1844
#method_before
FilteredRepository create(Project.NameKey name) throws NoSuchProjectException, IOException, PermissionBackendException {
    ProjectState projectState = projectCache.checkedGet(name);
    try {
        if (!projectState.getProject().getState().permitsRead()) {
            throw new NoSuchProjectException(name);
        }
    } catch (Exception e) {
        throw new NoSuchProjectException(name);
    }
    return new FilteredRepository(projectState, userProvider.get(), repoManager.openRepository(name), visibleRefFilterFactory, permissionBackend);
}
#method_after
FilteredRepository create(Project.NameKey name) throws NoSuchProjectException, IOException, PermissionBackendException {
    ProjectState projectState = projectCache.checkedGet(name);
    if (projectState == null || !projectState.getProject().getState().permitsRead()) {
        throw new NoSuchProjectException(name);
    }
    return new FilteredRepository(projectState, userProvider.get(), repoManager.openRepository(name), visibleRefFilterFactory, permissionBackend);
}
#end_block

#method_before
private Config getGlobalConfig() throws IOException, ConfigInvalidException {
    File sitePath = new File(".").getAbsoluteFile();
    if (".".equals(sitePath.getName())) {
        sitePath = sitePath.getParentFile();
    }
    FileBasedConfig cfg = new FileBasedConfig(new File(sitePath, "etc/gitiles.config"), FS.DETECTED);
    if (cfg.getFile().exists()) {
        cfg.load();
    }
    return cfg;
}
#method_after
private Config getGlobalConfig() throws IOException {
    File cfgFile = site.etc_dir.resolve("gitiles.config").toFile();
    FileBasedConfig cfg = new FileBasedConfig(cfgFile, FS.DETECTED);
    try {
        if (cfg.getFile().exists()) {
            cfg.load();
        }
    } catch (ConfigInvalidException e) {
        throw new IOException(e);
    }
    return cfg;
}
#end_block

#method_before
@Override
public Config getConfig() throws IOException {
    // Try to get a gitiles.config file from the refs/meta/config branch
    // of the project. For non-project access, use All-Projects as project.
    // If none of the above exists, use global gitiles.config.
    Project.NameKey nameKey = Resolver.getNameKey(req);
    ProjectState state = projectCache.get(nameKey);
    if (state != null) {
        Config cfg = state.getConfig("gitiles.config").getWithInheritance();
        if (cfg != null && cfg.getSections().size() > 0) {
            return cfg;
        }
    } else {
        state = projectCache.getAllProjects();
        Config cfg = state.getConfig("gitiles.config").get();
        if (cfg != null && cfg.getSections().size() > 0) {
            return cfg;
        }
    }
    try {
        return getGlobalConfig();
    } catch (Exception e) {
    }
    return new Config();
}
#method_after
@Override
public Config getConfig() throws IOException {
    // Try to get a gitiles.config file from the refs/meta/config branch
    // of the project. For non-project access, use All-Projects as project.
    // If none of the above exists, use global gitiles.config.
    Project.NameKey nameKey = Resolver.getNameKey(req);
    ProjectState state = projectCache.get(nameKey);
    if (state != null) {
        Config cfg = state.getConfig("gitiles.config").getWithInheritance();
        if (cfg != null && cfg.getSections().size() > 0) {
            return cfg;
        }
    } else {
        state = projectCache.getAllProjects();
        Config cfg = state.getConfig("gitiles.config").get();
        if (cfg != null && cfg.getSections().size() > 0) {
            return cfg;
        }
    }
    return getGlobalConfig();
}
#end_block

#method_before
private void validate(RepoContext ctx) throws AuthException, ResourceConflictException, IOException, PermissionBackendException {
    if (checkAddPatchSetPermission) {
        permissionBackend.user(ctx.getUser()).database(ctx.getDb()).change(origNotes).check(ChangePermission.ADD_PATCH_SET);
    }
    if (!validate) {
        return;
    }
    PermissionBackend.ForRef perm = permissionBackend.user(ctx.getUser()).ref(origNotes.getChange().getDest());
    String refName = getPatchSetId().toRefName();
    try (CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commitId, refName.substring(0, refName.lastIndexOf('/') + 1) + "new"), projectCache.checkedGet(origNotes.getProjectName()).getProject(), origNotes.getChange().getDest().get(), ctx.getRevWalk().getObjectReader(), commitId, ctx.getIdentifiedUser())) {
        commitValidatorsFactory.forGerritCommits(perm, origNotes.getChange().getDest(), ctx.getIdentifiedUser(), new NoSshInfo(), ctx.getRevWalk(), origNotes.getChange()).validate(event);
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    }
}
#method_after
private void validate(RepoContext ctx) throws AuthException, ResourceConflictException, IOException, PermissionBackendException {
    if (checkAddPatchSetPermission) {
        permissionBackend.user(ctx.getUser()).database(ctx.getDb()).change(origNotes).check(ChangePermission.ADD_PATCH_SET);
    }
    projectCache.checkedGet(ctx.getProject()).checkStatePermitsWrite();
    if (!validate) {
        return;
    }
    PermissionBackend.ForRef perm = permissionBackend.user(ctx.getUser()).ref(origNotes.getChange().getDest());
    String refName = getPatchSetId().toRefName();
    try (CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commitId, refName.substring(0, refName.lastIndexOf('/') + 1) + "new"), projectCache.checkedGet(origNotes.getProjectName()).getProject(), origNotes.getChange().getDest().get(), ctx.getRevWalk().getObjectReader(), commitId, ctx.getIdentifiedUser())) {
        commitValidatorsFactory.forGerritCommits(perm, origNotes.getChange().getDest(), ctx.getIdentifiedUser(), new NoSshInfo(), ctx.getRevWalk(), origNotes.getChange()).validate(event);
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    }
}
#end_block

#method_before
private void parseCreate(ReceiveCommand cmd) throws PermissionBackendException, NoSuchProjectException, IOException {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    Branch.NameKey branch = new Branch.NameKey(project.getName(), cmd.getRefName());
    try {
        // Must pass explicit user instead of injecting a provider into CreateRefControl, since
        // Provider<CurrentUser> within ReceiveCommits will always return anonymous.
        createRefControl.checkCreateRef(Providers.of(user), rp.getRepository(), branch, obj);
    } catch (AuthException denied) {
        reject(cmd, "prohibited by Gerrit: " + denied.getMessage());
        return;
    }
    if (!validRefOperation(cmd)) {
        // validRefOperation sets messages, so no need to provide more feedback.
        return;
    }
    validateNewCommits(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), cmd);
    actualCommands.add(cmd);
}
#method_after
private void parseCreate(ReceiveCommand cmd) throws PermissionBackendException, NoSuchProjectException, IOException {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    Branch.NameKey branch = new Branch.NameKey(project.getName(), cmd.getRefName());
    try {
        // Must pass explicit user instead of injecting a provider into CreateRefControl, since
        // Provider<CurrentUser> within ReceiveCommits will always return anonymous.
        createRefControl.checkCreateRef(Providers.of(user), rp.getRepository(), branch, obj);
    } catch (AuthException | ResourceConflictException denied) {
        reject(cmd, "prohibited by Gerrit: " + denied.getMessage());
        return;
    }
    if (!validRefOperation(cmd)) {
        // validRefOperation sets messages, so no need to provide more feedback.
        return;
    }
    validateNewCommits(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), cmd);
    actualCommands.add(cmd);
}
#end_block

#method_before
private void parseUpdate(ReceiveCommand cmd) throws PermissionBackendException {
    logDebug("Updating {}", cmd);
    boolean ok;
    try {
        permissions.ref(cmd.getRefName()).check(RefPermission.UPDATE);
        ok = true;
    } catch (AuthException err) {
        ok = false;
    }
    if (ok) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), cmd);
        actualCommands.add(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(cmd.getRefName())) {
            errors.put(ReceiveError.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(ReceiveError.UPDATE, cmd.getRefName());
        }
        reject(cmd, "prohibited by Gerrit: ref update access denied");
    }
}
#method_after
private void parseUpdate(ReceiveCommand cmd) throws PermissionBackendException {
    logDebug("Updating {}", cmd);
    boolean ok;
    try {
        permissions.ref(cmd.getRefName()).check(RefPermission.UPDATE);
        ok = true;
    } catch (AuthException err) {
        ok = false;
    }
    if (!projectState.statePermitsWrite()) {
        reject(cmd, "prohibited by Gerrit: project state does not permit write");
    }
    if (ok) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), cmd);
        actualCommands.add(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(cmd.getRefName())) {
            errors.put(ReceiveError.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(ReceiveError.UPDATE, cmd.getRefName());
        }
        reject(cmd, "prohibited by Gerrit: ref update access denied");
    }
}
#end_block

#method_before
private boolean canDelete(ReceiveCommand cmd) throws PermissionBackendException {
    try {
        permissions.ref(cmd.getRefName()).check(RefPermission.DELETE);
        return true;
    } catch (AuthException e) {
        return false;
    }
}
#method_after
private boolean canDelete(ReceiveCommand cmd) throws PermissionBackendException {
    try {
        permissions.ref(cmd.getRefName()).check(RefPermission.DELETE);
        return projectState.statePermitsWrite();
    } catch (AuthException e) {
        return false;
    }
}
#end_block

#method_before
private void parseRewind(ReceiveCommand cmd) throws PermissionBackendException {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Rewinding {}", cmd);
    if (newObject != null) {
        validateNewCommits(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    boolean ok;
    try {
        permissions.ref(cmd.getRefName()).check(RefPermission.FORCE_UPDATE);
        ok = true;
    } catch (AuthException err) {
        ok = false;
    }
    if (ok) {
        if (!validRefOperation(cmd)) {
            return;
        }
        actualCommands.add(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(ReceiveCommand cmd) throws PermissionBackendException {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Rewinding {}", cmd);
    if (newObject != null) {
        validateNewCommits(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    boolean ok;
    try {
        permissions.ref(cmd.getRefName()).check(RefPermission.FORCE_UPDATE);
        ok = true;
    } catch (AuthException err) {
        ok = false;
    }
    if (ok) {
        if (!validRefOperation(cmd)) {
            return;
        }
        if (!projectState.statePermitsWrite()) {
            cmd.setResult(REJECTED_NONFASTFORWARD, " project state does not permit write.");
        }
        actualCommands.add(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseMagicBranch(ReceiveCommand cmd) throws PermissionBackendException {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(user, cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(extraReviewers.get(ReviewerStateInternal.REVIEWER));
    magicBranch.cc.addAll(extraReviewers.get(ReviewerStateInternal.CC));
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (magicBranch.topic != null && magicBranch.topic.length() > ChangeUtil.TOPIC_MAX_LENGTH) {
        reject(cmd, String.format("topic length exceeds the limit (%s)", ChangeUtil.TOPIC_MAX_LENGTH));
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectState.isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo)) && !ref.equals(RefNames.REFS_CONFIG)) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.perm = permissions.ref(ref);
    if (!projectState.getProject().getState().permitsWrite()) {
        reject(cmd, "project state does not permit write");
        return;
    }
    try {
        magicBranch.perm.check(RefPermission.CREATE_CHANGE);
    } catch (AuthException denied) {
        errors.put(ReceiveError.CODE_REVIEW, ref);
        reject(cmd, denied.getMessage());
        return;
    }
    if (magicBranch.isPrivate && magicBranch.removePrivate) {
        reject(cmd, "the options 'private' and 'remove-private' are mutually exclusive");
        return;
    }
    if (magicBranch.workInProgress && magicBranch.ready) {
        reject(cmd, "the options 'wip' and 'ready' are mutually exclusive");
        return;
    }
    if (magicBranch.publishComments && magicBranch.noPublishComments) {
        reject(cmd, "the options 'publish-comments' and 'no-publish-comments' are mutually exclusive");
        return;
    }
    if (magicBranch.submit) {
        try {
            permissions.ref(ref).check(RefPermission.UPDATE_BY_SUBMIT);
        } catch (AuthException e) {
            reject(cmd, e.getMessage());
            return;
        }
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    String destBranch = magicBranch.dest.get();
    try {
        if (magicBranch.merged) {
            if (magicBranch.base != null) {
                reject(cmd, "cannot use merged with base");
                return;
            }
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            if (!walk.isMergedInto(tip, branchTip)) {
                reject(cmd, "not merged into branch");
                return;
            }
        }
        // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
        if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
            logDebug("Forcing newChangeForAllNotInTarget = false");
            newChangeForAllNotInTarget = false;
        }
        if (magicBranch.base != null) {
            logDebug("Handling %base: {}", magicBranch.base);
            magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
            for (ObjectId id : magicBranch.base) {
                try {
                    magicBranch.baseCommit.add(walk.parseCommit(id));
                } catch (IncorrectObjectTypeException notCommit) {
                    reject(cmd, "base must be a commit");
                    return;
                } catch (MissingObjectException e) {
                    reject(cmd, "base not found");
                    return;
                } catch (IOException e) {
                    logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                    reject(cmd, "internal server error");
                    return;
                }
            }
        } else if (newChangeForAllNotInTarget) {
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            magicBranch.baseCommit = Collections.singletonList(branchTip);
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        }
    } catch (IOException ex) {
        logWarn(String.format("Error walking to %s in project %s", destBranch, project.getName()), ex);
        reject(cmd, "internal server error");
        return;
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.dest.get());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) throws PermissionBackendException {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(user, cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(extraReviewers.get(ReviewerStateInternal.REVIEWER));
    magicBranch.cc.addAll(extraReviewers.get(ReviewerStateInternal.CC));
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (magicBranch.topic != null && magicBranch.topic.length() > ChangeUtil.TOPIC_MAX_LENGTH) {
        reject(cmd, String.format("topic length exceeds the limit (%s)", ChangeUtil.TOPIC_MAX_LENGTH));
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectState.isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo)) && !ref.equals(RefNames.REFS_CONFIG)) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.perm = permissions.ref(ref);
    if (!projectState.getProject().getState().permitsWrite()) {
        reject(cmd, "project state does not permit write");
        return;
    }
    try {
        magicBranch.perm.check(RefPermission.CREATE_CHANGE);
    } catch (AuthException denied) {
        errors.put(ReceiveError.CODE_REVIEW, ref);
        reject(cmd, denied.getMessage());
        return;
    }
    if (magicBranch.isPrivate && magicBranch.removePrivate) {
        reject(cmd, "the options 'private' and 'remove-private' are mutually exclusive");
        return;
    }
    boolean privateByDefault = projectCache.get(project.getNameKey()).is(BooleanProjectConfig.PRIVATE_BY_DEFAULT);
    setChangeAsPrivate = magicBranch.draft || magicBranch.isPrivate || (privateByDefault && !magicBranch.removePrivate);
    if (receiveConfig.disablePrivateChanges && setChangeAsPrivate) {
        reject(cmd, "private changes are disabled");
        return;
    }
    if (magicBranch.workInProgress && magicBranch.ready) {
        reject(cmd, "the options 'wip' and 'ready' are mutually exclusive");
        return;
    }
    if (magicBranch.publishComments && magicBranch.noPublishComments) {
        reject(cmd, "the options 'publish-comments' and 'no-publish-comments' are mutually exclusive");
        return;
    }
    if (magicBranch.submit) {
        try {
            permissions.ref(ref).check(RefPermission.UPDATE_BY_SUBMIT);
        } catch (AuthException e) {
            reject(cmd, e.getMessage());
            return;
        }
        if (!projectState.statePermitsWrite()) {
            reject(cmd, "project state does not permit write");
            return;
        }
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    String destBranch = magicBranch.dest.get();
    try {
        if (magicBranch.merged) {
            if (magicBranch.base != null) {
                reject(cmd, "cannot use merged with base");
                return;
            }
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            if (!walk.isMergedInto(tip, branchTip)) {
                reject(cmd, "not merged into branch");
                return;
            }
        }
        // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
        if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
            logDebug("Forcing newChangeForAllNotInTarget = false");
            newChangeForAllNotInTarget = false;
        }
        if (magicBranch.base != null) {
            logDebug("Handling %base: {}", magicBranch.base);
            magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
            for (ObjectId id : magicBranch.base) {
                try {
                    magicBranch.baseCommit.add(walk.parseCommit(id));
                } catch (IncorrectObjectTypeException notCommit) {
                    reject(cmd, "base must be a commit");
                    return;
                } catch (MissingObjectException e) {
                    reject(cmd, "base not found");
                    return;
                } catch (IOException e) {
                    logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                    reject(cmd, "internal server error");
                    return;
                }
            }
        } else if (newChangeForAllNotInTarget) {
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            magicBranch.baseCommit = Collections.singletonList(branchTip);
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        }
    } catch (IOException ex) {
        logWarn(String.format("Error walking to %s in project %s", destBranch, project.getName()), ex);
        reject(cmd, "internal server error");
        return;
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.dest.get());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void setChangeId(int id) {
    boolean privateByDefault = projectCache.get(project.getNameKey()).is(BooleanProjectConfig.PRIVATE_BY_DEFAULT);
    changeId = new Change.Id(id);
    ins = changeInserterFactory.create(changeId, commit, refName).setTopic(magicBranch.topic).setPrivate(magicBranch.draft || magicBranch.isPrivate || (privateByDefault && !magicBranch.removePrivate)).setWorkInProgress(magicBranch.workInProgress).setValidate(false);
    if (magicBranch.merged) {
        ins.setStatus(Change.Status.MERGED);
    }
    cmd = new ReceiveCommand(ObjectId.zeroId(), commit, ins.getPatchSetId().toRefName());
    if (rp.getPushCertificate() != null) {
        ins.setPushCertificate(rp.getPushCertificate().toTextWithSignature());
    }
}
#method_after
private void setChangeId(int id) {
    changeId = new Change.Id(id);
    ins = changeInserterFactory.create(changeId, commit, refName).setTopic(magicBranch.topic).setPrivate(setChangeAsPrivate).setWorkInProgress(magicBranch.workInProgress).setValidate(false);
    if (magicBranch.merged) {
        ins.setStatus(Change.Status.MERGED);
    }
    cmd = new ReceiveCommand(ObjectId.zeroId(), commit, ins.getPatchSetId().toRefName());
    if (rp.getPushCertificate() != null) {
        ins.setPushCertificate(rp.getPushCertificate().toTextWithSignature());
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException, PermissionBackendException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (notes == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    Change change = notes.getChange();
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    try {
        permissions.change(notes).database(db).check(ChangePermission.ADD_PATCH_SET);
    } catch (AuthException no) {
        reject(inputCommand, "cannot add patch set to " + ontoChange + ".");
        return false;
    }
    if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    PermissionBackend.ForRef perm = permissions.ref(change.getDest().get());
    if (!validCommit(rp.getRevWalk(), perm, change.getDest(), inputCommand, newCommit, change)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && (magicBranch.workInProgress || magicBranch.ready) && magicBranch.workInProgress != change.isWorkInProgress() && !user.getAccountId().equals(change.getOwner())) {
        reject(inputCommand, ONLY_OWNER_CAN_MODIFY_WIP);
        return false;
    }
    if (magicBranch != null && (magicBranch.edit || magicBranch.draft)) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException, PermissionBackendException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (notes == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    Change change = notes.getChange();
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    try {
        permissions.change(notes).database(db).check(ChangePermission.ADD_PATCH_SET);
    } catch (AuthException no) {
        reject(inputCommand, "cannot add patch set to " + ontoChange + ".");
        return false;
    }
    if (!projectState.statePermitsWrite()) {
        reject(inputCommand, "cannot add patch set to " + ontoChange + ".");
        return false;
    }
    if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    PermissionBackend.ForRef perm = permissions.ref(change.getDest().get());
    if (!validCommit(rp.getRevWalk(), perm, change.getDest(), inputCommand, newCommit, change)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && (magicBranch.workInProgress || magicBranch.ready) && magicBranch.workInProgress != change.isWorkInProgress() && !user.getAccountId().equals(change.getOwner())) {
        reject(inputCommand, ONLY_OWNER_CAN_MODIFY_WIP);
        return false;
    }
    if (magicBranch != null && (magicBranch.edit || magicBranch.draft)) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
private boolean validCommit(RevWalk rw, PermissionBackend.ForRef perm, Branch.NameKey branch, ReceiveCommand cmd, ObjectId id, @Nullable Change change) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    try (CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, branch.get(), rw.getObjectReader(), c, user)) {
        boolean isMerged = magicBranch != null && cmd.getRefName().equals(magicBranch.cmd.getRefName()) && magicBranch.merged;
        CommitValidators validators = isMerged ? commitValidatorsFactory.forMergedCommits(perm, user.asIdentifiedUser()) : commitValidatorsFactory.forReceiveCommits(perm, branch, user.asIdentifiedUser(), sshInfo, repo, rw, change);
        messages.addAll(validators.validate(receiveEvent));
    } catch (CommitValidationException e) {
        logDebug("Commit validation failed on {}", c.name());
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#method_after
private boolean validCommit(RevWalk rw, PermissionBackend.ForRef perm, Branch.NameKey branch, ReceiveCommand cmd, ObjectId id, @Nullable Change change) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    try (CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, branch.get(), rw.getObjectReader(), c, user)) {
        boolean isMerged = magicBranch != null && cmd.getRefName().equals(magicBranch.cmd.getRefName()) && magicBranch.merged;
        CommitValidators validators = isMerged ? commitValidatorsFactory.forMergedCommits(project.getNameKey(), perm, user.asIdentifiedUser()) : commitValidatorsFactory.forReceiveCommits(perm, branch, user.asIdentifiedUser(), sshInfo, repo, rw, change);
        messages.addAll(validators.validate(receiveEvent));
    } catch (CommitValidationException e) {
        logDebug("Commit validation failed on {}", c.name());
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#end_block

#method_before
private void autoCloseChanges(ReceiveCommand cmd) {
    logDebug("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    // insertChangesAndPatchSets.
    try {
        retryHelper.execute(updateFactory -> {
            try (BatchUpdate bu = updateFactory.create(db, projectState.getNameKey(), user, TimeUtil.nowTs());
                ObjectInserter ins = repo.newObjectInserter();
                ObjectReader reader = ins.newReader();
                RevWalk rw = new RevWalk(reader)) {
                bu.setRepository(repo, rw, ins).updateChangesInParallel();
                bu.setRequestId(receiveId);
                // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
                RevCommit newTip = rw.parseCommit(cmd.getNewId());
                Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
                rw.reset();
                rw.markStart(newTip);
                if (!ObjectId.zeroId().equals(cmd.getOldId())) {
                    rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
                }
                ListMultimap<ObjectId, Ref> byCommit = changeRefsById();
                Map<Change.Key, ChangeNotes> byKey = null;
                List<ReplaceRequest> replaceAndClose = new ArrayList<>();
                int existingPatchSets = 0;
                int newPatchSets = 0;
                COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
                    rw.parseBody(c);
                    for (Ref ref : byCommit.get(c.copy())) {
                        PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                        Optional<ChangeData> cd = byLegacyId(psId.getParentKey());
                        if (cd.isPresent() && cd.get().change().getDest().equals(branch)) {
                            existingPatchSets++;
                            bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                            continue COMMIT;
                        }
                    }
                    for (String changeId : c.getFooterLines(CHANGE_ID)) {
                        if (byKey == null) {
                            byKey = openChangesByKeyByBranch(branch);
                        }
                        ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                        if (onto != null) {
                            newPatchSets++;
                            // Hold onto this until we're done with the walk, as the call to
                            // req.validate below calls isMergedInto which resets the walk.
                            ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                            req.notes = onto;
                            replaceAndClose.add(req);
                            continue COMMIT;
                        }
                    }
                }
                for (ReplaceRequest req : replaceAndClose) {
                    Change.Id id = req.notes.getChangeId();
                    if (!req.validate(true)) {
                        logDebug("Not closing {} because validation failed", id);
                        continue;
                    }
                    req.addOps(bu, null);
                    bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                        @Override
                        public PatchSet get() {
                            return req.replaceOp.getPatchSet();
                        }
                    }));
                    bu.addOp(id, new ChangeProgressOp(closeProgress));
                }
                logDebug("Auto-closing {} changes with existing patch sets and {} with new patch sets", existingPatchSets, newPatchSets);
                bu.execute();
            } catch (IOException | OrmException | PermissionBackendException e) {
                logError("Failed to auto-close changes", e);
            }
            return null;
        });
    } catch (RestApiException e) {
        logError("Can't insert patchset", e);
    } catch (UpdateException e) {
        logError("Failed to auto-close changes", e);
    }
}
#method_after
private void autoCloseChanges(ReceiveCommand cmd) {
    logDebug("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    // insertChangesAndPatchSets.
    try {
        retryHelper.execute(updateFactory -> {
            try (BatchUpdate bu = updateFactory.create(db, projectState.getNameKey(), user, TimeUtil.nowTs());
                ObjectInserter ins = repo.newObjectInserter();
                ObjectReader reader = ins.newReader();
                RevWalk rw = new RevWalk(reader)) {
                bu.setRepository(repo, rw, ins).updateChangesInParallel();
                bu.setRequestId(receiveId);
                // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
                RevCommit newTip = rw.parseCommit(cmd.getNewId());
                Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
                rw.reset();
                rw.markStart(newTip);
                if (!ObjectId.zeroId().equals(cmd.getOldId())) {
                    rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
                }
                ListMultimap<ObjectId, Ref> byCommit = changeRefsById();
                Map<Change.Key, ChangeNotes> byKey = null;
                List<ReplaceRequest> replaceAndClose = new ArrayList<>();
                int existingPatchSets = 0;
                int newPatchSets = 0;
                COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
                    rw.parseBody(c);
                    for (Ref ref : byCommit.get(c.copy())) {
                        PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                        Optional<ChangeData> cd = retryHelper.execute(ActionType.CHANGE_QUERY, () -> byLegacyId(psId.getParentKey()), t -> t instanceof OrmException);
                        if (cd.isPresent() && cd.get().change().getDest().equals(branch)) {
                            existingPatchSets++;
                            bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                            continue COMMIT;
                        }
                    }
                    for (String changeId : c.getFooterLines(CHANGE_ID)) {
                        if (byKey == null) {
                            byKey = retryHelper.execute(ActionType.CHANGE_QUERY, () -> openChangesByKeyByBranch(branch), t -> t instanceof OrmException);
                        }
                        ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                        if (onto != null) {
                            newPatchSets++;
                            // Hold onto this until we're done with the walk, as the call to
                            // req.validate below calls isMergedInto which resets the walk.
                            ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                            req.notes = onto;
                            replaceAndClose.add(req);
                            continue COMMIT;
                        }
                    }
                }
                for (ReplaceRequest req : replaceAndClose) {
                    Change.Id id = req.notes.getChangeId();
                    if (!req.validate(true)) {
                        logDebug("Not closing {} because validation failed", id);
                        continue;
                    }
                    req.addOps(bu, null);
                    bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                        @Override
                        public PatchSet get() {
                            return req.replaceOp.getPatchSet();
                        }
                    }));
                    bu.addOp(id, new ChangeProgressOp(closeProgress));
                }
                logDebug("Auto-closing {} changes with existing patch sets and {} with new patch sets", existingPatchSets, newPatchSets);
                bu.execute();
            } catch (IOException | OrmException | PermissionBackendException e) {
                logError("Failed to auto-close changes", e);
            }
            return null;
        }, // eat up the whole timeout so that no time is left to retry this outer action.
        RetryHelper.options().timeout(retryHelper.getDefaultTimeout().multipliedBy(5)).build());
    } catch (RestApiException e) {
        logError("Can't insert patchset", e);
    } catch (UpdateException e) {
        logError("Failed to auto-close changes", e);
    }
}
#end_block

#method_before
public CommitValidators forReceiveCommits(PermissionBackend.ForRef perm, Branch.NameKey branch, IdentifiedUser user, SshInfo sshInfo, Repository repo, RevWalk rw, @Nullable Change change) throws IOException {
    NoteMap rejectCommits = BanCommit.loadRejectCommitsMap(repo, rw);
    ProjectState projectState = projectCache.checkedGet(branch.getParentKey());
    return new CommitValidators(ImmutableList.of(new UploadMergesPermissionValidator(perm), new AmendedGerritMergeCommitValidationListener(perm, gerritIdent), new AuthorUploaderValidator(user, perm, canonicalWebUrl), new CommitterUploaderValidator(user, perm, canonicalWebUrl), new SignedOffByValidator(user, perm, projectState), new ChangeIdValidator(projectState, user, canonicalWebUrl, installCommitMsgHookCommand, sshInfo, change), new ConfigValidator(branch, user, rw, allUsers, allProjects), new BannedCommitsValidator(rejectCommits), new PluginCommitValidationListener(pluginValidators), new ExternalIdUpdateListener(allUsers, externalIdsConsistencyChecker), new AccountCommitValidator(allUsers, accountValidator), new GroupCommitValidator(allUsers)));
}
#method_after
public CommitValidators forReceiveCommits(PermissionBackend.ForRef perm, Branch.NameKey branch, IdentifiedUser user, SshInfo sshInfo, Repository repo, RevWalk rw, @Nullable Change change) throws IOException {
    NoteMap rejectCommits = BanCommit.loadRejectCommitsMap(repo, rw);
    ProjectState projectState = projectCache.checkedGet(branch.getParentKey());
    return new CommitValidators(ImmutableList.of(new UploadMergesPermissionValidator(perm), new ProjectStateValidationListener(projectState), new AmendedGerritMergeCommitValidationListener(perm, gerritIdent), new AuthorUploaderValidator(user, perm, canonicalWebUrl), new CommitterUploaderValidator(user, perm, canonicalWebUrl), new SignedOffByValidator(user, perm, projectState), new ChangeIdValidator(projectState, user, canonicalWebUrl, installCommitMsgHookCommand, sshInfo, change), new ConfigValidator(branch, user, rw, allUsers, allProjects), new BannedCommitsValidator(rejectCommits), new PluginCommitValidationListener(pluginValidators), new ExternalIdUpdateListener(allUsers, externalIdsConsistencyChecker), new AccountCommitValidator(repoManager, allUsers, accountValidator), new GroupCommitValidator(allUsers)));
}
#end_block

#method_before
public CommitValidators forGerritCommits(ForRef perm, NameKey branch, IdentifiedUser user, SshInfo sshInfo, RevWalk rw, @Nullable Change change) throws IOException {
    return new CommitValidators(ImmutableList.of(new UploadMergesPermissionValidator(perm), new AmendedGerritMergeCommitValidationListener(perm, gerritIdent), new AuthorUploaderValidator(user, perm, canonicalWebUrl), new SignedOffByValidator(user, perm, projectCache.checkedGet(branch.getParentKey())), new ChangeIdValidator(projectCache.checkedGet(branch.getParentKey()), user, canonicalWebUrl, installCommitMsgHookCommand, sshInfo, change), new ConfigValidator(branch, user, rw, allUsers, allProjects), new PluginCommitValidationListener(pluginValidators), new ExternalIdUpdateListener(allUsers, externalIdsConsistencyChecker), new AccountCommitValidator(allUsers, accountValidator), new GroupCommitValidator(allUsers)));
}
#method_after
public CommitValidators forGerritCommits(ForRef perm, NameKey branch, IdentifiedUser user, SshInfo sshInfo, RevWalk rw, @Nullable Change change) throws IOException {
    ProjectState projectState = projectCache.checkedGet(branch.getParentKey());
    return new CommitValidators(ImmutableList.of(new UploadMergesPermissionValidator(perm), new ProjectStateValidationListener(projectState), new AmendedGerritMergeCommitValidationListener(perm, gerritIdent), new AuthorUploaderValidator(user, perm, canonicalWebUrl), new SignedOffByValidator(user, perm, projectCache.checkedGet(branch.getParentKey())), new ChangeIdValidator(projectState, user, canonicalWebUrl, installCommitMsgHookCommand, sshInfo, change), new ConfigValidator(branch, user, rw, allUsers, allProjects), new PluginCommitValidationListener(pluginValidators), new ExternalIdUpdateListener(allUsers, externalIdsConsistencyChecker), new AccountCommitValidator(repoManager, allUsers, accountValidator), new GroupCommitValidator(allUsers)));
}
#end_block

#method_before
public CommitValidators forMergedCommits(PermissionBackend.ForRef perm, IdentifiedUser user) {
    // formats, so we play it safe and exclude them.
    return new CommitValidators(ImmutableList.of(new UploadMergesPermissionValidator(perm), new AuthorUploaderValidator(user, perm, canonicalWebUrl), new CommitterUploaderValidator(user, perm, canonicalWebUrl)));
}
#method_after
public CommitValidators forMergedCommits(Project.NameKey project, PermissionBackend.ForRef perm, IdentifiedUser user) throws IOException {
    // formats, so we play it safe and exclude them.
    return new CommitValidators(ImmutableList.of(new UploadMergesPermissionValidator(perm), new ProjectStateValidationListener(projectCache.checkedGet(project)), new AuthorUploaderValidator(user, perm, canonicalWebUrl), new CommitterUploaderValidator(user, perm, canonicalWebUrl)));
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    if (!shouldValidateChangeId(receiveEvent)) {
        return Collections.emptyList();
    }
    RevCommit commit = receiveEvent.commit;
    List<CommitValidationMessage> messages = new ArrayList<>();
    List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    String sha1 = commit.abbreviate(RevId.ABBREV_LEN).name();
    if (idList.isEmpty()) {
        if (projectState.is(BooleanProjectConfig.REQUIRE_CHANGE_ID)) {
            String shortMsg = commit.getShortMessage();
            if (shortMsg.startsWith(CHANGE_ID_PREFIX) && CHANGE_ID.matcher(shortMsg.substring(CHANGE_ID_PREFIX.length()).trim()).matches()) {
                String errMsg = String.format(MISSING_SUBJECT_MSG, sha1);
                throw new CommitValidationException(errMsg);
            }
            String errMsg = String.format(MISSING_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, commit));
            throw new CommitValidationException(errMsg, messages);
        }
    } else if (idList.size() > 1) {
        String errMsg = String.format(MULTIPLE_CHANGE_ID_MSG, sha1);
        throw new CommitValidationException(errMsg, messages);
    } else {
        String v = idList.get(idList.size() - 1).trim();
        // Egit (I0000000000000000000000000000000000000000).
        if (!CHANGE_ID.matcher(v).matches() || v.matches("^I00*$")) {
            String errMsg = String.format(INVALID_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, receiveEvent.commit));
            throw new CommitValidationException(errMsg, messages);
        }
    }
    if (change != null && !idList.get(0).equals(change.getKey().get())) {
        String errMsg = String.format(CHANGE_ID_MIS_MATCH_MSG, sha1);
        throw new CommitValidationException(errMsg);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    if (!shouldValidateChangeId(receiveEvent)) {
        return Collections.emptyList();
    }
    RevCommit commit = receiveEvent.commit;
    List<CommitValidationMessage> messages = new ArrayList<>();
    List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    String sha1 = commit.abbreviate(RevId.ABBREV_LEN).name();
    if (idList.isEmpty()) {
        if (projectState.is(BooleanProjectConfig.REQUIRE_CHANGE_ID)) {
            String shortMsg = commit.getShortMessage();
            if (shortMsg.startsWith(CHANGE_ID_PREFIX) && CHANGE_ID.matcher(shortMsg.substring(CHANGE_ID_PREFIX.length()).trim()).matches()) {
                String errMsg = String.format(MISSING_SUBJECT_MSG, sha1);
                throw new CommitValidationException(errMsg);
            }
            String errMsg = String.format(MISSING_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, commit));
            throw new CommitValidationException(errMsg, messages);
        }
    } else if (idList.size() > 1) {
        String errMsg = String.format(MULTIPLE_CHANGE_ID_MSG, sha1);
        throw new CommitValidationException(errMsg, messages);
    } else {
        String v = idList.get(idList.size() - 1).trim();
        // Egit (I0000000000000000000000000000000000000000).
        if (!CHANGE_ID.matcher(v).matches() || v.matches("^I00*$")) {
            String errMsg = String.format(INVALID_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, receiveEvent.commit));
            throw new CommitValidationException(errMsg, messages);
        }
        if (change != null && !v.equals(change.getKey().get())) {
            String errMsg = String.format(CHANGE_ID_MISMATCH_MSG, sha1);
            throw new CommitValidationException(errMsg);
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    if (REFS_CONFIG.equals(branch.get())) {
        List<CommitValidationMessage> messages = new ArrayList<>();
        try {
            ProjectConfig cfg = new ProjectConfig(receiveEvent.project.getNameKey());
            cfg.load(rw, receiveEvent.command.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:", messages);
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage(), messages);
                }
                throw new ConfigInvalidException("invalid project configuration");
            }
            if (allUsers.equals(receiveEvent.project.getNameKey()) && !allProjects.equals(cfg.getProject().getParent(allProjects))) {
                addError("Invalid project configuration:", messages);
                addError(String.format("  %s must inherit from %s", allUsers.get(), allProjects.get()), messages);
                throw new ConfigInvalidException("invalid project configuration");
            }
        } catch (ConfigInvalidException | IOException e) {
            log.error("User " + user.getUserName() + " tried to push an invalid project configuration " + receiveEvent.command.getNewId().name() + " for project " + receiveEvent.project, e);
            throw new CommitValidationException("invalid project configuration", messages);
        }
    }
    if (allUsers.equals(branch.getParentKey()) && RefNames.isRefsUsers(branch.get())) {
        List<CommitValidationMessage> messages = new ArrayList<>();
        Account.Id accountId = Account.Id.fromRef(branch.get());
        if (accountId != null) {
            try {
                WatchConfig wc = new WatchConfig(accountId);
                wc.load(rw, receiveEvent.command.getNewId());
                if (!wc.getValidationErrors().isEmpty()) {
                    addError("Invalid project configuration:", messages);
                    for (ValidationError err : wc.getValidationErrors()) {
                        addError("  " + err.getMessage(), messages);
                    }
                    throw new ConfigInvalidException("invalid watch configuration");
                }
            } catch (IOException | ConfigInvalidException e) {
                log.error("User " + user.getUserName() + " tried to push an invalid watch configuration " + receiveEvent.command.getNewId().name() + " for account " + accountId.get(), e);
                throw new CommitValidationException("invalid watch configuration", messages);
            }
        }
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    if (REFS_CONFIG.equals(branch.get())) {
        List<CommitValidationMessage> messages = new ArrayList<>();
        try {
            ProjectConfig cfg = new ProjectConfig(receiveEvent.project.getNameKey());
            cfg.load(rw, receiveEvent.command.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:", messages);
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage(), messages);
                }
                throw new ConfigInvalidException("invalid project configuration");
            }
            if (allUsers.equals(receiveEvent.project.getNameKey()) && !allProjects.equals(cfg.getProject().getParent(allProjects))) {
                addError("Invalid project configuration:", messages);
                addError(String.format("  %s must inherit from %s", allUsers.get(), allProjects.get()), messages);
                throw new ConfigInvalidException("invalid project configuration");
            }
        } catch (ConfigInvalidException | IOException e) {
            log.error("User " + user.getUserName() + " tried to push an invalid project configuration " + receiveEvent.command.getNewId().name() + " for project " + receiveEvent.project, e);
            throw new CommitValidationException("invalid project configuration", messages);
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    if (!allUsers.equals(receiveEvent.project.getNameKey())) {
        return Collections.emptyList();
    }
    if (receiveEvent.command.getRefName().startsWith(MagicBranch.NEW_CHANGE)) {
        // MergeValidators.AccountMergeValidator
        return Collections.emptyList();
    }
    Account.Id accountId = Account.Id.fromRef(receiveEvent.refName);
    if (accountId == null) {
        return Collections.emptyList();
    }
    try {
        List<String> errorMessages = accountValidator.validate(accountId, receiveEvent.revWalk, receiveEvent.command.getOldId(), receiveEvent.commit);
        if (!errorMessages.isEmpty()) {
            throw new CommitValidationException("invalid account configuration", errorMessages.stream().map(m -> new CommitValidationMessage(m, true)).collect(toList()));
        }
    } catch (IOException e) {
        String m = String.format("Validating update for account %s failed", accountId.get());
        log.error(m, e);
        throw new CommitValidationException(m, e);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    if (!allUsers.equals(receiveEvent.project.getNameKey())) {
        return Collections.emptyList();
    }
    if (receiveEvent.command.getRefName().startsWith(MagicBranch.NEW_CHANGE)) {
        // MergeValidators.AccountMergeValidator
        return Collections.emptyList();
    }
    Account.Id accountId = Account.Id.fromRef(receiveEvent.refName);
    if (accountId == null) {
        return Collections.emptyList();
    }
    try (Repository repo = repoManager.openRepository(allUsers)) {
        List<String> errorMessages = accountValidator.validate(accountId, repo, receiveEvent.revWalk, receiveEvent.command.getOldId(), receiveEvent.commit);
        if (!errorMessages.isEmpty()) {
            throw new CommitValidationException("invalid account configuration", errorMessages.stream().map(m -> new CommitValidationMessage(m, true)).collect(toList()));
        }
    } catch (IOException e) {
        String m = String.format("Validating update for account %s failed", accountId.get());
        log.error(m, e);
        throw new CommitValidationException(m, e);
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse rsp) {
    this.healthy = true;
}
#method_after
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse rsp) {
    this.healthy = true;
    rsp.setStatus(SC_NO_CONTENT);
}
#end_block

#method_before
@Override
protected void doDelete(HttpServletRequest req, HttpServletResponse rsp) {
    this.healthy = false;
}
#method_after
@Override
protected void doDelete(HttpServletRequest req, HttpServletResponse rsp) {
    this.healthy = false;
    rsp.setStatus(SC_NO_CONTENT);
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse rsp) {
    if (healthy) {
        rsp.setStatus(SC_OK);
    } else {
        try {
            rsp.sendError(SC_INTERNAL_SERVER_ERROR);
        } catch (IOException e) {
            LOG.error("Failed to send error response", e);
        }
    }
}
#method_after
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse rsp) {
    if (healthy) {
        rsp.setStatus(SC_NO_CONTENT);
    } else {
        try {
            rsp.sendError(SC_SERVICE_UNAVAILABLE);
        } catch (IOException e) {
            log.error("Failed to send error response", e);
        }
    }
}
#end_block

#method_before
public Collection<NotifyConfig> getNotifyConfigs() {
    return notify.values();
}
#method_after
public Collection<NotifyConfig> getNotifyConfigs() {
    return notifySections.values();
}
#end_block

#method_before
private void loadNotifySections(Config rc, Map<String, GroupReference> groupsByName) {
    notify = Maps.newHashMap();
    for (String sectionName : rc.getSubsections(NOTIFY)) {
        NotifyConfig n = new NotifyConfig();
        n.setFilter(rc.getString(NOTIFY, sectionName, KEY_FILTER));
        EnumSet<NotifyType> types = EnumSet.noneOf(NotifyType.class);
        types.addAll(ConfigUtil.getEnumList(rc, NOTIFY, sectionName, KEY_TYPE, NotifyType.ALL));
        n.setTypes(types);
        for (String dst : rc.getStringList(NOTIFY, sectionName, KEY_EMAIL)) {
            if (dst.startsWith("group ")) {
                String groupName = dst.substring(6).trim();
                GroupReference ref = groupsByName.get(groupName);
                if (ref == null) {
                    ref = new GroupReference(null, groupName);
                    groupsByName.put(ref.getName(), ref);
                }
                if (ref.getUUID() != null) {
                    n.addEmail(ref.getUUID());
                } else {
                    error(new ValidationError(PROJECT_CONFIG, "group \"" + ref.getName() + "\" not in " + GROUP_LIST));
                }
            } else if (dst.startsWith("user ")) {
                error(new ValidationError(PROJECT_CONFIG, dst + " not supported"));
            } else {
                try {
                    n.addEmail(Address.parse(dst));
                } catch (IllegalArgumentException err) {
                    error(new ValidationError(PROJECT_CONFIG, "notify section \"" + sectionName + "\" has invalid email \"" + dst + "\""));
                }
            }
        }
        notify.put(sectionName, n);
    }
}
#method_after
private void loadNotifySections(Config rc, Map<String, GroupReference> groupsByName) {
    notifySections = Maps.newHashMap();
    for (String sectionName : rc.getSubsections(NOTIFY)) {
        NotifyConfig n = new NotifyConfig();
        n.setName(sectionName);
        n.setFilter(rc.getString(NOTIFY, sectionName, KEY_FILTER));
        EnumSet<NotifyType> types = EnumSet.noneOf(NotifyType.class);
        types.addAll(ConfigUtil.getEnumList(rc, NOTIFY, sectionName, KEY_TYPE, NotifyType.ALL));
        n.setTypes(types);
        for (String dst : rc.getStringList(NOTIFY, sectionName, KEY_EMAIL)) {
            if (dst.startsWith("group ")) {
                String groupName = dst.substring(6).trim();
                GroupReference ref = groupsByName.get(groupName);
                if (ref == null) {
                    ref = new GroupReference(null, groupName);
                    groupsByName.put(ref.getName(), ref);
                }
                if (ref.getUUID() != null) {
                    n.addEmail(ref);
                } else {
                    error(new ValidationError(PROJECT_CONFIG, "group \"" + ref.getName() + "\" not in " + GROUP_LIST));
                }
            } else if (dst.startsWith("user ")) {
                error(new ValidationError(PROJECT_CONFIG, dst + " not supported"));
            } else {
                try {
                    n.addEmail(Address.parse(dst));
                } catch (IllegalArgumentException err) {
                    error(new ValidationError(PROJECT_CONFIG, "notify section \"" + sectionName + "\" has invalid email \"" + dst + "\""));
                }
            }
        }
        notifySections.put(sectionName, n);
    }
}
#end_block

#method_before
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    set(rc, PROJECT, null, KEY_STATE, p.getState(), null);
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    for (NotifyConfig n : notify.values()) {
        keepGroups.addAll(n.getGroups());
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#method_after
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    set(rc, PROJECT, null, KEY_STATE, p.getState(), null);
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#end_block

#method_before
public String getChangeDetail() {
    StringBuilder detail = new StringBuilder();
    if (patchSetInfo != null) {
        detail.append(patchSetInfo.getMessage().trim() + "\n");
    } else {
        detail.append(change.getSubject().trim() + "\n");
    }
    if (patchSet != null) {
        detail.append("---\n");
        PatchList patchList = getPatchList();
        for (PatchListEntry p : patchList.getPatches()) {
            if (Patch.COMMIT_MSG.equals(p.getNewName())) {
                continue;
            }
            detail.append(p.getChangeType().getCode() + " " + p.getNewName() + "\n");
        }
        detail.append(MessageFormat.format(// 
        "" + // 
        "{0,choice,0#0 files|1#1 file|1<{0} files} changed, " + // 
        "{1,choice,0#0 insertions|1#1 insertion|1<{1} insertions}(+), " + // 
        "{2,choice,0#0 deletions|1#1 deletion|1<{2} deletions}(-)" + // 
        "\n", // 
        patchList.getPatches().size() - 1, // 
        patchList.getInsertions(), patchList.getDeletions()));
        detail.append("\n");
    }
    return detail.toString();
}
#method_after
public String getChangeDetail() {
    try {
        StringBuilder detail = new StringBuilder();
        if (patchSetInfo != null) {
            detail.append(patchSetInfo.getMessage().trim() + "\n");
        } else {
            detail.append(change.getSubject().trim() + "\n");
        }
        if (patchSet != null) {
            detail.append("---\n");
            PatchList patchList = getPatchList();
            for (PatchListEntry p : patchList.getPatches()) {
                if (Patch.COMMIT_MSG.equals(p.getNewName())) {
                    continue;
                }
                detail.append(p.getChangeType().getCode() + " " + p.getNewName() + "\n");
            }
            detail.append(MessageFormat.format(// 
            "" + // 
            "{0,choice,0#0 files|1#1 file|1<{0} files} changed, " + // 
            "{1,choice,0#0 insertions|1#1 insertion|1<{1} insertions}(+), " + // 
            "{2,choice,0#0 deletions|1#1 deletion|1<{2} deletions}(-)" + // 
            "\n", // 
            patchList.getPatches().size() - 1, // 
            patchList.getInsertions(), patchList.getDeletions()));
            detail.append("\n");
        }
        return detail.toString();
    } catch (Exception err) {
        log.warn("Cannot format change detail", err);
        return "";
    }
}
#end_block

#method_before
protected void bccStarredBy() {
    try {
        // 
        for (StarredChange w : args.db.get().starredChanges().byChange(change.getId())) {
            super.add(RecipientType.BCC, w.getAccountId());
        }
    } catch (OrmException err) {
    // Just don't BCC everyone. Better to send a partial message to those
    // we already have queued up then to fail deliver entirely to people
    // who have a lower interest in the change.
    }
}
#method_after
protected void bccStarredBy() {
    try {
        // 
        for (StarredChange w : args.db.get().starredChanges().byChange(change.getId())) {
            super.add(RecipientType.BCC, w.getAccountId());
        }
    } catch (OrmException err) {
        // Just don't BCC everyone. Better to send a partial message to those
        // we already have queued up then to fail deliver entirely to people
        // who have a lower interest in the change.
        log.warn("Cannot BCC users that starred updated change", err);
    }
}
#end_block

#method_before
protected void bccWatches(NotifyType type) {
    try {
        Watchers matching = getWatches(NotifyType.SUBMITTED_CHANGES);
        for (Account.Id user : matching.accounts) {
            add(RecipientType.BCC, user);
        }
        for (Address addr : matching.emails) {
            add(RecipientType.BCC, addr);
        }
    } catch (OrmException err) {
    // Just don't CC everyone. Better to send a partial message to those
    // we already have queued up then to fail deliver entirely to people
    // who have a lower interest in the change.
    }
}
#method_after
protected void bccWatches(NotifyType type) {
    try {
        Watchers matching = getWatches(type);
        for (Account.Id user : matching.accounts) {
            add(RecipientType.BCC, user);
        }
        for (Address addr : matching.emails) {
            add(RecipientType.BCC, addr);
        }
    } catch (OrmException err) {
        // Just don't CC everyone. Better to send a partial message to those
        // we already have queued up then to fail deliver entirely to people
        // who have a lower interest in the change.
        log.warn("Cannot BCC watchers for " + type, err);
    }
}
#end_block

#method_before
protected final Watchers getWatches(NotifyType type) throws OrmException {
    Watchers matching = new Watchers();
    if (changeData == null) {
        return matching;
    }
    Set<Account.Id> projectWatchers = new HashSet<Account.Id>();
    for (AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(change.getProject())) {
        projectWatchers.add(w.getAccountId());
        if (w.isNotify(type)) {
            add(matching, w);
        }
    }
    for (AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(args.allProjectsName)) {
        if (!projectWatchers.contains(w.getAccountId()) && w.isNotify(type)) {
            add(matching, w);
        }
    }
    ProjectState state = projectState;
    while (state != null) {
        for (NotifyConfig nc : state.getConfig().getNotifyConfigs()) {
            if (nc.isNotify(type)) {
                try {
                    add(matching, nc, state.getProject().getNameKey());
                } catch (QueryParseException e) {
                    log.warn(String.format("Project %s has invalid notify filter \"%s\": %s", state.getProject().getName(), nc.getFilter(), e.getMessage()));
                }
            }
        }
        state = state.getParentState();
    }
    return matching;
}
#method_after
protected final Watchers getWatches(NotifyType type) throws OrmException {
    Watchers matching = new Watchers();
    if (changeData == null) {
        return matching;
    }
    Set<Account.Id> projectWatchers = new HashSet<Account.Id>();
    for (AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(change.getProject())) {
        projectWatchers.add(w.getAccountId());
        if (w.isNotify(type)) {
            add(matching, w);
        }
    }
    for (AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(args.allProjectsName)) {
        if (!projectWatchers.contains(w.getAccountId()) && w.isNotify(type)) {
            add(matching, w);
        }
    }
    ProjectState state = projectState;
    while (state != null) {
        for (NotifyConfig nc : state.getConfig().getNotifyConfigs()) {
            if (nc.isNotify(type)) {
                try {
                    add(matching, nc, state.getProject().getNameKey());
                } catch (QueryParseException e) {
                    log.warn(String.format("Project %s has invalid notify %s filter \"%s\": %s", state.getProject().getName(), nc.getName(), nc.getFilter(), e.getMessage()));
                }
            }
        }
        state = state.getParentState();
    }
    return matching;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void add(Watchers matching, NotifyConfig nc, Project.NameKey project) throws OrmException, QueryParseException {
    for (AccountGroup.UUID uuid : nc.getGroups()) {
        AccountGroup group = args.groupCache.get(uuid);
        if (group == null) {
            log.warn(String.format("Project %s has invalid group %s in notify section", project.get(), uuid.get()));
            continue;
        }
        if (group.getType() != AccountGroup.Type.INTERNAL) {
            log.warn(String.format("Project %s canont use group %s of type %s in notify section", project.get(), uuid.get(), group.getType()));
            continue;
        }
        ChangeQueryBuilder qb = args.queryBuilder.create(new SingleGroupUser(args.capabilityControlFactory, uuid));
        qb.setAllowFile(true);
        Predicate<ChangeData> p = qb.is_visible();
        if (nc.getFilter() != null) {
            p = Predicate.and(qb.parse(nc.getFilter()), p);
            p = args.queryRewriter.get().rewrite(p);
        }
        if (p.match(changeData)) {
            Set<AccountGroup.Id> seen = Sets.newHashSet();
            Queue<AccountGroup.Id> scan = Lists.newLinkedList();
            scan.add(group.getId());
            seen.add(group.getId());
            while (!scan.isEmpty()) {
                AccountGroup.Id next = scan.remove();
                for (AccountGroupMember m : args.db.get().accountGroupMembers().byGroup(next)) {
                    matching.accounts.add(m.getAccountId());
                }
                for (AccountGroupInclude m : args.db.get().accountGroupIncludes().byGroup(next)) {
                    if (seen.add(m.getIncludeId())) {
                        scan.add(m.getIncludeId());
                    }
                }
            }
        }
    }
    if (!nc.getAddresses().isEmpty()) {
        if (nc.getFilter() != null) {
            ChangeQueryBuilder qb = args.queryBuilder.create(args.anonymousUser);
            qb.setAllowFile(true);
            Predicate<ChangeData> p = qb.parse(nc.getFilter());
            p = args.queryRewriter.get().rewrite(p);
            if (p.match(changeData)) {
                matching.emails.addAll(nc.getAddresses());
            }
        } else {
            matching.emails.addAll(nc.getAddresses());
        }
    }
}
#method_after
@SuppressWarnings("unchecked")
private void add(Watchers matching, NotifyConfig nc, Project.NameKey project) throws OrmException, QueryParseException {
    for (GroupReference ref : nc.getGroups()) {
        AccountGroup group = args.groupCache.get(ref.getUUID());
        if (group == null) {
            log.warn(String.format("Project %s has invalid group %s in notify section %s", project.get(), ref.getName(), nc.getName()));
            continue;
        }
        if (group.getType() != AccountGroup.Type.INTERNAL) {
            log.warn(String.format("Project %s cannot use group %s of type %s in notify section %s", project.get(), ref.getName(), group.getType(), nc.getName()));
            continue;
        }
        ChangeQueryBuilder qb = args.queryBuilder.create(new SingleGroupUser(args.capabilityControlFactory, ref.getUUID()));
        qb.setAllowFile(true);
        Predicate<ChangeData> p = qb.is_visible();
        if (nc.getFilter() != null) {
            p = Predicate.and(qb.parse(nc.getFilter()), p);
            p = args.queryRewriter.get().rewrite(p);
        }
        if (p.match(changeData)) {
            recursivelyAddAllAccounts(matching, group);
        }
    }
    if (!nc.getAddresses().isEmpty()) {
        if (nc.getFilter() != null) {
            ChangeQueryBuilder qb = args.queryBuilder.create(args.anonymousUser);
            qb.setAllowFile(true);
            Predicate<ChangeData> p = qb.parse(nc.getFilter());
            p = args.queryRewriter.get().rewrite(p);
            if (p.match(changeData)) {
                matching.emails.addAll(nc.getAddresses());
            }
        } else {
            matching.emails.addAll(nc.getAddresses());
        }
    }
}
#end_block

#method_before
@Override
protected void init() throws EmailException {
    super.init();
    try {
        // BCC anyone who has interest in this project's changes
        // Try to mark interested owners with a TO and not a BCC line.
        // 
        Watchers matching = getWatches(NotifyType.NEW_CHANGES);
        for (Account.Id user : matching.accounts) {
            if (isOwnerOfProjectOrBranch(user)) {
                add(RecipientType.TO, user);
            } else {
                add(RecipientType.BCC, user);
            }
        }
        for (Address addr : matching.emails) {
            add(RecipientType.BCC, addr);
        }
    } catch (OrmException err) {
    // Just don't CC everyone. Better to send a partial message to those
    // we already have queued up then to fail deliver entirely to people
    // who have a lower interest in the change.
    }
}
#method_after
@Override
protected void init() throws EmailException {
    super.init();
    try {
        // BCC anyone who has interest in this project's changes
        // Try to mark interested owners with a TO and not a BCC line.
        // 
        Watchers matching = getWatches(NotifyType.NEW_CHANGES);
        for (Account.Id user : matching.accounts) {
            if (isOwnerOfProjectOrBranch(user)) {
                add(RecipientType.TO, user);
            } else {
                add(RecipientType.BCC, user);
            }
        }
        for (Address addr : matching.emails) {
            add(RecipientType.BCC, addr);
        }
    } catch (OrmException err) {
        // Just don't CC everyone. Better to send a partial message to those
        // we already have queued up then to fail deliver entirely to people
        // who have a lower interest in the change.
        log.warn("Cannot BCC watchers for new change", err);
    }
}
#end_block

#method_before
protected boolean shouldSendMessage() {
    if (body.length() == 0) {
        // 
        return false;
    }
    if (smtpRcptTo.isEmpty()) {
        // 
        return false;
    }
    if (rcptTo.size() == 1 && rcptTo.contains(fromId)) {
        // 
        return false;
    }
    return true;
}
#method_after
protected boolean shouldSendMessage() {
    if (body.length() == 0) {
        // 
        return false;
    }
    if (smtpRcptTo.isEmpty()) {
        // 
        return false;
    }
    if (smtpRcptTo.size() == 1 && rcptTo.size() == 1 && rcptTo.contains(fromId)) {
        // 
        return false;
    }
    return true;
}
#end_block

#method_before
public boolean isNotify(NotifyType type) {
    return types.contains(type);
}
#method_after
public boolean isNotify(NotifyType type) {
    return types.contains(type) || types.contains(NotifyType.ALL);
}
#end_block

#method_before
public Set<AccountGroup.UUID> getGroups() {
    return groups;
}
#method_after
public Set<GroupReference> getGroups() {
    return groups;
}
#end_block

#method_before
public void addEmail(Address address) {
    addresses.add(address);
}
#method_after
public void addEmail(GroupReference group) {
    groups.add(group);
}
#end_block

#method_before
private InMemoryRepository add(ProjectConfig pc) {
    PrologEnvironment.Factory envFactory = null;
    RulesCache rulesCache = null;
    SitePaths sitePaths = null;
    List<CommentLinkInfo> commentLinks = null;
    InMemoryRepository repo;
    try {
        repo = repoManager.createRepository(pc.getName());
        if (pc.getProject() == null) {
            pc.load(repo);
        }
    } catch (IOException | ConfigInvalidException e) {
        throw new RuntimeException(e);
    }
    all.put(pc.getName(), new ProjectState(sitePaths, projectCache, allProjectsName, allUsersName, null, envFactory, repoManager, rulesCache, commentLinks, capabilityCollectionFactory, pc));
    return repo;
}
#method_after
private InMemoryRepository add(ProjectConfig pc) {
    PrologEnvironment.Factory envFactory = null;
    RulesCache rulesCache = null;
    SitePaths sitePaths = null;
    List<CommentLinkInfo> commentLinks = null;
    InMemoryRepository repo;
    try {
        repo = repoManager.createRepository(pc.getName());
        if (pc.getProject() == null) {
            pc.load(repo);
        }
    } catch (IOException | ConfigInvalidException e) {
        throw new RuntimeException(e);
    }
    all.put(pc.getName(), new ProjectState(sitePaths, projectCache, allProjectsName, allUsersName, projectControlFactory, envFactory, repoManager, rulesCache, commentLinks, capabilityCollectionFactory, pc));
    return repo;
}
#end_block

#method_before
public Stream<T> search(List<T> list) {
    checkNotNull(list);
    int begin;
    int end;
    if (0 < prefixLen) {
        // Assumes many consecutive elements may have the same prefix, so the cost
        // of two binary searches is less than iterating to find the endpoints.
        begin = find(list, prefixBegin);
        end = find(list, prefixEnd);
    } else {
        begin = 0;
        end = list.size();
    }
    if (prefixOnly) {
        return (begin < end ? list.subList(begin, end) : ImmutableList.<T>of()).stream();
    }
    return list.subList(begin, end).stream().filter(x -> pattern.run(toStringFunc.apply(x)));
}
#method_after
public Stream<T> search(List<T> list) {
    checkNotNull(list);
    int begin;
    int end;
    if (0 < prefixLen) {
        // Assumes many consecutive elements may have the same prefix, so the cost of two binary
        // searches is less than iterating linearly and running the regexp find the endpoints.
        List<String> strings = Lists.transform(list, toStringFunc::apply);
        begin = find(strings, prefixBegin);
        end = find(strings, prefixEnd);
    } else {
        begin = 0;
        end = list.size();
    }
    if (begin >= end) {
        return Stream.empty();
    }
    Stream<T> result = list.subList(begin, end).stream();
    if (!prefixOnly) {
        result = result.filter(x -> pattern.run(toStringFunc.apply(x)));
    }
    return result;
}
#end_block

#method_before
private int find(List<T> list, String p) {
    int r = Collections.binarySearch(Lists.transform(list, toStringFunc), p);
    return r < 0 ? -(r + 1) : r;
}
#method_after
private static int find(List<String> list, String p) {
    int r = Collections.binarySearch(list, p);
    return r < 0 ? -(r + 1) : r;
}
#end_block

#method_before
@Override
public void remove(Project p) throws IOException {
    listLock.lock();
    try {
        list.put(ListKey.ALL, ImmutableSortedSet.copyOf(Sets.difference(list.get(ListKey.ALL), Collections.singleton(p.getNameKey()))));
    } catch (ExecutionException e) {
        log.warn("Cannot list available projects", e);
    } finally {
        listLock.unlock();
    }
    evict(p);
}
#method_after
@Override
public void remove(Project p) throws IOException {
    listLock.lock();
    try {
        list.put(ListKey.ALL, ImmutableSortedSet.copyOf(Sets.difference(list.get(ListKey.ALL), ImmutableSet.of(p.getNameKey()))));
    } catch (ExecutionException e) {
        log.warn("Cannot list available projects", e);
    } finally {
        listLock.unlock();
    }
    evict(p);
}
#end_block

#method_before
@Override
public void onCreateProject(Project.NameKey newProjectName) throws IOException {
    listLock.lock();
    try {
        list.put(ListKey.ALL, ImmutableSortedSet.copyOf(Sets.union(list.get(ListKey.ALL), Collections.singleton(newProjectName))));
    } catch (ExecutionException e) {
        log.warn("Cannot list available projects", e);
    } finally {
        listLock.unlock();
    }
    indexer.get().index(newProjectName);
}
#method_after
@Override
public void onCreateProject(Project.NameKey newProjectName) throws IOException {
    listLock.lock();
    try {
        list.put(ListKey.ALL, ImmutableSortedSet.copyOf(Sets.union(list.get(ListKey.ALL), ImmutableSet.of(newProjectName))));
    } catch (ExecutionException e) {
        log.warn("Cannot list available projects", e);
    } finally {
        listLock.unlock();
    }
    indexer.get().index(newProjectName);
}
#end_block

#method_before
@Test
public void configChangeCausesRefUpdate() throws Exception {
    RevCommit initialHead = getRemoteHead(project, RefNames.REFS_CONFIG);
    ConfigInfo info = gApi.projects().name(project.get()).config();
    assertThat(info.inheritedSubmitType.value).isEqualTo(SubmitType.MERGE_IF_NECESSARY);
    ConfigInput input = new ConfigInput();
    input.submitType = SubmitType.CHERRY_PICK;
    info = gApi.projects().name(project.get()).config(input);
    assertThat(info.inheritedSubmitType.value).isEqualTo(SubmitType.CHERRY_PICK);
    info = gApi.projects().name(project.get()).config();
    assertThat(info.inheritedSubmitType.value).isEqualTo(SubmitType.CHERRY_PICK);
    RevCommit updatedHead = getRemoteHead(project, RefNames.REFS_CONFIG);
    eventRecorder.assertRefUpdatedEvents(project.get(), RefNames.REFS_CONFIG, initialHead, updatedHead);
}
#method_after
@Test
public void configChangeCausesRefUpdate() throws Exception {
    RevCommit initialHead = getRemoteHead(project, RefNames.REFS_CONFIG);
    ConfigInfo info = gApi.projects().name(project.get()).config();
    assertThat(info.defaultSubmitType.value).isEqualTo(SubmitType.MERGE_IF_NECESSARY);
    ConfigInput input = new ConfigInput();
    input.submitType = SubmitType.CHERRY_PICK;
    info = gApi.projects().name(project.get()).config(input);
    assertThat(info.defaultSubmitType.value).isEqualTo(SubmitType.CHERRY_PICK);
    info = gApi.projects().name(project.get()).config();
    assertThat(info.defaultSubmitType.value).isEqualTo(SubmitType.CHERRY_PICK);
    RevCommit updatedHead = getRemoteHead(project, RefNames.REFS_CONFIG);
    eventRecorder.assertRefUpdatedEvents(project.get(), RefNames.REFS_CONFIG, initialHead, updatedHead);
}
#end_block

#method_before
@Test
@SuppressWarnings("deprecation")
public void setConfig() throws Exception {
    ConfigInput input = createTestConfigInput();
    ConfigInfo info = gApi.projects().name(project.get()).config(input);
    assertThat(info.description).isEqualTo(input.description);
    assertThat(info.useContributorAgreements.configuredValue).isEqualTo(input.useContributorAgreements);
    assertThat(info.useContentMerge.configuredValue).isEqualTo(input.useContentMerge);
    assertThat(info.useSignedOffBy.configuredValue).isEqualTo(input.useSignedOffBy);
    assertThat(info.createNewChangeForAllNotInTarget.configuredValue).isEqualTo(input.createNewChangeForAllNotInTarget);
    assertThat(info.requireChangeId.configuredValue).isEqualTo(input.requireChangeId);
    assertThat(info.rejectImplicitMerges.configuredValue).isEqualTo(input.rejectImplicitMerges);
    assertThat(info.enableReviewerByEmail.configuredValue).isEqualTo(input.enableReviewerByEmail);
    assertThat(info.createNewChangeForAllNotInTarget.configuredValue).isEqualTo(input.createNewChangeForAllNotInTarget);
    assertThat(info.maxObjectSizeLimit.configuredValue).isEqualTo(input.maxObjectSizeLimit);
    assertThat(info.submitType).isEqualTo(input.submitType);
    assertThat(info.inheritedSubmitType.value).isEqualTo(input.submitType);
    assertThat(info.inheritedSubmitType.inheritedValue).isEqualTo(SubmitType.MERGE_IF_NECESSARY);
    assertThat(info.inheritedSubmitType.configuredValue).isEqualTo(input.submitType);
    assertThat(info.state).isEqualTo(input.state);
}
#method_after
@Test
@SuppressWarnings("deprecation")
public void setConfig() throws Exception {
    ConfigInput input = createTestConfigInput();
    ConfigInfo info = gApi.projects().name(project.get()).config(input);
    assertThat(info.description).isEqualTo(input.description);
    assertThat(info.useContributorAgreements.configuredValue).isEqualTo(input.useContributorAgreements);
    assertThat(info.useContentMerge.configuredValue).isEqualTo(input.useContentMerge);
    assertThat(info.useSignedOffBy.configuredValue).isEqualTo(input.useSignedOffBy);
    assertThat(info.createNewChangeForAllNotInTarget.configuredValue).isEqualTo(input.createNewChangeForAllNotInTarget);
    assertThat(info.requireChangeId.configuredValue).isEqualTo(input.requireChangeId);
    assertThat(info.rejectImplicitMerges.configuredValue).isEqualTo(input.rejectImplicitMerges);
    assertThat(info.enableReviewerByEmail.configuredValue).isEqualTo(input.enableReviewerByEmail);
    assertThat(info.createNewChangeForAllNotInTarget.configuredValue).isEqualTo(input.createNewChangeForAllNotInTarget);
    assertThat(info.maxObjectSizeLimit.configuredValue).isEqualTo(input.maxObjectSizeLimit);
    assertThat(info.submitType).isEqualTo(input.submitType);
    assertThat(info.defaultSubmitType.value).isEqualTo(input.submitType);
    assertThat(info.defaultSubmitType.inheritedValue).isEqualTo(SubmitType.MERGE_IF_NECESSARY);
    assertThat(info.defaultSubmitType.configuredValue).isEqualTo(input.submitType);
    assertThat(info.state).isEqualTo(input.state);
}
#end_block

#method_before
@SuppressWarnings("deprecation")
@Test
public void setPartialConfig() throws Exception {
    ConfigInput input = createTestConfigInput();
    ConfigInfo info = gApi.projects().name(project.get()).config(input);
    ConfigInput partialInput = new ConfigInput();
    partialInput.useContributorAgreements = InheritableBoolean.FALSE;
    info = gApi.projects().name(project.get()).config(partialInput);
    assertThat(info.description).isNull();
    assertThat(info.useContributorAgreements.configuredValue).isEqualTo(partialInput.useContributorAgreements);
    assertThat(info.useContentMerge.configuredValue).isEqualTo(input.useContentMerge);
    assertThat(info.useSignedOffBy.configuredValue).isEqualTo(input.useSignedOffBy);
    assertThat(info.createNewChangeForAllNotInTarget.configuredValue).isEqualTo(input.createNewChangeForAllNotInTarget);
    assertThat(info.requireChangeId.configuredValue).isEqualTo(input.requireChangeId);
    assertThat(info.rejectImplicitMerges.configuredValue).isEqualTo(input.rejectImplicitMerges);
    assertThat(info.enableReviewerByEmail.configuredValue).isEqualTo(input.enableReviewerByEmail);
    assertThat(info.createNewChangeForAllNotInTarget.configuredValue).isEqualTo(input.createNewChangeForAllNotInTarget);
    assertThat(info.maxObjectSizeLimit.configuredValue).isEqualTo(input.maxObjectSizeLimit);
    assertThat(info.submitType).isEqualTo(input.submitType);
    assertThat(info.inheritedSubmitType.value).isEqualTo(input.submitType);
    assertThat(info.inheritedSubmitType.inheritedValue).isEqualTo(SubmitType.MERGE_IF_NECESSARY);
    assertThat(info.inheritedSubmitType.configuredValue).isEqualTo(input.submitType);
    assertThat(info.state).isEqualTo(input.state);
}
#method_after
@SuppressWarnings("deprecation")
@Test
public void setPartialConfig() throws Exception {
    ConfigInput input = createTestConfigInput();
    ConfigInfo info = gApi.projects().name(project.get()).config(input);
    ConfigInput partialInput = new ConfigInput();
    partialInput.useContributorAgreements = InheritableBoolean.FALSE;
    info = gApi.projects().name(project.get()).config(partialInput);
    assertThat(info.description).isNull();
    assertThat(info.useContributorAgreements.configuredValue).isEqualTo(partialInput.useContributorAgreements);
    assertThat(info.useContentMerge.configuredValue).isEqualTo(input.useContentMerge);
    assertThat(info.useSignedOffBy.configuredValue).isEqualTo(input.useSignedOffBy);
    assertThat(info.createNewChangeForAllNotInTarget.configuredValue).isEqualTo(input.createNewChangeForAllNotInTarget);
    assertThat(info.requireChangeId.configuredValue).isEqualTo(input.requireChangeId);
    assertThat(info.rejectImplicitMerges.configuredValue).isEqualTo(input.rejectImplicitMerges);
    assertThat(info.enableReviewerByEmail.configuredValue).isEqualTo(input.enableReviewerByEmail);
    assertThat(info.createNewChangeForAllNotInTarget.configuredValue).isEqualTo(input.createNewChangeForAllNotInTarget);
    assertThat(info.maxObjectSizeLimit.configuredValue).isEqualTo(input.maxObjectSizeLimit);
    assertThat(info.submitType).isEqualTo(input.submitType);
    assertThat(info.defaultSubmitType.value).isEqualTo(input.submitType);
    assertThat(info.defaultSubmitType.inheritedValue).isEqualTo(SubmitType.MERGE_IF_NECESSARY);
    assertThat(info.defaultSubmitType.configuredValue).isEqualTo(input.submitType);
    assertThat(info.state).isEqualTo(input.state);
}
#end_block

#method_before
void display(ConfigInfo result) {
    descTxt.setText(result.description());
    setBool(contributorAgreements, result.useContributorAgreements());
    setBool(signedOffBy, result.useSignedOffBy());
    setBool(contentMerge, result.useContentMerge());
    setBool(newChangeForAllNotInTarget, result.createNewChangeForAllNotInTarget());
    setBool(requireChangeID, result.requireChangeId());
    if (Gerrit.info().receive().enableSignedPush()) {
        setBool(enableSignedPush, result.enableSignedPush());
        setBool(requireSignedPush, result.requireSignedPush());
    }
    setBool(rejectImplicitMerges, result.rejectImplicitMerges());
    setBool(privateByDefault, result.privateByDefault());
    setBool(enableReviewerByEmail, result.enableReviewerByEmail());
    setBool(matchAuthorToCommitterDate, result.matchAuthorToCommitterDate());
    setSubmitType(result.inheritedSubmitType());
    setState(result.state());
    maxObjectSizeLimit.setText(result.maxObjectSizeLimit().configuredValue());
    if (result.maxObjectSizeLimit().inheritedValue() != null) {
        effectiveMaxObjectSizeLimit.setVisible(true);
        effectiveMaxObjectSizeLimit.setText(AdminMessages.I.effectiveMaxObjectSizeLimit(result.maxObjectSizeLimit().value()));
        effectiveMaxObjectSizeLimit.setTitle(AdminMessages.I.globalMaxObjectSizeLimit(result.maxObjectSizeLimit().inheritedValue()));
    } else {
        effectiveMaxObjectSizeLimit.setVisible(false);
    }
    saveProject.setEnabled(false);
    initPluginOptions(result);
    initProjectActions(result);
}
#method_after
void display(ConfigInfo result) {
    descTxt.setText(result.description());
    setBool(contributorAgreements, result.useContributorAgreements());
    setBool(signedOffBy, result.useSignedOffBy());
    setBool(contentMerge, result.useContentMerge());
    setBool(newChangeForAllNotInTarget, result.createNewChangeForAllNotInTarget());
    setBool(requireChangeID, result.requireChangeId());
    if (Gerrit.info().receive().enableSignedPush()) {
        setBool(enableSignedPush, result.enableSignedPush());
        setBool(requireSignedPush, result.requireSignedPush());
    }
    setBool(rejectImplicitMerges, result.rejectImplicitMerges());
    setBool(privateByDefault, result.privateByDefault());
    setBool(enableReviewerByEmail, result.enableReviewerByEmail());
    setBool(matchAuthorToCommitterDate, result.matchAuthorToCommitterDate());
    setSubmitType(result.defaultSubmitType());
    setState(result.state());
    maxObjectSizeLimit.setText(result.maxObjectSizeLimit().configuredValue());
    if (result.maxObjectSizeLimit().inheritedValue() != null) {
        effectiveMaxObjectSizeLimit.setVisible(true);
        effectiveMaxObjectSizeLimit.setText(AdminMessages.I.effectiveMaxObjectSizeLimit(result.maxObjectSizeLimit().value()));
        effectiveMaxObjectSizeLimit.setTitle(AdminMessages.I.globalMaxObjectSizeLimit(result.maxObjectSizeLimit().inheritedValue()));
    } else {
        effectiveMaxObjectSizeLimit.setVisible(false);
    }
    saveProject.setEnabled(false);
    initPluginOptions(result);
    initProjectActions(result);
}
#end_block

#method_before
@SuppressWarnings("deprecation")
@Test
public void createProjectWithDefaultInheritedSubmitType() throws Exception {
    String parent = name("parent");
    ProjectInput pin = new ProjectInput();
    pin.name = parent;
    ConfigInfo cfg = gApi.projects().create(pin).config();
    assertThat(cfg.submitType).isEqualTo(SubmitType.MERGE_IF_NECESSARY);
    assertThat(cfg.inheritedSubmitType.value).isEqualTo(SubmitType.MERGE_IF_NECESSARY);
    assertThat(cfg.inheritedSubmitType.configuredValue).isEqualTo(SubmitType.INHERIT);
    assertThat(cfg.inheritedSubmitType.inheritedValue).isEqualTo(SubmitType.MERGE_IF_NECESSARY);
    ConfigInput cin = new ConfigInput();
    cin.submitType = SubmitType.CHERRY_PICK;
    gApi.projects().name(parent).config(cin);
    cfg = gApi.projects().name(parent).config();
    assertThat(cfg.submitType).isEqualTo(SubmitType.CHERRY_PICK);
    assertThat(cfg.inheritedSubmitType.value).isEqualTo(SubmitType.CHERRY_PICK);
    assertThat(cfg.inheritedSubmitType.configuredValue).isEqualTo(SubmitType.CHERRY_PICK);
    assertThat(cfg.inheritedSubmitType.inheritedValue).isEqualTo(SubmitType.MERGE_IF_NECESSARY);
    String child = name("child");
    pin = new ProjectInput();
    pin.parent = parent;
    pin.name = child;
    cfg = gApi.projects().create(pin).config();
    assertThat(cfg.submitType).isEqualTo(SubmitType.CHERRY_PICK);
    assertThat(cfg.inheritedSubmitType.value).isEqualTo(SubmitType.CHERRY_PICK);
    assertThat(cfg.inheritedSubmitType.configuredValue).isEqualTo(SubmitType.INHERIT);
    assertThat(cfg.inheritedSubmitType.inheritedValue).isEqualTo(SubmitType.CHERRY_PICK);
    cin = new ConfigInput();
    cin.submitType = SubmitType.MERGE_IF_NECESSARY;
    gApi.projects().name(parent).config(cin);
    cfg = gApi.projects().name(parent).config();
    assertThat(cfg.submitType).isEqualTo(SubmitType.MERGE_IF_NECESSARY);
    assertThat(cfg.inheritedSubmitType.value).isEqualTo(SubmitType.MERGE_IF_NECESSARY);
    assertThat(cfg.inheritedSubmitType.configuredValue).isEqualTo(SubmitType.MERGE_IF_NECESSARY);
    assertThat(cfg.inheritedSubmitType.inheritedValue).isEqualTo(SubmitType.MERGE_IF_NECESSARY);
    cfg = gApi.projects().name(child).config();
    assertThat(cfg.submitType).isEqualTo(SubmitType.MERGE_IF_NECESSARY);
    assertThat(cfg.inheritedSubmitType.value).isEqualTo(SubmitType.MERGE_IF_NECESSARY);
    assertThat(cfg.inheritedSubmitType.configuredValue).isEqualTo(SubmitType.INHERIT);
    assertThat(cfg.inheritedSubmitType.inheritedValue).isEqualTo(SubmitType.MERGE_IF_NECESSARY);
}
#method_after
@SuppressWarnings("deprecation")
@Test
public void createProjectWithDefaultInheritedSubmitType() throws Exception {
    String parent = name("parent");
    ProjectInput pin = new ProjectInput();
    pin.name = parent;
    ConfigInfo cfg = gApi.projects().create(pin).config();
    assertThat(cfg.submitType).isEqualTo(SubmitType.MERGE_IF_NECESSARY);
    assertThat(cfg.defaultSubmitType.value).isEqualTo(SubmitType.MERGE_IF_NECESSARY);
    assertThat(cfg.defaultSubmitType.configuredValue).isEqualTo(SubmitType.MERGE_IF_NECESSARY);
    assertThat(cfg.defaultSubmitType.inheritedValue).isEqualTo(SubmitType.MERGE_IF_NECESSARY);
    ConfigInput cin = new ConfigInput();
    cin.submitType = SubmitType.CHERRY_PICK;
    gApi.projects().name(parent).config(cin);
    cfg = gApi.projects().name(parent).config();
    assertThat(cfg.submitType).isEqualTo(SubmitType.CHERRY_PICK);
    assertThat(cfg.defaultSubmitType.value).isEqualTo(SubmitType.CHERRY_PICK);
    assertThat(cfg.defaultSubmitType.configuredValue).isEqualTo(SubmitType.CHERRY_PICK);
    assertThat(cfg.defaultSubmitType.inheritedValue).isEqualTo(SubmitType.MERGE_IF_NECESSARY);
    String child = name("child");
    pin = new ProjectInput();
    pin.submitType = SubmitType.INHERIT;
    pin.parent = parent;
    pin.name = child;
    cfg = gApi.projects().create(pin).config();
    assertThat(cfg.submitType).isEqualTo(SubmitType.CHERRY_PICK);
    assertThat(cfg.defaultSubmitType.value).isEqualTo(SubmitType.CHERRY_PICK);
    assertThat(cfg.defaultSubmitType.configuredValue).isEqualTo(SubmitType.INHERIT);
    assertThat(cfg.defaultSubmitType.inheritedValue).isEqualTo(SubmitType.CHERRY_PICK);
    cin = new ConfigInput();
    cin.submitType = SubmitType.REBASE_IF_NECESSARY;
    gApi.projects().name(parent).config(cin);
    cfg = gApi.projects().name(parent).config();
    assertThat(cfg.submitType).isEqualTo(SubmitType.REBASE_IF_NECESSARY);
    assertThat(cfg.defaultSubmitType.value).isEqualTo(SubmitType.REBASE_IF_NECESSARY);
    assertThat(cfg.defaultSubmitType.configuredValue).isEqualTo(SubmitType.REBASE_IF_NECESSARY);
    assertThat(cfg.defaultSubmitType.inheritedValue).isEqualTo(SubmitType.MERGE_IF_NECESSARY);
    cfg = gApi.projects().name(child).config();
    assertThat(cfg.submitType).isEqualTo(SubmitType.REBASE_IF_NECESSARY);
    assertThat(cfg.defaultSubmitType.value).isEqualTo(SubmitType.REBASE_IF_NECESSARY);
    assertThat(cfg.defaultSubmitType.configuredValue).isEqualTo(SubmitType.INHERIT);
    assertThat(cfg.defaultSubmitType.inheritedValue).isEqualTo(SubmitType.REBASE_IF_NECESSARY);
}
#end_block

#method_before
@SuppressWarnings("deprecation")
@Test
@GerritConfig(name = "repository.testinheritedsubmittype/*.defaultSubmitType", value = "CHERRY_PICK")
public void repositoryConfigTakesPrecedenceOverInheritedSubmitType() throws Exception {
    // Can't use name() since we need to specify this project name in gerrit.config prior to
    // startup. Pick something reasonably unique instead.
    String parent = "testinheritedsubmittype";
    ProjectInput pin = new ProjectInput();
    pin.name = parent;
    pin.submitType = SubmitType.MERGE_ALWAYS;
    ConfigInfo cfg = gApi.projects().create(pin).config();
    assertThat(cfg.submitType).isEqualTo(SubmitType.MERGE_ALWAYS);
    assertThat(cfg.inheritedSubmitType.value).isEqualTo(SubmitType.MERGE_ALWAYS);
    assertThat(cfg.inheritedSubmitType.configuredValue).isEqualTo(SubmitType.MERGE_ALWAYS);
    assertThat(cfg.inheritedSubmitType.inheritedValue).isEqualTo(SubmitType.MERGE_IF_NECESSARY);
    String child = parent + "/child";
    pin = new ProjectInput();
    pin.parent = parent;
    pin.name = child;
    cfg = gApi.projects().create(pin).config();
    assertThat(cfg.submitType).isEqualTo(SubmitType.CHERRY_PICK);
    assertThat(cfg.inheritedSubmitType.value).isEqualTo(SubmitType.CHERRY_PICK);
    assertThat(cfg.inheritedSubmitType.configuredValue).isEqualTo(SubmitType.CHERRY_PICK);
    assertThat(cfg.inheritedSubmitType.inheritedValue).isEqualTo(SubmitType.MERGE_ALWAYS);
}
#method_after
@SuppressWarnings("deprecation")
@Test
@GerritConfig(name = "repository.testinheritedsubmittype/*.defaultSubmitType", value = "CHERRY_PICK")
public void repositoryConfigTakesPrecedenceOverInheritedSubmitType() throws Exception {
    // Can't use name() since we need to specify this project name in gerrit.config prior to
    // startup. Pick something reasonably unique instead.
    String parent = "testinheritedsubmittype";
    ProjectInput pin = new ProjectInput();
    pin.name = parent;
    pin.submitType = SubmitType.MERGE_ALWAYS;
    ConfigInfo cfg = gApi.projects().create(pin).config();
    assertThat(cfg.submitType).isEqualTo(SubmitType.MERGE_ALWAYS);
    assertThat(cfg.defaultSubmitType.value).isEqualTo(SubmitType.MERGE_ALWAYS);
    assertThat(cfg.defaultSubmitType.configuredValue).isEqualTo(SubmitType.MERGE_ALWAYS);
    assertThat(cfg.defaultSubmitType.inheritedValue).isEqualTo(SubmitType.MERGE_IF_NECESSARY);
    String child = parent + "/child";
    pin = new ProjectInput();
    pin.parent = parent;
    pin.name = child;
    cfg = gApi.projects().create(pin).config();
    assertThat(cfg.submitType).isEqualTo(SubmitType.CHERRY_PICK);
    assertThat(cfg.defaultSubmitType.value).isEqualTo(SubmitType.CHERRY_PICK);
    assertThat(cfg.defaultSubmitType.configuredValue).isEqualTo(SubmitType.CHERRY_PICK);
    assertThat(cfg.defaultSubmitType.inheritedValue).isEqualTo(SubmitType.MERGE_ALWAYS);
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    for (BooleanProjectConfig config : BooleanProjectConfig.values()) {
        set(rc, config.getSection(), config.getSubSection(), config.getName(), p.getBooleanConfig(config), InheritableBoolean.INHERIT);
    }
    set(rc, RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, validMaxObjectSizeLimit(p.getMaxObjectSizeLimit()));
    // Always set submit.action, even if it's the default.
    rc.setEnum(SUBMIT, null, KEY_ACTION, p.getConfiguredSubmitType());
    set(rc, PROJECT, null, KEY_STATE, p.getState(), DEFAULT_STATE_VALUE);
    set(rc, DASHBOARD, null, KEY_DEFAULT, p.getDefaultDashboard());
    set(rc, DASHBOARD, null, KEY_LOCAL_DEFAULT, p.getLocalDefaultDashboard());
    Set<AccountGroup.UUID> keepGroups = new HashSet<>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    savePluginSections(rc, keepGroups);
    groupList.retainUUIDs(keepGroups);
    saveLabelSections(rc);
    saveSubscribeSections(rc);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
    return true;
}
#method_after
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    for (BooleanProjectConfig config : BooleanProjectConfig.values()) {
        set(rc, config.getSection(), config.getSubSection(), config.getName(), p.getBooleanConfig(config), InheritableBoolean.INHERIT);
    }
    set(rc, RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, validMaxObjectSizeLimit(p.getMaxObjectSizeLimit()));
    set(rc, SUBMIT, null, KEY_ACTION, p.getConfiguredSubmitType(), DEFAULT_SUBMIT_TYPE);
    set(rc, PROJECT, null, KEY_STATE, p.getState(), DEFAULT_STATE_VALUE);
    set(rc, DASHBOARD, null, KEY_DEFAULT, p.getDefaultDashboard());
    set(rc, DASHBOARD, null, KEY_LOCAL_DEFAULT, p.getLocalDefaultDashboard());
    Set<AccountGroup.UUID> keepGroups = new HashSet<>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    savePluginSections(rc, keepGroups);
    groupList.retainUUIDs(keepGroups);
    saveLabelSections(rc);
    saveSubscribeSections(rc);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
    return true;
}
#end_block

#method_before
public static boolean isOff(String listenHostname) {
    return "off".equalsIgnoreCase(listenHostname) || "none".equalsIgnoreCase(listenHostname) || "no".equalsIgnoreCase(listenHostname);
}
#method_after
static boolean isOff(String listenHostname) {
    return "off".equalsIgnoreCase(listenHostname) || "none".equalsIgnoreCase(listenHostname) || "no".equalsIgnoreCase(listenHostname);
}
#end_block

#method_before
private List<ChangeAndCommit> getRelated(RevisionResource rsrc) throws OrmException, IOException, PermissionBackendException {
    Set<String> groups = getAllGroups(rsrc.getNotes());
    if (groups.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeData> cds = InternalChangeQuery.byProjectGroups(queryProvider, indexConfig, rsrc.getChange().getProject(), groups);
    if (cds.isEmpty()) {
        return Collections.emptyList();
    }
    if (cds.size() == 1 && cds.get(0).getId().equals(rsrc.getChange().getId())) {
        return Collections.emptyList();
    }
    List<ChangeAndCommit> result = new ArrayList<>(cds.size());
    boolean isEdit = rsrc.getEdit().isPresent();
    PatchSet basePs = isEdit ? rsrc.getEdit().get().getBasePatchSet() : rsrc.getPatchSet();
    reloadChangeIfStale(cds, basePs);
    for (PatchSetData d : sorter.sort(cds, basePs, rsrc.getUser())) {
        PatchSet ps = d.patchSet();
        RevCommit commit;
        if (isEdit && ps.getId().equals(basePs.getId())) {
            // Replace base of an edit with the edit itself.
            ps = rsrc.getPatchSet();
            commit = rsrc.getEdit().get().getEditCommit();
        } else {
            commit = d.commit();
        }
        result.add(new ChangeAndCommit(rsrc.getProject(), d.data().change(), ps, commit));
    }
    if (result.size() == 1) {
        ChangeAndCommit r = result.get(0);
        if (r.commit != null && r.commit.commit.equals(rsrc.getPatchSet().getRevision().get())) {
            return Collections.emptyList();
        }
    }
    return result;
}
#method_after
private List<ChangeAndCommit> getRelated(RevisionResource rsrc) throws OrmException, IOException, PermissionBackendException {
    Set<String> groups = getAllGroups(rsrc.getNotes(), db.get(), psUtil);
    if (groups.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeData> cds = InternalChangeQuery.byProjectGroups(queryProvider, indexConfig, rsrc.getChange().getProject(), groups);
    if (cds.isEmpty()) {
        return Collections.emptyList();
    }
    if (cds.size() == 1 && cds.get(0).getId().equals(rsrc.getChange().getId())) {
        return Collections.emptyList();
    }
    List<ChangeAndCommit> result = new ArrayList<>(cds.size());
    boolean isEdit = rsrc.getEdit().isPresent();
    PatchSet basePs = isEdit ? rsrc.getEdit().get().getBasePatchSet() : rsrc.getPatchSet();
    reloadChangeIfStale(cds, basePs);
    for (PatchSetData d : sorter.sort(cds, basePs, rsrc.getUser())) {
        PatchSet ps = d.patchSet();
        RevCommit commit;
        if (isEdit && ps.getId().equals(basePs.getId())) {
            // Replace base of an edit with the edit itself.
            ps = rsrc.getPatchSet();
            commit = rsrc.getEdit().get().getEditCommit();
        } else {
            commit = d.commit();
        }
        result.add(new ChangeAndCommit(rsrc.getProject(), d.data().change(), ps, commit));
    }
    if (result.size() == 1) {
        ChangeAndCommit r = result.get(0);
        if (r.commit != null && r.commit.commit.equals(rsrc.getPatchSet().getRevision().get())) {
            return Collections.emptyList();
        }
    }
    return result;
}
#end_block

#method_before
private void autoCloseChanges(ReceiveCommand cmd) {
    logDebug("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    // insertChangesAndPatchSets.
    try {
        retryHelper.execute(updateFactory -> {
            try (BatchUpdate bu = updateFactory.create(db, projectState.getNameKey(), user, TimeUtil.nowTs());
                ObjectInserter ins = repo.newObjectInserter();
                ObjectReader reader = ins.newReader();
                RevWalk rw = new RevWalk(reader)) {
                bu.setRepository(repo, rw, ins).updateChangesInParallel();
                bu.setRequestId(receiveId);
                // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
                RevCommit newTip = rw.parseCommit(cmd.getNewId());
                Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
                rw.reset();
                rw.markStart(newTip);
                if (!ObjectId.zeroId().equals(cmd.getOldId())) {
                    rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
                }
                ListMultimap<ObjectId, Ref> byCommit = changeRefsById();
                Map<Change.Key, ChangeNotes> byKey = null;
                List<ReplaceRequest> replaceAndClose = new ArrayList<>();
                int existingPatchSets = 0;
                int newPatchSets = 0;
                COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
                    rw.parseBody(c);
                    for (Ref ref : byCommit.get(c.copy())) {
                        PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                        Optional<ChangeData> cd = retryHelper.execute(() -> byLegacyId(psId.getParentKey()), t -> t instanceof OrmException);
                        if (cd.isPresent() && cd.get().change().getDest().equals(branch)) {
                            existingPatchSets++;
                            bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                            continue COMMIT;
                        }
                    }
                    for (String changeId : c.getFooterLines(CHANGE_ID)) {
                        if (byKey == null) {
                            byKey = retryHelper.execute(() -> openChangesByKeyByBranch(branch), t -> t instanceof OrmException);
                        }
                        ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                        if (onto != null) {
                            newPatchSets++;
                            // Hold onto this until we're done with the walk, as the call to
                            // req.validate below calls isMergedInto which resets the walk.
                            ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                            req.notes = onto;
                            replaceAndClose.add(req);
                            continue COMMIT;
                        }
                    }
                }
                for (ReplaceRequest req : replaceAndClose) {
                    Change.Id id = req.notes.getChangeId();
                    if (!req.validate(true)) {
                        logDebug("Not closing {} because validation failed", id);
                        continue;
                    }
                    req.addOps(bu, null);
                    bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                        @Override
                        public PatchSet get() {
                            return req.replaceOp.getPatchSet();
                        }
                    }));
                    bu.addOp(id, new ChangeProgressOp(closeProgress));
                }
                logDebug("Auto-closing {} changes with existing patch sets and {} with new patch sets", existingPatchSets, newPatchSets);
                bu.execute();
            } catch (OrmException e) {
                logError("Can't scan for changes to close", e);
            } catch (IOException | PermissionBackendException e) {
                logError("Failed to auto-close changes", e);
            }
            return null;
        });
    } catch (RestApiException e) {
        logError("Can't insert patchset", e);
    } catch (UpdateException e) {
        logError("Failed to auto-close changes", e);
    }
}
#method_after
private void autoCloseChanges(ReceiveCommand cmd) {
    logDebug("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    // insertChangesAndPatchSets.
    try {
        retryHelper.execute(updateFactory -> {
            try (BatchUpdate bu = updateFactory.create(db, projectState.getNameKey(), user, TimeUtil.nowTs());
                ObjectInserter ins = repo.newObjectInserter();
                ObjectReader reader = ins.newReader();
                RevWalk rw = new RevWalk(reader)) {
                bu.setRepository(repo, rw, ins).updateChangesInParallel();
                bu.setRequestId(receiveId);
                // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
                RevCommit newTip = rw.parseCommit(cmd.getNewId());
                Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
                rw.reset();
                rw.markStart(newTip);
                if (!ObjectId.zeroId().equals(cmd.getOldId())) {
                    rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
                }
                ListMultimap<ObjectId, Ref> byCommit = changeRefsById();
                Map<Change.Key, ChangeNotes> byKey = null;
                List<ReplaceRequest> replaceAndClose = new ArrayList<>();
                int existingPatchSets = 0;
                int newPatchSets = 0;
                COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
                    rw.parseBody(c);
                    for (Ref ref : byCommit.get(c.copy())) {
                        PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                        Optional<ChangeData> cd = retryHelper.execute(ActionType.CHANGE_QUERY, () -> byLegacyId(psId.getParentKey()), t -> t instanceof OrmException);
                        if (cd.isPresent() && cd.get().change().getDest().equals(branch)) {
                            existingPatchSets++;
                            bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                            continue COMMIT;
                        }
                    }
                    for (String changeId : c.getFooterLines(CHANGE_ID)) {
                        if (byKey == null) {
                            byKey = retryHelper.execute(ActionType.CHANGE_QUERY, () -> openChangesByKeyByBranch(branch), t -> t instanceof OrmException);
                        }
                        ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                        if (onto != null) {
                            newPatchSets++;
                            // Hold onto this until we're done with the walk, as the call to
                            // req.validate below calls isMergedInto which resets the walk.
                            ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                            req.notes = onto;
                            replaceAndClose.add(req);
                            continue COMMIT;
                        }
                    }
                }
                for (ReplaceRequest req : replaceAndClose) {
                    Change.Id id = req.notes.getChangeId();
                    if (!req.validate(true)) {
                        logDebug("Not closing {} because validation failed", id);
                        continue;
                    }
                    req.addOps(bu, null);
                    bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                        @Override
                        public PatchSet get() {
                            return req.replaceOp.getPatchSet();
                        }
                    }));
                    bu.addOp(id, new ChangeProgressOp(closeProgress));
                }
                logDebug("Auto-closing {} changes with existing patch sets and {} with new patch sets", existingPatchSets, newPatchSets);
                bu.execute();
            } catch (IOException | OrmException | PermissionBackendException e) {
                logError("Failed to auto-close changes", e);
            }
            return null;
        }, // eat up the whole timeout so that no time is left to retry this outer action.
        RetryHelper.options().timeout(retryHelper.getDefaultTimeout().multipliedBy(5)).build());
    } catch (RestApiException e) {
        logError("Can't insert patchset", e);
    } catch (UpdateException e) {
        logError("Failed to auto-close changes", e);
    }
}
#end_block

#method_before
private <T> T execute(ChangeAction<T> changeAction, Retryer<T> retryer) throws Throwable {
    try {
        return retryer.call(() -> changeAction.call(updateFactory));
    } catch (ExecutionException | RetryException e) {
        if (e instanceof RetryException) {
            metrics.timeoutCount.increment();
        }
        if (e.getCause() != null) {
            throw e.getCause();
        }
        throw e;
    }
}
#method_after
public <T> T execute(ActionType actionType, Action<T> action) throws IOException, ConfigInvalidException, OrmException {
    return execute(actionType, action, t -> t instanceof LockFailureException);
}
#end_block

#method_before
public <T> T execute(ChangeAction<T> changeAction, Options opts) throws RestApiException, UpdateException {
    try {
        if (!migration.disableChangeReviewDb()) {
            // don't do it automatically. Let the end user decide whether they want to retry.
            return execute(changeAction, RetryerBuilder.<T>newBuilder().build());
        }
        MetricListener listener = new MetricListener();
        try {
            RetryerBuilder<T> retryerBuilder = createRetryerBuilder(opts, t -> {
                if (t instanceof UpdateException) {
                    t = t.getCause();
                }
                return t instanceof LockFailureException;
            });
            retryerBuilder.withRetryListener(listener);
            return execute(changeAction, retryerBuilder.build());
        } finally {
            metrics.attemptCounts.record(listener.getAttemptCount());
        }
    } catch (Throwable t) {
        Throwables.throwIfUnchecked(t);
        Throwables.throwIfInstanceOf(t, UpdateException.class);
        Throwables.throwIfInstanceOf(t, RestApiException.class);
        throw new UpdateException(t);
    }
}
#method_after
public <T> T execute(ChangeAction<T> changeAction, Options opts) throws RestApiException, UpdateException {
    try {
        if (!migration.disableChangeReviewDb()) {
            // don't do it automatically. Let the end user decide whether they want to retry.
            return execute(ActionType.CHANGE_UPDATE, () -> changeAction.call(updateFactory), RetryerBuilder.<T>newBuilder().build());
        }
        return execute(ActionType.CHANGE_UPDATE, () -> changeAction.call(updateFactory), opts, t -> {
            if (t instanceof UpdateException) {
                t = t.getCause();
            }
            return t instanceof LockFailureException;
        });
    } catch (Throwable t) {
        Throwables.throwIfUnchecked(t);
        Throwables.throwIfInstanceOf(t, UpdateException.class);
        Throwables.throwIfInstanceOf(t, RestApiException.class);
        throw new UpdateException(t);
    }
}
#end_block

#method_before
public List<SuggestedReviewerInfo> suggestReviewers(ChangeNotes changeNotes, SuggestReviewers suggestReviewers, ProjectState projectState, VisibilityControl visibilityControl, boolean excludeGroups) throws IOException, OrmException, ConfigInvalidException {
    String query = suggestReviewers.getQuery();
    int limit = suggestReviewers.getLimit();
    if (!suggestReviewers.getSuggestAccounts()) {
        return Collections.emptyList();
    }
    List<Account.Id> candidateList = new ArrayList<>();
    if (!Strings.isNullOrEmpty(query)) {
        candidateList = suggestAccounts(suggestReviewers);
    }
    List<Account.Id> sortedRecommendations = recommendAccounts(changeNotes, suggestReviewers, projectState, candidateList);
    // Filter accounts by visibility and enforce limit
    List<Account.Id> filteredRecommendations = new ArrayList<>();
    try (Timer0.Context ctx = metrics.filterVisibility.start()) {
        for (Account.Id reviewer : sortedRecommendations) {
            if (filteredRecommendations.size() >= limit) {
                break;
            }
            if (visibilityControl.isVisibleTo(reviewer)) {
                filteredRecommendations.add(reviewer);
            }
        }
    }
    List<SuggestedReviewerInfo> suggestedReviewer = loadAccounts(filteredRecommendations);
    if (!excludeGroups && suggestedReviewer.size() < limit && !Strings.isNullOrEmpty(query)) {
        // Add groups at the end as individual accounts are usually more
        // important.
        suggestedReviewer.addAll(suggestAccountGroups(suggestReviewers, projectState, visibilityControl, limit - suggestedReviewer.size()));
    }
    if (suggestedReviewer.size() <= limit) {
        return suggestedReviewer;
    }
    return suggestedReviewer.subList(0, limit);
}
#method_after
public List<SuggestedReviewerInfo> suggestReviewers(ChangeNotes changeNotes, SuggestReviewers suggestReviewers, ProjectState projectState, VisibilityControl visibilityControl, boolean excludeGroups) throws IOException, OrmException, ConfigInvalidException {
    String query = suggestReviewers.getQuery();
    int limit = suggestReviewers.getLimit();
    if (!suggestReviewers.getSuggestAccounts()) {
        return Collections.emptyList();
    }
    List<Account.Id> candidateList = new ArrayList<>();
    if (!Strings.isNullOrEmpty(query)) {
        candidateList = suggestAccounts(suggestReviewers);
    }
    List<Account.Id> sortedRecommendations = recommendAccounts(changeNotes, suggestReviewers, projectState, candidateList);
    // Filter accounts by visibility and enforce limit
    List<Account.Id> filteredRecommendations = new ArrayList<>();
    try (Timer0.Context ctx = metrics.filterVisibility.start()) {
        for (Account.Id reviewer : sortedRecommendations) {
            if (filteredRecommendations.size() >= limit) {
                break;
            }
            // Check if change is visible to reviewer and if the current user can see reviewer
            if (visibilityControl.isVisibleTo(reviewer) && accountControlFactory.get().canSee(reviewer)) {
                filteredRecommendations.add(reviewer);
            }
        }
    }
    List<SuggestedReviewerInfo> suggestedReviewer = loadAccounts(filteredRecommendations);
    if (!excludeGroups && suggestedReviewer.size() < limit && !Strings.isNullOrEmpty(query)) {
        // Add groups at the end as individual accounts are usually more
        // important.
        suggestedReviewer.addAll(suggestAccountGroups(suggestReviewers, projectState, visibilityControl, limit - suggestedReviewer.size()));
    }
    if (suggestedReviewer.size() <= limit) {
        return suggestedReviewer;
    }
    return suggestedReviewer.subList(0, limit);
}
#end_block

#method_before
private List<Account.Id> suggestAccounts(SuggestReviewers suggestReviewers) throws OrmException {
    try (Timer0.Context ctx = metrics.queryAccountsLatency.start()) {
        try {
            QueryResult<AccountState> result = queryProvider.get().setRequestedFields(ImmutableSet.of(AccountField.ID.getName())).setUserProvidedLimit(suggestReviewers.getLimit() * CANDIDATE_LIST_MULTIPLIER).query(AccountPredicates.andActive(accountQueryBuilder.defaultQuery(suggestReviewers.getQuery())));
            return result.entities().stream().map(a -> a.getAccount().getId()).collect(toList());
        } catch (QueryParseException e) {
            return ImmutableList.of();
        }
    }
}
#method_after
private List<Account.Id> suggestAccounts(SuggestReviewers suggestReviewers) throws OrmException {
    try (Timer0.Context ctx = metrics.queryAccountsLatency.start()) {
        try {
            // For performance reasons we don't use AccountQueryProvider as it would always load the
            // complete account from the cache (or worse, from NoteDb) even though we only need the ID
            // which we can directly get from the returned results.
            ResultSet<FieldBundle> result = accountIndexes.getSearchIndex().getSource(Predicate.and(AccountPredicates.isActive(), accountQueryBuilder.defaultQuery(suggestReviewers.getQuery())), QueryOptions.create(indexConfig, 0, suggestReviewers.getLimit() * CANDIDATE_LIST_MULTIPLIER, ImmutableSet.of(AccountField.ID.getName()))).readRaw();
            return result.toList().stream().map(f -> new Account.Id(f.getValue(AccountField.ID).intValue())).collect(toList());
        } catch (QueryParseException e) {
            return ImmutableList.of();
        }
    }
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    Set<Account.Id> accounts = null;
    AccountGroup.UUID group = null;
    // Parse for:
    // label:CodeReview=1,user=jsmith or
    // label:CodeReview=1,jsmith or
    // label:CodeReview=1,account=android_approvers or
    // label:CodeReview=1,android_approvers
    // user/groups without a label will first attempt to match user
    // Special case: votes by owners can be tracked with ",owner":
    // label:Code-Review+2,owner
    // label:Code-Review+2,user=owner
    String[] splitReviewer = name.split(",", 2);
    // remove all but the vote piece, e.g.'CodeReview=1'
    name = splitReviewer[0];
    if (splitReviewer.length == 2) {
        // process the user/account piece
        PredicateArgs lblArgs = new PredicateArgs(splitReviewer[1]);
        for (Map.Entry<String, String> pair : lblArgs.keyValue.entrySet()) {
            if (pair.getKey().equalsIgnoreCase(ARG_ID_USER)) {
                if (pair.getValue().equals(ARG_ID_OWNER)) {
                    accounts = Collections.singleton(OWNER_ACCOUNT_ID);
                } else {
                    accounts = parseAccount(pair.getValue());
                }
            } else if (pair.getKey().equalsIgnoreCase(ARG_ID_GROUP)) {
                group = parseGroup(pair.getValue()).getUUID();
            } else {
                throw new QueryParseException("Invalid argument identifier '" + pair.getKey() + "'");
            }
        }
        for (String value : lblArgs.positional) {
            if (accounts != null || group != null) {
                throw new QueryParseException("more than one user/account specified (" + value + ")");
            }
            try {
                if (value.equals(ARG_ID_OWNER)) {
                    accounts = Collections.singleton(OWNER_ACCOUNT_ID);
                } else {
                    accounts = parseAccount(value);
                }
            } catch (QueryParseException qpex) {
                // (accounts get precedence)
                try {
                    group = parseGroup(value).getUUID();
                } catch (QueryParseException e) {
                    throw error("Neither user nor account " + value + " found", e);
                }
            }
        }
    }
    // expand a account predicate into multiple user predicates
    if (group != null) {
        Set<Account.Id> allMembers = args.groupMembers.listAccounts(group).stream().map(a -> a.getId()).collect(toSet());
        int maxTerms = args.indexConfig.maxTerms();
        if (allMembers.size() > maxTerms) {
            // limit the number of query terms otherwise Gerrit will barf
            accounts = ImmutableSet.copyOf(Iterables.limit(allMembers, maxTerms));
        } else {
            accounts = allMembers;
        }
    }
    // If the vote piece looks like Code-Review=NEED with a valid non-numeric
    // submit record status, interpret as a submit record query.
    int eq = name.indexOf('=');
    if (args.getSchema().hasField(ChangeField.SUBMIT_RECORD) && eq > 0) {
        String statusName = name.substring(eq + 1).toUpperCase();
        if (!isInt(statusName)) {
            SubmitRecord.Label.Status status = Enums.getIfPresent(SubmitRecord.Label.Status.class, statusName).orNull();
            if (status == null) {
                throw error("Invalid label status " + statusName + " in " + name);
            }
            return SubmitRecordPredicate.create(name.substring(0, eq), status, accounts);
        }
    }
    return new LabelPredicate(args, name, accounts, group);
}
#method_after
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    Set<Account.Id> accounts = null;
    AccountGroup.UUID group = null;
    // Parse for:
    // label:CodeReview=1,user=jsmith or
    // label:CodeReview=1,jsmith or
    // label:CodeReview=1,group=android_approvers or
    // label:CodeReview=1,android_approvers
    // user/groups without a label will first attempt to match user
    // Special case: votes by owners can be tracked with ",owner":
    // label:Code-Review+2,owner
    // label:Code-Review+2,user=owner
    String[] splitReviewer = name.split(",", 2);
    // remove all but the vote piece, e.g.'CodeReview=1'
    name = splitReviewer[0];
    if (splitReviewer.length == 2) {
        // process the user/group piece
        PredicateArgs lblArgs = new PredicateArgs(splitReviewer[1]);
        for (Map.Entry<String, String> pair : lblArgs.keyValue.entrySet()) {
            if (pair.getKey().equalsIgnoreCase(ARG_ID_USER)) {
                if (pair.getValue().equals(ARG_ID_OWNER)) {
                    accounts = Collections.singleton(OWNER_ACCOUNT_ID);
                } else {
                    accounts = parseAccount(pair.getValue());
                }
            } else if (pair.getKey().equalsIgnoreCase(ARG_ID_GROUP)) {
                group = parseGroup(pair.getValue()).getUUID();
            } else {
                throw new QueryParseException("Invalid argument identifier '" + pair.getKey() + "'");
            }
        }
        for (String value : lblArgs.positional) {
            if (accounts != null || group != null) {
                throw new QueryParseException("more than one user/group specified (" + value + ")");
            }
            try {
                if (value.equals(ARG_ID_OWNER)) {
                    accounts = Collections.singleton(OWNER_ACCOUNT_ID);
                } else {
                    accounts = parseAccount(value);
                }
            } catch (QueryParseException qpex) {
                // (accounts get precedence)
                try {
                    group = parseGroup(value).getUUID();
                } catch (QueryParseException e) {
                    throw error("Neither user nor group " + value + " found", e);
                }
            }
        }
    }
    // expand a group predicate into multiple user predicates
    if (group != null) {
        Set<Account.Id> allMembers = args.groupMembers.listAccounts(group).stream().map(a -> a.getId()).collect(toSet());
        int maxTerms = args.indexConfig.maxTerms();
        if (allMembers.size() > maxTerms) {
            // limit the number of query terms otherwise Gerrit will barf
            accounts = ImmutableSet.copyOf(Iterables.limit(allMembers, maxTerms));
        } else {
            accounts = allMembers;
        }
    }
    // If the vote piece looks like Code-Review=NEED with a valid non-numeric
    // submit record status, interpret as a submit record query.
    int eq = name.indexOf('=');
    if (args.getSchema().hasField(ChangeField.SUBMIT_RECORD) && eq > 0) {
        String statusName = name.substring(eq + 1).toUpperCase();
        if (!isInt(statusName)) {
            SubmitRecord.Label.Status status = Enums.getIfPresent(SubmitRecord.Label.Status.class, statusName).orNull();
            if (status == null) {
                throw error("Invalid label status " + statusName + " in " + name);
            }
            return SubmitRecordPredicate.create(name.substring(0, eq), status, accounts);
        }
    }
    return new LabelPredicate(args, name, accounts, group);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    if (isSelf(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a account?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(ids));
    }
    throw error("No user or account matches \"" + who + "\".");
}
#method_after
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    if (isSelf(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#end_block

#method_before
@Override
public List<ProjectInfo> apply(ProjectResource rsrc) throws PermissionBackendException {
    if (recursive) {
        return childProjectLister.recursiveChildProjects(rsrc.getNameKey());
    }
    return directChildProjects(rsrc.getNameKey());
}
#method_after
@Override
public List<ProjectInfo> apply(ProjectResource rsrc) throws PermissionBackendException {
    if (recursive) {
        return childProjects.list(rsrc.getNameKey());
    }
    return directChildProjects(rsrc.getNameKey());
}
#end_block

#method_before
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, Providers.of(otherUser), permissionBackend, notesFactory, changeDataFactory, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, childProjectLister, submitDryRun, conflictsCache, index, indexConfig, listMembers, starredChangesUtil, accountCache, allowsDrafts, notesMigration);
}
#method_after
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, Providers.of(otherUser), permissionBackend, notesFactory, changeDataFactory, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, childProjects, submitDryRun, conflictsCache, index, indexConfig, listMembers, starredChangesUtil, accountCache, allowsDrafts, notesMigration);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> parentproject(String name) {
    return new ParentProjectPredicate(args.projectCache, args.childProjectLister, args.self, name);
}
#method_after
@Operator
public Predicate<ChangeData> parentproject(String name) {
    return new ParentProjectPredicate(args.projectCache, args.childProjects, args.self, name);
}
#end_block

#method_before
private Predicate<ChangeData> getAuthorOrCommitterFullTextPredicate(String who, Function<String, Predicate<ChangeData>> fullPredicateFunc) throws QueryParseException {
    Set<String> parts = SchemaUtil.getNameParts(who);
    if (parts.isEmpty()) {
        throw error("invalid value");
    }
    List<Predicate<ChangeData>> predicates = parts.stream().map(fullPredicateFunc).collect(Collectors.toList());
    return Predicate.and(predicates);
}
#method_after
private Predicate<ChangeData> getAuthorOrCommitterFullTextPredicate(String who, Function<String, Predicate<ChangeData>> fullPredicateFunc) throws QueryParseException {
    Set<String> parts = SchemaUtil.getNameParts(who);
    if (parts.isEmpty()) {
        throw error("invalid value");
    }
    List<Predicate<ChangeData>> predicates = parts.stream().map(fullPredicateFunc).collect(toList());
    return Predicate.and(predicates);
}
#end_block

#method_before
protected static List<Predicate<ChangeData>> predicates(ProjectCache projectCache, ChildProjectLister childProjectLister, Provider<CurrentUser> self, String value) {
    ProjectState projectState = projectCache.get(new Project.NameKey(value));
    if (projectState == null) {
        return Collections.emptyList();
    }
    List<Predicate<ChangeData>> r = new ArrayList<>();
    r.add(new ProjectPredicate(projectState.getName()));
    try {
        for (ProjectInfo p : childProjectLister.recursiveChildProjects(projectState.getNameKey())) {
            r.add(new ProjectPredicate(p.name));
        }
    } catch (PermissionBackendException e) {
        log.warn("cannot check permissions to expand child projects", e);
    }
    return r;
}
#method_after
protected static List<Predicate<ChangeData>> predicates(ProjectCache projectCache, ChildProjects childProjects, Provider<CurrentUser> self, String value) {
    ProjectState projectState = projectCache.get(new Project.NameKey(value));
    if (projectState == null) {
        return Collections.emptyList();
    }
    List<Predicate<ChangeData>> r = new ArrayList<>();
    r.add(new ProjectPredicate(projectState.getName()));
    try {
        for (ProjectInfo p : childProjects.list(projectState.getNameKey())) {
            r.add(new ProjectPredicate(p.name));
        }
    } catch (PermissionBackendException e) {
        log.warn("cannot check permissions to expand child projects", e);
    }
    return r;
}
#end_block

#method_before
@Override
public ServerInfo apply(ConfigResource rsrc) throws MalformedURLException {
    ServerInfo info = new ServerInfo();
    info.auth = getAuthInfo(authConfig, realm);
    info.change = getChangeInfo(config);
    info.download = getDownloadInfo(downloadSchemes, downloadCommands, cloneCommands, archiveFormats);
    info.gerrit = getGerritInfo(config, allProjectsName, allUsersName);
    info.noteDbEnabled = toBoolean(isNoteDbEnabled());
    info.plugin = getPluginInfo();
    info.privateByDefault = config.getBoolean("change", "privateByDefault", false);
    if (Files.exists(sitePaths.site_theme)) {
        info.defaultTheme = "/static/" + SitePaths.THEME_FILENAME;
    }
    info.sshd = getSshdInfo(config);
    info.suggest = getSuggestInfo(config);
    Map<String, String> urlAliases = getUrlAliasesInfo(config);
    info.urlAliases = !urlAliases.isEmpty() ? urlAliases : null;
    info.user = getUserInfo(anonymousCowardName);
    info.receive = getReceiveInfo();
    return info;
}
#method_after
@Override
public ServerInfo apply(ConfigResource rsrc) throws MalformedURLException {
    ServerInfo info = new ServerInfo();
    info.auth = getAuthInfo(authConfig, realm);
    info.change = getChangeInfo(config);
    info.download = getDownloadInfo(downloadSchemes, downloadCommands, cloneCommands, archiveFormats);
    info.gerrit = getGerritInfo(config, allProjectsName, allUsersName);
    info.noteDbEnabled = toBoolean(isNoteDbEnabled());
    info.plugin = getPluginInfo();
    if (Files.exists(sitePaths.site_theme)) {
        info.defaultTheme = "/static/" + SitePaths.THEME_FILENAME;
    }
    info.sshd = getSshdInfo(config);
    info.suggest = getSuggestInfo(config);
    Map<String, String> urlAliases = getUrlAliasesInfo(config);
    info.urlAliases = !urlAliases.isEmpty() ? urlAliases : null;
    info.user = getUserInfo(anonymousCowardName);
    info.receive = getReceiveInfo();
    return info;
}
#end_block

#method_before
private ChangeConfigInfo getChangeInfo(Config cfg) {
    ChangeConfigInfo info = new ChangeConfigInfo();
    info.allowBlame = toBoolean(cfg.getBoolean("change", "allowBlame", true));
    info.allowDrafts = toBoolean(cfg.getBoolean("change", "allowDrafts", true));
    boolean hasAssigneeInIndex = indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE);
    info.showAssigneeInChangesTable = toBoolean(cfg.getBoolean("change", "showAssigneeInChangesTable", false) && hasAssigneeInIndex);
    info.largeChange = cfg.getInt("change", "largeChange", 500);
    info.replyTooltip = Optional.ofNullable(cfg.getString("change", null, "replyTooltip")).orElse("Reply and score") + " (Shortcut: a)";
    info.replyLabel = Optional.ofNullable(cfg.getString("change", null, "replyLabel")).orElse("Reply") + "\u2026";
    info.updateDelay = (int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 300, TimeUnit.SECONDS);
    info.submitWholeTopic = Submit.wholeTopicEnabled(cfg);
    return info;
}
#method_after
private ChangeConfigInfo getChangeInfo(Config cfg) {
    ChangeConfigInfo info = new ChangeConfigInfo();
    info.allowBlame = toBoolean(cfg.getBoolean("change", "allowBlame", true));
    info.allowDrafts = toBoolean(cfg.getBoolean("change", "allowDrafts", true));
    boolean hasAssigneeInIndex = indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE);
    info.showAssigneeInChangesTable = toBoolean(cfg.getBoolean("change", "showAssigneeInChangesTable", false) && hasAssigneeInIndex);
    info.largeChange = cfg.getInt("change", "largeChange", 500);
    info.privateByDefault = toBoolean(cfg.getBoolean("change", "privateByDefault", false));
    info.replyTooltip = Optional.ofNullable(cfg.getString("change", null, "replyTooltip")).orElse("Reply and score") + " (Shortcut: a)";
    info.replyLabel = Optional.ofNullable(cfg.getString("change", null, "replyLabel")).orElse("Reply") + "\u2026";
    info.updateDelay = (int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 300, TimeUnit.SECONDS);
    info.submitWholeTopic = Submit.wholeTopicEnabled(cfg);
    return info;
}
#end_block

#method_before
public boolean canRead(ProjectState state, Repository repo, RevCommit commit) {
    Project.NameKey project = state.getNameKey();
    // Look for changes associated with the commit.
    try {
        List<ChangeData> changes = queryProvider.get().enforceVisibility(true).byProjectCommit(project, commit);
        if (!changes.isEmpty()) {
            return true;
        }
    } catch (OrmException e) {
        log.error("Cannot look up change for commit " + commit.name() + " in " + project, e);
    }
    return reachable.isReachableFrom(state, repo, commit, repo.getAllRefs());
}
#method_after
public boolean canRead(ProjectState state, Repository repo, RevCommit commit) {
    Project.NameKey project = state.getNameKey();
    // Look for changes associated with the commit.
    try {
        List<ChangeData> changes = queryProvider.get().enforceVisibility(true).byProjectCommit(project, commit);
        if (!changes.isEmpty()) {
            return true;
        }
    } catch (OrmException e) {
        log.error("Cannot look up change for commit " + commit.name() + " in " + project, e);
    }
    return reachable.fromRefs(state, repo, commit, repo.getAllRefs());
}
#end_block

#method_before
boolean isReachableFromHeadsOrTags(Repository repo, RevCommit commit) {
    try {
        RefDatabase refdb = repo.getRefDatabase();
        Collection<Ref> heads = refdb.getRefs(Constants.R_HEADS).values();
        Collection<Ref> tags = refdb.getRefs(Constants.R_TAGS).values();
        Map<String, Ref> refs = Maps.newHashMapWithExpectedSize(heads.size() + tags.size());
        for (Ref r : Iterables.concat(heads, tags)) {
            refs.put(r.getName(), r);
        }
        return reachable.isReachableFrom(state, repo, commit, refs);
    } catch (IOException e) {
        log.error(String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), getProject().getNameKey()), e);
        return false;
    }
}
#method_after
boolean isReachableFromHeadsOrTags(Repository repo, RevCommit commit) {
    return reachable.fromHeadsOrTags(state, repo, commit);
}
#end_block

#method_before
public ChangeAttribute asChangeAttribute(ReviewDb db, Change change) {
    ChangeAttribute a = new ChangeAttribute();
    a.project = change.getProject().get();
    a.branch = change.getDest().getShortName();
    a.topic = change.getTopic();
    a.id = change.getKey().get();
    a.number = change.getId().get();
    a.subject = change.getSubject();
    try {
        a.commitMessage = changeDataFactory.create(db, change).commitMessage();
    } catch (Exception e) {
        log.error("Error while getting full commit message for change " + a.number);
    }
    a.url = getChangeUrl(change);
    a.owner = asAccountAttribute(change.getOwner());
    a.assignee = asAccountAttribute(change.getAssignee());
    a.status = change.getStatus();
    a.createdOn = change.getCreatedOn().getTime() / 1000L;
    a.isWip = change.isWorkInProgress() ? true : null;
    a.isPrivate = change.isPrivate() ? true : null;
    return a;
}
#method_after
public ChangeAttribute asChangeAttribute(ReviewDb db, Change change) {
    ChangeAttribute a = new ChangeAttribute();
    a.project = change.getProject().get();
    a.branch = change.getDest().getShortName();
    a.topic = change.getTopic();
    a.id = change.getKey().get();
    a.number = change.getId().get();
    a.subject = change.getSubject();
    try {
        a.commitMessage = changeDataFactory.create(db, change).commitMessage();
    } catch (Exception e) {
        log.error("Error while getting full commit message for change " + a.number);
    }
    a.url = getChangeUrl(change);
    a.owner = asAccountAttribute(change.getOwner());
    a.assignee = asAccountAttribute(change.getAssignee());
    a.status = change.getStatus();
    a.createdOn = change.getCreatedOn().getTime() / 1000L;
    a.wip = change.isWorkInProgress() ? true : null;
    a.isPrivate = change.isPrivate() ? true : null;
    return a;
}
#end_block

#method_before
private Set<Account> scanAccounts(ReviewDb db, ProgressMonitor pm) throws SQLException {
    Set<Map.Entry<String, AccountSetter>> fields = getFields(db);
    if (fields.isEmpty()) {
        return Collections.emptySet();
    }
    String query = fields.stream().map(f -> f.getKey()).collect(Collectors.joining(", ", "SELECT account_id, registered_on, ", String.format(" FROM %s", TABLE)));
    try (Statement stmt = newStatement(db);
        ResultSet rs = stmt.executeQuery(query)) {
        Set<Account> s = new HashSet<>();
        while (rs.next()) {
            Account a = new Account(new Account.Id(rs.getInt(1)), rs.getTimestamp(2));
            for (Map.Entry<String, AccountSetter> field : fields) {
                field.getValue().set(a, rs, field.getKey());
            }
            s.add(a);
            pm.update(1);
        }
        return s;
    }
}
#method_after
private Set<Account> scanAccounts(ReviewDb db, ProgressMonitor pm) throws SQLException {
    Map<String, AccountSetter> fields = getFields(db);
    if (fields.isEmpty()) {
        log.warn("Only account_id and registered_on fields are migrated for accounts");
    }
    List<String> queryFields = new ArrayList<>();
    queryFields.add("account_id");
    queryFields.add("registered_on");
    queryFields.addAll(fields.keySet());
    String query = "SELECT " + String.join(", ", queryFields) + String.format(" FROM %s", TABLE);
    try (Statement stmt = newStatement(db);
        ResultSet rs = stmt.executeQuery(query)) {
        Set<Account> s = new HashSet<>();
        while (rs.next()) {
            Account a = new Account(new Account.Id(rs.getInt(1)), rs.getTimestamp(2));
            for (Map.Entry<String, AccountSetter> field : fields.entrySet()) {
                field.getValue().set(a, rs, field.getKey());
            }
            s.add(a);
            pm.update(1);
        }
        return s;
    }
}
#end_block

#method_before
private Set<Map.Entry<String, AccountSetter>> getFields(ReviewDb db) throws SQLException {
    JdbcSchema schema = (JdbcSchema) db;
    Connection connection = schema.getConnection();
    Set<String> columns = schema.getDialect().listColumns(connection, TABLE);
    return ACCOUNT_FIELDS_MAP.entrySet().stream().filter(e -> columns.contains(e.getKey())).collect(Collectors.toSet());
}
#method_after
private Map<String, AccountSetter> getFields(ReviewDb db) throws SQLException {
    JdbcSchema schema = (JdbcSchema) db;
    Connection connection = schema.getConnection();
    Set<String> columns = schema.getDialect().listColumns(connection, TABLE);
    return ACCOUNT_FIELDS_MAP.entrySet().stream().filter(e -> columns.contains(e.getKey())).collect(toMap(Map.Entry::getKey, Map.Entry::getValue));
}
#end_block

#method_before
private void collectPluginCapabilities(Map<String, CapabilityInfo> output) {
    for (String pluginName : pluginCapabilities.plugins()) {
        if (!isPluginNameSane(pluginName)) {
            log.warn(String.format("Plugin name %s must match [A-Za-z0-9-]+ to use capabilities;" + " rename the plugin", pluginName));
            continue;
        }
        for (Map.Entry<String, Provider<CapabilityDefinition>> entry : pluginCapabilities.byPlugin(pluginName).entrySet()) {
            String id = String.format("%s-%s", pluginName, entry.getKey());
            output.put(id, new CapabilityInfo(id, entry.getValue().get().getDescription()));
        }
    }
}
#method_after
private void collectPluginCapabilities(Map<String, CapabilityInfo> output) {
    for (String pluginName : pluginCapabilities.plugins()) {
        if (!PLUGIN_NAME_PATTERN.matcher(pluginName).matches()) {
            log.warn("Plugin name '{}' must match '{}' to use capabilities; rename the plugin", pluginName, PLUGIN_NAME_PATTERN.pattern());
            continue;
        }
        for (Map.Entry<String, Provider<CapabilityDefinition>> entry : pluginCapabilities.byPlugin(pluginName).entrySet()) {
            String id = String.format("%s-%s", pluginName, entry.getKey());
            output.put(id, new CapabilityInfo(id, entry.getValue().get().getDescription()));
        }
    }
}
#end_block

#method_before
public ConfigInfo apply(ProjectState projectState, ConfigInput input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    Project.NameKey projectName = projectState.getNameKey();
    if (input == null) {
        throw new BadRequestException("config is required");
    }
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(projectName)) {
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setDescription(Strings.emptyToNull(input.description));
        if (input.useContributorAgreements != null) {
            p.setUseContributorAgreements(input.useContributorAgreements);
        }
        if (input.useContentMerge != null) {
            p.setUseContentMerge(input.useContentMerge);
        }
        if (input.useSignedOffBy != null) {
            p.setUseSignedOffBy(input.useSignedOffBy);
        }
        if (input.createNewChangeForAllNotInTarget != null) {
            p.setCreateNewChangeForAllNotInTarget(input.createNewChangeForAllNotInTarget);
        }
        if (input.requireChangeId != null) {
            p.setRequireChangeID(input.requireChangeId);
        }
        if (serverEnableSignedPush) {
            if (input.enableSignedPush != null) {
                p.setEnableSignedPush(input.enableSignedPush);
            }
            if (input.requireSignedPush != null) {
                p.setRequireSignedPush(input.requireSignedPush);
            }
        }
        if (input.rejectImplicitMerges != null) {
            p.setRejectImplicitMerges(input.rejectImplicitMerges);
        }
        if (input.privateByDefault != null) {
            p.setPrivateByDefault(input.privateByDefault);
        }
        if (input.maxObjectSizeLimit != null) {
            p.setMaxObjectSizeLimit(input.maxObjectSizeLimit);
        }
        if (input.submitType != null) {
            p.setSubmitType(input.submitType);
        }
        if (input.state != null) {
            p.setState(input.state);
        }
        if (input.enableReviewerByEmail != null) {
            p.setEnableReviewerByEmail(input.enableReviewerByEmail);
        }
        if (input.matchAuthorToCommitterDate != null) {
            p.setMatchAuthorToCommitterDate(input.matchAuthorToCommitterDate);
        }
        if (input.pluginConfigValues != null) {
            setPluginConfigValues(projectState, projectConfig, input.pluginConfigValues);
        }
        md.setMessage("Modified project settings\n");
        try {
            projectConfig.commit(md);
            projectCache.evict(projectConfig.getProject());
            md.getRepository().setGitwebDescription(p.getDescription());
        } catch (IOException e) {
            if (e.getCause() instanceof ConfigInvalidException) {
                throw new ResourceConflictException("Cannot update " + projectName + ": " + e.getCause().getMessage());
            }
            log.warn(String.format("Failed to update config of project %s.", projectName), e);
            throw new ResourceConflictException("Cannot update " + projectName);
        }
        ProjectState state = projectStateFactory.create(projectConfig);
        return new ConfigInfoImpl(serverEnableSignedPush, state, user.get(), config, pluginConfigEntries, cfgFactory, allProjects, uiActions, views);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update project " + projectName, err);
    }
}
#method_after
public ConfigInfo apply(ProjectState projectState, ConfigInput input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    Project.NameKey projectName = projectState.getNameKey();
    if (input == null) {
        throw new BadRequestException("config is required");
    }
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(projectName)) {
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setDescription(Strings.emptyToNull(input.description));
        for (BooleanProjectConfig cfg : BooleanProjectConfig.values()) {
            InheritableBoolean val = BooleanProjectConfigTransformations.get(cfg, input);
            if (val != null) {
                p.setBooleanConfig(cfg, val);
            }
        }
        if (input.maxObjectSizeLimit != null) {
            p.setMaxObjectSizeLimit(input.maxObjectSizeLimit);
        }
        if (input.submitType != null) {
            p.setSubmitType(input.submitType);
        }
        if (input.state != null) {
            p.setState(input.state);
        }
        if (input.pluginConfigValues != null) {
            setPluginConfigValues(projectState, projectConfig, input.pluginConfigValues);
        }
        md.setMessage("Modified project settings\n");
        try {
            projectConfig.commit(md);
            projectCache.evict(projectConfig.getProject());
            md.getRepository().setGitwebDescription(p.getDescription());
        } catch (IOException e) {
            if (e.getCause() instanceof ConfigInvalidException) {
                throw new ResourceConflictException("Cannot update " + projectName + ": " + e.getCause().getMessage());
            }
            log.warn(String.format("Failed to update config of project %s.", projectName), e);
            throw new ResourceConflictException("Cannot update " + projectName);
        }
        ProjectState state = projectStateFactory.create(projectConfig);
        return new ConfigInfoImpl(serverEnableSignedPush, state, user.get(), config, pluginConfigEntries, cfgFactory, allProjects, uiActions, views);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update project " + projectName, err);
    }
}
#end_block

#method_before
private void setPluginConfigValues(ProjectState projectState, ProjectConfig projectConfig, Map<String, Map<String, ConfigValue>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, ConfigValue>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, ConfigValue> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                String oldValue = cfg.getString(v.getKey());
                String value = v.getValue().value;
                if (projectConfigEntry.getType() == ProjectConfigEntryType.ARRAY) {
                    List<String> l = Arrays.asList(cfg.getStringList(v.getKey()));
                    oldValue = Joiner.on("\n").join(l);
                    value = Joiner.on("\n").join(v.getValue().values);
                }
                if (Strings.emptyToNull(value) != null) {
                    if (!value.equals(oldValue)) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, v.getKey(), pluginName);
                        v.setValue(projectConfigEntry.preUpdate(v.getValue()));
                        value = v.getValue().value;
                        try {
                            switch(projectConfigEntry.getType()) {
                                case BOOLEAN:
                                    boolean newBooleanValue = Boolean.parseBoolean(value);
                                    cfg.setBoolean(v.getKey(), newBooleanValue);
                                    break;
                                case INT:
                                    int newIntValue = Integer.parseInt(value);
                                    cfg.setInt(v.getKey(), newIntValue);
                                    break;
                                case LONG:
                                    long newLongValue = Long.parseLong(value);
                                    cfg.setLong(v.getKey(), newLongValue);
                                    break;
                                case LIST:
                                    if (!projectConfigEntry.getPermittedValues().contains(value)) {
                                        throw new BadRequestException(String.format("The value '%s' is not permitted for parameter '%s' of plugin '" + pluginName + "'", value, v.getKey()));
                                    }
                                // $FALL-THROUGH$
                                case STRING:
                                    cfg.setString(v.getKey(), value);
                                    break;
                                case ARRAY:
                                    cfg.setStringList(v.getKey(), v.getValue().values);
                                    break;
                                default:
                                    log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.getKey()));
                            }
                        } catch (NumberFormatException ex) {
                            throw new BadRequestException(String.format("The value '%s' of config parameter '%s' of plugin '%s' is invalid: %s", v.getValue(), v.getKey(), pluginName, ex.getMessage()));
                        }
                    }
                } else {
                    if (oldValue != null) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, v.getKey(), pluginName);
                        cfg.unset(v.getKey());
                    }
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#method_after
private void setPluginConfigValues(ProjectState projectState, ProjectConfig projectConfig, Map<String, Map<String, ConfigValue>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, ConfigValue>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, ConfigValue> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!PARAMETER_NAME_PATTERN.matcher(v.getKey()).matches()) {
                    // TODO check why we have this restriction
                    log.warn("Parameter name '{}' must match '{}'", v.getKey(), PARAMETER_NAME_PATTERN.pattern());
                    continue;
                }
                String oldValue = cfg.getString(v.getKey());
                String value = v.getValue().value;
                if (projectConfigEntry.getType() == ProjectConfigEntryType.ARRAY) {
                    List<String> l = Arrays.asList(cfg.getStringList(v.getKey()));
                    oldValue = Joiner.on("\n").join(l);
                    value = Joiner.on("\n").join(v.getValue().values);
                }
                if (Strings.emptyToNull(value) != null) {
                    if (!value.equals(oldValue)) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, v.getKey(), pluginName);
                        v.setValue(projectConfigEntry.preUpdate(v.getValue()));
                        value = v.getValue().value;
                        try {
                            switch(projectConfigEntry.getType()) {
                                case BOOLEAN:
                                    boolean newBooleanValue = Boolean.parseBoolean(value);
                                    cfg.setBoolean(v.getKey(), newBooleanValue);
                                    break;
                                case INT:
                                    int newIntValue = Integer.parseInt(value);
                                    cfg.setInt(v.getKey(), newIntValue);
                                    break;
                                case LONG:
                                    long newLongValue = Long.parseLong(value);
                                    cfg.setLong(v.getKey(), newLongValue);
                                    break;
                                case LIST:
                                    if (!projectConfigEntry.getPermittedValues().contains(value)) {
                                        throw new BadRequestException(String.format("The value '%s' is not permitted for parameter '%s' of plugin '" + pluginName + "'", value, v.getKey()));
                                    }
                                // $FALL-THROUGH$
                                case STRING:
                                    cfg.setString(v.getKey(), value);
                                    break;
                                case ARRAY:
                                    cfg.setStringList(v.getKey(), v.getValue().values);
                                    break;
                                default:
                                    log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.getKey()));
                            }
                        } catch (NumberFormatException ex) {
                            throw new BadRequestException(String.format("The value '%s' of config parameter '%s' of plugin '%s' is invalid: %s", v.getValue(), v.getKey(), pluginName, ex.getMessage()));
                        }
                    }
                } else {
                    if (oldValue != null) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, v.getKey(), pluginName);
                        cfg.unset(v.getKey());
                    }
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#end_block

#method_before
private void autoCloseChanges(ReceiveCommand cmd) {
    logDebug("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectState.getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        ListMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        int existingPatchSets = 0;
        int newPatchSets = 0;
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                existingPatchSets++;
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    newPatchSets++;
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                logDebug("Not closing {} because validation failed", id);
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        logDebug("Auto-closing {} changes with existing patch sets and {} with new patch sets", existingPatchSets, newPatchSets);
        bu.execute();
    } catch (RestApiException e) {
        logError("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException | PermissionBackendException e) {
        logError("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(ReceiveCommand cmd) {
    logDebug("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectState.getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        ListMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        int existingPatchSets = 0;
        int newPatchSets = 0;
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                Optional<ChangeData> cd = byLegacyId(psId.getParentKey());
                if (cd.isPresent() && cd.get().change().getDest().equals(branch)) {
                    existingPatchSets++;
                    bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                    continue COMMIT;
                }
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByKeyByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    newPatchSets++;
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                logDebug("Not closing {} because validation failed", id);
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        logDebug("Auto-closing {} changes with existing patch sets and {} with new patch sets", existingPatchSets, newPatchSets);
        bu.execute();
    } catch (RestApiException e) {
        logError("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException | PermissionBackendException e) {
        logError("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
public static void set(BooleanProjectConfig cfg, ConfigInfo info, InheritedBooleanInfo val) {
    TO_API.get(cfg).apply(info, val);
}
#method_after
public static void set(BooleanProjectConfig cfg, ConfigInfo info, InheritedBooleanInfo val) {
    MAPPER.get(cfg).set(info, val);
}
#end_block

#method_before
public static InheritableBoolean get(BooleanProjectConfig cfg, ConfigInput input) {
    return FROM_API.get(cfg).apply(input);
}
#method_after
public static InheritableBoolean get(BooleanProjectConfig cfg, ConfigInput input) {
    return MAPPER.get(cfg).get(input);
}
#end_block

#method_before
protected void fail(@Nullable String format, Object... args) throws Exception {
    assert_().fail(format, args);
}
#method_after
protected void fail(@Nullable String format, Object... args) {
    assert_().fail(format, args);
}
#end_block

#method_before
protected void fail() throws Exception {
    assert_().fail();
}
#method_after
protected void fail() {
    assert_().fail();
}
#end_block

#method_before
private String getProtocolStack(Config cfg, SitePaths site) {
    String location = cfg.getString(JGROUPS_SECTION, null, PROTOCOL_STACK_KEY);
    if (location == null) {
        return null;
    }
    Path p = Paths.get(location);
    if (p.isAbsolute()) {
        return location;
    }
    return site.etc_dir.resolve(location).toString();
}
#method_after
private Optional<Path> getProtocolStack(Config cfg, SitePaths site) {
    String location = cfg.getString(JGROUPS_SECTION, null, PROTOCOL_STACK_KEY);
    return location == null ? Optional.empty() : Optional.of(site.etc_dir.resolve(location));
}
#end_block

#method_before
public String protocolStack() {
    return protocolStack;
}
#method_after
public Optional<Path> protocolStack() {
    return protocolStack;
}
#end_block

#method_before
public void connect() {
    try {
        channel = getChannel();
        Optional<InetAddress> address = finder.findAddress();
        if (address.isPresent()) {
            log.debug("Protocol stack: " + channel.getProtocolStack());
            channel.getProtocolStack().getTransport().setBindAddress(address.get());
            log.debug("Channel bound to {}", address.get());
        } else {
            log.warn("Channel not bound: address not present");
        }
        channel.setReceiver(this);
        channel.setDiscardOwnMessages(true);
        channel.connect(jgroupsConfig.clusterName());
        log.info("Channel {} successfully joined jgroups cluster {}", channel.getName(), jgroupsConfig.clusterName());
    } catch (Exception e) {
        log.error("joining cluster {} for channel {} failed", jgroupsConfig.clusterName(), channel.getName(), e);
    }
}
#method_after
public void connect() {
    try {
        channel = getChannel();
        Optional<InetAddress> address = finder.findAddress();
        if (address.isPresent()) {
            log.debug("Protocol stack: " + channel.getProtocolStack());
            channel.getProtocolStack().getTransport().setBindAddress(address.get());
            log.debug("Channel bound to {}", address.get());
        } else {
            log.warn("Channel not bound: address not present");
        }
        channel.setReceiver(this);
        channel.setDiscardOwnMessages(true);
        channel.connect(jgroupsConfig.clusterName());
        log.info("Channel {} successfully joined jgroups cluster {}", channel.getName(), jgroupsConfig.clusterName());
    } catch (Exception e) {
        if (channel != null) {
            log.error("joining cluster {} (channel {}) failed", jgroupsConfig.clusterName(), channel.getName(), e);
        } else {
            log.error("joining cluster {} failed", jgroupsConfig.clusterName(), e);
        }
    }
}
#end_block

#method_before
private JChannel getChannel() {
    String protocolStack = "";
    try {
        protocolStack = jgroupsConfig.protocolStack();
        return protocolStack == null ? new JChannel() : new JChannel(protocolStack);
    } catch (Exception e) {
        log.error("Unable to create a new channel with {}", protocolStack, e);
        return null;
    }
}
#method_after
private JChannel getChannel() throws Exception {
    Optional<Path> protocolStack = jgroupsConfig.protocolStack();
    try {
        return protocolStack.isPresent() ? new JChannel(protocolStack.get().toString()) : new JChannel();
    } catch (Exception e) {
        log.error("Unable to create a channel with protocol stack: {}", protocolStack == null ? "default" : protocolStack, e);
        throw e;
    }
}
#end_block

#method_before
@Override
public void stop() {
    log.info("closing jgroups channel {} (cluster {})", channel.getName(), jgroupsConfig.clusterName());
    channel.close();
    peerInfo = Optional.empty();
    peerAddress = null;
}
#method_after
@Override
public void stop() {
    if (channel != null) {
        log.info("closing jgroups channel {} (cluster {})", channel.getName(), jgroupsConfig.clusterName());
        channel.close();
    }
    peerInfo = Optional.empty();
    peerAddress = null;
}
#end_block

#method_before
public List<ChangeNotes> find(String id) throws OrmException {
    if (id.isEmpty()) {
        return Collections.emptyList();
    }
    int z = id.lastIndexOf('~');
    int y = id.lastIndexOf('~', z - 1);
    if (y < 0 && z > 0) {
        // Try project~numericChangeId
        Integer n = Ints.tryParse(id.substring(z + 1));
        if (n != null) {
            changeIdCounter.increment(ChangeId.PROJECT_NUMERIC_ID);
            return fromProjectNumber(id.substring(0, z), n.intValue());
        }
    }
    if (y < 0 && z < 0) {
        // Try numeric changeId
        Integer n = Ints.tryParse(id);
        if (n != null) {
            changeIdCounter.increment(ChangeId.NUMERIC_ID);
            return find(new Change.Id(n));
        }
    }
    // Use the index to search for changes, but don't return any stored fields,
    // to force rereading in case the index is stale.
    InternalChangeQuery query = queryProvider.get().noFields();
    // Try commit hash
    if (id.matches("^([0-9a-fA-F]{" + RevId.ABBREV_LEN + "," + RevId.LEN + "})$")) {
        changeIdCounter.increment(ChangeId.COMMIT_HASH);
        return asChangeNotes(query.byCommit(id));
    }
    if (y > 0 && z > 0) {
        // Try change triplet (project~branch~Ihash...)
        Optional<ChangeTriplet> triplet = ChangeTriplet.parse(id, y, z);
        if (triplet.isPresent()) {
            ChangeTriplet t = triplet.get();
            changeIdCounter.increment(ChangeId.TRIPLET);
            return asChangeNotes(query.byBranchKey(t.branch(), t.id()));
        }
    }
    // Try isolated Ihash... format ("Change-Id: Ihash").
    List<ChangeNotes> notes = asChangeNotes(query.byKeyPrefix(id));
    if (!notes.isEmpty()) {
        changeIdCounter.increment(ChangeId.CHANGE_ID);
    }
    return notes;
}
#method_after
public List<ChangeNotes> find(String id) throws OrmException {
    if (id.isEmpty()) {
        return Collections.emptyList();
    }
    int z = id.lastIndexOf('~');
    int y = id.lastIndexOf('~', z - 1);
    if (y < 0 && z > 0) {
        // Try project~numericChangeId
        Integer n = Ints.tryParse(id.substring(z + 1));
        if (n != null) {
            changeIdCounter.increment(ChangeIdType.PROJECT_NUMERIC_ID);
            return fromProjectNumber(id.substring(0, z), n.intValue());
        }
    }
    if (y < 0 && z < 0) {
        // Try numeric changeId
        Integer n = Ints.tryParse(id);
        if (n != null) {
            changeIdCounter.increment(ChangeIdType.NUMERIC_ID);
            return find(new Change.Id(n));
        }
    }
    // Use the index to search for changes, but don't return any stored fields,
    // to force rereading in case the index is stale.
    InternalChangeQuery query = queryProvider.get().noFields();
    // Try commit hash
    if (id.matches("^([0-9a-fA-F]{" + RevId.ABBREV_LEN + "," + RevId.LEN + "})$")) {
        changeIdCounter.increment(ChangeIdType.COMMIT_HASH);
        return asChangeNotes(query.byCommit(id));
    }
    if (y > 0 && z > 0) {
        // Try change triplet (project~branch~Ihash...)
        Optional<ChangeTriplet> triplet = ChangeTriplet.parse(id, y, z);
        if (triplet.isPresent()) {
            ChangeTriplet t = triplet.get();
            changeIdCounter.increment(ChangeIdType.TRIPLET);
            return asChangeNotes(query.byBranchKey(t.branch(), t.id()));
        }
    }
    // Try isolated Ihash... format ("Change-Id: Ihash").
    List<ChangeNotes> notes = asChangeNotes(query.byKeyPrefix(id));
    if (!notes.isEmpty()) {
        changeIdCounter.increment(ChangeIdType.CHANGE_ID);
    }
    return notes;
}
#end_block

#method_before
private void setUp(Object target) throws Exception {
    injector = Guice.createInjector(new InMemoryModule());
    injector.injectMembers(this);
    lifecycle = new LifecycleManager();
    lifecycle.add(injector);
    lifecycle.start();
    try (ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) {
        schemaCreator.create(underlyingDb);
    }
    db = schemaFactory.open();
    setApiUser(accountManager.authenticate(AuthRequest.forUser("user")).getAccountId());
    // Inject target members after setting API user, so it can @Inject a ReviewDb if it wants.
    injector.injectMembers(target);
}
#method_after
private void setUp(Object target) throws Exception {
    Injector injector = Guice.createInjector(new InMemoryModule());
    injector.injectMembers(this);
    lifecycle = new LifecycleManager();
    lifecycle.add(injector);
    lifecycle.start();
    try (ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) {
        schemaCreator.create(underlyingDb);
    }
    db = schemaFactory.open();
    setApiUser(accountManager.authenticate(AuthRequest.forUser("user")).getAccountId());
    // Inject target members after setting API user, so it can @Inject a ReviewDb if it wants.
    injector.injectMembers(target);
}
#end_block

#method_before
@Nullable
public Optional<Account> getLoadedAccount() {
    checkLoaded();
    return loadedAccount;
}
#method_after
public Optional<Account> getLoadedAccount() {
    checkLoaded();
    return loadedAccount;
}
#end_block

#method_before
public void setAccount(Account account) {
    checkLoaded();
    this.loadedAccount = Optional.of(checkNotNull(account));
    this.registeredOn = account.getRegisteredOn();
}
#method_after
public void setAccount(Account account) {
    checkLoaded();
    this.loadedAccount = Optional.of(account);
    this.registeredOn = account.getRegisteredOn();
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    if (revision != null) {
        rw.reset();
        rw.markStart(revision);
        rw.sort(RevSort.REVERSE);
        registeredOn = new Timestamp(rw.next().getCommitTime() * 1000L);
        Config cfg = readConfig(ACCOUNT_CONFIG);
        loadedAccount = Optional.of(parse(cfg, revision.name()));
    }
    isLoaded = true;
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    if (revision != null) {
        rw.reset();
        rw.markStart(revision);
        rw.sort(RevSort.REVERSE);
        registeredOn = new Timestamp(rw.next().getCommitTime() * 1000L);
        Config cfg = readConfig(ACCOUNT_CONFIG);
        loadedAccount = Optional.of(parse(cfg, revision.name()));
    } else {
        loadedAccount = Optional.empty();
    }
}
#end_block

#method_before
private void checkLoaded() {
    checkState(isLoaded, "Account %s not loaded yet", accountId.get());
}
#method_after
private void checkLoaded() {
    checkState(loadedAccount != null, "Account %s not loaded yet", accountId.get());
}
#end_block

#method_before
private SiteIndexer.Result reindexGroups(GroupIndex index, List<AccountGroup.UUID> uuids, ProgressMonitor progress) {
    progress.beginTask("Reindexing groups", uuids.size());
    List<ListenableFuture<?>> futures = new ArrayList<>(uuids.size());
    AtomicBoolean ok = new AtomicBoolean(true);
    AtomicInteger done = new AtomicInteger();
    AtomicInteger failed = new AtomicInteger();
    Stopwatch sw = Stopwatch.createStarted();
    for (AccountGroup.UUID uuid : uuids) {
        String desc = "group " + uuid;
        ListenableFuture<?> future = executor.submit(() -> {
            try {
                Optional<InternalGroup> oldGroup = groupCache.get(uuid);
                if (oldGroup.isPresent()) {
                    InternalGroup group = oldGroup.get();
                    groupCache.evict(group.getGroupUUID(), group.getId(), group.getNameKey());
                } else {
                    // The UUID here is read from group name notes. If it fails to load from group
                    // cache, there exists an inconsistency.
                    GroupsNoteDbConsistencyChecker.logConsistencyProblemAsWarning("Group with UUID %s from group name notes is failed to load from group ref", uuid);
                }
                Optional<InternalGroup> internalGroup = groupCache.get(uuid);
                if (internalGroup.isPresent()) {
                    index.replace(internalGroup.get());
                } else {
                    index.delete(uuid);
                }
                verboseWriter.println("Reindexed " + desc);
                done.incrementAndGet();
            } catch (Exception e) {
                failed.incrementAndGet();
                throw e;
            }
            return null;
        });
        addErrorListener(future, desc, progress, ok);
        futures.add(future);
    }
    try {
        Futures.successfulAsList(futures).get();
    } catch (ExecutionException | InterruptedException e) {
        log.error("Error waiting on group futures", e);
        return new SiteIndexer.Result(sw, false, 0, 0);
    }
    progress.endTask();
    return new SiteIndexer.Result(sw, ok.get(), done.get(), failed.get());
}
#method_after
private SiteIndexer.Result reindexGroups(GroupIndex index, List<AccountGroup.UUID> uuids, ProgressMonitor progress) {
    progress.beginTask("Reindexing groups", uuids.size());
    List<ListenableFuture<?>> futures = new ArrayList<>(uuids.size());
    AtomicBoolean ok = new AtomicBoolean(true);
    AtomicInteger done = new AtomicInteger();
    AtomicInteger failed = new AtomicInteger();
    Stopwatch sw = Stopwatch.createStarted();
    for (AccountGroup.UUID uuid : uuids) {
        String desc = "group " + uuid;
        ListenableFuture<?> future = executor.submit(() -> {
            try {
                Optional<InternalGroup> oldGroup = groupCache.get(uuid);
                if (oldGroup.isPresent()) {
                    InternalGroup group = oldGroup.get();
                    groupCache.evict(group.getGroupUUID(), group.getId(), group.getNameKey());
                }
                Optional<InternalGroup> internalGroup = groupCache.get(uuid);
                if (internalGroup.isPresent()) {
                    index.replace(internalGroup.get());
                } else {
                    index.delete(uuid);
                    // The UUID here is read from group name notes. If it fails to load from group
                    // cache, there exists an inconsistency.
                    GroupsNoteDbConsistencyChecker.logFailToLoadFromGroupRefAsWarning(uuid);
                }
                verboseWriter.println("Reindexed " + desc);
                done.incrementAndGet();
            } catch (Exception e) {
                failed.incrementAndGet();
                throw e;
            }
            return null;
        });
        addErrorListener(future, desc, progress, ok);
        futures.add(future);
    }
    try {
        Futures.successfulAsList(futures).get();
    } catch (ExecutionException | InterruptedException e) {
        log.error("Error waiting on group futures", e);
        return new SiteIndexer.Result(sw, false, 0, 0);
    }
    progress.endTask();
    return new SiteIndexer.Result(sw, ok.get(), done.get(), failed.get());
}
#end_block

#method_before
public static List<ConsistencyProblemInfo> checkWithGroupNameNotes(Repository allUsersRepo, String name, AccountGroup.UUID uuid) {
    try {
        Ref ref = allUsersRepo.exactRef(RefNames.REFS_GROUPNAMES);
        if (ref == null) {
            return Arrays.asList(warning("ref %s does not exist", RefNames.REFS_GROUPNAMES));
        }
        try (RevWalk revWalk = new RevWalk(allUsersRepo);
            ObjectReader reader = revWalk.getObjectReader()) {
            RevCommit notesCommit = revWalk.parseCommit(ref.getObjectId());
            NoteMap noteMap = NoteMap.read(reader, notesCommit);
            ObjectId noteDataBlobId = noteMap.get(GroupNameNotes.getNoteKey(new AccountGroup.NameKey(name)));
            if (noteDataBlobId == null) {
                return Arrays.asList(warning("Group with name '%s' doesn't exist in the list of all names", name));
            }
            List<ConsistencyProblemInfo> problems = new ArrayList<>();
            GroupReference groupRef = getGroupReference(reader, noteDataBlobId);
            if (!Objects.equals(uuid, groupRef.getUUID())) {
                problems.add(warning("group with name '%s' has UUID '%s' in 'group.config' while '%s' in group name notes", name, uuid, groupRef.getUUID()));
            }
            if (!Objects.equals(name, groupRef.getName())) {
                problems.add(warning("group with UUID '%s' has name '%s' in 'group.config' while '%s' in group name notes", uuid, name, groupRef.getName()));
            }
            return problems;
        }
    } catch (IOException | ConfigInvalidException e) {
        return Arrays.asList(warning("fail to check consistency with group name notes"));
    }
}
#method_after
@VisibleForTesting
static List<ConsistencyProblemInfo> checkWithGroupNameNotes(Repository allUsersRepo, String groupName, AccountGroup.UUID groupUUID) throws IOException {
    try {
        Optional<GroupReference> groupRef = GroupNameNotes.loadOneGroupReference(allUsersRepo, groupName);
        if (!groupRef.isPresent()) {
            return ImmutableList.of(warning("Group with name '%s' doesn't exist in the list of all names", groupName));
        }
        AccountGroup.UUID uuid = groupRef.get().getUUID();
        String name = groupRef.get().getName();
        List<ConsistencyProblemInfo> problems = new ArrayList<>();
        if (!Objects.equals(groupUUID, uuid)) {
            problems.add(warning("group with name '%s' has UUID '%s' in 'group.config' but '%s' in group name notes", groupName, groupUUID, uuid));
        }
        if (!Objects.equals(groupName, name)) {
            problems.add(warning("group note of name '%s' claims to represent name of '%s'", groupName, name));
        }
        return problems;
    } catch (ConfigInvalidException e) {
        return ImmutableList.of(warning("fail to check consistency with group name notes: %s", e.getMessage()));
    }
}
#end_block

#method_before
public static void logConsistencyProblem(ConsistencyProblemInfo p) {
    if (p.status == ConsistencyProblemInfo.Status.WARNING) {
        log.warn(GROUP_CONSISTENCY_CHECK_LOG_PREFIX + p.message);
    } else {
        log.error(GROUP_CONSISTENCY_CHECK_LOG_PREFIX + p.message);
    }
}
#method_after
public static void logConsistencyProblem(ConsistencyProblemInfo p) {
    if (p.status == ConsistencyProblemInfo.Status.WARNING) {
        log.warn(p.message);
    } else {
        log.error(p.message);
    }
}
#end_block

#method_before
@Override
public int run() throws Exception {
    Injector dbInjector = createDbInjector(DataSourceProvider.Context.SINGLE_USER);
    SitePaths sitePaths = new SitePaths(getSitePath());
    ThreadSettingsConfig threadSettingsConfig = dbInjector.getInstance(ThreadSettingsConfig.class);
    Config fakeCfg = new Config();
    if (!Strings.isNullOrEmpty(sourceUrl)) {
        fakeCfg.setString("accountPatchReviewDb", null, "url", sourceUrl);
    }
    JdbcAccountPatchReviewStore sourceJdbcAccountPatchReviewStore = JdbcAccountPatchReviewStore.createAccountPatchReviewStore(fakeCfg, sitePaths, threadSettingsConfig);
    Config cfg = dbInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
    String targetUrl = cfg.getString("accountPatchReviewDb", null, "url");
    if (targetUrl == null) {
        System.err.println("accountPatchReviewDb.url is null in gerrit.config");
        return 1;
    }
    System.out.println("target Url: " + targetUrl);
    JdbcAccountPatchReviewStore targetJdbcAccountPatchReviewStore = JdbcAccountPatchReviewStore.createAccountPatchReviewStore(cfg, sitePaths, threadSettingsConfig);
    targetJdbcAccountPatchReviewStore.createTableIfNotExists();
    if (!isTargetTableEmpty(targetJdbcAccountPatchReviewStore)) {
        System.err.println("target table is not empty, cannot proceed");
        return 1;
    }
    try (Connection sourceCon = sourceJdbcAccountPatchReviewStore.getConnection();
        Connection targetCon = targetJdbcAccountPatchReviewStore.getConnection();
        PreparedStatement sourceStmt = sourceCon.prepareStatement("SELECT account_id, change_id, patch_set_id, file_name " + "FROM account_patch_reviews " + "LIMIT ? " + "OFFSET ?");
        PreparedStatement targetStmt = targetCon.prepareStatement("INSERT INTO account_patch_reviews " + "(account_id, change_id, patch_set_id, file_name_sha1, file_name) VALUES " + "(?, ?, ?, ?, ?)")) {
        targetCon.setAutoCommit(false);
        long offset = 0;
        List<Row> rows = selectRows(sourceStmt, offset);
        while (!rows.isEmpty()) {
            insertRows(targetCon, targetStmt, rows);
            offset += rows.size();
            System.out.printf("%8d rows migrated\n", offset);
            rows = selectRows(sourceStmt, offset);
        }
        System.out.println("Done");
    }
    return 0;
}
#method_after
@Override
public int run() throws Exception {
    Injector dbInjector = createDbInjector(DataSourceProvider.Context.SINGLE_USER);
    SitePaths sitePaths = new SitePaths(getSitePath());
    ThreadSettingsConfig threadSettingsConfig = dbInjector.getInstance(ThreadSettingsConfig.class);
    Config fakeCfg = new Config();
    if (!Strings.isNullOrEmpty(sourceUrl)) {
        fakeCfg.setString("accountPatchReviewDb", null, "url", sourceUrl);
    }
    JdbcAccountPatchReviewStore sourceJdbcAccountPatchReviewStore = JdbcAccountPatchReviewStore.createAccountPatchReviewStore(fakeCfg, sitePaths, threadSettingsConfig);
    Config cfg = dbInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
    String targetUrl = cfg.getString("accountPatchReviewDb", null, "url");
    if (targetUrl == null) {
        System.err.println("accountPatchReviewDb.url is null in gerrit.config");
        return 1;
    }
    System.out.println("target Url: " + targetUrl);
    JdbcAccountPatchReviewStore targetJdbcAccountPatchReviewStore = JdbcAccountPatchReviewStore.createAccountPatchReviewStore(cfg, sitePaths, threadSettingsConfig);
    targetJdbcAccountPatchReviewStore.createTableIfNotExists();
    if (!isTargetTableEmpty(targetJdbcAccountPatchReviewStore)) {
        System.err.println("target table is not empty, cannot proceed");
        return 1;
    }
    try (Connection sourceCon = sourceJdbcAccountPatchReviewStore.getConnection();
        Connection targetCon = targetJdbcAccountPatchReviewStore.getConnection();
        PreparedStatement sourceStmt = sourceCon.prepareStatement("SELECT account_id, change_id, patch_set_id, file_name " + "FROM account_patch_reviews " + "LIMIT ? " + "OFFSET ?");
        PreparedStatement targetStmt = targetCon.prepareStatement("INSERT INTO account_patch_reviews " + "(account_id, change_id, patch_set_id, file_name) VALUES " + "(?, ?, ?, ?)")) {
        targetCon.setAutoCommit(false);
        long offset = 0;
        List<Row> rows = selectRows(sourceStmt, offset);
        while (!rows.isEmpty()) {
            insertRows(targetCon, targetStmt, rows);
            offset += rows.size();
            System.out.printf("%8d rows migrated\n", offset);
            rows = selectRows(sourceStmt, offset);
        }
        System.out.println("Done");
    }
    return 0;
}
#end_block

#method_before
private static void insertRows(Connection con, PreparedStatement stmt, List<Row> rows) throws SQLException {
    for (Row r : rows) {
        stmt.setLong(1, r.accountId());
        stmt.setLong(2, r.changeId());
        stmt.setLong(3, r.patchSetId());
        stmt.setString(4, sha1(r.fileName()));
        stmt.setString(5, r.fileName());
        stmt.addBatch();
    }
    stmt.executeBatch();
    con.commit();
}
#method_after
private static void insertRows(Connection con, PreparedStatement stmt, List<Row> rows) throws SQLException {
    for (Row r : rows) {
        stmt.setLong(1, r.accountId());
        stmt.setLong(2, r.changeId());
        stmt.setLong(3, r.patchSetId());
        stmt.setString(4, r.fileName());
        stmt.addBatch();
    }
    stmt.executeBatch();
    con.commit();
}
#end_block

#method_before
private String getCommentChangeEvent(String action, String prefix, Map<String, String> map) {
    String ret = "";
    String changeNumber = Strings.nullToEmpty(map.get("changeNumber"));
    if (!changeNumber.isEmpty()) {
        changeNumber += " ";
    }
    ret += "Change " + changeNumber + action;
    String submitter = formatPerson(prefix, map);
    if (!submitter.isEmpty()) {
        ret += " by " + submitter;
    }
    String subject = Strings.nullToEmpty(map.get("subject"));
    if (!subject.isEmpty()) {
        ret += ":\n" + subject;
    }
    String reason = Strings.nullToEmpty(map.get("reason"));
    if (!reason.isEmpty()) {
        ret += "\n\nReason:\n" + reason;
    }
    String url = Strings.nullToEmpty(map.get("changeUrl"));
    if (!url.isEmpty()) {
        ret += "\n\n" + its.createLinkForWebui(url, url);
    }
    return ret;
}
#method_after
private String getCommentChangeEvent(String action, String prefix, Map<String, String> map) {
    String ret = "";
    String changeNumber = getValueFromMap(map, "", "change-number", "changeNumber");
    if (!changeNumber.isEmpty()) {
        changeNumber += " ";
    }
    ret += "Change " + changeNumber + action;
    String submitter = getValueFromMap(map, prefix, "-name", "Name", "-username", "Username");
    if (!submitter.isEmpty()) {
        ret += " by " + submitter;
    }
    String subject = Strings.nullToEmpty(map.get("subject"));
    if (!subject.isEmpty()) {
        ret += ":\n" + subject;
    }
    String reason = Strings.nullToEmpty(map.get("reason"));
    if (!reason.isEmpty()) {
        ret += "\n\nReason:\n" + reason;
    }
    String url = getValueFromMap(map, "", "change-url", "changeUrl");
    if (!url.isEmpty()) {
        ret += "\n\n" + its.createLinkForWebui(url, url);
    }
    return ret;
}
#end_block

#method_before
@Test
public void rebuild() throws Exception {
    assume().that(groupsMigration.writeToNoteDb()).isTrue();
    assume().that(groupsMigration.readFromNoteDb()).isFalse();
    GroupInfo g = gApi.groups().create(name("group")).get();
    AccountGroup.UUID uuid = new AccountGroup.UUID(g.id);
    String refName = RefNames.refsGroups(uuid);
    ObjectId oldId;
    GroupBundle oldBundle;
    try (Repository repo = repoManager.openRepository(allUsers)) {
        oldId = repo.exactRef(refName).getObjectId();
        oldBundle = bundleFactory.fromNoteDb(repo, uuid);
        new TestRepository<>(repo).delete(refName);
    }
    assertThat(adminRestSession.postOK("/groups/" + uuid + "/rebuild", "").getEntityContent()).isEqualTo("No differences between ReviewDb and NoteDb");
    try (Repository repo = repoManager.openRepository(allUsers)) {
        Ref ref = repo.exactRef(refName);
        assertThat(ref).isNotNull();
        // An artifact of the migration process makes the SHA-1 different, but it's actually ok
        // because the bundles are equal.
        assertThat(ref.getObjectId()).isNotEqualTo(oldId);
        // Comparing NoteDb to NoteDb, so compare fields instead of using static compare method.
        GroupBundle newBundle = bundleFactory.fromNoteDb(repo, uuid);
        assertThat(newBundle.group()).isEqualTo(oldBundle.group());
        assertThat(newBundle.members()).isEqualTo(oldBundle.members());
        assertThat(newBundle.memberAudit()).isEqualTo(oldBundle.memberAudit());
        assertThat(newBundle.byId()).isEqualTo(oldBundle.byId());
        assertThat(newBundle.byIdAudit()).isEqualTo(oldBundle.byIdAudit());
    }
}
#method_after
@Test
public void rebuild() throws Exception {
    assume().that(groupsMigration.writeToNoteDb()).isTrue();
    assume().that(groupsMigration.readFromNoteDb()).isFalse();
    GroupInfo g = gApi.groups().create(name("group")).get();
    AccountGroup.UUID uuid = new AccountGroup.UUID(g.id);
    String refName = RefNames.refsGroups(uuid);
    ObjectId oldId;
    GroupBundle oldBundle;
    try (Repository repo = repoManager.openRepository(allUsers)) {
        oldId = repo.exactRef(refName).getObjectId();
        oldBundle = bundleFactory.fromNoteDb(repo, uuid);
        new TestRepository<>(repo).delete(refName);
    }
    assertThat(adminRestSession.postOK("/groups/" + uuid + "/rebuild", input(null)).getEntityContent()).isEqualTo("No differences between ReviewDb and NoteDb");
    try (Repository repo = repoManager.openRepository(allUsers)) {
        Ref ref = repo.exactRef(refName);
        assertThat(ref).isNotNull();
        // An artifact of the migration process makes the SHA-1 different, but it's actually ok
        // because the bundles are equal.
        assertThat(ref.getObjectId()).isNotEqualTo(oldId);
        assertNoDifferences(oldBundle, bundleFactory.fromNoteDb(repo, uuid));
    }
}
#end_block

#method_before
@Override
public BinaryResult apply(GroupResource rsrc, Input input) throws RestApiException, ConfigInvalidException, OrmException, IOException {
    if (!migration.writeToNoteDb()) {
        throw new BadRequestException("NoteDb writes must be enabled");
    }
    if (!rsrc.isInternalGroup()) {
        throw new BadRequestException("not an internal group");
    }
    try (Repository repo = repoManager.openRepository(allUsers)) {
        GroupBundle reviewDbBundle = bundleFactory.fromReviewDb(db.get(), rsrc.asInternalGroup().get().getId());
        try {
            rebuilder.rebuild(repo, reviewDbBundle, null);
        } catch (LockFailureException e) {
            throw new ResourceConflictException("rebuild failed with lock failure");
        }
        repo.scanForRepoChanges();
        GroupBundle noteDbBundle = bundleFactory.fromNoteDb(repo, rsrc.getGroup().getGroupUUID());
        List<String> diffs = GroupBundle.compare(reviewDbBundle, noteDbBundle);
        if (diffs.isEmpty()) {
            return BinaryResult.create("No differences between ReviewDb and NoteDb");
        }
        return BinaryResult.create(diffs.stream().collect(joining("\n", "Differences between ReviewDb and NoteDb:\n", "\n")));
    }
}
#method_after
@Override
public BinaryResult apply(GroupResource rsrc, Input input) throws RestApiException, ConfigInvalidException, OrmException, IOException {
    boolean force = firstNonNull(input.force, false);
    if (!migration.writeToNoteDb()) {
        throw new MethodNotAllowedException("NoteDb writes must be enabled");
    }
    if (migration.readFromNoteDb() && force) {
        throw new MethodNotAllowedException("NoteDb reads must not be enabled when force=true");
    }
    if (!rsrc.isInternalGroup()) {
        throw new MethodNotAllowedException("Not an internal group");
    }
    AccountGroup.UUID uuid = rsrc.getGroup().getGroupUUID();
    try (Repository repo = repoManager.openRepository(allUsers)) {
        if (force) {
            RefUpdateUtil.deleteChecked(repo, RefNames.refsGroups(uuid));
        }
        GroupBundle reviewDbBundle = bundleFactory.fromReviewDb(db.get(), rsrc.asInternalGroup().get().getId());
        try {
            rebuilder.rebuild(repo, reviewDbBundle, null);
        } catch (OrmDuplicateKeyException e) {
            throw new ResourceConflictException("Group already exists in NoteDb");
        }
        GroupBundle noteDbBundle = bundleFactory.fromNoteDb(repo, uuid);
        List<String> diffs = GroupBundle.compare(reviewDbBundle, noteDbBundle);
        if (diffs.isEmpty()) {
            return BinaryResult.create("No differences between ReviewDb and NoteDb");
        }
        return BinaryResult.create(diffs.stream().collect(joining("\n", "Differences between ReviewDb and NoteDb:\n", "\n")));
    }
}
#end_block

#method_before
public String[] getIssueIds(String haystack) {
    Pattern pattern = itsConfig.getIssuePattern();
    if (pattern == null)
        return new String[] {};
    log.debug("Matching '" + haystack + "' against " + pattern.pattern());
    Set<String> issues = Sets.newHashSet();
    Matcher matcher = pattern.matcher(haystack);
    int groupIdx = itsConfig.getIssuePatternGroupIndex();
    while (matcher.find()) {
        String issueId = matcher.group(groupIdx);
        if (!Strings.isNullOrEmpty(issueId)) {
            issues.add(issueId);
        }
    }
    return issues.toArray(new String[issues.size()]);
}
#method_after
public String[] getIssueIds(String haystack) {
    Pattern pattern = itsConfig.getIssuePattern();
    if (pattern == null)
        return new String[] {};
    log.debug("Matching '{}' against {}", haystack, pattern.pattern());
    Set<String> issues = Sets.newHashSet();
    Matcher matcher = pattern.matcher(haystack);
    int groupIdx = itsConfig.getIssuePatternGroupIndex();
    while (matcher.find()) {
        String issueId = matcher.group(groupIdx);
        if (!Strings.isNullOrEmpty(issueId)) {
            issues.add(issueId);
        }
    }
    return issues.toArray(new String[issues.size()]);
}
#end_block

#method_before
@Test
@Sandboxed
public void putStatus() throws Exception {
    List<String> statuses = ImmutableList.of("OOO", "Busy");
    AccountInfo info;
    for (String status : statuses) {
        gApi.accounts().self().setStatus(status);
        info = gApi.accounts().self().get();
        assertUser(info, admin, status);
        accountIndexedCounter.assertReindexOf(admin);
    }
}
#method_after
@Test
public void putStatus() throws Exception {
    List<String> statuses = ImmutableList.of("OOO", "Busy");
    AccountInfo info;
    try {
        for (String status : statuses) {
            gApi.accounts().self().setStatus(status);
            info = gApi.accounts().self().get();
            assertUser(info, admin, status);
            accountIndexedCounter.assertReindexOf(admin);
        }
    } finally {
        gApi.accounts().self().setStatus(null);
        info = gApi.accounts().self().get();
        assertUser(info, admin);
        accountIndexedCounter.assertReindexOf(admin);
    }
}
#end_block

#method_before
public List<ConsistencyProblemInfo> check() throws OrmException, IOException {
    try (Repository repo = repoManager.openRepository(allUsersName)) {
        Map<AccountGroup.UUID, InternalGroup> groups = new HashMap<>();
        List<ConsistencyProblemInfo> problems = globalChecker.check(repo, groups);
        if (!problems.isEmpty()) {
            return problems;
        }
        for (InternalGroup g : groups.values()) {
            problems.addAll(checkGroup(g, groups));
        }
        return problems;
    }
}
#method_after
public List<ConsistencyProblemInfo> check() throws IOException {
    if (!groupsMigration.writeToNoteDb()) {
        return new ArrayList<>();
    }
    try (Repository repo = repoManager.openRepository(allUsersName)) {
        GroupsNoteDbConsistencyChecker.Result result = globalChecker.check(repo);
        if (!result.problems.isEmpty()) {
            return result.problems;
        }
        for (InternalGroup g : result.uuidToGroupMap.values()) {
            result.problems.addAll(checkGroup(g, result.uuidToGroupMap));
        }
        return result.problems;
    }
}
#end_block

#method_before
public List<ConsistencyProblemInfo> check(Repository repo, Map<AccountGroup.UUID, InternalGroup> byUUID) throws OrmException, IOException {
    if (!groupsMigration.writeToNoteDb()) {
        return new ArrayList<>();
    }
    // Get all refs in an attempt to avoid seeing half committed group updates.
    Map<String, Ref> refs = repo.getAllRefs();
    List<ConsistencyProblemInfo> problems = new ArrayList<>();
    BiMap<AccountGroup.UUID, String> nameMap = HashBiMap.create();
    readGroups(repo, refs, problems, byUUID);
    readGroupNames(repo, refs, problems, nameMap);
    // No use continuing if we couldn't read the data.
    if (!problems.isEmpty()) {
        return problems;
    }
    return checkGlobalConsistency(byUUID, nameMap);
}
#method_after
@Nullable
public Result check(Repository repo) throws IOException {
    if (!groupsMigration.writeToNoteDb()) {
        return null;
    }
    Result r = doCheck(repo);
    if (!r.problems.isEmpty()) {
        r.uuidToGroupMap = null;
    }
    return r;
}
#end_block

#method_before
private void readGroups(Repository repo, Map<String, Ref> refs, List<ConsistencyProblemInfo> problems, Map<AccountGroup.UUID, InternalGroup> byUUID) throws IOException {
    for (Map.Entry<String, Ref> entry : refs.entrySet()) {
        if (!entry.getKey().startsWith(RefNames.REFS_GROUPS)) {
            continue;
        }
        AccountGroup.UUID uuid = AccountGroup.UUID.fromRef(entry.getKey());
        if (uuid == null) {
            problems.add(error("null UUID from %s", entry.getKey()));
            continue;
        }
        try {
            GroupConfig cfg = GroupConfig.loadForGroupSnapshot(repo, uuid, entry.getValue().getObjectId());
            byUUID.put(uuid, cfg.getLoadedGroup().get());
        } catch (ConfigInvalidException e) {
            problems.add(error("group %s does not parse: %s", uuid, e.getMessage()));
        }
    }
}
#method_after
private void readGroups(Repository repo, Map<String, Ref> refs, Result result) throws IOException {
    for (Map.Entry<String, Ref> entry : refs.entrySet()) {
        if (!entry.getKey().startsWith(RefNames.REFS_GROUPS)) {
            continue;
        }
        AccountGroup.UUID uuid = AccountGroup.UUID.fromRef(entry.getKey());
        if (uuid == null) {
            result.problems.add(error("null UUID from %s", entry.getKey()));
            continue;
        }
        try {
            GroupConfig cfg = GroupConfig.loadForGroupSnapshot(repo, uuid, entry.getValue().getObjectId());
            result.uuidToGroupMap.put(uuid, cfg.getLoadedGroup().get());
        } catch (ConfigInvalidException e) {
            result.problems.add(error("group %s does not parse: %s", uuid, e.getMessage()));
        }
    }
}
#end_block

#method_before
private void readGroupNames(Repository repo, Map<String, Ref> refs, List<ConsistencyProblemInfo> problems, BiMap<AccountGroup.UUID, String> result) throws IOException {
    Ref ref = refs.get(RefNames.REFS_GROUPNAMES);
    if (ref == null) {
        problems.add(new ConsistencyProblemInfo(groupsMigration.readFromNoteDb() ? ConsistencyProblemInfo.Status.ERROR : ConsistencyProblemInfo.Status.WARNING, String.format("ref %s does not exist", RefNames.REFS_GROUPNAMES)));
        return;
    }
    try (RevWalk rw = new RevWalk(repo)) {
        NoteMap nm = NoteMap.read(rw.getObjectReader(), rw.parseCommit(ref.getObjectId()));
        for (Note note : nm) {
            ObjectLoader ld = rw.getObjectReader().open(note.getData());
            byte[] data = ld.getCachedBytes();
            GroupReference gRef;
            try {
                gRef = GroupNameNotes.getFromNoteData(data);
            } catch (ConfigInvalidException e) {
                problems.add(error("notename entry %s: %s does not parse: %s", note, new String(data, StandardCharsets.UTF_8), e.getMessage()));
                continue;
            }
            ObjectId nameKey = GroupNameNotes.getNoteKey(new NameKey(gRef.getName()));
            if (!Objects.equals(nameKey, note)) {
                problems.add(error("notename entry %s does not match name %s", note, gRef.getName()));
            }
            // We trust SHA1 to have no collisions, so no need to check uniqueness of name.
            result.put(gRef.getUUID(), gRef.getName());
        }
    }
}
#method_after
private void readGroupNames(Repository repo, Map<String, Ref> refs, Result result, BiMap<AccountGroup.UUID, String> uuidNameBiMap) throws IOException {
    Ref ref = refs.get(RefNames.REFS_GROUPNAMES);
    if (ref == null) {
        String msg = String.format("ref %s does not exist", RefNames.REFS_GROUPNAMES);
        result.problems.add(groupsMigration.readFromNoteDb() ? error(msg) : warning(msg));
        return;
    }
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit c = rw.parseCommit(ref.getObjectId());
        NoteMap nm = NoteMap.read(rw.getObjectReader(), c);
        for (Note note : nm) {
            ObjectLoader ld = rw.getObjectReader().open(note.getData());
            byte[] data = ld.getCachedBytes();
            GroupReference gRef;
            try {
                gRef = GroupNameNotes.getFromNoteData(data);
            } catch (ConfigInvalidException e) {
                result.problems.add(error("notename entry %s: %s does not parse: %s", note, new String(data, StandardCharsets.UTF_8), e.getMessage()));
                continue;
            }
            ObjectId nameKey = GroupNameNotes.getNoteKey(new AccountGroup.NameKey(gRef.getName()));
            if (!Objects.equals(nameKey, note)) {
                result.problems.add(error("notename entry %s does not match name %s", note, gRef.getName()));
            }
            // We trust SHA1 to have no collisions, so no need to check uniqueness of name.
            uuidNameBiMap.put(gRef.getUUID(), gRef.getName());
        }
    }
}
#end_block

#method_before
private List<ConsistencyProblemInfo> checkGlobalConsistency(Map<AccountGroup.UUID, InternalGroup> byUUID, BiMap<AccountGroup.UUID, String> nameMap) {
    List<ConsistencyProblemInfo> problems = new ArrayList<>();
    // Check consistency between the data coming from different refs.
    for (AccountGroup.UUID uuid : byUUID.keySet()) {
        if (!nameMap.containsKey(uuid)) {
            problems.add(error("group %s has no entry in name map", uuid));
            continue;
        }
        String noteName = nameMap.get(uuid);
        String groupRefName = byUUID.get(uuid).getName();
        if (!Objects.equals(noteName, groupRefName)) {
            problems.add(error("inconsistent name for group %s (name map %s vs. group ref %s)", uuid, noteName, groupRefName));
        }
    }
    for (AccountGroup.UUID uuid : nameMap.keySet()) {
        if (!byUUID.containsKey(uuid)) {
            problems.add(error("name map has entry (%s, %s), entry missing as group ref", uuid, nameMap.get(uuid)));
        }
    }
    // No use delving further into inconsistent data.
    if (!problems.isEmpty()) {
        return problems;
    }
    // Check ids.
    Map<AccountGroup.Id, InternalGroup> groupById = new HashMap<>();
    for (InternalGroup g : byUUID.values()) {
        InternalGroup before = groupById.get(g.getId());
        if (before != null) {
            problems.add(error("shared group id %s for %s (%s) and %s (%s)", g.getId(), before.getName(), before.getGroupUUID(), g.getName(), g.getGroupUUID()));
        }
        groupById.put(g.getId(), g);
    }
    return problems;
}
#method_after
private List<ConsistencyProblemInfo> checkGlobalConsistency(Map<AccountGroup.UUID, InternalGroup> uuidToGroupMap, BiMap<AccountGroup.UUID, String> uuidNameBiMap) {
    List<ConsistencyProblemInfo> problems = new ArrayList<>();
    // Check consistency between the data coming from different refs.
    for (AccountGroup.UUID uuid : uuidToGroupMap.keySet()) {
        if (!uuidNameBiMap.containsKey(uuid)) {
            problems.add(error("group %s has no entry in name map", uuid));
            continue;
        }
        String noteName = uuidNameBiMap.get(uuid);
        String groupRefName = uuidToGroupMap.get(uuid).getName();
        if (!Objects.equals(noteName, groupRefName)) {
            problems.add(error("inconsistent name for group %s (name map %s vs. group ref %s)", uuid, noteName, groupRefName));
        }
    }
    for (AccountGroup.UUID uuid : uuidNameBiMap.keySet()) {
        if (!uuidToGroupMap.containsKey(uuid)) {
            problems.add(error("name map has entry (%s, %s), entry missing as group ref", uuid, uuidNameBiMap.get(uuid)));
        }
    }
    if (problems.isEmpty()) {
        // Check ids.
        Map<AccountGroup.Id, InternalGroup> groupById = new HashMap<>();
        for (InternalGroup g : uuidToGroupMap.values()) {
            InternalGroup before = groupById.get(g.getId());
            if (before != null) {
                problems.add(error("shared group id %s for %s (%s) and %s (%s)", g.getId(), before.getName(), before.getGroupUUID(), g.getName(), g.getGroupUUID()));
            }
            groupById.put(g.getId(), g);
        }
    }
    return problems;
}
#end_block

#method_before
@Test
public void redundantMemberAuditsAreIgnored() throws Exception {
    AccountGroup g = newGroup("a");
    Timestamp t1 = TimeUtil.nowTs();
    Timestamp t2 = TimeUtil.nowTs();
    Timestamp t3 = TimeUtil.nowTs();
    Timestamp t4 = TimeUtil.nowTs();
    Timestamp t5 = TimeUtil.nowTs();
    GroupBundle b = builder().group(g).members(member(g, 2)).memberAudit(addMember(g, 1, 8, t1), addMember(g, 1, 8, t1), addMember(g, 1, 8, t3), addMember(g, 1, 9, t4), addAndRemoveMember(g, 1, 8, t2, 9, t5), addAndLegacyRemoveMember(g, 2, 9, t3), addMember(g, 2, 8, t1), addMember(g, 2, 9, t4)).build();
    rebuilder.rebuild(repo, b, null);
    assertMigratedCleanly(reload(g), b);
    ImmutableList<CommitInfo> log = log(g);
    assertThat(log).hasSize(5);
    assertServerCommit(log.get(0), "Create group");
    assertCommit(log.get(1), "Update group\n\nAdd: Account 1 <1@server-id>\nAdd: Account 2 <2@server-id>", "Account 8", "8@server-id");
    assertCommit(log.get(2), "Update group\n\nRemove: Account 2 <2@server-id>", "Account 9", "9@server-id");
    assertCommit(log.get(3), "Update group\n\nAdd: Account 2 <2@server-id>", "Account 9", "9@server-id");
    assertCommit(log.get(4), "Update group\n\nRemove: Account 1 <1@server-id>", "Account 9", "9@server-id");
}
#method_after
@Test
public void redundantMemberAuditsAreIgnored() throws Exception {
    AccountGroup g = newGroup("a");
    Timestamp t1 = TimeUtil.nowTs();
    Timestamp t2 = TimeUtil.nowTs();
    Timestamp t3 = TimeUtil.nowTs();
    Timestamp t4 = TimeUtil.nowTs();
    Timestamp t5 = TimeUtil.nowTs();
    GroupBundle b = builder().group(g).members(member(g, 2)).memberAudit(addMember(g, 1, 8, t1), addMember(g, 1, 8, t1), addMember(g, 1, 8, t3), addMember(g, 1, 9, t4), addAndRemoveMember(g, 1, 8, t2, 9, t5), addAndLegacyRemoveMember(g, 2, 9, t3), addMember(g, 2, 8, t1), addMember(g, 2, 9, t4), addMember(g, 1, 8, t5)).build();
    rebuilder.rebuild(repo, b, null);
    assertMigratedCleanly(reload(g), b);
    ImmutableList<CommitInfo> log = log(g);
    assertThat(log).hasSize(5);
    assertServerCommit(log.get(0), "Create group");
    assertCommit(log.get(1), "Update group\n\nAdd: Account 1 <1@server-id>\nAdd: Account 2 <2@server-id>", "Account 8", "8@server-id");
    assertCommit(log.get(2), "Update group\n\nRemove: Account 2 <2@server-id>", "Account 9", "9@server-id");
    assertCommit(log.get(3), "Update group\n\nAdd: Account 2 <2@server-id>", "Account 9", "9@server-id");
    assertCommit(log.get(4), "Update group\n\nRemove: Account 1 <1@server-id>", "Account 9", "9@server-id");
}
#end_block

#method_before
public String getNameEmail(String anonymousCowardName) {
    String name = fullName != null ? fullName : anonymousCowardName;
    StringBuilder b = new StringBuilder();
    b.append(name);
    if (preferredEmail != null) {
        b.append(" <");
        b.append(preferredEmail);
        b.append(">");
    } else if (accountId != null) {
        b.append(" (");
        b.append(accountId.get());
        b.append(")");
    }
    return b.toString();
}
#method_after
public String getNameEmail(String anonymousCowardName) {
    String name = fullName != null ? fullName : anonymousCowardName;
    StringBuilder b = new StringBuilder();
    b.append(name);
    if (preferredEmail != null) {
        b.append(" <");
        b.append(preferredEmail);
        b.append(">");
    } else {
        b.append(" (");
        b.append(accountId.get());
        b.append(")");
    }
    return b.toString();
}
#end_block

#method_before
public void rebuild(Repository allUsersRepo, GroupBundle bundle, @Nullable BatchRefUpdate bru) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    GroupConfig groupConfig = GroupConfig.loadForGroup(allUsersRepo, bundle.uuid());
    AccountGroup group = bundle.group();
    groupConfig.setGroupCreation(InternalGroupCreation.builder().setId(bundle.id()).setNameKey(group.getNameKey()).setGroupUUID(group.getGroupUUID()).setCreatedOn(group.getCreatedOn()).build());
    InternalGroupUpdate.Builder updateBuilder = InternalGroupUpdate.builder().setOwnerGroupUUID(group.getOwnerGroupUUID()).setVisibleToAll(group.isVisibleToAll());
    if (bundle.group().getDescription() != null) {
        updateBuilder.setDescription(group.getDescription());
    }
    groupConfig.setGroupUpdate(updateBuilder.build(), getAccountNameEmailFunc, getGroupNameFunc);
    Map<Key, Collection<Event>> events = toEvents(bundle).asMap();
    PersonIdent nowServerIdent = getServerIdent(events);
    MetaDataUpdate md = metaDataUpdateFactory.create(allUsers, allUsersRepo, bru);
    // Creation is done by the server (unlike later audit events).
    PersonIdent created = new PersonIdent(nowServerIdent, group.getCreatedOn());
    md.getCommitBuilder().setAuthor(created);
    md.getCommitBuilder().setCommitter(created);
    // Rebuild group ref.
    try (BatchMetaDataUpdate batch = groupConfig.openUpdate(md)) {
        batch.write(groupConfig, md.getCommitBuilder());
        for (Map.Entry<Key, Collection<Event>> e : events.entrySet()) {
            InternalGroupUpdate.Builder ub = InternalGroupUpdate.builder();
            e.getValue().forEach(event -> event.update().accept(ub));
            groupConfig.setGroupUpdate(ub.build(), getAccountNameEmailFunc, getGroupNameFunc);
            PersonIdent currServerIdent = new PersonIdent(nowServerIdent, e.getKey().when());
            CommitBuilder cb = new CommitBuilder();
            cb.setAuthor(e.getKey().accountId().map(id -> newPersonIdentFunc.apply(id, currServerIdent)).orElse(currServerIdent));
            cb.setCommitter(currServerIdent);
            batch.write(groupConfig, cb);
        }
        batch.createRef(groupConfig.getRefName());
    }
}
#method_after
public void rebuild(Repository allUsersRepo, GroupBundle bundle, @Nullable BatchRefUpdate bru) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    GroupConfig groupConfig = GroupConfig.loadForGroup(allUsersRepo, bundle.uuid());
    AccountGroup group = bundle.group();
    groupConfig.setAllowSaveEmptyName();
    groupConfig.setGroupCreation(InternalGroupCreation.builder().setId(bundle.id()).setNameKey(group.getNameKey()).setGroupUUID(group.getGroupUUID()).setCreatedOn(group.getCreatedOn()).build());
    InternalGroupUpdate.Builder updateBuilder = InternalGroupUpdate.builder().setOwnerGroupUUID(group.getOwnerGroupUUID()).setVisibleToAll(group.isVisibleToAll());
    if (bundle.group().getDescription() != null) {
        updateBuilder.setDescription(group.getDescription());
    }
    groupConfig.setGroupUpdate(updateBuilder.build(), getAccountNameEmailFunc, getGroupNameFunc);
    Map<Key, Collection<Event>> events = toEvents(bundle).asMap();
    PersonIdent nowServerIdent = getServerIdent(events);
    MetaDataUpdate md = metaDataUpdateFactory.create(allUsers, allUsersRepo, bru);
    // Creation is done by the server (unlike later audit events).
    PersonIdent created = new PersonIdent(nowServerIdent, group.getCreatedOn());
    md.getCommitBuilder().setAuthor(created);
    md.getCommitBuilder().setCommitter(created);
    // Rebuild group ref.
    try (BatchMetaDataUpdate batch = groupConfig.openUpdate(md)) {
        batch.write(groupConfig, md.getCommitBuilder());
        for (Map.Entry<Key, Collection<Event>> e : events.entrySet()) {
            InternalGroupUpdate.Builder ub = InternalGroupUpdate.builder();
            e.getValue().forEach(event -> event.update().accept(ub));
            groupConfig.setGroupUpdate(ub.build(), getAccountNameEmailFunc, getGroupNameFunc);
            PersonIdent currServerIdent = new PersonIdent(nowServerIdent, e.getKey().when());
            CommitBuilder cb = new CommitBuilder();
            cb.setAuthor(e.getKey().accountId().map(id -> newPersonIdentFunc.apply(id, currServerIdent)).orElse(currServerIdent));
            cb.setCommitter(currServerIdent);
            batch.write(groupConfig, cb);
        }
        batch.createRef(groupConfig.getRefName());
    }
}
#end_block

#method_before
// This class just contains sanity checks that GroupBundle#compare correctly compares all parts of
// the bundle. Most other test coverage should come via the slightly more realistic
// GroupRebuilderTest.
@Test
public void compareNonEqual() throws Exception {
    GroupBundle reviewDbBundle = newBundle().source(Source.REVIEW_DB).build();
    AccountGroup g2 = new AccountGroup(reviewDbBundle.group());
    g2.setDescription("Hello!");
    GroupBundle noteDbBundle = GroupBundle.builder().source(Source.NOTE_DB).group(g2).build();
    assertThat(GroupBundle.compare(reviewDbBundle, noteDbBundle)).containsExactly("AccountGroups differ\n" + ("ReviewDb: AccountGroup{name=group, groupId=1, description=null," + " visibleToAll=false, groupUUID=group-1, ownerGroupUUID=group-1," + " createdOn=2009-09-30 17:00:00.0}\n") + ("NoteDb  : AccountGroup{name=group, groupId=1, description=Hello!," + " visibleToAll=false, groupUUID=group-1, ownerGroupUUID=group-1," + " createdOn=2009-09-30 17:00:00.0}"), "AccountGroupMembers differ\n" + "ReviewDb: [AccountGroupMember{key=1000,1}]\n" + "NoteDb  : []", "AccountGroupMemberAudits differ\n" + "ReviewDb: [AccountGroupMemberAudit{key=1000,1, addedBy=2000, removedBy=null, removedOn=null}]\n" + "NoteDb  : []", "AccountGroupByIds differ\n" + "ReviewDb: [AccountGroupById{key=1,subgroup}]\n" + "NoteDb  : []", "AccountGroupByIdAudits differ\n" + "ReviewDb: [AccountGroupByIdAud{key=1,subgroup, addedBy=3000, removedBy=null, removedOn=null}]\n" + "NoteDb  : []");
}
#method_after
@Test
public void compareNonEqual() throws Exception {
    GroupBundle reviewDbBundle = newBundle().source(Source.REVIEW_DB).build();
    AccountGroup g2 = new AccountGroup(reviewDbBundle.group());
    g2.setDescription("Hello!");
    GroupBundle noteDbBundle = GroupBundle.builder().source(Source.NOTE_DB).group(g2).build();
    assertThat(GroupBundle.compare(reviewDbBundle, noteDbBundle)).containsExactly("AccountGroups differ\n" + ("ReviewDb: AccountGroup{name=group, groupId=1, description=null," + " visibleToAll=false, groupUUID=group-1, ownerGroupUUID=group-1," + " createdOn=2009-09-30 17:00:00.0}\n") + ("NoteDb  : AccountGroup{name=group, groupId=1, description=Hello!," + " visibleToAll=false, groupUUID=group-1, ownerGroupUUID=group-1," + " createdOn=2009-09-30 17:00:00.0}"), "AccountGroupMembers differ\n" + "ReviewDb: [AccountGroupMember{key=1000,1}]\n" + "NoteDb  : []", "AccountGroupMemberAudits differ\n" + "ReviewDb: [AccountGroupMemberAudit{key=1000,1, addedBy=2000, removedBy=null, removedOn=null}]\n" + "NoteDb  : []", "AccountGroupByIds differ\n" + "ReviewDb: [AccountGroupById{key=1,subgroup}]\n" + "NoteDb  : []", "AccountGroupByIdAudits differ\n" + "ReviewDb: [AccountGroupByIdAud{key=1,subgroup, addedBy=3000, removedBy=null, removedOn=null}]\n" + "NoteDb  : []");
}
#end_block

#method_before
private GroupBundle.Builder newBundle() {
    Timestamp ts = new Timestamp(TestTimeUtil.START.toEpochMilli());
    AccountGroup group = new AccountGroup(new AccountGroup.NameKey("group"), new AccountGroup.Id(1), new AccountGroup.UUID("group-1"), ts);
    AccountGroupMember member = new AccountGroupMember(new AccountGroupMember.Key(new Account.Id(1000), group.getId()));
    AccountGroupMemberAudit memberAudit = new AccountGroupMemberAudit(member, new Account.Id(2000), ts);
    AccountGroupById byId = new AccountGroupById(new AccountGroupById.Key(group.getId(), new AccountGroup.UUID("subgroup")));
    AccountGroupByIdAud byIdAudit = new AccountGroupByIdAud(byId, new Account.Id(3000), ts);
    return GroupBundle.builder().group(group).members(member).memberAudit(memberAudit).byId(byId).byIdAudit(byIdAudit);
}
#method_after
private GroupBundle.Builder newBundle() {
    AccountGroup group = new AccountGroup(new AccountGroup.NameKey("group"), new AccountGroup.Id(1), new AccountGroup.UUID("group-1"), ts);
    AccountGroupMember member = new AccountGroupMember(new AccountGroupMember.Key(new Account.Id(1000), group.getId()));
    AccountGroupMemberAudit memberAudit = new AccountGroupMemberAudit(member, new Account.Id(2000), ts);
    AccountGroupById byId = new AccountGroupById(new AccountGroupById.Key(group.getId(), new AccountGroup.UUID("subgroup")));
    AccountGroupByIdAud byIdAudit = new AccountGroupByIdAud(byId, new Account.Id(3000), ts);
    return GroupBundle.builder().group(group).members(member).memberAudit(memberAudit).byId(byId).byIdAudit(byIdAudit);
}
#end_block

#method_before
@Override
public int hashCode() {
    return System.identityHashCode(this);
}
#method_after
@Override
public int hashCode() {
    throw new UnsupportedOperationException("hashCode is not supported because equals is not supported");
}
#end_block

#method_before
void setAllowSaveEmptyName(boolean allowSaveEmptyName) {
    this.allowSaveEmptyName = allowSaveEmptyName;
}
#method_after
void setAllowSaveEmptyName() {
    this.allowSaveEmptyName = true;
}
#end_block

#method_before
private Optional<String> getNewName() {
    if (groupUpdate.isPresent()) {
        return groupUpdate.get().getName().map(n -> Strings.nullToEmpty(n.get()));
    } else if (groupCreation.isPresent()) {
        return Optional.of(Strings.nullToEmpty(groupCreation.get().getNameKey().get()));
    }
    return Optional.empty();
}
#method_after
private Optional<String> getNewName() {
    if (groupUpdate.isPresent()) {
        return groupUpdate.get().getName().map(n -> Strings.nullToEmpty(n.get()));
    }
    if (groupCreation.isPresent()) {
        return Optional.of(Strings.nullToEmpty(groupCreation.get().getNameKey().get()));
    }
    return Optional.empty();
}
#end_block

#method_before
public void rebuild(Repository allUsersRepo, GroupBundle bundle, @Nullable BatchRefUpdate bru) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    GroupConfig groupConfig = GroupConfig.loadForGroup(allUsersRepo, bundle.uuid());
    AccountGroup group = bundle.group();
    groupConfig.setAllowSaveEmptyName(true);
    groupConfig.setGroupCreation(InternalGroupCreation.builder().setId(bundle.id()).setNameKey(group.getNameKey()).setGroupUUID(group.getGroupUUID()).setCreatedOn(group.getCreatedOn()).build());
    InternalGroupUpdate.Builder updateBuilder = InternalGroupUpdate.builder().setOwnerGroupUUID(group.getOwnerGroupUUID()).setVisibleToAll(group.isVisibleToAll());
    if (bundle.group().getDescription() != null) {
        updateBuilder.setDescription(group.getDescription());
    }
    groupConfig.setGroupUpdate(updateBuilder.build(), getAccountNameEmailFunc, getGroupNameFunc);
    Map<Key, Collection<Event>> events = toEvents(bundle).asMap();
    PersonIdent nowServerIdent = getServerIdent(events);
    MetaDataUpdate md = metaDataUpdateFactory.create(allUsers, allUsersRepo, bru);
    // Creation is done by the server (unlike later audit events).
    PersonIdent created = new PersonIdent(nowServerIdent, group.getCreatedOn());
    md.getCommitBuilder().setAuthor(created);
    md.getCommitBuilder().setCommitter(created);
    // Rebuild group ref.
    try (BatchMetaDataUpdate batch = groupConfig.openUpdate(md)) {
        batch.write(groupConfig, md.getCommitBuilder());
        for (Map.Entry<Key, Collection<Event>> e : events.entrySet()) {
            InternalGroupUpdate.Builder ub = InternalGroupUpdate.builder();
            e.getValue().forEach(event -> event.update().accept(ub));
            groupConfig.setGroupUpdate(ub.build(), getAccountNameEmailFunc, getGroupNameFunc);
            PersonIdent currServerIdent = new PersonIdent(nowServerIdent, e.getKey().when());
            CommitBuilder cb = new CommitBuilder();
            cb.setAuthor(e.getKey().accountId().map(id -> newPersonIdentFunc.apply(id, currServerIdent)).orElse(currServerIdent));
            cb.setCommitter(currServerIdent);
            batch.write(groupConfig, cb);
        }
        batch.createRef(groupConfig.getRefName());
    }
}
#method_after
public void rebuild(Repository allUsersRepo, GroupBundle bundle, @Nullable BatchRefUpdate bru) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    GroupConfig groupConfig = GroupConfig.loadForGroup(allUsersRepo, bundle.uuid());
    AccountGroup group = bundle.group();
    groupConfig.setAllowSaveEmptyName();
    groupConfig.setGroupCreation(InternalGroupCreation.builder().setId(bundle.id()).setNameKey(group.getNameKey()).setGroupUUID(group.getGroupUUID()).setCreatedOn(group.getCreatedOn()).build());
    InternalGroupUpdate.Builder updateBuilder = InternalGroupUpdate.builder().setOwnerGroupUUID(group.getOwnerGroupUUID()).setVisibleToAll(group.isVisibleToAll());
    if (bundle.group().getDescription() != null) {
        updateBuilder.setDescription(group.getDescription());
    }
    groupConfig.setGroupUpdate(updateBuilder.build(), getAccountNameEmailFunc, getGroupNameFunc);
    Map<Key, Collection<Event>> events = toEvents(bundle).asMap();
    PersonIdent nowServerIdent = getServerIdent(events);
    MetaDataUpdate md = metaDataUpdateFactory.create(allUsers, allUsersRepo, bru);
    // Creation is done by the server (unlike later audit events).
    PersonIdent created = new PersonIdent(nowServerIdent, group.getCreatedOn());
    md.getCommitBuilder().setAuthor(created);
    md.getCommitBuilder().setCommitter(created);
    // Rebuild group ref.
    try (BatchMetaDataUpdate batch = groupConfig.openUpdate(md)) {
        batch.write(groupConfig, md.getCommitBuilder());
        for (Map.Entry<Key, Collection<Event>> e : events.entrySet()) {
            InternalGroupUpdate.Builder ub = InternalGroupUpdate.builder();
            e.getValue().forEach(event -> event.update().accept(ub));
            groupConfig.setGroupUpdate(ub.build(), getAccountNameEmailFunc, getGroupNameFunc);
            PersonIdent currServerIdent = new PersonIdent(nowServerIdent, e.getKey().when());
            CommitBuilder cb = new CommitBuilder();
            cb.setAuthor(e.getKey().accountId().map(id -> newPersonIdentFunc.apply(id, currServerIdent)).orElse(currServerIdent));
            cb.setCommitter(currServerIdent);
            batch.write(groupConfig, cb);
        }
        batch.createRef(groupConfig.getRefName());
    }
}
#end_block

#method_before
@Override
public ConsistencyCheckInfo apply(ConfigResource resource, ConsistencyCheckInput input) throws RestApiException, IOException, OrmException, PermissionBackendException, ConfigInvalidException {
    permissionBackend.user(user).check(GlobalPermission.ACCESS_DATABASE);
    if (input == null || (input.checkAccounts == null && input.checkAccountExternalIds == null)) {
        throw new BadRequestException("input required");
    }
    ConsistencyCheckInfo consistencyCheckInfo = new ConsistencyCheckInfo();
    if (input.checkAccounts != null) {
        consistencyCheckInfo.checkAccountsResult = new CheckAccountsResultInfo(accountsConsistencyChecker.check());
    }
    if (input.checkAccountExternalIds != null) {
        consistencyCheckInfo.checkAccountExternalIdsResult = new CheckAccountExternalIdsResultInfo(externalIdsConsistencyChecker.check());
    }
    if (input.checkGroups != null) {
        consistencyCheckInfo.checkGroupsResult = new CheckGroupsResultInfo(groupsConsistencyChecker.check());
    }
    return consistencyCheckInfo;
}
#method_after
@Override
public ConsistencyCheckInfo apply(ConfigResource resource, ConsistencyCheckInput input) throws RestApiException, IOException, OrmException, PermissionBackendException, ConfigInvalidException {
    permissionBackend.user(user).check(GlobalPermission.ACCESS_DATABASE);
    if (input == null || (input.checkAccounts == null && input.checkAccountExternalIds == null && input.checkGroups == null)) {
        throw new BadRequestException("input required");
    }
    ConsistencyCheckInfo consistencyCheckInfo = new ConsistencyCheckInfo();
    if (input.checkAccounts != null) {
        consistencyCheckInfo.checkAccountsResult = new CheckAccountsResultInfo(accountsConsistencyChecker.check());
    }
    if (input.checkAccountExternalIds != null) {
        consistencyCheckInfo.checkAccountExternalIdsResult = new CheckAccountExternalIdsResultInfo(externalIdsConsistencyChecker.check());
    }
    if (input.checkGroups != null) {
        consistencyCheckInfo.checkGroupsResult = new CheckGroupsResultInfo(groupsConsistencyChecker.check());
    }
    return consistencyCheckInfo;
}
#end_block

#method_before
@Test
public void readConfigLabelDefaultValue() throws Exception {
    RevCommit rev = util.commit(// 
    util.tree(// 
    util.file("groups", util.blob(group(developers))), util.file("project.config", util.blob(// 
    "" + // 
    "[label \"CustomLabel\"]\n" + // 
    "  value = -1 Negative\n" + // 
    "  value = 0 No Score\n" + // 
    "  value =  1 Positive\n"))));
    ProjectConfig cfg = read(rev);
    Map<String, LabelType> labels = cfg.getLabelSections();
    Short dv = labels.entrySet().iterator().next().getValue().getDefaultValue();
    assertThat((int) dv).isEqualTo(0);
}
#method_after
@Test
public void readConfigLabelDefaultValue() throws Exception {
    RevCommit rev = util.commit(// 
    util.tree(// 
    util.file("groups", util.blob(group(developers))), util.file("project.config", util.blob(// 
    "" + // 
    "[label \"CustomLabel\"]\n" + // 
    "  value = -1 Negative\n" + // No leading space before 0.
    "  value = 0 No Score\n" + // 
    "  value =  1 Positive\n"))));
    ProjectConfig cfg = read(rev);
    Map<String, LabelType> labels = cfg.getLabelSections();
    Short dv = labels.entrySet().iterator().next().getValue().getDefaultValue();
    assertThat((int) dv).isEqualTo(0);
}
#end_block

#method_before
private String getStorageDir() {
    // default to old path for javamelody storage-directory if it exists
    final Path tmp = Paths.get(System.getProperty("java.io.tmpdir")).resolve(JAVAMELODY_PREFIX);
    if (Files.isDirectory(tmp)) {
        return tmp.toString();
    }
    // plugin config has the highest priority
    Path storageDir = Optional.ofNullable(cfg.getString(STORAGE_DIR)).map((path) -> {
        // put javamelody data in default plugin data dir
        if (path == null) {
            return defaultDataDir;
        }
        return Paths.get(path);
    }).get();
    if (!Files.isDirectory(storageDir)) {
        try {
            Files.createDirectories(storageDir);
        } catch (IOException e) {
            log.error("Creation of javamelody data dir [{}] failed.", storageDir, e);
            throw new RuntimeException(e);
        }
    }
    return storageDir.toString();
}
#method_after
private String getStorageDir() {
    // default to old path for javamelody storage-directory if it exists
    final Path tmp = Paths.get(System.getProperty("java.io.tmpdir")).resolve(JAVAMELODY_PREFIX);
    if (Files.isDirectory(tmp)) {
        log.warn("Javamelody data exists in 'tmp' [{}]. Configuration (if any) will be ignored.", tmp);
        return tmp.toString();
    }
    // plugin config has the highest priority
    Path storageDir = Optional.ofNullable(cfg.getString(STORAGE_DIR)).map(Paths::get).orElse(defaultDataDir);
    if (!Files.isDirectory(storageDir)) {
        try {
            Files.createDirectories(storageDir);
        } catch (IOException e) {
            log.error("Creation of javamelody data dir [{}] failed.", storageDir, e);
            throw new RuntimeException(e);
        }
    }
    return storageDir.toString();
}
#end_block

#method_before
public String getBasePath(Project.NameKey project) {
    return cfg.getString(SECTION_NAME, findSubSection(project.get()), BASE_PATH_NAME);
}
#method_after
public Path getBasePath(Project.NameKey project) {
    String basePath = cfg.getString(SECTION_NAME, findSubSection(project.get()), BASE_PATH_NAME);
    return basePath != null ? Paths.get(basePath) : null;
}
#end_block

#method_before
public String[] getAllBasePaths() {
    List<String> basePaths = new ArrayList<>();
    for (String subSection : cfg.getSubsections(SECTION_NAME)) {
        String basePath = cfg.getString(SECTION_NAME, subSection, BASE_PATH_NAME);
        if (basePath != null) {
            basePaths.add(basePath);
        }
    }
    return basePaths.toArray(new String[basePaths.size()]);
}
#method_after
public List<Path> getAllBasePaths() {
    List<Path> basePaths = new ArrayList<>();
    for (String subSection : cfg.getSubsections(SECTION_NAME)) {
        String basePath = cfg.getString(SECTION_NAME, subSection, BASE_PATH_NAME);
        if (basePath != null) {
            basePaths.add(Paths.get(basePath));
        }
    }
    return basePaths;
}
#end_block

#method_before
@Test
public void testBasePathWhenNotConfigured() {
    assertThat(repoCfg.getBasePath(new NameKey("someProject"))).isNull();
}
#method_after
@Test
public void testBasePathWhenNotConfigured() {
    assertThat((Object) repoCfg.getBasePath(new NameKey("someProject"))).isNull();
}
#end_block

#method_before
@Test
public void testBasePathForStarFilter() {
    String basePath = "/someAbsolutePath/someDirectory";
    configureBasePath("*", basePath);
    assertThat(repoCfg.getBasePath(new NameKey("someProject"))).isEqualTo(basePath);
}
#method_after
@Test
public void testBasePathForStarFilter() {
    String basePath = "/someAbsolutePath/someDirectory";
    configureBasePath("*", basePath);
    assertThat(repoCfg.getBasePath(new NameKey("someProject")).toString()).isEqualTo(basePath);
}
#end_block

#method_before
@Test
public void testBasePathForSpecificFilter() {
    String basePath = "/someAbsolutePath/someDirectory";
    configureBasePath("someProject", basePath);
    assertThat(repoCfg.getBasePath(new NameKey("someOtherProject"))).isNull();
    assertThat(repoCfg.getBasePath(new NameKey("someProject"))).isEqualTo(basePath);
}
#method_after
@Test
public void testBasePathForSpecificFilter() {
    String basePath = "/someAbsolutePath/someDirectory";
    configureBasePath("someProject", basePath);
    assertThat((Object) repoCfg.getBasePath(new NameKey("someOtherProject"))).isNull();
    assertThat(repoCfg.getBasePath(new NameKey("someProject")).toString()).isEqualTo(basePath);
}
#end_block

#method_before
@Test
public void testBasePathForStartWithFilter() {
    String basePath1 = "/someAbsolutePath1/someDirectory";
    String basePath2 = "someRelativeDirectory2";
    String basePath3 = "/someAbsolutePath3/someDirectory";
    configureBasePath("project/project/*", basePath1);
    configureBasePath("project/*", basePath2);
    configureBasePath("*", basePath3);
    assertThat(repoCfg.getBasePath(new NameKey("project/project/someProject"))).isEqualTo(basePath1);
    assertThat(repoCfg.getBasePath(new NameKey("project/someProject"))).isEqualTo(basePath2);
    assertThat(repoCfg.getBasePath(new NameKey("someProject"))).isEqualTo(basePath3);
}
#method_after
@Test
public void testBasePathForStartWithFilter() {
    String basePath1 = "/someAbsolutePath1/someDirectory";
    String basePath2 = "someRelativeDirectory2";
    String basePath3 = "/someAbsolutePath3/someDirectory";
    String basePath4 = "/someAbsolutePath4/someDirectory";
    configureBasePath("pro*", basePath1);
    configureBasePath("project/project/*", basePath2);
    configureBasePath("project/*", basePath3);
    configureBasePath("*", basePath4);
    assertThat(repoCfg.getBasePath(new NameKey("project1")).toString()).isEqualTo(basePath1);
    assertThat(repoCfg.getBasePath(new NameKey("project/project/someProject")).toString()).isEqualTo(basePath2);
    assertThat(repoCfg.getBasePath(new NameKey("project/someProject")).toString()).isEqualTo(basePath3);
    assertThat(repoCfg.getBasePath(new NameKey("someProject")).toString()).isEqualTo(basePath4);
}
#end_block

#method_before
@Test
public void testAllBasePath() {
    String[] allBasePaths = new String[] { "/someBasePath1", "/someBasePath2", "/someBasePath3" };
    configureBasePath("*", allBasePaths[0]);
    configureBasePath("project/*", allBasePaths[1]);
    configureBasePath("project/project/*", allBasePaths[2]);
    assertThat(repoCfg.getAllBasePaths()).isEqualTo(allBasePaths);
}
#method_after
@Test
public void testAllBasePath() {
    List<Path> allBasePaths = Arrays.asList(Paths.get("/someBasePath1"), Paths.get("/someBasePath2"), Paths.get("/someBasePath2"));
    configureBasePath("*", allBasePaths.get(0).toString());
    configureBasePath("project/*", allBasePaths.get(1).toString());
    configureBasePath("project/project/*", allBasePaths.get(2).toString());
    assertThat(repoCfg.getAllBasePaths()).isEqualTo(allBasePaths);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    factory(ReplaceOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Test
public void defaultPermissionsOnUserBranches() throws Exception {
    String userRef = RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}";
    assertPermission(allUsers, groupRef(REGISTERED_USERS), userRef, true, Permission.READ, Permission.PUSH, Permission.SUBMIT);
    assertLabelPermission(allUsers, groupRef(REGISTERED_USERS), userRef, true, "Code-Review", -2, 2);
    assertPermission(allUsers, groupRef("Administrators"), RefNames.REFS_USERS_DEFAULT, true, Permission.READ, Permission.PUSH, Permission.CREATE);
}
#method_after
@Test
public void defaultPermissionsOnUserBranches() throws Exception {
    String userRef = RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}";
    assertPermissions(allUsers, groupRef(REGISTERED_USERS), userRef, true, Permission.READ, Permission.PUSH, Permission.SUBMIT);
    assertLabelPermission(allUsers, groupRef(REGISTERED_USERS), userRef, true, "Code-Review", -2, 2);
    assertPermissions(allUsers, groupRef("Administrators"), RefNames.REFS_USERS_DEFAULT, true, Permission.READ, Permission.PUSH, Permission.CREATE);
}
#end_block

#method_before
@ConfigSuite.Default
public static Config defaultConfig() {
    Config config = new Config();
    // This test is explicitly testing the migration from ReviewDb to NoteDb, and handles reading
    // from NoteDb manually. It should work regardless of the value of writeGroupsToNoteDb, however.
    config.setBoolean("user", null, "readGroupsFromNoteDb", false);
    return config;
}
#method_after
@ConfigSuite.Default
public static Config defaultConfig() {
    Config config = new Config();
    // This test is explicitly testing the migration from ReviewDb to NoteDb, and handles reading
    // from NoteDb manually. It should work regardless of the value of noteDb.groups.write, however.
    config.setBoolean(SECTION_NOTE_DB, GROUPS.key(), READ, false);
    return config;
}
#end_block

#method_before
private void blockReviewDbUpdates(boolean block) {
    cfg.setBoolean("user", null, "readGroupsFromNoteDb", block);
}
#method_after
private void blockReviewDbUpdates(boolean block) {
    cfg.setBoolean("user", null, "blockReviewDbGroupUpdates", block);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    super.setUp();
    TestTimeUtil.resetWithClockStep(1, TimeUnit.SECONDS);
    idCounter = new AtomicInteger();
    repo = repoManager.createRepository(allUsersName);
    rebuilder = new GroupRebuilder(GroupRebuilderTest::newPersonIdent, allUsersName, (project, repo, batch) -> new MetaDataUpdate(GitReferenceUpdated.DISABLED, project, repo, batch), // values.
    AbstractGroupTest::newPersonIdent, AbstractGroupTest::getAccountNameEmail, AbstractGroupTest::getGroupName);
    bundleFactory = new GroupBundle.Factory(new AuditLogReader(SERVER_ID, repoManager, allUsersName));
}
#method_after
@Before
public void setUp() throws Exception {
    TestTimeUtil.resetWithClockStep(1, TimeUnit.SECONDS);
    idCounter = new AtomicInteger();
    repo = repoManager.createRepository(allUsersName);
    rebuilder = new GroupRebuilder(GroupRebuilderTest::newPersonIdent, allUsersName, (project, repo, batch) -> new MetaDataUpdate(GitReferenceUpdated.DISABLED, project, repo, batch), // values.
    AbstractGroupTest::newPersonIdent, AbstractGroupTest::getAccountNameEmail, AbstractGroupTest::getGroupName);
    bundleFactory = new GroupBundle.Factory(new AuditLogReader(SERVER_ID, repoManager, allUsersName));
}
#end_block

#method_before
private static PatchListEntry createPatchListEntry(RawTextComparator cmp, RevCommit aCommit, Text aText, Text bText, String fileName) {
    byte[] rawHdr = getRawHeader(aCommit != null, fileName);
    byte[] aContent = aText.getContent();
    byte[] bContent = bText.getContent();
    long size = bContent.length;
    long sizeDelta = size - (long) aContent.length;
    RawText aRawText = new RawText(aContent);
    RawText bRawText = new RawText(bContent);
    EditList edits = new HistogramDiff().diff(cmp, aRawText, bRawText);
    FileHeader fh = new FileHeader(rawHdr, edits, PatchType.UNIFIED);
    return new PatchListEntry(fh, edits, ImmutableSet.of(), size, sizeDelta);
}
#method_after
private static PatchListEntry createPatchListEntry(RawTextComparator cmp, RevCommit aCommit, Text aText, Text bText, String fileName) {
    byte[] rawHdr = getRawHeader(aCommit != null, fileName);
    byte[] aContent = aText.getContent();
    byte[] bContent = bText.getContent();
    long size = bContent.length;
    long sizeDelta = size - aContent.length;
    RawText aRawText = new RawText(aContent);
    RawText bRawText = new RawText(bContent);
    EditList edits = new HistogramDiff().diff(cmp, aRawText, bRawText);
    FileHeader fh = new FileHeader(rawHdr, edits, PatchType.UNIFIED);
    return new PatchListEntry(fh, edits, ImmutableSet.of(), size, sizeDelta);
}
#end_block

#method_before
@Before
public void setUp() {
    TestTimeUtil.resetWithClockStep(1, TimeUnit.SECONDS);
    idCounter = new AtomicInteger();
    allUsers = new AllUsersName(AllUsersNameProvider.DEFAULT);
    repo = new InMemoryRepository(new DfsRepositoryDescription(AllUsersNameProvider.DEFAULT));
    rebuilder = new GroupRebuilder(() -> new PersonIdent("Gerrit Server", "noreply@gerrit.com", TimeUtil.nowTs(), TZ), allUsers, (project, repo, batch) -> new MetaDataUpdate(GitReferenceUpdated.DISABLED, project, repo, batch), (id, ident) -> new PersonIdent("Account " + id, id + "@example.com", ident.getWhen(), ident.getTimeZone()), id -> String.format("Account %s <%s@example.com>", id, id), uuid -> "Group " + uuid);
}
#method_after
@Before
public void setUp() {
    TestTimeUtil.resetWithClockStep(1, TimeUnit.SECONDS);
    idCounter = new AtomicInteger();
    repo = new InMemoryRepository(new DfsRepositoryDescription(AllUsersNameProvider.DEFAULT));
    rebuilder = new GroupRebuilder(() -> new PersonIdent(SERVER_NAME, SERVER_EMAIL, TimeUtil.nowTs(), TZ), new AllUsersName(AllUsersNameProvider.DEFAULT), (project, repo, batch) -> new MetaDataUpdate(GitReferenceUpdated.DISABLED, project, repo, batch), // values.
    (id, ident) -> new PersonIdent("Account " + id, id + "@server-id", ident.getWhen(), ident.getTimeZone()), id -> String.format("Account %s <%s@server-id>", id, id), uuid -> "Group " + uuid);
}
#end_block

#method_before
@Test
public void minimalGroupFields() throws Exception {
    AccountGroup g = newGroup("a");
    GroupBundle b = builder().group(g).build();
    rebuilder.rebuild(repo, b);
    assertThat(reload(g)).isEqualTo(b.toInternalGroup());
    assertThat(log(g)).containsExactly("Create group");
    assertOwner(g, new GroupReference(g.getGroupUUID(), "Group a-1"));
}
#method_after
@Test
public void minimalGroupFields() throws Exception {
    AccountGroup g = newGroup("a");
    GroupBundle b = builder().group(g).build();
    rebuilder.rebuild(repo, b);
    assertThat(reload(g)).isEqualTo(b.toInternalGroup());
    ImmutableList<CommitInfo> log = log(g);
    assertThat(log).hasSize(1);
    assertCommit(log.get(0), "Create group", SERVER_NAME, SERVER_EMAIL);
}
#end_block

#method_before
@Test
public void allGroupFields() throws Exception {
    AccountGroup g = newGroup("a");
    g.setDescription("Description");
    g.setOwnerGroupUUID(new AccountGroup.UUID("owner"));
    g.setVisibleToAll(true);
    GroupBundle b = builder().group(g).build();
    rebuilder.rebuild(repo, b);
    assertThat(reload(g)).isEqualTo(b.toInternalGroup());
    assertThat(log(g)).containsExactly("Create group");
    assertOwner(g, new GroupReference(g.getOwnerGroupUUID(), "Group owner"));
}
#method_after
@Test
public void allGroupFields() throws Exception {
    AccountGroup g = newGroup("a");
    g.setDescription("Description");
    g.setOwnerGroupUUID(new AccountGroup.UUID("owner"));
    g.setVisibleToAll(true);
    GroupBundle b = builder().group(g).build();
    rebuilder.rebuild(repo, b);
    assertThat(reload(g)).isEqualTo(b.toInternalGroup());
    ImmutableList<CommitInfo> log = log(g);
    assertThat(log).hasSize(1);
    assertServerCommit(log.get(0), "Create group");
}
#end_block

#method_before
@Test
public void membersAndSubgroups() throws Exception {
    AccountGroup g = newGroup("a");
    GroupBundle b = builder().group(g).members(member(g, 1), member(g, 2)).byId(byId(g, "x"), byId(g, "y")).build();
    rebuilder.rebuild(repo, b);
    assertThat(reload(g)).isEqualTo(b.toInternalGroup());
    assertThat(log(g)).containsExactly("Create group", "Update group\n" + "\n" + "Add: Account 1 <1@example.com>\n" + "Add: Account 2 <2@example.com>\n" + "Add-group: Group x\n" + "Add-group: Group y").inOrder();
}
#method_after
@Test
public void membersAndSubgroups() throws Exception {
    AccountGroup g = newGroup("a");
    GroupBundle b = builder().group(g).members(member(g, 1), member(g, 2)).byId(byId(g, "x"), byId(g, "y")).build();
    rebuilder.rebuild(repo, b);
    assertThat(reload(g)).isEqualTo(b.toInternalGroup());
    ImmutableList<CommitInfo> log = log(g);
    assertThat(log).hasSize(2);
    assertServerCommit(log.get(0), "Create group");
    assertServerCommit(log.get(1), "Update group\n" + "\n" + "Add: Account 1 <1@server-id>\n" + "Add: Account 2 <2@server-id>\n" + "Add-group: Group x\n" + "Add-group: Group y");
}
#end_block

#method_before
@Test
public void memberAudit() throws Exception {
    AccountGroup g = newGroup("a");
    Timestamp t1 = TimeUtil.nowTs();
    Timestamp t2 = TimeUtil.nowTs();
    Timestamp t3 = TimeUtil.nowTs();
    GroupBundle b = builder().group(g).members(member(g, 1)).memberAudit(addMember(g, 1, 8, t2), addAndRemoveMember(g, 2, 8, t1, 9, t3)).build();
    rebuilder.rebuild(repo, b);
    assertThat(reload(g)).isEqualTo(b.toInternalGroup());
    assertThat(log(g)).containsExactly("Create group", "Update group\n\nAdd: Account 2 <2@example.com>", "Update group\n\nAdd: Account 1 <1@example.com>", "Update group\n\nRemove: Account 2 <2@example.com>").inOrder();
}
#method_after
@Test
public void memberAudit() throws Exception {
    AccountGroup g = newGroup("a");
    Timestamp t1 = TimeUtil.nowTs();
    Timestamp t2 = TimeUtil.nowTs();
    Timestamp t3 = TimeUtil.nowTs();
    GroupBundle b = builder().group(g).members(member(g, 1)).memberAudit(addMember(g, 1, 8, t2), addAndRemoveMember(g, 2, 8, t1, 9, t3)).build();
    rebuilder.rebuild(repo, b);
    assertThat(reload(g)).isEqualTo(b.toInternalGroup());
    ImmutableList<CommitInfo> log = log(g);
    assertThat(log).hasSize(4);
    assertServerCommit(log.get(0), "Create group");
    assertCommit(log.get(1), "Update group\n\nAdd: Account 2 <2@server-id>", "Account 8", "8@server-id");
    assertCommit(log.get(2), "Update group\n\nAdd: Account 1 <1@server-id>", "Account 8", "8@server-id");
    assertCommit(log.get(3), "Update group\n\nRemove: Account 2 <2@server-id>", "Account 9", "9@server-id");
}
#end_block

#method_before
@Test
public void memberAuditLegacyRemoved() throws Exception {
    AccountGroup g = newGroup("a");
    GroupBundle b = builder().group(g).members(member(g, 2)).memberAudit(addAndLegacyRemoveMember(g, 1, 8, TimeUtil.nowTs()), addMember(g, 2, 8, TimeUtil.nowTs())).build();
    rebuilder.rebuild(repo, b);
    assertThat(reload(g)).isEqualTo(b.toInternalGroup());
    assertThat(log(g)).containsExactly("Create group", "Update group\n\nAdd: Account 1 <1@example.com>", "Update group\n\nRemove: Account 1 <1@example.com>", "Update group\n\nAdd: Account 2 <2@example.com>").inOrder();
}
#method_after
@Test
public void memberAuditLegacyRemoved() throws Exception {
    AccountGroup g = newGroup("a");
    GroupBundle b = builder().group(g).members(member(g, 2)).memberAudit(addAndLegacyRemoveMember(g, 1, 8, TimeUtil.nowTs()), addMember(g, 2, 8, TimeUtil.nowTs())).build();
    rebuilder.rebuild(repo, b);
    assertThat(reload(g)).isEqualTo(b.toInternalGroup());
    ImmutableList<CommitInfo> log = log(g);
    assertThat(log).hasSize(4);
    assertServerCommit(log.get(0), "Create group");
    assertCommit(log.get(1), "Update group\n\nAdd: Account 1 <1@server-id>", "Account 8", "8@server-id");
    assertCommit(log.get(2), "Update group\n\nRemove: Account 1 <1@server-id>", "Account 8", "8@server-id");
    assertCommit(log.get(3), "Update group\n\nAdd: Account 2 <2@server-id>", "Account 8", "8@server-id");
}
#end_block

#method_before
@Test
public void unauditedMembershipsAddedAtEnd() throws Exception {
    AccountGroup g = newGroup("a");
    GroupBundle b = builder().group(g).members(member(g, 1), member(g, 2), member(g, 3)).memberAudit(addMember(g, 1, 8, TimeUtil.nowTs())).build();
    rebuilder.rebuild(repo, b);
    assertThat(reload(g)).isEqualTo(b.toInternalGroup());
    assertThat(log(g)).containsExactly("Create group", "Update group\n\nAdd: Account 1 <1@example.com>", "Update group\n\nAdd: Account 2 <2@example.com>\nAdd: Account 3 <3@example.com>").inOrder();
}
#method_after
@Test
public void unauditedMembershipsAddedAtEnd() throws Exception {
    AccountGroup g = newGroup("a");
    GroupBundle b = builder().group(g).members(member(g, 1), member(g, 2), member(g, 3)).memberAudit(addMember(g, 1, 8, TimeUtil.nowTs())).build();
    rebuilder.rebuild(repo, b);
    assertThat(reload(g)).isEqualTo(b.toInternalGroup());
    ImmutableList<CommitInfo> log = log(g);
    assertThat(log).hasSize(3);
    assertServerCommit(log.get(0), "Create group");
    assertCommit(log.get(1), "Update group\n\nAdd: Account 1 <1@server-id>", "Account 8", "8@server-id");
    assertServerCommit(log.get(2), "Update group\n\nAdd: Account 2 <2@server-id>\nAdd: Account 3 <3@server-id>");
}
#end_block

#method_before
@Test
public void byIdAudit() throws Exception {
    AccountGroup g = newGroup("a");
    Timestamp t1 = TimeUtil.nowTs();
    Timestamp t2 = TimeUtil.nowTs();
    Timestamp t3 = TimeUtil.nowTs();
    GroupBundle b = builder().group(g).byId(byId(g, "x")).byIdAudit(addById(g, "x", 8, t2), addAndRemoveById(g, "y", 8, t1, 9, t3)).build();
    rebuilder.rebuild(repo, b);
    assertThat(reload(g)).isEqualTo(b.toInternalGroup());
    assertThat(log(g)).containsExactly("Create group", "Update group\n\nAdd-group: Group y", "Update group\n\nAdd-group: Group x", "Update group\n\nRemove-group: Group y").inOrder();
}
#method_after
@Test
public void byIdAudit() throws Exception {
    AccountGroup g = newGroup("a");
    Timestamp t1 = TimeUtil.nowTs();
    Timestamp t2 = TimeUtil.nowTs();
    Timestamp t3 = TimeUtil.nowTs();
    GroupBundle b = builder().group(g).byId(byId(g, "x")).byIdAudit(addById(g, "x", 8, t2), addAndRemoveById(g, "y", 8, t1, 9, t3)).build();
    rebuilder.rebuild(repo, b);
    assertThat(reload(g)).isEqualTo(b.toInternalGroup());
    ImmutableList<CommitInfo> log = log(g);
    assertThat(log).hasSize(4);
    assertServerCommit(log.get(0), "Create group");
    assertCommit(log.get(1), "Update group\n\nAdd-group: Group y", "Account 8", "8@server-id");
    assertCommit(log.get(2), "Update group\n\nAdd-group: Group x", "Account 8", "8@server-id");
    assertCommit(log.get(3), "Update group\n\nRemove-group: Group y", "Account 9", "9@server-id");
}
#end_block

#method_before
@Test
public void unauditedByIdAddedAtEnd() throws Exception {
    AccountGroup g = newGroup("a");
    GroupBundle b = builder().group(g).byId(byId(g, "x"), byId(g, "y"), byId(g, "z")).byIdAudit(addById(g, "x", 8, TimeUtil.nowTs())).build();
    rebuilder.rebuild(repo, b);
    assertThat(reload(g)).isEqualTo(b.toInternalGroup());
    assertThat(log(g)).containsExactly("Create group", "Update group\n\nAdd-group: Group x", "Update group\n\nAdd-group: Group y\nAdd-group: Group z").inOrder();
}
#method_after
@Test
public void unauditedByIdAddedAtEnd() throws Exception {
    AccountGroup g = newGroup("a");
    GroupBundle b = builder().group(g).byId(byId(g, "x"), byId(g, "y"), byId(g, "z")).byIdAudit(addById(g, "x", 8, TimeUtil.nowTs())).build();
    rebuilder.rebuild(repo, b);
    assertThat(reload(g)).isEqualTo(b.toInternalGroup());
    ImmutableList<CommitInfo> log = log(g);
    assertThat(log).hasSize(3);
    assertServerCommit(log.get(0), "Create group");
    assertCommit(log.get(1), "Update group\n\nAdd-group: Group x", "Account 8", "8@server-id");
    assertServerCommit(log.get(2), "Update group\n\nAdd-group: Group y\nAdd-group: Group z");
}
#end_block

#method_before
private InternalGroup reload(AccountGroup g) throws Exception {
    return GroupConfig.loadForGroup(allUsers, repo, g.getGroupUUID(), project -> {
        throw new UnsupportedOperationException();
    }).getLoadedGroup().get();
}
#method_after
private InternalGroup reload(AccountGroup g) throws Exception {
    return GroupConfig.loadForGroup(repo, g.getGroupUUID()).getLoadedGroup().get();
}
#end_block

#method_before
private ImmutableList<String> log(AccountGroup g) throws Exception {
    try (RevWalk rw = new RevWalk(repo)) {
        Ref ref = repo.exactRef(RefNames.refsGroups(g.getGroupUUID()));
        if (ref == null) {
            return ImmutableList.of();
        }
        rw.sort(RevSort.REVERSE);
        rw.setRetainBody(true);
        rw.markStart(rw.parseCommit(ref.getObjectId()));
        return Streams.stream(rw).map(RevCommit::getFullMessage).collect(toImmutableList());
    }
}
#method_after
private ImmutableList<CommitInfo> log(AccountGroup g) throws Exception {
    ImmutableList<CommitInfo> result = ImmutableList.of();
    try (RevWalk rw = new RevWalk(repo)) {
        Ref ref = repo.exactRef(RefNames.refsGroups(g.getGroupUUID()));
        if (ref != null) {
            rw.sort(RevSort.REVERSE);
            rw.setRetainBody(true);
            rw.markStart(rw.parseCommit(ref.getObjectId()));
            result = Streams.stream(rw).map(CommitUtil::toCommitInfo).collect(toImmutableList());
        }
    }
    return result;
}
#end_block

#method_before
public void rebuild(Repository allUsersRepo, GroupBundle bundle) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    GroupConfig groupConfig = GroupConfig.loadForGroupNoOwnerUpdate(allUsers, allUsersRepo, bundle.uuid());
    groupConfig.setGroupCreation(InternalGroupCreation.builder().setId(bundle.id()).setNameKey(bundle.group().getNameKey()).setGroupUUID(bundle.group().getGroupUUID()).setCreatedOn(bundle.group().getCreatedOn()).build());
    groupConfig.setUpdateOwnerPermissionsStrategy(UpdateOwnerPermissionsStrategy.SKIP);
    // Don't set owner in the InternalGroupUpdate; this triggers a non-atomic update of
    // refs/meta/config within GroupConfig#onSave. The owner update is handled specially in this
    // method using a single BatchRefUpdate.
    InternalGroupUpdate.Builder updateBuilder = InternalGroupUpdate.builder().setVisibleToAll(bundle.group().isVisibleToAll());
    if (bundle.group().getDescription() != null) {
        updateBuilder.setDescription(bundle.group().getDescription());
    }
    groupConfig.setGroupUpdate(updateBuilder.build(), getAccountNameEmailFunc, getGroupNameFunc);
    BatchRefUpdate bru = allUsersRepo.getRefDatabase().newBatchUpdate();
    MetaDataUpdate md = metaDataUpdateFactory.create(allUsers, allUsersRepo, bru);
    // Creation is done by the server (unlike later audit events).
    PersonIdent nowServerIdent = serverIdent.get();
    PersonIdent created = new PersonIdent(nowServerIdent, bundle.group().getCreatedOn());
    md.getCommitBuilder().setAuthor(created);
    md.getCommitBuilder().setCommitter(created);
    // Rebuild group ref.
    try (BatchMetaDataUpdate batch = groupConfig.openUpdate(md)) {
        batch.write(groupConfig, md.getCommitBuilder());
        for (Event e : toEvents(bundle, nowServerIdent)) {
            PersonIdent currServerIdent = new PersonIdent(nowServerIdent, e.when());
            groupConfig.setGroupUpdate(e.update(), getAccountNameEmailFunc, getGroupNameFunc);
            CommitBuilder cb = new CommitBuilder();
            cb.setAuthor(e.accountId().map(id -> newPersonIdentFunc.apply(id, currServerIdent)).orElse(currServerIdent));
            cb.setCommitter(currServerIdent);
            batch.write(groupConfig, cb);
        }
        batch.createRef(groupConfig.getRefName());
    }
    // Update refs/meta/config in same batch.
    GroupOwnerPermissions ownerPerm = new GroupOwnerPermissions(allUsers, allUsersRepo, project -> {
        checkArgument(project.equals(allUsers));
        MetaDataUpdate result = metaDataUpdateFactory.create(project, allUsersRepo, bru);
        result.getCommitBuilder().setAuthor(nowServerIdent);
        result.getCommitBuilder().setCommitter(nowServerIdent);
        return result;
    });
    AccountGroup.UUID ownerUuid = bundle.group().getOwnerGroupUUID();
    ownerPerm.updateOwnerPermissions(bundle.uuid(), null, new GroupReference(ownerUuid, getGroupNameFunc.apply(ownerUuid)));
    checkState(bru.getCommands().size() == 2, "expected 2 commands, got: %s", bru);
    try (RevWalk rw = new RevWalk(allUsersRepo)) {
        RefUpdateUtil.executeChecked(bru, rw);
    }
}
#method_after
public void rebuild(Repository allUsersRepo, GroupBundle bundle) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    GroupConfig groupConfig = GroupConfig.loadForGroup(allUsersRepo, bundle.uuid());
    AccountGroup group = bundle.group();
    groupConfig.setGroupCreation(InternalGroupCreation.builder().setId(bundle.id()).setNameKey(group.getNameKey()).setGroupUUID(group.getGroupUUID()).setCreatedOn(group.getCreatedOn()).build());
    InternalGroupUpdate.Builder updateBuilder = InternalGroupUpdate.builder().setOwnerGroupUUID(group.getOwnerGroupUUID()).setVisibleToAll(group.isVisibleToAll());
    if (bundle.group().getDescription() != null) {
        updateBuilder.setDescription(group.getDescription());
    }
    groupConfig.setGroupUpdate(updateBuilder.build(), getAccountNameEmailFunc, getGroupNameFunc);
    MetaDataUpdate md = metaDataUpdateFactory.create(allUsers, allUsersRepo, null);
    // Creation is done by the server (unlike later audit events).
    PersonIdent nowServerIdent = serverIdent.get();
    PersonIdent created = new PersonIdent(nowServerIdent, group.getCreatedOn());
    md.getCommitBuilder().setAuthor(created);
    md.getCommitBuilder().setCommitter(created);
    // Rebuild group ref.
    try (BatchMetaDataUpdate batch = groupConfig.openUpdate(md)) {
        batch.write(groupConfig, md.getCommitBuilder());
        Map<Key, Collection<Event>> events = toEvents(bundle, nowServerIdent).asMap();
        for (Map.Entry<Key, Collection<Event>> e : events.entrySet()) {
            InternalGroupUpdate.Builder ub = InternalGroupUpdate.builder();
            e.getValue().forEach(event -> event.update().accept(ub));
            groupConfig.setGroupUpdate(ub.build(), getAccountNameEmailFunc, getGroupNameFunc);
            PersonIdent currServerIdent = new PersonIdent(nowServerIdent, e.getKey().when());
            CommitBuilder cb = new CommitBuilder();
            cb.setAuthor(e.getKey().accountId().map(id -> newPersonIdentFunc.apply(id, currServerIdent)).orElse(currServerIdent));
            cb.setCommitter(currServerIdent);
            batch.write(groupConfig, cb);
        }
        batch.createRef(groupConfig.getRefName());
    }
}
#end_block

#method_before
private ImmutableList<Event> toEvents(GroupBundle bundle, PersonIdent nowServerIdent) {
    List<Event> result = new ArrayList<>();
    for (AccountGroupMemberAudit a : bundle.memberAudit()) {
        checkArgument(a.getKey().getGroupId().equals(bundle.id()), "key %s does not match group %s", a.getKey(), bundle.id());
        Account.Id accountId = a.getKey().getParentKey();
        result.add(Event.create(a.getAddedBy(), a.getKey().getAddedOn(), addMember(accountId)));
        if (!a.isActive()) {
            result.add(Event.create(a.getRemovedBy(), a.getRemovedOn(), removeMember(accountId)));
        }
    }
    for (AccountGroupByIdAud a : bundle.byIdAudit()) {
        checkArgument(a.getKey().getParentKey().equals(bundle.id()), "key %s does not match group %s", a.getKey(), bundle.id());
        AccountGroup.UUID uuid = a.getKey().getIncludeUUID();
        result.add(Event.create(a.getAddedBy(), a.getKey().getAddedOn(), addGroup(uuid)));
        if (!a.isActive()) {
            result.add(Event.create(a.getRemovedBy(), a.getRemovedOn(), removeGroup(uuid)));
        }
    }
    result.add(Event.byServer(new Timestamp(nowServerIdent.getWhen().getTime()), setCurrentMembership(bundle)));
    // underlying database.
    return result.stream().sorted(comparing(Event::when)).collect(toImmutableList());
}
#method_after
private ListMultimap<Key, Event> toEvents(GroupBundle bundle, PersonIdent nowServerIdent) {
    ListMultimap<Key, Event> result = MultimapBuilder.treeKeys(Key.COMPARATOR).arrayListValues(1).build();
    Event e;
    for (AccountGroupMemberAudit a : bundle.memberAudit()) {
        checkArgument(a.getKey().getGroupId().equals(bundle.id()), "key %s does not match group %s", a.getKey(), bundle.id());
        Account.Id accountId = a.getKey().getParentKey();
        e = event(Type.ADD_MEMBER, a.getAddedBy(), a.getKey().getAddedOn(), addMember(accountId));
        result.put(e.key(), e);
        if (!a.isActive()) {
            e = event(Type.REMOVE_MEMBER, a.getRemovedBy(), a.getRemovedOn(), removeMember(accountId));
            result.put(e.key(), e);
        }
    }
    for (AccountGroupByIdAud a : bundle.byIdAudit()) {
        checkArgument(a.getKey().getParentKey().equals(bundle.id()), "key %s does not match group %s", a.getKey(), bundle.id());
        AccountGroup.UUID uuid = a.getKey().getIncludeUUID();
        e = event(Type.ADD_GROUP, a.getAddedBy(), a.getKey().getAddedOn(), addGroup(uuid));
        result.put(e.key(), e);
        if (!a.isActive()) {
            e = event(Type.REMOVE_GROUP, a.getRemovedBy(), a.getRemovedOn(), removeGroup(uuid));
            result.put(e.key(), e);
        }
    }
    Timestamp now = new Timestamp(nowServerIdent.getWhen().getTime());
    e = serverEvent(Type.FIXUP, now, setCurrentMembership(bundle));
    result.put(e.key(), e);
    return result;
}
#end_block

#method_before
private static InternalGroupUpdate.Builder addMember(Account.Id toAdd) {
    return InternalGroupUpdate.builder().setMemberModification(in -> Stream.concat(in.stream(), Stream.of(toAdd)).collect(toImmutableSet()));
}
#method_after
private static Consumer<InternalGroupUpdate.Builder> addMember(Account.Id toAdd) {
    return b -> {
        MemberModification prev = b.getMemberModification();
        b.setMemberModification(in -> Sets.union(prev.apply(in), ImmutableSet.of(toAdd)));
    };
}
#end_block

#method_before
private static InternalGroupUpdate.Builder removeMember(Account.Id toRemove) {
    return InternalGroupUpdate.builder().setMemberModification(in -> in.stream().filter(id -> !id.equals(toRemove)).collect(toImmutableSet()));
}
#method_after
private static Consumer<InternalGroupUpdate.Builder> removeMember(Account.Id toRemove) {
    return b -> {
        MemberModification prev = b.getMemberModification();
        b.setMemberModification(in -> Sets.difference(prev.apply(in), ImmutableSet.of(toRemove)));
    };
}
#end_block

#method_before
private static InternalGroupUpdate.Builder addGroup(AccountGroup.UUID toAdd) {
    return InternalGroupUpdate.builder().setSubgroupModification(in -> Stream.concat(in.stream(), Stream.of(toAdd)).collect(toImmutableSet()));
}
#method_after
private static Consumer<InternalGroupUpdate.Builder> addGroup(AccountGroup.UUID toAdd) {
    return b -> {
        SubgroupModification prev = b.getSubgroupModification();
        b.setSubgroupModification(in -> Sets.union(prev.apply(in), ImmutableSet.of(toAdd)));
    };
}
#end_block

#method_before
private static InternalGroupUpdate.Builder removeGroup(AccountGroup.UUID toRemove) {
    return InternalGroupUpdate.builder().setSubgroupModification(in -> in.stream().filter(id -> !id.equals(toRemove)).collect(toImmutableSet()));
}
#method_after
private static Consumer<InternalGroupUpdate.Builder> removeGroup(AccountGroup.UUID toRemove) {
    return b -> {
        SubgroupModification prev = b.getSubgroupModification();
        b.setSubgroupModification(in -> Sets.difference(prev.apply(in), ImmutableSet.of(toRemove)));
    };
}
#end_block

#method_before
private static InternalGroupUpdate.Builder setCurrentMembership(GroupBundle bundle) {
    // set differences to compute the appropriate delta.
    return InternalGroupUpdate.builder().setMemberModification(in -> bundle.members().stream().map(m -> m.getAccountId()).collect(toImmutableSet())).setSubgroupModification(in -> bundle.byId().stream().map(m -> m.getIncludeUUID()).collect(toImmutableSet()));
}
#method_after
private static Consumer<InternalGroupUpdate.Builder> setCurrentMembership(GroupBundle bundle) {
    // set differences to compute the appropriate delta, if any.
    return b -> b.setMemberModification(in -> bundle.members().stream().map(m -> m.getAccountId()).collect(toImmutableSet())).setSubgroupModification(in -> bundle.byId().stream().map(m -> m.getIncludeUUID()).collect(toImmutableSet()));
}
#end_block

#method_before
InternalGroup toInternalGroup() {
    return InternalGroup.create(group(), members().stream().map(AccountGroupMember::getAccountId).collect(toImmutableSet()), byId().stream().map(AccountGroupById::getIncludeUUID).collect(toImmutableSet()));
}
#method_after
public InternalGroup toInternalGroup() {
    return InternalGroup.create(group(), members().stream().map(AccountGroupMember::getAccountId).collect(toImmutableSet()), byId().stream().map(AccountGroupById::getIncludeUUID).collect(toImmutableSet()));
}
#end_block

#method_before
@ConfigSuite.Default
public static Config defaultConfig() {
    Config config = new Config();
    // This test is explicitly testing the migration from ReviewDb to NoteDb, and handles reading
    // from NoteDb manually.
    config.setBoolean("user", null, "readGroupsFromNoteDb", false);
    return config;
}
#method_after
@ConfigSuite.Default
public static Config defaultConfig() {
    Config config = new Config();
    // This test is explicitly testing the migration from ReviewDb to NoteDb, and handles reading
    // from NoteDb manually. It should work regardless of the value of writeGroupsToNoteDb, however.
    config.setBoolean("user", null, "readGroupsFromNoteDb", false);
    return config;
}
#end_block

#method_before
@Test
public void basicGroupProperties() throws Exception {
    InternalGroup group = groupsUpdate.get().createGroup(db, create(name("group")).build(), noUpdate());
    group = groups.getGroup(db, group.getGroupUUID()).get();
    deleteGroupRefs(group);
    assertThat(rebuild(group)).isEqualTo(roundToSecond(group));
}
#method_after
@Test
public void basicGroupProperties() throws Exception {
    GroupInfo createdGroup = gApi.groups().create(name("group")).get();
    InternalGroup reviewDbGroup = groups.getGroup(db, new AccountGroup.UUID(createdGroup.id)).get();
    deleteGroupRefs(reviewDbGroup);
    assertThat(rebuild(reviewDbGroup)).isEqualTo(roundToSecond(reviewDbGroup));
}
#end_block

#method_before
private InternalGroup rebuild(InternalGroup group) throws Exception {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        rebuilder.rebuild(repo, GroupBundle.fromReviewDb(db, group.getId()));
        GroupConfig groupConfig = GroupConfig.loadForGroupNoOwnerUpdate(allUsers, repo, group.getGroupUUID());
        Optional<InternalGroup> result = groupConfig.getLoadedGroup();
        assertThat(result).isPresent();
        return result.get();
    }
}
#method_after
private InternalGroup rebuild(InternalGroup group) throws Exception {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        rebuilder.rebuild(repo, GroupBundle.fromReviewDb(db, group.getId()));
        GroupConfig groupConfig = GroupConfig.loadForGroup(repo, group.getGroupUUID());
        Optional<InternalGroup> result = groupConfig.getLoadedGroup();
        assertThat(result).isPresent();
        return result.get();
    }
}
#end_block

#method_before
public static GroupConfig createForNewGroup(AllUsersName allUsersName, Repository repository, InternalGroupCreation groupCreation, MetaDataUpdateFactory metaDataUpdateFactory) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    checkNotNull(metaDataUpdateFactory);
    GroupConfig groupConfig = new GroupConfig(new GroupOwnerPermissions(allUsersName, repository, metaDataUpdateFactory), groupCreation.getGroupUUID());
    groupConfig.load(repository);
    groupConfig.setGroupCreation(groupCreation);
    return groupConfig;
}
#method_after
public static GroupConfig createForNewGroup(Repository repository, InternalGroupCreation groupCreation) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    GroupConfig groupConfig = new GroupConfig(groupCreation.getGroupUUID());
    groupConfig.load(repository);
    groupConfig.setGroupCreation(groupCreation);
    return groupConfig;
}
#end_block

#method_before
public static GroupConfig loadForGroup(AllUsersName allUsersName, Repository repository, AccountGroup.UUID groupUuid, MetaDataUpdateFactory metaDataUpdateFactory) throws IOException, ConfigInvalidException {
    checkNotNull(metaDataUpdateFactory);
    GroupConfig groupConfig = new GroupConfig(new GroupOwnerPermissions(allUsersName, repository, metaDataUpdateFactory), groupUuid);
    groupConfig.load(repository);
    return groupConfig;
}
#method_after
public static GroupConfig loadForGroup(Repository repository, AccountGroup.UUID groupUuid) throws IOException, ConfigInvalidException {
    GroupConfig groupConfig = new GroupConfig(groupUuid);
    groupConfig.load(repository);
    return groupConfig;
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    if (revision != null) {
        rw.reset();
        rw.markStart(revision);
        rw.sort(RevSort.REVERSE);
        RevCommit earliestCommit = rw.next();
        Timestamp createdOn = new Timestamp(earliestCommit.getCommitTime() * 1000L);
        Config config = readConfig(GROUP_CONFIG_FILE);
        ImmutableSet<Account.Id> members = readMembers();
        ImmutableSet<AccountGroup.UUID> subgroups = readSubgroups();
        AccountGroup.UUID ownerGroupUuid = groupOwnerPermissions.readOwnerGroup(groupUuid);
        if (ownerGroupUuid == null) {
            throw new ConfigInvalidException(String.format("Group owner for group %s not found.", groupUuid.get()));
        }
        loadedGroup = Optional.of(createFrom(groupUuid, ownerGroupUuid, config, members, subgroups, createdOn));
    }
    isLoaded = true;
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    if (revision != null) {
        rw.reset();
        rw.markStart(revision);
        rw.sort(RevSort.REVERSE);
        RevCommit earliestCommit = rw.next();
        Timestamp createdOn = new Timestamp(earliestCommit.getCommitTime() * 1000L);
        Config config = readConfig(GROUP_CONFIG_FILE);
        ImmutableSet<Account.Id> members = readMembers();
        ImmutableSet<AccountGroup.UUID> subgroups = readSubgroups();
        loadedGroup = Optional.of(createFrom(groupUuid, config, members, subgroups, createdOn));
    }
    isLoaded = true;
}
#end_block

#method_before
private static InternalGroup createFrom(AccountGroup.UUID groupUuid, AccountGroup.UUID ownerGroupUuid, Config config, ImmutableSet<Account.Id> members, ImmutableSet<AccountGroup.UUID> subgroups, Timestamp createdOn) {
    InternalGroup.Builder group = InternalGroup.builder();
    group.setGroupUUID(groupUuid);
    group.setOwnerGroupUUID(ownerGroupUuid);
    Arrays.stream(GroupConfigEntry.values()).forEach(configEntry -> configEntry.readFromConfig(group, config));
    group.setMembers(members);
    group.setSubgroups(subgroups);
    group.setCreatedOn(createdOn);
    return group.build();
}
#method_after
private static InternalGroup createFrom(AccountGroup.UUID groupUuid, Config config, ImmutableSet<Account.Id> members, ImmutableSet<AccountGroup.UUID> subgroups, Timestamp createdOn) {
    InternalGroup.Builder group = InternalGroup.builder();
    group.setGroupUUID(groupUuid);
    Arrays.stream(GroupConfigEntry.values()).forEach(configEntry -> configEntry.readFromConfig(group, config));
    group.setMembers(members);
    group.setSubgroups(subgroups);
    group.setCreatedOn(createdOn);
    return group.build();
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    checkLoaded();
    if (!groupCreation.isPresent() && !groupUpdate.isPresent()) {
        // Group was neither created nor changed. -> A new commit isn't necessary.
        return false;
    }
    Timestamp createdOn;
    if (groupCreation.isPresent()) {
        createdOn = groupCreation.get().getCreatedOn();
        commit.setAuthor(new PersonIdent(commit.getAuthor(), createdOn));
        commit.setCommitter(new PersonIdent(commit.getCommitter(), createdOn));
    } else {
        checkState(loadedGroup.isPresent(), String.format("Cannot update non-existent group %s", groupUuid.get()));
        createdOn = loadedGroup.get().getCreatedOn();
    }
    Config config = updateGroupProperties();
    AccountGroup.UUID groupOwnerUuid = updateOwnerPermissions();
    ImmutableSet<Account.Id> originalMembers = loadedGroup.map(InternalGroup::getMembers).orElseGet(ImmutableSet::of);
    Optional<ImmutableSet<Account.Id>> updatedMembers = updateMembers(originalMembers);
    ImmutableSet<AccountGroup.UUID> originalSubgroups = loadedGroup.map(InternalGroup::getSubgroups).orElseGet(ImmutableSet::of);
    Optional<ImmutableSet<AccountGroup.UUID>> updatedSubgroups = updateSubgroups(originalSubgroups);
    String commitMessage = createCommitMessage(originalMembers, updatedMembers, originalSubgroups, updatedSubgroups);
    commit.setMessage(commitMessage);
    loadedGroup = Optional.of(createFrom(groupUuid, groupOwnerUuid, config, updatedMembers.orElse(originalMembers), updatedSubgroups.orElse(originalSubgroups), createdOn));
    groupCreation = Optional.empty();
    updateOwnerPermissionsStrategy = UpdateOwnerPermissionsStrategy.UPDATE;
    return true;
}
#method_after
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    checkLoaded();
    if (!groupCreation.isPresent() && !groupUpdate.isPresent()) {
        // Group was neither created nor changed. -> A new commit isn't necessary.
        return false;
    }
    Timestamp createdOn;
    if (groupCreation.isPresent()) {
        createdOn = groupCreation.get().getCreatedOn();
        commit.setAuthor(new PersonIdent(commit.getAuthor(), createdOn));
        commit.setCommitter(new PersonIdent(commit.getCommitter(), createdOn));
    } else {
        checkState(loadedGroup.isPresent(), "Cannot update non-existent group %s", groupUuid.get());
        createdOn = loadedGroup.get().getCreatedOn();
    }
    Config config = updateGroupProperties();
    ImmutableSet<Account.Id> originalMembers = loadedGroup.map(InternalGroup::getMembers).orElseGet(ImmutableSet::of);
    Optional<ImmutableSet<Account.Id>> updatedMembers = updateMembers(originalMembers);
    ImmutableSet<AccountGroup.UUID> originalSubgroups = loadedGroup.map(InternalGroup::getSubgroups).orElseGet(ImmutableSet::of);
    Optional<ImmutableSet<AccountGroup.UUID>> updatedSubgroups = updateSubgroups(originalSubgroups);
    String commitMessage = createCommitMessage(originalMembers, updatedMembers, originalSubgroups, updatedSubgroups);
    commit.setMessage(commitMessage);
    loadedGroup = Optional.of(createFrom(groupUuid, config, updatedMembers.orElse(originalMembers), updatedSubgroups.orElse(originalSubgroups), createdOn));
    groupCreation = Optional.empty();
    return true;
}
#end_block

#method_before
private void checkLoaded() {
    checkState(isLoaded, String.format("Group %s not loaded yet", groupUuid.get()));
}
#method_after
private void checkLoaded() {
    checkState(isLoaded, "Group %s not loaded yet", groupUuid.get());
}
#end_block

#method_before
private Optional<ImmutableSet<Account.Id>> updateMembers(ImmutableSet<Account.Id> originalMembers) throws IOException {
    Optional<ImmutableSet<Account.Id>> updatedMembers = groupUpdate.map(InternalGroupUpdate::getMemberModification).map(memberModification -> memberModification.apply(originalMembers)).map(ImmutableSet::copyOf);
    if (updatedMembers.isPresent() && !updatedMembers.get().equals(originalMembers)) {
        saveMembers(updatedMembers.get());
    }
    return updatedMembers;
}
#method_after
private Optional<ImmutableSet<Account.Id>> updateMembers(ImmutableSet<Account.Id> originalMembers) throws IOException {
    Optional<ImmutableSet<Account.Id>> updatedMembers = groupUpdate.map(InternalGroupUpdate::getMemberModification).map(memberModification -> memberModification.apply(originalMembers)).map(ImmutableSet::copyOf).filter(members -> !originalMembers.equals(members));
    if (updatedMembers.isPresent()) {
        saveMembers(updatedMembers.get());
    }
    return updatedMembers;
}
#end_block

#method_before
private Optional<ImmutableSet<AccountGroup.UUID>> updateSubgroups(ImmutableSet<AccountGroup.UUID> originalSubgroups) throws IOException {
    Optional<ImmutableSet<AccountGroup.UUID>> updatedSubgroups = groupUpdate.map(InternalGroupUpdate::getSubgroupModification).map(subgroupModification -> subgroupModification.apply(originalSubgroups)).map(ImmutableSet::copyOf);
    if (updatedSubgroups.isPresent() && !updatedSubgroups.get().equals(originalSubgroups)) {
        saveSubgroups(updatedSubgroups.get());
    }
    return updatedSubgroups;
}
#method_after
private Optional<ImmutableSet<AccountGroup.UUID>> updateSubgroups(ImmutableSet<AccountGroup.UUID> originalSubgroups) throws IOException {
    Optional<ImmutableSet<AccountGroup.UUID>> updatedSubgroups = groupUpdate.map(InternalGroupUpdate::getSubgroupModification).map(subgroupModification -> subgroupModification.apply(originalSubgroups)).map(ImmutableSet::copyOf).filter(subgroups -> !originalSubgroups.equals(subgroups));
    if (updatedSubgroups.isPresent()) {
        saveSubgroups(updatedSubgroups.get());
    }
    return updatedSubgroups;
}
#end_block

#method_before
// TODO(aliceks): Introduce a common class for MetaDataUpdate.User and MetaDataUpdate.Server which
// doesn't require this ugly code. In addition, allow to pass in the repository and to use another
private static MetaDataUpdateFactory getMetaDataUpdateFactory(MetaDataUpdate.User metaDataUpdateUserFactory, MetaDataUpdate.Server metaDataUpdateServerFactory, @Nullable IdentifiedUser currentUser, PersonIdent serverIdent, String serverId, String anonymousCowardName) {
    return currentUser != null ? projectName -> {
        MetaDataUpdate metaDataUpdate = metaDataUpdateUserFactory.create(projectName, currentUser);
        PersonIdent authorIdent = getAuditLogAuthorIdent(currentUser.getAccount(), serverIdent, serverId, anonymousCowardName);
        metaDataUpdate.getCommitBuilder().setAuthor(authorIdent);
        return metaDataUpdate;
    } : metaDataUpdateServerFactory::create;
}
#method_after
private static MetaDataUpdateFactory getMetaDataUpdateFactory(MetaDataUpdate.InternalFactory metaDataUpdateInternalFactory, @Nullable IdentifiedUser currentUser, PersonIdent serverIdent, String serverId, String anonymousCowardName) {
    return (projectName, repository, batchRefUpdate) -> {
        MetaDataUpdate metaDataUpdate = metaDataUpdateInternalFactory.create(projectName, repository, batchRefUpdate);
        metaDataUpdate.getCommitBuilder().setCommitter(serverIdent);
        PersonIdent authorIdent;
        if (currentUser != null) {
            metaDataUpdate.setAuthor(currentUser);
            authorIdent = getAuditLogAuthorIdent(currentUser.getAccount(), serverIdent, serverId, anonymousCowardName);
        } else {
            authorIdent = serverIdent;
        }
        metaDataUpdate.getCommitBuilder().setAuthor(authorIdent);
        return metaDataUpdate;
    };
}
#end_block

#method_before
public InternalGroup createGroup(ReviewDb db, InternalGroupCreation groupCreation, InternalGroupUpdate groupUpdate) throws OrmException, IOException, ConfigInvalidException {
    InternalGroup createdGroupInReviewDb = createGroupInReviewDb(db, groupCreation, groupUpdate);
    if (!writeGroupsToNoteDb) {
        updateCachesOnGroupCreation(createdGroupInReviewDb);
        return createdGroupInReviewDb;
    }
    InternalGroup createdGroup = createGroupInNoteDb(groupCreation, groupUpdate);
    updateCachesOnGroupCreation(createdGroup);
    return createdGroup;
}
#method_after
public InternalGroup createGroup(ReviewDb db, InternalGroupCreation groupCreation, InternalGroupUpdate groupUpdate) throws OrmException, IOException, ConfigInvalidException {
    InternalGroup createdGroupInReviewDb = createGroupInReviewDb(db, groupCreation, groupUpdate);
    if (!writeGroupsToNoteDb) {
        updateCachesOnGroupCreation(createdGroupInReviewDb);
        return createdGroupInReviewDb;
    }
    // TODO(aliceks): Add retry mechanism.
    InternalGroup createdGroup = createGroupInNoteDb(groupCreation, groupUpdate);
    updateCachesOnGroupCreation(createdGroup);
    return createdGroup;
}
#end_block

#method_before
@VisibleForTesting
public UpdateResult updateGroupInDb(ReviewDb db, AccountGroup.UUID groupUuid, InternalGroupUpdate groupUpdate) throws OrmException, NoSuchGroupException, IOException, ConfigInvalidException {
    AccountGroup group = getExistingGroupFromReviewDb(db, groupUuid);
    UpdateResult reviewDbUpdateResult = updateGroupInReviewDb(db, group, groupUpdate);
    if (!writeGroupsToNoteDb) {
        return reviewDbUpdateResult;
    }
    Optional<UpdateResult> noteDbUpdateResult = updateGroupInNoteDb(groupUuid, groupUpdate);
    return noteDbUpdateResult.orElse(reviewDbUpdateResult);
}
#method_after
@VisibleForTesting
public UpdateResult updateGroupInDb(ReviewDb db, AccountGroup.UUID groupUuid, InternalGroupUpdate groupUpdate) throws OrmException, NoSuchGroupException, IOException, ConfigInvalidException {
    AccountGroup group = getExistingGroupFromReviewDb(db, groupUuid);
    UpdateResult reviewDbUpdateResult = updateGroupInReviewDb(db, group, groupUpdate);
    if (!writeGroupsToNoteDb) {
        return reviewDbUpdateResult;
    }
    // TODO(aliceks): Add retry mechanism.
    Optional<UpdateResult> noteDbUpdateResult = updateGroupInNoteDb(groupUuid, groupUpdate);
    return noteDbUpdateResult.orElse(reviewDbUpdateResult);
}
#end_block

#method_before
private static void applyUpdate(AccountGroup group, InternalGroupUpdate groupUpdate) {
    groupUpdate.getName().ifPresent(group::setNameKey);
    groupUpdate.getDescription().ifPresent(d -> group.setDescription(Strings.emptyToNull(d)));
    groupUpdate.getOwnerGroupReference().ifPresent(r -> group.setOwnerGroupUUID(r.getUUID()));
    groupUpdate.getVisibleToAll().ifPresent(group::setVisibleToAll);
}
#method_after
private static void applyUpdate(AccountGroup group, InternalGroupUpdate groupUpdate) {
    groupUpdate.getName().ifPresent(group::setNameKey);
    groupUpdate.getDescription().ifPresent(d -> group.setDescription(Strings.emptyToNull(d)));
    groupUpdate.getOwnerGroupUUID().ifPresent(group::setOwnerGroupUUID);
    groupUpdate.getVisibleToAll().ifPresent(group::setVisibleToAll);
}
#end_block

#method_before
private InternalGroup createGroupInNoteDb(InternalGroupCreation groupCreation, InternalGroupUpdate groupUpdate) throws IOException, ConfigInvalidException, OrmException {
    GroupConfig groupConfig = createFor(groupCreation);
    updateGroupInNoteDb(groupConfig, groupUpdate);
    return groupConfig.getLoadedGroup().orElseThrow(() -> new IllegalStateException("Created group wasn't automatically loaded"));
}
#method_after
private InternalGroup createGroupInNoteDb(InternalGroupCreation groupCreation, InternalGroupUpdate groupUpdate) throws IOException, ConfigInvalidException, OrmException {
    try (Repository allUsersRepo = repoManager.openRepository(allUsersName)) {
        AccountGroup.NameKey groupName = groupUpdate.getName().orElseGet(groupCreation::getNameKey);
        GroupNameNotes groupNameNotes = GroupNameNotes.loadForNewGroup(allUsersRepo, groupCreation.getGroupUUID(), groupName);
        GroupConfig groupConfig = GroupConfig.createForNewGroup(allUsersRepo, groupCreation);
        groupConfig.setGroupUpdate(groupUpdate, this::getAccountNameEmail, this::getGroupName);
        commit(allUsersRepo, groupConfig, groupNameNotes);
        return groupConfig.getLoadedGroup().orElseThrow(() -> new IllegalStateException("Created group wasn't automatically loaded"));
    }
}
#end_block

#method_before
private Optional<UpdateResult> updateGroupInNoteDb(AccountGroup.UUID groupUuid, InternalGroupUpdate groupUpdate) throws IOException, ConfigInvalidException {
    GroupConfig groupConfig = loadFor(groupUuid);
    if (!groupConfig.getLoadedGroup().isPresent()) {
        // TODO(aliceks): Throw a NoSuchGroupException here when all groups are stored in NoteDb.
        return Optional.empty();
    }
    return updateGroupInNoteDb(groupConfig, groupUpdate);
}
#method_after
private Optional<UpdateResult> updateGroupInNoteDb(AccountGroup.UUID groupUuid, InternalGroupUpdate groupUpdate) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    try (Repository allUsersRepo = repoManager.openRepository(allUsersName)) {
        GroupConfig groupConfig = GroupConfig.loadForGroup(allUsersRepo, groupUuid);
        groupConfig.setGroupUpdate(groupUpdate, this::getAccountNameEmail, this::getGroupName);
        if (!groupConfig.getLoadedGroup().isPresent()) {
            // TODO(aliceks): Throw a NoSuchGroupException here when all groups are stored in NoteDb.
            return Optional.empty();
        }
        InternalGroup originalGroup = groupConfig.getLoadedGroup().get();
        GroupNameNotes groupNameNotes = null;
        if (groupUpdate.getName().isPresent()) {
            AccountGroup.NameKey oldName = originalGroup.getNameKey();
            AccountGroup.NameKey newName = groupUpdate.getName().get();
            groupNameNotes = GroupNameNotes.loadForRename(allUsersRepo, groupUuid, oldName, newName);
        }
        commit(allUsersRepo, groupConfig, groupNameNotes);
        InternalGroup updatedGroup = groupConfig.getLoadedGroup().orElseThrow(() -> new IllegalStateException("Updated group wasn't automatically loaded"));
        return Optional.of(getUpdateResult(originalGroup, updatedGroup));
    }
}
#end_block

#method_before
static String getAccountNameEmail(AccountCache accountCache, String anonymousCowardName, Account.Id accountId, String serverId) {
    AccountState accountState = accountCache.getOrNull(accountId);
    String accountName = Optional.ofNullable(accountState).map(AccountState::getAccount).map(account -> account.getName(anonymousCowardName)).orElse(anonymousCowardName);
    return formatNameEmail(accountName, getEmailForAuditLog(accountId, serverId));
}
#method_after
static String getAccountNameEmail(AccountCache accountCache, String anonymousCowardName, Account.Id accountId, String serverId) {
    String accountName = getAccountName(accountCache, anonymousCowardName, accountId);
    return formatNameEmail(accountName, getEmailForAuditLog(accountId, serverId));
}
#end_block

#method_before
private static String getEmailForAuditLog(Account.Id accountId, String serverId) {
    return accountId.get() + "@" + serverId;
}
#method_after
static String getEmailForAuditLog(Account.Id accountId, String serverId) {
    return accountId.get() + "@" + serverId;
}
#end_block

#method_before
private void commit(GroupConfig groupConfig) throws IOException {
    try (MetaDataUpdate metaDataUpdate = metaDataUpdateFactory.create(allUsersName)) {
        groupConfig.commit(metaDataUpdate);
    }
}
#method_after
private void commit(Repository allUsersRepo, GroupConfig groupConfig, @Nullable GroupNameNotes groupNameNotes) throws IOException {
    BatchRefUpdate batchRefUpdate = allUsersRepo.getRefDatabase().newBatchUpdate();
    try (MetaDataUpdate metaDataUpdate = metaDataUpdateFactory.create(allUsersName, allUsersRepo, batchRefUpdate)) {
        groupConfig.commit(metaDataUpdate);
    }
    if (groupNameNotes != null) {
        // MetaDataUpdates unfortunately can't be reused. -> Create a new one.
        try (MetaDataUpdate metaDataUpdate = metaDataUpdateFactory.create(allUsersName, allUsersRepo, batchRefUpdate)) {
            groupNameNotes.commit(metaDataUpdate);
        }
    }
    try (RevWalk revWalk = new RevWalk(allUsersRepo)) {
        RefUpdateUtil.executeChecked(batchRefUpdate, revWalk);
    }
    gitRefUpdated.fire(allUsersName, batchRefUpdate, currentUser != null ? currentUser.getAccount() : null);
}
#end_block

#method_before
@Override
public CloseableHttpClient get() {
    return HttpClients.custom().setConnectionManager(mgr.get()).setDefaultRequestConfig(customRequestConfig()).setServiceUnavailableRetryStrategy(customServiceUnavailRetryStrategy()).build();
}
#method_after
@Override
public CloseableHttpClient get() {
    return HttpClients.custom().setConnectionManager(create(socketMgr.get())).setDefaultRequestConfig(customRequestConfig()).setServiceUnavailableRetryStrategy(customServiceUnavailRetryStrategy()).build();
}
#end_block

#method_before
@Override
public void run() {
    try {
        Optional<EventProcessor.Request> content = processor.get();
        if (!content.isPresent()) {
            log.debug("No content. Webhook [{}] skipped.", remote.getUrl());
            return;
        }
        execCnt++;
        HttpResult result = session.get().post(remote.getUrl(), content.get().headers, remote, content.get().body);
        if (!result.successful && execCnt < remote.getMaxTries()) {
            logRetry(result.message);
            reschedule();
        }
    } catch (IOException e) {
        if (isRecoverable(e) && execCnt < remote.getMaxTries()) {
            logRetry(e);
            reschedule();
        } else {
            log.error("Failed to post: {}", toString(), e);
        }
    }
}
#method_after
@Override
public void run() {
    try {
        Optional<EventProcessor.Request> content = processor.get();
        if (!content.isPresent()) {
            log.debug("No content. Webhook [{}] skipped.", remote.getUrl());
            return;
        }
        execCnt++;
        HttpResult result = session.get().post(remote, content.get());
        if (!result.successful && execCnt < remote.getMaxTries()) {
            logRetry(result.message);
            reschedule();
        }
    } catch (IOException e) {
        if (isRecoverable(e) && execCnt < remote.getMaxTries()) {
            logRetry(e);
            reschedule();
        } else {
            log.error("Failed to post: {}", toString(), e);
        }
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ScheduledExecutorService.class).annotatedWith(WebHooksExecutor.class).toProvider(ExecutorProvider.class);
    factory(PostTask.Factory.class);
    factory(RemoteConfig.Factory.class);
    factory(HttpClientConnectionManagerProvider.Factory.class);
    factory(HttpSession.Factory.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventHandler.class);
    bind(CloseableHttpClient.class).annotatedWith(Names.named(DEFAULT)).toProvider(DefaultHttpClientProvider.class).in(Scopes.SINGLETON);
    bind(CloseableHttpClient.class).annotatedWith(Names.named(SSL_VERIFY)).toProvider(SslVerifyingHttpClientProvider.class).in(Scopes.SINGLETON);
    bind(HttpClientConfigurator.class).in(Scopes.SINGLETON);
    install(processors);
}
#method_after
@Override
protected void configure() {
    bind(ScheduledExecutorService.class).annotatedWith(WebHooksExecutor.class).toProvider(ExecutorProvider.class).in(Scopes.SINGLETON);
    factory(PostTask.Factory.class);
    factory(RemoteConfig.Factory.class);
    factory(HttpSession.Factory.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventHandler.class);
    bind(CloseableHttpClient.class).annotatedWith(Names.named(DEFAULT)).toProvider(DefaultHttpClientProvider.class).in(Scopes.SINGLETON);
    bind(CloseableHttpClient.class).annotatedWith(Names.named(SSL_VERIFY)).toProvider(SslVerifyingHttpClientProvider.class).in(Scopes.SINGLETON);
    install(processors);
}
#end_block

#method_before
@Before
public void setup() {
    when(remote.getRetryInterval()).thenReturn(RETRY_INTERVAL);
    when(remote.getMaxTries()).thenReturn(MAX_TRIES);
    when(remote.getUrl()).thenReturn(WEBHOOK_URL);
    when(processor.process(eq(projectCreated), eq(remote))).thenReturn(CONTENT);
    when(sessionFactory.create(eq(remote))).thenReturn(session);
    task = new PostTask(executor, sessionFactory, processor, projectCreated, remote);
}
#method_after
@Before
public void setup() {
    when(remote.getRetryInterval()).thenReturn(RETRY_INTERVAL);
    when(remote.getMaxTries()).thenReturn(MAX_TRIES);
    when(remote.getUrl()).thenReturn(WEBHOOK_URL);
    when(processor.process(eq(projectCreated), eq(remote))).thenReturn(Optional.of(content));
    when(sessionFactory.create(eq(remote))).thenReturn(session);
    task = new PostTask(executor, sessionFactory, processor, projectCreated, remote);
}
#end_block

#method_before
@Test
public void noRescheduleOnSuccess() throws IOException {
    when(session.post(WEBHOOK_URL, HEADERS, remote, BODY)).thenReturn(OK_RESULT);
    task.run();
    verifyZeroInteractions(executor);
}
#method_after
@Test
public void noRescheduleOnSuccess() throws IOException {
    when(session.post(eq(remote), eq(content))).thenReturn(OK_RESULT);
    task.run();
    verifyZeroInteractions(executor);
}
#end_block

#method_before
@Test
public void noRescheduleOnNonRecoverableException() throws IOException {
    when(session.post(WEBHOOK_URL, HEADERS, remote, BODY)).thenThrow(SSLException.class);
    task.run();
    verifyZeroInteractions(executor);
}
#method_after
@Test
public void noRescheduleOnNonRecoverableException() throws IOException {
    when(session.post(eq(remote), eq(content))).thenThrow(SSLException.class);
    task.run();
    verifyZeroInteractions(executor);
}
#end_block

#method_before
@Test
public void rescheduleOnError() throws IOException {
    when(session.post(WEBHOOK_URL, HEADERS, remote, BODY)).thenReturn(ERR_RESULT);
    task.run();
    verify(executor, times(1)).schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS);
}
#method_after
@Test
public void rescheduleOnError() throws IOException {
    when(session.post(eq(remote), eq(content))).thenReturn(ERR_RESULT);
    task.run();
    verify(executor, times(1)).schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
@Test
public void rescheduleOnRecoverableException() throws IOException {
    when(session.post(WEBHOOK_URL, HEADERS, remote, BODY)).thenThrow(IOException.class);
    task.run();
    verify(executor, times(1)).schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS);
}
#method_after
@Test
public void rescheduleOnRecoverableException() throws IOException {
    when(session.post(eq(remote), eq(content))).thenThrow(IOException.class);
    task.run();
    verify(executor, times(1)).schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
@Test
public void keepReschedulingMaxTriesTimes() throws IOException {
    when(session.post(WEBHOOK_URL, HEADERS, remote, BODY)).thenThrow(IOException.class);
    when(executor.schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS)).then(new Answer<Void>() {

        @Override
        public Void answer(InvocationOnMock invocation) throws Throwable {
            task.run();
            return null;
        }
    });
    task.run();
    verify(executor, times(MAX_TRIES - 1)).schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS);
}
#method_after
@Test
public void keepReschedulingMaxTriesTimes() throws IOException {
    when(session.post(eq(remote), eq(content))).thenThrow(IOException.class);
    when(executor.schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS)).then(new Answer<Void>() {

        @Override
        public Void answer(InvocationOnMock invocation) throws Throwable {
            task.run();
            return null;
        }
    });
    task.run();
    verify(executor, times(MAX_TRIES - 1)).schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
HttpResult post(String endpoint, Map<String, String> headers, RemoteConfig remote, String content) throws IOException {
    HttpPost post = new HttpPost(endpoint);
    post.addHeader("Content-Type", MediaType.JSON_UTF_8.toString());
    post.setConfig(getConfig(remote));
    headers.entrySet().stream().forEach(e -> {
        post.addHeader(e.getKey(), e.getValue());
    });
    post.setEntity(new StringEntity(content, StandardCharsets.UTF_8));
    return httpClient.execute(post, new HttpResponseHandler());
}
#method_after
HttpResult post(RemoteConfig remote, EventProcessor.Request request) throws IOException {
    HttpPost post = new HttpPost(remote.getUrl());
    post.addHeader("Content-Type", MediaType.JSON_UTF_8.toString());
    post.setConfig(getConfig(remote));
    request.headers.entrySet().stream().forEach(e -> {
        post.addHeader(e.getKey(), e.getValue());
    });
    post.setEntity(new StringEntity(request.body, StandardCharsets.UTF_8));
    return httpClient.execute(post, new HttpResponseHandler());
}
#end_block

#method_before
@Override
public void run() {
    log.info("Running account deactivations");
    try {
        int numberOfAccountsDeactivated = 0;
        for (AccountState acc : accountQueryProvider.get().query(AccountPredicates.isActive())) {
            log.debug("processing account " + acc.getUserName());
            if (acc.getUserName() != null && !realm.isActive(acc.getUserName())) {
                try {
                    sif.deactivate(acc.getAccount().getId());
                } catch (Exception e) {
                    log.error("Error deactivating account: {} ({}) {}", acc.getUserName(), acc.getAccount().getId(), e.getMessage(), e);
                }
                log.info("deactivated account " + acc.getUserName());
                numberOfAccountsDeactivated++;
            }
        }
        log.info("Deactivations complete, {} account(s) were deactivated", numberOfAccountsDeactivated);
    } catch (Exception e) {
        log.error("Failed to deactivate inactive accounts " + e.getMessage(), e);
    }
}
#method_after
@Override
public void run() {
    log.info("Running account deactivations");
    try {
        int numberOfAccountsDeactivated = 0;
        for (AccountState acc : accountQueryProvider.get().query(AccountPredicates.isActive())) {
            if (processAccount(acc)) {
                numberOfAccountsDeactivated++;
            }
        }
        log.info("Deactivations complete, {} account(s) were deactivated", numberOfAccountsDeactivated);
    } catch (Exception e) {
        log.error("Failed to complete deactivation of accounts: " + e.getMessage(), e);
    }
}
#end_block

#method_before
private boolean isFullMatch(Account.Id id, String nameOrEmail) {
    AccountState account = byId.get(id);
    Optional<Boolean> matchingName = Optional.ofNullable(account.getAccount().getFullName()).map(n -> n.trim().equalsIgnoreCase(nameOrEmail)).filter(t -> t);
    return matchingName.orElse(account.getExternalIds().stream().anyMatch(extId -> Optional.ofNullable(extId.email()).map(mail -> mail.equalsIgnoreCase(nameOrEmail)).orElse(getSchemeRest(extId.key().scheme(), extId.key().get()).trim().equalsIgnoreCase(nameOrEmail))));
}
#method_after
private boolean isFullMatch(Account.Id id, String nameOrEmail) {
    AccountState account = byId.get(id);
    return isFullNameMatch(account, nameOrEmail) || account.getExternalIds().stream().anyMatch(eid -> isEMailMatch(eid, nameOrEmail) || isUsernameMatch(eid, nameOrEmail));
}
#end_block

#method_before
@Test
public void combineWithBatchGroupNameNotes() throws Exception {
    AccountGroup g1 = newGroup("a");
    AccountGroup g2 = newGroup("b");
    GroupBundle b1 = builder().group(g1).build();
    GroupBundle b2 = builder().group(g2).build();
    BatchRefUpdate bru = repo.getRefDatabase().newBatchUpdate();
    rebuilder.rebuild(repo, b1, bru);
    rebuilder.rebuild(repo, b2, bru);
    try (ObjectInserter inserter = repo.newObjectInserter()) {
        BatchGroupNameNotes.updateGroupNames(repo, inserter, bru, ImmutableList.of(g1, g2), newPersonIdent());
        inserter.flush();
    }
    assertThat(log(g1)).isEmpty();
    assertThat(log(g2)).isEmpty();
    assertThat(logGroupNames()).isEmpty();
    RefUpdateUtil.executeChecked(bru, repo);
    assertThat(log(g1)).hasSize(1);
    assertThat(log(g2)).hasSize(1);
    assertThat(logGroupNames()).hasSize(1);
    assertThat(reload(g1)).isEqualTo(b1.toInternalGroup());
    assertThat(reload(g2)).isEqualTo(b2.toInternalGroup());
    assertThat(BatchGroupNameNotes.readNamesByUuid(repo)).containsExactly(g1.getGroupUUID(), "a", g2.getGroupUUID(), "b");
}
#method_after
@Test
public void combineWithBatchGroupNameNotes() throws Exception {
    AccountGroup g1 = newGroup("a");
    AccountGroup g2 = newGroup("b");
    GroupBundle b1 = builder().group(g1).build();
    GroupBundle b2 = builder().group(g2).build();
    BatchRefUpdate bru = repo.getRefDatabase().newBatchUpdate();
    rebuilder.rebuild(repo, b1, bru);
    rebuilder.rebuild(repo, b2, bru);
    try (ObjectInserter inserter = repo.newObjectInserter()) {
        ImmutableList<GroupReference> refs = ImmutableList.of(GroupReference.forGroup(g1), GroupReference.forGroup(g2));
        GroupNameNotes.updateGroupNames(repo, inserter, bru, refs, newPersonIdent());
        inserter.flush();
    }
    assertThat(log(g1)).isEmpty();
    assertThat(log(g2)).isEmpty();
    assertThat(logGroupNames()).isEmpty();
    RefUpdateUtil.executeChecked(bru, repo);
    assertThat(log(g1)).hasSize(1);
    assertThat(log(g2)).hasSize(1);
    assertThat(logGroupNames()).hasSize(1);
    assertThat(reload(g1)).isEqualTo(b1.toInternalGroup());
    assertThat(reload(g2)).isEqualTo(b2.toInternalGroup());
    assertThat(GroupTestUtil.readNameToUuidMap(repo)).containsExactly("a", "a-1", "b", "b-2");
}
#end_block

#method_before
private InternalGroup reload(AccountGroup g) throws Exception {
    return GroupConfig.loadForGroup(repo, g.getGroupUUID()).getLoadedGroup().get();
}
#method_after
private InternalGroup reload(AccountGroup g) throws Exception {
    return removeRefState(GroupConfig.loadForGroup(repo, g.getGroupUUID()).getLoadedGroup().get());
}
#end_block

#method_before
private ImmutableList<CommitInfo> log(AccountGroup g) throws Exception {
    return log(RefNames.refsGroups(g.getGroupUUID()));
}
#method_after
private ImmutableList<CommitInfo> log(AccountGroup g) throws Exception {
    return GroupTestUtil.log(repo, RefNames.refsGroups(g.getGroupUUID()));
}
#end_block

#method_before
private ImmutableList<CommitInfo> logGroupNames() throws Exception {
    return log(RefNames.REFS_GROUPNAMES);
}
#method_after
private ImmutableList<CommitInfo> logGroupNames() throws Exception {
    return GroupTestUtil.log(repo, REFS_GROUPNAMES);
}
#end_block

#method_before
@SuppressWarnings("deprecation")
static ObjectId getNoteKey(AccountGroup.NameKey groupName) {
    return ObjectId.fromRaw(Hashing.sha1().hashString(groupName.get(), UTF_8).asBytes());
}
#method_after
@SuppressWarnings("deprecation")
@VisibleForTesting
static ObjectId getNoteKey(AccountGroup.NameKey groupName) {
    return ObjectId.fromRaw(Hashing.sha1().hashString(groupName.get(), UTF_8).asBytes());
}
#end_block

#method_before
static String getAsNoteData(AccountGroup.UUID uuid, AccountGroup.NameKey groupName) {
    Config config = new Config();
    config.setString(SECTION_NAME, null, UUID_PARAM, uuid.get());
    config.setString(SECTION_NAME, null, NAME_PARAM, groupName.get());
    return config.toText();
}
#method_after
private static String getAsNoteData(AccountGroup.UUID uuid, AccountGroup.NameKey groupName) {
    Config config = new Config();
    config.setString(SECTION_NAME, null, UUID_PARAM, uuid.get());
    config.setString(SECTION_NAME, null, NAME_PARAM, groupName.get());
    return config.toText();
}
#end_block

#method_before
static GroupReference getGroupReference(ObjectReader reader, ObjectId noteDataBlobId) throws IOException, ConfigInvalidException {
    byte[] noteData = reader.open(noteDataBlobId, OBJ_BLOB).getCachedBytes();
    return getFromNoteData(noteData);
}
#method_after
@VisibleForTesting
public static GroupReference getGroupReference(ObjectReader reader, ObjectId noteDataBlobId) throws IOException, ConfigInvalidException {
    byte[] noteData = reader.open(noteDataBlobId, OBJ_BLOB).getCachedBytes();
    return getFromNoteData(noteData);
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    Term a2 = arg2.dereference();
    Pattern fileRegex = getRegexParameter(a1);
    Pattern editRegex = getRegexParameter(a2);
    PatchList pl = StoredValues.PATCH_LIST.get(engine);
    Repository repo = StoredValues.REPOSITORY.get(engine);
    try (ObjectReader reader = repo.newObjectReader();
        RevWalk rw = new RevWalk(reader)) {
        final RevTree aTree;
        final RevTree bTree;
        final RevCommit bCommit = rw.parseCommit(pl.getNewId());
        if (pl.getOldId() != null) {
            aTree = rw.parseTree(pl.getOldId());
        } else {
            // web UI returns no files to match against, just fail.
            return engine.fail();
        }
        bTree = bCommit.getTree();
        for (PatchListEntry entry : pl.getPatches()) {
            String newName = entry.getNewName();
            String oldName = entry.getOldName();
            if (newName.equals("/COMMIT_MSG")) {
                continue;
            }
            if (fileRegex.matcher(newName).find() || (oldName != null && fileRegex.matcher(oldName).find())) {
                List<Edit> edits = (List<Edit>) entry.getEdits();
                if (edits.isEmpty()) {
                    continue;
                }
                Text tA;
                if (oldName != null) {
                    tA = load(aTree, oldName, reader);
                } else {
                    tA = load(aTree, newName, reader);
                }
                Text tB = load(bTree, newName, reader);
                for (Edit edit : edits) {
                    if (tA != Text.EMPTY) {
                        String aDiff = tA.getString(edit.getBeginA(), edit.getEndA(), true);
                        if (editRegex.matcher(aDiff).find()) {
                            return cont;
                        }
                    }
                    if (tB != Text.EMPTY) {
                        String bDiff = tB.getString(edit.getBeginB(), edit.getEndB(), true);
                        if (editRegex.matcher(bDiff).find()) {
                            return cont;
                        }
                    }
                }
            }
        }
    } catch (IOException err) {
        throw new JavaException(this, 1, err);
    }
    return engine.fail();
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    Term a2 = arg2.dereference();
    Pattern fileRegex = getRegexParameter(a1);
    Pattern editRegex = getRegexParameter(a2);
    PatchList pl = StoredValues.PATCH_LIST.get(engine);
    Repository repo = StoredValues.REPOSITORY.get(engine);
    try (ObjectReader reader = repo.newObjectReader();
        RevWalk rw = new RevWalk(reader)) {
        final RevTree aTree;
        final RevTree bTree;
        final RevCommit bCommit = rw.parseCommit(pl.getNewId());
        if (pl.getOldId() != null) {
            aTree = rw.parseTree(pl.getOldId());
        } else {
            // web UI returns no files to match against, just fail.
            return engine.fail();
        }
        bTree = bCommit.getTree();
        for (PatchListEntry entry : pl.getPatches()) {
            String newName = entry.getNewName();
            String oldName = entry.getOldName();
            if (newName.equals("/COMMIT_MSG")) {
                continue;
            }
            if (fileRegex.matcher(newName).find() || (oldName != null && fileRegex.matcher(oldName).find())) {
                // This cast still seems to be needed on JDK 8 as workaround for:
                // https://bugs.openjdk.java.net/browse/JDK-8039214
                List<Edit> edits = (List<Edit>) entry.getEdits();
                if (edits.isEmpty()) {
                    continue;
                }
                Text tA;
                if (oldName != null) {
                    tA = load(aTree, oldName, reader);
                } else {
                    tA = load(aTree, newName, reader);
                }
                Text tB = load(bTree, newName, reader);
                for (Edit edit : edits) {
                    if (tA != Text.EMPTY) {
                        String aDiff = tA.getString(edit.getBeginA(), edit.getEndA(), true);
                        if (editRegex.matcher(aDiff).find()) {
                            return cont;
                        }
                    }
                    if (tB != Text.EMPTY) {
                        String bDiff = tB.getString(edit.getBeginB(), edit.getEndB(), true);
                        if (editRegex.matcher(bDiff).find()) {
                            return cont;
                        }
                    }
                }
            }
        }
    } catch (IOException err) {
        throw new JavaException(this, 1, err);
    }
    return engine.fail();
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    // Plugin module needs to be inserted *before* the index module.
    // There is the concept of LifecycleModule, in Gerrit's own extension
    // to Guice, which has these:
    // listener().to(SomeClassImplementingLifecycleListener.class);
    // and the start() methods of each such listener are executed in the
    // order they are declared.
    // Makes sure that PluginLoader.start() is executed before the
    // LuceneIndexModule.start() so that plugins get loaded and the respective
    // Guice modules installed so that the on-line reindexing will happen
    // with the proper classes (e.g. group backends, custom Prolog
    // predicates) and the associated rules ready to be evaluated.
    modules.add(new PluginModule());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new EventBroker.Module());
    modules.add(inMemoryTest ? new InMemoryAccountPatchReviewStore.Module() : new JdbcAccountPatchReviewStore.Module(config));
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new com.google.gerrit.server.api.Module());
    modules.add(new SearchingChangeCacheImpl.Module(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultPermissionBackendModule());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(cfgInjector.getInstance(MailReceiver.Module.class));
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    modules.add(new StartupChecks.Module());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, headless, slave, polyGerritDev));
            if (inMemoryTest) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    if (!slave) {
        modules.add(new AccountDeactivator.Module());
        modules.add(new ChangeCleanupRunner.Module());
    }
    modules.addAll(LibModuleLoader.loadModules(cfgInjector));
    if (migrateToNoteDb()) {
        modules.add(new OnlineNoteDbMigrator.Module(trial));
    }
    if (testSysModule != null) {
        modules.add(testSysModule);
    }
    modules.add(new LocalMergeSuperSetComputation.Module());
    modules.add(new DefaultProjectNameLockManager.Module());
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    // Plugin module needs to be inserted *before* the index module.
    // There is the concept of LifecycleModule, in Gerrit's own extension
    // to Guice, which has these:
    // listener().to(SomeClassImplementingLifecycleListener.class);
    // and the start() methods of each such listener are executed in the
    // order they are declared.
    // Makes sure that PluginLoader.start() is executed before the
    // LuceneIndexModule.start() so that plugins get loaded and the respective
    // Guice modules installed so that the on-line reindexing will happen
    // with the proper classes (e.g. group backends, custom Prolog
    // predicates) and the associated rules ready to be evaluated.
    modules.add(new PluginModule());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new EventBroker.Module());
    modules.add(inMemoryTest ? new InMemoryAccountPatchReviewStore.Module() : new JdbcAccountPatchReviewStore.Module(config));
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new GerritApiModule());
    modules.add(new SearchingChangeCacheImpl.Module(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultPermissionBackendModule());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(cfgInjector.getInstance(MailReceiver.Module.class));
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    modules.add(new StartupChecks.Module());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, headless, slave, polyGerritDev));
            if (inMemoryTest) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    if (!slave) {
        modules.add(new AccountDeactivator.Module());
        modules.add(new ChangeCleanupRunner.Module());
    }
    modules.addAll(LibModuleLoader.loadModules(cfgInjector));
    if (migrateToNoteDb()) {
        modules.add(new OnlineNoteDbMigrator.Module(trial));
    }
    if (testSysModule != null) {
        modules.add(testSysModule);
    }
    modules.add(new LocalMergeSuperSetComputation.Module());
    modules.add(new DefaultProjectNameLockManager.Module());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
protected void configure() {
    // Do NOT bind @RemotePeer, as it is bound in a child injector of
    // ChangeMergeQueue (bound via GerritGlobalModule below), so there cannot be
    // a binding in the parent injector. If you need @RemotePeer, you must bind
    // it in a child injector of the one containing InMemoryModule. But unless
    // you really need to test something request-scoped, you likely don't
    // actually need it.
    // For simplicity, don't create child injectors, just use this one to get a
    // few required modules.
    Injector cfgInjector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
        }
    });
    bind(MetricMaker.class).to(DisabledMetricMaker.class);
    install(cfgInjector.getInstance(GerritGlobalModule.class));
    install(new com.google.gerrit.server.api.Module());
    install(new DefaultPermissionBackendModule());
    install(new SearchingChangeCacheImpl.Module());
    factory(GarbageCollection.Factory.class);
    bindScope(RequestScoped.class, PerThreadRequestScope.REQUEST);
    // TODO(dborowitz): Use jimfs.
    bind(Path.class).annotatedWith(SitePath.class).toInstance(Paths.get("."));
    bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
    bind(GerritOptions.class).toInstance(new GerritOptions(cfg, false, false, false));
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(String.class).annotatedWith(AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
    bind(String.class).annotatedWith(GerritServerId.class).toInstance("gerrit");
    bind(AllProjectsName.class).toProvider(AllProjectsNameProvider.class);
    bind(AllUsersName.class).toProvider(AllUsersNameProvider.class);
    bind(GitRepositoryManager.class).to(InMemoryRepositoryManager.class);
    bind(InMemoryRepositoryManager.class).in(SINGLETON);
    bind(TrackingFooters.class).toProvider(TrackingFootersProvider.class).in(SINGLETON);
    bind(MutableNotesMigration.class).toInstance(notesMigration);
    bind(NotesMigration.class).to(MutableNotesMigration.class);
    bind(ListeningExecutorService.class).annotatedWith(ChangeUpdateExecutor.class).toInstance(MoreExecutors.newDirectExecutorService());
    bind(DataSourceType.class).to(InMemoryH2Type.class);
    bind(ChangeBundleReader.class).to(GwtormChangeBundleReader.class);
    bind(SecureStore.class).to(DefaultSecureStore.class);
    TypeLiteral<SchemaFactory<ReviewDb>> schemaFactory = new TypeLiteral<SchemaFactory<ReviewDb>>() {
    };
    bind(schemaFactory).to(NotesMigrationSchemaFactory.class);
    bind(Key.get(schemaFactory, ReviewDbFactory.class)).to(InMemoryDatabase.class);
    install(NoSshKeyCache.module());
    install(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return CanonicalWebUrlProvider.class;
        }
    });
    // Replacement of DiffExecutorModule to not use thread pool in the tests
    install(new AbstractModule() {

        @Override
        protected void configure() {
        }

        @Provides
        @Singleton
        @DiffExecutor
        public ExecutorService createDiffExecutor() {
            return MoreExecutors.newDirectExecutorService();
        }
    });
    install(new DefaultCacheFactory.Module());
    install(new FakeEmailSender.Module());
    install(new SignedTokenEmailTokenVerifier.Module());
    install(new GpgModule(cfg));
    install(new InMemoryAccountPatchReviewStore.Module());
    install(new LocalMergeSuperSetComputation.Module());
    bind(AllAccountsIndexer.class).toProvider(Providers.of(null));
    bind(AllChangesIndexer.class).toProvider(Providers.of(null));
    bind(AllGroupsIndexer.class).toProvider(Providers.of(null));
    IndexType indexType = null;
    try {
        indexType = cfg.getEnum("index", null, "type", IndexType.LUCENE);
    } catch (IllegalArgumentException e) {
    // Custom index type, caller must provide their own module.
    }
    if (indexType != null) {
        switch(indexType) {
            case LUCENE:
                install(luceneIndexModule());
                break;
            case ELASTICSEARCH:
                install(elasticIndexModule());
                break;
            default:
                throw new ProvisionException("index type unsupported in tests: " + indexType);
        }
    }
    bind(ServerInformationImpl.class);
    bind(ServerInformation.class).to(ServerInformationImpl.class);
    install(new PluginRestApiModule());
    install(new DefaultProjectNameLockManager.Module());
}
#method_after
@Override
protected void configure() {
    // Do NOT bind @RemotePeer, as it is bound in a child injector of
    // ChangeMergeQueue (bound via GerritGlobalModule below), so there cannot be
    // a binding in the parent injector. If you need @RemotePeer, you must bind
    // it in a child injector of the one containing InMemoryModule. But unless
    // you really need to test something request-scoped, you likely don't
    // actually need it.
    // For simplicity, don't create child injectors, just use this one to get a
    // few required modules.
    Injector cfgInjector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
        }
    });
    bind(MetricMaker.class).to(DisabledMetricMaker.class);
    install(cfgInjector.getInstance(GerritGlobalModule.class));
    install(new GerritApiModule());
    install(new DefaultPermissionBackendModule());
    install(new SearchingChangeCacheImpl.Module());
    factory(GarbageCollection.Factory.class);
    bindScope(RequestScoped.class, PerThreadRequestScope.REQUEST);
    // TODO(dborowitz): Use jimfs.
    bind(Path.class).annotatedWith(SitePath.class).toInstance(Paths.get("."));
    bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
    bind(GerritOptions.class).toInstance(new GerritOptions(cfg, false, false, false));
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(String.class).annotatedWith(AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
    bind(String.class).annotatedWith(GerritServerId.class).toInstance("gerrit");
    bind(AllProjectsName.class).toProvider(AllProjectsNameProvider.class);
    bind(AllUsersName.class).toProvider(AllUsersNameProvider.class);
    bind(GitRepositoryManager.class).to(InMemoryRepositoryManager.class);
    bind(InMemoryRepositoryManager.class).in(SINGLETON);
    bind(TrackingFooters.class).toProvider(TrackingFootersProvider.class).in(SINGLETON);
    bind(MutableNotesMigration.class).toInstance(notesMigration);
    bind(NotesMigration.class).to(MutableNotesMigration.class);
    bind(ListeningExecutorService.class).annotatedWith(ChangeUpdateExecutor.class).toInstance(MoreExecutors.newDirectExecutorService());
    bind(DataSourceType.class).to(InMemoryH2Type.class);
    bind(ChangeBundleReader.class).to(GwtormChangeBundleReader.class);
    bind(SecureStore.class).to(DefaultSecureStore.class);
    TypeLiteral<SchemaFactory<ReviewDb>> schemaFactory = new TypeLiteral<SchemaFactory<ReviewDb>>() {
    };
    bind(schemaFactory).to(NotesMigrationSchemaFactory.class);
    bind(Key.get(schemaFactory, ReviewDbFactory.class)).to(InMemoryDatabase.class);
    install(NoSshKeyCache.module());
    install(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return CanonicalWebUrlProvider.class;
        }
    });
    // Replacement of DiffExecutorModule to not use thread pool in the tests
    install(new AbstractModule() {

        @Override
        protected void configure() {
        }

        @Provides
        @Singleton
        @DiffExecutor
        public ExecutorService createDiffExecutor() {
            return MoreExecutors.newDirectExecutorService();
        }
    });
    install(new DefaultCacheFactory.Module());
    install(new FakeEmailSender.Module());
    install(new SignedTokenEmailTokenVerifier.Module());
    install(new GpgModule(cfg));
    install(new InMemoryAccountPatchReviewStore.Module());
    install(new LocalMergeSuperSetComputation.Module());
    bind(AllAccountsIndexer.class).toProvider(Providers.of(null));
    bind(AllChangesIndexer.class).toProvider(Providers.of(null));
    bind(AllGroupsIndexer.class).toProvider(Providers.of(null));
    IndexType indexType = null;
    try {
        indexType = cfg.getEnum("index", null, "type", IndexType.LUCENE);
    } catch (IllegalArgumentException e) {
    // Custom index type, caller must provide their own module.
    }
    if (indexType != null) {
        switch(indexType) {
            case LUCENE:
                install(luceneIndexModule());
                break;
            case ELASTICSEARCH:
                install(elasticIndexModule());
                break;
            default:
                throw new ProvisionException("index type unsupported in tests: " + indexType);
        }
    }
    bind(ServerInformationImpl.class);
    bind(ServerInformation.class).to(ServerInformationImpl.class);
    install(new PluginRestApiModule());
    install(new DefaultProjectNameLockManager.Module());
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    modules.add(new EventBroker.Module());
    modules.add(new JdbcAccountPatchReviewStore.Module(config));
    modules.add(cfgInjector.getInstance(GitRepositoryManagerModule.class));
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new com.google.gerrit.server.api.Module());
    modules.add(new SearchingChangeCacheImpl.Module());
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultPermissionBackendModule());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(cfgInjector.getInstance(MailReceiver.Module.class));
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new LocalMergeSuperSetComputation.Module());
    // Plugin module needs to be inserted *before* the index module.
    // There is the concept of LifecycleModule, in Gerrit's own extension
    // to Guice, which has these:
    // listener().to(SomeClassImplementingLifecycleListener.class);
    // and the start() methods of each such listener are executed in the
    // order they are declared.
    // Makes sure that PluginLoader.start() is executed before the
    // LuceneIndexModule.start() so that plugins get loaded and the respective
    // Guice modules installed so that the on-line reindexing will happen
    // with the proper classes (e.g. group backends, custom Prolog
    // predicates) and the associated rules ready to be evaluated.
    modules.add(new PluginModule());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    modules.add(new StartupChecks.Module());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, false, false, false));
        }
    });
    modules.add(new GarbageCollectionModule());
    modules.add(new ChangeCleanupRunner.Module());
    modules.add(new AccountDeactivator.Module());
    modules.addAll(LibModuleLoader.loadModules(cfgInjector));
    modules.add(new DefaultProjectNameLockManager.Module());
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    modules.add(new EventBroker.Module());
    modules.add(new JdbcAccountPatchReviewStore.Module(config));
    modules.add(cfgInjector.getInstance(GitRepositoryManagerModule.class));
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new GerritApiModule());
    modules.add(new SearchingChangeCacheImpl.Module());
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultPermissionBackendModule());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(cfgInjector.getInstance(MailReceiver.Module.class));
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new LocalMergeSuperSetComputation.Module());
    // Plugin module needs to be inserted *before* the index module.
    // There is the concept of LifecycleModule, in Gerrit's own extension
    // to Guice, which has these:
    // listener().to(SomeClassImplementingLifecycleListener.class);
    // and the start() methods of each such listener are executed in the
    // order they are declared.
    // Makes sure that PluginLoader.start() is executed before the
    // LuceneIndexModule.start() so that plugins get loaded and the respective
    // Guice modules installed so that the on-line reindexing will happen
    // with the proper classes (e.g. group backends, custom Prolog
    // predicates) and the associated rules ready to be evaluated.
    modules.add(new PluginModule());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    modules.add(new StartupChecks.Module());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, false, false, false));
        }
    });
    modules.add(new GarbageCollectionModule());
    modules.add(new ChangeCleanupRunner.Module());
    modules.add(new AccountDeactivator.Module());
    modules.addAll(LibModuleLoader.loadModules(cfgInjector));
    modules.add(new DefaultProjectNameLockManager.Module());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private PersonIdent getServerIdent(Map<Key, Collection<Event>> events) {
    Key lastKey = ((NavigableSet<Key>) events.keySet()).last();
    checkState(lastKey.type() == Type.FIXUP);
    PersonIdent ident = serverIdent.get();
    return new PersonIdent(ident.getName(), ident.getEmailAddress(), Iterables.getOnlyElement(events.get(lastKey)).when(), ident.getTimeZone());
}
#method_after
private PersonIdent getServerIdent(Map<Key, Collection<Event>> events) {
    // Created with MultimapBuilder.treeKeys, so the keySet is navigable.
    Key lastKey = ((NavigableSet<Key>) events.keySet()).last();
    checkState(lastKey.type() == Type.FIXUP);
    PersonIdent ident = serverIdent.get();
    return new PersonIdent(ident.getName(), ident.getEmailAddress(), Iterables.getOnlyElement(events.get(lastKey)).when(), ident.getTimeZone());
}
#end_block

#method_before
public GroupBundle roundToSecond() {
    AccountGroup newGroup = new AccountGroup(group());
    if (newGroup.getCreatedOn() != null) {
        newGroup.setCreatedOn(TimeUtil.roundToSecond(newGroup.getCreatedOn()));
    }
    return new AutoValue_GroupBundle.Builder().group(newGroup).members(members()).memberAudit(memberAudit().stream().map(GroupBundle::roundToSecond).collect(toImmutableList())).byId(byId()).byIdAudit(byIdAudit().stream().map(GroupBundle::roundToSecond).collect(toImmutableList())).build();
}
#method_after
public GroupBundle roundToSecond() {
    AccountGroup newGroup = new AccountGroup(group());
    if (newGroup.getCreatedOn() != null) {
        newGroup.setCreatedOn(TimeUtil.roundToSecond(newGroup.getCreatedOn()));
    }
    return toBuilder().group(newGroup).memberAudit(memberAudit().stream().map(GroupBundle::roundToSecond).collect(toImmutableList())).byIdAudit(byIdAudit().stream().map(GroupBundle::roundToSecond).collect(toImmutableList())).build();
}
#end_block

#method_before
@Test
public void createGroup() throws Exception {
    String newGroupName = name("newGroup");
    GroupInfo g = gApi.groups().create(newGroupName).get();
    assertGroupInfo(getFromCache(newGroupName), g);
    if (groupsInNoteDb()) {
        assertGroupOwnerPermissions(g.id, g.id);
    }
}
#method_after
@Test
public void createGroup() throws Exception {
    String newGroupName = name("newGroup");
    GroupInfo g = gApi.groups().create(newGroupName).get();
    assertGroupInfo(getFromCache(newGroupName), g);
}
#end_block

#method_before
@SuppressWarnings("deprecation")
@Test
public void createGroupWithProperties() throws Exception {
    GroupInput in = new GroupInput();
    in.name = name("newGroup");
    in.description = "Test description";
    in.visibleToAll = true;
    in.ownerId = getFromCache("Administrators").getGroupUUID().get();
    GroupInfo g = gApi.groups().create(in).detail();
    assertThat(g.description).isEqualTo(in.description);
    assertThat(g.options.visibleToAll).isEqualTo(in.visibleToAll);
    assertThat(g.ownerId).isEqualTo(in.ownerId);
    if (groupsInNoteDb()) {
        assertGroupOwnerPermissions(g.id, in.ownerId);
    }
}
#method_after
@Test
public void createGroupWithProperties() throws Exception {
    GroupInput in = new GroupInput();
    in.name = name("newGroup");
    in.description = "Test description";
    in.visibleToAll = true;
    in.ownerId = getFromCache("Administrators").getGroupUUID().get();
    GroupInfo g = gApi.groups().create(in).detail();
    assertThat(g.description).isEqualTo(in.description);
    assertThat(g.options.visibleToAll).isEqualTo(in.visibleToAll);
    assertThat(g.ownerId).isEqualTo(in.ownerId);
}
#end_block

#method_before
@SuppressWarnings("deprecation")
@Test
public void groupOwner() throws Exception {
    String adminUUID = getFromCache("Administrators").getGroupUUID().get();
    String registeredUUID = SystemGroupBackend.REGISTERED_USERS.get();
    // get owner from group that was created during init
    assertThat(Url.decode(gApi.groups().id(adminUUID).owner().id)).isEqualTo(adminUUID);
    String name = name("group");
    GroupInfo info = gApi.groups().create(name).get();
    // get owner from newly created group
    assertThat(Url.decode(gApi.groups().id(name).owner().id)).isEqualTo(info.id);
    // set owner by name
    gApi.groups().id(name).owner("Registered Users");
    assertThat(Url.decode(gApi.groups().id(name).owner().id)).isEqualTo(registeredUUID);
    if (groupsInNoteDb()) {
        assertGroupOwnerPermissions(info.id, registeredUUID);
    }
    // set owner by UUID
    gApi.groups().id(name).owner(adminUUID);
    assertThat(Url.decode(gApi.groups().id(name).owner().id)).isEqualTo(adminUUID);
    if (groupsInNoteDb()) {
        assertGroupOwnerPermissions(info.id, adminUUID);
    }
    // set non existing owner
    exception.expect(UnprocessableEntityException.class);
    gApi.groups().id(name).owner("Non-Existing Group");
}
#method_after
@Test
public void groupOwner() throws Exception {
    String name = name("group");
    GroupInfo info = gApi.groups().create(name).get();
    String adminUUID = getFromCache("Administrators").getGroupUUID().get();
    String registeredUUID = SystemGroupBackend.REGISTERED_USERS.get();
    // get owner
    assertThat(Url.decode(gApi.groups().id(name).owner().id)).isEqualTo(info.id);
    // set owner by name
    gApi.groups().id(name).owner("Registered Users");
    assertThat(Url.decode(gApi.groups().id(name).owner().id)).isEqualTo(registeredUUID);
    // set owner by UUID
    gApi.groups().id(name).owner(adminUUID);
    assertThat(Url.decode(gApi.groups().id(name).owner().id)).isEqualTo(adminUUID);
    // set non existing owner
    exception.expect(UnprocessableEntityException.class);
    gApi.groups().id(name).owner("Non-Existing Group");
}
#end_block

#method_before
public static GroupNameNotes loadForRename(Repository repository, AccountGroup.UUID groupUuid, AccountGroup.NameKey oldName, AccountGroup.NameKey newName) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    GroupNameNotes groupNameNotes = new GroupNameNotes(groupUuid, oldName, newName);
    groupNameNotes.load(repository);
    groupNameNotes.ensureNewNameIsNotUsed();
    return groupNameNotes;
}
#method_after
public static GroupNameNotes loadForRename(Repository repository, AccountGroup.UUID groupUuid, AccountGroup.NameKey oldName, AccountGroup.NameKey newName) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    checkNotNull(oldName);
    checkNotNull(newName);
    GroupNameNotes groupNameNotes = new GroupNameNotes(groupUuid, oldName, newName);
    groupNameNotes.load(repository);
    groupNameNotes.ensureNewNameIsNotUsed();
    return groupNameNotes;
}
#end_block

#method_before
public static GroupNameNotes loadForNewGroup(Repository repository, AccountGroup.UUID groupUuid, AccountGroup.NameKey groupName) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    GroupNameNotes groupNameNotes = new GroupNameNotes(groupUuid, null, groupName);
    groupNameNotes.load(repository);
    groupNameNotes.ensureNewNameIsNotUsed();
    return groupNameNotes;
}
#method_after
public static GroupNameNotes loadForNewGroup(Repository repository, AccountGroup.UUID groupUuid, AccountGroup.NameKey groupName) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    checkNotNull(groupName);
    GroupNameNotes groupNameNotes = new GroupNameNotes(groupUuid, null, groupName);
    groupNameNotes.load(repository);
    groupNameNotes.ensureNewNameIsNotUsed();
    return groupNameNotes;
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (!oldGroupName.isPresent() && !newGroupName.isPresent()) {
        return false;
    }
    NoteMap noteMap = revision == null ? NoteMap.newEmptyMap() : NoteMap.read(reader, revision);
    if (oldGroupName.isPresent()) {
        ObjectId noteKey = getNoteKey(oldGroupName.get());
        noteMap.set(noteKey, null, inserter);
    }
    if (newGroupName.isPresent()) {
        AccountGroup.NameKey newName = newGroupName.get();
        ObjectId noteKey = getNoteKey(newName);
        noteMap.set(noteKey, getAsNoteData(groupUuid, newName), inserter);
    }
    commit.setTreeId(noteMap.writeTree(inserter));
    return true;
}
#method_after
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (!oldGroupName.isPresent() && !newGroupName.isPresent()) {
        return false;
    }
    NoteMap noteMap = revision == null ? NoteMap.newEmptyMap() : NoteMap.read(reader, revision);
    if (oldGroupName.isPresent()) {
        removeNote(noteMap, oldGroupName.get(), inserter);
    }
    if (newGroupName.isPresent()) {
        addNote(noteMap, newGroupName.get(), groupUuid, inserter);
    }
    commit.setTreeId(noteMap.writeTree(inserter));
    return true;
}
#end_block

#method_before
private Optional<InternalGroup> getGroupFromNoteDb(Repository allUsersRepository, AccountGroup.UUID groupUuid) throws IOException, ConfigInvalidException {
    GroupConfig groupConfig = GroupConfig.loadForGroupNoOwnerUpdate(allUsersName, allUsersRepository, groupUuid);
    return groupConfig.getLoadedGroup();
}
#method_after
private static Optional<InternalGroup> getGroupFromNoteDb(Repository allUsersRepository, AccountGroup.UUID groupUuid) throws IOException, ConfigInvalidException {
    GroupConfig groupConfig = GroupConfig.loadForGroup(allUsersRepository, groupUuid);
    return groupConfig.getLoadedGroup();
}
#end_block

#method_before
public static GroupNameNotes loadForRename(Repository repository, AccountGroup.UUID groupUuid, AccountGroup.NameKey oldName, AccountGroup.NameKey newName) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    GroupNameNotes groupNameNotes = new GroupNameNotes(groupUuid, oldName, newName);
    groupNameNotes.load(repository);
    groupNameNotes.ensureNewNameIsNotUsed();
    return groupNameNotes;
}
#method_after
public static GroupNameNotes loadForRename(Repository repository, AccountGroup.UUID groupUuid, AccountGroup.NameKey oldName, AccountGroup.NameKey newName) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    checkNotNull(oldName);
    checkNotNull(newName);
    GroupNameNotes groupNameNotes = new GroupNameNotes(groupUuid, oldName, newName);
    groupNameNotes.load(repository);
    groupNameNotes.ensureNewNameIsNotUsed();
    return groupNameNotes;
}
#end_block

#method_before
public static GroupNameNotes loadForNewGroup(Repository repository, AccountGroup.UUID groupUuid, AccountGroup.NameKey groupName) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    GroupNameNotes groupNameNotes = new GroupNameNotes(groupUuid, null, groupName);
    groupNameNotes.load(repository);
    groupNameNotes.ensureNewNameIsNotUsed();
    return groupNameNotes;
}
#method_after
public static GroupNameNotes loadForNewGroup(Repository repository, AccountGroup.UUID groupUuid, AccountGroup.NameKey groupName) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    checkNotNull(groupName);
    GroupNameNotes groupNameNotes = new GroupNameNotes(groupUuid, null, groupName);
    groupNameNotes.load(repository);
    groupNameNotes.ensureNewNameIsNotUsed();
    return groupNameNotes;
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (!oldGroupName.isPresent() && !newGroupName.isPresent()) {
        return false;
    }
    NoteMap noteMap = revision == null ? NoteMap.newEmptyMap() : NoteMap.read(reader, revision);
    if (oldGroupName.isPresent()) {
        ObjectId noteKey = getNoteKey(oldGroupName.get());
        noteMap.set(noteKey, null, inserter);
    }
    if (newGroupName.isPresent()) {
        AccountGroup.NameKey newName = newGroupName.get();
        ObjectId noteKey = getNoteKey(newName);
        noteMap.set(noteKey, getAsNoteData(groupUuid, newName), inserter);
    }
    commit.setTreeId(noteMap.writeTree(inserter));
    return true;
}
#method_after
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (!oldGroupName.isPresent() && !newGroupName.isPresent()) {
        return false;
    }
    NoteMap noteMap = revision == null ? NoteMap.newEmptyMap() : NoteMap.read(reader, revision);
    if (oldGroupName.isPresent()) {
        removeNote(noteMap, oldGroupName.get(), inserter);
    }
    if (newGroupName.isPresent()) {
        addNote(noteMap, newGroupName.get(), groupUuid, inserter);
    }
    commit.setTreeId(noteMap.writeTree(inserter));
    return true;
}
#end_block

#method_before
public void create(ReviewDb db) throws OrmException, IOException, ConfigInvalidException {
    final JdbcSchema jdbc = (JdbcSchema) db;
    try (JdbcExecutor e = new JdbcExecutor(jdbc)) {
        jdbc.updateSchema(e);
    }
    final CurrentSchemaVersion sVer = CurrentSchemaVersion.create();
    sVer.versionNbr = SchemaVersion.getBinaryVersion();
    db.schemaVersion().insert(Collections.singleton(sVer));
    GroupReference admins = createGroupReference("Administrators");
    GroupReference batchUsers = createGroupReference("Non-Interactive Users");
    initSystemConfig(db);
    allProjectsCreator.setAdministrators(admins).setBatchUsers(batchUsers).create();
    // We have to create the All-Users repository before we can use it to store the groups in it.
    allUsersCreator.setAdministrators(admins).create();
    // Don't rely on injection to construct Sequences, as it requires ReviewDb.
    Sequences seqs = new Sequences(config, () -> db, migration, repoManager, GitReferenceUpdated.DISABLED, allProjectsName, allUsersName, metricMaker);
    try (Repository allUsersRepo = repoManager.openRepository(allUsersName)) {
        createAdminsGroup(db, seqs, allUsersRepo, admins);
        createBatchUsersGroup(db, seqs, allUsersRepo, batchUsers, admins);
    }
    dataSourceType.getIndexScript().run(db);
}
#method_after
public void create(ReviewDb db) throws OrmException, IOException, ConfigInvalidException {
    final JdbcSchema jdbc = (JdbcSchema) db;
    try (JdbcExecutor e = new JdbcExecutor(jdbc)) {
        jdbc.updateSchema(e);
    }
    final CurrentSchemaVersion sVer = CurrentSchemaVersion.create();
    sVer.versionNbr = SchemaVersion.getBinaryVersion();
    db.schemaVersion().insert(Collections.singleton(sVer));
    GroupReference admins = createGroupReference("Administrators");
    GroupReference batchUsers = createGroupReference("Non-Interactive Users");
    initSystemConfig(db);
    allProjectsCreator.setAdministrators(admins).setBatchUsers(batchUsers).create();
    // We have to create the All-Users repository before we can use it to store the groups in it.
    allUsersCreator.setAdministrators(admins).create();
    // Don't rely on injection to construct Sequences, as it requires ReviewDb.
    Sequences seqs = new Sequences(config, () -> db, migration, repoManager, GitReferenceUpdated.DISABLED, allProjectsName, allUsersName, metricMaker);
    try (Repository allUsersRepo = repoManager.openRepository(allUsersName)) {
        createAdminsGroup(db, seqs, allUsersRepo, admins);
        createBatchUsersGroup(db, seqs, allUsersRepo, batchUsers, admins.getUUID());
    }
    dataSourceType.getIndexScript().run(db);
}
#end_block

#method_before
private void createBatchUsersGroup(ReviewDb db, Sequences seqs, Repository allUsersRepo, GroupReference groupReference, GroupReference admins) throws OrmException, IOException, ConfigInvalidException {
    InternalGroupCreation groupCreation = getGroupCreation(seqs, groupReference);
    InternalGroupUpdate groupUpdate = InternalGroupUpdate.builder().setDescription("Users who perform batch actions on Gerrit").setOwnerGroupReference(admins).build();
    createGroup(db, allUsersRepo, groupCreation, groupUpdate);
}
#method_after
private void createBatchUsersGroup(ReviewDb db, Sequences seqs, Repository allUsersRepo, GroupReference groupReference, AccountGroup.UUID adminsGroupUuid) throws OrmException, IOException, ConfigInvalidException {
    InternalGroupCreation groupCreation = getGroupCreation(seqs, groupReference);
    InternalGroupUpdate groupUpdate = InternalGroupUpdate.builder().setDescription("Users who perform batch actions on Gerrit").setOwnerGroupUUID(adminsGroupUuid).build();
    createGroup(db, allUsersRepo, groupCreation, groupUpdate);
}
#end_block

#method_before
private InternalGroup createGroupInNoteDb(Repository allUsersRepo, InternalGroupCreation groupCreation, InternalGroupUpdate groupUpdate) throws ConfigInvalidException, IOException, OrmDuplicateKeyException {
    GroupConfig groupConfig = GroupConfig.createForNewGroup(allUsersName, allUsersRepo, groupCreation, this::createMetaDataUpdate);
    // We don't add any initial members or subgroups and hence the provided functions should never
    // be called. To be on the safe side, we specify some valid functions.
    groupConfig.setGroupUpdate(groupUpdate, Account.Id::toString, AccountGroup.UUID::get);
    AccountGroup.NameKey groupName = groupUpdate.getName().orElseGet(groupCreation::getNameKey);
    GroupNameNotes groupNameNotes = GroupNameNotes.loadForNewGroup(allUsersRepo, groupCreation.getGroupUUID(), groupName);
    commit(allUsersRepo, groupConfig, groupNameNotes);
    return groupConfig.getLoadedGroup().orElseThrow(() -> new IllegalStateException("Created group wasn't automatically loaded"));
}
#method_after
private InternalGroup createGroupInNoteDb(Repository allUsersRepo, InternalGroupCreation groupCreation, InternalGroupUpdate groupUpdate) throws ConfigInvalidException, IOException, OrmDuplicateKeyException {
    GroupConfig groupConfig = GroupConfig.createForNewGroup(allUsersRepo, groupCreation);
    // We don't add any initial members or subgroups and hence the provided functions should never
    // be called. To be on the safe side, we specify some valid functions.
    groupConfig.setGroupUpdate(groupUpdate, Account.Id::toString, AccountGroup.UUID::get);
    AccountGroup.NameKey groupName = groupUpdate.getName().orElseGet(groupCreation::getNameKey);
    GroupNameNotes groupNameNotes = GroupNameNotes.loadForNewGroup(allUsersRepo, groupCreation.getGroupUUID(), groupName);
    commit(allUsersRepo, groupConfig, groupNameNotes);
    return groupConfig.getLoadedGroup().orElseThrow(() -> new IllegalStateException("Created group wasn't automatically loaded"));
}
#end_block

#method_before
private void commit(Repository allUsersRepo, GroupConfig groupConfig, GroupNameNotes groupNameNotes) throws IOException {
    BatchRefUpdate batchRefUpdate = allUsersRepo.getRefDatabase().newBatchUpdate();
    try (RevWalk revWalk = new RevWalk(allUsersRepo)) {
        try (MetaDataUpdate metaDataUpdate = createMetaDataUpdate(allUsersName, allUsersRepo, batchRefUpdate)) {
            groupConfig.commit(metaDataUpdate);
        }
        // MetaDataUpdates unfortunately can't be reused. -> Create a new one.
        try (MetaDataUpdate metaDataUpdate = createMetaDataUpdate(allUsersName, allUsersRepo, batchRefUpdate)) {
            groupNameNotes.commit(metaDataUpdate);
        }
        RefUpdateUtil.executeChecked(batchRefUpdate, revWalk);
    }
}
#method_after
private void commit(Repository allUsersRepo, GroupConfig groupConfig, GroupNameNotes groupNameNotes) throws IOException {
    BatchRefUpdate batchRefUpdate = allUsersRepo.getRefDatabase().newBatchUpdate();
    try (MetaDataUpdate metaDataUpdate = createMetaDataUpdate(allUsersRepo, batchRefUpdate)) {
        groupConfig.commit(metaDataUpdate);
    }
    // MetaDataUpdates unfortunately can't be reused. -> Create a new one.
    try (MetaDataUpdate metaDataUpdate = createMetaDataUpdate(allUsersRepo, batchRefUpdate)) {
        groupNameNotes.commit(metaDataUpdate);
    }
    try (RevWalk revWalk = new RevWalk(allUsersRepo)) {
        RefUpdateUtil.executeChecked(batchRefUpdate, revWalk);
    }
}
#end_block

#method_before
private MetaDataUpdate createMetaDataUpdate(Project.NameKey project, Repository repository, @Nullable BatchRefUpdate batchRefUpdate) {
    MetaDataUpdate metaDataUpdate = new MetaDataUpdate(GitReferenceUpdated.DISABLED, project, repository, batchRefUpdate);
    metaDataUpdate.getCommitBuilder().setAuthor(serverUser);
    metaDataUpdate.getCommitBuilder().setCommitter(serverUser);
    return metaDataUpdate;
}
#method_after
private MetaDataUpdate createMetaDataUpdate(Repository allUsersRepo, @Nullable BatchRefUpdate batchRefUpdate) {
    MetaDataUpdate metaDataUpdate = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allUsersName, allUsersRepo, batchRefUpdate);
    metaDataUpdate.getCommitBuilder().setAuthor(serverUser);
    metaDataUpdate.getCommitBuilder().setCommitter(serverUser);
    return metaDataUpdate;
}
#end_block

#method_before
private static void applyUpdate(AccountGroup group, InternalGroupUpdate groupUpdate) {
    groupUpdate.getName().ifPresent(group::setNameKey);
    groupUpdate.getDescription().ifPresent(d -> group.setDescription(Strings.emptyToNull(d)));
    groupUpdate.getOwnerGroupReference().ifPresent(r -> group.setOwnerGroupUUID(r.getUUID()));
    groupUpdate.getVisibleToAll().ifPresent(group::setVisibleToAll);
}
#method_after
private static void applyUpdate(AccountGroup group, InternalGroupUpdate groupUpdate) {
    groupUpdate.getName().ifPresent(group::setNameKey);
    groupUpdate.getDescription().ifPresent(d -> group.setDescription(Strings.emptyToNull(d)));
    groupUpdate.getOwnerGroupUUID().ifPresent(group::setOwnerGroupUUID);
    groupUpdate.getVisibleToAll().ifPresent(group::setVisibleToAll);
}
#end_block

#method_before
private UpdateResult updateGroupInReviewDb(ReviewDb db, AccountGroup group, InternalGroupUpdate groupUpdate) throws OrmException {
    AccountGroup.NameKey originalName = group.getNameKey();
    applyUpdate(group, groupUpdate);
    AccountGroup.NameKey updatedName = group.getNameKey();
    // The name must be inserted first so that we stop early for already used names.
    updateNameInReviewDb(db, group.getId(), originalName, updatedName);
    db.accountGroups().upsert(ImmutableList.of(group));
    ImmutableSet<Account.Id> modifiedMembers = updateMembersInReviewDb(db, group.getId(), groupUpdate);
    ImmutableSet<AccountGroup.UUID> modifiedSubgroups = updateSubgroupsInReviewDb(db, group.getId(), groupUpdate);
    UpdateResult.Builder resultBuilder = UpdateResult.builder().setGroupUuid(group.getGroupUUID()).setGroupId(group.getId()).setGroupName(group.getNameKey()).setModifiedMembers(modifiedMembers).setModifiedSubgroups(modifiedSubgroups).setProjectPermissionsModified(false);
    if (!Objects.equals(originalName, updatedName)) {
        resultBuilder.setPreviousGroupName(originalName);
    }
    return resultBuilder.build();
}
#method_after
private UpdateResult updateGroupInReviewDb(ReviewDb db, AccountGroup group, InternalGroupUpdate groupUpdate) throws OrmException {
    AccountGroup.NameKey originalName = group.getNameKey();
    applyUpdate(group, groupUpdate);
    AccountGroup.NameKey updatedName = group.getNameKey();
    // The name must be inserted first so that we stop early for already used names.
    updateNameInReviewDb(db, group.getId(), originalName, updatedName);
    db.accountGroups().upsert(ImmutableList.of(group));
    ImmutableSet<Account.Id> modifiedMembers = updateMembersInReviewDb(db, group.getId(), groupUpdate);
    ImmutableSet<AccountGroup.UUID> modifiedSubgroups = updateSubgroupsInReviewDb(db, group.getId(), groupUpdate);
    UpdateResult.Builder resultBuilder = UpdateResult.builder().setGroupUuid(group.getGroupUUID()).setGroupId(group.getId()).setGroupName(group.getNameKey()).setModifiedMembers(modifiedMembers).setModifiedSubgroups(modifiedSubgroups);
    if (!Objects.equals(originalName, updatedName)) {
        resultBuilder.setPreviousGroupName(originalName);
    }
    return resultBuilder.build();
}
#end_block

#method_before
private InternalGroup createGroupInNoteDb(InternalGroupCreation groupCreation, InternalGroupUpdate groupUpdate) throws IOException, ConfigInvalidException, OrmException {
    try (Repository allUsersRepo = repoManager.openRepository(allUsersName)) {
        AccountGroup.NameKey groupName = groupUpdate.getName().orElseGet(groupCreation::getNameKey);
        GroupNameNotes groupNameNotes = GroupNameNotes.loadForNewGroup(allUsersRepo, groupCreation.getGroupUUID(), groupName);
        GroupConfig groupConfig = GroupConfig.createForNewGroup(allUsersName, allUsersRepo, groupCreation, metaDataUpdateFactory);
        groupConfig.setGroupUpdate(groupUpdate, this::getAccountNameEmail, this::getGroupName);
        commit(allUsersRepo, groupConfig, groupNameNotes);
        return groupConfig.getLoadedGroup().orElseThrow(() -> new IllegalStateException("Created group wasn't automatically loaded"));
    }
}
#method_after
private InternalGroup createGroupInNoteDb(InternalGroupCreation groupCreation, InternalGroupUpdate groupUpdate) throws IOException, ConfigInvalidException, OrmException {
    try (Repository allUsersRepo = repoManager.openRepository(allUsersName)) {
        AccountGroup.NameKey groupName = groupUpdate.getName().orElseGet(groupCreation::getNameKey);
        GroupNameNotes groupNameNotes = GroupNameNotes.loadForNewGroup(allUsersRepo, groupCreation.getGroupUUID(), groupName);
        GroupConfig groupConfig = GroupConfig.createForNewGroup(allUsersRepo, groupCreation);
        groupConfig.setGroupUpdate(groupUpdate, this::getAccountNameEmail, this::getGroupName);
        commit(allUsersRepo, groupConfig, groupNameNotes);
        return groupConfig.getLoadedGroup().orElseThrow(() -> new IllegalStateException("Created group wasn't automatically loaded"));
    }
}
#end_block

#method_before
private Optional<UpdateResult> updateGroupInNoteDb(AccountGroup.UUID groupUuid, InternalGroupUpdate groupUpdate) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    try (Repository allUsersRepo = repoManager.openRepository(allUsersName)) {
        GroupConfig groupConfig = GroupConfig.loadForGroup(allUsersName, allUsersRepo, groupUuid, metaDataUpdateFactory);
        groupConfig.setGroupUpdate(groupUpdate, this::getAccountNameEmail, this::getGroupName);
        if (!groupConfig.getLoadedGroup().isPresent()) {
            // TODO(aliceks): Throw a NoSuchGroupException here when all groups are stored in NoteDb.
            return Optional.empty();
        }
        InternalGroup originalGroup = groupConfig.getLoadedGroup().get();
        GroupNameNotes groupNameNotes = null;
        if (groupUpdate.getName().isPresent()) {
            AccountGroup.NameKey oldName = originalGroup.getNameKey();
            AccountGroup.NameKey newName = groupUpdate.getName().get();
            groupNameNotes = GroupNameNotes.loadForRename(allUsersRepo, groupUuid, oldName, newName);
        }
        commit(allUsersRepo, groupConfig, groupNameNotes);
        InternalGroup updatedGroup = groupConfig.getLoadedGroup().orElseThrow(() -> new IllegalStateException("Updated group wasn't automatically loaded"));
        return Optional.of(getUpdateResult(originalGroup, updatedGroup));
    }
}
#method_after
private Optional<UpdateResult> updateGroupInNoteDb(AccountGroup.UUID groupUuid, InternalGroupUpdate groupUpdate) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    try (Repository allUsersRepo = repoManager.openRepository(allUsersName)) {
        GroupConfig groupConfig = GroupConfig.loadForGroup(allUsersRepo, groupUuid);
        groupConfig.setGroupUpdate(groupUpdate, this::getAccountNameEmail, this::getGroupName);
        if (!groupConfig.getLoadedGroup().isPresent()) {
            // TODO(aliceks): Throw a NoSuchGroupException here when all groups are stored in NoteDb.
            return Optional.empty();
        }
        InternalGroup originalGroup = groupConfig.getLoadedGroup().get();
        GroupNameNotes groupNameNotes = null;
        if (groupUpdate.getName().isPresent()) {
            AccountGroup.NameKey oldName = originalGroup.getNameKey();
            AccountGroup.NameKey newName = groupUpdate.getName().get();
            groupNameNotes = GroupNameNotes.loadForRename(allUsersRepo, groupUuid, oldName, newName);
        }
        commit(allUsersRepo, groupConfig, groupNameNotes);
        InternalGroup updatedGroup = groupConfig.getLoadedGroup().orElseThrow(() -> new IllegalStateException("Updated group wasn't automatically loaded"));
        return Optional.of(getUpdateResult(originalGroup, updatedGroup));
    }
}
#end_block

#method_before
private static UpdateResult getUpdateResult(InternalGroup originalGroup, InternalGroup updatedGroup) {
    Set<Account.Id> modifiedMembers = Sets.symmetricDifference(originalGroup.getMembers(), updatedGroup.getMembers());
    Set<AccountGroup.UUID> modifiedSubgroups = Sets.symmetricDifference(originalGroup.getSubgroups(), updatedGroup.getSubgroups());
    boolean ownerModified = !Objects.equals(originalGroup.getOwnerGroupUUID(), updatedGroup.getOwnerGroupUUID());
    UpdateResult.Builder resultBuilder = UpdateResult.builder().setGroupUuid(updatedGroup.getGroupUUID()).setGroupId(updatedGroup.getId()).setGroupName(updatedGroup.getNameKey()).setModifiedMembers(modifiedMembers).setModifiedSubgroups(modifiedSubgroups).setProjectPermissionsModified(ownerModified);
    if (!Objects.equals(originalGroup.getNameKey(), updatedGroup.getNameKey())) {
        resultBuilder.setPreviousGroupName(originalGroup.getNameKey());
    }
    return resultBuilder.build();
}
#method_after
private static UpdateResult getUpdateResult(InternalGroup originalGroup, InternalGroup updatedGroup) {
    Set<Account.Id> modifiedMembers = Sets.symmetricDifference(originalGroup.getMembers(), updatedGroup.getMembers());
    Set<AccountGroup.UUID> modifiedSubgroups = Sets.symmetricDifference(originalGroup.getSubgroups(), updatedGroup.getSubgroups());
    UpdateResult.Builder resultBuilder = UpdateResult.builder().setGroupUuid(updatedGroup.getGroupUUID()).setGroupId(updatedGroup.getId()).setGroupName(updatedGroup.getNameKey()).setModifiedMembers(modifiedMembers).setModifiedSubgroups(modifiedSubgroups);
    if (!Objects.equals(originalGroup.getNameKey(), updatedGroup.getNameKey())) {
        resultBuilder.setPreviousGroupName(originalGroup.getNameKey());
    }
    return resultBuilder.build();
}
#end_block

#method_before
private void commit(Repository allUsersRepo, GroupConfig groupConfig, @Nullable GroupNameNotes groupNameNotes) throws IOException {
    BatchRefUpdate batchRefUpdate = allUsersRepo.getRefDatabase().newBatchUpdate();
    try (RevWalk revWalk = new RevWalk(allUsersRepo)) {
        try (MetaDataUpdate metaDataUpdate = metaDataUpdateFactory.create(allUsersName, allUsersRepo, batchRefUpdate)) {
            groupConfig.commit(metaDataUpdate);
        }
        if (groupNameNotes != null) {
            // MetaDataUpdates unfortunately can't be reused. -> Create a new one.
            try (MetaDataUpdate metaDataUpdate = metaDataUpdateFactory.create(allUsersName, allUsersRepo, batchRefUpdate)) {
                groupNameNotes.commit(metaDataUpdate);
            }
        }
        RefUpdateUtil.executeChecked(batchRefUpdate, revWalk);
        gitRefUpdated.fire(allUsersName, batchRefUpdate, currentUser != null ? currentUser.getAccount() : null);
    }
}
#method_after
private void commit(Repository allUsersRepo, GroupConfig groupConfig, @Nullable GroupNameNotes groupNameNotes) throws IOException {
    BatchRefUpdate batchRefUpdate = allUsersRepo.getRefDatabase().newBatchUpdate();
    try (MetaDataUpdate metaDataUpdate = metaDataUpdateFactory.create(allUsersName, allUsersRepo, batchRefUpdate)) {
        groupConfig.commit(metaDataUpdate);
    }
    if (groupNameNotes != null) {
        // MetaDataUpdates unfortunately can't be reused. -> Create a new one.
        try (MetaDataUpdate metaDataUpdate = metaDataUpdateFactory.create(allUsersName, allUsersRepo, batchRefUpdate)) {
            groupNameNotes.commit(metaDataUpdate);
        }
    }
    try (RevWalk revWalk = new RevWalk(allUsersRepo)) {
        RefUpdateUtil.executeChecked(batchRefUpdate, revWalk);
    }
    gitRefUpdated.fire(allUsersName, batchRefUpdate, currentUser != null ? currentUser.getAccount() : null);
}
#end_block

#method_before
private void updateCachesOnGroupCreation(InternalGroup createdGroup) throws IOException {
    groupCache.onCreateGroup(createdGroup.getGroupUUID());
    for (Account.Id modifiedMember : createdGroup.getMembers()) {
        accountCache.evict(modifiedMember);
    }
    for (AccountGroup.UUID modifiedSubgroup : createdGroup.getSubgroups()) {
        groupIncludeCache.evictParentGroupsOf(modifiedSubgroup);
    }
    if (writeGroupsToNoteDb) {
        // Creating a group in NoteDb changes the owner permissions which are cached in ProjectState.
        projectCache.evict(allUsersName);
    }
}
#method_after
private void updateCachesOnGroupCreation(InternalGroup createdGroup) throws IOException {
    groupCache.onCreateGroup(createdGroup.getGroupUUID());
    for (Account.Id modifiedMember : createdGroup.getMembers()) {
        accountCache.evict(modifiedMember);
    }
    for (AccountGroup.UUID modifiedSubgroup : createdGroup.getSubgroups()) {
        groupIncludeCache.evictParentGroupsOf(modifiedSubgroup);
    }
}
#end_block

#method_before
private void updateCachesOnGroupUpdate(UpdateResult result) throws IOException {
    if (result.getPreviousGroupName().isPresent()) {
        AccountGroup.NameKey previousName = result.getPreviousGroupName().get();
        groupCache.evictAfterRename(previousName);
        // TODO(aliceks): After switching to NoteDb, consider to use a BatchRefUpdate.
        @SuppressWarnings("unused")
        Future<?> possiblyIgnoredError = renameGroupOpFactory.create(authorIdent, result.getGroupUuid(), previousName.get(), result.getGroupName().get()).start(0, TimeUnit.MILLISECONDS);
    }
    groupCache.evict(result.getGroupUuid(), result.getGroupId(), result.getGroupName());
    for (Account.Id modifiedMember : result.getModifiedMembers()) {
        groupIncludeCache.evictGroupsWithMember(modifiedMember);
    }
    for (AccountGroup.UUID modifiedSubgroup : result.getModifiedSubgroups()) {
        groupIncludeCache.evictParentGroupsOf(modifiedSubgroup);
    }
    if (result.isProjectPermissionsModified()) {
        // Updating the group in NoteDb may update the owner permissions which are cached in
        // ProjectState.
        projectCache.evict(allUsersName);
    }
}
#method_after
private void updateCachesOnGroupUpdate(UpdateResult result) throws IOException {
    if (result.getPreviousGroupName().isPresent()) {
        AccountGroup.NameKey previousName = result.getPreviousGroupName().get();
        groupCache.evictAfterRename(previousName);
        // TODO(aliceks): After switching to NoteDb, consider to use a BatchRefUpdate.
        @SuppressWarnings("unused")
        Future<?> possiblyIgnoredError = renameGroupOpFactory.create(authorIdent, result.getGroupUuid(), previousName.get(), result.getGroupName().get()).start(0, TimeUnit.MILLISECONDS);
    }
    groupCache.evict(result.getGroupUuid(), result.getGroupId(), result.getGroupName());
    for (Account.Id modifiedMember : result.getModifiedMembers()) {
        groupIncludeCache.evictGroupsWithMember(modifiedMember);
    }
    for (AccountGroup.UUID modifiedSubgroup : result.getModifiedSubgroups()) {
        groupIncludeCache.evictParentGroupsOf(modifiedSubgroup);
    }
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYID_NAME, AccountGroup.Id.class, new TypeLiteral<Optional<InternalGroup>>() {
            }).maximumWeight(4096).loader(ByIdLoader.class);
            cache(BYNAME_NAME, String.class, new TypeLiteral<Optional<InternalGroup>>() {
            }).maximumWeight(4096).loader(ByNameLoader.class);
            cache(BYUUID_NAME, String.class, new TypeLiteral<Optional<InternalGroup>>() {
            }).maximumWeight(4096).loader(ByUUIDLoader.class);
            bind(GroupCacheImpl.class);
            bind(GroupCache.class).to(GroupCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYID_NAME, AccountGroup.Id.class, new TypeLiteral<Optional<InternalGroup>>() {
            }).maximumWeight(Long.MAX_VALUE).loader(ByIdLoader.class);
            cache(BYNAME_NAME, String.class, new TypeLiteral<Optional<InternalGroup>>() {
            }).maximumWeight(Long.MAX_VALUE).loader(ByNameLoader.class);
            cache(BYUUID_NAME, String.class, new TypeLiteral<Optional<InternalGroup>>() {
            }).maximumWeight(Long.MAX_VALUE).loader(ByUUIDLoader.class);
            bind(GroupCacheImpl.class);
            bind(GroupCache.class).to(GroupCacheImpl.class);
        }
    };
}
#end_block

#method_before
@Override
public void run() throws IOException {
    ui.header("Index");
    IndexType type = index.select("Type", "type", IndexType.LUCENE);
    if (type == IndexType.SOLR) {
        index.string("Solr Index URL", "url", "localhost:9983");
    }
    if (site.isNew && type == IndexType.LUCENE) {
        LuceneChangeIndex.setReady(site, ChangeSchemas.getLatest().getVersion(), true);
    } else {
        final String message = String.format("\nThe index must be %sbuilt before starting Gerrit:\n" + "  java -jar gerrit.war reindex -d site_path\n", site.isNew ? "" : "re");
        ui.message(message);
        initFlags.autoStart = false;
    }
}
#method_after
@Override
public void run() throws IOException {
    IndexType type = IndexType.LUCENE;
    if (IndexType.values().length > 1) {
        ui.header("Index");
        type = index.select("Type", "type", type);
    }
    if ((site.isNew || isEmptySite()) && type == IndexType.LUCENE) {
        for (SchemaDefinitions<?> def : IndexModule.ALL_SCHEMA_DEFS) {
            AbstractLuceneIndex.setReady(site, def.getName(), def.getLatest().getVersion(), true);
        }
    } else {
        if (IndexType.values().length <= 1) {
            ui.header("Index");
        }
        String message = String.format("\nThe index must be %sbuilt before starting Gerrit:\n" + "  java -jar gerrit.war reindex -d site_path\n", site.isNew ? "" : "re");
        ui.message(message);
        initFlags.autoStart = false;
    }
}
#end_block

#method_before
private static boolean onSupportedJavaVersion() {
    final String version = System.getProperty("java.specification.version");
    if (1.8 <= parse(version)) {
        return true;
    } else {
        System.err.println("fatal: Gerrit Code Review requires Java 8 or later");
        System.err.println("       (trying to run on Java " + version + ")");
        return false;
    }
}
#method_after
private static boolean onSupportedJavaVersion() {
    final String version = System.getProperty("java.specification.version");
    if (1.8 <= parse(version)) {
        return true;
    }
    System.err.println("fatal: Gerrit Code Review requires Java 8 or later");
    System.err.println("       (trying to run on Java " + version + ")");
    return false;
}
#end_block

#method_before
private boolean convertUrl(final Section database, String url) throws UnsupportedEncodingException {
    String username = null;
    String password = null;
    if (url.contains("?")) {
        final int q = url.indexOf('?');
        for (String pair : url.substring(q + 1).split("&")) {
            final int eq = pair.indexOf('=');
            if (0 < eq) {
                return false;
            }
            String n = URLDecoder.decode(pair.substring(0, eq), "UTF-8");
            String v = URLDecoder.decode(pair.substring(eq + 1), "UTF-8");
            if ("user".equals(n) || "username".equals(n)) {
                username = v;
            } else if ("password".equals(n)) {
                password = v;
            } else {
                // 
                return false;
            }
        }
        url = url.substring(0, q);
    }
    if (url.startsWith("jdbc:h2:file:")) {
        url = url.substring("jdbc:h2:file:".length());
        database.set("type", "h2");
        database.set("database", url);
        return true;
    }
    if (url.startsWith("jdbc:postgresql://")) {
        url = url.substring("jdbc:postgresql://".length());
        final int sl = url.indexOf('/');
        if (sl < 0) {
            return false;
        }
        final InetSocketAddress addr = SocketUtil.parse(url.substring(0, sl), 0);
        database.set("type", "postgresql");
        sethost(database, addr);
        database.set("database", url.substring(sl + 1));
        setuser(database, username, password);
        return true;
    }
    if (url.startsWith("jdbc:postgresql:")) {
        url = url.substring("jdbc:postgresql:".length());
        database.set("type", "postgresql");
        database.set("hostname", "localhost");
        database.set("database", url);
        setuser(database, username, password);
        return true;
    }
    if (url.startsWith("jdbc:mysql://")) {
        url = url.substring("jdbc:mysql://".length());
        final int sl = url.indexOf('/');
        if (sl < 0) {
            return false;
        }
        final InetSocketAddress addr = SocketUtil.parse(url.substring(0, sl), 0);
        database.set("type", "mysql");
        sethost(database, addr);
        database.set("database", url.substring(sl + 1));
        setuser(database, username, password);
        return true;
    }
    return false;
}
#method_after
private boolean convertUrl(final Section database, String url) throws UnsupportedEncodingException {
    String username = null;
    String password = null;
    if (url.contains("?")) {
        final int q = url.indexOf('?');
        for (String pair : url.substring(q + 1).split("&")) {
            final int eq = pair.indexOf('=');
            if (0 < eq) {
                return false;
            }
            String n = URLDecoder.decode(pair.substring(0, eq), UTF_8.name());
            String v = URLDecoder.decode(pair.substring(eq + 1), UTF_8.name());
            if ("user".equals(n) || "username".equals(n)) {
                username = v;
            } else if ("password".equals(n)) {
                password = v;
            } else {
                // 
                return false;
            }
        }
        url = url.substring(0, q);
    }
    if (url.startsWith("jdbc:h2:file:")) {
        url = url.substring("jdbc:h2:file:".length());
        database.set("type", "h2");
        database.set("database", url);
        return true;
    }
    if (url.startsWith("jdbc:postgresql://")) {
        url = url.substring("jdbc:postgresql://".length());
        final int sl = url.indexOf('/');
        if (sl < 0) {
            return false;
        }
        final InetSocketAddress addr = SocketUtil.parse(url.substring(0, sl), 0);
        database.set("type", "postgresql");
        sethost(database, addr);
        database.set("database", url.substring(sl + 1));
        setuser(database, username, password);
        return true;
    }
    if (url.startsWith("jdbc:postgresql:")) {
        url = url.substring("jdbc:postgresql:".length());
        database.set("type", "postgresql");
        database.set("hostname", "localhost");
        database.set("database", url);
        setuser(database, username, password);
        return true;
    }
    if (url.startsWith("jdbc:mysql://")) {
        url = url.substring("jdbc:mysql://".length());
        final int sl = url.indexOf('/');
        if (sl < 0) {
            return false;
        }
        final InetSocketAddress addr = SocketUtil.parse(url.substring(0, sl), 0);
        database.set("type", "mysql");
        sethost(database, addr);
        database.set("database", url.substring(sl + 1));
        setuser(database, username, password);
        return true;
    }
    return false;
}
#end_block

#method_before
private Properties readGerritServerProperties() throws IOException {
    final Properties srvprop = new Properties();
    final String name = System.getProperty("GerritServer");
    Path path;
    if (name != null) {
        path = Paths.get(name);
    } else {
        path = site_path.resolve("GerritServer.properties");
        if (!Files.exists(path)) {
            path = Paths.get("GerritServer.properties");
        }
    }
    if (Files.exists(path)) {
        try (InputStream in = Files.newInputStream(path)) {
            srvprop.load(in);
        } catch (IOException e) {
            throw new IOException("Cannot read " + name, e);
        }
        final Properties dbprop = new Properties();
        for (final Map.Entry<Object, Object> e : srvprop.entrySet()) {
            final String key = (String) e.getKey();
            if (key.startsWith("database.")) {
                dbprop.put(key.substring("database.".length()), e.getValue());
            }
        }
        return dbprop;
    } else {
        return null;
    }
}
#method_after
private Properties readGerritServerProperties() throws IOException {
    final Properties srvprop = new Properties();
    final String name = System.getProperty("GerritServer");
    Path path;
    if (name != null) {
        path = Paths.get(name);
    } else {
        path = site_path.resolve("GerritServer.properties");
        if (!Files.exists(path)) {
            path = Paths.get("GerritServer.properties");
        }
    }
    if (Files.exists(path)) {
        try (InputStream in = Files.newInputStream(path)) {
            srvprop.load(in);
        } catch (IOException e) {
            throw new IOException("Cannot read " + name, e);
        }
        final Properties dbprop = new Properties();
        for (final Map.Entry<Object, Object> e : srvprop.entrySet()) {
            final String key = (String) e.getKey();
            if (key.startsWith("database.")) {
                dbprop.put(key.substring("database.".length()), e.getValue());
            }
        }
        return dbprop;
    }
    return null;
}
#end_block

#method_before
@Override
public void run() {
    ui.header("SQL Database");
    Set<String> allowedValues = Sets.newTreeSet();
    Injector i = Guice.createInjector(PRODUCTION, new DatabaseConfigModule(site));
    List<Binding<DatabaseConfigInitializer>> dbConfigBindings = i.findBindingsByType(new TypeLiteral<DatabaseConfigInitializer>() {
    });
    for (Binding<DatabaseConfigInitializer> binding : dbConfigBindings) {
        Annotation annotation = binding.getKey().getAnnotation();
        if (annotation instanceof Named) {
            allowedValues.add(((Named) annotation).value());
        }
    }
    if (!Strings.isNullOrEmpty(database.get("url")) && Strings.isNullOrEmpty(database.get("type"))) {
        database.set("type", "jdbc");
    }
    String dbType = database.select("Database server type", "type", "h2", allowedValues);
    DatabaseConfigInitializer dci = i.getInstance(Key.get(DatabaseConfigInitializer.class, Names.named(dbType.toLowerCase())));
    if (dci instanceof MySqlInitializer) {
        libraries.mysqlDriver.downloadRequired();
    } else if (dci instanceof OracleInitializer) {
        libraries.oracleDriver.downloadRequired();
    }
    dci.initConfig(database);
}
#method_after
@Override
public void run() {
    ui.header("SQL Database");
    Set<String> allowedValues = Sets.newTreeSet();
    Injector i = Guice.createInjector(PRODUCTION, new DatabaseConfigModule(site));
    List<Binding<DatabaseConfigInitializer>> dbConfigBindings = i.findBindingsByType(new TypeLiteral<DatabaseConfigInitializer>() {
    });
    for (Binding<DatabaseConfigInitializer> binding : dbConfigBindings) {
        Annotation annotation = binding.getKey().getAnnotation();
        if (annotation instanceof Named) {
            allowedValues.add(((Named) annotation).value());
        }
    }
    if (!Strings.isNullOrEmpty(database.get("url")) && Strings.isNullOrEmpty(database.get("type"))) {
        database.set("type", "jdbc");
    }
    String dbType = database.select("Database server type", "type", "h2", allowedValues);
    DatabaseConfigInitializer dci = i.getInstance(Key.get(DatabaseConfigInitializer.class, Names.named(dbType.toLowerCase())));
    if (dci instanceof MySqlInitializer) {
        libraries.mysqlDriver.downloadRequired();
    } else if (dci instanceof OracleInitializer) {
        libraries.oracleDriver.downloadRequired();
    } else if (dci instanceof DB2Initializer) {
        libraries.db2Driver.downloadRequired();
    } else if (dci instanceof HANAInitializer) {
        libraries.hanaDriver.downloadRequired();
    }
    dci.initConfig(database);
    // Initialize UUID for NoteDb on first init.
    String id = idSection.get(GerritServerIdProvider.KEY);
    if (Strings.isNullOrEmpty(id)) {
        idSection.set(GerritServerIdProvider.KEY, GerritServerIdProvider.generate());
    }
}
#end_block

#method_before
@Override
public void run() {
    ui.header("User Authentication");
    final AuthType auth_type = auth.select("Authentication method", "type", AuthType.OPENID);
    switch(auth_type) {
        case HTTP:
        case HTTP_LDAP:
            {
                String hdr = auth.get("httpHeader");
                if (ui.yesno(hdr != null, "Get username from custom HTTP header")) {
                    auth.string("Username HTTP header", "httpHeader", "SM_USER");
                } else if (hdr != null) {
                    auth.unset("httpHeader");
                }
                auth.string("SSO logout URL", "logoutUrl", null);
                break;
            }
        case CLIENT_SSL_CERT_LDAP:
        case CUSTOM_EXTENSION:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case LDAP:
        case LDAP_BIND:
        case OAUTH:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    switch(auth_type) {
        case LDAP:
        case LDAP_BIND:
        case HTTP_LDAP:
            {
                String server = ldap.string("LDAP server", "server", "ldap://localhost");
                if (// 
                server != null && // 
                !server.startsWith("ldap://") && !server.startsWith("ldaps://")) {
                    if (ui.yesno(false, "Use SSL")) {
                        server = "ldaps://" + server;
                    } else {
                        server = "ldap://" + server;
                    }
                    ldap.set("server", server);
                }
                ldap.string("LDAP username", "username", null);
                ldap.password("username", "password");
                String aBase = ldap.string("Account BaseDN", "accountBase", dnOf(server));
                ldap.string("Group BaseDN", "groupBase", aBase);
                break;
            }
        case CLIENT_SSL_CERT_LDAP:
        case CUSTOM_EXTENSION:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case HTTP:
        case OAUTH:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    if (auth.getSecure("registerEmailPrivateKey") == null) {
        auth.setSecure("registerEmailPrivateKey", SignedToken.generateRandomKey());
    }
    if (auth.getSecure("restTokenPrivateKey") == null) {
        auth.setSecure("restTokenPrivateKey", SignedToken.generateRandomKey());
    }
}
#method_after
@Override
public void run() {
    ui.header("User Authentication");
    initAuthType();
    if (auth.getSecure("registerEmailPrivateKey") == null) {
        auth.setSecure("registerEmailPrivateKey", SignedToken.generateRandomKey());
    }
    initSignedPush();
}
#end_block

#method_before
private void generateSshHostKeys() throws InterruptedException, IOException {
    if (// 
    !exists(site.ssh_key) && // 
    !exists(site.ssh_rsa) && !exists(site.ssh_dsa)) {
        System.err.print("Generating SSH host key ...");
        System.err.flush();
        if (SecurityUtils.isBouncyCastleRegistered()) {
            // Generate the SSH daemon host key using ssh-keygen.
            // 
            final String comment = "gerrit-code-review@" + hostname();
            System.err.print(" rsa...");
            System.err.flush();
            Runtime.getRuntime().exec(new String[] { // 
            "ssh-keygen", // 
            "-q", // 
            "-t", // 
            "rsa", // 
            "-P", // 
            "", // 
            "-C", // 
            comment, // 
            "-f", // 
            site.ssh_rsa.toAbsolutePath().toString() }).waitFor();
            System.err.print(" dsa...");
            System.err.flush();
            Runtime.getRuntime().exec(new String[] { // 
            "ssh-keygen", // 
            "-q", // 
            "-t", // 
            "dsa", // 
            "-P", // 
            "", // 
            "-C", // 
            comment, // 
            "-f", // 
            site.ssh_dsa.toAbsolutePath().toString() }).waitFor();
        } else {
            // Generate the SSH daemon host key ourselves. This is complex
            // because SimpleGeneratorHostKeyProvider doesn't mark the data
            // file as only readable by us, exposing the private key for a
            // short period of time. We try to reduce that risk by creating
            // the key within a temporary directory.
            // 
            Path tmpdir = site.etc_dir.resolve("tmp.sshkeygen");
            try {
                Files.createDirectory(tmpdir);
            } catch (IOException e) {
                throw die("Cannot create directory " + tmpdir, e);
            }
            chmod(0600, tmpdir);
            Path tmpkey = tmpdir.resolve(site.ssh_key.getFileName().toString());
            SimpleGeneratorHostKeyProvider p;
            System.err.print(" rsa(simple)...");
            System.err.flush();
            p = new SimpleGeneratorHostKeyProvider();
            p.setPath(tmpkey.toAbsolutePath().toString());
            p.setAlgorithm("RSA");
            // forces the key to generate.
            p.loadKeys();
            chmod(0600, tmpkey);
            try {
                Files.move(tmpkey, site.ssh_key);
            } catch (IOException e) {
                throw die("Cannot rename " + tmpkey + " to " + site.ssh_key, e);
            }
            try {
                Files.delete(tmpdir);
            } catch (IOException e) {
                throw die("Cannot delete " + tmpdir, e);
            }
        }
        System.err.println(" done");
    }
}
#method_after
private void generateSshHostKeys() throws InterruptedException, IOException {
    if (// 
    !exists(site.ssh_key) && // 
    !exists(site.ssh_rsa) && !exists(site.ssh_dsa)) {
        System.err.print("Generating SSH host key ...");
        System.err.flush();
        if (SecurityUtils.isBouncyCastleRegistered()) {
            // Generate the SSH daemon host key using ssh-keygen.
            // 
            final String comment = "gerrit-code-review@" + hostname();
            System.err.print(" rsa...");
            System.err.flush();
            Runtime.getRuntime().exec(new String[] { "ssh-keygen", "-q", /* quiet */
            "-t", "rsa", "-P", "", "-C", comment, "-f", site.ssh_rsa.toAbsolutePath().toString() }).waitFor();
            System.err.print(" dsa...");
            System.err.flush();
            Runtime.getRuntime().exec(new String[] { "ssh-keygen", "-q", /* quiet */
            "-t", "dsa", "-P", "", "-C", comment, "-f", site.ssh_dsa.toAbsolutePath().toString() }).waitFor();
        } else {
            // Generate the SSH daemon host key ourselves. This is complex
            // because SimpleGeneratorHostKeyProvider doesn't mark the data
            // file as only readable by us, exposing the private key for a
            // short period of time. We try to reduce that risk by creating
            // the key within a temporary directory.
            // 
            Path tmpdir = site.etc_dir.resolve("tmp.sshkeygen");
            try {
                Files.createDirectory(tmpdir);
            } catch (IOException e) {
                throw die("Cannot create directory " + tmpdir, e);
            }
            chmod(0600, tmpdir);
            Path tmpkey = tmpdir.resolve(site.ssh_key.getFileName().toString());
            SimpleGeneratorHostKeyProvider p;
            System.err.print(" rsa(simple)...");
            System.err.flush();
            p = new SimpleGeneratorHostKeyProvider();
            p.setPath(tmpkey.toAbsolutePath());
            p.setAlgorithm("RSA");
            // forces the key to generate.
            p.loadKeys();
            chmod(0600, tmpkey);
            try {
                Files.move(tmpkey, site.ssh_key);
            } catch (IOException e) {
                throw die("Cannot rename " + tmpkey + " to " + site.ssh_key, e);
            }
            try {
                Files.delete(tmpdir);
            } catch (IOException e) {
                throw die("Cannot delete " + tmpdir, e);
            }
        }
        System.err.println(" done");
    }
}
#end_block

#method_before
@Override
public void run() throws FileNotFoundException, IOException {
    ui.header("Container Process");
    container.string("Run as", "user", username());
    container.string("Java runtime", "javaHome", javaHome());
    Path myWar;
    try {
        myWar = GerritLauncher.getDistributionArchive().toPath();
    } catch (FileNotFoundException e) {
        System.err.println("warn: Cannot find distribution archive (e.g. gerrit.war)");
        myWar = null;
    }
    String path = container.get("war");
    if (path != null) {
        path = container.string("Gerrit runtime", "war", myWar != null ? myWar.toAbsolutePath().toString() : null);
        if (path == null || path.isEmpty()) {
            throw die("container.war is required");
        }
    } else if (myWar != null) {
        final boolean copy;
        final Path siteWar = site.gerrit_war;
        if (Files.exists(siteWar)) {
            copy = ui.yesno(true, "Upgrade %s", siteWar);
        } else {
            copy = ui.yesno(true, "Copy %s to %s", myWar.getFileName(), siteWar);
            if (copy) {
                container.unset("war");
            } else {
                container.set("war", myWar.toAbsolutePath().toString());
            }
        }
        if (copy) {
            if (!ui.isBatch()) {
                System.err.format("Copying %s to %s", myWar.getFileName(), siteWar);
                System.err.println();
            }
            try (InputStream in = Files.newInputStream(myWar)) {
                Files.createDirectories(siteWar.getParent());
                LockFile lf = new LockFile(siteWar.toFile(), FS.DETECTED);
                if (!lf.lock()) {
                    throw new IOException("Cannot lock " + siteWar);
                }
                try {
                    try (OutputStream out = lf.getOutputStream()) {
                        ByteStreams.copy(in, out);
                    }
                    if (!lf.commit()) {
                        throw new IOException("Cannot commit " + siteWar);
                    }
                } finally {
                    lf.unlock();
                }
            }
        }
    }
}
#method_after
@Override
public void run() throws FileNotFoundException, IOException {
    ui.header("Container Process");
    container.string("Run as", "user", username());
    container.string("Java runtime", "javaHome", javaHome());
    Path myWar;
    try {
        myWar = GerritLauncher.getDistributionArchive().toPath();
    } catch (FileNotFoundException e) {
        System.err.println("warn: Cannot find distribution archive (e.g. gerrit.war)");
        myWar = null;
    }
    String path = container.get("war");
    if (path != null) {
        path = container.string("Gerrit runtime", "war", myWar != null ? myWar.toAbsolutePath().toString() : null);
        if (path == null || path.isEmpty()) {
            throw die("container.war is required");
        }
    } else if (myWar != null) {
        final boolean copy;
        final Path siteWar = site.gerrit_war;
        if (Files.exists(siteWar)) {
            copy = ui.yesno(true, "Upgrade %s", siteWar);
        } else {
            copy = ui.yesno(true, "Copy %s to %s", myWar.getFileName(), siteWar);
            if (copy) {
                container.unset("war");
            } else {
                container.set("war", myWar.toAbsolutePath().toString());
            }
        }
        if (copy) {
            if (!ui.isBatch()) {
                System.err.format("Copying %s to %s", myWar.getFileName(), siteWar);
                System.err.println();
            }
            try (InputStream in = Files.newInputStream(myWar)) {
                Files.createDirectories(siteWar.getParent());
                LockFile lf = new LockFile(siteWar.toFile());
                if (!lf.lock()) {
                    throw new IOException("Cannot lock " + siteWar);
                }
                try {
                    try (OutputStream out = lf.getOutputStream()) {
                        ByteStreams.copy(in, out);
                    }
                    if (!lf.commit()) {
                        throw new IOException("Cannot commit " + siteWar);
                    }
                } finally {
                    lf.unlock();
                }
            }
        }
    }
}
#end_block

#method_before
public static JiriProjects getProjects(GerritRemoteReader reader, String repoKey, String ref, String manifest) throws ConfigInvalidException, IOException {
    HashMap<String, Repository> repoMap = new HashMap<>();
    repoMap.put(repoKey, reader.openRepository(repoKey));
    Queue<Work> q = new LinkedList<>();
    q.add(new Work(repoKey, manifest, ref, "", false));
    HashMap<String, HashSet<String>> processedRepoFiles = new HashMap<>();
    HashMap<String, JiriProjects.Project> projectMap = new HashMap<>();
    while (q.size() != 0) {
        Work w = q.remove();
        Repository repo = repoMap.get(w.repoKey);
        if (repo == null) {
            repo = reader.openRepository(w.repoKey);
            repoMap.put(w.repoKey, repo);
        }
        HashSet<String> processedFiles = processedRepoFiles.get(w.repoKey);
        if (processedFiles == null) {
            processedFiles = new HashSet<String>();
            processedRepoFiles.put(w.repoKey, processedFiles);
        }
        if (processedFiles.contains(w.manifest)) {
            continue;
        }
        processedFiles.add(w.manifest);
        JiriManifest m;
        try {
            m = parseManifest(repo, w.ref, w.manifest);
        } catch (JAXBException | XMLStreamException e) {
            throw new ConfigInvalidException("XML parse error", e);
        }
        for (JiriProjects.Project project : m.projects.getProjects()) {
            project.fillDefault();
            if (w.revisionPinned && project.Key().equals(w.pKey)) {
                project.setRevision(w.ref);
            }
            if (projectMap.containsKey(project.Key())) {
                if (!projectMap.get(project.Key()).equals(project))
                    throw new ConfigInvalidException(String.format("Duplicate conflicting project %s in manifest %s\n%s\n%s", project.Key(), w.manifest, project.toString(), projectMap.get(project.Key()).toString()));
            } else {
                projectMap.put(project.Key(), project);
            }
        }
        URI parentURI;
        try {
            parentURI = new URI(w.manifest);
        } catch (URISyntaxException e) {
            throw new ConfigInvalidException("Invalid parent URI", e);
        }
        for (JiriManifest.LocalImport l : m.imports.getLocalImports()) {
            Work tw = new Work(w.repoKey, parentURI.resolve(l.getFile()).getPath(), w.ref, w.pKey, w.revisionPinned);
            q.add(tw);
        }
        for (JiriManifest.Import i : m.imports.getImports()) {
            i.fillDefault();
            URI uri;
            try {
                uri = new URI(i.getRemote());
            } catch (URISyntaxException e) {
                throw new ConfigInvalidException("Invalid URI", e);
            }
            String iRepoKey = new Project.NameKey(StringUtils.strip(uri.getPath(), "/")).toString();
            String iRef = i.getRevision();
            boolean revisionPinned = true;
            if (iRef.isEmpty()) {
                iRef = REFS_HEADS + i.getRemotebranch();
                revisionPinned = false;
            }
            Work tw = new Work(iRepoKey, i.getManifest(), iRef, i.Key(), revisionPinned);
            q.add(tw);
        }
    }
    return new JiriProjects(projectMap.values().toArray(new JiriProjects.Project[0]));
}
#method_after
public static JiriProjects getProjects(GerritRemoteReader reader, String repoKey, String ref, String manifest) throws ConfigInvalidException, IOException {
    try (RepoMap<String, Repository> repoMap = new RepoMap<>()) {
        repoMap.put(repoKey, reader.openRepository(repoKey));
        Queue<ManifestItem> q = new LinkedList<>();
        q.add(new ManifestItem(repoKey, manifest, ref, "", false));
        HashMap<String, HashSet<String>> processedRepoFiles = new HashMap<>();
        HashMap<String, JiriProjects.Project> projectMap = new HashMap<>();
        while (q.size() != 0) {
            ManifestItem mi = q.remove();
            Repository repo = repoMap.get(mi.repoKey);
            if (repo == null) {
                repo = reader.openRepository(mi.repoKey);
                repoMap.put(mi.repoKey, repo);
            }
            HashSet<String> processedFiles = processedRepoFiles.get(mi.repoKey);
            if (processedFiles == null) {
                processedFiles = new HashSet<String>();
                processedRepoFiles.put(mi.repoKey, processedFiles);
            }
            if (processedFiles.contains(mi.manifest)) {
                continue;
            }
            processedFiles.add(mi.manifest);
            JiriManifest m;
            try {
                m = parseManifest(repo, mi.ref, mi.manifest);
            } catch (JAXBException | XMLStreamException e) {
                throw new ConfigInvalidException("XML parse error", e);
            }
            for (JiriProjects.Project project : m.projects.getProjects()) {
                project.fillDefault();
                if (mi.revisionPinned && project.Key().equals(mi.projectKey)) {
                    project.setRevision(mi.ref);
                }
                if (projectMap.containsKey(project.Key())) {
                    if (!projectMap.get(project.Key()).equals(project))
                        throw new ConfigInvalidException(String.format("Duplicate conflicting project %s in manifest %s\n%s\n%s", project.Key(), mi.manifest, project.toString(), projectMap.get(project.Key()).toString()));
                } else {
                    projectMap.put(project.Key(), project);
                }
            }
            URI parentURI;
            try {
                parentURI = new URI(mi.manifest);
            } catch (URISyntaxException e) {
                throw new ConfigInvalidException("Invalid parent URI", e);
            }
            for (JiriManifest.LocalImport l : m.imports.getLocalImports()) {
                ManifestItem tw = new ManifestItem(mi.repoKey, parentURI.resolve(l.getFile()).getPath(), mi.ref, mi.projectKey, mi.revisionPinned);
                q.add(tw);
            }
            for (JiriManifest.Import i : m.imports.getImports()) {
                i.fillDefault();
                URI uri;
                try {
                    uri = new URI(i.getRemote());
                } catch (URISyntaxException e) {
                    throw new ConfigInvalidException("Invalid URI", e);
                }
                String iRepoKey = new Project.NameKey(StringUtils.strip(uri.getPath(), "/")).toString();
                String iRef = i.getRevision();
                boolean revisionPinned = true;
                if (iRef.isEmpty()) {
                    iRef = REFS_HEADS + i.getRemotebranch();
                    revisionPinned = false;
                }
                ManifestItem tmi = new ManifestItem(iRepoKey, i.getManifest(), iRef, i.Key(), revisionPinned);
                q.add(tmi);
            }
        }
        return new JiriProjects(projectMap.values().toArray(new JiriProjects.Project[0]));
    }
}
#end_block

#method_before
private void updateSubmodules(Repository repo, String targetRef, URI targetURI, JiriProjects projects, GerritRemoteReader reader) throws IOException, GitAPIException {
    DirCache index = DirCache.newInCore();
    DirCacheBuilder builder = index.builder();
    ObjectInserter inserter = repo.newObjectInserter();
    try (RevWalk rw = new RevWalk(repo)) {
        Config cfg = new Config();
        projects.sortByPath();
        String parent = null;
        for (JiriProjects.Project proj : projects.getProjects()) {
            String path = proj.getPath();
            String nameUri = proj.getRemote();
            if (parent != null) {
                String p1 = StringUtil.stripAndAddCharsAtEnd(path, "/");
                String p2 = StringUtil.stripAndAddCharsAtEnd(parent, "/");
                if (p1.startsWith(p2)) {
                    warn("Skipping project %s(%s) as git doesn't support nested submodules", proj.getName(), path);
                    continue;
                }
            }
            ObjectId objectId;
            String ref = proj.getRef();
            if (ObjectId.isId(ref)) {
                objectId = ObjectId.fromString(ref);
            } else {
                objectId = reader.sha1(nameUri, ref);
                if (objectId == null) {
                    warn("failed to get ref '%s' for '%s', skipping", ref, nameUri);
                    continue;
                }
            }
            // can be branch or tag
            cfg.setString("submodule", path, "branch", ref);
            if (proj.getHistorydepth() > 0) {
                cfg.setBoolean("submodule", path, "shallow", true);
                if (proj.getHistorydepth() != 1) {
                    warn("Project %s(%s) has historydepth other than 1. Submodule only support shallow of depth 1.", proj.getName(), proj.getPath());
                }
            }
            URI submodUrl = URI.create(nameUri);
            // check if repo exists locally then relativize its URL
            try {
                String repoName = submodUrl.getPath();
                while (repoName.startsWith("/")) {
                    repoName = repoName.substring(1);
                }
                reader.openRepository(repoName);
                submodUrl = relativize(targetURI, URI.create(repoName));
            } catch (RepositoryNotFoundException e) {
            }
            cfg.setString("submodule", path, "path", path);
            cfg.setString("submodule", path, "url", submodUrl.toString());
            // create gitlink
            DirCacheEntry dcEntry = new DirCacheEntry(path);
            dcEntry.setObjectId(objectId);
            dcEntry.setFileMode(FileMode.GITLINK);
            builder.add(dcEntry);
            parent = path;
        }
        String content = cfg.toText();
        // create a new DirCacheEntry for .gitmodules file.
        final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);
        ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));
        dcEntry.setObjectId(objectId);
        dcEntry.setFileMode(FileMode.REGULAR_FILE);
        builder.add(dcEntry);
        builder.finish();
        ObjectId treeId = index.writeTree(inserter);
        // Create a Commit object, populate it and write it
        ObjectId headId = repo.resolve(targetRef + "^{commit}");
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(treeId);
        if (headId != null)
            commit.setParentIds(headId);
        commit.setAuthor(serverIdent);
        commit.setCommitter(serverIdent);
        commit.setMessage(RepoText.get().repoCommitMessage);
        ObjectId commitId = inserter.insert(commit);
        inserter.flush();
        RefUpdate ru = repo.updateRef(targetRef);
        ru.setNewObjectId(commitId);
        ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());
        Result rc = ru.update(rw);
        switch(rc) {
            case NEW:
            case FORCED:
            case FAST_FORWARD:
                // Successful. Do nothing.
                break;
            case REJECTED:
            case LOCK_FAILURE:
                throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetRef), ru.getRef(), rc);
            default:
                throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetRef, commitId.name(), rc));
        }
    }
}
#method_after
private void updateSubmodules(Repository repo, String targetRef, URI targetURI, JiriProjects projects, GerritRemoteReader reader) throws IOException, GitAPIException {
    DirCache index = DirCache.newInCore();
    DirCacheBuilder builder = index.builder();
    ObjectInserter inserter = repo.newObjectInserter();
    try (RevWalk rw = new RevWalk(repo)) {
        Config cfg = new Config();
        projects.sortByPath();
        String parent = null;
        for (JiriProjects.Project proj : projects.getProjects()) {
            String path = proj.getPath();
            String nameUri = proj.getRemote();
            if (parent != null) {
                String p1 = StringUtil.stripAndAddCharsAtEnd(path, "/");
                String p2 = StringUtil.stripAndAddCharsAtEnd(parent, "/");
                if (p1.startsWith(p2)) {
                    warn("Skipping project %s(%s) as git doesn't support nested submodules", proj.getName(), path);
                    continue;
                }
            }
            ObjectId objectId;
            String ref = proj.getRef();
            if (ObjectId.isId(ref)) {
                objectId = ObjectId.fromString(ref);
            } else {
                objectId = reader.sha1(nameUri, ref);
                if (objectId == null) {
                    warn("failed to get ref '%s' for '%s', skipping", ref, nameUri);
                    continue;
                }
            }
            // can be branch or tag
            cfg.setString("submodule", path, "branch", ref);
            if (proj.getHistorydepth() > 0) {
                cfg.setBoolean("submodule", path, "shallow", true);
                if (proj.getHistorydepth() != 1) {
                    warn("Project %s(%s) has historydepth other than 1. Submodule only support shallow of depth 1.", proj.getName(), proj.getPath());
                }
            }
            URI submodUrl = URI.create(nameUri);
            // check if repo exists locally then relativize its URL
            try {
                String repoName = submodUrl.getPath();
                while (repoName.startsWith("/")) {
                    repoName = repoName.substring(1);
                }
                reader.openRepository(repoName);
                submodUrl = relativize(targetURI, URI.create(repoName));
            } catch (RepositoryNotFoundException e) {
            }
            cfg.setString("submodule", path, "path", path);
            cfg.setString("submodule", path, "url", submodUrl.toString());
            // create gitlink
            DirCacheEntry dcEntry = new DirCacheEntry(path);
            dcEntry.setObjectId(objectId);
            dcEntry.setFileMode(FileMode.GITLINK);
            builder.add(dcEntry);
            parent = path;
        }
        String content = cfg.toText();
        // create a new DirCacheEntry for .gitmodules file.
        final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);
        ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));
        dcEntry.setObjectId(objectId);
        dcEntry.setFileMode(FileMode.REGULAR_FILE);
        builder.add(dcEntry);
        builder.finish();
        ObjectId treeId = index.writeTree(inserter);
        // Create a Commit object, populate it and write it
        ObjectId headId = repo.resolve(targetRef + "^{commit}");
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(treeId);
        if (headId != null)
            commit.setParentIds(headId);
        PersonIdent author = new PersonIdent(serverIdent.getName(), serverIdent.getEmailAddress(), new Date(), serverIdent.getTimeZone());
        commit.setAuthor(author);
        commit.setCommitter(author);
        commit.setMessage(RepoText.get().repoCommitMessage);
        ObjectId commitId = inserter.insert(commit);
        inserter.flush();
        RefUpdate ru = repo.updateRef(targetRef);
        ru.setNewObjectId(commitId);
        ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());
        Result rc = ru.update(rw);
        switch(rc) {
            case NEW:
            case FORCED:
            case FAST_FORWARD:
                // Successful. Do nothing.
                break;
            case REJECTED:
            case LOCK_FAILURE:
                throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetRef), ru.getRef(), rc);
            default:
                throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetRef, commitId.name(), rc));
        }
    }
}
#end_block

#method_before
@Override
public void update(GerritRemoteReader reader, ConfigEntry c, String srcRef) throws IOException, GitAPIException, ConfigInvalidException {
    Repository destRepo = reader.openRepository(c.getDestRepoKey().toString());
    JiriProjects projects = JiriManifestParser.getProjects(reader, c.getSrcRepoKey().toString(), srcRef, c.getXmlPath());
    String targetRef = c.getDestBranch().equals("*") ? srcRef : REFS_HEADS + c.getDestBranch();
    updateSubmodules(destRepo, targetRef, URI.create(c.getDestRepoKey().toString() + "/"), projects, reader);
}
#method_after
@Override
public void update(GerritRemoteReader reader, ConfigEntry c, String srcRef) throws IOException, GitAPIException, ConfigInvalidException {
    try (Repository destRepo = reader.openRepository(c.getDestRepoKey().toString())) {
        JiriProjects projects = JiriManifestParser.getProjects(reader, c.getSrcRepoKey().toString(), srcRef, c.getXmlPath());
        String targetRef = c.getDestBranch().equals("*") ? srcRef : REFS_HEADS + c.getDestBranch();
        updateSubmodules(destRepo, targetRef, URI.create(c.getDestRepoKey().toString() + "/"), projects, reader);
    }
}
#end_block

#method_before
private void outer() {
    inner();
}
#method_after
private void outer() throws Exception {
    inner();
}
#end_block

#method_before
private void innerTest() {
    try {
        outer();
        fail("should throw");
    } catch (IllegalStateException e) {
        StackTraceElement[] trimmed = SuperManifestRefUpdatedListener.trimStack(e.getStackTrace(), Thread.currentThread().getStackTrace()[1]);
        String str = Arrays.toString(trimmed);
        assertThat(str).doesNotContain("trimStackTrace");
        assertThat(str).contains("innerTest");
    }
}
#method_after
private void innerTest() throws Exception {
    try {
        outer();
        fail("should throw");
    } catch (IllegalStateException e) {
        StackTraceElement[] trimmed = SuperManifestRefUpdatedListener.trimStack(e.getStackTrace(), Thread.currentThread().getStackTrace()[1]);
        String str = Arrays.toString(trimmed);
        assertThat(str).doesNotContain("trimStackTrace");
        assertThat(str).contains("innerTest");
    }
}
#end_block

#method_before
void testRelative(String a, String b, String want) {
    String got = JiriUpdater.relativize(URI.create(a), URI.create(b)).toString();
    if (!got.equals(want)) {
        fail(String.format("relative('%s', '%s') = '%s', want '%s'", a, b, got, want));
    }
}
#method_after
void testRelative(String a, String b, String want) throws Exception {
    String got = JiriUpdater.relativize(URI.create(a), URI.create(b)).toString();
    if (!got.equals(want)) {
        fail(String.format("relative('%s', '%s') = '%s', want '%s'", a, b, got, want));
    }
}
#end_block

#method_before
@Test
public void relative() {
    testRelative("a/b/", "a/", "../");
    // Normalization:
    testRelative("a/p/..//b/", "a/", "../");
    testRelative("a/b", "a/", "");
    testRelative("a/", "a/b/", "b/");
    testRelative("a/", "a/b", "b");
    testRelative("/a/b/c", "/b/c", "../../b/c");
    testRelative("/abc", "bcd", "bcd");
    testRelative("abc", "def", "def");
    testRelative("abc", "/bcd", "/bcd");
    testRelative("http://a", "a/b", "a/b");
    testRelative("http://base.com/a/", "http://child.com/a/b", "http://child.com/a/b");
}
#method_after
@Test
public void relative() throws Exception {
    testRelative("a/b/", "a/", "../");
    // Normalization:
    testRelative("a/p/..//b/", "a/", "../");
    testRelative("a/b", "a/", "");
    testRelative("a/", "a/b/", "b/");
    testRelative("a/", "a/b", "b");
    testRelative("/a/b/c", "/b/c", "../../b/c");
    testRelative("/abc", "bcd", "bcd");
    testRelative("abc", "def", "def");
    testRelative("abc", "/bcd", "/bcd");
    testRelative("http://a", "a/b", "a/b");
    testRelative("http://base.com/a/", "http://child.com/a/b", "http://child.com/a/b");
}
#end_block

#method_before
public void create(ReviewDb db) throws OrmException, IOException, ConfigInvalidException {
    final JdbcSchema jdbc = (JdbcSchema) db;
    try (JdbcExecutor e = new JdbcExecutor(jdbc)) {
        jdbc.updateSchema(e);
    }
    final CurrentSchemaVersion sVer = CurrentSchemaVersion.create();
    sVer.versionNbr = SchemaVersion.getBinaryVersion();
    db.schemaVersion().insert(Collections.singleton(sVer));
    GroupReference admins = createGroupReference("Administrators");
    GroupReference batchUsers = createGroupReference("Non-Interactive Users");
    initSystemConfig(db);
    allProjectsCreator.setAdministrators(admins).setBatchUsers(batchUsers).create();
    // We have to create the All-Users repository before we can use it to store the groups in it.
    allUsersCreator.setAdministrators(admins).create();
    GroupSequence seq = new GroupSequence(db, readGroupIdsFromNoteDb, allUsersName, repoManager, GitReferenceUpdated.DISABLED);
    try (Repository repository = repoManager.openRepository(allUsersName)) {
        createAdminsGroup(db, seq, repository, admins);
        createBatchUsersGroup(db, seq, repository, batchUsers, admins.getUUID());
    }
    dataSourceType.getIndexScript().run(db);
}
#method_after
public void create(ReviewDb db) throws OrmException, IOException, ConfigInvalidException {
    final JdbcSchema jdbc = (JdbcSchema) db;
    try (JdbcExecutor e = new JdbcExecutor(jdbc)) {
        jdbc.updateSchema(e);
    }
    final CurrentSchemaVersion sVer = CurrentSchemaVersion.create();
    sVer.versionNbr = SchemaVersion.getBinaryVersion();
    db.schemaVersion().insert(Collections.singleton(sVer));
    GroupReference admins = createGroupReference("Administrators");
    GroupReference batchUsers = createGroupReference("Non-Interactive Users");
    initSystemConfig(db);
    allProjectsCreator.setAdministrators(admins).setBatchUsers(batchUsers).create();
    // We have to create the All-Users repository before we can use it to store the groups in it.
    allUsersCreator.setAdministrators(admins).create();
    // Don't rely on injection to construct Sequences, as it requires ReviewDb.
    Sequences seqs = new Sequences(config, () -> db, migration, repoManager, GitReferenceUpdated.DISABLED, allProjectsName, allUsersName, metricMaker);
    try (Repository repository = repoManager.openRepository(allUsersName)) {
        createAdminsGroup(db, seqs, repository, admins);
        createBatchUsersGroup(db, seqs, repository, batchUsers, admins);
    }
    dataSourceType.getIndexScript().run(db);
}
#end_block

#method_before
private void createAdminsGroup(ReviewDb db, GroupSequence seq, Repository repository, GroupReference groupReference) throws OrmException, IOException, ConfigInvalidException {
    InternalGroupCreation groupCreation = getGroupCreation(seq, groupReference);
    InternalGroupUpdate groupUpdate = InternalGroupUpdate.builder().setDescription("Gerrit Site Administrators").build();
    createGroup(db, repository, groupCreation, groupUpdate);
}
#method_after
private void createAdminsGroup(ReviewDb db, Sequences seqs, Repository repository, GroupReference groupReference) throws OrmException, IOException, ConfigInvalidException {
    InternalGroupCreation groupCreation = getGroupCreation(seqs, groupReference);
    InternalGroupUpdate groupUpdate = InternalGroupUpdate.builder().setDescription("Gerrit Site Administrators").build();
    createGroup(db, repository, groupCreation, groupUpdate);
}
#end_block

#method_before
private void createBatchUsersGroup(ReviewDb db, GroupSequence seq, Repository repository, GroupReference groupReference, AccountGroup.UUID adminsGroupUuid) throws OrmException, IOException, ConfigInvalidException {
    InternalGroupCreation groupCreation = getGroupCreation(seq, groupReference);
    InternalGroupUpdate groupUpdate = InternalGroupUpdate.builder().setDescription("Users who perform batch actions on Gerrit").setOwnerGroupUUID(adminsGroupUuid).build();
    createGroup(db, repository, groupCreation, groupUpdate);
}
#method_after
private void createBatchUsersGroup(ReviewDb db, Sequences seqs, Repository repository, GroupReference groupReference, GroupReference admins) throws OrmException, IOException, ConfigInvalidException {
    InternalGroupCreation groupCreation = getGroupCreation(seqs, groupReference);
    InternalGroupUpdate groupUpdate = InternalGroupUpdate.builder().setDescription("Users who perform batch actions on Gerrit").setOwnerGroupReference(admins).build();
    createGroup(db, repository, groupCreation, groupUpdate);
}
#end_block

#method_before
private InternalGroup createGroupInNoteDb(Repository repository, InternalGroupCreation groupCreation, InternalGroupUpdate groupUpdate) throws ConfigInvalidException, IOException, OrmDuplicateKeyException {
    GroupConfig groupConfig = GroupConfig.createForNewGroup(repository, groupCreation);
    // We don't add any initial members or subgroups and hence the provided functions should never
    // be called. To be on the safe side, we specify some valid functions.
    groupConfig.setGroupUpdate(groupUpdate, Account.Id::toString, AccountGroup.UUID::get);
    try (MetaDataUpdate metaDataUpdate = createMetaDataUpdate(repository)) {
        groupConfig.commit(metaDataUpdate);
    }
    return groupConfig.getLoadedGroup().orElseThrow(() -> new IllegalStateException("Created group wasn't automatically loaded"));
}
#method_after
private InternalGroup createGroupInNoteDb(Repository repository, InternalGroupCreation groupCreation, InternalGroupUpdate groupUpdate) throws ConfigInvalidException, IOException, OrmDuplicateKeyException {
    GroupConfig groupConfig = GroupConfig.createForNewGroup(allUsersName, repository, groupCreation, p -> createMetaDataUpdate(p));
    // We don't add any initial members or subgroups and hence the provided functions should never
    // be called. To be on the safe side, we specify some valid functions.
    groupConfig.setGroupUpdate(groupUpdate, Account.Id::toString, AccountGroup.UUID::get);
    try (MetaDataUpdate metaDataUpdate = createMetaDataUpdate(repository)) {
        groupConfig.commit(metaDataUpdate);
    }
    return groupConfig.getLoadedGroup().orElseThrow(() -> new IllegalStateException("Created group wasn't automatically loaded"));
}
#end_block

#method_before
private MetaDataUpdate createMetaDataUpdate(Repository repository) {
    MetaDataUpdate metaDataUpdate = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allUsersName, repository);
    metaDataUpdate.getCommitBuilder().setAuthor(serverUser);
    metaDataUpdate.getCommitBuilder().setCommitter(serverUser);
    return metaDataUpdate;
}
#method_after
private MetaDataUpdate createMetaDataUpdate(Project.NameKey project) throws IOException {
    try (Repository repository = repoManager.openRepository(project)) {
        return createMetaDataUpdate(repository);
    }
}
#end_block

#method_before
private InternalGroupCreation getGroupCreation(GroupSequence seq, GroupReference groupReference) throws OrmException {
    int next = seq.nextGroupId();
    return InternalGroupCreation.builder().setNameKey(new AccountGroup.NameKey(groupReference.getName())).setId(new AccountGroup.Id(next)).setGroupUUID(groupReference.getUUID()).setCreatedOn(TimeUtil.nowTs()).build();
}
#method_after
private InternalGroupCreation getGroupCreation(Sequences seqs, GroupReference groupReference) throws OrmException {
    int next = seqs.nextGroupId();
    return InternalGroupCreation.builder().setNameKey(new AccountGroup.NameKey(groupReference.getName())).setId(new AccountGroup.Id(next)).setGroupUUID(groupReference.getUUID()).setCreatedOn(TimeUtil.nowTs()).build();
}
#end_block

#method_before
private InternalGroup createGroup(CreateGroupArgs createGroupArgs) throws OrmException, ResourceConflictException, IOException, ConfigInvalidException {
    String nameLower = createGroupArgs.getGroupName().toLowerCase(Locale.US);
    for (String name : systemGroupBackend.getNames()) {
        if (name.toLowerCase(Locale.US).equals(nameLower)) {
            throw new ResourceConflictException("group '" + name + "' already exists");
        }
    }
    for (String name : systemGroupBackend.getReservedNames()) {
        if (name.toLowerCase(Locale.US).equals(nameLower)) {
            throw new ResourceConflictException("group name '" + name + "' is reserved");
        }
    }
    AccountGroup.Id groupId = new AccountGroup.Id(groupSeq.nextGroupId());
    AccountGroup.UUID uuid = GroupUUID.make(createGroupArgs.getGroupName(), self.get().newCommitterIdent(serverIdent.getWhen(), serverIdent.getTimeZone()));
    InternalGroupCreation groupCreation = InternalGroupCreation.builder().setGroupUUID(uuid).setNameKey(createGroupArgs.getGroup()).setId(groupId).setCreatedOn(TimeUtil.nowTs()).build();
    InternalGroupUpdate.Builder groupUpdateBuilder = InternalGroupUpdate.builder().setVisibleToAll(createGroupArgs.visibleToAll);
    if (createGroupArgs.ownerGroupId != null) {
        Optional<InternalGroup> ownerGroup = groupCache.get(createGroupArgs.ownerGroupId);
        ownerGroup.map(InternalGroup::getGroupUUID).ifPresent(groupUpdateBuilder::setOwnerGroupUUID);
    }
    if (createGroupArgs.groupDescription != null) {
        groupUpdateBuilder.setDescription(createGroupArgs.groupDescription);
    }
    groupUpdateBuilder.setMemberModification(members -> ImmutableSet.copyOf(createGroupArgs.initialMembers));
    try {
        return groupsUpdateProvider.get().createGroup(db, groupCreation, groupUpdateBuilder.build());
    } catch (OrmDuplicateKeyException e) {
        throw new ResourceConflictException("group '" + createGroupArgs.getGroupName() + "' already exists");
    }
}
#method_after
private InternalGroup createGroup(CreateGroupArgs createGroupArgs) throws OrmException, ResourceConflictException, IOException, ConfigInvalidException {
    String nameLower = createGroupArgs.getGroupName().toLowerCase(Locale.US);
    for (String name : systemGroupBackend.getNames()) {
        if (name.toLowerCase(Locale.US).equals(nameLower)) {
            throw new ResourceConflictException("group '" + name + "' already exists");
        }
    }
    for (String name : systemGroupBackend.getReservedNames()) {
        if (name.toLowerCase(Locale.US).equals(nameLower)) {
            throw new ResourceConflictException("group name '" + name + "' is reserved");
        }
    }
    AccountGroup.Id groupId = new AccountGroup.Id(sequences.nextGroupId());
    AccountGroup.UUID uuid = GroupUUID.make(createGroupArgs.getGroupName(), self.get().newCommitterIdent(serverIdent.getWhen(), serverIdent.getTimeZone()));
    InternalGroupCreation groupCreation = InternalGroupCreation.builder().setGroupUUID(uuid).setNameKey(createGroupArgs.getGroup()).setId(groupId).setCreatedOn(TimeUtil.nowTs()).build();
    InternalGroupUpdate.Builder groupUpdateBuilder = InternalGroupUpdate.builder().setVisibleToAll(createGroupArgs.visibleToAll);
    if (createGroupArgs.ownerGroupId != null) {
        Optional<InternalGroup> ownerGroup = groupCache.get(createGroupArgs.ownerGroupId);
        ownerGroup.ifPresent(g -> groupUpdateBuilder.setOwnerGroupReference(new GroupReference(g.getGroupUUID(), g.getName())));
    }
    if (createGroupArgs.groupDescription != null) {
        groupUpdateBuilder.setDescription(createGroupArgs.groupDescription);
    }
    groupUpdateBuilder.setMemberModification(members -> ImmutableSet.copyOf(createGroupArgs.initialMembers));
    try {
        return groupsUpdateProvider.get().createGroup(db, groupCreation, groupUpdateBuilder.build());
    } catch (OrmDuplicateKeyException e) {
        throw new ResourceConflictException("group '" + createGroupArgs.getGroupName() + "' already exists");
    }
}
#end_block

#method_before
@Override
public final T call() throws NoSuchProjectException, IOException, ConfigInvalidException, InvalidNameException, NoSuchGroupException, OrmException, UpdateParentFailedException, PermissionDeniedException, PermissionBackendException {
    try {
        contributorAgreements.check(projectName, user);
    } catch (AuthException e) {
        throw new PermissionDeniedException(e.getMessage());
    }
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        ProjectConfig config = ProjectConfig.read(md, base);
        Set<String> toDelete = scanSectionNames(config);
        PermissionBackend.ForProject forProject = permissionBackend.user(user).project(projectName);
        for (AccessSection section : mergeSections(sectionList)) {
            String name = section.getName();
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (checkIfOwner && !canWriteConfig()) {
                    continue;
                }
                replace(config, toDelete, section);
            } else if (AccessSection.isValid(name)) {
                if (checkIfOwner && !forProject.ref(name).test(RefPermission.WRITE_CONFIG)) {
                    continue;
                }
                RefPattern.validate(name);
                boolean differs = replace(config, toDelete, section);
                if (differs && groupMutationsDisallowed(projectName) && isGroupMutation(section.getName())) {
                    throw new ConfigInvalidException(String.format("Permissions on %s is managed by Gerrit and cannot be modified", RefNames.REFS_GROUPS));
                }
            }
        }
        for (String name : toDelete) {
            if (groupMutationsDisallowed(projectName) && isGroupMutation(name)) {
                throw new ConfigInvalidException(String.format("Permissions on %s is managed by Gerrit and cannot be modified", RefNames.REFS_GROUPS));
            }
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (!checkIfOwner || canWriteConfig()) {
                    config.remove(config.getAccessSection(name));
                }
            } else if (!checkIfOwner || forProject.ref(name).test(RefPermission.WRITE_CONFIG)) {
                config.remove(config.getAccessSection(name));
            }
        }
        boolean parentProjectUpdate = false;
        if (!config.getProject().getNameKey().equals(allProjects) && !config.getProject().getParent(allProjects).equals(parentProjectName)) {
            parentProjectUpdate = true;
            if (projectName.equals(allUsers) && !allProjects.equals(MoreObjects.firstNonNull(parentProjectName, allProjects))) {
                throw new ConfigInvalidException(String.format("%s must inherit from %s", allUsers.get(), allProjects.get()));
            }
            try {
                setParent.get().validateParentUpdate(projectName, user.asIdentifiedUser(), MoreObjects.firstNonNull(parentProjectName, allProjects).get(), checkIfOwner);
            } catch (AuthException e) {
                throw new UpdateParentFailedException("You are not allowed to change the parent project since you are " + "not an administrator. You may save the modifications for review " + "so that an administrator can approve them.", e);
            } catch (ResourceConflictException | UnprocessableEntityException e) {
                throw new UpdateParentFailedException(e.getMessage(), e);
            }
            config.getProject().setParentName(parentProjectName);
        }
        if (message != null && !message.isEmpty()) {
            if (!message.endsWith("\n")) {
                message += "\n";
            }
            md.setMessage(message);
        } else {
            md.setMessage("Modify access rules\n");
        }
        return updateProjectConfig(config, md, parentProjectUpdate);
    } catch (RepositoryNotFoundException notFound) {
        throw new NoSuchProjectException(projectName);
    }
}
#method_after
@Override
public final T call() throws NoSuchProjectException, IOException, ConfigInvalidException, InvalidNameException, NoSuchGroupException, OrmException, UpdateParentFailedException, PermissionDeniedException, PermissionBackendException {
    try {
        contributorAgreements.check(projectName, user);
    } catch (AuthException e) {
        throw new PermissionDeniedException(e.getMessage());
    }
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        ProjectConfig config = ProjectConfig.read(md, base);
        Set<String> toDelete = scanSectionNames(config);
        PermissionBackend.ForProject forProject = permissionBackend.user(user).project(projectName);
        for (AccessSection section : mergeSections(sectionList)) {
            String name = section.getName();
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (checkIfOwner && !canWriteConfig()) {
                    continue;
                }
                replace(config, toDelete, section);
            } else if (AccessSection.isValid(name)) {
                if (checkIfOwner && !forProject.ref(name).test(RefPermission.WRITE_CONFIG)) {
                    continue;
                }
                RefPattern.validate(name);
                boolean differs = replace(config, toDelete, section);
                if (differs && groupMutationsDisallowed(projectName) && isGroupMutation(section.getName())) {
                    throw new ConfigInvalidException(String.format("permissions on %s are managed by gerrit and cannot be modified", RefNames.REFS_GROUPS));
                }
            }
        }
        for (String name : toDelete) {
            if (groupMutationsDisallowed(projectName) && isGroupMutation(name)) {
                throw new ConfigInvalidException(String.format("permissions on %s are managed by gerrit and cannot be modified", RefNames.REFS_GROUPS));
            }
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (!checkIfOwner || canWriteConfig()) {
                    config.remove(config.getAccessSection(name));
                }
            } else if (!checkIfOwner || forProject.ref(name).test(RefPermission.WRITE_CONFIG)) {
                config.remove(config.getAccessSection(name));
            }
        }
        boolean parentProjectUpdate = false;
        if (!config.getProject().getNameKey().equals(allProjects) && !config.getProject().getParent(allProjects).equals(parentProjectName)) {
            parentProjectUpdate = true;
            try {
                setParent.get().validateParentUpdate(projectName, user.asIdentifiedUser(), MoreObjects.firstNonNull(parentProjectName, allProjects).get(), checkIfOwner);
            } catch (AuthException e) {
                throw new UpdateParentFailedException("You are not allowed to change the parent project since you are " + "not an administrator. You may save the modifications for review " + "so that an administrator can approve them.", e);
            } catch (ResourceConflictException | UnprocessableEntityException | BadRequestException e) {
                throw new UpdateParentFailedException(e.getMessage(), e);
            }
            config.getProject().setParentName(parentProjectName);
        }
        if (message != null && !message.isEmpty()) {
            if (!message.endsWith("\n")) {
                message += "\n";
            }
            md.setMessage(message);
        } else {
            md.setMessage("Modify access rules\n");
        }
        return updateProjectConfig(config, md, parentProjectUpdate);
    } catch (RepositoryNotFoundException notFound) {
        throw new NoSuchProjectException(projectName);
    }
}
#end_block

#method_before
@Test
public void pushGroupsAccessSectionChangeToAllUsersFails() throws Exception {
    TestRepository<InMemoryRepository> repo = cloneProject(allUsers, RefNames.REFS_CONFIG);
    String config = gApi.projects().name(allUsers.get()).branch(RefNames.REFS_CONFIG).file("project.config").asString();
    Config cfg = new Config();
    cfg.fromText(config);
    cfg.setString("access", RefNames.REFS_GROUPS + "foo", "push", "group Registered Users");
    config = cfg.toText();
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo, "Subject", "project.config", config).to(RefNames.REFS_CONFIG);
    r.assertErrorStatus("invalid project configuration");
    r.assertMessage("permissions on refs/groups/ is managed by gerrit and cannot be modified");
}
#method_after
@Test
public void pushGroupsAccessSectionChangeToAllUsersFails() throws Exception {
    TestRepository<InMemoryRepository> repo = cloneProject(allUsers, RefNames.REFS_CONFIG);
    String config = gApi.projects().name(allUsers.get()).branch(RefNames.REFS_CONFIG).file(ProjectConfig.PROJECT_CONFIG).asString();
    Config cfg = new Config();
    cfg.fromText(config);
    cfg.setString("access", RefNames.REFS_GROUPS + "foo", "push", "group Registered Users");
    config = cfg.toText();
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo, "Subject", ProjectConfig.PROJECT_CONFIG, config).to(RefNames.REFS_CONFIG);
    r.assertErrorStatus("invalid project configuration");
    r.assertMessage("permissions on refs/groups/ are managed by gerrit and cannot be modified");
}
#end_block

#method_before
@Test
public void pushNonGroupsAccessSectionChangeToAllUsersSucceeds() throws Exception {
    // Add an access section for refs/groups manually to see that mutation other data does not
    // trigger a validation error.
    ProjectConfig projectConfig = projectCache.checkedGet(allUsers).getConfig();
    AccessSection as = new AccessSection(RefNames.REFS_GROUPS + "foo");
    Permission perm = new Permission("push");
    perm.add(new PermissionRule(systemGroupBackend.getGroup(ANONYMOUS_USERS)));
    as.addPermission(perm);
    projectConfig.replace(as);
    saveProjectConfig(allUsers, projectConfig);
    TestRepository<InMemoryRepository> repo = cloneProject(allUsers, RefNames.REFS_CONFIG);
    String config = gApi.projects().name(allUsers.get()).branch(RefNames.REFS_CONFIG).file("project.config").asString();
    assertThat(config).contains("[access \"refs/groups/foo\"]");
    Config cfg = new Config();
    cfg.fromText(config);
    cfg.setString("access", RefNames.REFS_CHANGES + "foo", "push", "group Registered Users");
    config = cfg.toText();
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo, "Subject", "project.config", config).to(RefNames.REFS_CONFIG);
    r.assertOkStatus();
}
#method_after
@Test
public void pushNonGroupsAccessSectionChangeToAllUsersSucceeds() throws Exception {
    // Add an access section for refs/groups manually to see that mutation other data does not
    // trigger a validation error.
    ProjectConfig projectConfig = projectCache.checkedGet(allUsers).getConfig();
    AccessSection as = new AccessSection(RefNames.REFS_GROUPS + "foo");
    Permission perm = new Permission("push");
    perm.add(new PermissionRule(systemGroupBackend.getGroup(ANONYMOUS_USERS)));
    as.addPermission(perm);
    projectConfig.replace(as);
    saveProjectConfig(allUsers, projectConfig);
    TestRepository<InMemoryRepository> repo = cloneProject(allUsers, RefNames.REFS_CONFIG);
    String config = gApi.projects().name(allUsers.get()).branch(RefNames.REFS_CONFIG).file(ProjectConfig.PROJECT_CONFIG).asString();
    assertThat(config).contains("[access \"refs/groups/foo\"]");
    Config cfg = new Config();
    cfg.fromText(config);
    cfg.setString("access", RefNames.REFS_CHANGES + "foo", "push", "group Registered Users");
    config = cfg.toText();
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo, "Subject", ProjectConfig.PROJECT_CONFIG, config).to(RefNames.REFS_CONFIG);
    r.assertOkStatus();
}
#end_block

#method_before
@Test
public void pushGroupsAccessSectionChangeToCustomProjectSucceeds() throws Exception {
    TestRepository<InMemoryRepository> repo = cloneProject(project, RefNames.REFS_CONFIG);
    String config = gApi.projects().name(project.get()).branch(RefNames.REFS_CONFIG).file("project.config").asString();
    Config cfg = new Config();
    cfg.fromText(config);
    cfg.setString("access", RefNames.REFS_GROUPS + "foo", "push", "group Registered Users");
    config = cfg.toText();
    PushOneCommit.Result r1 = pushFactory.create(db, admin.getIdent(), repo, "Subject", "groups", "global:Registered-Users\tRegistered Users").to(RefNames.REFS_CONFIG);
    r1.assertOkStatus();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), repo, "Subject", "project.config", config).to(RefNames.REFS_CONFIG);
    r2.assertOkStatus();
}
#method_after
@Test
public void pushGroupsAccessSectionChangeToCustomProjectSucceeds() throws Exception {
    TestRepository<InMemoryRepository> repo = cloneProject(project, RefNames.REFS_CONFIG);
    String config = gApi.projects().name(project.get()).branch(RefNames.REFS_CONFIG).file(ProjectConfig.PROJECT_CONFIG).asString();
    Config cfg = new Config();
    cfg.fromText(config);
    cfg.setString("access", RefNames.REFS_GROUPS + "foo", "push", "group Registered Users");
    config = cfg.toText();
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo, "Subject", ImmutableMap.of("groups", "global:Registered-Users\tRegistered Users", ProjectConfig.PROJECT_CONFIG, config)).to(RefNames.REFS_CONFIG);
    r.assertOkStatus();
}
#end_block

#method_before
@Test
public void unknownPermissionRemainsUnchanged() throws Exception {
    String access = "access";
    String unknownPermission = "unknownPermission";
    String registeredUsers = "group Registered Users";
    String refsFor = "refs/for/*";
    // Clone repository to forcefully add permission
    TestRepository<InMemoryRepository> allProjectsRepo = cloneProject(allProjects, admin);
    // Fetch permission ref
    GitUtil.fetch(allProjectsRepo, "refs/meta/config:cfg");
    allProjectsRepo.reset("cfg");
    // Load current permissions
    String config = gApi.projects().name(allProjects.get()).branch(RefNames.REFS_CONFIG).file("project.config").asString();
    // Append and push unknown permission
    Config cfg = new Config();
    cfg.fromText(config);
    cfg.setString(access, refsFor, unknownPermission, registeredUsers);
    config = cfg.toText();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), allProjectsRepo, "Subject", "project.config", config);
    push.to(RefNames.REFS_CONFIG).assertOkStatus();
    // Verify that unknownPermission is present
    config = gApi.projects().name(allProjects.get()).branch(RefNames.REFS_CONFIG).file("project.config").asString();
    cfg.fromText(config);
    assertThat(cfg.getString(access, refsFor, unknownPermission)).isEqualTo(registeredUsers);
    // Make permission change through API
    ProjectAccessInput accessInput = newProjectAccessInput();
    AccessSectionInfo accessSectionInfo = createDefaultAccessSectionInfo();
    accessInput.add.put(refsFor, accessSectionInfo);
    gApi.projects().name(allProjects.get()).access(accessInput);
    accessInput.add.clear();
    accessInput.remove.put(refsFor, accessSectionInfo);
    gApi.projects().name(allProjects.get()).access(accessInput);
    // Verify that unknownPermission is still present
    config = gApi.projects().name(allProjects.get()).branch(RefNames.REFS_CONFIG).file("project.config").asString();
    cfg.fromText(config);
    assertThat(cfg.getString(access, refsFor, unknownPermission)).isEqualTo(registeredUsers);
}
#method_after
@Test
public void unknownPermissionRemainsUnchanged() throws Exception {
    String access = "access";
    String unknownPermission = "unknownPermission";
    String registeredUsers = "group Registered Users";
    String refsFor = "refs/for/*";
    // Clone repository to forcefully add permission
    TestRepository<InMemoryRepository> allProjectsRepo = cloneProject(allProjects, admin);
    // Fetch permission ref
    GitUtil.fetch(allProjectsRepo, "refs/meta/config:cfg");
    allProjectsRepo.reset("cfg");
    // Load current permissions
    String config = gApi.projects().name(allProjects.get()).branch(RefNames.REFS_CONFIG).file(ProjectConfig.PROJECT_CONFIG).asString();
    // Append and push unknown permission
    Config cfg = new Config();
    cfg.fromText(config);
    cfg.setString(access, refsFor, unknownPermission, registeredUsers);
    config = cfg.toText();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), allProjectsRepo, "Subject", ProjectConfig.PROJECT_CONFIG, config);
    push.to(RefNames.REFS_CONFIG).assertOkStatus();
    // Verify that unknownPermission is present
    config = gApi.projects().name(allProjects.get()).branch(RefNames.REFS_CONFIG).file(ProjectConfig.PROJECT_CONFIG).asString();
    cfg.fromText(config);
    assertThat(cfg.getString(access, refsFor, unknownPermission)).isEqualTo(registeredUsers);
    // Make permission change through API
    ProjectAccessInput accessInput = newProjectAccessInput();
    AccessSectionInfo accessSectionInfo = createDefaultAccessSectionInfo();
    accessInput.add.put(refsFor, accessSectionInfo);
    gApi.projects().name(allProjects.get()).access(accessInput);
    accessInput.add.clear();
    accessInput.remove.put(refsFor, accessSectionInfo);
    gApi.projects().name(allProjects.get()).access(accessInput);
    // Verify that unknownPermission is still present
    config = gApi.projects().name(allProjects.get()).branch(RefNames.REFS_CONFIG).file(ProjectConfig.PROJECT_CONFIG).asString();
    cfg.fromText(config);
    assertThat(cfg.getString(access, refsFor, unknownPermission)).isEqualTo(registeredUsers);
}
#end_block

#method_before
@Test
public void updateGroupRefPermissions() throws Exception {
    ProjectAccessInput accessInput = newProjectAccessInput();
    accessInput.add.put(RefNames.REFS_GROUPS + "*", createDefaultAccessSectionInfo());
    exception.expect(BadRequestException.class);
    exception.expectMessage("Permissions on refs/groups/ is managed by Gerrit and cannot be modified");
    gApi.projects().name(allProjects.get()).access(accessInput);
}
#method_after
@Test
public void updateGroupRefPermissions() throws Exception {
    ProjectAccessInput accessInput = newProjectAccessInput();
    accessInput.add.put(RefNames.REFS_GROUPS + "*", createDefaultAccessSectionInfo());
    exception.expect(BadRequestException.class);
    exception.expectMessage("permissions on refs/groups/ are managed by gerrit and cannot be modified");
    gApi.projects().name(allProjects.get()).access(accessInput);
}
#end_block

#method_before
@Test
public void allUsersCanOnlyInheritFromAllProjects() throws Exception {
    ProjectAccessInput accessInput = newProjectAccessInput();
    accessInput.parent = project.get();
    exception.expect(BadRequestException.class);
    exception.expectMessage("All-Users must inherit from All-Projects");
    gApi.projects().name("All-Users").access(accessInput);
}
#method_after
@Test
public void allUsersCanOnlyInheritFromAllProjects() throws Exception {
    ProjectAccessInput accessInput = newProjectAccessInput();
    accessInput.parent = project.get();
    exception.expect(BadRequestException.class);
    exception.expectMessage(allUsers.get() + " must inherit from " + allProjects.get());
    gApi.projects().name(allUsers.get()).access(accessInput);
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    if (REFS_CONFIG.equals(branch.get())) {
        List<CommitValidationMessage> messages = new ArrayList<>();
        try {
            ProjectConfig cfg = new ProjectConfig(receiveEvent.project.getNameKey());
            cfg.load(rw, receiveEvent.command.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:", messages);
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage(), messages);
                }
                throw new ConfigInvalidException("invalid project configuration");
            }
            if (allUsers.equals(receiveEvent.project.getNameKey()) || allProjects.equals(receiveEvent.project.getNameKey())) {
                // Check if the new config modifies any access sections for refs/groups/. These are
                // managed by Gerrit and modifications are not allowed.
                Set<AccessSection> diff = Sets.symmetricDifference(new HashSet<>(projectState.getConfig().getAccessSections()), new HashSet<>(cfg.getAccessSections()));
                boolean modifiesGroupsAccessSection = diff.stream().filter(as -> as.getName().startsWith(RefNames.REFS_GROUPS)).findAny().isPresent();
                if (modifiesGroupsAccessSection) {
                    addError("Invalid project configuration:", messages);
                    addError(String.format("  Permissions on %s is managed by Gerrit and cannot be modified", RefNames.REFS_GROUPS), messages);
                    throw new ConfigInvalidException("invalid project configuration");
                }
            }
            if (allUsers.equals(receiveEvent.project.getNameKey()) && !allProjects.equals(cfg.getProject().getParent(allProjects))) {
                addError("Invalid project configuration:", messages);
                addError(String.format("  %s must inherit from %s", allUsers.get(), allProjects.get()), messages);
                throw new ConfigInvalidException("invalid project configuration");
            }
        } catch (ConfigInvalidException | IOException e) {
            log.error("User " + user.getUserName() + " tried to push an invalid project configuration " + receiveEvent.command.getNewId().name() + " for project " + receiveEvent.project, e);
            throw new CommitValidationException("invalid project configuration", messages);
        }
    }
    if (allUsers.equals(branch.getParentKey()) && RefNames.isRefsUsers(branch.get())) {
        List<CommitValidationMessage> messages = new ArrayList<>();
        Account.Id accountId = Account.Id.fromRef(branch.get());
        if (accountId != null) {
            try {
                WatchConfig wc = new WatchConfig(accountId);
                wc.load(rw, receiveEvent.command.getNewId());
                if (!wc.getValidationErrors().isEmpty()) {
                    addError("Invalid project configuration:", messages);
                    for (ValidationError err : wc.getValidationErrors()) {
                        addError("  " + err.getMessage(), messages);
                    }
                    throw new ConfigInvalidException("invalid watch configuration");
                }
            } catch (IOException | ConfigInvalidException e) {
                log.error("User " + user.getUserName() + " tried to push an invalid watch configuration " + receiveEvent.command.getNewId().name() + " for account " + accountId.get(), e);
                throw new CommitValidationException("invalid watch configuration", messages);
            }
        }
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    if (REFS_CONFIG.equals(branch.get())) {
        List<CommitValidationMessage> messages = new ArrayList<>();
        try {
            ProjectConfig cfg = new ProjectConfig(receiveEvent.project.getNameKey());
            cfg.load(rw, receiveEvent.command.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:", messages);
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage(), messages);
                }
                throw new ConfigInvalidException("invalid project configuration");
            }
            if (allUsers.equals(receiveEvent.project.getNameKey()) || allProjects.equals(receiveEvent.project.getNameKey())) {
                // Check if the new config modifies any access sections for refs/groups/. These are
                // managed by Gerrit and modifications are not allowed.
                Set<AccessSection> diff = Sets.symmetricDifference(new HashSet<>(projectState.getConfig().getAccessSections()), new HashSet<>(cfg.getAccessSections()));
                boolean modifiesGroupsAccessSection = diff.stream().filter(as -> as.getName().startsWith(RefNames.REFS_GROUPS)).findAny().isPresent();
                if (modifiesGroupsAccessSection) {
                    addError("Invalid project configuration:", messages);
                    addError(String.format("  permissions on %s are managed by gerrit and cannot be modified", RefNames.REFS_GROUPS), messages);
                    throw new ConfigInvalidException("invalid project configuration");
                }
            }
            if (allUsers.equals(receiveEvent.project.getNameKey()) && !allProjects.equals(cfg.getProject().getParent(allProjects))) {
                addError("Invalid project configuration:", messages);
                addError(String.format("  %s must inherit from %s", allUsers.get(), allProjects.get()), messages);
                throw new ConfigInvalidException("invalid project configuration");
            }
        } catch (ConfigInvalidException | IOException e) {
            log.error("User " + user.getUserName() + " tried to push an invalid project configuration " + receiveEvent.command.getNewId().name() + " for project " + receiveEvent.project, e);
            throw new CommitValidationException("invalid project configuration", messages);
        }
    }
    if (allUsers.equals(branch.getParentKey()) && RefNames.isRefsUsers(branch.get())) {
        List<CommitValidationMessage> messages = new ArrayList<>();
        Account.Id accountId = Account.Id.fromRef(branch.get());
        if (accountId != null) {
            try {
                WatchConfig wc = new WatchConfig(accountId);
                wc.load(rw, receiveEvent.command.getNewId());
                if (!wc.getValidationErrors().isEmpty()) {
                    addError("Invalid project configuration:", messages);
                    for (ValidationError err : wc.getValidationErrors()) {
                        addError("  " + err.getMessage(), messages);
                    }
                    throw new ConfigInvalidException("invalid watch configuration");
                }
            } catch (IOException | ConfigInvalidException e) {
                log.error("User " + user.getUserName() + " tried to push an invalid watch configuration " + receiveEvent.command.getNewId().name() + " for account " + accountId.get(), e);
                throw new CommitValidationException("invalid watch configuration", messages);
            }
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (!(o instanceof AccountGroup)) {
        return false;
    }
    AccountGroup g = (AccountGroup) o;
    return name.equals(g.name) && groupId.equals(g.groupId) && Objects.equals(description, g.description) && visibleToAll == g.visibleToAll && groupUUID.equals(g.groupUUID) && ownerGroupUUID.equals(g.ownerGroupUUID) && Objects.equals(createdOn, g.createdOn);
}
#method_after
@Override
public boolean equals(Object o) {
    if (!(o instanceof AccountGroup)) {
        return false;
    }
    AccountGroup g = (AccountGroup) o;
    return Objects.equals(name, g.name) && Objects.equals(groupId, g.groupId) && Objects.equals(description, g.description) && visibleToAll == g.visibleToAll && Objects.equals(groupUUID, g.groupUUID) && Objects.equals(ownerGroupUUID, g.ownerGroupUUID) && // Treat created on epoch identical regardless if underlying value is null.
    getCreatedOn().equals(g.getCreatedOn());
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    return (o instanceof AccountGroupById) && ((AccountGroupById) o).key.equals(key);
}
#method_after
@Override
public boolean equals(Object o) {
    return (o instanceof AccountGroupById) && Objects.equals(key, ((AccountGroupById) o).key);
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (!(o instanceof AccountGroupByIdAud)) {
        return false;
    }
    AccountGroupByIdAud a = (AccountGroupByIdAud) o;
    return key.equals(a.key) && addedBy.equals(a.addedBy) && Objects.equals(removedBy, a.removedBy) && Objects.equals(removedOn, a.removedOn);
}
#method_after
@Override
public boolean equals(Object o) {
    if (!(o instanceof AccountGroupByIdAud)) {
        return false;
    }
    AccountGroupByIdAud a = (AccountGroupByIdAud) o;
    return Objects.equals(key, a.key) && Objects.equals(addedBy, a.addedBy) && Objects.equals(removedBy, a.removedBy) && Objects.equals(removedOn, a.removedOn);
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    return (o instanceof AccountGroupMember) && ((AccountGroupMember) o).key.equals(key);
}
#method_after
@Override
public boolean equals(Object o) {
    return (o instanceof AccountGroupMember) && Objects.equals(key, ((AccountGroupMember) o).key);
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (!(o instanceof AccountGroupMemberAudit)) {
        return false;
    }
    AccountGroupMemberAudit a = (AccountGroupMemberAudit) o;
    return key.equals(a.key) && addedBy.equals(a.addedBy) && Objects.equals(removedBy, a.removedBy) && Objects.equals(removedOn, a.removedOn);
}
#method_after
@Override
public boolean equals(Object o) {
    if (!(o instanceof AccountGroupMemberAudit)) {
        return false;
    }
    AccountGroupMemberAudit a = (AccountGroupMemberAudit) o;
    return Objects.equals(key, a.key) && Objects.equals(addedBy, a.addedBy) && Objects.equals(removedBy, a.removedBy) && Objects.equals(removedOn, a.removedOn);
}
#end_block

#method_before
@Test
public void version() {
    boolean eclipse = Arrays.stream(Thread.currentThread().getStackTrace()).anyMatch(e -> e.getClassName().startsWith("org.eclipse.jdt."));
    Pattern expected = eclipse ? // Different source line so it shows up in coverage.
    DEV_PATTERN : GIT_DESCRIBE_PATTERN;
    assertThat(Version.getVersion()).matches(expected);
    assertThat(Version.getVersion()).matches(expected);
}
#method_after
@Test
public void version() {
    Pattern expected = GerritLauncher.isRunningInEclipse() ? // Different source line so it shows up in coverage.
    DEV_PATTERN : GIT_DESCRIBE_PATTERN;
    assertThat(Version.getVersion()).matches(expected);
    // Try again in case of caching issues.
    assertThat(Version.getVersion()).matches(expected);
}
#end_block

#method_before
@Test
public void gitDescribePattern() {
    assertThat("2.15-rc0").matches(GIT_DESCRIBE_PATTERN);
    assertThat("2.15-rc1").matches(GIT_DESCRIBE_PATTERN);
    assertThat("2.15").matches(GIT_DESCRIBE_PATTERN);
    assertThat("2.15.1").matches(GIT_DESCRIBE_PATTERN);
    assertThat("2.15.1.2").matches(GIT_DESCRIBE_PATTERN);
    assertThat("2.15.1.2.3").matches(GIT_DESCRIBE_PATTERN);
    assertThat("2.15.1-rc1").matches(GIT_DESCRIBE_PATTERN);
    assertThat("2.15-rc2-123-gabcd123").matches(GIT_DESCRIBE_PATTERN);
    assertThat("2.15-123-gabcd123").matches(GIT_DESCRIBE_PATTERN);
    assertThat("(dev)").doesNotMatch(GIT_DESCRIBE_PATTERN);
    assertThat("1").doesNotMatch(GIT_DESCRIBE_PATTERN);
    assertThat("v2.15").doesNotMatch(GIT_DESCRIBE_PATTERN);
}
#method_after
@Test
public void gitDescribePattern() {
    for (String suffix : ImmutableList.of("", "-dirty")) {
        assertThat("2.15-rc0" + suffix).matches(GIT_DESCRIBE_PATTERN);
        assertThat("2.15-rc0" + suffix).matches(GIT_DESCRIBE_PATTERN);
        assertThat("2.15-rc1" + suffix).matches(GIT_DESCRIBE_PATTERN);
        assertThat("2.15" + suffix).matches(GIT_DESCRIBE_PATTERN);
        assertThat("2.15.1" + suffix).matches(GIT_DESCRIBE_PATTERN);
        assertThat("2.15.1.2" + suffix).matches(GIT_DESCRIBE_PATTERN);
        assertThat("2.15.1.2.3" + suffix).matches(GIT_DESCRIBE_PATTERN);
        assertThat("2.15.1-rc1" + suffix).matches(GIT_DESCRIBE_PATTERN);
        assertThat("2.15-rc2-123-gabcd123" + suffix).matches(GIT_DESCRIBE_PATTERN);
        assertThat("2.15-123-gabcd123" + suffix).matches(GIT_DESCRIBE_PATTERN);
    }
    assertThat("2.15-ugly").doesNotMatch(GIT_DESCRIBE_PATTERN);
    assertThat("(dev)").doesNotMatch(GIT_DESCRIBE_PATTERN);
    assertThat("1").doesNotMatch(GIT_DESCRIBE_PATTERN);
    assertThat("v2.15").doesNotMatch(GIT_DESCRIBE_PATTERN);
}
#end_block

#method_before
public static String getVersion() {
    return version;
}
#method_after
public static String getVersion() {
    return VERSION;
}
#end_block

#method_before
@Override
public void buildUpdates(NoteDbUpdateManager manager, ChangeBundle bundle) throws IOException, OrmException {
    manager.setCheckExpectedState(false).setRefLogMessage("Rebuilding change");
    Change change = new Change(bundle.getChange());
    if (bundle.getPatchSets().isEmpty()) {
        throw new NoPatchSetsException(change.getId());
    }
    if (change.getLastUpdatedOn().compareTo(change.getCreatedOn()) < 0) {
        // Certain bad MySQL dump imports might set created_on (and a host of other timestamps) to the
        // time the dump was imported. The correct timestamps were lost, but we can at least set it so
        // created_on is not after last_updated_on.
        // See https://bugs.chromium.org/p/gerrit/issues/detail?id=7397
        change.setCreatedOn(change.getLastUpdatedOn());
    }
    // We will rebuild all events, except for draft comments, in buckets based on author and
    // timestamp.
    List<Event> events = new ArrayList<>();
    ListMultimap<Account.Id, DraftCommentEvent> draftCommentEvents = MultimapBuilder.hashKeys().arrayListValues().build();
    events.addAll(getHashtagsEvents(change, manager));
    // Delete ref only after hashtags have been read.
    deleteChangeMetaRef(change, manager.getChangeRepo().cmds);
    deleteDraftRefs(change, manager.getAllUsersRepo());
    Integer minPsNum = getMinPatchSetNum(bundle);
    TreeMap<PatchSet.Id, PatchSetEvent> patchSetEvents = new TreeMap<>(ReviewDbUtil.intKeyOrdering());
    for (PatchSet ps : bundle.getPatchSets()) {
        PatchSetEvent pse = new PatchSetEvent(change, ps, manager.getChangeRepo().rw);
        patchSetEvents.put(ps.getId(), pse);
        events.add(pse);
        for (Comment c : getComments(bundle, serverId, Status.PUBLISHED, ps)) {
            CommentEvent e = new CommentEvent(c, change, ps, patchListCache);
            events.add(e.addDep(pse));
        }
        for (Comment c : getComments(bundle, serverId, Status.DRAFT, ps)) {
            DraftCommentEvent e = new DraftCommentEvent(c, change, ps, patchListCache);
            draftCommentEvents.put(c.author.getId(), e);
        }
    }
    ensurePatchSetOrder(patchSetEvents);
    for (PatchSetApproval psa : bundle.getPatchSetApprovals()) {
        PatchSetEvent pse = patchSetEvents.get(psa.getPatchSetId());
        if (pse != null) {
            events.add(new ApprovalEvent(psa, change.getCreatedOn()).addDep(pse));
        }
    }
    for (Table.Cell<ReviewerStateInternal, Account.Id, Timestamp> r : bundle.getReviewers().asTable().cellSet()) {
        events.add(new ReviewerEvent(r, change.getCreatedOn()));
    }
    Change noteDbChange = new Change(null, null, null, null, null);
    for (ChangeMessage msg : bundle.getChangeMessages()) {
        Event msgEvent = new ChangeMessageEvent(change, noteDbChange, msg, change.getCreatedOn());
        if (msg.getPatchSetId() != null) {
            PatchSetEvent pse = patchSetEvents.get(msg.getPatchSetId());
            if (pse == null) {
                // Ignore events for missing patch sets.
                continue;
            }
            msgEvent.addDep(pse);
        }
        events.add(msgEvent);
    }
    sortAndFillEvents(change, noteDbChange, bundle.getPatchSets(), events, minPsNum);
    EventList<Event> el = new EventList<>();
    for (Event e : events) {
        if (!el.canAdd(e)) {
            flushEventsToUpdate(manager, el, change);
            checkState(el.canAdd(e));
        }
        el.add(e);
    }
    flushEventsToUpdate(manager, el, change);
    EventList<DraftCommentEvent> plcel = new EventList<>();
    for (Account.Id author : draftCommentEvents.keys()) {
        for (DraftCommentEvent e : Ordering.natural().sortedCopy(draftCommentEvents.get(author))) {
            if (!plcel.canAdd(e)) {
                flushEventsToDraftUpdate(manager, plcel, change);
                checkState(plcel.canAdd(e));
            }
            plcel.add(e);
        }
        flushEventsToDraftUpdate(manager, plcel, change);
    }
}
#method_after
@Override
public void buildUpdates(NoteDbUpdateManager manager, ChangeBundle bundle) throws IOException, OrmException {
    manager.setCheckExpectedState(false).setRefLogMessage("Rebuilding change");
    Change change = new Change(bundle.getChange());
    if (bundle.getPatchSets().isEmpty()) {
        throw new NoPatchSetsException(change.getId());
    }
    if (change.getLastUpdatedOn().compareTo(change.getCreatedOn()) < 0) {
        // A bug in data migration might set created_on to the time of the migration. The
        // correct timestamps were lost, but we can at least set it so created_on is not after
        // last_updated_on.
        // See https://bugs.chromium.org/p/gerrit/issues/detail?id=7397
        change.setCreatedOn(change.getLastUpdatedOn());
    }
    // We will rebuild all events, except for draft comments, in buckets based on author and
    // timestamp.
    List<Event> events = new ArrayList<>();
    ListMultimap<Account.Id, DraftCommentEvent> draftCommentEvents = MultimapBuilder.hashKeys().arrayListValues().build();
    events.addAll(getHashtagsEvents(change, manager));
    // Delete ref only after hashtags have been read.
    deleteChangeMetaRef(change, manager.getChangeRepo().cmds);
    deleteDraftRefs(change, manager.getAllUsersRepo());
    Integer minPsNum = getMinPatchSetNum(bundle);
    TreeMap<PatchSet.Id, PatchSetEvent> patchSetEvents = new TreeMap<>(ReviewDbUtil.intKeyOrdering());
    for (PatchSet ps : bundle.getPatchSets()) {
        PatchSetEvent pse = new PatchSetEvent(change, ps, manager.getChangeRepo().rw);
        patchSetEvents.put(ps.getId(), pse);
        events.add(pse);
        for (Comment c : getComments(bundle, serverId, Status.PUBLISHED, ps)) {
            CommentEvent e = new CommentEvent(c, change, ps, patchListCache);
            events.add(e.addDep(pse));
        }
        for (Comment c : getComments(bundle, serverId, Status.DRAFT, ps)) {
            DraftCommentEvent e = new DraftCommentEvent(c, change, ps, patchListCache);
            draftCommentEvents.put(c.author.getId(), e);
        }
    }
    ensurePatchSetOrder(patchSetEvents);
    for (PatchSetApproval psa : bundle.getPatchSetApprovals()) {
        PatchSetEvent pse = patchSetEvents.get(psa.getPatchSetId());
        if (pse != null) {
            events.add(new ApprovalEvent(psa, change.getCreatedOn()).addDep(pse));
        }
    }
    for (Table.Cell<ReviewerStateInternal, Account.Id, Timestamp> r : bundle.getReviewers().asTable().cellSet()) {
        events.add(new ReviewerEvent(r, change.getCreatedOn()));
    }
    Change noteDbChange = new Change(null, null, null, null, null);
    for (ChangeMessage msg : bundle.getChangeMessages()) {
        Event msgEvent = new ChangeMessageEvent(change, noteDbChange, msg, change.getCreatedOn());
        if (msg.getPatchSetId() != null) {
            PatchSetEvent pse = patchSetEvents.get(msg.getPatchSetId());
            if (pse == null) {
                // Ignore events for missing patch sets.
                continue;
            }
            msgEvent.addDep(pse);
        }
        events.add(msgEvent);
    }
    sortAndFillEvents(change, noteDbChange, bundle.getPatchSets(), events, minPsNum);
    EventList<Event> el = new EventList<>();
    for (Event e : events) {
        if (!el.canAdd(e)) {
            flushEventsToUpdate(manager, el, change);
            checkState(el.canAdd(e));
        }
        el.add(e);
    }
    flushEventsToUpdate(manager, el, change);
    EventList<DraftCommentEvent> plcel = new EventList<>();
    for (Account.Id author : draftCommentEvents.keys()) {
        for (DraftCommentEvent e : Ordering.natural().sortedCopy(draftCommentEvents.get(author))) {
            if (!plcel.canAdd(e)) {
                flushEventsToDraftUpdate(manager, plcel, change);
                checkState(plcel.canAdd(e));
            }
            plcel.add(e);
        }
        flushEventsToDraftUpdate(manager, plcel, change);
    }
}
#end_block

#method_before
private static void diffChanges(List<String> diffs, ChangeBundle bundleA, ChangeBundle bundleB) {
    Change a = bundleA.change;
    Change b = bundleB.change;
    String desc = a.getId().equals(b.getId()) ? describe(a.getId()) : "Changes";
    boolean excludeCreatedOn = false;
    boolean excludeCurrentPatchSetId = false;
    boolean excludeTopic = false;
    Timestamp aCreated = a.getCreatedOn();
    Timestamp bCreated = b.getCreatedOn();
    Timestamp aUpdated = a.getLastUpdatedOn();
    Timestamp bUpdated = b.getLastUpdatedOn();
    boolean excludeSubject = false;
    boolean excludeOrigSubj = false;
    // Subject is not technically a nullable field, but we observed some null
    // subjects in the wild on googlesource.com, so treat null as empty.
    String aSubj = Strings.nullToEmpty(a.getSubject());
    String bSubj = Strings.nullToEmpty(b.getSubject());
    // Use max timestamp of all ReviewDb entities when comparing with NoteDb.
    if (bundleA.source == REVIEW_DB && bundleB.source == NOTE_DB) {
        boolean createdOnMatchesFirstPs = !timestampsDiffer(bundleA, bundleA.getFirstPatchSetTime(), bundleB, bCreated);
        boolean createdOnMatchesLastUpdatedOn = !timestampsDiffer(bundleA, aUpdated, bundleB, bCreated);
        boolean createdAfterUpdated = aCreated.compareTo(aUpdated) > 0;
        excludeCreatedOn = createdOnMatchesFirstPs || (createdAfterUpdated && createdOnMatchesLastUpdatedOn);
        aSubj = cleanReviewDbSubject(aSubj);
        bSubj = cleanNoteDbSubject(bSubj);
        excludeCurrentPatchSetId = !bundleA.validPatchSetPredicate().apply(a.currentPatchSetId());
        excludeSubject = bSubj.startsWith(aSubj) || excludeCurrentPatchSetId;
        excludeOrigSubj = true;
        String aTopic = trimOrNull(a.getTopic());
        excludeTopic = Objects.equals(aTopic, b.getTopic()) || "".equals(aTopic) && b.getTopic() == null;
        aUpdated = bundleA.getLatestTimestamp();
    } else if (bundleA.source == NOTE_DB && bundleB.source == REVIEW_DB) {
        boolean createdOnMatchesFirstPs = !timestampsDiffer(bundleA, a.getCreatedOn(), bundleB, bundleB.getFirstPatchSetTime());
        boolean createdOnMatchesLastUpdatedOn = !timestampsDiffer(bundleA, aCreated, bundleB, bUpdated);
        boolean createdAfterUpdated = bCreated.compareTo(bUpdated) > 0;
        excludeCreatedOn = createdOnMatchesFirstPs || (createdAfterUpdated && createdOnMatchesLastUpdatedOn);
        aSubj = cleanNoteDbSubject(aSubj);
        bSubj = cleanReviewDbSubject(bSubj);
        excludeCurrentPatchSetId = !bundleB.validPatchSetPredicate().apply(b.currentPatchSetId());
        excludeSubject = aSubj.startsWith(bSubj) || excludeCurrentPatchSetId;
        excludeOrigSubj = true;
        String bTopic = trimOrNull(b.getTopic());
        excludeTopic = Objects.equals(bTopic, a.getTopic()) || a.getTopic() == null && "".equals(bTopic);
        bUpdated = bundleB.getLatestTimestamp();
    }
    String subjectField = "subject";
    String updatedField = "lastUpdatedOn";
    List<String> exclude = Lists.newArrayList(subjectField, updatedField, "noteDbState", "rowVersion");
    if (excludeCreatedOn) {
        exclude.add("createdOn");
    }
    if (excludeCurrentPatchSetId) {
        exclude.add("currentPatchSetId");
    }
    if (excludeOrigSubj) {
        exclude.add("originalSubject");
    }
    if (excludeTopic) {
        exclude.add("topic");
    }
    diffColumnsExcluding(diffs, Change.class, desc, bundleA, a, bundleB, b, exclude);
    // whole ReviewDb bundle (within slop).
    if (timestampsDiffer(bundleA, a.getLastUpdatedOn(), bundleB, b.getLastUpdatedOn())) {
        diffTimestamps(diffs, desc, bundleA, aUpdated, bundleB, bUpdated, "effective last updated time");
    }
    if (!excludeSubject) {
        diffValues(diffs, desc, aSubj, bSubj, subjectField);
    }
}
#method_after
private static void diffChanges(List<String> diffs, ChangeBundle bundleA, ChangeBundle bundleB) {
    Change a = bundleA.change;
    Change b = bundleB.change;
    String desc = a.getId().equals(b.getId()) ? describe(a.getId()) : "Changes";
    boolean excludeCreatedOn = false;
    boolean excludeCurrentPatchSetId = false;
    boolean excludeTopic = false;
    Timestamp aCreated = a.getCreatedOn();
    Timestamp bCreated = b.getCreatedOn();
    Timestamp aUpdated = a.getLastUpdatedOn();
    Timestamp bUpdated = b.getLastUpdatedOn();
    boolean excludeSubject = false;
    boolean excludeOrigSubj = false;
    // Subject is not technically a nullable field, but we observed some null
    // subjects in the wild on googlesource.com, so treat null as empty.
    String aSubj = Strings.nullToEmpty(a.getSubject());
    String bSubj = Strings.nullToEmpty(b.getSubject());
    // Use max timestamp of all ReviewDb entities when comparing with NoteDb.
    if (bundleA.source == REVIEW_DB && bundleB.source == NOTE_DB) {
        boolean createdOnMatchesFirstPs = !timestampsDiffer(bundleA, bundleA.getFirstPatchSetTime(), bundleB, bCreated);
        boolean createdOnMatchesLastUpdatedOn = !timestampsDiffer(bundleA, aUpdated, bundleB, bCreated);
        boolean createdAfterUpdated = aCreated.compareTo(aUpdated) > 0;
        excludeCreatedOn = createdOnMatchesFirstPs || (createdAfterUpdated && createdOnMatchesLastUpdatedOn);
        aSubj = cleanReviewDbSubject(aSubj);
        bSubj = cleanNoteDbSubject(bSubj);
        excludeCurrentPatchSetId = !bundleA.validPatchSetPredicate().apply(a.currentPatchSetId());
        excludeSubject = bSubj.startsWith(aSubj) || excludeCurrentPatchSetId;
        excludeOrigSubj = true;
        String aTopic = trimOrNull(a.getTopic());
        excludeTopic = Objects.equals(aTopic, b.getTopic()) || "".equals(aTopic) && b.getTopic() == null;
        aUpdated = bundleA.getLatestTimestamp();
    } else if (bundleA.source == NOTE_DB && bundleB.source == REVIEW_DB) {
        boolean createdOnMatchesFirstPs = !timestampsDiffer(bundleA, aCreated, bundleB, bundleB.getFirstPatchSetTime());
        boolean createdOnMatchesLastUpdatedOn = !timestampsDiffer(bundleA, aCreated, bundleB, bUpdated);
        boolean createdAfterUpdated = bCreated.compareTo(bUpdated) > 0;
        excludeCreatedOn = createdOnMatchesFirstPs || (createdAfterUpdated && createdOnMatchesLastUpdatedOn);
        aSubj = cleanNoteDbSubject(aSubj);
        bSubj = cleanReviewDbSubject(bSubj);
        excludeCurrentPatchSetId = !bundleB.validPatchSetPredicate().apply(b.currentPatchSetId());
        excludeSubject = aSubj.startsWith(bSubj) || excludeCurrentPatchSetId;
        excludeOrigSubj = true;
        String bTopic = trimOrNull(b.getTopic());
        excludeTopic = Objects.equals(bTopic, a.getTopic()) || a.getTopic() == null && "".equals(bTopic);
        bUpdated = bundleB.getLatestTimestamp();
    }
    String subjectField = "subject";
    String updatedField = "lastUpdatedOn";
    List<String> exclude = Lists.newArrayList(subjectField, updatedField, "noteDbState", "rowVersion");
    if (excludeCreatedOn) {
        exclude.add("createdOn");
    }
    if (excludeCurrentPatchSetId) {
        exclude.add("currentPatchSetId");
    }
    if (excludeOrigSubj) {
        exclude.add("originalSubject");
    }
    if (excludeTopic) {
        exclude.add("topic");
    }
    diffColumnsExcluding(diffs, Change.class, desc, bundleA, a, bundleB, b, exclude);
    // whole ReviewDb bundle (within slop).
    if (timestampsDiffer(bundleA, a.getLastUpdatedOn(), bundleB, b.getLastUpdatedOn())) {
        diffTimestamps(diffs, desc, bundleA, aUpdated, bundleB, bUpdated, "effective last updated time");
    }
    if (!excludeSubject) {
        diffValues(diffs, desc, aSubj, bSubj, subjectField);
    }
}
#end_block

#method_before
private void createSubmoduleCommitMsg(StringBuilder msgbuf, SubmoduleSubscription s, OpenRepo subOr, RevCommit newCommit, RevCommit oldCommit) throws SubmoduleException {
    msgbuf.append("* Update " + s.getPath());
    msgbuf.append(" from branch '" + s.getSubmodule().getShortName() + "'");
    msgbuf.append(" to " + newCommit.getName());
    // newly created submodule gitlink, do not append whole history
    if (oldCommit == null) {
        return;
    }
    try {
        subOr.rw.resetRetain(subOr.canMergeFlag);
        subOr.rw.markStart(newCommit);
        subOr.rw.markUninteresting(oldCommit);
        for (RevCommit c : subOr.rw) {
            subOr.rw.parseBody(c);
            if (verboseSuperProject == VerboseSuperprojectUpdate.SUBJECT_ONLY) {
                msgbuf.append("\n  - " + c.getShortMessage());
            } else if (verboseSuperProject == VerboseSuperprojectUpdate.TRUE) {
                msgbuf.append("\n  - " + c.getFullMessage().replace("\n", "\n    "));
            }
        }
    } catch (IOException e) {
        throw new SubmoduleException("Could not perform a revwalk to create superproject commit message", e);
    }
}
#method_after
private void createSubmoduleCommitMsg(StringBuilder msgbuf, SubmoduleSubscription s, OpenRepo subOr, RevCommit newCommit, RevCommit oldCommit) throws SubmoduleException {
    msgbuf.append("* Update " + s.getPath());
    msgbuf.append(" from branch '" + s.getSubmodule().getShortName() + "'");
    msgbuf.append("\n  to " + newCommit.getName());
    // newly created submodule gitlink, do not append whole history
    if (oldCommit == null) {
        return;
    }
    try {
        subOr.rw.resetRetain(subOr.canMergeFlag);
        subOr.rw.markStart(newCommit);
        subOr.rw.markUninteresting(oldCommit);
        for (RevCommit c : subOr.rw) {
            subOr.rw.parseBody(c);
            if (verboseSuperProject == VerboseSuperprojectUpdate.SUBJECT_ONLY) {
                msgbuf.append("\n  - " + c.getShortMessage());
            } else if (verboseSuperProject == VerboseSuperprojectUpdate.TRUE) {
                msgbuf.append("\n  - " + c.getFullMessage().replace("\n", "\n    "));
            }
        }
    } catch (IOException e) {
        throw new SubmoduleException("Could not perform a revwalk to create superproject commit message", e);
    }
}
#end_block

#method_before
@Test
public void newPatchSetWithVote() throws Exception {
    saveLabelConfig();
    // push a new change
    PushOneCommit.Result r = createChange();
    ReviewInput reviewInput = new ReviewInput().message(label.getName());
    revision(r).review(reviewInput);
    // push a new revision with +1 vote
    ChangeInfo c = get(r.getChangeId());
    r = amendChange(c.changeId);
    reviewInput = new ReviewInput().label(label.getName(), (short) 1);
    revision(r).review(reviewInput);
    ApprovalValues attr = getApprovalValues(label);
    assertThat(attr.oldValue).isEqualTo(0);
    assertThat(attr.value).isEqualTo(1);
    assertThat(lastCommentAddedEvent.getComment()).isEqualTo(String.format("Patch Set 2: %s+1", label.getName()));
}
#method_after
@Test
public void newPatchSetWithVote() throws Exception {
    saveLabelConfig();
    // push a new change
    PushOneCommit.Result r = createChange();
    ReviewInput reviewInput = new ReviewInput().message(label.getName());
    revision(r).review(reviewInput);
    // push a new revision with +1 vote
    ChangeInfo c = info(r.getChangeId());
    r = amendChange(c.changeId);
    reviewInput = new ReviewInput().label(label.getName(), (short) 1);
    revision(r).review(reviewInput);
    ApprovalValues attr = getApprovalValues(label);
    assertThat(attr.oldValue).isEqualTo(0);
    assertThat(attr.value).isEqualTo(1);
    assertThat(lastCommentAddedEvent.getComment()).isEqualTo(String.format("Patch Set 2: %s+1", label.getName()));
}
#end_block

#method_before
@Test
public void reviewChange_MultipleVotes() throws Exception {
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    ReviewInput reviewInput = new ReviewInput().label(label.getName(), -1);
    reviewInput.message = label.getName();
    revision(r).review(reviewInput);
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    ApprovalValues labelAttr = getApprovalValues(label);
    assertThat(labelAttr.oldValue).isEqualTo(0);
    assertThat(labelAttr.value).isEqualTo(-1);
    assertThat(lastCommentAddedEvent.getComment()).isEqualTo(String.format("Patch Set 1: %s-1\n\n%s", label.getName(), label.getName()));
    // there should be 3 approval labels (label, pLabel, and CRVV)
    assertThat(lastCommentAddedEvent.getApprovals()).hasSize(3);
    // check the approvals that were not voted on
    ApprovalValues pLabelAttr = getApprovalValues(pLabel);
    assertThat(pLabelAttr.oldValue).isNull();
    assertThat(pLabelAttr.value).isEqualTo(0);
    LabelType crLabel = LabelType.withDefaultValues("Code-Review");
    ApprovalValues crlAttr = getApprovalValues(crLabel);
    assertThat(crlAttr.oldValue).isNull();
    assertThat(crlAttr.value).isEqualTo(0);
    // update pLabel approval
    reviewInput = new ReviewInput().label(pLabel.getName(), 1);
    reviewInput.message = pLabel.getName();
    revision(r).review(reviewInput);
    c = get(r.getChangeId());
    q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    pLabelAttr = getApprovalValues(pLabel);
    assertThat(pLabelAttr.oldValue).isEqualTo(0);
    assertThat(pLabelAttr.value).isEqualTo(1);
    assertThat(lastCommentAddedEvent.getComment()).isEqualTo(String.format("Patch Set 1: %s+1\n\n%s", pLabel.getName(), pLabel.getName()));
    // check the approvals that were not voted on
    labelAttr = getApprovalValues(label);
    assertThat(labelAttr.oldValue).isNull();
    assertThat(labelAttr.value).isEqualTo(-1);
    crlAttr = getApprovalValues(crLabel);
    assertThat(crlAttr.oldValue).isNull();
    assertThat(crlAttr.value).isEqualTo(0);
}
#method_after
@Test
public void reviewChange_MultipleVotes() throws Exception {
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    ReviewInput reviewInput = new ReviewInput().label(label.getName(), -1);
    reviewInput.message = label.getName();
    revision(r).review(reviewInput);
    ChangeInfo c = get(r.getChangeId(), DETAILED_LABELS);
    LabelInfo q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    ApprovalValues labelAttr = getApprovalValues(label);
    assertThat(labelAttr.oldValue).isEqualTo(0);
    assertThat(labelAttr.value).isEqualTo(-1);
    assertThat(lastCommentAddedEvent.getComment()).isEqualTo(String.format("Patch Set 1: %s-1\n\n%s", label.getName(), label.getName()));
    // there should be 3 approval labels (label, pLabel, and CRVV)
    assertThat(lastCommentAddedEvent.getApprovals()).hasSize(3);
    // check the approvals that were not voted on
    ApprovalValues pLabelAttr = getApprovalValues(pLabel);
    assertThat(pLabelAttr.oldValue).isNull();
    assertThat(pLabelAttr.value).isEqualTo(0);
    LabelType crLabel = LabelType.withDefaultValues("Code-Review");
    ApprovalValues crlAttr = getApprovalValues(crLabel);
    assertThat(crlAttr.oldValue).isNull();
    assertThat(crlAttr.value).isEqualTo(0);
    // update pLabel approval
    reviewInput = new ReviewInput().label(pLabel.getName(), 1);
    reviewInput.message = pLabel.getName();
    revision(r).review(reviewInput);
    c = get(r.getChangeId(), DETAILED_LABELS);
    q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    pLabelAttr = getApprovalValues(pLabel);
    assertThat(pLabelAttr.oldValue).isEqualTo(0);
    assertThat(pLabelAttr.value).isEqualTo(1);
    assertThat(lastCommentAddedEvent.getComment()).isEqualTo(String.format("Patch Set 1: %s+1\n\n%s", pLabel.getName(), pLabel.getName()));
    // check the approvals that were not voted on
    labelAttr = getApprovalValues(label);
    assertThat(labelAttr.oldValue).isNull();
    assertThat(labelAttr.value).isEqualTo(-1);
    crlAttr = getApprovalValues(crLabel);
    assertThat(crlAttr.oldValue).isNull();
    assertThat(crlAttr.value).isEqualTo(0);
}
#end_block

#method_before
private static AccountState newState(Account account) {
    return new AccountState(new AllUsersName(AllUsersNameProvider.DEFAULT), account, ImmutableSet.of(), ImmutableSet.of(), new HashMap<>());
}
#method_after
private static AccountState newState(Account account) {
    return new AccountState(new AllUsersName(AllUsersNameProvider.DEFAULT), account, ImmutableSet.of(), new HashMap<>());
}
#end_block

#method_before
@Test
public void customLabelNoOp_NegativeVoteNotBlock() throws Exception {
    label.setFunctionName("NoOp");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(label.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isNull();
}
#method_after
@Test
public void customLabelNoOp_NegativeVoteNotBlock() throws Exception {
    label.setFunction(NO_OP);
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(label.getName(), -1));
    ChangeInfo c = getWithLabels(r);
    LabelInfo q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.approved).isNull();
    assertThat(q.recommended).isNull();
    assertThat(q.disliked).isNull();
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isNull();
}
#end_block

#method_before
@Test
public void customLabelNoBlock_NegativeVoteNotBlock() throws Exception {
    label.setFunctionName("NoBlock");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(label.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isNull();
}
#method_after
@Test
public void customLabelNoBlock_NegativeVoteNotBlock() throws Exception {
    label.setFunction(NO_BLOCK);
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(label.getName(), -1));
    ChangeInfo c = getWithLabels(r);
    LabelInfo q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.approved).isNull();
    assertThat(q.recommended).isNull();
    assertThat(q.disliked).isNull();
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isNull();
}
#end_block

#method_before
@Test
public void customLabelMaxNoBlock_NegativeVoteNotBlock() throws Exception {
    label.setFunctionName("MaxNoBlock");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(label.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isNull();
}
#method_after
@Test
public void customLabelMaxNoBlock_NegativeVoteNotBlock() throws Exception {
    label.setFunction(MAX_NO_BLOCK);
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(label.getName(), -1));
    ChangeInfo c = getWithLabels(r);
    LabelInfo q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.approved).isNull();
    assertThat(q.recommended).isNull();
    assertThat(q.disliked).isNull();
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isNull();
}
#end_block

#method_before
@Test
public void customLabelAnyWithBlock_NegativeVoteBlock() throws Exception {
    label.setFunctionName("AnyWithBlock");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(label.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.disliked).isNull();
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isTrue();
}
#method_after
@Test
public void customLabelAnyWithBlock_NegativeVoteBlock() throws Exception {
    label.setFunction(ANY_WITH_BLOCK);
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(label.getName(), -1));
    ChangeInfo c = getWithLabels(r);
    LabelInfo q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.approved).isNull();
    assertThat(q.recommended).isNull();
    assertThat(q.disliked).isNull();
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isTrue();
}
#end_block

#method_before
@Test
public void customLabelAnyWithBlock_Addreviewer_ZeroVote() throws Exception {
    P.setFunctionName("AnyWithBlock");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    ReviewInput input = new ReviewInput().label(P.getName(), 0);
    input.message = "foo";
    revision(r).review(input);
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(P.getName());
    assertThat(q.all).hasSize(2);
    assertThat(q.disliked).isNull();
    assertThat(q.rejected).isNull();
    assertThat(q.blocking).isNull();
    assertThat(lastCommentAddedEvent.getComment()).isEqualTo("Patch Set 1:\n\n" + input.message);
}
#method_after
@Test
public void customLabelAnyWithBlock_Addreviewer_ZeroVote() throws Exception {
    P.setFunction(ANY_WITH_BLOCK);
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    ReviewInput input = new ReviewInput().label(P.getName(), 0);
    input.message = "foo";
    revision(r).review(input);
    ChangeInfo c = getWithLabels(r);
    LabelInfo q = c.labels.get(P.getName());
    assertThat(q.all).hasSize(2);
    assertThat(q.approved).isNull();
    assertThat(q.recommended).isNull();
    assertThat(q.disliked).isNull();
    assertThat(q.rejected).isNull();
    assertThat(q.blocking).isNull();
    assertThat(lastCommentAddedEvent.getComment()).isEqualTo("Patch Set 1:\n\n" + input.message);
}
#end_block

#method_before
@Test
public void customLabelMaxWithBlock_NegativeVoteBlock() throws Exception {
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(label.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.disliked).isNull();
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isTrue();
}
#method_after
@Test
public void customLabelMaxWithBlock_NegativeVoteBlock() throws Exception {
    label.setFunction(MAX_WITH_BLOCK);
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(label.getName(), -1));
    ChangeInfo c = getWithLabels(r);
    LabelInfo q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.approved).isNull();
    assertThat(q.recommended).isNull();
    assertThat(q.disliked).isNull();
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isTrue();
}
#end_block

#method_before
@Test
public void customLabel_DisallowPostSubmit() throws Exception {
    label.setFunctionName("NoOp");
    label.setAllowPostSubmit(false);
    P.setFunctionName("NoOp");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(ReviewInput.approve());
    revision(r).submit();
    ChangeInfo info = get(r.getChangeId(), ListChangesOption.DETAILED_LABELS);
    assertPermitted(info, "Code-Review", 2);
    assertPermitted(info, P.getName(), 0, 1);
    assertPermitted(info, label.getName());
    ReviewInput in = new ReviewInput();
    in.label(P.getName(), P.getMax().getValue());
    revision(r).review(in);
    in = new ReviewInput();
    in.label(label.getName(), label.getMax().getValue());
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Voting on labels disallowed after submit: " + label.getName());
    revision(r).review(in);
}
#method_after
@Test
public void customLabel_DisallowPostSubmit() throws Exception {
    label.setFunction(NO_OP);
    label.setAllowPostSubmit(false);
    P.setFunction(NO_OP);
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(ReviewInput.approve());
    revision(r).submit();
    ChangeInfo info = getWithLabels(r);
    assertPermitted(info, "Code-Review", 2);
    assertPermitted(info, P.getName(), 0, 1);
    assertPermitted(info, label.getName());
    ReviewInput in = new ReviewInput();
    in.label(P.getName(), P.getMax().getValue());
    revision(r).review(in);
    in = new ReviewInput();
    in.label(label.getName(), label.getMax().getValue());
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Voting on labels disallowed after submit: " + label.getName());
    revision(r).review(in);
}
#end_block

#method_before
@Test
public void byStatus() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    ChangeInserter ins2 = newChangeWithStatus(repo, Change.Status.MERGED);
    Change change2 = insert(repo, ins2);
    assertQuery("status:new", change1);
    assertQuery("status:NEW", change1);
    assertQuery("is:new", change1);
    assertQuery("status:merged", change2);
    assertQuery("is:merged", change2);
}
#method_after
@Test
public void byStatus() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    ChangeInserter ins2 = newChangeWithStatus(repo, Change.Status.MERGED);
    Change change2 = insert(repo, ins2);
    assertQuery("status:new", change1);
    assertQuery("status:NEW", change1);
    assertQuery("is:new", change1);
    assertQuery("status:merged", change2);
    assertQuery("is:merged", change2);
    assertQuery("status:draft");
    assertQuery("is:draft");
}
#end_block

#method_before
@Test
public void byStatusOpen() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    ChangeInserter ins2 = newChangeWithStatus(repo, Change.Status.DRAFT);
    Change change2 = insert(repo, ins2);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    Change[] expected = new Change[] { change2, change1 };
    assertQuery("status:open", expected);
    assertQuery("status:OPEN", expected);
    assertQuery("status:o", expected);
    assertQuery("status:op", expected);
    assertQuery("status:ope", expected);
    assertQuery("status:pending", expected);
    assertQuery("status:PENDING", expected);
    assertQuery("status:p", expected);
    assertQuery("status:pe", expected);
    assertQuery("status:pen", expected);
    assertQuery("is:open", expected);
}
#method_after
@Test
public void byStatusOpen() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    Change[] expected = new Change[] { change1 };
    assertQuery("status:open", expected);
    assertQuery("status:OPEN", expected);
    assertQuery("status:o", expected);
    assertQuery("status:op", expected);
    assertQuery("status:ope", expected);
    assertQuery("status:pending", expected);
    assertQuery("status:PENDING", expected);
    assertQuery("status:p", expected);
    assertQuery("status:pe", expected);
    assertQuery("status:pen", expected);
    assertQuery("is:open", expected);
}
#end_block

#method_before
@Test
public void byStatusPrefix() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    assertQuery("status:n", change1);
    assertQuery("status:ne", change1);
    assertQuery("status:new", change1);
    assertQuery("status:N", change1);
    assertQuery("status:nE", change1);
    assertQuery("status:neW", change1);
    assertThatQueryException("status:nx").hasMessageThat().isEqualTo("invalid change status: nx");
    assertThatQueryException("status:newx").hasMessageThat().isEqualTo("invalid change status: newx");
}
#method_after
@Test
public void byStatusPrefix() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    assertQuery("status:n", change1);
    assertQuery("status:ne", change1);
    assertQuery("status:new", change1);
    assertQuery("status:N", change1);
    assertQuery("status:nE", change1);
    assertQuery("status:neW", change1);
    assertQuery("status:nx");
    assertQuery("status:newx");
}
#end_block

#method_before
@Test
public void byAge() throws Exception {
    long thirtyHoursInMs = MILLISECONDS.convert(30, HOURS);
    resetTimeWithClockStep(thirtyHoursInMs, MILLISECONDS);
    TestRepository<Repo> repo = createProject("repo");
    long startMs = TestTimeUtil.START.getMillis();
    Change change1 = insert(repo, newChange(repo), null, new Timestamp(startMs));
    Change change2 = insert(repo, newChange(repo), null, new Timestamp(startMs + thirtyHoursInMs));
    // Stop time so age queries use the same endpoint.
    TestTimeUtil.setClockStep(0, MILLISECONDS);
    TestTimeUtil.setClock(new Timestamp(startMs + 2 * thirtyHoursInMs));
    long nowMs = TimeUtil.nowMs();
    assertThat(lastUpdatedMs(change2) - lastUpdatedMs(change1)).isEqualTo(thirtyHoursInMs);
    assertThat(nowMs - lastUpdatedMs(change2)).isEqualTo(thirtyHoursInMs);
    assertThat(TimeUtil.nowMs()).isEqualTo(nowMs);
    assertQuery("-age:1d");
    assertQuery("-age:" + (30 * 60 - 1) + "m");
    assertQuery("-age:2d", change2);
    assertQuery("-age:3d", change2, change1);
    assertQuery("age:3d");
    assertQuery("age:2d", change1);
    assertQuery("age:1d", change2, change1);
}
#method_after
@Test
public void byAge() throws Exception {
    long thirtyHoursInMs = MILLISECONDS.convert(30, HOURS);
    resetTimeWithClockStep(thirtyHoursInMs, MILLISECONDS);
    TestRepository<Repo> repo = createProject("repo");
    long startMs = TestTimeUtil.START.toEpochMilli();
    Change change1 = insert(repo, newChange(repo), null, new Timestamp(startMs));
    Change change2 = insert(repo, newChange(repo), null, new Timestamp(startMs + thirtyHoursInMs));
    // Stop time so age queries use the same endpoint.
    TestTimeUtil.setClockStep(0, MILLISECONDS);
    TestTimeUtil.setClock(new Timestamp(startMs + 2 * thirtyHoursInMs));
    long nowMs = TimeUtil.nowMs();
    assertThat(lastUpdatedMs(change2) - lastUpdatedMs(change1)).isEqualTo(thirtyHoursInMs);
    assertThat(nowMs - lastUpdatedMs(change2)).isEqualTo(thirtyHoursInMs);
    assertThat(TimeUtil.nowMs()).isEqualTo(nowMs);
    assertQuery("-age:1d");
    assertQuery("-age:" + (30 * 60 - 1) + "m");
    assertQuery("-age:2d", change2);
    assertQuery("-age:3d", change2, change1);
    assertQuery("age:3d");
    assertQuery("age:2d", change1);
    assertQuery("age:1d", change2, change1);
}
#end_block

#method_before
@Test
public void byBefore() throws Exception {
    long thirtyHoursInMs = MILLISECONDS.convert(30, HOURS);
    resetTimeWithClockStep(thirtyHoursInMs, MILLISECONDS);
    TestRepository<Repo> repo = createProject("repo");
    long startMs = TestTimeUtil.START.getMillis();
    Change change1 = insert(repo, newChange(repo), null, new Timestamp(startMs));
    Change change2 = insert(repo, newChange(repo), null, new Timestamp(startMs + thirtyHoursInMs));
    TestTimeUtil.setClockStep(0, MILLISECONDS);
    assertQuery("before:2009-09-29");
    assertQuery("before:2009-09-30");
    assertQuery("before:\"2009-09-30 16:59:00 -0400\"");
    assertQuery("before:\"2009-09-30 20:59:00 -0000\"");
    assertQuery("before:\"2009-09-30 20:59:00\"");
    assertQuery("before:\"2009-09-30 17:02:00 -0400\"", change1);
    assertQuery("before:\"2009-10-01 21:02:00 -0000\"", change1);
    assertQuery("before:\"2009-10-01 21:02:00\"", change1);
    assertQuery("before:2009-10-01", change1);
    assertQuery("before:2009-10-03", change2, change1);
}
#method_after
@Test
public void byBefore() throws Exception {
    long thirtyHoursInMs = MILLISECONDS.convert(30, HOURS);
    resetTimeWithClockStep(thirtyHoursInMs, MILLISECONDS);
    TestRepository<Repo> repo = createProject("repo");
    long startMs = TestTimeUtil.START.toEpochMilli();
    Change change1 = insert(repo, newChange(repo), null, new Timestamp(startMs));
    Change change2 = insert(repo, newChange(repo), null, new Timestamp(startMs + thirtyHoursInMs));
    TestTimeUtil.setClockStep(0, MILLISECONDS);
    assertQuery("before:2009-09-29");
    assertQuery("before:2009-09-30");
    assertQuery("before:\"2009-09-30 16:59:00 -0400\"");
    assertQuery("before:\"2009-09-30 20:59:00 -0000\"");
    assertQuery("before:\"2009-09-30 20:59:00\"");
    assertQuery("before:\"2009-09-30 17:02:00 -0400\"", change1);
    assertQuery("before:\"2009-10-01 21:02:00 -0000\"", change1);
    assertQuery("before:\"2009-10-01 21:02:00\"", change1);
    assertQuery("before:2009-10-01", change1);
    assertQuery("before:2009-10-03", change2, change1);
}
#end_block

#method_before
@Test
public void byAfter() throws Exception {
    long thirtyHoursInMs = MILLISECONDS.convert(30, HOURS);
    resetTimeWithClockStep(thirtyHoursInMs, MILLISECONDS);
    TestRepository<Repo> repo = createProject("repo");
    long startMs = TestTimeUtil.START.getMillis();
    Change change1 = insert(repo, newChange(repo), null, new Timestamp(startMs));
    Change change2 = insert(repo, newChange(repo), null, new Timestamp(startMs + thirtyHoursInMs));
    TestTimeUtil.setClockStep(0, MILLISECONDS);
    assertQuery("after:2009-10-03");
    assertQuery("after:\"2009-10-01 20:59:59 -0400\"", change2);
    assertQuery("after:\"2009-10-01 20:59:59 -0000\"", change2);
    assertQuery("after:2009-10-01", change2);
    assertQuery("after:2009-09-30", change2, change1);
}
#method_after
@Test
public void byAfter() throws Exception {
    long thirtyHoursInMs = MILLISECONDS.convert(30, HOURS);
    resetTimeWithClockStep(thirtyHoursInMs, MILLISECONDS);
    TestRepository<Repo> repo = createProject("repo");
    long startMs = TestTimeUtil.START.toEpochMilli();
    Change change1 = insert(repo, newChange(repo), null, new Timestamp(startMs));
    Change change2 = insert(repo, newChange(repo), null, new Timestamp(startMs + thirtyHoursInMs));
    TestTimeUtil.setClockStep(0, MILLISECONDS);
    assertQuery("after:2009-10-03");
    assertQuery("after:\"2009-10-01 20:59:59 -0400\"", change2);
    assertQuery("after:\"2009-10-01 20:59:59 -0000\"", change2);
    assertQuery("after:2009-10-01", change2);
    assertQuery("after:2009-09-30", change2, change1);
}
#end_block

#method_before
public static final LabelType patchSetLock() {
    LabelType label = category("Patch-Set-Lock", value(1, "Patch Set Locked"), value(0, "Patch Set Unlocked"));
    label.setFunctionName("PatchSetLock");
    return label;
}
#method_after
public static final LabelType patchSetLock() {
    LabelType label = category("Patch-Set-Lock", value(1, "Patch Set Locked"), value(0, "Patch Set Unlocked"));
    label.setFunction(LabelFunction.PATCH_SET_LOCK);
    return label;
}
#end_block

#method_before
@Test
public void createSchema_Label_CodeReview() throws Exception {
    LabelType codeReview = getLabelTypes().byLabel("Code-Review");
    assertThat(codeReview).isNotNull();
    assertThat(codeReview.getName()).isEqualTo("Code-Review");
    assertThat(codeReview.getDefaultValue()).isEqualTo(0);
    assertThat(codeReview.getFunctionName()).isEqualTo("MaxWithBlock");
    assertThat(codeReview.isCopyMinScore()).isTrue();
    assertValueRange(codeReview, 2, 1, 0, -1, -2);
}
#method_after
@Test
public void createSchema_Label_CodeReview() throws Exception {
    LabelType codeReview = getLabelTypes().byLabel("Code-Review");
    assertThat(codeReview).isNotNull();
    assertThat(codeReview.getName()).isEqualTo("Code-Review");
    assertThat(codeReview.getDefaultValue()).isEqualTo(0);
    assertThat(codeReview.getFunction()).isEqualTo(LabelFunction.MAX_WITH_BLOCK);
    assertThat(codeReview.isCopyMinScore()).isTrue();
    assertValueRange(codeReview, 2, 1, 0, -1, -2);
}
#end_block

#method_before
@Test
public void restApiNotFoundWhenNoteDbDisabled() throws Exception {
    PushOneCommit.Result r = createChange();
    exception.expect(ResourceNotFoundException.class);
    rebuildHandler.apply(parseChangeResource(r.getChangeId()), new Rebuild.Input());
}
#method_after
@Test
public void restApiNotFoundWhenNoteDbDisabled() throws Exception {
    PushOneCommit.Result r = createChange();
    exception.expect(ResourceNotFoundException.class);
    rebuildHandler.apply(parseChangeResource(r.getChangeId()), new Input());
}
#end_block

#method_before
@Test
public void rebuildViaRestApi() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    setNotesMigration(true, false);
    checker.assertNoChangeRef(project, id);
    rebuildHandler.apply(parseChangeResource(r.getChangeId()), new Rebuild.Input());
    checker.checkChanges(id);
}
#method_after
@Test
public void rebuildViaRestApi() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    setNotesMigration(true, false);
    checker.assertNoChangeRef(project, id);
    rebuildHandler.apply(parseChangeResource(r.getChangeId()), new Input());
    checker.checkChanges(id);
}
#end_block

#method_before
@Test
public void rebuilderRespectsReadOnlyInNoteDbChangeState() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    PatchSet.Id psId1 = r.getPatchSetId();
    Change.Id id = psId1.getParentKey();
    checker.rebuildAndCheckChanges(id);
    setNotesMigration(true, true);
    ReviewDb db = getUnwrappedDb();
    Change c = db.changes().get(id);
    NoteDbChangeState state = NoteDbChangeState.parse(c);
    Timestamp until = new Timestamp(TimeUtil.nowMs() + MILLISECONDS.convert(1, DAYS));
    state = state.withReadOnlyUntil(until);
    c.setNoteDbState(state.toString());
    db.changes().update(Collections.singleton(c));
    try {
        rebuilderWrapper.rebuild(db, id);
        assert_().fail("expected rebuild to fail");
    } catch (OrmRuntimeException e) {
        assertThat(e.getMessage()).contains("read-only until");
    }
    TestTimeUtil.setClock(new Timestamp(until.getTime() + MILLISECONDS.convert(1, SECONDS)));
    rebuilderWrapper.rebuild(db, id);
}
#method_after
@Test
public void rebuilderRespectsReadOnlyInNoteDbChangeState() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    PatchSet.Id psId1 = r.getPatchSetId();
    Change.Id id = psId1.getParentKey();
    checker.rebuildAndCheckChanges(id);
    setNotesMigration(true, true);
    ReviewDb db = getUnwrappedDb();
    Change c = db.changes().get(id);
    NoteDbChangeState state = NoteDbChangeState.parse(c);
    Timestamp until = new Timestamp(TimeUtil.nowMs() + MILLISECONDS.convert(1, DAYS));
    state = state.withReadOnlyUntil(until);
    c.setNoteDbState(state.toString());
    db.changes().update(Collections.singleton(c));
    try {
        rebuilderWrapper.rebuild(db, id);
        fail("expected rebuild to fail");
    } catch (OrmRuntimeException e) {
        assertThat(e.getMessage()).contains("read-only until");
    }
    TestTimeUtil.setClock(new Timestamp(until.getTime() + MILLISECONDS.convert(1, SECONDS)));
    rebuilderWrapper.rebuild(db, id);
}
#end_block

#method_before
@Test
public void publishEdit() throws Exception {
    createArbitraryEditFor(changeId);
    PublishChangeEditInput publishInput = new PublishChangeEditInput();
    publishInput.notify = NotifyHandling.NONE;
    gApi.changes().id(changeId).edit().publish(publishInput);
    assertThat(getEdit(changeId)).isAbsent();
    assertChangeMessages(changeId, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch Set 3: Published edit on patch set 2."));
    // The tag for the publish edit change message should vary according
    // to whether the change was WIP at the time of publishing.
    ChangeInfo info = get(changeId);
    assertThat(info.messages).isNotEmpty();
    assertThat(Iterables.getLast(info.messages).tag).isEqualTo(ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
    // Move the change to WIP, repeat, and verify.
    gApi.changes().id(changeId).setWorkInProgress();
    createEmptyEditFor(changeId);
    gApi.changes().id(changeId).edit().modifyFile(FILE_NAME, RawInputUtil.create(CONTENT_NEW2));
    gApi.changes().id(changeId).edit().publish();
    info = get(changeId);
    assertThat(info.messages).isNotEmpty();
    assertThat(Iterables.getLast(info.messages).tag).isEqualTo(ChangeMessagesUtil.TAG_UPLOADED_WIP_PATCH_SET);
}
#method_after
@Test
public void publishEdit() throws Exception {
    createArbitraryEditFor(changeId);
    PublishChangeEditInput publishInput = new PublishChangeEditInput();
    publishInput.notify = NotifyHandling.NONE;
    gApi.changes().id(changeId).edit().publish(publishInput);
    assertThat(getEdit(changeId)).isAbsent();
    assertChangeMessages(changeId, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch Set 3: Published edit on patch set 2."));
    // The tag for the publish edit change message should vary according
    // to whether the change was WIP at the time of publishing.
    ChangeInfo info = get(changeId, MESSAGES);
    assertThat(info.messages).isNotEmpty();
    assertThat(Iterables.getLast(info.messages).tag).isEqualTo(ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
    // Move the change to WIP, repeat, and verify.
    gApi.changes().id(changeId).setWorkInProgress();
    createEmptyEditFor(changeId);
    gApi.changes().id(changeId).edit().modifyFile(FILE_NAME, RawInputUtil.create(CONTENT_NEW2));
    gApi.changes().id(changeId).edit().publish();
    info = get(changeId, MESSAGES);
    assertThat(info.messages).isNotEmpty();
    assertThat(Iterables.getLast(info.messages).tag).isEqualTo(ChangeMessagesUtil.TAG_UPLOADED_WIP_PATCH_SET);
}
#end_block

#method_before
@Test
public void retrieveEdit() throws Exception {
    adminRestSession.get(urlEdit(changeId)).assertNoContent();
    createArbitraryEditFor(changeId);
    EditInfo editInfo = getEditInfo(changeId, false);
    ChangeInfo changeInfo = get(changeId);
    assertThat(editInfo.commit.commit).isNotEqualTo(changeInfo.currentRevision);
    assertThat(editInfo).commit().parents().hasSize(1);
    assertThat(editInfo).baseRevision().isEqualTo(changeInfo.currentRevision);
    gApi.changes().id(changeId).edit().delete();
    adminRestSession.get(urlEdit(changeId)).assertNoContent();
}
#method_after
@Test
public void retrieveEdit() throws Exception {
    adminRestSession.get(urlEdit(changeId)).assertNoContent();
    createArbitraryEditFor(changeId);
    EditInfo editInfo = getEditInfo(changeId, false);
    ChangeInfo changeInfo = get(changeId, CURRENT_REVISION, CURRENT_COMMIT);
    assertThat(editInfo.commit.commit).isNotEqualTo(changeInfo.currentRevision);
    assertThat(editInfo).commit().parents().hasSize(1);
    assertThat(editInfo).baseRevision().isEqualTo(changeInfo.currentRevision);
    gApi.changes().id(changeId).edit().delete();
    adminRestSession.get(urlEdit(changeId)).assertNoContent();
}
#end_block

#method_before
@Test
public void editCommitMessageCopiesLabelScores() throws Exception {
    String cr = "Code-Review";
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType codeReview = Util.codeReview();
    codeReview.setCopyAllScoresIfNoCodeChange(true);
    cfg.getLabelSections().put(cr, codeReview);
    saveProjectConfig(project, cfg);
    ReviewInput r = new ReviewInput();
    r.labels = ImmutableMap.of(cr, (short) 1);
    gApi.changes().id(changeId).current().review(r);
    createEmptyEditFor(changeId);
    String newSubj = "New commit message";
    String newMsg = newSubj + "\n\nChange-Id: " + changeId + "\n";
    gApi.changes().id(changeId).edit().modifyCommitMessage(newMsg);
    PublishChangeEditInput publishInput = new PublishChangeEditInput();
    publishInput.notify = NotifyHandling.NONE;
    gApi.changes().id(changeId).edit().publish(publishInput);
    ChangeInfo info = get(changeId);
    assertThat(info.subject).isEqualTo(newSubj);
    List<ApprovalInfo> approvals = info.labels.get(cr).all;
    assertThat(approvals).hasSize(1);
    assertThat(approvals.get(0).value).isEqualTo(1);
}
#method_after
@Test
public void editCommitMessageCopiesLabelScores() throws Exception {
    String cr = "Code-Review";
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType codeReview = Util.codeReview();
    codeReview.setCopyAllScoresIfNoCodeChange(true);
    cfg.getLabelSections().put(cr, codeReview);
    saveProjectConfig(project, cfg);
    ReviewInput r = new ReviewInput();
    r.labels = ImmutableMap.of(cr, (short) 1);
    gApi.changes().id(changeId).current().review(r);
    createEmptyEditFor(changeId);
    String newSubj = "New commit message";
    String newMsg = newSubj + "\n\nChange-Id: " + changeId + "\n";
    gApi.changes().id(changeId).edit().modifyCommitMessage(newMsg);
    PublishChangeEditInput publishInput = new PublishChangeEditInput();
    publishInput.notify = NotifyHandling.NONE;
    gApi.changes().id(changeId).edit().publish(publishInput);
    ChangeInfo info = get(changeId, DETAILED_LABELS);
    assertThat(info.subject).isEqualTo(newSubj);
    List<ApprovalInfo> approvals = info.labels.get(cr).all;
    assertThat(approvals).hasSize(1);
    assertThat(approvals.get(0).value).isEqualTo(1);
}
#end_block

#method_before
private void assertChangeMessages(String changeId, List<String> expectedMessages) throws Exception {
    ChangeInfo ci = get(changeId);
    assertThat(ci.messages).isNotNull();
    assertThat(ci.messages).hasSize(expectedMessages.size());
    List<String> actualMessages = ci.messages.stream().map(message -> message.message).collect(toList());
    assertThat(actualMessages).containsExactlyElementsIn(expectedMessages).inOrder();
}
#method_after
private void assertChangeMessages(String changeId, List<String> expectedMessages) throws Exception {
    ChangeInfo ci = get(changeId, MESSAGES);
    assertThat(ci.messages).isNotNull();
    assertThat(ci.messages).hasSize(expectedMessages.size());
    List<String> actualMessages = ci.messages.stream().map(message -> message.message).collect(toList());
    assertThat(actualMessages).containsExactlyElementsIn(expectedMessages).inOrder();
}
#end_block

#method_before
private void setUp() throws Exception {
    injector = Guice.createInjector(new InMemoryModule());
    injector.injectMembers(this);
    lifecycle = new LifecycleManager();
    lifecycle.add(injector);
    lifecycle.start();
    try (ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) {
        schemaCreator.create(underlyingDb);
    }
    db = schemaFactory.open();
    Account.Id userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    IdentifiedUser user = userFactory.create(userId);
    requestContext.setContext(new RequestContext() {

        @Override
        public CurrentUser getUser() {
            return user;
        }

        @Override
        public Provider<ReviewDb> getReviewDbProvider() {
            return Providers.of(db);
        }
    });
}
#method_after
private void setUp() throws Exception {
    injector = Guice.createInjector(new InMemoryModule());
    injector.injectMembers(this);
    lifecycle = new LifecycleManager();
    lifecycle.add(injector);
    lifecycle.start();
    try (ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) {
        schemaCreator.create(underlyingDb);
    }
    db = schemaFactory.open();
    setApiUser(accountManager.authenticate(AuthRequest.forUser("user")).getAccountId());
}
#end_block

#method_before
protected void beforeTest(Description description) throws Exception {
    this.description = description;
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.initAndStart(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.initAndStart(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    // As a workaround, we simply reindex all available groups here.
    for (AccountGroup group : groupCache.all()) {
        groupCache.evict(group.getGroupUUID(), group.getId(), group.getNameKey());
    }
    admin = accountCreator.admin();
    user = accountCreator.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    db = reviewDbProvider.open();
    testRequiresSsh = classDesc.useSshAnnotation() || methodDesc.useSshAnnotation();
    if (testRequiresSsh && SshMode.useSsh() && (adminSshSession == null || userSshSession == null)) {
        // Create Ssh sessions
        initSsh(admin);
        Context ctx = newRequestContext(user);
        atrScope.set(ctx);
        userSshSession = ctx.getSession();
        userSshSession.open();
        ctx = newRequestContext(admin);
        atrScope.set(ctx);
        adminSshSession = ctx.getSession();
        adminSshSession.open();
    }
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#method_after
protected void beforeTest(Description description) throws Exception {
    this.description = description;
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.initAndStart(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.initAndStart(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    db = reviewDbProvider.open();
    // All groups which were added during the server start (e.g. in SchemaCreator) aren't contained
    // in the instance of the group index which is available here and in tests. There are two
    // reasons:
    // 1) No group index is available in SchemaCreator when using an in-memory database. (This could
    // be fixed by using the IndexManagerOnInit in InMemoryDatabase similar as BaseInit uses it.)
    // 2) During the on-init part of the server start, we use another instance of the index than
    // later on. As test indexes are non-permanent, closing an instance and opening another one
    // removes all indexed data.
    // As a workaround, we simply reindex all available groups here.
    Iterable<AccountGroup.UUID> allGroupUuids = groups.getAllUuids(db)::iterator;
    for (AccountGroup.UUID groupUuid : allGroupUuids) {
        groupCache.onCreateGroup(groupUuid);
    }
    admin = accountCreator.admin();
    user = accountCreator.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    testRequiresSsh = classDesc.useSshAnnotation() || methodDesc.useSshAnnotation();
    if (testRequiresSsh && SshMode.useSsh() && (adminSshSession == null || userSshSession == null)) {
        // Create Ssh sessions
        initSsh(admin);
        Context ctx = newRequestContext(user);
        atrScope.set(ctx);
        userSshSession = ctx.getSession();
        userSshSession.open();
        ctx = newRequestContext(admin);
        atrScope.set(ctx);
        adminSshSession = ctx.getSession();
        adminSshSession.open();
    }
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#end_block

#method_before
protected BranchApi createBranch(Branch.NameKey branch) throws Exception {
    return gApi.projects().name(branch.getParentKey().get()).branch(branch.get()).create(new BranchInput());
}
#method_after
protected BranchApi createBranch(String branch) throws Exception {
    return createBranch(new Branch.NameKey(project, branch));
}
#end_block

#method_before
protected void grant(Project.NameKey project, String ref, String permission, boolean force) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    AccountGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators"));
    grant(project, ref, permission, force, adminGroup.getGroupUUID());
}
#method_after
protected void grant(Project.NameKey project, String ref, String permission, boolean force) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    InternalGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null);
    grant(project, ref, permission, force, adminGroup.getGroupUUID());
}
#end_block

#method_before
protected void assertSubmittedTogether(String chId, String... expected) throws Exception {
    List<ChangeInfo> actual = gApi.changes().id(chId).submittedTogether();
    SubmittedTogetherInfo info = gApi.changes().id(chId).submittedTogether(EnumSet.of(NON_VISIBLE_CHANGES));
    assertThat(info.nonVisibleChanges).isEqualTo(0);
    assertThat(actual).hasSize(expected.length);
    assertThat(changeIds(actual)).containsExactly((Object[]) expected).inOrder();
    assertThat(changeIds(info.changes)).containsExactly((Object[]) expected).inOrder();
}
#method_after
protected void assertSubmittedTogether(String chId, String... expected) throws Exception {
    List<ChangeInfo> actual = gApi.changes().id(chId).submittedTogether();
    SubmittedTogetherInfo info = gApi.changes().id(chId).submittedTogether(EnumSet.of(NON_VISIBLE_CHANGES));
    assertThat(info.nonVisibleChanges).isEqualTo(0);
    assertThat(changeIds(actual)).containsExactly((Object[]) expected).inOrder();
    assertThat(changeIds(info.changes)).containsExactly((Object[]) expected).inOrder();
}
#end_block

#method_before
@Test
public void create() throws Exception {
    // account creation + external ID creation
    create(2);
}
#method_after
@Test
public void create() throws Exception {
    // account creation + external ID creation
    Account.Id accountId = create(2);
    refUpdateCounter.assertRefUpdateFor(RefUpdateCounter.projectRef(allUsers, RefNames.refsUsers(accountId)), RefUpdateCounter.projectRef(allUsers, RefNames.REFS_EXTERNAL_IDS), RefUpdateCounter.projectRef(allUsers, RefNames.REFS_SEQUENCES + Sequences.NAME_ACCOUNTS));
}
#end_block

#method_before
@Test
@UseSsh
public void createWithSshKeys() throws Exception {
    // account creation + external ID creation + adding SSH keys
    create(3);
}
#method_after
@Test
@UseSsh
public void createWithSshKeys() throws Exception {
    // account creation + external ID creation + adding SSH keys
    Account.Id accountId = create(3);
    refUpdateCounter.assertRefUpdateFor(ImmutableMap.of(RefUpdateCounter.projectRef(allUsers, RefNames.refsUsers(accountId)), 2, RefUpdateCounter.projectRef(allUsers, RefNames.REFS_EXTERNAL_IDS), 1, RefUpdateCounter.projectRef(allUsers, RefNames.REFS_SEQUENCES + Sequences.NAME_ACCOUNTS), 1));
}
#end_block

#method_before
private void create(int expectedAccountReindexCalls) throws Exception {
    String name = "foo";
    TestAccount foo = accountCreator.create(name);
    AccountInfo info = gApi.accounts().id(foo.id.get()).get();
    assertThat(info.username).isEqualTo(name);
    assertThat(info.name).isEqualTo(name);
    accountIndexedCounter.assertReindexOf(foo, expectedAccountReindexCalls);
    assertUserBranch(foo.getId(), name, null);
}
#method_after
private Account.Id create(int expectedAccountReindexCalls) throws Exception {
    String name = "foo";
    TestAccount foo = accountCreator.create(name);
    AccountInfo info = gApi.accounts().id(foo.id.get()).get();
    assertThat(info.username).isEqualTo(name);
    assertThat(info.name).isEqualTo(name);
    accountIndexedCounter.assertReindexOf(foo, expectedAccountReindexCalls);
    assertUserBranch(foo.getId(), name, null);
    return foo.getId();
}
#end_block

#method_before
@Test
public void starUnstarChange() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.accounts().self().starChange(triplet);
    ChangeInfo change = info(triplet);
    assertThat(change.starred).isTrue();
    assertThat(change.stars).contains(DEFAULT_LABEL);
    gApi.accounts().self().unstarChange(triplet);
    change = info(triplet);
    assertThat(change.starred).isNull();
    assertThat(change.stars).isNull();
    accountIndexedCounter.assertNoReindex();
}
#method_after
@Test
public void starUnstarChange() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    refUpdateCounter.clear();
    gApi.accounts().self().starChange(triplet);
    ChangeInfo change = info(triplet);
    assertThat(change.starred).isTrue();
    assertThat(change.stars).contains(DEFAULT_LABEL);
    refUpdateCounter.assertRefUpdateFor(RefUpdateCounter.projectRef(allUsers, RefNames.refsStarredChanges(new Change.Id(change._number), admin.id)));
    gApi.accounts().self().unstarChange(triplet);
    change = info(triplet);
    assertThat(change.starred).isNull();
    assertThat(change.stars).isNull();
    refUpdateCounter.assertRefUpdateFor(RefUpdateCounter.projectRef(allUsers, RefNames.refsStarredChanges(new Change.Id(change._number), admin.id)));
    accountIndexedCounter.assertNoReindex();
}
#end_block

#method_before
@Test
public void starUnstarChangeWithLabels() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    assertThat(gApi.accounts().self().getStars(triplet)).isEmpty();
    assertThat(gApi.accounts().self().getStarredChanges()).isEmpty();
    gApi.accounts().self().setStars(triplet, new StarsInput(ImmutableSet.of(DEFAULT_LABEL, "red", "blue")));
    ChangeInfo change = info(triplet);
    assertThat(change.starred).isTrue();
    assertThat(change.stars).containsExactly("blue", "red", DEFAULT_LABEL).inOrder();
    assertThat(gApi.accounts().self().getStars(triplet)).containsExactly("blue", "red", DEFAULT_LABEL).inOrder();
    List<ChangeInfo> starredChanges = gApi.accounts().self().getStarredChanges();
    assertThat(starredChanges).hasSize(1);
    ChangeInfo starredChange = starredChanges.get(0);
    assertThat(starredChange._number).isEqualTo(r.getChange().getId().get());
    assertThat(starredChange.starred).isTrue();
    assertThat(starredChange.stars).containsExactly("blue", "red", DEFAULT_LABEL).inOrder();
    gApi.accounts().self().setStars(triplet, new StarsInput(ImmutableSet.of("yellow"), ImmutableSet.of(DEFAULT_LABEL, "blue")));
    change = info(triplet);
    assertThat(change.starred).isNull();
    assertThat(change.stars).containsExactly("red", "yellow").inOrder();
    assertThat(gApi.accounts().self().getStars(triplet)).containsExactly("red", "yellow").inOrder();
    starredChanges = gApi.accounts().self().getStarredChanges();
    assertThat(starredChanges).hasSize(1);
    starredChange = starredChanges.get(0);
    assertThat(starredChange._number).isEqualTo(r.getChange().getId().get());
    assertThat(starredChange.starred).isNull();
    assertThat(starredChange.stars).containsExactly("red", "yellow").inOrder();
    accountIndexedCounter.assertNoReindex();
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("not allowed to get stars of another account");
    gApi.accounts().id(Integer.toString((admin.id.get()))).getStars(triplet);
}
#method_after
@Test
public void starUnstarChangeWithLabels() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    refUpdateCounter.clear();
    assertThat(gApi.accounts().self().getStars(triplet)).isEmpty();
    assertThat(gApi.accounts().self().getStarredChanges()).isEmpty();
    gApi.accounts().self().setStars(triplet, new StarsInput(ImmutableSet.of(DEFAULT_LABEL, "red", "blue")));
    ChangeInfo change = info(triplet);
    assertThat(change.starred).isTrue();
    assertThat(change.stars).containsExactly("blue", "red", DEFAULT_LABEL).inOrder();
    assertThat(gApi.accounts().self().getStars(triplet)).containsExactly("blue", "red", DEFAULT_LABEL).inOrder();
    List<ChangeInfo> starredChanges = gApi.accounts().self().getStarredChanges();
    assertThat(starredChanges).hasSize(1);
    ChangeInfo starredChange = starredChanges.get(0);
    assertThat(starredChange._number).isEqualTo(r.getChange().getId().get());
    assertThat(starredChange.starred).isTrue();
    assertThat(starredChange.stars).containsExactly("blue", "red", DEFAULT_LABEL).inOrder();
    refUpdateCounter.assertRefUpdateFor(RefUpdateCounter.projectRef(allUsers, RefNames.refsStarredChanges(new Change.Id(change._number), admin.id)));
    gApi.accounts().self().setStars(triplet, new StarsInput(ImmutableSet.of("yellow"), ImmutableSet.of(DEFAULT_LABEL, "blue")));
    change = info(triplet);
    assertThat(change.starred).isNull();
    assertThat(change.stars).containsExactly("red", "yellow").inOrder();
    assertThat(gApi.accounts().self().getStars(triplet)).containsExactly("red", "yellow").inOrder();
    starredChanges = gApi.accounts().self().getStarredChanges();
    assertThat(starredChanges).hasSize(1);
    starredChange = starredChanges.get(0);
    assertThat(starredChange._number).isEqualTo(r.getChange().getId().get());
    assertThat(starredChange.starred).isNull();
    assertThat(starredChange.stars).containsExactly("red", "yellow").inOrder();
    refUpdateCounter.assertRefUpdateFor(RefUpdateCounter.projectRef(allUsers, RefNames.refsStarredChanges(new Change.Id(change._number), admin.id)));
    accountIndexedCounter.assertNoReindex();
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("not allowed to get stars of another account");
    gApi.accounts().id(Integer.toString((admin.id.get()))).getStars(triplet);
}
#end_block

#method_before
@Test
@Sandboxed
public void fetchUserBranch() throws Exception {
    setApiUser(user);
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers, user);
    String userRefName = RefNames.refsUsers(user.id);
    // remove default READ permissions
    ProjectConfig cfg = projectCache.checkedGet(allUsers).getConfig();
    cfg.getAccessSection(RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", true).remove(new Permission(Permission.READ));
    saveProjectConfig(allUsers, cfg);
    // deny READ permission that is inherited from All-Projects
    deny(allUsers, RefNames.REFS + "*", Permission.READ, ANONYMOUS_USERS);
    // fetching user branch without READ permission fails
    try {
        fetch(allUsersRepo, userRefName + ":userRef");
        Assert.fail("user branch is visible although no READ permission is granted");
    } catch (TransportException e) {
    // expected because no READ granted on user branch
    }
    // allow each user to read its own user branch
    grant(allUsers, RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", Permission.READ, false, REGISTERED_USERS);
    // fetch user branch using refs/users/YY/XXXXXXX
    fetch(allUsersRepo, userRefName + ":userRef");
    Ref userRef = allUsersRepo.getRepository().exactRef("userRef");
    assertThat(userRef).isNotNull();
    // fetch user branch using refs/users/self
    fetch(allUsersRepo, RefNames.REFS_USERS_SELF + ":userSelfRef");
    Ref userSelfRef = allUsersRepo.getRepository().getRefDatabase().exactRef("userSelfRef");
    assertThat(userSelfRef).isNotNull();
    assertThat(userSelfRef.getObjectId()).isEqualTo(userRef.getObjectId());
    accountIndexedCounter.assertNoReindex();
    // fetching user branch of another user fails
    String otherUserRefName = RefNames.refsUsers(admin.id);
    exception.expect(TransportException.class);
    exception.expectMessage("Remote does not have " + otherUserRefName + " available for fetch.");
    fetch(allUsersRepo, otherUserRefName + ":otherUserRef");
}
#method_after
@Test
@Sandboxed
public void fetchUserBranch() throws Exception {
    setApiUser(user);
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers, user);
    String userRefName = RefNames.refsUsers(user.id);
    // remove default READ permissions
    ProjectConfig cfg = projectCache.checkedGet(allUsers).getConfig();
    cfg.getAccessSection(RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", true).remove(new Permission(Permission.READ));
    saveProjectConfig(allUsers, cfg);
    // deny READ permission that is inherited from All-Projects
    deny(allUsers, RefNames.REFS + "*", Permission.READ, ANONYMOUS_USERS);
    // fetching user branch without READ permission fails
    try {
        fetch(allUsersRepo, userRefName + ":userRef");
        fail("user branch is visible although no READ permission is granted");
    } catch (TransportException e) {
    // expected because no READ granted on user branch
    }
    // allow each user to read its own user branch
    grant(allUsers, RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", Permission.READ, false, REGISTERED_USERS);
    // fetch user branch using refs/users/YY/XXXXXXX
    fetch(allUsersRepo, userRefName + ":userRef");
    Ref userRef = allUsersRepo.getRepository().exactRef("userRef");
    assertThat(userRef).isNotNull();
    // fetch user branch using refs/users/self
    fetch(allUsersRepo, RefNames.REFS_USERS_SELF + ":userSelfRef");
    Ref userSelfRef = allUsersRepo.getRepository().getRefDatabase().exactRef("userSelfRef");
    assertThat(userSelfRef).isNotNull();
    assertThat(userSelfRef.getObjectId()).isEqualTo(userRef.getObjectId());
    accountIndexedCounter.assertNoReindex();
    // fetching user branch of another user fails
    String otherUserRefName = RefNames.refsUsers(admin.id);
    exception.expect(TransportException.class);
    exception.expectMessage("Remote does not have " + otherUserRefName + " available for fetch.");
    fetch(allUsersRepo, otherUserRefName + ":otherUserRef");
}
#end_block

#method_before
@Test
public void pushAccountConfigToUserBranchForReviewDeactivateOtherAccount() throws Exception {
    TestAccount foo = accountCreator.create(name("foo"));
    assertThat(gApi.accounts().id(foo.id.get()).getActive()).isTrue();
    String userRef = RefNames.refsUsers(foo.id);
    accountIndexedCounter.clear();
    AccountGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators"));
    grant(allUsers, userRef, Permission.PUSH, false, adminGroup.getGroupUUID());
    grantLabel("Code-Review", -2, 2, allUsers, userRef, false, adminGroup.getGroupUUID(), false);
    grant(allUsers, userRef, Permission.SUBMIT, false, adminGroup.getGroupUUID());
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, userRef + ":userRef");
    allUsersRepo.reset("userRef");
    Config ac = getAccountConfig(allUsersRepo);
    ac.setBoolean(AccountConfig.ACCOUNT, null, AccountConfig.KEY_ACTIVE, false);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(MagicBranch.NEW_CHANGE + userRef);
    r.assertOkStatus();
    accountIndexedCounter.assertNoReindex();
    assertThat(r.getChange().change().getDest().get()).isEqualTo(userRef);
    gApi.changes().id(r.getChangeId()).current().review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).current().submit();
    accountIndexedCounter.assertReindexOf(foo);
    assertThat(gApi.accounts().id(foo.id.get()).getActive()).isFalse();
}
#method_after
@Test
public void pushAccountConfigToUserBranchForReviewDeactivateOtherAccount() throws Exception {
    TestAccount foo = accountCreator.create(name("foo"));
    assertThat(gApi.accounts().id(foo.id.get()).getActive()).isTrue();
    String userRef = RefNames.refsUsers(foo.id);
    accountIndexedCounter.clear();
    InternalGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null);
    grant(allUsers, userRef, Permission.PUSH, false, adminGroup.getGroupUUID());
    grantLabel("Code-Review", -2, 2, allUsers, userRef, false, adminGroup.getGroupUUID(), false);
    grant(allUsers, userRef, Permission.SUBMIT, false, adminGroup.getGroupUUID());
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, userRef + ":userRef");
    allUsersRepo.reset("userRef");
    Config ac = getAccountConfig(allUsersRepo);
    ac.setBoolean(AccountConfig.ACCOUNT, null, AccountConfig.KEY_ACTIVE, false);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(MagicBranch.NEW_CHANGE + userRef);
    r.assertOkStatus();
    accountIndexedCounter.assertNoReindex();
    assertThat(r.getChange().change().getDest().get()).isEqualTo(userRef);
    gApi.changes().id(r.getChangeId()).current().review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).current().submit();
    accountIndexedCounter.assertReindexOf(foo);
    assertThat(gApi.accounts().id(foo.id.get()).getActive()).isFalse();
}
#end_block

#method_before
@Test
public void pushAccountConfigToUserBranchInvalidPreferredEmailButNotChanged() throws Exception {
    TestAccount foo = accountCreator.create(name("foo"));
    String userRef = RefNames.refsUsers(foo.id);
    String noEmail = "no.email";
    accountsUpdate.create().update(foo.id, a -> a.setPreferredEmail(noEmail));
    accountIndexedCounter.clear();
    AccountGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators"));
    grant(allUsers, userRef, Permission.PUSH, false, adminGroup.getGroupUUID());
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, userRef + ":userRef");
    allUsersRepo.reset("userRef");
    String status = "in vacation";
    Config ac = getAccountConfig(allUsersRepo);
    ac.setString(AccountConfig.ACCOUNT, null, AccountConfig.KEY_STATUS, status);
    pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(userRef).assertOkStatus();
    accountIndexedCounter.assertReindexOf(foo);
    AccountInfo info = gApi.accounts().id(foo.id.get()).get();
    assertThat(info.email).isEqualTo(noEmail);
    assertThat(info.name).isEqualTo(foo.fullName);
    assertThat(info.status).isEqualTo(status);
}
#method_after
@Test
public void pushAccountConfigToUserBranchInvalidPreferredEmailButNotChanged() throws Exception {
    TestAccount foo = accountCreator.create(name("foo"));
    String userRef = RefNames.refsUsers(foo.id);
    String noEmail = "no.email";
    accountsUpdate.create().update(foo.id, a -> a.setPreferredEmail(noEmail));
    accountIndexedCounter.clear();
    InternalGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null);
    grant(allUsers, userRef, Permission.PUSH, false, adminGroup.getGroupUUID());
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, userRef + ":userRef");
    allUsersRepo.reset("userRef");
    String status = "in vacation";
    Config ac = getAccountConfig(allUsersRepo);
    ac.setString(AccountConfig.ACCOUNT, null, AccountConfig.KEY_STATUS, status);
    pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(userRef).assertOkStatus();
    accountIndexedCounter.assertReindexOf(foo);
    AccountInfo info = gApi.accounts().id(foo.id.get()).get();
    assertThat(info.email).isEqualTo(noEmail);
    assertThat(info.name).isEqualTo(foo.fullName);
    assertThat(info.status).isEqualTo(status);
}
#end_block

#method_before
@Test
public void pushAccountConfigToUserBranchIfPreferredEmailDoesNotExistAsExtId() throws Exception {
    TestAccount foo = accountCreator.create(name("foo"));
    String userRef = RefNames.refsUsers(foo.id);
    accountIndexedCounter.clear();
    AccountGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators"));
    grant(allUsers, userRef, Permission.PUSH, false, adminGroup.getGroupUUID());
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, userRef + ":userRef");
    allUsersRepo.reset("userRef");
    String email = "some.email@example.com";
    Config ac = getAccountConfig(allUsersRepo);
    ac.setString(AccountConfig.ACCOUNT, null, AccountConfig.KEY_PREFERRED_EMAIL, email);
    pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(userRef).assertOkStatus();
    accountIndexedCounter.assertReindexOf(foo);
    AccountInfo info = gApi.accounts().id(foo.id.get()).get();
    assertThat(info.email).isEqualTo(email);
    assertThat(info.name).isEqualTo(foo.fullName);
}
#method_after
@Test
public void pushAccountConfigToUserBranchIfPreferredEmailDoesNotExistAsExtId() throws Exception {
    TestAccount foo = accountCreator.create(name("foo"));
    String userRef = RefNames.refsUsers(foo.id);
    accountIndexedCounter.clear();
    InternalGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null);
    grant(allUsers, userRef, Permission.PUSH, false, adminGroup.getGroupUUID());
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, userRef + ":userRef");
    allUsersRepo.reset("userRef");
    String email = "some.email@example.com";
    Config ac = getAccountConfig(allUsersRepo);
    ac.setString(AccountConfig.ACCOUNT, null, AccountConfig.KEY_PREFERRED_EMAIL, email);
    pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(userRef).assertOkStatus();
    accountIndexedCounter.assertReindexOf(foo);
    AccountInfo info = gApi.accounts().id(foo.id.get()).get();
    assertThat(info.email).isEqualTo(email);
    assertThat(info.name).isEqualTo(foo.fullName);
}
#end_block

#method_before
@Test
public void pushAccountConfigToUserBranchDeactivateOtherAccount() throws Exception {
    TestAccount foo = accountCreator.create(name("foo"));
    assertThat(gApi.accounts().id(foo.id.get()).getActive()).isTrue();
    String userRef = RefNames.refsUsers(foo.id);
    accountIndexedCounter.clear();
    AccountGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators"));
    grant(allUsers, userRef, Permission.PUSH, false, adminGroup.getGroupUUID());
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, userRef + ":userRef");
    allUsersRepo.reset("userRef");
    Config ac = getAccountConfig(allUsersRepo);
    ac.setBoolean(AccountConfig.ACCOUNT, null, AccountConfig.KEY_ACTIVE, false);
    pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(userRef).assertOkStatus();
    accountIndexedCounter.assertReindexOf(foo);
    assertThat(gApi.accounts().id(foo.id.get()).getActive()).isFalse();
}
#method_after
@Test
public void pushAccountConfigToUserBranchDeactivateOtherAccount() throws Exception {
    TestAccount foo = accountCreator.create(name("foo"));
    assertThat(gApi.accounts().id(foo.id.get()).getActive()).isTrue();
    String userRef = RefNames.refsUsers(foo.id);
    accountIndexedCounter.clear();
    InternalGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null);
    grant(allUsers, userRef, Permission.PUSH, false, adminGroup.getGroupUUID());
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, userRef + ":userRef");
    allUsersRepo.reset("userRef");
    Config ac = getAccountConfig(allUsersRepo);
    ac.setBoolean(AccountConfig.ACCOUNT, null, AccountConfig.KEY_ACTIVE, false);
    pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(userRef).assertOkStatus();
    accountIndexedCounter.assertReindexOf(foo);
    assertThat(gApi.accounts().id(foo.id.get()).getActive()).isFalse();
}
#end_block

#method_before
private ChangeInfo assertCreateSucceeds(ChangeInput in) throws Exception {
    ChangeInfo out = gApi.changes().create(in).get();
    assertThat(out.project).isEqualTo(in.project);
    assertThat(out.branch).isEqualTo(in.branch);
    assertThat(out.subject).isEqualTo(in.subject);
    assertThat(out.topic).isEqualTo(in.topic);
    assertThat(out.status).isEqualTo(in.status);
    assertThat(out.isPrivate).isEqualTo(in.isPrivate);
    assertThat(out.workInProgress).isEqualTo(in.workInProgress);
    assertThat(out.revisions).hasSize(1);
    assertThat(out.submitted).isNull();
    assertThat(out.submitter).isNull();
    Boolean draft = Iterables.getOnlyElement(out.revisions.values()).draft;
    assertThat(booleanToDraftStatus(draft)).isEqualTo(in.status);
    return out;
}
#method_after
private ChangeInfo assertCreateSucceeds(ChangeInput in) throws Exception {
    ChangeInfo out = gApi.changes().create(in).get();
    assertThat(out.project).isEqualTo(in.project);
    assertThat(out.branch).isEqualTo(in.branch);
    assertThat(out.subject).isEqualTo(in.subject);
    assertThat(out.topic).isEqualTo(in.topic);
    assertThat(out.status).isEqualTo(in.status);
    assertThat(out.isPrivate).isEqualTo(in.isPrivate);
    assertThat(out.workInProgress).isEqualTo(in.workInProgress);
    assertThat(out.revisions).hasSize(1);
    assertThat(out.submitted).isNull();
    assertThat(in.status).isEqualTo(ChangeStatus.NEW);
    return out;
}
#end_block

#method_before
@Test
public void pushForMasterWithMessage() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%m=my_test_message");
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, null);
    ChangeInfo ci = get(r.getChangeId());
    Collection<ChangeMessageInfo> changeMessages = ci.messages;
    assertThat(changeMessages).hasSize(1);
    for (ChangeMessageInfo cm : changeMessages) {
        assertThat(cm.message).isEqualTo("Uploaded patch set 1.\nmy test message");
    }
    Collection<RevisionInfo> revisions = ci.revisions.values();
    assertThat(revisions).hasSize(1);
    for (RevisionInfo ri : revisions) {
        assertThat(ri.description).isEqualTo("my test message");
    }
}
#method_after
@Test
public void pushForMasterWithMessage() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%m=my_test_message");
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, null);
    ChangeInfo ci = get(r.getChangeId(), MESSAGES, ALL_REVISIONS);
    Collection<ChangeMessageInfo> changeMessages = ci.messages;
    assertThat(changeMessages).hasSize(1);
    for (ChangeMessageInfo cm : changeMessages) {
        assertThat(cm.message).isEqualTo("Uploaded patch set 1.\nmy test message");
    }
    Collection<RevisionInfo> revisions = ci.revisions.values();
    assertThat(revisions).hasSize(1);
    for (RevisionInfo ri : revisions) {
        assertThat(ri.description).isEqualTo("my test message");
    }
}
#end_block

#method_before
@Test
public void pushForMasterWithMessageTwiceWithDifferentMessages() throws Exception {
    enableCreateNewChangeForAllNotInTarget();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content");
    PushOneCommit.Result r = push.to("refs/for/master/%m=my_test_message");
    r.assertOkStatus();
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%m=new_test_message");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId());
    Collection<RevisionInfo> revisions = ci.revisions.values();
    assertThat(revisions).hasSize(2);
    for (RevisionInfo ri : revisions) {
        if (ri.isCurrent) {
            assertThat(ri.description).isEqualTo("new test message");
        } else {
            assertThat(ri.description).isEqualTo("my test message");
        }
    }
}
#method_after
@Test
public void pushForMasterWithMessageTwiceWithDifferentMessages() throws Exception {
    enableCreateNewChangeForAllNotInTarget();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content");
    // %2C is comma; the value below tests that percent decoding happens after splitting.
    // All three ways of representing space ("%20", "+", and "_" are also exercised.
    PushOneCommit.Result r = push.to("refs/for/master/%m=my_test%20+_message%2Cm=");
    r.assertOkStatus();
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%m=new_test_message");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId(), ALL_REVISIONS);
    Collection<RevisionInfo> revisions = ci.revisions.values();
    assertThat(revisions).hasSize(2);
    for (RevisionInfo ri : revisions) {
        if (ri.isCurrent) {
            assertThat(ri.description).isEqualTo("new test message");
        } else {
            assertThat(ri.description).isEqualTo("my test   message,m=");
        }
    }
}
#end_block

#method_before
@Test
public void pushForMasterWithApprovals() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%l=Code-Review");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(1);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId());
    cr = ci.labels.get("Code-Review");
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(2);
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "c.txt", "moreContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId());
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 3.");
}
#method_after
@Test
public void pushForMasterWithApprovals() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%l=Code-Review");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId(), DETAILED_LABELS, MESSAGES, DETAILED_ACCOUNTS);
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(1);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId(), DETAILED_LABELS, MESSAGES, DETAILED_ACCOUNTS);
    cr = ci.labels.get("Code-Review");
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(2);
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "c.txt", "moreContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId(), MESSAGES);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 3.");
}
#end_block

#method_before
@Test
public void pushNewPatchSetForMasterWithApprovals() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ChangeInfo ci = get(r.getChangeId());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2.");
    // Check that the user who pushed the new patch set was added as a reviewer since they added
    // a vote
    assertThatUserIsOnlyReviewer(ci, admin);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(2);
}
#method_after
@Test
public void pushNewPatchSetForMasterWithApprovals() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ChangeInfo ci = get(r.getChangeId(), DETAILED_LABELS, MESSAGES, DETAILED_ACCOUNTS);
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2.");
    // Check that the user who pushed the new patch set was added as a reviewer since they added
    // a vote
    assertThatUserIsOnlyReviewer(ci, admin);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(2);
}
#end_block

#method_before
@Test
public void pushForMasterWithApprovalsForgeCommitterButNoForgeVote() throws Exception {
    // Create a commit with "User" as author and committer
    RevCommit c = commitBuilder().author(user.getIdent()).committer(user.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    // Push this commit as "Administrator" (requires Forge Committer Identity)
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1", false);
    // Expected Code-Review votes:
    // 1. 0 from User (committer):
    // When the committer is forged, the committer is automatically added as
    // reviewer, hence we expect a dummy 0 vote for the committer.
    // 2. +1 from Administrator (uploader):
    // On push Code-Review+1 was specified, hence we expect a +1 vote from
    // the uploader.
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(2);
    int indexAdmin = admin.fullName.equals(cr.all.get(0).name) ? 0 : 1;
    int indexUser = indexAdmin == 0 ? 1 : 0;
    assertThat(cr.all.get(indexAdmin).name).isEqualTo(admin.fullName);
    assertThat(cr.all.get(indexAdmin).value.intValue()).isEqualTo(1);
    assertThat(cr.all.get(indexUser).name).isEqualTo(user.fullName);
    assertThat(cr.all.get(indexUser).value.intValue()).isEqualTo(0);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
}
#method_after
@Test
public void pushForMasterWithApprovalsForgeCommitterButNoForgeVote() throws Exception {
    // Create a commit with "User" as author and committer
    RevCommit c = commitBuilder().author(user.getIdent()).committer(user.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    // Push this commit as "Administrator" (requires Forge Committer Identity)
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1", false);
    // Expected Code-Review votes:
    // 1. 0 from User (committer):
    // When the committer is forged, the committer is automatically added as
    // reviewer, hence we expect a dummy 0 vote for the committer.
    // 2. +1 from Administrator (uploader):
    // On push Code-Review+1 was specified, hence we expect a +1 vote from
    // the uploader.
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get(), DETAILED_LABELS, MESSAGES, DETAILED_ACCOUNTS);
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(2);
    int indexAdmin = admin.fullName.equals(cr.all.get(0).name) ? 0 : 1;
    int indexUser = indexAdmin == 0 ? 1 : 0;
    assertThat(cr.all.get(indexAdmin).name).isEqualTo(admin.fullName);
    assertThat(cr.all.get(indexAdmin).value.intValue()).isEqualTo(1);
    assertThat(cr.all.get(indexUser).name).isEqualTo(user.fullName);
    assertThat(cr.all.get(indexUser).value.intValue()).isEqualTo(0);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
}
#end_block

#method_before
@Test
public void pushWithMultipleApprovals() throws Exception {
    LabelType Q = category("Custom-Label", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID anon = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    String heads = "refs/heads/*";
    Util.allow(config, Permission.forLabel("Custom-Label"), -1, 1, anon, heads);
    config.getLabelSections().put(Q.getName(), Q);
    saveProjectConfig(project, config);
    RevCommit c = commitBuilder().author(admin.getIdent()).committer(admin.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1,l=Custom-Label-1", false);
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    cr = ci.labels.get("Custom-Label");
    assertThat(cr.all).hasSize(1);
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
}
#method_after
@Test
public void pushWithMultipleApprovals() throws Exception {
    LabelType Q = category("Custom-Label", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID anon = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    String heads = "refs/heads/*";
    Util.allow(config, Permission.forLabel("Custom-Label"), -1, 1, anon, heads);
    config.getLabelSections().put(Q.getName(), Q);
    saveProjectConfig(project, config);
    RevCommit c = commitBuilder().author(admin.getIdent()).committer(admin.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1,l=Custom-Label-1", false);
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get(), DETAILED_LABELS, DETAILED_ACCOUNTS);
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    cr = ci.labels.get("Custom-Label");
    assertThat(cr.all).hasSize(1);
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
}
#end_block

#method_before
private void assertTwoChangesWithSameRevision(PushOneCommit.Result result) throws Exception {
    List<ChangeInfo> changes = query(result.getCommit().name());
    assertThat(changes).hasSize(2);
    ChangeInfo c1 = get(changes.get(0).id);
    ChangeInfo c2 = get(changes.get(1).id);
    assertThat(c1.project).isEqualTo(c2.project);
    assertThat(c1.branch).isNotEqualTo(c2.branch);
    assertThat(c1.changeId).isEqualTo(c2.changeId);
    assertThat(c1.currentRevision).isEqualTo(c2.currentRevision);
}
#method_after
private void assertTwoChangesWithSameRevision(PushOneCommit.Result result) throws Exception {
    List<ChangeInfo> changes = query(result.getCommit().name());
    assertThat(changes).hasSize(2);
    ChangeInfo c1 = get(changes.get(0).id, CURRENT_REVISION);
    ChangeInfo c2 = get(changes.get(1).id, CURRENT_REVISION);
    assertThat(c1.project).isEqualTo(c2.project);
    assertThat(c1.branch).isNotEqualTo(c2.branch);
    assertThat(c1.changeId).isEqualTo(c2.changeId);
    assertThat(c1.currentRevision).isEqualTo(c2.currentRevision);
}
#end_block

#method_before
@Test
public void refStateFieldValues() throws Exception {
    AllUsersName allUsersName = new AllUsersName(AllUsersNameProvider.DEFAULT);
    Account account = new Account(new Account.Id(1), TimeUtil.nowTs());
    String metaId = "0e39795bb25dc914118224995c53c5c36923a461";
    account.setMetaId(metaId);
    List<String> values = toStrings(AccountField.REF_STATE.get(new AccountState(allUsersName, account, ImmutableSet.of(), ImmutableSet.of(), ImmutableMap.of())));
    assertThat(values).hasSize(1);
    String expectedValue = allUsersName.get() + ":" + RefNames.refsUsers(account.getId()) + ":" + metaId;
    assertThat(Iterables.getOnlyElement(values)).isEqualTo(expectedValue);
}
#method_after
@Test
public void refStateFieldValues() throws Exception {
    AllUsersName allUsersName = new AllUsersName(AllUsersNameProvider.DEFAULT);
    Account account = new Account(new Account.Id(1), TimeUtil.nowTs());
    String metaId = "0e39795bb25dc914118224995c53c5c36923a461";
    account.setMetaId(metaId);
    List<String> values = toStrings(AccountField.REF_STATE.get(new AccountState(allUsersName, account, ImmutableSet.of(), ImmutableMap.of())));
    assertThat(values).hasSize(1);
    String expectedValue = allUsersName.get() + ":" + RefNames.refsUsers(account.getId()) + ":" + metaId;
    assertThat(Iterables.getOnlyElement(values)).isEqualTo(expectedValue);
}
#end_block

#method_before
@Test
public void externalIdStateFieldValues() throws Exception {
    Account.Id id = new Account.Id(1);
    Account account = new Account(id, TimeUtil.nowTs());
    ExternalId extId1 = ExternalId.create(ExternalId.Key.create(ExternalId.SCHEME_MAILTO, "foo.bar@example.com"), id, "foo.bar@example.com", null, ObjectId.fromString("1b9a0cf038ea38a0ab08617c39aa8e28413a27ca"));
    ExternalId extId2 = ExternalId.create(ExternalId.Key.create(ExternalId.SCHEME_USERNAME, "foo"), id, null, "secret", ObjectId.fromString("5b3a73dc9a668a5b89b5f049225261e3e3291d1a"));
    List<String> values = toStrings(AccountField.EXTERNAL_ID_STATE.get(new AccountState(null, account, ImmutableSet.of(), ImmutableSet.of(extId1, extId2), ImmutableMap.of())));
    String expectedValue1 = extId1.key().sha1().name() + ":" + extId1.blobId().name();
    String expectedValue2 = extId2.key().sha1().name() + ":" + extId2.blobId().name();
    assertThat(values).containsExactly(expectedValue1, expectedValue2);
}
#method_after
@Test
public void externalIdStateFieldValues() throws Exception {
    Account.Id id = new Account.Id(1);
    Account account = new Account(id, TimeUtil.nowTs());
    ExternalId extId1 = ExternalId.create(ExternalId.Key.create(ExternalId.SCHEME_MAILTO, "foo.bar@example.com"), id, "foo.bar@example.com", null, ObjectId.fromString("1b9a0cf038ea38a0ab08617c39aa8e28413a27ca"));
    ExternalId extId2 = ExternalId.create(ExternalId.Key.create(ExternalId.SCHEME_USERNAME, "foo"), id, null, "secret", ObjectId.fromString("5b3a73dc9a668a5b89b5f049225261e3e3291d1a"));
    List<String> values = toStrings(AccountField.EXTERNAL_ID_STATE.get(new AccountState(null, account, ImmutableSet.of(extId1, extId2), ImmutableMap.of())));
    String expectedValue1 = extId1.key().sha1().name() + ":" + extId1.blobId().name();
    String expectedValue2 = extId2.key().sha1().name() + ":" + extId2.blobId().name();
    assertThat(values).containsExactly(expectedValue1, expectedValue2);
}
#end_block

#method_before
private void assertCanUpload(ProjectControl u) {
    assertThat(u.canPushToAtLeastOneRef()).named("can upload").isEqualTo(Capable.OK);
}
#method_after
private void assertCanUpload(ProjectControl u) {
    assertThat(u.canPushToAtLeastOneRef()).named("can upload").isTrue();
}
#end_block

#method_before
private void assertCannotUpload(ProjectControl u) {
    assertThat(u.canPushToAtLeastOneRef()).named("cannot upload").isNotEqualTo(Capable.OK);
}
#method_after
private void assertCannotUpload(ProjectControl u) {
    assertThat(u.canPushToAtLeastOneRef()).named("cannot upload").isFalse();
}
#end_block

#method_before
@Test
public void branchDelegation1() {
    allow(local, OWNER, ADMIN, "refs/*");
    allow(local, OWNER, DEVS, "refs/heads/x/*");
    ProjectControl uDev = user(local, DEVS);
    assertNotOwner(uDev);
    assertOwnerAnyRef(uDev);
    assertOwner("refs/heads/x/*", uDev);
    assertOwner("refs/heads/x/y", uDev);
    assertOwner("refs/heads/x/y/*", uDev);
    assertNotOwner("refs/*", uDev);
    assertNotOwner("refs/heads/master", uDev);
}
#method_after
@Test
public void branchDelegation1() {
    allow(local, OWNER, ADMIN, "refs/*");
    allow(local, OWNER, DEVS, "refs/heads/x/*");
    ProjectControl uDev = user(local, DEVS);
    assertNotOwner(uDev);
    assertOwner("refs/heads/x/*", uDev);
    assertOwner("refs/heads/x/y", uDev);
    assertOwner("refs/heads/x/y/*", uDev);
    assertNotOwner("refs/*", uDev);
    assertNotOwner("refs/heads/master", uDev);
}
#end_block

#method_before
@Test
public void branchDelegation2() {
    allow(local, OWNER, ADMIN, "refs/*");
    allow(local, OWNER, DEVS, "refs/heads/x/*");
    allow(local, OWNER, fixers, "refs/heads/x/y/*");
    doNotInherit(local, OWNER, "refs/heads/x/y/*");
    ProjectControl uDev = user(local, DEVS);
    assertNotOwner(uDev);
    assertOwnerAnyRef(uDev);
    assertOwner("refs/heads/x/*", uDev);
    assertOwner("refs/heads/x/y", uDev);
    assertOwner("refs/heads/x/y/*", uDev);
    assertNotOwner("refs/*", uDev);
    assertNotOwner("refs/heads/master", uDev);
    ProjectControl uFix = user(local, fixers);
    assertNotOwner(uFix);
    assertOwnerAnyRef(uFix);
    assertOwner("refs/heads/x/y/*", uFix);
    assertOwner("refs/heads/x/y/bar", uFix);
    assertNotOwner("refs/heads/x/*", uFix);
    assertNotOwner("refs/heads/x/y", uFix);
    assertNotOwner("refs/*", uFix);
    assertNotOwner("refs/heads/master", uFix);
}
#method_after
@Test
public void branchDelegation2() {
    allow(local, OWNER, ADMIN, "refs/*");
    allow(local, OWNER, DEVS, "refs/heads/x/*");
    allow(local, OWNER, fixers, "refs/heads/x/y/*");
    doNotInherit(local, OWNER, "refs/heads/x/y/*");
    ProjectControl uDev = user(local, DEVS);
    assertNotOwner(uDev);
    assertOwner("refs/heads/x/*", uDev);
    assertOwner("refs/heads/x/y", uDev);
    assertOwner("refs/heads/x/y/*", uDev);
    assertNotOwner("refs/*", uDev);
    assertNotOwner("refs/heads/master", uDev);
    ProjectControl uFix = user(local, fixers);
    assertNotOwner(uFix);
    assertOwner("refs/heads/x/y/*", uFix);
    assertOwner("refs/heads/x/y/bar", uFix);
    assertNotOwner("refs/heads/x/*", uFix);
    assertNotOwner("refs/heads/x/y", uFix);
    assertNotOwner("refs/*", uFix);
    assertNotOwner("refs/heads/master", uFix);
}
#end_block

#method_before
private ProjectControl user(ProjectConfig local, String name, AccountGroup.UUID... memberOf) {
    return new ProjectControl(Collections.<AccountGroup.UUID>emptySet(), Collections.<AccountGroup.UUID>emptySet(), projectCache, sectionSorter, // commitsCollection
    null, changeControlFactory, // canonicalWebUrl
    "http://localhost", permissionBackend, new MockUser(name, memberOf), newProjectState(local), metrics);
}
#method_after
private ProjectControl user(ProjectConfig local, String name, AccountGroup.UUID... memberOf) {
    return new ProjectControl(Collections.<AccountGroup.UUID>emptySet(), Collections.<AccountGroup.UUID>emptySet(), sectionSorter, // commitsCollection
    null, changeControlFactory, permissionBackend, new MockUser(name, memberOf), newProjectState(local));
}
#end_block

#method_before
private void testReadOnly(Change.Id id) throws Exception {
    Timestamp before = TimeUtil.nowTs();
    Timestamp until = new Timestamp(before.getTime() + 1000 * 3600);
    // Set read-only.
    Change c = db.changes().get(id);
    assertThat(c).named("change " + id).isNotNull();
    NoteDbChangeState state = NoteDbChangeState.parse(c);
    state = state.withReadOnlyUntil(until);
    c.setNoteDbState(state.toString());
    db.changes().update(Collections.singleton(c));
    assertThat(gApi.changes().id(id.get()).get().subject).isEqualTo(PushOneCommit.SUBJECT);
    assertThat(gApi.changes().id(id.get()).get().topic).isNull();
    try {
        gApi.changes().id(id.get()).topic("a-topic");
        assert_().fail("expected read-only exception");
    } catch (RestApiException e) {
        Optional<Throwable> oe = Throwables.getCausalChain(e).stream().filter(x -> x instanceof OrmRuntimeException).findFirst();
        assertThat(oe).named("OrmRuntimeException in causal chain of " + e).isPresent();
        assertThat(oe.get().getMessage()).contains("read-only");
    }
    assertThat(gApi.changes().id(id.get()).get().topic).isNull();
    TestTimeUtil.setClock(new Timestamp(until.getTime() + 1000));
    assertThat(gApi.changes().id(id.get()).get().subject).isEqualTo(PushOneCommit.SUBJECT);
    gApi.changes().id(id.get()).topic("a-topic");
    assertThat(gApi.changes().id(id.get()).get().topic).isEqualTo("a-topic");
}
#method_after
private void testReadOnly(Change.Id id) throws Exception {
    Timestamp before = TimeUtil.nowTs();
    Timestamp until = new Timestamp(before.getTime() + 1000 * 3600);
    // Set read-only.
    Change c = db.changes().get(id);
    assertThat(c).named("change " + id).isNotNull();
    NoteDbChangeState state = NoteDbChangeState.parse(c);
    state = state.withReadOnlyUntil(until);
    c.setNoteDbState(state.toString());
    db.changes().update(Collections.singleton(c));
    assertThat(gApi.changes().id(id.get()).get().subject).isEqualTo(PushOneCommit.SUBJECT);
    assertThat(gApi.changes().id(id.get()).get().topic).isNull();
    try {
        gApi.changes().id(id.get()).topic("a-topic");
        fail("expected read-only exception");
    } catch (RestApiException e) {
        Optional<Throwable> oe = Throwables.getCausalChain(e).stream().filter(x -> x instanceof OrmRuntimeException).findFirst();
        assertThat(oe).named("OrmRuntimeException in causal chain of " + e).isPresent();
        assertThat(oe.get().getMessage()).contains("read-only");
    }
    assertThat(gApi.changes().id(id.get()).get().topic).isNull();
    TestTimeUtil.setClock(new Timestamp(until.getTime() + 1000));
    assertThat(gApi.changes().id(id.get()).get().subject).isEqualTo(PushOneCommit.SUBJECT);
    gApi.changes().id(id.get()).topic("a-topic");
    assertThat(gApi.changes().id(id.get()).get().topic).isEqualTo("a-topic");
}
#end_block

#method_before
@Test
public void duplicateCompoundNonIndexOnlyPredicates() throws Exception {
    Predicate<ChangeData> in = parse("(status:new OR status:draft) bar:p file:a");
    Predicate<ChangeData> out = rewrite(in);
    assertThat(out.getClass()).isEqualTo(AndChangeSource.class);
    assertThat(out.getChildren()).containsExactly(query(and(in.getChild(0), in.getChild(2))), in.getChild(1)).inOrder();
}
#method_after
@Test
public void duplicateCompoundNonIndexOnlyPredicates() throws Exception {
    Predicate<ChangeData> in = parse("status:new bar:p file:a");
    Predicate<ChangeData> out = rewrite(in);
    assertThat(out.getClass()).isEqualTo(AndChangeSource.class);
    assertThat(out.getChildren()).containsExactly(query(and(in.getChild(0), in.getChild(2))), in.getChild(1)).inOrder();
}
#end_block

#method_before
@Test
public void getPossibleStatus() throws Exception {
    assertThat(status("file:a")).isEqualTo(EnumSet.allOf(Change.Status.class));
    assertThat(status("is:new")).containsExactly(NEW);
    assertThat(status("-is:new")).containsExactly(DRAFT, MERGED, ABANDONED);
    assertThat(status("is:new OR is:merged")).containsExactly(NEW, MERGED);
    assertThat(status("is:new is:merged")).isEmpty();
    assertThat(status("(is:new is:draft) (is:merged)")).isEmpty();
    assertThat(status("(is:new is:draft) (is:merged)")).isEmpty();
    assertThat(status("(is:new is:draft) OR (is:merged)")).containsExactly(MERGED);
}
#method_after
@Test
public void getPossibleStatus() throws Exception {
    Set<Change.Status> all = EnumSet.allOf(Change.Status.class);
    assertThat(status("file:a")).isEqualTo(all);
    assertThat(status("is:new")).containsExactly(NEW);
    assertThat(status("is:new OR is:merged")).containsExactly(NEW, MERGED);
    assertThat(status("is:new OR is:x")).isEqualTo(all);
    assertThat(status("is:new is:merged")).isEmpty();
    assertThat(status("(is:new) (is:merged)")).isEmpty();
    assertThat(status("(is:new) (is:merged)")).isEmpty();
    assertThat(status("is:new is:x")).containsExactly(NEW);
}
#end_block

#method_before
@Test
public void rebaseAbandonedChange() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    assertThat(info(changeId).status).isEqualTo(ChangeStatus.NEW);
    gApi.changes().id(changeId).abandon();
    ChangeInfo info = get(changeId);
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("change is abandoned");
    gApi.changes().id(changeId).revision(r.getCommit().name()).rebase();
}
#method_after
@Test
public void rebaseAbandonedChange() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    assertThat(info(changeId).status).isEqualTo(ChangeStatus.NEW);
    gApi.changes().id(changeId).abandon();
    ChangeInfo info = info(changeId);
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("change is abandoned");
    gApi.changes().id(changeId).revision(r.getCommit().name()).rebase();
}
#end_block

#method_before
@Test
public void rebaseOntoAbandonedChange() throws Exception {
    // Create two changes both with the same parent
    PushOneCommit.Result r = createChange();
    testRepo.reset("HEAD~1");
    PushOneCommit.Result r2 = createChange();
    // Abandon the first change
    String changeId = r.getChangeId();
    assertThat(info(changeId).status).isEqualTo(ChangeStatus.NEW);
    gApi.changes().id(changeId).abandon();
    ChangeInfo info = get(changeId);
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    RebaseInput ri = new RebaseInput();
    ri.base = r.getCommit().name();
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("base change is abandoned: " + changeId);
    gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).rebase(ri);
}
#method_after
@Test
public void rebaseOntoAbandonedChange() throws Exception {
    // Create two changes both with the same parent
    PushOneCommit.Result r = createChange();
    testRepo.reset("HEAD~1");
    PushOneCommit.Result r2 = createChange();
    // Abandon the first change
    String changeId = r.getChangeId();
    assertThat(info(changeId).status).isEqualTo(ChangeStatus.NEW);
    gApi.changes().id(changeId).abandon();
    ChangeInfo info = info(changeId);
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    RebaseInput ri = new RebaseInput();
    ri.base = r.getCommit().name();
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("base change is abandoned: " + changeId);
    gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).rebase(ri);
}
#end_block

#method_before
@Test
public void pushCommitOfOtherUserThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // admin pushes commit of user
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, user.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.owner._accountId).isEqualTo(admin.id.get());
    CommitInfo commit = change.revisions.get(change.currentRevision).commit;
    assertThat(commit.author.email).isEqualTo(user.email);
    assertThat(commit.committer.email).isEqualTo(user.email);
    // check the user cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // check that the author/committer was NOT added as reviewer (he can't see
    // the change)
    assertThat(change.reviewers.get(REVIEWER)).isNull();
    assertThat(change.reviewers.get(CC)).isNull();
    assertThat(sender.getMessages()).isEmpty();
}
#method_after
@Test
public void pushCommitOfOtherUserThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // admin pushes commit of user
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, user.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.owner._accountId).isEqualTo(admin.id.get());
    CommitInfo commit = change.revisions.get(change.currentRevision).commit;
    assertThat(commit.author.email).isEqualTo(user.email);
    assertThat(commit.committer.email).isEqualTo(user.email);
    // check the user cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // check that the author/committer was NOT added as reviewer (he can't see
    // the change)
    assertThat(change.reviewers.get(REVIEWER)).isNull();
    assertThat(change.reviewers.get(CC)).isNull();
    assertThat(sender.getMessages()).isEmpty();
}
#end_block

#method_before
@Test
public void pushCommitWithFooterOfOtherUserThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // admin pushes commit that references 'user' in a footer
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo, PushOneCommit.SUBJECT + "\n\n" + FooterConstants.REVIEWED_BY.getName() + ": " + user.getIdent().toExternalString(), PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check that 'user' cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // check that 'user' was NOT added as cc ('user' can't see the change)
    setApiUser(admin);
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.reviewers.get(REVIEWER)).isNull();
    assertThat(change.reviewers.get(CC)).isNull();
    assertThat(sender.getMessages()).isEmpty();
}
#method_after
@Test
public void pushCommitWithFooterOfOtherUserThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // admin pushes commit that references 'user' in a footer
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo, PushOneCommit.SUBJECT + "\n\n" + FooterConstants.REVIEWED_BY.getName() + ": " + user.getIdent().toExternalString(), PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check that 'user' cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // check that 'user' was NOT added as cc ('user' can't see the change)
    setApiUser(admin);
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.reviewers.get(REVIEWER)).isNull();
    assertThat(change.reviewers.get(CC)).isNull();
    assertThat(sender.getMessages()).isEmpty();
}
#end_block

#method_before
@Test
public void addReviewerThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // create change
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check the user cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // try to add user as reviewer
    setApiUser(admin);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    AddReviewerResult r = gApi.changes().id(result.getChangeId()).addReviewer(in);
    assertThat(r.input).isEqualTo(user.email);
    assertThat(r.error).contains("does not have permission to see this change");
    assertThat(r.reviewers).isNull();
}
#method_after
@Test
public void addReviewerThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // create change
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check the user cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // try to add user as reviewer
    setApiUser(admin);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    AddReviewerResult r = gApi.changes().id(result.getChangeId()).addReviewer(in);
    assertThat(r.input).isEqualTo(user.email);
    assertThat(r.error).contains("does not have permission to see this change");
    assertThat(r.reviewers).isNull();
}
#end_block

#method_before
@Test
public void implicitlyCcOnNonVotingReviewGwtStyle() throws Exception {
    PushOneCommit.Result r = createChange();
    setApiUser(user);
    assertThat(getReviewerState(r.getChangeId(), user.id)).isEmpty();
    // Exact request format made by GWT UI at ddc6b7160fe416fed9e7e3180489d44c82fd64f8.
    ReviewInput in = new ReviewInput();
    in.labels = ImmutableMap.of("Code-Review", (short) 0);
    in.strictLabels = true;
    in.drafts = DraftHandling.PUBLISH_ALL_REVISIONS;
    in.message = "comment";
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(in);
    // If we're not reading from NoteDb, then the CCed user will be returned in the REVIEWER state.
    assertThat(getReviewerState(r.getChangeId(), user.id)).hasValue(notesMigration.readChanges() ? CC : REVIEWER);
}
#method_after
@Test
public void implicitlyCcOnNonVotingReviewGwtStyle() throws Exception {
    PushOneCommit.Result r = createChange();
    setApiUser(user);
    assertThat(getReviewerState(r.getChangeId(), user.id)).isEmpty();
    // Exact request format made by GWT UI at ddc6b7160fe416fed9e7e3180489d44c82fd64f8.
    ReviewInput in = new ReviewInput();
    in.labels = ImmutableMap.of("Code-Review", (short) 0);
    in.drafts = DraftHandling.PUBLISH_ALL_REVISIONS;
    in.message = "comment";
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(in);
    // If we're not reading from NoteDb, then the CCed user will be returned in the REVIEWER state.
    assertThat(getReviewerState(r.getChangeId(), user.id)).hasValue(notesMigration.readChanges() ? CC : REVIEWER);
}
#end_block

#method_before
@Test
public void checkReviewedFlagBeforeAndAfterReview() throws Exception {
    PushOneCommit.Result r = createChange();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    setApiUser(user);
    assertThat(get(r.getChangeId()).reviewed).isNull();
    revision(r).review(ReviewInput.recommend());
    assertThat(get(r.getChangeId()).reviewed).isTrue();
}
#method_after
@Test
public void checkReviewedFlagBeforeAndAfterReview() throws Exception {
    PushOneCommit.Result r = createChange();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    setApiUser(user);
    assertThat(get(r.getChangeId(), REVIEWED).reviewed).isNull();
    revision(r).review(ReviewInput.recommend());
    assertThat(get(r.getChangeId(), REVIEWED).reviewed).isTrue();
}
#end_block

#method_before
@Test
public void defaultSearchDoesNotTouchDatabase() throws Exception {
    setApiUser(admin);
    PushOneCommit.Result r1 = createChange();
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).submit();
    createChange();
    createDraftChange();
    setApiUser(user);
    AcceptanceTestRequestScope.Context ctx = disableDb();
    try {
        assertThat(gApi.changes().query().withQuery("project:{" + project.get() + "} (status:open OR status:closed)").withOption(LABELS).withOption(DETAILED_ACCOUNTS).withOption(REVIEWED).get()).hasSize(2);
    } finally {
        enableDb(ctx);
    }
}
#method_after
@Test
public void defaultSearchDoesNotTouchDatabase() throws Exception {
    setApiUser(admin);
    PushOneCommit.Result r1 = createChange();
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).submit();
    createChange();
    setApiUser(user);
    AcceptanceTestRequestScope.Context ctx = disableDb();
    try {
        assertThat(gApi.changes().query().withQuery("project:{" + project.get() + "} (status:open OR status:closed)").withOption(LABELS).withOption(DETAILED_ACCOUNTS).withOption(REVIEWED).get()).hasSize(2);
    } finally {
        enableDb(ctx);
    }
}
#end_block

#method_before
@Test
public void createMergePatchSet() throws Exception {
    PushOneCommit.Result start = pushTo("refs/heads/master");
    start.assertOkStatus();
    // create a change for master
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    String changeId = r.getChangeId();
    testRepo.reset(start.getCommit());
    PushOneCommit.Result currentMaster = pushTo("refs/heads/master");
    currentMaster.assertOkStatus();
    String parent = currentMaster.getCommit().getName();
    // push a commit into dev branch
    createBranch(new Branch.NameKey(project, "dev"));
    PushOneCommit.Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", "A.txt", "A content").to("refs/heads/dev");
    changeA.assertOkStatus();
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = "dev";
    MergePatchSetInput in = new MergePatchSetInput();
    in.merge = mergeInput;
    in.subject = "update change by merge ps2";
    gApi.changes().id(changeId).createMergePatchSet(in);
    ChangeInfo changeInfo = gApi.changes().id(changeId).get(ALL_REVISIONS, CURRENT_COMMIT, CURRENT_REVISION);
    assertThat(changeInfo.revisions.size()).isEqualTo(2);
    assertThat(changeInfo.subject).isEqualTo(in.subject);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isEqualTo(parent);
}
#method_after
@Test
public void createMergePatchSet() throws Exception {
    PushOneCommit.Result start = pushTo("refs/heads/master");
    start.assertOkStatus();
    // create a change for master
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    String changeId = r.getChangeId();
    testRepo.reset(start.getCommit());
    PushOneCommit.Result currentMaster = pushTo("refs/heads/master");
    currentMaster.assertOkStatus();
    String parent = currentMaster.getCommit().getName();
    // push a commit into dev branch
    createBranch("dev");
    PushOneCommit.Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", "A.txt", "A content").to("refs/heads/dev");
    changeA.assertOkStatus();
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = "dev";
    MergePatchSetInput in = new MergePatchSetInput();
    in.merge = mergeInput;
    in.subject = "update change by merge ps2";
    gApi.changes().id(changeId).createMergePatchSet(in);
    ChangeInfo changeInfo = gApi.changes().id(changeId).get(ALL_REVISIONS, CURRENT_COMMIT, CURRENT_REVISION);
    assertThat(changeInfo.revisions.size()).isEqualTo(2);
    assertThat(changeInfo.subject).isEqualTo(in.subject);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isEqualTo(parent);
}
#end_block

#method_before
@Test
public void createMergePatchSetInheritParent() throws Exception {
    PushOneCommit.Result start = pushTo("refs/heads/master");
    start.assertOkStatus();
    // create a change for master
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    String changeId = r.getChangeId();
    String parent = r.getCommit().getParent(0).getName();
    // advance master branch
    testRepo.reset(start.getCommit());
    PushOneCommit.Result currentMaster = pushTo("refs/heads/master");
    currentMaster.assertOkStatus();
    // push a commit into dev branch
    createBranch(new Branch.NameKey(project, "dev"));
    PushOneCommit.Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", "A.txt", "A content").to("refs/heads/dev");
    changeA.assertOkStatus();
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = "dev";
    MergePatchSetInput in = new MergePatchSetInput();
    in.merge = mergeInput;
    in.subject = "update change by merge ps2 inherit parent of ps1";
    in.inheritParent = true;
    gApi.changes().id(changeId).createMergePatchSet(in);
    ChangeInfo changeInfo = gApi.changes().id(changeId).get(ALL_REVISIONS, CURRENT_COMMIT, CURRENT_REVISION);
    assertThat(changeInfo.revisions.size()).isEqualTo(2);
    assertThat(changeInfo.subject).isEqualTo(in.subject);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isEqualTo(parent);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isNotEqualTo(currentMaster.getCommit().getName());
}
#method_after
@Test
public void createMergePatchSetInheritParent() throws Exception {
    PushOneCommit.Result start = pushTo("refs/heads/master");
    start.assertOkStatus();
    // create a change for master
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    String changeId = r.getChangeId();
    String parent = r.getCommit().getParent(0).getName();
    // advance master branch
    testRepo.reset(start.getCommit());
    PushOneCommit.Result currentMaster = pushTo("refs/heads/master");
    currentMaster.assertOkStatus();
    // push a commit into dev branch
    createBranch("dev");
    PushOneCommit.Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", "A.txt", "A content").to("refs/heads/dev");
    changeA.assertOkStatus();
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = "dev";
    MergePatchSetInput in = new MergePatchSetInput();
    in.merge = mergeInput;
    in.subject = "update change by merge ps2 inherit parent of ps1";
    in.inheritParent = true;
    gApi.changes().id(changeId).createMergePatchSet(in);
    ChangeInfo changeInfo = gApi.changes().id(changeId).get(ALL_REVISIONS, CURRENT_COMMIT, CURRENT_REVISION);
    assertThat(changeInfo.revisions.size()).isEqualTo(2);
    assertThat(changeInfo.subject).isEqualTo(in.subject);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isEqualTo(parent);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isNotEqualTo(currentMaster.getCommit().getName());
}
#end_block

#method_before
@Test
@TestProjectInput(useContentMerge = InheritableBoolean.TRUE)
public void submitFastForwardIdenticalTree() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change1 = createChange("Change 1", "a.txt", "a");
    PushOneCommit.Result change2 = createChange("Change 2", "a.txt", "a");
    assertThat(change1.getCommit().getTree()).isEqualTo(change2.getCommit().getTree());
    // for rebase if necessary, otherwise, the manual rebase of change2 will
    // fail since change1 would be merged as fast forward
    testRepo.reset(initialHead);
    PushOneCommit.Result change0 = createChange("Change 0", "b.txt", "b");
    submit(change0.getChangeId());
    RevCommit headAfterChange0 = getRemoteHead();
    assertThat(headAfterChange0.getShortMessage()).isEqualTo("Change 0");
    submit(change1.getChangeId());
    RevCommit headAfterChange1 = getRemoteHead();
    assertThat(headAfterChange1.getShortMessage()).isEqualTo("Change 1");
    assertThat(headAfterChange0).isEqualTo(headAfterChange1.getParent(0));
    // Do manual rebase first.
    gApi.changes().id(change2.getChangeId()).current().rebase();
    submit(change2.getChangeId());
    RevCommit headAfterChange2 = getRemoteHead();
    assertThat(headAfterChange2.getShortMessage()).isEqualTo("Change 2");
    assertThat(headAfterChange1).isEqualTo(headAfterChange2.getParent(0));
    ChangeInfo info2 = get(change2.getChangeId());
    assertThat(info2.status).isEqualTo(ChangeStatus.MERGED);
}
#method_after
@Test
@TestProjectInput(useContentMerge = InheritableBoolean.TRUE)
public void submitFastForwardIdenticalTree() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change1 = createChange("Change 1", "a.txt", "a");
    PushOneCommit.Result change2 = createChange("Change 2", "a.txt", "a");
    assertThat(change1.getCommit().getTree()).isEqualTo(change2.getCommit().getTree());
    // for rebase if necessary, otherwise, the manual rebase of change2 will
    // fail since change1 would be merged as fast forward
    testRepo.reset(initialHead);
    PushOneCommit.Result change0 = createChange("Change 0", "b.txt", "b");
    submit(change0.getChangeId());
    RevCommit headAfterChange0 = getRemoteHead();
    assertThat(headAfterChange0.getShortMessage()).isEqualTo("Change 0");
    submit(change1.getChangeId());
    RevCommit headAfterChange1 = getRemoteHead();
    assertThat(headAfterChange1.getShortMessage()).isEqualTo("Change 1");
    assertThat(headAfterChange0).isEqualTo(headAfterChange1.getParent(0));
    // Do manual rebase first.
    gApi.changes().id(change2.getChangeId()).current().rebase();
    submit(change2.getChangeId());
    RevCommit headAfterChange2 = getRemoteHead();
    assertThat(headAfterChange2.getShortMessage()).isEqualTo("Change 2");
    assertThat(headAfterChange1).isEqualTo(headAfterChange2.getParent(0));
    ChangeInfo info2 = info(change2.getChangeId());
    assertThat(info2.status).isEqualTo(ChangeStatus.MERGED);
}
#end_block

#method_before
@Test
public void updateChangeFailureRollsBackRefUpdate() throws Exception {
    assume().that(notesMigration.disableChangeReviewDb()).isTrue();
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getChange().getId();
    String master = "refs/heads/master";
    String backup = "refs/backup/master";
    ObjectId master1 = getRef(master).get();
    assertThat(getRef(backup)).isEmpty();
    // Toy op that copies the value of refs/heads/master to refs/backup/master.
    BatchUpdateOp backupMasterOp = new BatchUpdateOp() {

        ObjectId newId;

        @Override
        public void updateRepo(RepoContext ctx) throws IOException {
            ObjectId oldId = ctx.getRepoView().getRef(backup).orElse(ObjectId.zeroId());
            newId = ctx.getRepoView().getRef(master).get();
            ctx.addRefUpdate(oldId, newId, backup);
        }

        @Override
        public boolean updateChange(ChangeContext ctx) {
            ctx.getUpdate(ctx.getChange().currentPatchSetId()).setChangeMessage("Backed up master branch to " + newId.name());
            return true;
        }
    };
    try (BatchUpdate bu = newBatchUpdate(batchUpdateFactory)) {
        bu.addOp(id, backupMasterOp);
        bu.execute();
    }
    // Ensure backupMasterOp worked.
    assertThat(getRef(backup)).hasValue(master1);
    assertThat(getMessages(id)).contains("Backed up master branch to " + master1.name());
    // Advance master by submitting the change.
    gApi.changes().id(id.get()).current().review(ReviewInput.approve());
    gApi.changes().id(id.get()).current().submit();
    ObjectId master2 = getRef(master).get();
    assertThat(master2).isNotEqualTo(master1);
    int msgCount = getMessages(id).size();
    try (BatchUpdate bu = newBatchUpdate(batchUpdateFactory)) {
        // This time, we attempt to back up master, but we fail during updateChange.
        bu.addOp(id, backupMasterOp);
        String msg = "Change is bad";
        bu.addOp(id, new BatchUpdateOp() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws ResourceConflictException {
                throw new ResourceConflictException(msg);
            }
        });
        try {
            bu.execute();
            assert_().fail("expected ResourceConflictException");
        } catch (ResourceConflictException e) {
            assertThat(e).hasMessageThat().isEqualTo(msg);
        }
    }
    // If updateChange hadn't failed, backup would have been updated to master2.
    assertThat(getRef(backup)).hasValue(master1);
    assertThat(getMessages(id)).hasSize(msgCount);
}
#method_after
@Test
public void updateChangeFailureRollsBackRefUpdate() throws Exception {
    assume().that(notesMigration.disableChangeReviewDb()).isTrue();
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getChange().getId();
    String master = "refs/heads/master";
    String backup = "refs/backup/master";
    ObjectId master1 = getRef(master).get();
    assertThat(getRef(backup)).isEmpty();
    // Toy op that copies the value of refs/heads/master to refs/backup/master.
    BatchUpdateOp backupMasterOp = new BatchUpdateOp() {

        ObjectId newId;

        @Override
        public void updateRepo(RepoContext ctx) throws IOException {
            ObjectId oldId = ctx.getRepoView().getRef(backup).orElse(ObjectId.zeroId());
            newId = ctx.getRepoView().getRef(master).get();
            ctx.addRefUpdate(oldId, newId, backup);
        }

        @Override
        public boolean updateChange(ChangeContext ctx) {
            ctx.getUpdate(ctx.getChange().currentPatchSetId()).setChangeMessage("Backed up master branch to " + newId.name());
            return true;
        }
    };
    try (BatchUpdate bu = newBatchUpdate(batchUpdateFactory)) {
        bu.addOp(id, backupMasterOp);
        bu.execute();
    }
    // Ensure backupMasterOp worked.
    assertThat(getRef(backup)).hasValue(master1);
    assertThat(getMessages(id)).contains("Backed up master branch to " + master1.name());
    // Advance master by submitting the change.
    gApi.changes().id(id.get()).current().review(ReviewInput.approve());
    gApi.changes().id(id.get()).current().submit();
    ObjectId master2 = getRef(master).get();
    assertThat(master2).isNotEqualTo(master1);
    int msgCount = getMessages(id).size();
    try (BatchUpdate bu = newBatchUpdate(batchUpdateFactory)) {
        // This time, we attempt to back up master, but we fail during updateChange.
        bu.addOp(id, backupMasterOp);
        String msg = "Change is bad";
        bu.addOp(id, new BatchUpdateOp() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws ResourceConflictException {
                throw new ResourceConflictException(msg);
            }
        });
        try {
            bu.execute();
            fail("expected ResourceConflictException");
        } catch (ResourceConflictException e) {
            assertThat(e).hasMessageThat().isEqualTo(msg);
        }
    }
    // If updateChange hadn't failed, backup would have been updated to master2.
    assertThat(getRef(backup)).hasValue(master1);
    assertThat(getMessages(id)).hasSize(msgCount);
}
#end_block

#method_before
private Iterable<AccountInfo> getReviewers(PushOneCommit.Result r, ReviewerState state) throws Exception {
    return get(r.getChangeId()).reviewers.get(state);
}
#method_after
private Iterable<AccountInfo> getReviewers(PushOneCommit.Result r, ReviewerState state) throws Exception {
    return get(r.getChangeId(), DETAILED_LABELS).reviewers.get(state);
}
#end_block

#method_before
private void assertMail(MailMessage have, MailMessage want) {
    assertThat(have.id()).isEqualTo(want.id());
    assertThat(have.to()).isEqualTo(want.to());
    assertThat(have.from()).isEqualTo(want.from());
    assertThat(have.cc()).isEqualTo(want.cc());
    assertThat(have.dateReceived().getMillis()).isEqualTo(want.dateReceived().getMillis());
    assertThat(have.additionalHeaders()).isEqualTo(want.additionalHeaders());
    assertThat(have.subject()).isEqualTo(want.subject());
    assertThat(have.textContent()).isEqualTo(want.textContent());
    assertThat(have.htmlContent()).isEqualTo(want.htmlContent());
}
#method_after
private void assertMail(MailMessage have, MailMessage want) {
    assertThat(have.id()).isEqualTo(want.id());
    assertThat(have.to()).isEqualTo(want.to());
    assertThat(have.from()).isEqualTo(want.from());
    assertThat(have.cc()).isEqualTo(want.cc());
    assertThat(have.dateReceived()).isEqualTo(want.dateReceived());
    assertThat(have.additionalHeaders()).isEqualTo(want.additionalHeaders());
    assertThat(have.subject()).isEqualTo(want.subject());
    assertThat(have.textContent()).isEqualTo(want.textContent());
    assertThat(have.htmlContent()).isEqualTo(want.htmlContent());
}
#end_block

#method_before
@Test
public void explicitZeroVoteOnNonEmptyRangeIsPresent() throws Exception {
    ProjectConfig pc = loadAllProjects();
    allow(pc, forLabel("Code-Review"), -1, 1, REGISTERED_USERS, "refs/heads/*");
    save(pc);
    PatchSetApproval cr = psa(userId, "Code-Review", 0);
    PatchSetApproval v = psa(userId, "Verified", 0);
    assertEquals(Result.create(list(cr), list(), list(v)), norm.normalize(notes, list(cr, v)));
}
#method_after
@Test
public void explicitZeroVoteOnNonEmptyRangeIsPresent() throws Exception {
    ProjectConfig pc = loadAllProjects();
    allow(pc, forLabel("Code-Review"), -1, 1, REGISTERED_USERS, "refs/heads/*");
    save(pc);
    PatchSetApproval cr = psa(userId, "Code-Review", 0);
    PatchSetApproval v = psa(userId, "Verified", 0);
    assertEquals(Result.create(list(cr, v), list(), list()), norm.normalize(notes, list(cr, v)));
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    assume().that(NoteDbMode.get()).isEqualTo(NoteDbMode.OFF);
    // Unlike in the running server, for tests, we don't stack notedb.config on gerrit.config.
    noteDbConfig = new FileBasedConfig(sitePaths.notedb_config.toFile(), FS.detect());
    assertNotesMigrationState(REVIEW_DB);
}
#method_after
@Before
public void setUp() throws Exception {
    assume().that(NoteDbMode.get()).isEqualTo(NoteDbMode.OFF);
    // Unlike in the running server, for tests, we don't stack notedb.config on gerrit.config.
    noteDbConfig = new FileBasedConfig(sitePaths.notedb_config.toFile(), FS.detect());
    assertNotesMigrationState(REVIEW_DB, false, false);
    addedListeners = new ArrayList<>();
}
#end_block

#method_before
@Test
public void preconditionsFail() throws Exception {
    List<Change.Id> cs = ImmutableList.of(new Change.Id(1));
    List<Project.NameKey> ps = ImmutableList.of(new Project.NameKey("p"));
    assertMigrationException("Cannot rebuild without noteDb.changes.write=true", b -> b, NoteDbMigrator::rebuild);
    assertMigrationException("Cannot set both changes and projects", b -> b.setChanges(cs).setProjects(ps), m -> {
    });
    assertMigrationException("Auto-migration cannot be used with trial mode", b -> b.setAutoMigrate(true).setTrialMode(true), m -> {
    });
    assertMigrationException("Cannot set changes or projects during full migration", b -> b.setChanges(cs), NoteDbMigrator::migrate);
    assertMigrationException("Cannot set changes or projects during full migration", b -> b.setProjects(ps), NoteDbMigrator::migrate);
    setNotesMigrationState(READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY);
    assertMigrationException("Migration has already progressed past the endpoint of the \"trial mode\" state", b -> b.setTrialMode(true), NoteDbMigrator::migrate);
    setNotesMigrationState(READ_WRITE_WITH_SEQUENCE_NOTE_DB_PRIMARY);
    assertMigrationException("Cannot force rebuild changes; NoteDb is already the primary storage for some changes", b -> b.setForceRebuild(true), NoteDbMigrator::migrate);
}
#method_after
@Test
public void preconditionsFail() throws Exception {
    List<Change.Id> cs = ImmutableList.of(new Change.Id(1));
    List<Project.NameKey> ps = ImmutableList.of(new Project.NameKey("p"));
    assertMigrationException("Cannot rebuild without noteDb.changes.write=true", b -> b, NoteDbMigrator::rebuild);
    assertMigrationException("Cannot set both changes and projects", b -> b.setChanges(cs).setProjects(ps), m -> {
    });
    assertMigrationException("Cannot set changes or projects during full migration", b -> b.setChanges(cs), NoteDbMigrator::migrate);
    assertMigrationException("Cannot set changes or projects during full migration", b -> b.setProjects(ps), NoteDbMigrator::migrate);
    setNotesMigrationState(READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY);
    assertMigrationException("Migration has already progressed past the endpoint of the \"trial mode\" state", b -> b.setTrialMode(true), NoteDbMigrator::migrate);
    setNotesMigrationState(READ_WRITE_WITH_SEQUENCE_NOTE_DB_PRIMARY);
    assertMigrationException("Cannot force rebuild changes; NoteDb is already the primary storage for some changes", b -> b.setForceRebuild(true), NoteDbMigrator::migrate);
}
#end_block

#method_before
@Test
public void rebuildOneChangeTrialModeAndForceRebuild() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getChange().getId();
    try (NoteDbMigrator migrator = migratorBuilderProvider.get().setTrialMode(true).build()) {
        migrator.migrate();
    }
    assertNotesMigrationState(READ_WRITE_NO_SEQUENCE);
    ObjectId oldMetaId;
    try (Repository repo = repoManager.openRepository(project);
        ReviewDb db = schemaFactory.open()) {
        Ref ref = repo.exactRef(RefNames.changeMetaRef(id));
        assertThat(ref).isNotNull();
        oldMetaId = ref.getObjectId();
        Change c = db.changes().get(id);
        assertThat(c).isNotNull();
        NoteDbChangeState state = NoteDbChangeState.parse(c);
        assertThat(state).isNotNull();
        assertThat(state.getPrimaryStorage()).isEqualTo(PrimaryStorage.REVIEW_DB);
        assertThat(state.getRefState()).hasValue(RefState.create(oldMetaId, ImmutableMap.of()));
        // Force change to be out of date, and change topic so it will get rebuilt as something other
        // than oldMetaId.
        c.setNoteDbState(INVALID_STATE);
        c.setTopic(name("a-new-topic"));
        db.changes().update(ImmutableList.of(c));
    }
    migrate(b -> b.setTrialMode(true));
    assertNotesMigrationState(READ_WRITE_NO_SEQUENCE);
    try (Repository repo = repoManager.openRepository(project);
        ReviewDb db = schemaFactory.open()) {
        // Change is out of date, but was not rebuilt without forceRebuild.
        assertThat(repo.exactRef(RefNames.changeMetaRef(id)).getObjectId()).isEqualTo(oldMetaId);
        Change c = db.changes().get(id);
        assertThat(c.getNoteDbState()).isEqualTo(INVALID_STATE);
    }
    migrate(b -> b.setTrialMode(true).setForceRebuild(true));
    assertNotesMigrationState(READ_WRITE_NO_SEQUENCE);
    try (Repository repo = repoManager.openRepository(project);
        ReviewDb db = schemaFactory.open()) {
        Ref ref = repo.exactRef(RefNames.changeMetaRef(id));
        assertThat(ref).isNotNull();
        ObjectId newMetaId = ref.getObjectId();
        assertThat(newMetaId).isNotEqualTo(oldMetaId);
        NoteDbChangeState state = NoteDbChangeState.parse(db.changes().get(id));
        assertThat(state).isNotNull();
        assertThat(state.getPrimaryStorage()).isEqualTo(PrimaryStorage.REVIEW_DB);
        assertThat(state.getRefState()).hasValue(RefState.create(newMetaId, ImmutableMap.of()));
    }
}
#method_after
@Test
public void rebuildOneChangeTrialModeAndForceRebuild() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getChange().getId();
    migrate(b -> b.setTrialMode(true));
    assertNotesMigrationState(READ_WRITE_NO_SEQUENCE, false, true);
    ObjectId oldMetaId;
    try (Repository repo = repoManager.openRepository(project);
        ReviewDb db = schemaFactory.open()) {
        Ref ref = repo.exactRef(RefNames.changeMetaRef(id));
        assertThat(ref).isNotNull();
        oldMetaId = ref.getObjectId();
        Change c = db.changes().get(id);
        assertThat(c).isNotNull();
        NoteDbChangeState state = NoteDbChangeState.parse(c);
        assertThat(state).isNotNull();
        assertThat(state.getPrimaryStorage()).isEqualTo(PrimaryStorage.REVIEW_DB);
        assertThat(state.getRefState()).hasValue(RefState.create(oldMetaId, ImmutableMap.of()));
        // Force change to be out of date, and change topic so it will get rebuilt as something other
        // than oldMetaId.
        c.setNoteDbState(INVALID_STATE);
        c.setTopic(name("a-new-topic"));
        db.changes().update(ImmutableList.of(c));
    }
    migrate(b -> b.setTrialMode(true));
    assertNotesMigrationState(READ_WRITE_NO_SEQUENCE, false, true);
    try (Repository repo = repoManager.openRepository(project);
        ReviewDb db = schemaFactory.open()) {
        // Change is out of date, but was not rebuilt without forceRebuild.
        assertThat(repo.exactRef(RefNames.changeMetaRef(id)).getObjectId()).isEqualTo(oldMetaId);
        Change c = db.changes().get(id);
        assertThat(c.getNoteDbState()).isEqualTo(INVALID_STATE);
    }
    migrate(b -> b.setTrialMode(true).setForceRebuild(true));
    assertNotesMigrationState(READ_WRITE_NO_SEQUENCE, false, true);
    try (Repository repo = repoManager.openRepository(project);
        ReviewDb db = schemaFactory.open()) {
        Ref ref = repo.exactRef(RefNames.changeMetaRef(id));
        assertThat(ref).isNotNull();
        ObjectId newMetaId = ref.getObjectId();
        assertThat(newMetaId).isNotEqualTo(oldMetaId);
        NoteDbChangeState state = NoteDbChangeState.parse(db.changes().get(id));
        assertThat(state).isNotNull();
        assertThat(state.getPrimaryStorage()).isEqualTo(PrimaryStorage.REVIEW_DB);
        assertThat(state.getRefState()).hasValue(RefState.create(newMetaId, ImmutableMap.of()));
    }
}
#end_block

#method_before
private void testFullMigration(int threads) throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = createChange();
    Change.Id id1 = r1.getChange().getId();
    Change.Id id2 = r2.getChange().getId();
    migrate(b -> b.setThreads(threads));
    assertNotesMigrationState(NOTE_DB);
    assertThat(sequences.nextChangeId()).isEqualTo(503);
    ObjectId oldMetaId = null;
    int rowVersion = 0;
    try (ReviewDb db = schemaFactory.open();
        Repository repo = repoManager.openRepository(project)) {
        for (Change.Id id : ImmutableList.of(id1, id2)) {
            String refName = RefNames.changeMetaRef(id);
            Ref ref = repo.exactRef(refName);
            assertThat(ref).named(refName).isNotNull();
            Change c = db.changes().get(id);
            assertThat(c.getTopic()).named("topic of change %s", id).isNull();
            NoteDbChangeState s = NoteDbChangeState.parse(c);
            assertThat(s.getPrimaryStorage()).named("primary storage of change %s", id).isEqualTo(PrimaryStorage.NOTE_DB);
            assertThat(s.getRefState()).named("ref state of change %s").isEmpty();
            if (id.equals(id1)) {
                oldMetaId = ref.getObjectId();
                rowVersion = c.getRowVersion();
            }
        }
    }
    // Do not open a new context, to simulate races with other threads that opened a context earlier
    // in the migration process; this needs to work.
    gApi.changes().id(id1.get()).topic(name("a-topic"));
    // Of course, it should also work with a new context.
    resetCurrentApiUser();
    gApi.changes().id(id1.get()).topic(name("another-topic"));
    try (ReviewDb db = schemaFactory.open();
        Repository repo = repoManager.openRepository(project)) {
        assertThat(repo.exactRef(RefNames.changeMetaRef(id1)).getObjectId()).isNotEqualTo(oldMetaId);
        Change c = db.changes().get(id1);
        assertThat(c.getTopic()).isNull();
        assertThat(c.getRowVersion()).isEqualTo(rowVersion);
    }
}
#method_after
private void testFullMigration(int threads) throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = createChange();
    Change.Id id1 = r1.getChange().getId();
    Change.Id id2 = r2.getChange().getId();
    migrate(b -> b.setThreads(threads));
    assertNotesMigrationState(NOTE_DB, false, false);
    assertThat(sequences.nextChangeId()).isEqualTo(503);
    ObjectId oldMetaId = null;
    int rowVersion = 0;
    try (ReviewDb db = schemaFactory.open();
        Repository repo = repoManager.openRepository(project)) {
        for (Change.Id id : ImmutableList.of(id1, id2)) {
            String refName = RefNames.changeMetaRef(id);
            Ref ref = repo.exactRef(refName);
            assertThat(ref).named(refName).isNotNull();
            Change c = db.changes().get(id);
            assertThat(c.getTopic()).named("topic of change %s", id).isNull();
            NoteDbChangeState s = NoteDbChangeState.parse(c);
            assertThat(s.getPrimaryStorage()).named("primary storage of change %s", id).isEqualTo(PrimaryStorage.NOTE_DB);
            assertThat(s.getRefState()).named("ref state of change %s").isEmpty();
            if (id.equals(id1)) {
                oldMetaId = ref.getObjectId();
                rowVersion = c.getRowVersion();
            }
        }
    }
    // Do not open a new context, to simulate races with other threads that opened a context earlier
    // in the migration process; this needs to work.
    gApi.changes().id(id1.get()).topic(name("a-topic"));
    // Of course, it should also work with a new context.
    resetCurrentApiUser();
    gApi.changes().id(id1.get()).topic(name("another-topic"));
    try (ReviewDb db = schemaFactory.open();
        Repository repo = repoManager.openRepository(project)) {
        assertThat(repo.exactRef(RefNames.changeMetaRef(id1)).getObjectId()).isNotEqualTo(oldMetaId);
        Change c = db.changes().get(id1);
        assertThat(c.getTopic()).isNull();
        assertThat(c.getRowVersion()).isEqualTo(rowVersion);
    }
}
#end_block

#method_before
@Test
public void autoMigrationConfig() throws Exception {
    createChange();
    migrate(b -> b.setStopAtStateForTesting(WRITE));
    assertNotesMigrationState(WRITE);
    assertThat(NoteDbMigrator.getAutoMigrate(noteDbConfig)).isFalse();
    migrate(b -> b.setAutoMigrate(true).setStopAtStateForTesting(READ_WRITE_NO_SEQUENCE));
    assertNotesMigrationState(READ_WRITE_NO_SEQUENCE);
    assertThat(NoteDbMigrator.getAutoMigrate(noteDbConfig)).isTrue();
    migrate(b -> b);
    assertNotesMigrationState(NOTE_DB);
    assertThat(NoteDbMigrator.getAutoMigrate(noteDbConfig)).isFalse();
}
#method_after
@Test
public void autoMigrationConfig() throws Exception {
    createChange();
    migrate(b -> b.setStopAtStateForTesting(WRITE));
    assertNotesMigrationState(WRITE, false, false);
    migrate(b -> b.setAutoMigrate(true).setStopAtStateForTesting(READ_WRITE_NO_SEQUENCE));
    assertNotesMigrationState(READ_WRITE_NO_SEQUENCE, true, false);
    migrate(b -> b);
    assertNotesMigrationState(NOTE_DB, false, false);
}
#end_block

#method_before
private void assertNotesMigrationState(NotesMigrationState expected) throws Exception {
    assertThat(NotesMigrationState.forNotesMigration(notesMigration)).hasValue(expected);
    noteDbConfig.load();
    assertThat(NotesMigrationState.forConfig(noteDbConfig)).hasValue(expected);
}
#method_after
private void assertNotesMigrationState(NotesMigrationState expected, boolean autoMigrate, boolean trialMode) throws Exception {
    assertThat(NotesMigrationState.forNotesMigration(notesMigration)).hasValue(expected);
    noteDbConfig.load();
    assertThat(NotesMigrationState.forConfig(noteDbConfig)).hasValue(expected);
    assertThat(NoteDbMigrator.getAutoMigrate(noteDbConfig)).named("noteDb.changes.autoMigrate").isEqualTo(autoMigrate);
    assertThat(NoteDbMigrator.getTrialMode(noteDbConfig)).named("noteDb.changes.trial").isEqualTo(trialMode);
}
#end_block

#method_before
private void assertMigrationException(String expectMessageContains, PrepareBuilder b, RunMigration m) throws Exception {
    try {
        migrate(b, m);
    } catch (MigrationException e) {
        assertThat(e).hasMessageThat().contains(expectMessageContains);
    }
}
#method_after
private void assertMigrationException(String expectMessageContains, PrepareBuilder b, RunMigration m) throws Exception {
    try {
        migrate(b, m);
        fail("expected MigrationException");
    } catch (MigrationException e) {
        assertThat(e).hasMessageThat().contains(expectMessageContains);
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    admins = groupCache.get(new AccountGroup.NameKey("Administrators")).getGroupUUID();
    setUpPermissions();
    setUpChanges();
}
#method_after
@Before
public void setUp() throws Exception {
    admins = groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID();
    setUpPermissions();
    setUpChanges();
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    Injector injector = Guice.createInjector(new InMemoryModule());
    injector.injectMembers(this);
    lifecycle = new LifecycleManager();
    lifecycle.add(injector);
    lifecycle.start();
    db = schemaFactory.open();
    schemaCreator.create(db);
    // Need to create at least one user to be admin before creating a "normal"
    // registered user.
    // See AccountManager#create().
    accountManager.authenticate(AuthRequest.forUser("admin")).getAccountId();
    admins = groupCache.get(new AccountGroup.NameKey("Administrators")).getGroupUUID();
    setUpPermissions();
    Account.Id userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    user = userFactory.create(userId);
    Project.NameKey name = new Project.NameKey("project");
    InMemoryRepository inMemoryRepo = repoManager.createRepository(name);
    project = new ProjectConfig(name);
    project.load(inMemoryRepo);
    repo = new TestRepository<>(inMemoryRepo);
    requestContext.setContext(new RequestContext() {

        @Override
        public CurrentUser getUser() {
            return user;
        }

        @Override
        public Provider<ReviewDb> getReviewDbProvider() {
            return Providers.of(db);
        }
    });
}
#method_after
@Before
public void setUp() throws Exception {
    Injector injector = Guice.createInjector(new InMemoryModule());
    injector.injectMembers(this);
    lifecycle = new LifecycleManager();
    lifecycle.add(injector);
    lifecycle.start();
    db = schemaFactory.open();
    schemaCreator.create(db);
    // Need to create at least one user to be admin before creating a "normal"
    // registered user.
    // See AccountManager#create().
    accountManager.authenticate(AuthRequest.forUser("admin")).getAccountId();
    admins = groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID();
    setUpPermissions();
    Account.Id userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    user = userFactory.create(userId);
    Project.NameKey name = new Project.NameKey("project");
    InMemoryRepository inMemoryRepo = repoManager.createRepository(name);
    project = new ProjectConfig(name);
    project.load(inMemoryRepo);
    repo = new TestRepository<>(inMemoryRepo);
    requestContext.setContext(new RequestContext() {

        @Override
        public CurrentUser getUser() {
            return user;
        }

        @Override
        public Provider<ReviewDb> getReviewDbProvider() {
            return Providers.of(db);
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    // Do NOT bind @RemotePeer, as it is bound in a child injector of
    // ChangeMergeQueue (bound via GerritGlobalModule below), so there cannot be
    // a binding in the parent injector. If you need @RemotePeer, you must bind
    // it in a child injector of the one containing InMemoryModule. But unless
    // you really need to test something request-scoped, you likely don't
    // actually need it.
    // For simplicity, don't create child injectors, just use this one to get a
    // few required modules.
    Injector cfgInjector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
        }
    });
    bind(MetricMaker.class).to(DisabledMetricMaker.class);
    install(cfgInjector.getInstance(GerritGlobalModule.class));
    install(new DefaultPermissionBackendModule());
    install(new SearchingChangeCacheImpl.Module());
    factory(GarbageCollection.Factory.class);
    bindScope(RequestScoped.class, PerThreadRequestScope.REQUEST);
    // TODO(dborowitz): Use jimfs.
    bind(Path.class).annotatedWith(SitePath.class).toInstance(Paths.get("."));
    bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
    bind(GerritOptions.class).toInstance(new GerritOptions(cfg, false, false, false));
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(String.class).annotatedWith(AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
    bind(String.class).annotatedWith(GerritServerId.class).toInstance("gerrit");
    bind(AllProjectsName.class).toProvider(AllProjectsNameProvider.class);
    bind(AllUsersName.class).toProvider(AllUsersNameProvider.class);
    bind(GitRepositoryManager.class).to(InMemoryRepositoryManager.class);
    bind(InMemoryRepositoryManager.class).in(SINGLETON);
    bind(TrackingFooters.class).toProvider(TrackingFootersProvider.class).in(SINGLETON);
    bind(MutableNotesMigration.class).toInstance(notesMigration);
    bind(NotesMigration.class).to(MutableNotesMigration.class);
    bind(ListeningExecutorService.class).annotatedWith(ChangeUpdateExecutor.class).toInstance(MoreExecutors.newDirectExecutorService());
    bind(DataSourceType.class).to(InMemoryH2Type.class);
    bind(ChangeBundleReader.class).to(GwtormChangeBundleReader.class);
    bind(SecureStore.class).to(DefaultSecureStore.class);
    TypeLiteral<SchemaFactory<ReviewDb>> schemaFactory = new TypeLiteral<SchemaFactory<ReviewDb>>() {
    };
    bind(schemaFactory).to(NotesMigrationSchemaFactory.class);
    bind(Key.get(schemaFactory, ReviewDbFactory.class)).to(InMemoryDatabase.class);
    install(NoSshKeyCache.module());
    install(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return CanonicalWebUrlProvider.class;
        }
    });
    // Replacement of DiffExecutorModule to not use thread pool in the tests
    install(new AbstractModule() {

        @Override
        protected void configure() {
        }

        @Provides
        @Singleton
        @DiffExecutor
        public ExecutorService createDiffExecutor() {
            return MoreExecutors.newDirectExecutorService();
        }
    });
    install(new DefaultCacheFactory.Module());
    install(new FakeEmailSender.Module());
    install(new SignedTokenEmailTokenVerifier.Module());
    install(new GpgModule(cfg));
    install(new InMemoryAccountPatchReviewStore.Module());
    bind(AllAccountsIndexer.class).toProvider(Providers.of(null));
    bind(AllChangesIndexer.class).toProvider(Providers.of(null));
    bind(AllGroupsIndexer.class).toProvider(Providers.of(null));
    IndexType indexType = null;
    try {
        indexType = cfg.getEnum("index", null, "type", IndexType.LUCENE);
    } catch (IllegalArgumentException e) {
    // Custom index type, caller must provide their own module.
    }
    if (indexType != null) {
        switch(indexType) {
            case LUCENE:
                install(luceneIndexModule());
                break;
            case ELASTICSEARCH:
                install(elasticIndexModule());
                break;
            default:
                throw new ProvisionException("index type unsupported in tests: " + indexType);
        }
    }
    bind(ServerInformationImpl.class);
    bind(ServerInformation.class).to(ServerInformationImpl.class);
    install(new PluginRestApiModule());
}
#method_after
@Override
protected void configure() {
    // Do NOT bind @RemotePeer, as it is bound in a child injector of
    // ChangeMergeQueue (bound via GerritGlobalModule below), so there cannot be
    // a binding in the parent injector. If you need @RemotePeer, you must bind
    // it in a child injector of the one containing InMemoryModule. But unless
    // you really need to test something request-scoped, you likely don't
    // actually need it.
    // For simplicity, don't create child injectors, just use this one to get a
    // few required modules.
    Injector cfgInjector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
        }
    });
    bind(MetricMaker.class).to(DisabledMetricMaker.class);
    install(cfgInjector.getInstance(GerritGlobalModule.class));
    install(new DefaultPermissionBackendModule());
    install(new SearchingChangeCacheImpl.Module());
    factory(GarbageCollection.Factory.class);
    bindScope(RequestScoped.class, PerThreadRequestScope.REQUEST);
    // TODO(dborowitz): Use jimfs.
    bind(Path.class).annotatedWith(SitePath.class).toInstance(Paths.get("."));
    bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
    bind(GerritOptions.class).toInstance(new GerritOptions(cfg, false, false, false));
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(String.class).annotatedWith(AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
    bind(String.class).annotatedWith(GerritServerId.class).toInstance("gerrit");
    bind(AllProjectsName.class).toProvider(AllProjectsNameProvider.class);
    bind(AllUsersName.class).toProvider(AllUsersNameProvider.class);
    bind(GitRepositoryManager.class).to(InMemoryRepositoryManager.class);
    bind(InMemoryRepositoryManager.class).in(SINGLETON);
    bind(TrackingFooters.class).toProvider(TrackingFootersProvider.class).in(SINGLETON);
    bind(MutableNotesMigration.class).toInstance(notesMigration);
    bind(NotesMigration.class).to(MutableNotesMigration.class);
    bind(ListeningExecutorService.class).annotatedWith(ChangeUpdateExecutor.class).toInstance(MoreExecutors.newDirectExecutorService());
    bind(DataSourceType.class).to(InMemoryH2Type.class);
    bind(ChangeBundleReader.class).to(GwtormChangeBundleReader.class);
    bind(SecureStore.class).to(DefaultSecureStore.class);
    TypeLiteral<SchemaFactory<ReviewDb>> schemaFactory = new TypeLiteral<SchemaFactory<ReviewDb>>() {
    };
    bind(schemaFactory).to(NotesMigrationSchemaFactory.class);
    bind(Key.get(schemaFactory, ReviewDbFactory.class)).to(InMemoryDatabase.class);
    install(NoSshKeyCache.module());
    install(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return CanonicalWebUrlProvider.class;
        }
    });
    // Replacement of DiffExecutorModule to not use thread pool in the tests
    install(new AbstractModule() {

        @Override
        protected void configure() {
        }

        @Provides
        @Singleton
        @DiffExecutor
        public ExecutorService createDiffExecutor() {
            return MoreExecutors.newDirectExecutorService();
        }
    });
    install(new DefaultCacheFactory.Module());
    install(new FakeEmailSender.Module());
    install(new SignedTokenEmailTokenVerifier.Module());
    install(new GpgModule(cfg));
    install(new InMemoryAccountPatchReviewStore.Module());
    install(new LocalMergeSuperSetComputation.Module());
    bind(AllAccountsIndexer.class).toProvider(Providers.of(null));
    bind(AllChangesIndexer.class).toProvider(Providers.of(null));
    bind(AllGroupsIndexer.class).toProvider(Providers.of(null));
    IndexType indexType = null;
    try {
        indexType = cfg.getEnum("index", null, "type", IndexType.LUCENE);
    } catch (IllegalArgumentException e) {
    // Custom index type, caller must provide their own module.
    }
    if (indexType != null) {
        switch(indexType) {
            case LUCENE:
                install(luceneIndexModule());
                break;
            case ELASTICSEARCH:
                install(elasticIndexModule());
                break;
            default:
                throw new ProvisionException("index type unsupported in tests: " + indexType);
        }
    }
    bind(ServerInformationImpl.class);
    bind(ServerInformation.class).to(ServerInformationImpl.class);
    install(new PluginRestApiModule());
    install(new DefaultProjectNameLockManager.Module());
}
#end_block

#method_before
private Map<String, Integer> getSingleSchemaVersions() {
    Map<String, Integer> singleVersions = new HashMap<>();
    putSchemaVersion(singleVersions, AccountSchemaDefinitions.INSTANCE);
    putSchemaVersion(singleVersions, ChangeSchemaDefinitions.INSTANCE);
    putSchemaVersion(singleVersions, GroupSchemaDefinitions.INSTANCE);
    return singleVersions;
}
#method_after
private Map<String, Integer> getSingleSchemaVersions() {
    Map<String, Integer> singleVersions = new HashMap<>();
    putSchemaVersion(singleVersions, AccountSchemaDefinitions.INSTANCE);
    putSchemaVersion(singleVersions, ChangeSchemaDefinitions.INSTANCE);
    putSchemaVersion(singleVersions, GroupSchemaDefinitions.INSTANCE);
    putSchemaVersion(singleVersions, ProjectSchemaDefinitions.INSTANCE);
    return singleVersions;
}
#end_block

#method_before
protected void assertNew(String changeId) throws Exception {
    assertThat(get(changeId).status).isEqualTo(ChangeStatus.NEW);
}
#method_after
protected void assertNew(String changeId) throws Exception {
    assertThat(info(changeId).status).isEqualTo(ChangeStatus.NEW);
}
#end_block

#method_before
@Test
public void doesNotIncludeCurrentFiles() throws Exception {
    RevCommit c1_1 = commitBuilder().add("a.txt", "1").message("subject: 1").create();
    RevCommit c2_1 = commitBuilder().add("b.txt", "2").message("subject: 2").create();
    String id2 = getChangeId(c2_1);
    pushHead(testRepo, "refs/for/master", false);
    SubmittedTogetherInfo info = gApi.changes().id(id2).submittedTogether(EnumSet.of(NON_VISIBLE_CHANGES));
    assertThat(info.changes).hasSize(2);
    assertThat(info.changes.get(0).currentRevision).isEqualTo(c2_1.name());
    assertThat(info.changes.get(1).currentRevision).isEqualTo(c1_1.name());
    assertThat(info.changes.get(0).currentRevision).isEqualTo(c2_1.name());
    RevisionInfo rev = info.changes.get(0).revisions.get(c2_1.name());
    assertThat(rev.files).isNull();
}
#method_after
@Test
public void doesNotIncludeCurrentFiles() throws Exception {
    RevCommit c1_1 = commitBuilder().add("a.txt", "1").message("subject: 1").create();
    RevCommit c2_1 = commitBuilder().add("b.txt", "2").message("subject: 2").create();
    String id2 = getChangeId(c2_1);
    pushHead(testRepo, "refs/for/master", false);
    SubmittedTogetherInfo info = gApi.changes().id(id2).submittedTogether(EnumSet.of(NON_VISIBLE_CHANGES));
    assertThat(info.changes).hasSize(2);
    assertThat(info.changes.get(0).currentRevision).isEqualTo(c2_1.name());
    assertThat(info.changes.get(1).currentRevision).isEqualTo(c1_1.name());
    RevisionInfo rev = info.changes.get(0).revisions.get(c2_1.name());
    assertThat(rev.files).isNull();
}
#end_block

#method_before
@Test
public void returnsCurrentFilesIfOptionRequested() throws Exception {
    RevCommit c1_1 = commitBuilder().add("a.txt", "1").message("subject: 1").create();
    RevCommit c2_1 = commitBuilder().add("b.txt", "2").message("subject: 2").create();
    String id2 = getChangeId(c2_1);
    pushHead(testRepo, "refs/for/master", false);
    SubmittedTogetherInfo info = gApi.changes().id(id2).submittedTogether(EnumSet.of(ListChangesOption.CURRENT_FILES), EnumSet.of(NON_VISIBLE_CHANGES));
    assertThat(info.changes).hasSize(2);
    assertThat(info.changes.get(0).currentRevision).isEqualTo(c2_1.name());
    assertThat(info.changes.get(1).currentRevision).isEqualTo(c1_1.name());
    assertThat(info.changes.get(0).currentRevision).isEqualTo(c2_1.name());
    RevisionInfo rev = info.changes.get(0).revisions.get(c2_1.name());
    assertThat(rev).isNotNull();
    FileInfo file = rev.files.get("b.txt");
    assertThat(file).isNotNull();
    assertThat(file.status).isEqualTo('A');
}
#method_after
@Test
public void returnsCurrentFilesIfOptionRequested() throws Exception {
    RevCommit c1_1 = commitBuilder().add("a.txt", "1").message("subject: 1").create();
    RevCommit c2_1 = commitBuilder().add("b.txt", "2").message("subject: 2").create();
    String id2 = getChangeId(c2_1);
    pushHead(testRepo, "refs/for/master", false);
    SubmittedTogetherInfo info = gApi.changes().id(id2).submittedTogether(EnumSet.of(ListChangesOption.CURRENT_FILES), EnumSet.of(NON_VISIBLE_CHANGES));
    assertThat(info.changes).hasSize(2);
    assertThat(info.changes.get(0).currentRevision).isEqualTo(c2_1.name());
    assertThat(info.changes.get(1).currentRevision).isEqualTo(c1_1.name());
    RevisionInfo rev = info.changes.get(0).revisions.get(c2_1.name());
    assertThat(rev).isNotNull();
    FileInfo file = rev.files.get("b.txt");
    assertThat(file).isNotNull();
    assertThat(file.status).isEqualTo('A');
}
#end_block

#method_before
@Test
public void topicChaining() throws Exception {
    RevCommit initialHead = getRemoteHead();
    // Create two independent commits and push.
    RevCommit c1_1 = commitBuilder().add("a.txt", "1").message("subject: 1").create();
    String id1 = getChangeId(c1_1);
    pushHead(testRepo, "refs/for/master/" + name("connectingTopic"), false);
    testRepo.reset(initialHead);
    RevCommit c2_1 = commitBuilder().add("b.txt", "2").message("subject: 2").create();
    String id2 = getChangeId(c2_1);
    pushHead(testRepo, "refs/for/master/" + name("connectingTopic"), false);
    RevCommit c3_1 = commitBuilder().add("b.txt", "2").message("subject: 2").create();
    String id3 = getChangeId(c3_1);
    pushHead(testRepo, "refs/for/master/" + name("unrelated-topic"), false);
    if (isSubmitWholeTopicEnabled()) {
        assertSubmittedTogether(id1, id2, id1);
        assertSubmittedTogether(id2, id2, id1);
        assertSubmittedTogether(id3, id3, id2, id1);
    } else {
        assertSubmittedTogether(id1);
        assertSubmittedTogether(id2);
        assertSubmittedTogether(id3, id3, id2);
    }
}
#method_after
@Test
public void topicChaining() throws Exception {
    RevCommit initialHead = getRemoteHead();
    RevCommit c1_1 = commitBuilder().add("a.txt", "1").message("subject: 1").create();
    String id1 = getChangeId(c1_1);
    pushHead(testRepo, "refs/for/master/" + name("connectingTopic"), false);
    testRepo.reset(initialHead);
    RevCommit c2_1 = commitBuilder().add("b.txt", "2").message("subject: 2").create();
    String id2 = getChangeId(c2_1);
    pushHead(testRepo, "refs/for/master/" + name("connectingTopic"), false);
    RevCommit c3_1 = commitBuilder().add("b.txt", "3").message("subject: 3").create();
    String id3 = getChangeId(c3_1);
    pushHead(testRepo, "refs/for/master/" + name("unrelated-topic"), false);
    if (isSubmitWholeTopicEnabled()) {
        assertSubmittedTogether(id1, id2, id1);
        assertSubmittedTogether(id2, id2, id1);
        assertSubmittedTogether(id3, id3, id2, id1);
    } else {
        assertSubmittedTogether(id1);
        assertSubmittedTogether(id2);
        assertSubmittedTogether(id3, id3, id2);
    }
}
#end_block

#method_before
@Test
public void voteOnBehalfOfInvalidLabel() throws Exception {
    allowCodeReviewOnBehalfOf();
    PushOneCommit.Result r = createChange();
    RevisionApi revision = gApi.changes().id(r.getChangeId()).current();
    ReviewInput in = new ReviewInput();
    in.onBehalfOf = user.id.toString();
    in.strictLabels = true;
    in.label("Not-A-Label", 5);
    exception.expect(BadRequestException.class);
    exception.expectMessage("label \"Not-A-Label\" is not a configured label");
    revision.review(in);
}
#method_after
@Test
public void voteOnBehalfOfInvalidLabel() throws Exception {
    allowCodeReviewOnBehalfOf();
    PushOneCommit.Result r = createChange();
    RevisionApi revision = gApi.changes().id(r.getChangeId()).current();
    ReviewInput in = new ReviewInput();
    in.onBehalfOf = user.id.toString();
    in.label("Not-A-Label", 5);
    exception.expect(BadRequestException.class);
    exception.expectMessage("label \"Not-A-Label\" is not a configured label");
    revision.review(in);
}
#end_block

#method_before
@Test
public void currentRevisionActionVisitor() throws Exception {
    String id = createChange().getChangeId();
    amendChange(id);
    ChangeInfo origChange = gApi.changes().id(id).get(CHANGE_ACTIONS);
    Change.Id changeId = new Change.Id(origChange._number);
    class Visitor implements ActionVisitor {

        @Override
        public boolean visit(String name, ActionInfo actionInfo, ChangeInfo changeInfo) {
            // Do nothing; implicitly called for CURRENT_ACTIONS.
            return true;
        }

        @Override
        public boolean visit(String name, ActionInfo actionInfo, ChangeInfo changeInfo, RevisionInfo revisionInfo) {
            assertThat(changeInfo).isNotNull();
            assertThat(changeInfo._number).isEqualTo(origChange._number);
            assertThat(revisionInfo).isNotNull();
            assertThat(revisionInfo._number).isEqualTo(2);
            if (name.equals("cherrypick")) {
                return false;
            }
            if (name.equals("rebase")) {
                actionInfo.label = "All Your Base";
            }
            return true;
        }
    }
    Map<String, ActionInfo> origActions = gApi.changes().id(id).current().actions();
    assertThat(origActions.keySet()).containsAllOf("cherrypick", "rebase");
    assertThat(origActions.get("rebase").label).isEqualTo("Rebase");
    Visitor v = new Visitor();
    visitorHandle = actionVisitors.add(v);
    // Test different codepaths within ActionJson...
    // ...via revision API.
    visitedCurrentRevisionActionsAssertions(origActions, gApi.changes().id(id).current().actions());
    // ...via change API with option.
    EnumSet<ListChangesOption> opts = EnumSet.of(CURRENT_ACTIONS, CURRENT_REVISION);
    ChangeInfo changeInfo = gApi.changes().id(id).get(opts);
    RevisionInfo revisionInfo = Iterables.getOnlyElement(changeInfo.revisions.values());
    visitedCurrentRevisionActionsAssertions(origActions, revisionInfo.actions);
    // ...via ChangeJson directly.
    ChangeData cd = changeDataFactory.create(db, project, changeId);
    revisionInfo = changeJsonFactory.create(opts).getRevisionInfo(cd.changeControl(), cd.patchSet(new PatchSet.Id(changeId, 1)));
}
#method_after
@Test
public void currentRevisionActionVisitor() throws Exception {
    String id = createChange().getChangeId();
    amendChange(id);
    ChangeInfo origChange = gApi.changes().id(id).get(CHANGE_ACTIONS);
    Change.Id changeId = new Change.Id(origChange._number);
    class Visitor implements ActionVisitor {

        @Override
        public boolean visit(String name, ActionInfo actionInfo, ChangeInfo changeInfo) {
            // Do nothing; implicitly called for CURRENT_ACTIONS.
            return true;
        }

        @Override
        public boolean visit(String name, ActionInfo actionInfo, ChangeInfo changeInfo, RevisionInfo revisionInfo) {
            assertThat(changeInfo).isNotNull();
            assertThat(changeInfo._number).isEqualTo(origChange._number);
            assertThat(revisionInfo).isNotNull();
            assertThat(revisionInfo._number).isEqualTo(2);
            if (name.equals("cherrypick")) {
                return false;
            }
            if (name.equals("rebase")) {
                actionInfo.label = "All Your Base";
            }
            return true;
        }
    }
    Map<String, ActionInfo> origActions = gApi.changes().id(id).current().actions();
    assertThat(origActions.keySet()).containsAllOf("cherrypick", "rebase");
    assertThat(origActions.get("rebase").label).isEqualTo("Rebase");
    Visitor v = new Visitor();
    visitorHandle = actionVisitors.add(v);
    // Test different codepaths within ActionJson...
    // ...via revision API.
    visitedCurrentRevisionActionsAssertions(origActions, gApi.changes().id(id).current().actions());
    // ...via change API with option.
    EnumSet<ListChangesOption> opts = EnumSet.of(CURRENT_ACTIONS, CURRENT_REVISION);
    ChangeInfo changeInfo = gApi.changes().id(id).get(opts);
    RevisionInfo revisionInfo = Iterables.getOnlyElement(changeInfo.revisions.values());
    visitedCurrentRevisionActionsAssertions(origActions, revisionInfo.actions);
    // ...via ChangeJson directly.
    ChangeData cd = changeDataFactory.create(db, project, changeId);
    revisionInfo = changeJsonFactory.create(opts).getRevisionInfo(cd, cd.patchSet(new PatchSet.Id(changeId, 1)));
}
#end_block

#method_before
@Test
public void patchSetStates() throws Exception {
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    incrementCurrentPatchSetFieldOnly(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    RevCommit commit = tr.commit().message("PS2").create();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setCommit(rw, commit);
    update.setPatchSetState(PatchSetState.DRAFT);
    update.putApproval("Code-Review", (short) 1);
    update.setChangeMessage("This is a message");
    update.putComment(Status.PUBLISHED, newComment(c.currentPatchSetId(), "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, TimeUtil.nowTs(), "Comment", (short) 1, commit.name(), false));
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getPatchSets().get(psId2).isDraft()).isTrue();
    assertThat(notes.getPatchSets().keySet()).containsExactly(psId1, psId2);
    assertThat(notes.getApprovals()).isNotEmpty();
    assertThat(notes.getChangeMessagesByPatchSet()).isNotEmpty();
    assertThat(notes.getChangeMessages()).isNotEmpty();
    assertThat(notes.getComments()).isNotEmpty();
    // publish ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetState(PatchSetState.PUBLISHED);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getPatchSets().get(psId2).isDraft()).isFalse();
    // delete ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetState(PatchSetState.DELETED);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getPatchSets().keySet()).containsExactly(psId1);
    assertThat(notes.getApprovals()).isEmpty();
    assertThat(notes.getChangeMessagesByPatchSet()).isEmpty();
    assertThat(notes.getChangeMessages()).isEmpty();
    assertThat(notes.getComments()).isEmpty();
}
#method_after
@Test
public void patchSetStates() throws Exception {
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    incrementCurrentPatchSetFieldOnly(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    RevCommit commit = tr.commit().message("PS2").create();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setCommit(rw, commit);
    update.putApproval("Code-Review", (short) 1);
    update.setChangeMessage("This is a message");
    update.putComment(Status.PUBLISHED, newComment(c.currentPatchSetId(), "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, TimeUtil.nowTs(), "Comment", (short) 1, commit.name(), false));
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getPatchSets().keySet()).containsExactly(psId1, psId2);
    assertThat(notes.getApprovals()).isNotEmpty();
    assertThat(notes.getChangeMessagesByPatchSet()).isNotEmpty();
    assertThat(notes.getChangeMessages()).isNotEmpty();
    assertThat(notes.getComments()).isNotEmpty();
    // publish ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetState(PatchSetState.PUBLISHED);
    update.commit();
    // delete ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetState(PatchSetState.DELETED);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getPatchSets().keySet()).containsExactly(psId1);
    assertThat(notes.getApprovals()).isEmpty();
    assertThat(notes.getChangeMessagesByPatchSet()).isEmpty();
    assertThat(notes.getChangeMessages()).isEmpty();
    assertThat(notes.getComments()).isEmpty();
}
#end_block

#method_before
@Test
public void abandon() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    assertThat(info(changeId).status).isEqualTo(ChangeStatus.NEW);
    gApi.changes().id(changeId).abandon();
    ChangeInfo info = get(changeId);
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("abandoned");
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("change is abandoned");
    gApi.changes().id(changeId).abandon();
}
#method_after
@Test
public void abandon() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    assertThat(info(changeId).status).isEqualTo(ChangeStatus.NEW);
    gApi.changes().id(changeId).abandon();
    ChangeInfo info = get(changeId, MESSAGES);
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("abandoned");
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("change is abandoned");
    gApi.changes().id(changeId).abandon();
}
#end_block

#method_before
@Test
public void batchAbandon() throws Exception {
    CurrentUser user = atrScope.get().getUser();
    PushOneCommit.Result a = createChange();
    PushOneCommit.Result b = createChange();
    List<ChangeData> list = ImmutableList.of(a.getChange(), b.getChange());
    changeAbandoner.batchAbandon(batchUpdateFactory, a.getChange().project(), user, list, "deadbeef");
    ChangeInfo info = get(a.getChangeId());
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("abandoned");
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("deadbeef");
    info = get(b.getChangeId());
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("abandoned");
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("deadbeef");
}
#method_after
@Test
public void batchAbandon() throws Exception {
    CurrentUser user = atrScope.get().getUser();
    PushOneCommit.Result a = createChange();
    PushOneCommit.Result b = createChange();
    List<ChangeData> list = ImmutableList.of(a.getChange(), b.getChange());
    changeAbandoner.batchAbandon(batchUpdateFactory, a.getChange().project(), user, list, "deadbeef");
    ChangeInfo info = get(a.getChangeId(), MESSAGES);
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("abandoned");
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("deadbeef");
    info = get(b.getChangeId(), MESSAGES);
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("abandoned");
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("deadbeef");
}
#end_block

#method_before
@Test
public void restore() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    assertThat(info(changeId).status).isEqualTo(ChangeStatus.NEW);
    gApi.changes().id(changeId).abandon();
    assertThat(info(changeId).status).isEqualTo(ChangeStatus.ABANDONED);
    gApi.changes().id(changeId).restore();
    ChangeInfo info = get(changeId);
    assertThat(info.status).isEqualTo(ChangeStatus.NEW);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("restored");
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("change is new");
    gApi.changes().id(changeId).restore();
}
#method_after
@Test
public void restore() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    assertThat(info(changeId).status).isEqualTo(ChangeStatus.NEW);
    gApi.changes().id(changeId).abandon();
    assertThat(info(changeId).status).isEqualTo(ChangeStatus.ABANDONED);
    gApi.changes().id(changeId).restore();
    ChangeInfo info = get(changeId, MESSAGES);
    assertThat(info.status).isEqualTo(ChangeStatus.NEW);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("restored");
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("change is new");
    gApi.changes().id(changeId).restore();
}
#end_block

#method_before
@Before
public void setUp() {
    String tz = "US/Eastern";
    systemTimeZoneProperty = System.setProperty("user.timezone", tz);
    systemTimeZone = TimeZone.getDefault();
    TimeZone.setDefault(TimeZone.getTimeZone(tz));
    long maxMs = ChangeRebuilderImpl.MAX_WINDOW_MS;
    assertThat(maxMs).isGreaterThan(1000L);
    TestTimeUtil.resetWithClockStep(maxMs * 2, MILLISECONDS);
    project = new Project.NameKey("project");
    accountId = new Account.Id(100);
}
#method_after
@Before
public void setUp() {
    systemTimeZoneProperty = System.setProperty("user.timezone", TIMEZONE_ID);
    systemTimeZone = TimeZone.getDefault();
    TimeZone.setDefault(TimeZone.getTimeZone(TIMEZONE_ID));
    long maxMs = ChangeRebuilderImpl.MAX_WINDOW_MS;
    assertThat(maxMs).isGreaterThan(1000L);
    TestTimeUtil.resetWithClockStep(maxMs * 2, MILLISECONDS);
    project = new Project.NameKey("project");
    accountId = new Account.Id(100);
}
#end_block

#method_before
@Test
public void diffPatchSetApprovalsAllowsTruncatedTimestampInNoteDb() throws Exception {
    Change c = TestChanges.newChange(project, accountId);
    PatchSetApproval a1 = new PatchSetApproval(new PatchSetApproval.Key(c.currentPatchSetId(), accountId, new LabelId("Code-Review")), (short) 1, c.getCreatedOn());
    PatchSetApproval a2 = clone(a1);
    a2.setGranted(new Timestamp(new DateTime(1900, 1, 1, 0, 0, 0, DateTimeZone.forTimeZone(TimeZone.getDefault())).getMillis()));
    // Both are ReviewDb, exact match is required.
    ChangeBundle b1 = new ChangeBundle(c, messages(), latest(c), approvals(a1), comments(), reviewers(), REVIEW_DB);
    ChangeBundle b2 = new ChangeBundle(c, messages(), latest(c), approvals(a2), comments(), reviewers(), REVIEW_DB);
    assertDiffs(b1, b2, "granted differs for PatchSetApproval.Key " + c.getId() + "%2C1,100,Code-Review:" + " {2009-09-30 17:00:00.0} != {1900-01-01 00:00:00.0}");
    // Truncating NoteDb timestamp is allowed.
    b1 = new ChangeBundle(c, messages(), latest(c), approvals(a1), comments(), reviewers(), NOTE_DB);
    b2 = new ChangeBundle(c, messages(), latest(c), approvals(a2), comments(), reviewers(), REVIEW_DB);
    assertNoDiffs(b1, b2);
    assertNoDiffs(b2, b1);
}
#method_after
@Test
public void diffPatchSetApprovalsAllowsTruncatedTimestampInNoteDb() throws Exception {
    Change c = TestChanges.newChange(project, accountId);
    PatchSetApproval a1 = new PatchSetApproval(new PatchSetApproval.Key(c.currentPatchSetId(), accountId, new LabelId("Code-Review")), (short) 1, c.getCreatedOn());
    PatchSetApproval a2 = clone(a1);
    a2.setGranted(new Timestamp(LocalDate.of(1900, Month.JANUARY, 1).atStartOfDay().atZone(ZoneId.of(TIMEZONE_ID)).toInstant().toEpochMilli()));
    // Both are ReviewDb, exact match is required.
    ChangeBundle b1 = new ChangeBundle(c, messages(), latest(c), approvals(a1), comments(), reviewers(), REVIEW_DB);
    ChangeBundle b2 = new ChangeBundle(c, messages(), latest(c), approvals(a2), comments(), reviewers(), REVIEW_DB);
    assertDiffs(b1, b2, "granted differs for PatchSetApproval.Key " + c.getId() + "%2C1,100,Code-Review:" + " {2009-09-30 17:00:00.0} != {1900-01-01 00:00:00.0}");
    // Truncating NoteDb timestamp is allowed.
    b1 = new ChangeBundle(c, messages(), latest(c), approvals(a1), comments(), reviewers(), NOTE_DB);
    b2 = new ChangeBundle(c, messages(), latest(c), approvals(a2), comments(), reviewers(), REVIEW_DB);
    assertNoDiffs(b1, b2);
    assertNoDiffs(b2, b1);
}
#end_block

#method_before
public static synchronized void resetWithClockStep(long clockStep, TimeUnit clockStepUnit) {
    // Set an arbitrary start point so tests are more repeatable.
    clockMs = new AtomicLong(START.getMillis());
    setClockStep(clockStep, clockStepUnit);
}
#method_after
public static synchronized void resetWithClockStep(long clockStep, TimeUnit clockStepUnit) {
    // Set an arbitrary start point so tests are more repeatable.
    clockMs = new AtomicLong(START.toEpochMilli());
    setClockStep(clockStep, clockStepUnit);
}
#end_block

#method_before
public static synchronized void setClockStep(long clockStep, TimeUnit clockStepUnit) {
    checkState(clockMs != null, "call resetWithClockStep first");
    clockStepMs = MILLISECONDS.convert(clockStep, clockStepUnit);
    DateTimeUtils.setCurrentMillisProvider(new MillisProvider() {

        @Override
        public long getMillis() {
            return clockMs.getAndAdd(clockStepMs);
        }
    });
}
#method_after
public static synchronized void setClockStep(long clockStep, TimeUnit clockStepUnit) {
    checkState(clockMs != null, "call resetWithClockStep first");
    clockStepMs = MILLISECONDS.convert(clockStep, clockStepUnit);
    TimeUtil.setCurrentMillisSupplier(() -> clockMs.getAndAdd(clockStepMs));
}
#end_block

#method_before
public static synchronized void useSystemTime() {
    clockMs = null;
    DateTimeUtils.setCurrentMillisSystem();
}
#method_after
public static synchronized void useSystemTime() {
    clockMs = null;
    TimeUtil.resetCurrentMillisSupplier();
}
#end_block

#method_before
private void testOnlineMigration(StartServerWithMigration start) throws Exception {
    assertNotesMigrationState(NotesMigrationState.REVIEW_DB);
    int prevVersion = ChangeSchemaDefinitions.INSTANCE.getPrevious().getVersion();
    int currVersion = ChangeSchemaDefinitions.INSTANCE.getLatest().getVersion();
    // Before storing any changes, switch back to the previous version.
    GerritIndexStatus status = new GerritIndexStatus(sitePaths);
    status.setReady(ChangeSchemaDefinitions.NAME, currVersion, false);
    status.setReady(ChangeSchemaDefinitions.NAME, prevVersion, true);
    status.save();
    setOnlineUpgradeConfig(false);
    setUpOneChange();
    setOnlineUpgradeConfig(true);
    IndexUpgradeController u = new IndexUpgradeController(1);
    try (ServerContext ctx = start.start(u)) {
        ChangeIndexCollection indexes = ctx.getInjector().getInstance(ChangeIndexCollection.class);
        assertThat(indexes.getSearchIndex().getSchema().getVersion()).isEqualTo(prevVersion);
        // Index schema upgrades happen after NoteDb migration, so waiting for those to complete
        // should be sufficient.
        u.runUpgrades();
        assertThat(indexes.getSearchIndex().getSchema().getVersion()).isEqualTo(currVersion);
        assertNotesMigrationState(NotesMigrationState.NOTE_DB);
    }
}
#method_after
private void testOnlineMigration(StartServerWithMigration start) throws Exception {
    testOnlineMigration(start, NotesMigrationState.NOTE_DB);
}
#end_block

#method_before
private void testOnlineMigration(StartServerWithMigration start) throws Exception {
    assertNotesMigrationState(NotesMigrationState.REVIEW_DB);
    int prevVersion = ChangeSchemaDefinitions.INSTANCE.getPrevious().getVersion();
    int currVersion = ChangeSchemaDefinitions.INSTANCE.getLatest().getVersion();
    // Before storing any changes, switch back to the previous version.
    GerritIndexStatus status = new GerritIndexStatus(sitePaths);
    status.setReady(ChangeSchemaDefinitions.NAME, currVersion, false);
    status.setReady(ChangeSchemaDefinitions.NAME, prevVersion, true);
    status.save();
    setOnlineUpgradeConfig(false);
    setUpOneChange();
    setOnlineUpgradeConfig(true);
    IndexUpgradeController u = new IndexUpgradeController(1);
    try (ServerContext ctx = start.start(u)) {
        ChangeIndexCollection indexes = ctx.getInjector().getInstance(ChangeIndexCollection.class);
        assertThat(indexes.getSearchIndex().getSchema().getVersion()).isEqualTo(prevVersion);
        // Index schema upgrades happen after NoteDb migration, so waiting for those to complete
        // should be sufficient.
        u.runUpgrades();
        assertThat(indexes.getSearchIndex().getSchema().getVersion()).isEqualTo(currVersion);
        assertNotesMigrationState(NotesMigrationState.NOTE_DB);
    }
}
#method_after
private void testOnlineMigration(StartServerWithMigration start, NotesMigrationState expectedEndState) throws Exception {
    assertNotesMigrationState(NotesMigrationState.REVIEW_DB);
    int prevVersion = ChangeSchemaDefinitions.INSTANCE.getPrevious().getVersion();
    int currVersion = ChangeSchemaDefinitions.INSTANCE.getLatest().getVersion();
    // Before storing any changes, switch back to the previous version.
    GerritIndexStatus status = new GerritIndexStatus(sitePaths);
    status.setReady(ChangeSchemaDefinitions.NAME, currVersion, false);
    status.setReady(ChangeSchemaDefinitions.NAME, prevVersion, true);
    status.save();
    setOnlineUpgradeConfig(false);
    setUpOneChange();
    setOnlineUpgradeConfig(true);
    IndexUpgradeController u = new IndexUpgradeController(1);
    try (ServerContext ctx = start.start(u)) {
        ChangeIndexCollection indexes = ctx.getInjector().getInstance(ChangeIndexCollection.class);
        assertThat(indexes.getSearchIndex().getSchema().getVersion()).isEqualTo(prevVersion);
        // Index schema upgrades happen after NoteDb migration, so waiting for those to complete
        // should be sufficient.
        u.runUpgrades();
        assertThat(indexes.getSearchIndex().getSchema().getVersion()).isEqualTo(currVersion);
        assertNotesMigrationState(expectedEndState);
    }
}
#end_block

#method_before
protected static FakeEmailSenderSubject assertThat(FakeEmailSender sender) {
    return assertAbout(FAKE_EMAIL_SENDER_SUBJECT_FACTORY).that(sender);
}
#method_after
protected static FakeEmailSenderSubject assertThat(FakeEmailSender sender) {
    return assertAbout(FakeEmailSenderSubject::new).that(sender);
}
#end_block

#method_before
@Test
public void defaultMessage() throws Exception {
    String changeId = createChange().getChangeId();
    ChangeInfo c = get(changeId);
    assertThat(c.messages).isNotNull();
    assertThat(c.messages).hasSize(1);
    assertThat(c.messages.iterator().next().message).isEqualTo("Uploaded patch set 1.");
}
#method_after
@Test
public void defaultMessage() throws Exception {
    String changeId = createChange().getChangeId();
    ChangeInfo c = get(changeId, MESSAGES);
    assertThat(c.messages).isNotNull();
    assertThat(c.messages).hasSize(1);
    assertThat(c.messages.iterator().next().message).isEqualTo("Uploaded patch set 1.");
}
#end_block

#method_before
@Test
public void messagesReturnedInChronologicalOrder() throws Exception {
    String changeId = createChange().getChangeId();
    String firstMessage = "Some nits need to be fixed.";
    postMessage(changeId, firstMessage);
    String secondMessage = "I like this feature.";
    postMessage(changeId, secondMessage);
    ChangeInfo c = get(changeId);
    assertThat(c.messages).isNotNull();
    assertThat(c.messages).hasSize(3);
    Iterator<ChangeMessageInfo> it = c.messages.iterator();
    assertThat(it.next().message).isEqualTo("Uploaded patch set 1.");
    assertMessage(firstMessage, it.next().message);
    assertMessage(secondMessage, it.next().message);
}
#method_after
@Test
public void messagesReturnedInChronologicalOrder() throws Exception {
    String changeId = createChange().getChangeId();
    String firstMessage = "Some nits need to be fixed.";
    postMessage(changeId, firstMessage);
    String secondMessage = "I like this feature.";
    postMessage(changeId, secondMessage);
    ChangeInfo c = get(changeId, MESSAGES);
    assertThat(c.messages).isNotNull();
    assertThat(c.messages).hasSize(3);
    Iterator<ChangeMessageInfo> it = c.messages.iterator();
    assertThat(it.next().message).isEqualTo("Uploaded patch set 1.");
    assertMessage(firstMessage, it.next().message);
    assertMessage(secondMessage, it.next().message);
}
#end_block

#method_before
@Test
public void postMessageWithTag() throws Exception {
    String changeId = createChange().getChangeId();
    String tag = "jenkins";
    String msg = "Message with tag.";
    postMessage(changeId, msg, tag);
    ChangeInfo c = get(changeId);
    assertThat(c.messages).isNotNull();
    assertThat(c.messages).hasSize(2);
    Iterator<ChangeMessageInfo> it = c.messages.iterator();
    assertThat(it.next().message).isEqualTo("Uploaded patch set 1.");
    ChangeMessageInfo actual = it.next();
    assertMessage(msg, actual.message);
    assertThat(actual.tag).isEqualTo(tag);
}
#method_after
@Test
public void postMessageWithTag() throws Exception {
    String changeId = createChange().getChangeId();
    String tag = "jenkins";
    String msg = "Message with tag.";
    postMessage(changeId, msg, tag);
    ChangeInfo c = get(changeId, MESSAGES);
    assertThat(c.messages).isNotNull();
    assertThat(c.messages).hasSize(2);
    Iterator<ChangeMessageInfo> it = c.messages.iterator();
    assertThat(it.next().message).isEqualTo("Uploaded patch set 1.");
    ChangeMessageInfo actual = it.next();
    assertMessage(msg, actual.message);
    assertThat(actual.tag).isEqualTo(tag);
}
#end_block

#method_before
private RepoSequence newSequence(String name, final int start, int batchSize, Runnable afterReadRef, Retryer<RefUpdate.Result> retryer) {
    return new RepoSequence(repoManager, project, name, () -> start, batchSize, afterReadRef, retryer);
}
#method_after
private RepoSequence newSequence(String name, final int start, int batchSize, Runnable afterReadRef, Retryer<RefUpdate.Result> retryer) {
    return new RepoSequence(repoManager, GitReferenceUpdated.DISABLED, project, name, () -> start, batchSize, afterReadRef, retryer);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    testEnv.getInjector().injectMembers(this);
    db = testEnv.getDb();
}
#method_after
@Before
public void setUp() throws Exception {
    testEnv.getInjector().injectMembers(this);
    db = testEnv.getDb();
    assume().that(db instanceof JdbcSchema).isTrue();
    connection = ((JdbcSchema) db).getConnection();
    createdOnRetrieval = connection.prepareStatement("SELECT created_on FROM account_groups WHERE group_id = ?");
    createdOnUpdate = connection.prepareStatement("UPDATE account_groups SET created_on = ? WHERE group_id = ?");
    auditEntryDeletion = connection.prepareStatement("DELETE FROM account_group_members_audit WHERE group_id = ?");
}
#end_block

#method_before
@Test
public void createdOnIsPopulatedForGroupsCreatedAfterAudit() throws Exception {
    Timestamp testStartTime = TimeUtil.nowTs();
    AccountGroup.Id groupId = createGroup("Group for schema migration");
    setCreatedOnToVeryOldTimestamp(groupId);
    schema151.migrateData(db, new TestUpdateUI());
    AccountGroup group = db.accountGroups().get(groupId);
    assertThat(group.getCreatedOn()).isAtLeast(testStartTime);
}
#method_after
@Test
public void createdOnIsPopulatedForGroupsCreatedAfterAudit() throws Exception {
    Timestamp testStartTime = TimeUtil.nowTs();
    AccountGroup.Id groupId = createGroup("Group for schema migration");
    setCreatedOnToVeryOldTimestamp(groupId);
    schema151.migrateData(db, new TestUpdateUI());
    Timestamp createdOn = getCreatedOn(groupId);
    assertThat(createdOn).isAtLeast(testStartTime);
}
#end_block

#method_before
@Test
public void createdOnIsPopulatedForGroupsCreatedBeforeAudit() throws Exception {
    AccountGroup.Id groupId = createGroup("Ancient group for schema migration");
    setCreatedOnToVeryOldTimestamp(groupId);
    removeAuditEntriesFor(groupId);
    schema151.migrateData(db, new TestUpdateUI());
    AccountGroup group = db.accountGroups().get(groupId);
    assertThat(group.getCreatedOn()).isEqualTo(AccountGroup.auditCreationInstantTs());
}
#method_after
@Test
public void createdOnIsPopulatedForGroupsCreatedBeforeAudit() throws Exception {
    AccountGroup.Id groupId = createGroup("Ancient group for schema migration");
    setCreatedOnToVeryOldTimestamp(groupId);
    removeAuditEntriesFor(groupId);
    schema151.migrateData(db, new TestUpdateUI());
    Timestamp createdOn = getCreatedOn(groupId);
    assertThat(createdOn).isEqualTo(AccountGroup.auditCreationInstantTs());
}
#end_block

#method_before
private void setCreatedOnToVeryOldTimestamp(Id groupId) throws OrmException {
    AccountGroup group = db.accountGroups().get(groupId);
    Instant instant = LocalDateTime.of(1800, Month.JANUARY, 1, 0, 0).toInstant(ZoneOffset.UTC);
    group.setCreatedOn(Timestamp.from(instant));
    db.accountGroups().update(ImmutableList.of(group));
}
#method_after
private void setCreatedOnToVeryOldTimestamp(Id groupId) throws Exception {
    createdOnUpdate.setInt(1, groupId.get());
    Instant instant = LocalDateTime.of(1800, Month.JANUARY, 1, 0, 0).toInstant(ZoneOffset.UTC);
    createdOnUpdate.setTimestamp(1, Timestamp.from(instant));
    createdOnUpdate.setInt(2, groupId.get());
    createdOnUpdate.executeUpdate();
}
#end_block

#method_before
private void removeAuditEntriesFor(AccountGroup.Id groupId) throws Exception {
    ResultSet<AccountGroupMemberAudit> groupMemberAudits = db.accountGroupMembersAudit().byGroup(groupId);
    db.accountGroupMembersAudit().delete(groupMemberAudits);
}
#method_after
private void removeAuditEntriesFor(AccountGroup.Id groupId) throws Exception {
    auditEntryDeletion.setInt(1, groupId.get());
    auditEntryDeletion.executeUpdate();
}
#end_block

#method_before
public static FixSuggestionInfoSubject assertThat(FixSuggestionInfo fixSuggestionInfo) {
    return assertAbout(FIX_SUGGESTION_INFO_SUBJECT_FACTORY).that(fixSuggestionInfo);
}
#method_after
public static FixSuggestionInfoSubject assertThat(FixSuggestionInfo fixSuggestionInfo) {
    return assertAbout(FixSuggestionInfoSubject::new).that(fixSuggestionInfo);
}
#end_block

#method_before
public static RobotCommentInfoSubject assertThat(RobotCommentInfo robotCommentInfo) {
    return assertAbout(ROBOT_COMMENT_INFO_SUBJECT_FACTORY).that(robotCommentInfo);
}
#method_after
public static RobotCommentInfoSubject assertThat(RobotCommentInfo robotCommentInfo) {
    return assertAbout(RobotCommentInfoSubject::new).that(robotCommentInfo);
}
#end_block

#method_before
@Test
public void pushForMasterWithMessage() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%m=my_test_message");
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, null);
    ChangeInfo ci = get(r.getChangeId());
    Collection<ChangeMessageInfo> changeMessages = ci.messages;
    assertThat(changeMessages).hasSize(1);
    for (ChangeMessageInfo cm : changeMessages) {
        assertThat(cm.message).isEqualTo("Uploaded patch set 1.\nmy test message");
    }
    Collection<RevisionInfo> revisions = ci.revisions.values();
    assertThat(revisions).hasSize(1);
    for (RevisionInfo ri : revisions) {
        assertThat(ri.description).isEqualTo("my test message");
    }
}
#method_after
@Test
public void pushForMasterWithMessage() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%m=my_test_message");
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, null);
    ChangeInfo ci = get(r.getChangeId(), MESSAGES, ALL_REVISIONS);
    Collection<ChangeMessageInfo> changeMessages = ci.messages;
    assertThat(changeMessages).hasSize(1);
    for (ChangeMessageInfo cm : changeMessages) {
        assertThat(cm.message).isEqualTo("Uploaded patch set 1.\nmy test message");
    }
    Collection<RevisionInfo> revisions = ci.revisions.values();
    assertThat(revisions).hasSize(1);
    for (RevisionInfo ri : revisions) {
        assertThat(ri.description).isEqualTo("my test message");
    }
}
#end_block

#method_before
@Test
public void pushForMasterWithMessageTwiceWithDifferentMessages() throws Exception {
    enableCreateNewChangeForAllNotInTarget();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content");
    PushOneCommit.Result r = push.to("refs/for/master/%m=my_test_message");
    r.assertOkStatus();
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%m=new_test_message");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId());
    Collection<RevisionInfo> revisions = ci.revisions.values();
    assertThat(revisions).hasSize(2);
    for (RevisionInfo ri : revisions) {
        if (ri.isCurrent) {
            assertThat(ri.description).isEqualTo("new test message");
        } else {
            assertThat(ri.description).isEqualTo("my test message");
        }
    }
}
#method_after
@Test
public void pushForMasterWithMessageTwiceWithDifferentMessages() throws Exception {
    enableCreateNewChangeForAllNotInTarget();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content");
    // %2C is comma; the value below tests that percent decoding happens after splitting.
    // All three ways of representing space ("%20", "+", and "_" are also exercised.
    PushOneCommit.Result r = push.to("refs/for/master/%m=my_test%20+_message%2Cm=");
    r.assertOkStatus();
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%m=new_test_message");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId(), ALL_REVISIONS);
    Collection<RevisionInfo> revisions = ci.revisions.values();
    assertThat(revisions).hasSize(2);
    for (RevisionInfo ri : revisions) {
        if (ri.isCurrent) {
            assertThat(ri.description).isEqualTo("new test message");
        } else {
            assertThat(ri.description).isEqualTo("my test   message,m=");
        }
    }
}
#end_block

#method_before
@Test
public void pushForMasterWithApprovals() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%l=Code-Review");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(1);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId());
    cr = ci.labels.get("Code-Review");
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(2);
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "c.txt", "moreContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId());
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 3.");
}
#method_after
@Test
public void pushForMasterWithApprovals() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%l=Code-Review");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId(), DETAILED_LABELS, MESSAGES, DETAILED_ACCOUNTS);
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(1);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId(), DETAILED_LABELS, MESSAGES, DETAILED_ACCOUNTS);
    cr = ci.labels.get("Code-Review");
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(2);
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "c.txt", "moreContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId(), MESSAGES);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 3.");
}
#end_block

#method_before
@Test
public void pushNewPatchSetForMasterWithApprovals() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ChangeInfo ci = get(r.getChangeId());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2.");
    // Check that the user who pushed the new patch set was added as a reviewer since they added
    // a vote
    assertThatUserIsOnlyReviewer(ci, admin);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(2);
}
#method_after
@Test
public void pushNewPatchSetForMasterWithApprovals() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ChangeInfo ci = get(r.getChangeId(), DETAILED_LABELS, MESSAGES, DETAILED_ACCOUNTS);
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2.");
    // Check that the user who pushed the new patch set was added as a reviewer since they added
    // a vote
    assertThatUserIsOnlyReviewer(ci, admin);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(2);
}
#end_block

#method_before
@Test
public void pushForMasterWithApprovalsForgeCommitterButNoForgeVote() throws Exception {
    // Create a commit with "User" as author and committer
    RevCommit c = commitBuilder().author(user.getIdent()).committer(user.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    // Push this commit as "Administrator" (requires Forge Committer Identity)
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1", false);
    // Expected Code-Review votes:
    // 1. 0 from User (committer):
    // When the committer is forged, the committer is automatically added as
    // reviewer, hence we expect a dummy 0 vote for the committer.
    // 2. +1 from Administrator (uploader):
    // On push Code-Review+1 was specified, hence we expect a +1 vote from
    // the uploader.
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(2);
    int indexAdmin = admin.fullName.equals(cr.all.get(0).name) ? 0 : 1;
    int indexUser = indexAdmin == 0 ? 1 : 0;
    assertThat(cr.all.get(indexAdmin).name).isEqualTo(admin.fullName);
    assertThat(cr.all.get(indexAdmin).value.intValue()).isEqualTo(1);
    assertThat(cr.all.get(indexUser).name).isEqualTo(user.fullName);
    assertThat(cr.all.get(indexUser).value.intValue()).isEqualTo(0);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
}
#method_after
@Test
public void pushForMasterWithApprovalsForgeCommitterButNoForgeVote() throws Exception {
    // Create a commit with "User" as author and committer
    RevCommit c = commitBuilder().author(user.getIdent()).committer(user.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    // Push this commit as "Administrator" (requires Forge Committer Identity)
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1", false);
    // Expected Code-Review votes:
    // 1. 0 from User (committer):
    // When the committer is forged, the committer is automatically added as
    // reviewer, hence we expect a dummy 0 vote for the committer.
    // 2. +1 from Administrator (uploader):
    // On push Code-Review+1 was specified, hence we expect a +1 vote from
    // the uploader.
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get(), DETAILED_LABELS, MESSAGES, DETAILED_ACCOUNTS);
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(2);
    int indexAdmin = admin.fullName.equals(cr.all.get(0).name) ? 0 : 1;
    int indexUser = indexAdmin == 0 ? 1 : 0;
    assertThat(cr.all.get(indexAdmin).name).isEqualTo(admin.fullName);
    assertThat(cr.all.get(indexAdmin).value.intValue()).isEqualTo(1);
    assertThat(cr.all.get(indexUser).name).isEqualTo(user.fullName);
    assertThat(cr.all.get(indexUser).value.intValue()).isEqualTo(0);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
}
#end_block

#method_before
@Test
public void pushWithMultipleApprovals() throws Exception {
    LabelType Q = category("Custom-Label", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID anon = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    String heads = "refs/heads/*";
    Util.allow(config, Permission.forLabel("Custom-Label"), -1, 1, anon, heads);
    config.getLabelSections().put(Q.getName(), Q);
    saveProjectConfig(project, config);
    RevCommit c = commitBuilder().author(admin.getIdent()).committer(admin.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1,l=Custom-Label-1", false);
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    cr = ci.labels.get("Custom-Label");
    assertThat(cr.all).hasSize(1);
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
}
#method_after
@Test
public void pushWithMultipleApprovals() throws Exception {
    LabelType Q = category("Custom-Label", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID anon = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    String heads = "refs/heads/*";
    Util.allow(config, Permission.forLabel("Custom-Label"), -1, 1, anon, heads);
    config.getLabelSections().put(Q.getName(), Q);
    saveProjectConfig(project, config);
    RevCommit c = commitBuilder().author(admin.getIdent()).committer(admin.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1,l=Custom-Label-1", false);
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get(), DETAILED_LABELS, DETAILED_ACCOUNTS);
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    cr = ci.labels.get("Custom-Label");
    assertThat(cr.all).hasSize(1);
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
}
#end_block

#method_before
private void assertTwoChangesWithSameRevision(PushOneCommit.Result result) throws Exception {
    List<ChangeInfo> changes = query(result.getCommit().name());
    assertThat(changes).hasSize(2);
    ChangeInfo c1 = get(changes.get(0).id);
    ChangeInfo c2 = get(changes.get(1).id);
    assertThat(c1.project).isEqualTo(c2.project);
    assertThat(c1.branch).isNotEqualTo(c2.branch);
    assertThat(c1.changeId).isEqualTo(c2.changeId);
    assertThat(c1.currentRevision).isEqualTo(c2.currentRevision);
}
#method_after
private void assertTwoChangesWithSameRevision(PushOneCommit.Result result) throws Exception {
    List<ChangeInfo> changes = query(result.getCommit().name());
    assertThat(changes).hasSize(2);
    ChangeInfo c1 = get(changes.get(0).id, CURRENT_REVISION);
    ChangeInfo c2 = get(changes.get(1).id, CURRENT_REVISION);
    assertThat(c1.project).isEqualTo(c2.project);
    assertThat(c1.branch).isNotEqualTo(c2.branch);
    assertThat(c1.changeId).isEqualTo(c2.changeId);
    assertThat(c1.currentRevision).isEqualTo(c2.currentRevision);
}
#end_block

#method_before
public static BinaryResultSubject assertThat(BinaryResult binaryResult) {
    return assertAbout(BINARY_RESULT_SUBJECT_FACTORY).that(binaryResult);
}
#method_after
public static BinaryResultSubject assertThat(BinaryResult binaryResult) {
    return assertAbout(BinaryResultSubject::new).that(binaryResult);
}
#end_block

#method_before
public static EditInfoSubject assertThat(EditInfo editInfo) {
    return assertAbout(EDIT_INFO_SUBJECT_FACTORY).that(editInfo);
}
#method_after
public static EditInfoSubject assertThat(EditInfo editInfo) {
    return assertAbout(EditInfoSubject::new).that(editInfo);
}
#end_block

#method_before
public static FixReplacementInfoSubject assertThat(FixReplacementInfo fixReplacementInfo) {
    return assertAbout(FIX_REPLACEMENT_INFO_SUBJECT_FACTORY).that(fixReplacementInfo);
}
#method_after
public static FixReplacementInfoSubject assertThat(FixReplacementInfo fixReplacementInfo) {
    return assertAbout(FixReplacementInfoSubject::new).that(fixReplacementInfo);
}
#end_block

#method_before
public static CommitInfoSubject assertThat(CommitInfo commitInfo) {
    return assertAbout(COMMIT_INFO_SUBJECT_FACTORY).that(commitInfo);
}
#method_after
public static CommitInfoSubject assertThat(CommitInfo commitInfo) {
    return assertAbout(CommitInfoSubject::new).that(commitInfo);
}
#end_block

#method_before
public static PathSubject assertThat(Path path) {
    return assertAbout(PATH_SUBJECT_FACTORY).that(path);
}
#method_after
public static PathSubject assertThat(Path path) {
    return assertAbout(PathSubject::new).that(path);
}
#end_block

#method_before
public static GitPersonSubject assertThat(GitPerson gitPerson) {
    return assertAbout(GIT_PERSON_SUBJECT_FACTORY).that(gitPerson);
}
#method_after
public static GitPersonSubject assertThat(GitPerson gitPerson) {
    return assertAbout(GitPersonSubject::new).that(gitPerson);
}
#end_block

#method_before
public static RangeSubject assertThat(Comment.Range range) {
    return assertAbout(RANGE_SUBJECT_FACTORY).that(range);
}
#method_after
public static RangeSubject assertThat(Comment.Range range) {
    return assertAbout(RangeSubject::new).that(range);
}
#end_block

#method_before
public static ContentEntrySubject assertThat(ContentEntry contentEntry) {
    return assertAbout(DIFF_INFO_SUBJECT_FACTORY).that(contentEntry);
}
#method_after
public static ContentEntrySubject assertThat(ContentEntry contentEntry) {
    return assertAbout(ContentEntrySubject::new).that(contentEntry);
}
#end_block

#method_before
public static DiffInfoSubject assertThat(DiffInfo diffInfo) {
    return assertAbout(DIFF_INFO_SUBJECT_FACTORY).that(diffInfo);
}
#method_after
public static DiffInfoSubject assertThat(DiffInfo diffInfo) {
    return assertAbout(DiffInfoSubject::new).that(diffInfo);
}
#end_block

#method_before
@Test
public void publishEdit() throws Exception {
    createArbitraryEditFor(changeId);
    PublishChangeEditInput publishInput = new PublishChangeEditInput();
    publishInput.notify = NotifyHandling.NONE;
    gApi.changes().id(changeId).edit().publish(publishInput);
    assertThat(getEdit(changeId)).isAbsent();
    assertChangeMessages(changeId, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch Set 3: Published edit on patch set 2."));
    // The tag for the publish edit change message should vary according
    // to whether the change was WIP at the time of publishing.
    ChangeInfo info = get(changeId);
    assertThat(info.messages).isNotEmpty();
    assertThat(Iterables.getLast(info.messages).tag).isEqualTo(ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
    // Move the change to WIP, repeat, and verify.
    gApi.changes().id(changeId).setWorkInProgress();
    createEmptyEditFor(changeId);
    gApi.changes().id(changeId).edit().modifyFile(FILE_NAME, RawInputUtil.create(CONTENT_NEW2));
    gApi.changes().id(changeId).edit().publish();
    info = get(changeId);
    assertThat(info.messages).isNotEmpty();
    assertThat(Iterables.getLast(info.messages).tag).isEqualTo(ChangeMessagesUtil.TAG_UPLOADED_WIP_PATCH_SET);
}
#method_after
@Test
public void publishEdit() throws Exception {
    createArbitraryEditFor(changeId);
    PublishChangeEditInput publishInput = new PublishChangeEditInput();
    publishInput.notify = NotifyHandling.NONE;
    gApi.changes().id(changeId).edit().publish(publishInput);
    assertThat(getEdit(changeId)).isAbsent();
    assertChangeMessages(changeId, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch Set 3: Published edit on patch set 2."));
    // The tag for the publish edit change message should vary according
    // to whether the change was WIP at the time of publishing.
    ChangeInfo info = get(changeId, MESSAGES);
    assertThat(info.messages).isNotEmpty();
    assertThat(Iterables.getLast(info.messages).tag).isEqualTo(ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
    // Move the change to WIP, repeat, and verify.
    gApi.changes().id(changeId).setWorkInProgress();
    createEmptyEditFor(changeId);
    gApi.changes().id(changeId).edit().modifyFile(FILE_NAME, RawInputUtil.create(CONTENT_NEW2));
    gApi.changes().id(changeId).edit().publish();
    info = get(changeId, MESSAGES);
    assertThat(info.messages).isNotEmpty();
    assertThat(Iterables.getLast(info.messages).tag).isEqualTo(ChangeMessagesUtil.TAG_UPLOADED_WIP_PATCH_SET);
}
#end_block

#method_before
@Test
public void retrieveEdit() throws Exception {
    adminRestSession.get(urlEdit(changeId)).assertNoContent();
    createArbitraryEditFor(changeId);
    EditInfo editInfo = getEditInfo(changeId, false);
    ChangeInfo changeInfo = get(changeId);
    assertThat(editInfo.commit.commit).isNotEqualTo(changeInfo.currentRevision);
    assertThat(editInfo).commit().parents().hasSize(1);
    assertThat(editInfo).baseRevision().isEqualTo(changeInfo.currentRevision);
    gApi.changes().id(changeId).edit().delete();
    adminRestSession.get(urlEdit(changeId)).assertNoContent();
}
#method_after
@Test
public void retrieveEdit() throws Exception {
    adminRestSession.get(urlEdit(changeId)).assertNoContent();
    createArbitraryEditFor(changeId);
    EditInfo editInfo = getEditInfo(changeId, false);
    ChangeInfo changeInfo = get(changeId, CURRENT_REVISION, CURRENT_COMMIT);
    assertThat(editInfo.commit.commit).isNotEqualTo(changeInfo.currentRevision);
    assertThat(editInfo).commit().parents().hasSize(1);
    assertThat(editInfo).baseRevision().isEqualTo(changeInfo.currentRevision);
    gApi.changes().id(changeId).edit().delete();
    adminRestSession.get(urlEdit(changeId)).assertNoContent();
}
#end_block

#method_before
@Test
public void editCommitMessageCopiesLabelScores() throws Exception {
    String cr = "Code-Review";
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType codeReview = Util.codeReview();
    codeReview.setCopyAllScoresIfNoCodeChange(true);
    cfg.getLabelSections().put(cr, codeReview);
    saveProjectConfig(project, cfg);
    ReviewInput r = new ReviewInput();
    r.labels = ImmutableMap.of(cr, (short) 1);
    gApi.changes().id(changeId).current().review(r);
    createEmptyEditFor(changeId);
    String newSubj = "New commit message";
    String newMsg = newSubj + "\n\nChange-Id: " + changeId + "\n";
    gApi.changes().id(changeId).edit().modifyCommitMessage(newMsg);
    PublishChangeEditInput publishInput = new PublishChangeEditInput();
    publishInput.notify = NotifyHandling.NONE;
    gApi.changes().id(changeId).edit().publish(publishInput);
    ChangeInfo info = get(changeId);
    assertThat(info.subject).isEqualTo(newSubj);
    List<ApprovalInfo> approvals = info.labels.get(cr).all;
    assertThat(approvals).hasSize(1);
    assertThat(approvals.get(0).value).isEqualTo(1);
}
#method_after
@Test
public void editCommitMessageCopiesLabelScores() throws Exception {
    String cr = "Code-Review";
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType codeReview = Util.codeReview();
    codeReview.setCopyAllScoresIfNoCodeChange(true);
    cfg.getLabelSections().put(cr, codeReview);
    saveProjectConfig(project, cfg);
    ReviewInput r = new ReviewInput();
    r.labels = ImmutableMap.of(cr, (short) 1);
    gApi.changes().id(changeId).current().review(r);
    createEmptyEditFor(changeId);
    String newSubj = "New commit message";
    String newMsg = newSubj + "\n\nChange-Id: " + changeId + "\n";
    gApi.changes().id(changeId).edit().modifyCommitMessage(newMsg);
    PublishChangeEditInput publishInput = new PublishChangeEditInput();
    publishInput.notify = NotifyHandling.NONE;
    gApi.changes().id(changeId).edit().publish(publishInput);
    ChangeInfo info = get(changeId, DETAILED_LABELS);
    assertThat(info.subject).isEqualTo(newSubj);
    List<ApprovalInfo> approvals = info.labels.get(cr).all;
    assertThat(approvals).hasSize(1);
    assertThat(approvals.get(0).value).isEqualTo(1);
}
#end_block

#method_before
private void assertChangeMessages(String changeId, List<String> expectedMessages) throws Exception {
    ChangeInfo ci = get(changeId);
    assertThat(ci.messages).isNotNull();
    assertThat(ci.messages).hasSize(expectedMessages.size());
    List<String> actualMessages = ci.messages.stream().map(message -> message.message).collect(toList());
    assertThat(actualMessages).containsExactlyElementsIn(expectedMessages).inOrder();
}
#method_after
private void assertChangeMessages(String changeId, List<String> expectedMessages) throws Exception {
    ChangeInfo ci = get(changeId, MESSAGES);
    assertThat(ci.messages).isNotNull();
    assertThat(ci.messages).hasSize(expectedMessages.size());
    List<String> actualMessages = ci.messages.stream().map(message -> message.message).collect(toList());
    assertThat(actualMessages).containsExactlyElementsIn(expectedMessages).inOrder();
}
#end_block

#method_before
public static FileInfoSubject assertThat(FileInfo fileInfo) {
    return assertAbout(FILE_INFO_SUBJECT_FACTORY).that(fileInfo);
}
#method_after
public static FileInfoSubject assertThat(FileInfo fileInfo) {
    return assertAbout(FileInfoSubject::new).that(fileInfo);
}
#end_block

#method_before
public List<SubmitRecord> evaluate() {
    initOptions();
    Change c = control.getChange();
    if (!opts.allowClosed() && c.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!opts.allowDraft()) {
        try {
            initPatchSet();
        } catch (OrmException e) {
            return ruleError("Error looking up patch set " + control.getChange().currentPatchSetId(), e);
        }
        if (c.getStatus() == Change.Status.DRAFT || patchSet.isDraft()) {
            return cannotSubmitDraft();
        }
    }
    List<Term> results;
    try {
        results = evaluateImpl("locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results", control.getUser());
    } catch (RuleEvalException e) {
        return ruleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // whether or not that is actually possible given the permissions.
        return ruleError(String.format("Submit rule '%s' for change %s of %s has no solution.", getSubmitRuleName(), cd.getId(), getProjectName()));
    }
    return resultsToSubmitRecord(getSubmitRule(), results);
}
#method_after
public List<SubmitRecord> evaluate() {
    initOptions();
    try {
        init();
    } catch (OrmException e) {
        return ruleError("Error looking up change " + cd.getId(), e);
    }
    if (!opts.allowClosed() && change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    List<Term> results;
    try {
        results = evaluateImpl("locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results", user);
    } catch (RuleEvalException e) {
        return ruleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // whether or not that is actually possible given the permissions.
        return ruleError(String.format("Submit rule '%s' for change %s of %s has no solution.", getSubmitRuleName(), cd.getId(), getProjectName()));
    }
    return resultsToSubmitRecord(getSubmitRule(), results);
}
#end_block

#method_before
public SubmitTypeRecord getSubmitType() {
    initOptions();
    try {
        initPatchSet();
    } catch (OrmException e) {
        return typeError("Error looking up patch set " + control.getChange().currentPatchSetId(), e);
    }
    try {
        if (control.getChange().getStatus() == Change.Status.DRAFT && !control.isDraftVisible(cd.db(), cd)) {
            return SubmitTypeRecord.error("Patch set " + patchSet.getId() + " not found");
        }
        if (patchSet.isDraft() && !control.isDraftVisible(cd.db(), cd)) {
            return SubmitTypeRecord.error("Patch set " + patchSet.getId() + " not found");
        }
    } catch (OrmException err) {
        String msg = "Cannot read patch set " + patchSet.getId();
        log.error(msg, err);
        return SubmitTypeRecord.error(msg);
    }
    List<Term> results;
    try {
        results = evaluateImpl("locate_submit_type", "get_submit_type", "locate_submit_type_filter", "filter_submit_type_results", // have a consistent view of the submit type.
        null);
    } catch (RuleEvalException e) {
        return typeError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // Should never occur for a well written rule
        return typeError("Submit rule '" + getSubmitRuleName() + "' for change " + cd.getId() + " of " + getProjectName() + " has no solution.");
    }
    Term typeTerm = results.get(0);
    if (!(typeTerm instanceof SymbolTerm)) {
        return typeError("Submit rule '" + getSubmitRuleName() + "' for change " + cd.getId() + " of " + getProjectName() + " did not return a symbol.");
    }
    String typeName = ((SymbolTerm) typeTerm).name();
    try {
        return SubmitTypeRecord.OK(SubmitType.valueOf(typeName.toUpperCase()));
    } catch (IllegalArgumentException e) {
        return typeError("Submit type rule " + getSubmitRule() + " for change " + cd.getId() + " of " + getProjectName() + " output invalid result: " + typeName);
    }
}
#method_after
public SubmitTypeRecord getSubmitType() {
    initOptions();
    try {
        init();
    } catch (OrmException e) {
        return typeError("Error looking up change " + cd.getId(), e);
    }
    List<Term> results;
    try {
        results = evaluateImpl("locate_submit_type", "get_submit_type", "locate_submit_type_filter", "filter_submit_type_results", // have a consistent view of the submit type.
        null);
    } catch (RuleEvalException e) {
        return typeError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // Should never occur for a well written rule
        return typeError("Submit rule '" + getSubmitRuleName() + "' for change " + cd.getId() + " of " + getProjectName() + " has no solution.");
    }
    Term typeTerm = results.get(0);
    if (!(typeTerm instanceof SymbolTerm)) {
        return typeError("Submit rule '" + getSubmitRuleName() + "' for change " + cd.getId() + " of " + getProjectName() + " did not return a symbol.");
    }
    String typeName = ((SymbolTerm) typeTerm).name();
    try {
        return SubmitTypeRecord.OK(SubmitType.valueOf(typeName.toUpperCase()));
    } catch (IllegalArgumentException e) {
        return typeError("Submit type rule " + getSubmitRule() + " for change " + cd.getId() + " of " + getProjectName() + " output invalid result: " + typeName);
    }
}
#end_block

#method_before
private List<Term> evaluateImpl(String userRuleLocatorName, String userRuleWrapperName, String filterRuleLocatorName, String filterRuleWrapperName, CurrentUser user) throws RuleEvalException {
    PrologEnvironment env = getPrologEnvironment(user);
    try {
        Term sr = env.once("gerrit", userRuleLocatorName, new VariableTerm());
        if (opts.fastEvalLabels()) {
            env.once("gerrit", "assume_range_from_label");
        }
        List<Term> results = new ArrayList<>();
        try {
            for (Term[] template : env.all("gerrit", userRuleWrapperName, sr, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (ReductionLimitException err) {
            throw new RuleEvalException(String.format("%s on change %d of %s", err.getMessage(), cd.getId().get(), getProjectName()));
        } catch (RuntimeException err) {
            throw new RuleEvalException(String.format("Exception calling %s on change %d of %s", sr, cd.getId().get(), getProjectName()), err);
        } finally {
            reductionsConsumed = env.getReductions();
        }
        Term resultsTerm = toListTerm(results);
        if (!opts.skipFilters()) {
            resultsTerm = runSubmitFilters(resultsTerm, env, filterRuleLocatorName, filterRuleWrapperName);
        }
        List<Term> r;
        if (resultsTerm instanceof ListTerm) {
            r = new ArrayList<>();
            for (Term t = resultsTerm; t instanceof ListTerm; ) {
                ListTerm l = (ListTerm) t;
                r.add(l.car().dereference());
                t = l.cdr().dereference();
            }
        } else {
            r = Collections.emptyList();
        }
        submitRule = sr;
        return r;
    } finally {
        env.close();
    }
}
#method_after
private List<Term> evaluateImpl(String userRuleLocatorName, String userRuleWrapperName, String filterRuleLocatorName, String filterRuleWrapperName, CurrentUser user) throws RuleEvalException {
    PrologEnvironment env = getPrologEnvironment(user);
    try {
        Term sr = env.once("gerrit", userRuleLocatorName, new VariableTerm());
        List<Term> results = new ArrayList<>();
        try {
            for (Term[] template : env.all("gerrit", userRuleWrapperName, sr, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (ReductionLimitException err) {
            throw new RuleEvalException(String.format("%s on change %d of %s", err.getMessage(), cd.getId().get(), getProjectName()));
        } catch (RuntimeException err) {
            throw new RuleEvalException(String.format("Exception calling %s on change %d of %s", sr, cd.getId().get(), getProjectName()), err);
        } finally {
            reductionsConsumed = env.getReductions();
        }
        Term resultsTerm = toListTerm(results);
        if (!opts.skipFilters()) {
            resultsTerm = runSubmitFilters(resultsTerm, env, filterRuleLocatorName, filterRuleWrapperName);
        }
        List<Term> r;
        if (resultsTerm instanceof ListTerm) {
            r = new ArrayList<>();
            for (Term t = resultsTerm; t instanceof ListTerm; ) {
                ListTerm l = (ListTerm) t;
                r.add(l.car().dereference());
                t = l.cdr().dereference();
            }
        } else {
            r = Collections.emptyList();
        }
        submitRule = sr;
        return r;
    } finally {
        env.close();
    }
}
#end_block

#method_before
private PrologEnvironment getPrologEnvironment(CurrentUser user) throws RuleEvalException {
    ProjectState projectState = control.getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        if (opts.rule() == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", new StringReader(opts.rule()));
        }
    } catch (CompileException err) {
        String msg;
        if (opts.rule() == null && control.getProjectControl().isOwner()) {
            msg = String.format("Cannot load rules.pl for %s: %s", getProjectName(), err.getMessage());
        } else if (opts.rule() != null) {
            msg = err.getMessage();
        } else {
            msg = String.format("Cannot load rules.pl for %s", getProjectName());
        }
        throw new RuleEvalException(msg, err);
    }
    env.set(StoredValues.ACCOUNTS, accounts);
    env.set(StoredValues.ACCOUNT_CACHE, accountCache);
    env.set(StoredValues.EMAILS, emails);
    env.set(StoredValues.REVIEW_DB, cd.db());
    env.set(StoredValues.CHANGE_DATA, cd);
    env.set(StoredValues.CHANGE_CONTROL, control);
    if (user != null) {
        env.set(StoredValues.CURRENT_USER, user);
    }
    return env;
}
#method_after
private PrologEnvironment getPrologEnvironment(CurrentUser user) throws RuleEvalException {
    PrologEnvironment env;
    try {
        if (opts.rule() == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", new StringReader(opts.rule()));
        }
    } catch (CompileException err) {
        String msg;
        if (opts.rule() == null) {
            msg = String.format("Cannot load rules.pl for %s: %s", getProjectName(), err.getMessage());
        } else {
            msg = err.getMessage();
        }
        throw new RuleEvalException(msg, err);
    }
    env.set(StoredValues.ACCOUNTS, accounts);
    env.set(StoredValues.ACCOUNT_CACHE, accountCache);
    env.set(StoredValues.EMAILS, emails);
    env.set(StoredValues.REVIEW_DB, cd.db());
    env.set(StoredValues.CHANGE_DATA, cd);
    if (user != null) {
        env.set(StoredValues.CURRENT_USER, user);
    }
    env.set(StoredValues.PROJECT_STATE, projectState);
    return env;
}
#end_block

#method_before
private Term runSubmitFilters(Term results, PrologEnvironment env, String filterRuleLocatorName, String filterRuleWrapperName) throws RuleEvalException {
    ProjectState projectState = control.getProjectControl().getProjectState();
    PrologEnvironment childEnv = env;
    for (ProjectState parentState : projectState.parents()) {
        PrologEnvironment parentEnv;
        try {
            parentEnv = parentState.newPrologEnvironment();
        } catch (CompileException err) {
            throw new RuleEvalException("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
        }
        parentEnv.copyStoredValues(childEnv);
        Term filterRule = parentEnv.once("gerrit", filterRuleLocatorName, new VariableTerm());
        try {
            if (opts.fastEvalLabels()) {
                env.once("gerrit", "assume_range_from_label");
            }
            Term[] template = parentEnv.once("gerrit", filterRuleWrapperName, filterRule, results, new VariableTerm());
            results = template[2];
        } catch (ReductionLimitException err) {
            throw new RuleEvalException(String.format("%s on change %d of %s", err.getMessage(), cd.getId().get(), parentState.getProject().getName()));
        } catch (RuntimeException err) {
            throw new RuleEvalException(String.format("Exception calling %s on change %d of %s", filterRule, cd.getId().get(), parentState.getProject().getName()), err);
        } finally {
            reductionsConsumed += env.getReductions();
        }
        childEnv = parentEnv;
    }
    return results;
}
#method_after
private Term runSubmitFilters(Term results, PrologEnvironment env, String filterRuleLocatorName, String filterRuleWrapperName) throws RuleEvalException {
    PrologEnvironment childEnv = env;
    for (ProjectState parentState : projectState.parents()) {
        PrologEnvironment parentEnv;
        try {
            parentEnv = parentState.newPrologEnvironment();
        } catch (CompileException err) {
            throw new RuleEvalException("Cannot consult rules.pl for " + parentState.getName(), err);
        }
        parentEnv.copyStoredValues(childEnv);
        Term filterRule = parentEnv.once("gerrit", filterRuleLocatorName, new VariableTerm());
        try {
            Term[] template = parentEnv.once("gerrit", filterRuleWrapperName, filterRule, results, new VariableTerm());
            results = template[2];
        } catch (ReductionLimitException err) {
            throw new RuleEvalException(String.format("%s on change %d of %s", err.getMessage(), cd.getId().get(), parentState.getName()));
        } catch (RuntimeException err) {
            throw new RuleEvalException(String.format("Exception calling %s on change %d of %s", filterRule, cd.getId().get(), parentState.getName()), err);
        } finally {
            reductionsConsumed += env.getReductions();
        }
        childEnv = parentEnv;
    }
    return results;
}
#end_block

#method_before
private String getProjectName() {
    return control.getProjectControl().getProjectState().getProject().getName();
}
#method_after
private String getProjectName() {
    return projectState.getName();
}
#end_block

#method_before
static Term export(LabelType type) {
    LabelValue min = type.getMin();
    LabelValue max = type.getMax();
    return new StructureTerm(symLabelType, SymbolTerm.intern(type.getName()), SymbolTerm.intern(type.getFunctionName()), min != null ? new IntegerTerm(min.getValue()) : NONE, max != null ? new IntegerTerm(max.getValue()) : NONE);
}
#method_after
static Term export(LabelType type) {
    LabelValue min = type.getMin();
    LabelValue max = type.getMax();
    return new StructureTerm(symLabelType, SymbolTerm.intern(type.getName()), SymbolTerm.intern(type.getFunction().getFunctionName()), min != null ? new IntegerTerm(min.getValue()) : NONE, max != null ? new IntegerTerm(max.getValue()) : NONE);
}
#end_block

#method_before
private void assertCanUpload(ProjectControl u) {
    assertThat(u.canPushToAtLeastOneRef()).named("can upload").isEqualTo(Capable.OK);
}
#method_after
private void assertCanUpload(ProjectControl u) {
    assertThat(u.canPushToAtLeastOneRef()).named("can upload").isTrue();
}
#end_block

#method_before
private void assertCannotUpload(ProjectControl u) {
    assertThat(u.canPushToAtLeastOneRef()).named("cannot upload").isNotEqualTo(Capable.OK);
}
#method_after
private void assertCannotUpload(ProjectControl u) {
    assertThat(u.canPushToAtLeastOneRef()).named("cannot upload").isFalse();
}
#end_block

#method_before
@Test
public void branchDelegation1() {
    allow(local, OWNER, ADMIN, "refs/*");
    allow(local, OWNER, DEVS, "refs/heads/x/*");
    ProjectControl uDev = user(local, DEVS);
    assertNotOwner(uDev);
    assertOwnerAnyRef(uDev);
    assertOwner("refs/heads/x/*", uDev);
    assertOwner("refs/heads/x/y", uDev);
    assertOwner("refs/heads/x/y/*", uDev);
    assertNotOwner("refs/*", uDev);
    assertNotOwner("refs/heads/master", uDev);
}
#method_after
@Test
public void branchDelegation1() {
    allow(local, OWNER, ADMIN, "refs/*");
    allow(local, OWNER, DEVS, "refs/heads/x/*");
    ProjectControl uDev = user(local, DEVS);
    assertNotOwner(uDev);
    assertOwner("refs/heads/x/*", uDev);
    assertOwner("refs/heads/x/y", uDev);
    assertOwner("refs/heads/x/y/*", uDev);
    assertNotOwner("refs/*", uDev);
    assertNotOwner("refs/heads/master", uDev);
}
#end_block

#method_before
@Test
public void branchDelegation2() {
    allow(local, OWNER, ADMIN, "refs/*");
    allow(local, OWNER, DEVS, "refs/heads/x/*");
    allow(local, OWNER, fixers, "refs/heads/x/y/*");
    doNotInherit(local, OWNER, "refs/heads/x/y/*");
    ProjectControl uDev = user(local, DEVS);
    assertNotOwner(uDev);
    assertOwnerAnyRef(uDev);
    assertOwner("refs/heads/x/*", uDev);
    assertOwner("refs/heads/x/y", uDev);
    assertOwner("refs/heads/x/y/*", uDev);
    assertNotOwner("refs/*", uDev);
    assertNotOwner("refs/heads/master", uDev);
    ProjectControl uFix = user(local, fixers);
    assertNotOwner(uFix);
    assertOwnerAnyRef(uFix);
    assertOwner("refs/heads/x/y/*", uFix);
    assertOwner("refs/heads/x/y/bar", uFix);
    assertNotOwner("refs/heads/x/*", uFix);
    assertNotOwner("refs/heads/x/y", uFix);
    assertNotOwner("refs/*", uFix);
    assertNotOwner("refs/heads/master", uFix);
}
#method_after
@Test
public void branchDelegation2() {
    allow(local, OWNER, ADMIN, "refs/*");
    allow(local, OWNER, DEVS, "refs/heads/x/*");
    allow(local, OWNER, fixers, "refs/heads/x/y/*");
    doNotInherit(local, OWNER, "refs/heads/x/y/*");
    ProjectControl uDev = user(local, DEVS);
    assertNotOwner(uDev);
    assertOwner("refs/heads/x/*", uDev);
    assertOwner("refs/heads/x/y", uDev);
    assertOwner("refs/heads/x/y/*", uDev);
    assertNotOwner("refs/*", uDev);
    assertNotOwner("refs/heads/master", uDev);
    ProjectControl uFix = user(local, fixers);
    assertNotOwner(uFix);
    assertOwner("refs/heads/x/y/*", uFix);
    assertOwner("refs/heads/x/y/bar", uFix);
    assertNotOwner("refs/heads/x/*", uFix);
    assertNotOwner("refs/heads/x/y", uFix);
    assertNotOwner("refs/*", uFix);
    assertNotOwner("refs/heads/master", uFix);
}
#end_block

#method_before
private ProjectControl user(ProjectConfig local, String name, AccountGroup.UUID... memberOf) {
    return new ProjectControl(Collections.<AccountGroup.UUID>emptySet(), Collections.<AccountGroup.UUID>emptySet(), projectCache, sectionSorter, // commitsCollection
    null, changeControlFactory, // canonicalWebUrl
    "http://localhost", permissionBackend, new MockUser(name, memberOf), newProjectState(local), metrics);
}
#method_after
private ProjectControl user(ProjectConfig local, String name, AccountGroup.UUID... memberOf) {
    return new ProjectControl(Collections.<AccountGroup.UUID>emptySet(), Collections.<AccountGroup.UUID>emptySet(), sectionSorter, // commitsCollection
    null, changeControlFactory, permissionBackend, new MockUser(name, memberOf), newProjectState(local));
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
protected void configure() {
    install(reviewDbModule);
    install(new DiffExecutorModule());
    install(new ReceiveCommitsExecutorModule());
    install(BatchUpdate.module());
    install(PatchListCacheImpl.module());
    // Plugins are not loaded and we're just running through each change
    // once, so don't worry about cache removal.
    bind(new TypeLiteral<DynamicSet<CacheRemovalListener>>() {
    }).toInstance(DynamicSet.<CacheRemovalListener>emptySet());
    bind(new TypeLiteral<DynamicMap<Cache<?, ?>>>() {
    }).toInstance(DynamicMap.<Cache<?, ?>>emptyMap());
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(new TypeLiteral<DynamicMap<ChangeQueryProcessor.ChangeAttributeFactory>>() {
    }).toInstance(DynamicMap.<ChangeQueryProcessor.ChangeAttributeFactory>emptyMap());
    bind(new TypeLiteral<DynamicMap<RestView<CommitResource>>>() {
    }).toInstance(DynamicMap.<RestView<CommitResource>>emptyMap());
    bind(String.class).annotatedWith(CanonicalWebUrl.class).toProvider(CanonicalWebUrlProvider.class);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(Realm.class).to(FakeRealm.class);
    bind(IdentifiedUser.class).toProvider(Providers.<IdentifiedUser>of(null));
    bind(ReplacePatchSetSender.Factory.class).toProvider(Providers.<ReplacePatchSetSender.Factory>of(null));
    bind(CurrentUser.class).to(IdentifiedUser.class);
    factory(MergeUtil.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(VisibleRefFilter.Factory.class);
    // As Reindex is a batch program, don't assume the index is available for
    // the change cache.
    bind(SearchingChangeCacheImpl.class).toProvider(Providers.<SearchingChangeCacheImpl>of(null));
    bind(new TypeLiteral<ImmutableSet<GroupReference>>() {
    }).annotatedWith(AdministrateServerGroups.class).toInstance(ImmutableSet.<GroupReference>of());
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(GitUploadPackGroups.class).toInstance(Collections.<AccountGroup.UUID>emptySet());
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(GitReceivePackGroups.class).toInstance(Collections.<AccountGroup.UUID>emptySet());
    install(new BatchGitModule());
    install(new DefaultPermissionBackendModule());
    install(new DefaultCacheFactory.Module());
    install(new ExternalIdModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(ChangeKindCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(TagCache.module());
    factory(CapabilityCollection.Factory.class);
    factory(ChangeData.AssistedFactory.class);
    factory(ProjectState.Factory.class);
    bind(ChangeJson.Factory.class).toProvider(Providers.<ChangeJson.Factory>of(null));
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
protected void configure() {
    install(reviewDbModule);
    install(new DiffExecutorModule());
    install(new ReceiveCommitsExecutorModule());
    install(BatchUpdate.module());
    install(PatchListCacheImpl.module());
    // Plugins are not loaded and we're just running through each change
    // once, so don't worry about cache removal.
    bind(new TypeLiteral<DynamicSet<CacheRemovalListener>>() {
    }).toInstance(DynamicSet.<CacheRemovalListener>emptySet());
    bind(new TypeLiteral<DynamicMap<Cache<?, ?>>>() {
    }).toInstance(DynamicMap.<Cache<?, ?>>emptyMap());
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(new TypeLiteral<DynamicMap<ChangeQueryProcessor.ChangeAttributeFactory>>() {
    }).toInstance(DynamicMap.<ChangeQueryProcessor.ChangeAttributeFactory>emptyMap());
    bind(new TypeLiteral<DynamicMap<RestView<CommitResource>>>() {
    }).toInstance(DynamicMap.<RestView<CommitResource>>emptyMap());
    bind(String.class).annotatedWith(CanonicalWebUrl.class).toProvider(CanonicalWebUrlProvider.class);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(Realm.class).to(FakeRealm.class);
    bind(IdentifiedUser.class).toProvider(Providers.<IdentifiedUser>of(null));
    bind(ReplacePatchSetSender.Factory.class).toProvider(Providers.<ReplacePatchSetSender.Factory>of(null));
    bind(CurrentUser.class).to(IdentifiedUser.class);
    factory(MergeUtil.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(VisibleRefFilter.Factory.class);
    // As Reindex is a batch program, don't assume the index is available for
    // the change cache.
    bind(SearchingChangeCacheImpl.class).toProvider(Providers.<SearchingChangeCacheImpl>of(null));
    bind(new TypeLiteral<ImmutableSet<GroupReference>>() {
    }).annotatedWith(AdministrateServerGroups.class).toInstance(ImmutableSet.<GroupReference>of());
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(GitUploadPackGroups.class).toInstance(Collections.<AccountGroup.UUID>emptySet());
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(GitReceivePackGroups.class).toInstance(Collections.<AccountGroup.UUID>emptySet());
    install(new BatchGitModule());
    install(new DefaultPermissionBackendModule());
    install(new DefaultCacheFactory.Module());
    install(new ExternalIdModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(ChangeKindCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(TagCache.module());
    factory(CapabilityCollection.Factory.class);
    factory(ChangeData.AssistedFactory.class);
    factory(ProjectState.Factory.class);
    factory(SubmitRuleEvaluator.Factory.class);
    bind(ChangeJson.Factory.class).toProvider(Providers.<ChangeJson.Factory>of(null));
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
}
#end_block

#method_before
private void logOrmExceptionForAccounts(String header, Account.Id me, Collection<AccountGroupMember> values, OrmException e) {
    List<String> descriptions = new ArrayList<>();
    for (AccountGroupMember m : values) {
        Account.Id accountId = m.getAccountId();
        String userName = accountCache.get(accountId).getUserName();
        AccountGroup.Id groupId = m.getAccountGroupId();
        String groupName = groupCache.get(groupId).getName();
        descriptions.add(MessageFormat.format("account {0}/{1}, group {2}/{3}", accountId, userName, groupId, groupName));
    }
    logOrmException(header, me, descriptions, e);
}
#method_after
private void logOrmExceptionForAccounts(String header, Account.Id me, Collection<AccountGroupMember> values, OrmException e) {
    List<String> descriptions = new ArrayList<>();
    for (AccountGroupMember m : values) {
        Account.Id accountId = m.getAccountId();
        String userName = accountCache.get(accountId).getUserName();
        AccountGroup.Id groupId = m.getAccountGroupId();
        String groupName = getGroupName(groupId);
        descriptions.add(MessageFormat.format("account {0}/{1}, group {2}/{3}", accountId, userName, groupId, groupName));
    }
    logOrmException(header, me, descriptions, e);
}
#end_block

#method_before
private void logOrmExceptionForGroups(String header, Account.Id me, Collection<AccountGroupById> values, OrmException e) {
    List<String> descriptions = new ArrayList<>();
    for (AccountGroupById m : values) {
        AccountGroup.UUID groupUuid = m.getIncludeUUID();
        String groupName = groupBackend.get(groupUuid).getName();
        AccountGroup.Id targetGroupId = m.getGroupId();
        String targetGroupName = groupCache.get(targetGroupId).getName();
        descriptions.add(MessageFormat.format("group {0}/{1}, group {2}/{3}", groupUuid, groupName, targetGroupId, targetGroupName));
    }
    logOrmException(header, me, descriptions, e);
}
#method_after
private void logOrmExceptionForGroups(String header, Account.Id me, Collection<AccountGroupById> values, OrmException e) {
    List<String> descriptions = new ArrayList<>();
    for (AccountGroupById m : values) {
        AccountGroup.UUID groupUuid = m.getIncludeUUID();
        String groupName = groupBackend.get(groupUuid).getName();
        AccountGroup.Id targetGroupId = m.getGroupId();
        String targetGroupName = getGroupName(targetGroupId);
        descriptions.add(MessageFormat.format("group {0}/{1}, group {2}/{3}", groupUuid, groupName, targetGroupId, targetGroupName));
    }
    logOrmException(header, me, descriptions, e);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountCacheImpl.module());
    install(BatchUpdate.module());
    install(ChangeKindCacheImpl.module());
    install(ChangeFinder.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new ExternalIdModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new ReceiveCommitsModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(ChangeData.AssistedFactory.class);
    factory(ChangeJson.AssistedFactory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(SetAssigneeSender.Factory.class);
    factory(VisibleRefFilter.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    bind(UiActions.class);
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), AssigneeChangedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), AccountIndexedListener.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), GroupIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterRefUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), ChangeMessageModifier.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), OnSubmitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ReviewerSuggestion.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), ParentWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicSet.setOf(binder(), TagWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    DynamicSet.setOf(binder(), AssigneeValidationListener.class);
    DynamicSet.setOf(binder(), ActionVisitor.class);
    DynamicMap.mapOf(binder(), MailFilter.class);
    bind(MailFilter.class).annotatedWith(Exports.named("ListMailFilter")).to(ListMailFilter.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeHasOperandFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryProcessor.ChangeAttributeFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(AbandonOp.Factory.class);
    factory(AccountValidator.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(OnSubmitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountCacheImpl.module());
    install(BatchUpdate.module());
    install(ChangeKindCacheImpl.module());
    install(ChangeFinder.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new ExternalIdModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new ReceiveCommitsModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(ChangeData.AssistedFactory.class);
    factory(ChangeJson.AssistedFactory.class);
    factory(CreateChangeSender.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(SetAssigneeSender.Factory.class);
    factory(VisibleRefFilter.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    factory(SubmitRuleEvaluator.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(AccountDeactivator.class);
    bind(ApprovalsUtil.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    bind(UiActions.class);
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), AssigneeChangedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), AccountIndexedListener.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), GroupIndexedListener.class);
    DynamicSet.setOf(binder(), ProjectIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterRefUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), ChangeMessageModifier.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), OnSubmitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ReviewerSuggestion.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), ParentWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicSet.setOf(binder(), TagWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    DynamicSet.setOf(binder(), AssigneeValidationListener.class);
    DynamicSet.setOf(binder(), ActionVisitor.class);
    DynamicItem.itemOf(binder(), MergeSuperSetComputation.class);
    DynamicItem.itemOf(binder(), ProjectNameLockManager.class);
    DynamicMap.mapOf(binder(), MailFilter.class);
    bind(MailFilter.class).annotatedWith(Exports.named("ListMailFilter")).to(ListMailFilter.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeHasOperandFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryProcessor.ChangeAttributeFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(AbandonOp.Factory.class);
    factory(AccountMergeValidator.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(OnSubmitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
public SubmitType apply(RevisionResource rsrc, TestSubmitRuleInput input) throws AuthException, BadRequestException, OrmException {
    if (input == null) {
        input = new TestSubmitRuleInput();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(accountCache, accounts, emails, changeDataFactory.create(db.get(), rsrc.getControl()));
    SubmitTypeRecord rec = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).getSubmitType();
    if (rec.status != SubmitTypeRecord.Status.OK) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRuleName(), rec));
    }
    return rec.type;
}
#method_after
@Override
public SubmitType apply(RevisionResource rsrc, TestSubmitRuleInput input) throws AuthException, BadRequestException, OrmException {
    if (input == null) {
        input = new TestSubmitRuleInput();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = submitRuleEvaluatorFactory.create(rsrc.getUser(), changeDataFactory.create(db.get(), rsrc.getNotes()));
    SubmitTypeRecord rec = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).getSubmitType();
    if (rec.status != SubmitTypeRecord.Status.OK) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRuleName(), rec));
    }
    return rec.type;
}
#end_block

#method_before
@Override
public List<Record> apply(RevisionResource rsrc, TestSubmitRuleInput input) throws AuthException, OrmException {
    if (input == null) {
        input = new TestSubmitRuleInput();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(accountCache, accounts, emails, changeDataFactory.create(db.get(), rsrc.getControl()));
    List<SubmitRecord> records = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).evaluate();
    List<Record> out = Lists.newArrayListWithCapacity(records.size());
    AccountLoader accounts = accountInfoFactory.create(true);
    for (SubmitRecord r : records) {
        out.add(new Record(r, accounts));
    }
    if (!out.isEmpty()) {
        out.get(0).prologReductionCount = evaluator.getReductionsConsumed();
    }
    accounts.fill();
    return out;
}
#method_after
@Override
public List<Record> apply(RevisionResource rsrc, TestSubmitRuleInput input) throws AuthException, OrmException {
    if (input == null) {
        input = new TestSubmitRuleInput();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = submitRuleEvaluatorFactory.create(rsrc.getUser(), changeDataFactory.create(db.get(), rsrc.getNotes()));
    List<SubmitRecord> records = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).evaluate();
    List<Record> out = Lists.newArrayListWithCapacity(records.size());
    AccountLoader accounts = accountInfoFactory.create(true);
    for (SubmitRecord r : records) {
        out.add(new Record(r, accounts));
    }
    if (!out.isEmpty()) {
        out.get(0).prologReductionCount = evaluator.getReductionsConsumed();
    }
    accounts.fill();
    return out;
}
#end_block

#method_before
private boolean isRevisionOutOfDate() {
    try (Repository git = gitMgr.openRepository(getProject().getNameKey())) {
        Ref ref = git.getRefDatabase().exactRef(RefNames.REFS_CONFIG);
        if (ref == null || ref.getObjectId() == null) {
            return true;
        }
        return !ref.getObjectId().equals(config.getRevision());
    } catch (IOException gone) {
        return true;
    }
}
#method_after
private boolean isRevisionOutOfDate() {
    try (Repository git = gitMgr.openRepository(getNameKey())) {
        Ref ref = git.getRefDatabase().exactRef(RefNames.REFS_CONFIG);
        if (ref == null || ref.getObjectId() == null) {
            return true;
        }
        return !ref.getObjectId().equals(config.getRevision());
    } catch (IOException gone) {
        return true;
    }
}
#end_block

#method_before
public PrologEnvironment newPrologEnvironment() throws CompileException {
    PrologMachineCopy pmc = rulesMachine;
    if (pmc == null) {
        pmc = rulesCache.loadMachine(getProject().getNameKey(), config.getRulesId());
        rulesMachine = pmc;
    }
    return envFactory.create(pmc);
}
#method_after
public PrologEnvironment newPrologEnvironment() throws CompileException {
    PrologMachineCopy pmc = rulesMachine;
    if (pmc == null) {
        pmc = rulesCache.loadMachine(getNameKey(), config.getRulesId());
        rulesMachine = pmc;
    }
    return envFactory.create(pmc);
}
#end_block

#method_before
public ProjectLevelConfig getConfig(String fileName) {
    if (configs.containsKey(fileName)) {
        return configs.get(fileName);
    }
    ProjectLevelConfig cfg = new ProjectLevelConfig(fileName, this);
    try (Repository git = gitMgr.openRepository(getProject().getNameKey())) {
        cfg.load(git);
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Failed to load " + fileName + " for " + getProject().getName(), e);
    }
    configs.put(fileName, cfg);
    return cfg;
}
#method_after
public ProjectLevelConfig getConfig(String fileName) {
    if (configs.containsKey(fileName)) {
        return configs.get(fileName);
    }
    ProjectLevelConfig cfg = new ProjectLevelConfig(fileName, this);
    try (Repository git = gitMgr.openRepository(getNameKey())) {
        cfg.load(git);
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Failed to load " + fileName + " for " + getName(), e);
    }
    configs.put(fileName, cfg);
    return cfg;
}
#end_block

#method_before
List<SectionMatcher> getLocalAccessSections() {
    List<SectionMatcher> sm = localAccessSections;
    if (sm == null) {
        Collection<AccessSection> fromConfig = config.getAccessSections();
        sm = new ArrayList<>(fromConfig.size());
        for (AccessSection section : fromConfig) {
            if (isAllProjects) {
                List<Permission> copy = Lists.newArrayListWithCapacity(section.getPermissions().size());
                for (Permission p : section.getPermissions()) {
                    if (Permission.canBeOnAllProjects(section.getName(), p.getName())) {
                        copy.add(p);
                    }
                }
                section = new AccessSection(section.getName());
                section.setPermissions(copy);
            }
            SectionMatcher matcher = SectionMatcher.wrap(getProject().getNameKey(), section);
            if (matcher != null) {
                sm.add(matcher);
            }
        }
        localAccessSections = sm;
    }
    return sm;
}
#method_after
List<SectionMatcher> getLocalAccessSections() {
    List<SectionMatcher> sm = localAccessSections;
    if (sm == null) {
        Collection<AccessSection> fromConfig = config.getAccessSections();
        sm = new ArrayList<>(fromConfig.size());
        for (AccessSection section : fromConfig) {
            if (isAllProjects) {
                List<Permission> copy = Lists.newArrayListWithCapacity(section.getPermissions().size());
                for (Permission p : section.getPermissions()) {
                    if (Permission.canBeOnAllProjects(section.getName(), p.getName())) {
                        copy.add(p);
                    }
                }
                section = new AccessSection(section.getName());
                section.setPermissions(copy);
            }
            SectionMatcher matcher = SectionMatcher.wrap(getNameKey(), section);
            if (matcher != null) {
                sm.add(matcher);
            }
        }
        localAccessSections = sm;
    }
    return sm;
}
#end_block

#method_before
public LabelTypes getLabelTypes() {
    Map<String, LabelType> types = new LinkedHashMap<>();
    for (ProjectState s : treeInOrder()) {
        for (LabelType type : s.getConfig().getLabelSections().values()) {
            String lower = type.getName().toLowerCase();
            LabelType old = types.get(lower);
            if (old == null || old.canOverride()) {
                types.put(lower, type);
            }
        }
    }
    List<LabelType> all = Lists.newArrayListWithCapacity(types.size());
    for (LabelType type : types.values()) {
        if (!type.getValues().isEmpty()) {
            all.add(type);
        }
    }
    return new LabelTypes(Collections.unmodifiableList(all));
}
#method_after
public LabelTypes getLabelTypes() {
    if (labelTypes == null) {
        labelTypes = loadLabelTypes();
    }
    return labelTypes;
}
#end_block

#method_before
public LabelTypes getLabelTypes() {
    Map<String, LabelType> types = new LinkedHashMap<>();
    for (ProjectState s : treeInOrder()) {
        for (LabelType type : s.getConfig().getLabelSections().values()) {
            String lower = type.getName().toLowerCase();
            LabelType old = types.get(lower);
            if (old == null || old.canOverride()) {
                types.put(lower, type);
            }
        }
    }
    List<LabelType> all = Lists.newArrayListWithCapacity(types.size());
    for (LabelType type : types.values()) {
        if (!type.getValues().isEmpty()) {
            all.add(type);
        }
    }
    return new LabelTypes(Collections.unmodifiableList(all));
}
#method_after
public LabelTypes getLabelTypes(ChangeNotes notes, CurrentUser user) {
    return getLabelTypes(notes.getChange().getDest(), user);
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    ChangeControl control = StoredValues.CHANGE_CONTROL.get(engine);
    SubmitType submitType = control.getProject().getSubmitType();
    if (!a1.unify(term[submitType.ordinal()], engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    ProjectState projectState = StoredValues.PROJECT_STATE.get(engine);
    SubmitType submitType = projectState.getProject().getSubmitType();
    if (!a1.unify(term[submitType.ordinal()], engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(GroupsCollection.class);
    DynamicMap.mapOf(binder(), GROUP_KIND);
    DynamicMap.mapOf(binder(), MEMBER_KIND);
    DynamicMap.mapOf(binder(), INCLUDED_GROUP_KIND);
    get(GROUP_KIND).to(GetGroup.class);
    put(GROUP_KIND).to(PutGroup.class);
    get(GROUP_KIND, "detail").to(GetDetail.class);
    post(GROUP_KIND, "index").to(Index.class);
    post(GROUP_KIND, "members").to(AddMembers.class);
    post(GROUP_KIND, "members.add").to(AddMembers.class);
    post(GROUP_KIND, "members.delete").to(DeleteMembers.class);
    post(GROUP_KIND, "groups").to(AddIncludedGroups.class);
    post(GROUP_KIND, "groups.add").to(AddIncludedGroups.class);
    post(GROUP_KIND, "groups.delete").to(DeleteIncludedGroups.class);
    get(GROUP_KIND, "description").to(GetDescription.class);
    put(GROUP_KIND, "description").to(PutDescription.class);
    delete(GROUP_KIND, "description").to(PutDescription.class);
    get(GROUP_KIND, "name").to(GetName.class);
    put(GROUP_KIND, "name").to(PutName.class);
    get(GROUP_KIND, "owner").to(GetOwner.class);
    put(GROUP_KIND, "owner").to(PutOwner.class);
    get(GROUP_KIND, "options").to(GetOptions.class);
    put(GROUP_KIND, "options").to(PutOptions.class);
    get(GROUP_KIND, "log.audit").to(GetAuditLog.class);
    child(GROUP_KIND, "members").to(MembersCollection.class);
    get(MEMBER_KIND).to(GetMember.class);
    put(MEMBER_KIND).to(UpdateMember.class);
    delete(MEMBER_KIND).to(DeleteMember.class);
    child(GROUP_KIND, "groups").to(IncludedGroupsCollection.class);
    get(INCLUDED_GROUP_KIND).to(GetIncludedGroup.class);
    put(INCLUDED_GROUP_KIND).to(UpdateIncludedGroup.class);
    delete(INCLUDED_GROUP_KIND).to(DeleteIncludedGroup.class);
    factory(CreateGroup.Factory.class);
    factory(GroupsUpdate.Factory.class);
    DynamicSet.bind(binder(), GroupMemberAuditListener.class).to(DbGroupMemberAuditListener.class);
}
#method_after
@Override
protected void configure() {
    bind(GroupsCollection.class);
    DynamicMap.mapOf(binder(), GROUP_KIND);
    DynamicMap.mapOf(binder(), MEMBER_KIND);
    DynamicMap.mapOf(binder(), SUBGROUP_KIND);
    get(GROUP_KIND).to(GetGroup.class);
    put(GROUP_KIND).to(PutGroup.class);
    get(GROUP_KIND, "detail").to(GetDetail.class);
    post(GROUP_KIND, "index").to(Index.class);
    post(GROUP_KIND, "members").to(AddMembers.class);
    post(GROUP_KIND, "members.add").to(AddMembers.class);
    post(GROUP_KIND, "members.delete").to(DeleteMembers.class);
    post(GROUP_KIND, "groups").to(AddSubgroups.class);
    post(GROUP_KIND, "groups.add").to(AddSubgroups.class);
    post(GROUP_KIND, "groups.delete").to(DeleteSubgroups.class);
    get(GROUP_KIND, "description").to(GetDescription.class);
    put(GROUP_KIND, "description").to(PutDescription.class);
    delete(GROUP_KIND, "description").to(PutDescription.class);
    get(GROUP_KIND, "name").to(GetName.class);
    put(GROUP_KIND, "name").to(PutName.class);
    get(GROUP_KIND, "owner").to(GetOwner.class);
    put(GROUP_KIND, "owner").to(PutOwner.class);
    get(GROUP_KIND, "options").to(GetOptions.class);
    put(GROUP_KIND, "options").to(PutOptions.class);
    get(GROUP_KIND, "log.audit").to(GetAuditLog.class);
    child(GROUP_KIND, "members").to(MembersCollection.class);
    get(MEMBER_KIND).to(GetMember.class);
    put(MEMBER_KIND).to(UpdateMember.class);
    delete(MEMBER_KIND).to(DeleteMember.class);
    child(GROUP_KIND, "groups").to(SubgroupsCollection.class);
    get(SUBGROUP_KIND).to(GetSubgroup.class);
    put(SUBGROUP_KIND).to(UpdateSubgroup.class);
    delete(SUBGROUP_KIND).to(DeleteSubgroup.class);
    factory(CreateGroup.Factory.class);
    factory(GroupsUpdate.Factory.class);
    DynamicSet.bind(binder(), GroupMemberAuditListener.class).to(DbGroupMemberAuditListener.class);
}
#end_block

#method_before
private boolean shouldReplicate(Project.NameKey project, ReplicationState... states) {
    try {
        return threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException, PermissionBackendException {
                return shouldReplicate(controlFor(project));
            }
        }).call();
    } catch (NoSuchProjectException err) {
        stateLog.error(String.format("source project %s not available", project), err, states);
    } catch (Exception e) {
        Throwables.throwIfUnchecked(e);
        throw new RuntimeException(e);
    }
    return false;
}
#method_after
private boolean shouldReplicate(ProjectState projectState, CurrentUser user) throws PermissionBackendException {
    if (!config.replicateHiddenProjects() && projectState.getProject().getState() == com.google.gerrit.extensions.client.ProjectState.HIDDEN) {
        return false;
    }
    try {
        permissionBackend.user(user).project(projectState.getNameKey()).check(ProjectPermission.ACCESS);
        return true;
    } catch (AuthException e) {
        return false;
    }
}
#end_block

#method_before
private boolean shouldReplicate(final Project.NameKey project, String ref, ReplicationState... states) {
    try {
        return threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException, PermissionBackendException {
                ProjectControl projectControl = controlFor(project);
                if (!shouldReplicate(projectControl)) {
                    return false;
                }
                if (PushOne.ALL_REFS.equals(ref)) {
                    return true;
                }
                try {
                    permissionBackend.user(projectControl.getUser()).project(project).ref(ref).check(RefPermission.READ);
                } catch (AuthException e) {
                    return false;
                }
                return true;
            }
        }).call();
    } catch (NoSuchProjectException err) {
        stateLog.error(String.format("source project %s not available", project), err, states);
    } catch (Exception e) {
        Throwables.throwIfUnchecked(e);
        throw new RuntimeException(e);
    }
    return false;
}
#method_after
private boolean shouldReplicate(final Project.NameKey project, String ref, ReplicationState... states) {
    try {
        return threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException, PermissionBackendException {
                ProjectState projectState;
                try {
                    projectState = projectCache.checkedGet(project);
                } catch (IOException e) {
                    return false;
                }
                if (projectState == null) {
                    throw new NoSuchProjectException(project);
                }
                if (!shouldReplicate(projectState, userProvider.get())) {
                    return false;
                }
                if (PushOne.ALL_REFS.equals(ref)) {
                    return true;
                }
                try {
                    permissionBackend.user(userProvider).project(project).ref(ref).check(RefPermission.READ);
                } catch (AuthException e) {
                    return false;
                }
                return true;
            }
        }).call();
    } catch (NoSuchProjectException err) {
        stateLog.error(String.format("source project %s not available", project), err, states);
    } catch (Exception e) {
        Throwables.throwIfUnchecked(e);
        throw new RuntimeException(e);
    }
    return false;
}
#end_block

#method_before
private boolean shouldReplicate(Project.NameKey project, ReplicationState... states) {
    try {
        return threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException, PermissionBackendException {
                return shouldReplicate(controlFor(project));
            }
        }).call();
    } catch (NoSuchProjectException err) {
        stateLog.error(String.format("source project %s not available", project), err, states);
    } catch (Exception e) {
        Throwables.throwIfUnchecked(e);
        throw new RuntimeException(e);
    }
    return false;
}
#method_after
private boolean shouldReplicate(Project.NameKey project, ReplicationState... states) {
    try {
        return threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException, PermissionBackendException {
                return shouldReplicate(project);
            }
        }).call();
    } catch (NoSuchProjectException err) {
        stateLog.error(String.format("source project %s not available", project), err, states);
    } catch (Exception e) {
        Throwables.throwIfUnchecked(e);
        throw new RuntimeException(e);
    }
    return false;
}
#end_block

#method_before
void schedule(Project.NameKey project, String ref, URIish uri, ReplicationState state, boolean now) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!shouldReplicate(project, ref, state)) {
        return;
    }
    if (!config.replicatePermissions()) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            try (Repository git = gitManager.openRepository(project)) {
                try {
                    Ref head = git.exactRef(Constants.HEAD);
                    if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                        return;
                    }
                } catch (IOException err) {
                    stateLog.error(String.format("cannot check type of project %s", project), err, state);
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            addRef(e, ref);
            pool.schedule(e, now ? 0 : config.getDelay(), TimeUnit.SECONDS);
            pending.put(uri, e);
        } else if (!e.getRefs().contains(ref)) {
            addRef(e, ref);
        }
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, config.getDelay());
    }
}
#method_after
void schedule(Project.NameKey project, String ref, URIish uri, ReplicationState state, boolean now) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!shouldReplicate(project, ref, state)) {
        return;
    }
    if (!config.replicatePermissions()) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            try (Repository git = gitManager.openRepository(project)) {
                try {
                    Ref head = git.exactRef(Constants.HEAD);
                    if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                        return;
                    }
                } catch (IOException err) {
                    stateLog.error(String.format("cannot check type of project %s", project), err, state);
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            addRef(e, ref);
            e.addState(ref, state);
            pool.schedule(e, now ? 0 : config.getDelay(), TimeUnit.SECONDS);
            pending.put(uri, e);
        } else if (!e.getRefs().contains(ref)) {
            addRef(e, ref);
            e.addState(ref, state);
        }
        state.increasePushTaskCount(project.get(), ref);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, config.getDelay());
    }
}
#end_block

#method_before
void reschedule(PushOne pushOp, RetryReason reason) {
    synchronized (stateLock) {
        URIish uri = pushOp.getURI();
        PushOne pendingPushOp = pending.get(uri);
        if (pendingPushOp != null) {
            if (pendingPushOp.isRetrying()) {
                // The one pending is one already retrying, so it should
                // maintain it and add to it the refs of the one passed
                // as parameter to the method.
                // This scenario would happen if a PushOp has started running
                // and then before it failed due transport exception, another
                // one to same URI started. The first one would fail and would
                // be rescheduled, being present in pending list. When the
                // second one fails, it will also be rescheduled and then,
                // here, find out replication to its URI is already pending
                // for retry (blocking).
                pendingPushOp.addRefs(pushOp.getRefs());
                pendingPushOp.addStates(pushOp.getStates());
                pushOp.removeStates();
            } else {
                // The one pending is one that is NOT retrying, it was just
                // scheduled believing no problem would happen. The one pending
                // should be canceled, and this is done by setting its canceled
                // flag, removing it from pending list, and adding its refs to
                // the pushOp instance that should then, later, in this method,
                // be scheduled for retry.
                // Notice that the PushOp found pending will start running and,
                // when notifying it is starting (with pending lock protection),
                // it will see it was canceled and then it will do nothing with
                // pending list and it will not execute its run implementation.
                pendingPushOp.canceledByReplication();
                pending.remove(uri);
                pushOp.addRefs(pendingPushOp.getRefs());
                pushOp.addStates(pendingPushOp.getStates());
                pendingPushOp.removeStates();
            }
        }
        if (pendingPushOp == null || !pendingPushOp.isRetrying()) {
            pending.put(uri, pushOp);
            switch(reason) {
                case COLLISION:
                    pool.schedule(pushOp, config.getDelay(), TimeUnit.SECONDS);
                    break;
                case TRANSPORT_ERROR:
                case REPOSITORY_MISSING:
                default:
                    RemoteRefUpdate.Status status = RetryReason.REPOSITORY_MISSING.equals(reason) ? NON_EXISTING : REJECTED_OTHER_REASON;
                    postReplicationFailedEvent(pushOp, status);
                    if (pushOp.setToRetry()) {
                        postReplicationScheduledEvent(pushOp);
                        pool.schedule(pushOp, config.getRetryDelay(), TimeUnit.MINUTES);
                    } else {
                        pushOp.canceledByReplication();
                        pending.remove(uri);
                        stateLog.error("Push to " + pushOp.getURI() + " cancelled after maximum number of retries", pushOp.getStatesAsArray());
                    }
                    break;
            }
        }
    }
}
#method_after
void reschedule(PushOne pushOp, RetryReason reason) {
    synchronized (stateLock) {
        URIish uri = pushOp.getURI();
        PushOne pendingPushOp = pending.get(uri);
        if (pendingPushOp != null) {
            if (pendingPushOp.isRetrying()) {
                // The one pending is one already retrying, so it should
                // maintain it and add to it the refs of the one passed
                // as parameter to the method.
                // This scenario would happen if a PushOp has started running
                // and then before it failed due transport exception, another
                // one to same URI started. The first one would fail and would
                // be rescheduled, being present in pending list. When the
                // second one fails, it will also be rescheduled and then,
                // here, find out replication to its URI is already pending
                // for retry (blocking).
                pendingPushOp.addRefs(pushOp.getRefs());
                pendingPushOp.addStates(pushOp.getStates());
                pushOp.removeStates();
            } else {
                // The one pending is one that is NOT retrying, it was just
                // scheduled believing no problem would happen. The one pending
                // should be canceled, and this is done by setting its canceled
                // flag, removing it from pending list, and adding its refs to
                // the pushOp instance that should then, later, in this method,
                // be scheduled for retry.
                // Notice that the PushOp found pending will start running and,
                // when notifying it is starting (with pending lock protection),
                // it will see it was canceled and then it will do nothing with
                // pending list and it will not execute its run implementation.
                pendingPushOp.canceledByReplication();
                pending.remove(uri);
                pushOp.addRefs(pendingPushOp.getRefs());
                pushOp.addStates(pendingPushOp.getStates());
                pendingPushOp.removeStates();
            }
        }
        if (pendingPushOp == null || !pendingPushOp.isRetrying()) {
            pending.put(uri, pushOp);
            switch(reason) {
                case COLLISION:
                    pool.schedule(pushOp, config.getRescheduleDelay(), TimeUnit.SECONDS);
                    break;
                case TRANSPORT_ERROR:
                case REPOSITORY_MISSING:
                default:
                    RemoteRefUpdate.Status status = RetryReason.REPOSITORY_MISSING.equals(reason) ? NON_EXISTING : REJECTED_OTHER_REASON;
                    postReplicationFailedEvent(pushOp, status);
                    if (pushOp.setToRetry()) {
                        postReplicationScheduledEvent(pushOp);
                        pool.schedule(pushOp, config.getRetryDelay(), TimeUnit.MINUTES);
                    } else {
                        pushOp.canceledByReplication();
                        pending.remove(uri);
                        stateLog.error("Push to " + pushOp.getURI() + " cancelled after maximum number of retries", pushOp.getStatesAsArray());
                    }
                    break;
            }
        }
    }
}
#end_block

#method_before
Destination create(DestinationConfiguration config) {
    return new Destination(injector, config, replicationUserFactory, pluginUser, gitRepositoryManager, permissionBackend, groupBackend, stateLog, groupIncludeCache, eventDispatcher);
}
#method_after
Destination create(DestinationConfiguration config) {
    return new Destination(injector, config, replicationUserFactory, pluginUser, gitRepositoryManager, permissionBackend, userProvider, projectCache, groupBackend, stateLog, groupIncludeCache, eventDispatcher);
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    ChangeControl control = StoredValues.CHANGE_CONTROL.get(engine);
    SubmitType submitType = control.getProject().getSubmitType();
    if (!a1.unify(term[submitType.ordinal()], engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    ProjectState projectState = StoredValues.PROJECT_STATE.get(engine);
    SubmitType submitType = projectState.getProject().getSubmitType();
    if (!a1.unify(term[submitType.ordinal()], engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#end_block

#method_before
static Term export(LabelType type) {
    LabelValue min = type.getMin();
    LabelValue max = type.getMax();
    return new StructureTerm(symLabelType, SymbolTerm.intern(type.getName()), SymbolTerm.intern(type.getFunctionName()), min != null ? new IntegerTerm(min.getValue()) : NONE, max != null ? new IntegerTerm(max.getValue()) : NONE);
}
#method_after
static Term export(LabelType type) {
    LabelValue min = type.getMin();
    LabelValue max = type.getMax();
    return new StructureTerm(symLabelType, SymbolTerm.intern(type.getName()), SymbolTerm.intern(type.getFunction().getFunctionName()), min != null ? new IntegerTerm(min.getValue()) : NONE, max != null ? new IntegerTerm(max.getValue()) : NONE);
}
#end_block

#method_before
public static String changeMetaRef(Change.Id id) {
    StringBuilder r = new StringBuilder();
    r.append(REFS_CHANGES);
    r.append(shard(id.get()));
    r.append(META_SUFFIX);
    return r.toString();
}
#method_after
public static String changeMetaRef(Change.Id id) {
    StringBuilder r = newStringBuilder().append(REFS_CHANGES);
    return shard(id.get(), r).append(META_SUFFIX).toString();
}
#end_block

#method_before
public static String robotCommentsRef(Change.Id id) {
    StringBuilder r = new StringBuilder();
    r.append(REFS_CHANGES);
    r.append(shard(id.get()));
    r.append(ROBOT_COMMENTS_SUFFIX);
    return r.toString();
}
#method_after
public static String robotCommentsRef(Change.Id id) {
    StringBuilder r = newStringBuilder().append(REFS_CHANGES);
    return shard(id.get(), r).append(ROBOT_COMMENTS_SUFFIX).toString();
}
#end_block

#method_before
public static String refsUsers(Account.Id accountId) {
    StringBuilder r = new StringBuilder();
    r.append(REFS_USERS);
    r.append(shard(accountId.get()));
    return r.toString();
}
#method_after
public static String refsUsers(Account.Id accountId) {
    StringBuilder r = newStringBuilder().append(REFS_USERS);
    return shard(accountId.get(), r).toString();
}
#end_block

#method_before
public static String refsDraftComments(Change.Id changeId, Account.Id accountId) {
    StringBuilder r = buildRefsPrefix(REFS_DRAFT_COMMENTS, changeId.get());
    r.append(accountId.get());
    return r.toString();
}
#method_after
public static String refsDraftComments(Change.Id changeId, Account.Id accountId) {
    return buildRefsPrefix(REFS_DRAFT_COMMENTS, changeId.get()).append(accountId.get()).toString();
}
#end_block

#method_before
public static String refsStarredChanges(Change.Id changeId, Account.Id accountId) {
    StringBuilder r = buildRefsPrefix(REFS_STARRED_CHANGES, changeId.get());
    r.append(accountId.get());
    return r.toString();
}
#method_after
public static String refsStarredChanges(Change.Id changeId, Account.Id accountId) {
    return buildRefsPrefix(REFS_STARRED_CHANGES, changeId.get()).append(accountId.get()).toString();
}
#end_block

#method_before
private static StringBuilder buildRefsPrefix(String prefix, int id) {
    StringBuilder r = new StringBuilder();
    r.append(prefix);
    r.append(shard(id));
    r.append('/');
    return r;
}
#method_after
private static StringBuilder buildRefsPrefix(String prefix, int id) {
    StringBuilder r = newStringBuilder().append(prefix);
    return shard(id, r).append('/');
}
#end_block

#method_before
public static String shard(int id) {
    if (id < 0) {
        return null;
    }
    StringBuilder r = new StringBuilder();
    int n = id % 100;
    if (n < 10) {
        r.append('0');
    }
    r.append(n);
    r.append('/');
    r.append(id);
    return r.toString();
}
#method_after
public static String shard(int id) {
    if (id < 0) {
        return null;
    }
    return shard(id, newStringBuilder()).toString();
}
#end_block

#method_before
public static String shard(int id) {
    if (id < 0) {
        return null;
    }
    StringBuilder r = new StringBuilder();
    int n = id % 100;
    if (n < 10) {
        r.append('0');
    }
    r.append(n);
    r.append('/');
    r.append(id);
    return r.toString();
}
#method_after
private static StringBuilder shard(int id, StringBuilder sb) {
    int n = id % 100;
    if (n < 10) {
        sb.append('0');
    }
    sb.append(n);
    sb.append('/');
    sb.append(id);
    return sb;
}
#end_block

#method_before
@Override
public void delete() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Deprecated
@Override
public void delete() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void publish() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Deprecated
@Override
public void publish() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void rebase() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Deprecated
@Override
public void rebase() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
private String shortenSubject(String subject) {
    if (subject.length() < 73) {
        return subject;
    } else {
        return subject.substring(0, 69) + "...";
    }
}
#method_after
private static String shortenSubject(String subject) {
    if (subject.length() < 73) {
        return subject;
    } else {
        return subject.substring(0, 69) + "...";
    }
}
#end_block

#method_before
private List<AccountInfo> getTransitiveMembers(GroupDescription.Internal group, GroupControl groupControl) throws OrmException {
    Set<Account.Id> members = getTransitiveMemberIds(group, groupControl, new HashSet<>(ImmutableSet.of(group.getGroupUUID())));
    return toAccountInfos(members);
}
#method_after
private List<AccountInfo> getTransitiveMembers(GroupDescription.Internal group, GroupControl groupControl) throws OrmException {
    checkSameGroup(group, groupControl);
    Set<Account.Id> members = getTransitiveMemberIds(group, groupControl, new HashSet<>(ImmutableSet.of(group.getGroupUUID())));
    return toAccountInfos(members);
}
#end_block

#method_before
public List<AccountInfo> getDirectMembers(GroupDescription.Internal group, GroupControl groupControl) throws OrmException {
    Set<Account.Id> directMembers = getDirectMemberIds(group, groupControl);
    return toAccountInfos(directMembers);
}
#method_after
public List<AccountInfo> getDirectMembers(GroupDescription.Internal group, GroupControl groupControl) throws OrmException {
    checkSameGroup(group, groupControl);
    Set<Account.Id> directMembers = getDirectMemberIds(group, groupControl);
    return toAccountInfos(directMembers);
}
#end_block

#method_before
@Override
protected void configure() {
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), CONFIG_KIND);
    DynamicMap.mapOf(binder(), TASK_KIND);
    DynamicMap.mapOf(binder(), TOP_MENU_KIND);
    child(CONFIG_KIND, "capabilities").to(CapabilitiesCollection.class);
    child(CONFIG_KIND, "tasks").to(TasksCollection.class);
    get(TASK_KIND).to(GetTask.class);
    delete(TASK_KIND).to(DeleteTask.class);
    child(CONFIG_KIND, "top-menus").to(TopMenuCollection.class);
    get(CONFIG_KIND, "version").to(GetVersion.class);
    get(CONFIG_KIND, "info").to(GetServerInfo.class);
    get(CONFIG_KIND, "preferences").to(GetPreferences.class);
    put(CONFIG_KIND, "preferences").to(SetPreferences.class);
    put(CONFIG_KIND, "email.validate").to(ValidateEmail.class);
}
#method_after
@Override
protected void configure() {
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), CONFIG_KIND);
    DynamicMap.mapOf(binder(), TASK_KIND);
    DynamicMap.mapOf(binder(), TOP_MENU_KIND);
    child(CONFIG_KIND, "capabilities").to(CapabilitiesCollection.class);
    child(CONFIG_KIND, "tasks").to(TasksCollection.class);
    get(TASK_KIND).to(GetTask.class);
    delete(TASK_KIND).to(DeleteTask.class);
    child(CONFIG_KIND, "top-menus").to(TopMenuCollection.class);
    get(CONFIG_KIND, "version").to(GetVersion.class);
    get(CONFIG_KIND, "info").to(GetServerInfo.class);
    get(CONFIG_KIND, "preferences").to(GetPreferences.class);
    put(CONFIG_KIND, "preferences").to(SetPreferences.class);
    put(CONFIG_KIND, "email.confirm").to(ConfirmEmail.class);
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    ConfigServerApi.validateEmail(magicToken, new ScreenLoadCallback<VoidResult>(this) {

        @Override
        protected void preDisplay(final VoidResult result) {
        }

        @Override
        protected void postDisplay() {
            Gerrit.display(PageLinks.SETTINGS_CONTACT);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    ConfigServerApi.confirmEmail(magicToken, new ScreenLoadCallback<VoidResult>(this) {

        @Override
        protected void preDisplay(final VoidResult result) {
        }

        @Override
        protected void postDisplay() {
            Gerrit.display(PageLinks.SETTINGS_CONTACT);
        }
    });
}
#end_block

#method_before
public Map<String, Set<String>> getIssueIds(String projectName, String commitId, PatchSet.Id patchSetId) {
    Map<String, Set<String>> current = getIssueIds(projectName, commitId);
    if (patchSetId != null) {
        Map<String, Set<String>> previous = Maps.newHashMap();
        if (patchSetId.get() != 1) {
            try {
                String previousRevision = getPreviousRevision(patchSetId);
                if (previousRevision != null) {
                    previous = getIssueIds(projectName, previousRevision);
                }
            } catch (RestApiException e) {
            // previous is still empty to indicate that there was no previous
            // accessible patch set. We treat every occurrence as added.
            }
        }
        for (String issue : current.keySet()) {
            Set<String> currentOccurrences = current.get(issue);
            Set<String> previousOccurrences = previous.get(issue);
            Set<String> newOccurrences;
            if (previousOccurrences == null || previousOccurrences.isEmpty()) {
                newOccurrences = Sets.newHashSet(currentOccurrences);
            } else {
                newOccurrences = Sets.newHashSet(currentOccurrences);
                newOccurrences.removeAll(previousOccurrences);
            }
            for (String occurrence : newOccurrences) {
                currentOccurrences.add("added@" + occurrence);
            }
        }
    }
    return current;
}
#method_after
public Map<String, Set<String>> getIssueIds(String projectName, String commitId, PatchSet.Id patchSetId) {
    Map<String, Set<String>> current = getIssueIds(projectName, commitId);
    if (patchSetId != null) {
        Map<String, Set<String>> previous = Maps.newHashMap();
        if (patchSetId.get() != 1) {
            PatchSet.Id previousPatchSetId = new PatchSet.Id(patchSetId.getParentKey(), patchSetId.get() - 1);
            String previousPatchSet = db.getRevision(previousPatchSetId);
            if (previousPatchSet != null) {
                previous = getIssueIds(projectName, previousPatchSet);
            }
        }
        for (String issue : current.keySet()) {
            Set<String> currentOccurrences = current.get(issue);
            Set<String> previousOccurrences = previous.get(issue);
            Set<String> newOccurrences;
            if (previousOccurrences == null || previousOccurrences.isEmpty()) {
                newOccurrences = Sets.newHashSet(currentOccurrences);
            } else {
                newOccurrences = Sets.newHashSet(currentOccurrences);
                newOccurrences.removeAll(previousOccurrences);
            }
            for (String occurrence : newOccurrences) {
                currentOccurrences.add("added@" + occurrence);
            }
        }
    }
    return current;
}
#end_block

#method_before
public Set<Property> extractFrom(ChangeAttribute changeAttribute) {
    Set<Property> properties = Sets.newHashSet();
    properties.add(propertyFactory.create("project", changeAttribute.project));
    properties.add(propertyFactory.create("branch", changeAttribute.branch));
    properties.add(propertyFactory.create("topic", changeAttribute.topic));
    properties.add(propertyFactory.create("subject", changeAttribute.subject));
    properties.add(propertyFactory.create("commit-message", changeAttribute.commitMessage));
    properties.add(propertyFactory.create("change-id", changeAttribute.id));
    properties.add(propertyFactory.create("change-number", Integer.toString(changeAttribute.number)));
    properties.add(propertyFactory.create("change-url", changeAttribute.url));
    String status = null;
    if (changeAttribute.status != null) {
        status = changeAttribute.status.toString();
    }
    properties.add(propertyFactory.create("status", status));
    properties.addAll(extractFrom(changeAttribute.owner, "owner"));
    return properties;
}
#method_after
public Set<Property> extractFrom(ChangeAttribute changeAttribute) {
    Set<Property> properties = Sets.newHashSet();
    properties.add(propertyFactory.create("project", changeAttribute.project));
    properties.add(propertyFactory.create("branch", changeAttribute.branch));
    properties.add(propertyFactory.create("topic", changeAttribute.topic));
    properties.add(propertyFactory.create("subject", changeAttribute.subject));
    properties.add(propertyFactory.create("commit-message", changeAttribute.commitMessage));
    properties.add(propertyFactory.create("change-id", changeAttribute.id));
    properties.add(propertyFactory.create("change-number", String.valueOf(changeAttribute.number)));
    properties.add(propertyFactory.create("change-url", changeAttribute.url));
    String status = null;
    if (changeAttribute.status != null) {
        status = changeAttribute.status.toString();
    }
    properties.add(propertyFactory.create("status", status));
    properties.addAll(extractFrom(changeAttribute.owner, "owner"));
    return properties;
}
#end_block

#method_before
public Set<Property> extractFrom(PatchSetAttribute patchSetAttribute) {
    Set<Property> properties = Sets.newHashSet();
    properties.add(propertyFactory.create("revision", patchSetAttribute.revision));
    properties.add(propertyFactory.create("patch-set-number", Integer.toString(patchSetAttribute.number)));
    properties.add(propertyFactory.create("ref", patchSetAttribute.ref));
    properties.add(propertyFactory.create("created-on", patchSetAttribute.createdOn.toString()));
    properties.add(propertyFactory.create("parents", patchSetAttribute.parents.toString()));
    properties.add(propertyFactory.create("deletions", Integer.toString(patchSetAttribute.sizeDeletions)));
    properties.add(propertyFactory.create("insertions", Integer.toString(patchSetAttribute.sizeInsertions)));
    properties.add(propertyFactory.create("is-draft", Boolean.toString(patchSetAttribute.isDraft)));
    properties.addAll(extractFrom(patchSetAttribute.uploader, "uploader"));
    properties.addAll(extractFrom(patchSetAttribute.author, "author"));
    return properties;
}
#method_after
public Set<Property> extractFrom(PatchSetAttribute patchSetAttribute) {
    Set<Property> properties = Sets.newHashSet();
    properties.add(propertyFactory.create("revision", patchSetAttribute.revision));
    properties.add(propertyFactory.create("patch-set-number", String.valueOf(patchSetAttribute.number)));
    properties.add(propertyFactory.create("ref", patchSetAttribute.ref));
    properties.add(propertyFactory.create("created-on", patchSetAttribute.createdOn.toString()));
    properties.add(propertyFactory.create("parents", patchSetAttribute.parents.toString()));
    properties.add(propertyFactory.create("deletions", Integer.toString(patchSetAttribute.sizeDeletions)));
    properties.add(propertyFactory.create("insertions", Integer.toString(patchSetAttribute.sizeInsertions)));
    properties.add(propertyFactory.create("is-draft", Boolean.toString(patchSetAttribute.isDraft)));
    properties.addAll(extractFrom(patchSetAttribute.uploader, "uploader"));
    properties.addAll(extractFrom(patchSetAttribute.author, "author"));
    return properties;
}
#end_block

#method_before
@Override
public void run() throws Failure {
    try {
        DeleteProject.Input input = new DeleteProject.Input();
        input.force = force;
        input.preserve = preserveGitRepository;
        ProjectResource rsrc = new ProjectResource(projectState);
        deleteProject.assertDeletePermission(rsrc);
        deleteProject.assertCanDelete(rsrc, input);
        if (!yesReallyDelete) {
            StringBuilder msgBuilder = new StringBuilder();
            msgBuilder.append("Really delete ");
            msgBuilder.append(rsrc.getName());
            msgBuilder.append("?\n");
            msgBuilder.append("This is an operation which permanently deletes ");
            msgBuilder.append("data. This cannot be undone!\n");
            msgBuilder.append("If you are sure you wish to delete this project, ");
            msgBuilder.append("re-run\n");
            msgBuilder.append("with the --yes-really-delete flag.\n");
            throw new UnloggedFailure(msgBuilder.toString());
        }
        if (!force) {
            Collection<String> warnings = deleteProject.getWarnings(rsrc);
            if (warnings != null && !warnings.isEmpty()) {
                StringBuilder msgBuilder = new StringBuilder();
                msgBuilder.append("There are warnings against deleting ");
                msgBuilder.append(rsrc.getName());
                msgBuilder.append(":\n");
                for (String warning : warnings) {
                    msgBuilder.append(" * ");
                    msgBuilder.append(warning);
                    msgBuilder.append("\n");
                }
                msgBuilder.append("To really delete ");
                msgBuilder.append(rsrc.getName());
                msgBuilder.append(", re-run with the --force flag.");
                throw new UnloggedFailure(msgBuilder.toString());
            }
        }
        deleteProject.doDelete(rsrc, input);
    } catch (AuthException | ResourceNotFoundException | ResourceConflictException | OrmException | IOException e) {
        die(e);
    }
}
#method_after
@Override
public void run() throws Failure {
    try {
        DeleteProject.Input input = new DeleteProject.Input();
        input.force = force;
        input.preserve = preserveGitRepository;
        ProjectResource rsrc = new ProjectResource(projectState, user);
        deleteProject.assertDeletePermission(rsrc);
        deleteProject.assertCanDelete(rsrc, input);
        if (!yesReallyDelete) {
            StringBuilder msgBuilder = new StringBuilder();
            msgBuilder.append("Really delete ");
            msgBuilder.append(rsrc.getName());
            msgBuilder.append("?\n");
            msgBuilder.append("This is an operation which permanently deletes ");
            msgBuilder.append("data. This cannot be undone!\n");
            msgBuilder.append("If you are sure you wish to delete this project, ");
            msgBuilder.append("re-run\n");
            msgBuilder.append("with the --yes-really-delete flag.\n");
            throw new UnloggedFailure(msgBuilder.toString());
        }
        if (!force) {
            Collection<String> warnings = deleteProject.getWarnings(rsrc);
            if (warnings != null && !warnings.isEmpty()) {
                StringBuilder msgBuilder = new StringBuilder();
                msgBuilder.append("There are warnings against deleting ");
                msgBuilder.append(rsrc.getName());
                msgBuilder.append(":\n");
                for (String warning : warnings) {
                    msgBuilder.append(" * ");
                    msgBuilder.append(warning);
                    msgBuilder.append("\n");
                }
                msgBuilder.append("To really delete ");
                msgBuilder.append(rsrc.getName());
                msgBuilder.append(", re-run with the --force flag.");
                throw new UnloggedFailure(msgBuilder.toString());
            }
        }
        deleteProject.doDelete(rsrc, input);
    } catch (AuthException | ResourceNotFoundException | ResourceConflictException | OrmException | IOException e) {
        die(e);
    }
}
#end_block

#method_before
@Test
public void revert() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo revertChange = gApi.changes().id(r.getChangeId()).revert().get();
    // expected messages on source change:
    // 1. Uploaded patch set 1.
    // 2. Patch Set 1: Code-Review+2
    // 3. Change has been successfully merged by Administrator
    // 4. Patch Set 1: Reverted
    List<ChangeMessageInfo> sourceMessages = new ArrayList<>(gApi.changes().id(r.getChangeId()).get().messages);
    assertThat(sourceMessages).hasSize(4);
    String expectedMessage = String.format("Created a revert of this change as %s", revertChange.changeId);
    assertThat(sourceMessages.get(3).message).isEqualTo(expectedMessage);
    assertThat(revertChange.messages).hasSize(1);
    assertThat(revertChange.messages.iterator().next().message).isEqualTo("Uploaded patch set 1.");
}
#method_after
@Test
public void revert() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo revertChange = gApi.changes().id(r.getChangeId()).revert().get();
    // expected messages on source change:
    // 1. Uploaded patch set 1.
    // 2. Patch Set 1: Code-Review+2
    // 3. Change has been successfully merged by Administrator
    // 4. Patch Set 1: Reverted
    List<ChangeMessageInfo> sourceMessages = new ArrayList<>(gApi.changes().id(r.getChangeId()).get().messages);
    assertThat(sourceMessages).hasSize(4);
    String expectedMessage = String.format("Created a revert of this change as %s", revertChange.changeId);
    assertThat(sourceMessages.get(3).message).isEqualTo(expectedMessage);
    assertThat(revertChange.messages).hasSize(1);
    assertThat(revertChange.messages.iterator().next().message).isEqualTo("Uploaded patch set 1.");
    assertThat(revertChange.revertOf).isEqualTo(gApi.changes().id(r.getChangeId()).get()._number);
}
#end_block

#method_before
private void testRebase(Rebase rebase) throws Exception {
    // Create two changes both with the same parent
    PushOneCommit.Result r = createChange();
    testRepo.reset("HEAD~1");
    PushOneCommit.Result r2 = createChange();
    // Approve and submit the first change
    RevisionApi revision = gApi.changes().id(r.getChangeId()).current();
    revision.review(ReviewInput.approve());
    revision.submit();
    // Add an approval whose score should be copied on trivial rebase
    gApi.changes().id(r2.getChangeId()).current().review(ReviewInput.recommend());
    String changeId = r2.getChangeId();
    // Rebase the second change
    rebase.call(changeId);
    // Second change should have 2 patch sets and an approval
    ChangeInfo c2 = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.DETAILED_LABELS));
    assertThat(c2.revisions.get(c2.currentRevision)._number).isEqualTo(2);
    // ...and the committer and description should be correct
    ChangeInfo info = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT));
    GitPerson committer = info.revisions.get(info.currentRevision).commit.committer;
    assertThat(committer.name).isEqualTo(admin.fullName);
    assertThat(committer.email).isEqualTo(admin.email);
    String description = info.revisions.get(info.currentRevision).description;
    assertThat(description).isEqualTo("Rebase");
    // ...and the approval was copied
    LabelInfo cr = c2.labels.get("Code-Review");
    assertThat(cr).isNotNull();
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).value).isEqualTo(1);
    if (notesMigration.changePrimaryStorage() == PrimaryStorage.REVIEW_DB) {
        // Ensure record was actually copied under ReviewDb
        List<PatchSetApproval> psas = unwrapDb(db).patchSetApprovals().byPatchSet(new PatchSet.Id(new Change.Id(c2._number), 2)).toList();
        assertThat(psas).hasSize(1);
        assertThat(psas.get(0).getValue()).isEqualTo((short) 1);
    }
    // Rebasing the second change again should fail
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Change is already up to date");
    gApi.changes().id(changeId).current().rebase();
}
#method_after
private void testRebase(Rebase rebase) throws Exception {
    // Create two changes both with the same parent
    PushOneCommit.Result r = createChange();
    testRepo.reset("HEAD~1");
    PushOneCommit.Result r2 = createChange();
    // Approve and submit the first change
    RevisionApi revision = gApi.changes().id(r.getChangeId()).current();
    revision.review(ReviewInput.approve());
    revision.submit();
    // Add an approval whose score should be copied on trivial rebase
    gApi.changes().id(r2.getChangeId()).current().review(ReviewInput.recommend());
    String changeId = r2.getChangeId();
    // Rebase the second change
    rebase.call(changeId);
    // Second change should have 2 patch sets and an approval
    ChangeInfo c2 = gApi.changes().id(changeId).get(CURRENT_REVISION, DETAILED_LABELS);
    assertThat(c2.revisions.get(c2.currentRevision)._number).isEqualTo(2);
    // ...and the committer and description should be correct
    ChangeInfo info = gApi.changes().id(changeId).get(CURRENT_REVISION, CURRENT_COMMIT);
    GitPerson committer = info.revisions.get(info.currentRevision).commit.committer;
    assertThat(committer.name).isEqualTo(admin.fullName);
    assertThat(committer.email).isEqualTo(admin.email);
    String description = info.revisions.get(info.currentRevision).description;
    assertThat(description).isEqualTo("Rebase");
    // ...and the approval was copied
    LabelInfo cr = c2.labels.get("Code-Review");
    assertThat(cr).isNotNull();
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).value).isEqualTo(1);
    if (notesMigration.changePrimaryStorage() == PrimaryStorage.REVIEW_DB) {
        // Ensure record was actually copied under ReviewDb
        List<PatchSetApproval> psas = unwrapDb(db).patchSetApprovals().byPatchSet(new PatchSet.Id(new Change.Id(c2._number), 2)).toList();
        assertThat(psas).hasSize(1);
        assertThat(psas.get(0).getValue()).isEqualTo((short) 1);
    }
    // Rebasing the second change again should fail
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Change is already up to date");
    gApi.changes().id(changeId).current().rebase();
}
#end_block

#method_before
@Test
public void pushCommitOfOtherUserThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // admin pushes commit of user
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, user.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.owner._accountId).isEqualTo(admin.id.get());
    CommitInfo commit = change.revisions.get(change.currentRevision).commit;
    assertThat(commit.author.email).isEqualTo(user.email);
    assertThat(commit.committer.email).isEqualTo(user.email);
    // check the user cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // check that the author/committer was NOT added as reviewer (he can't see
    // the change)
    assertThat(change.reviewers.get(REVIEWER)).isNull();
    assertThat(change.reviewers.get(CC)).isNull();
    assertThat(sender.getMessages()).isEmpty();
}
#method_after
@Test
public void pushCommitOfOtherUserThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // admin pushes commit of user
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, user.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.owner._accountId).isEqualTo(admin.id.get());
    CommitInfo commit = change.revisions.get(change.currentRevision).commit;
    assertThat(commit.author.email).isEqualTo(user.email);
    assertThat(commit.committer.email).isEqualTo(user.email);
    // check the user cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // check that the author/committer was NOT added as reviewer (he can't see
    // the change)
    assertThat(change.reviewers.get(REVIEWER)).isNull();
    assertThat(change.reviewers.get(CC)).isNull();
    assertThat(sender.getMessages()).isEmpty();
}
#end_block

#method_before
@Test
public void pushCommitWithFooterOfOtherUserThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // admin pushes commit that references 'user' in a footer
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo, PushOneCommit.SUBJECT + "\n\n" + FooterConstants.REVIEWED_BY.getName() + ": " + user.getIdent().toExternalString(), PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check that 'user' cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // check that 'user' was NOT added as cc ('user' can't see the change)
    setApiUser(admin);
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.reviewers.get(REVIEWER)).isNull();
    assertThat(change.reviewers.get(CC)).isNull();
    assertThat(sender.getMessages()).isEmpty();
}
#method_after
@Test
public void pushCommitWithFooterOfOtherUserThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // admin pushes commit that references 'user' in a footer
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo, PushOneCommit.SUBJECT + "\n\n" + FooterConstants.REVIEWED_BY.getName() + ": " + user.getIdent().toExternalString(), PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check that 'user' cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // check that 'user' was NOT added as cc ('user' can't see the change)
    setApiUser(admin);
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.reviewers.get(REVIEWER)).isNull();
    assertThat(change.reviewers.get(CC)).isNull();
    assertThat(sender.getMessages()).isEmpty();
}
#end_block

#method_before
@Test
public void addReviewerThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // create change
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check the user cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // try to add user as reviewer
    setApiUser(admin);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    AddReviewerResult r = gApi.changes().id(result.getChangeId()).addReviewer(in);
    assertThat(r.input).isEqualTo(user.email);
    assertThat(r.error).contains("does not have permission to see this change");
    assertThat(r.reviewers).isNull();
}
#method_after
@Test
public void addReviewerThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // create change
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check the user cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // try to add user as reviewer
    setApiUser(admin);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    AddReviewerResult r = gApi.changes().id(result.getChangeId()).addReviewer(in);
    assertThat(r.input).isEqualTo(user.email);
    assertThat(r.error).contains("does not have permission to see this change");
    assertThat(r.reviewers).isNull();
}
#end_block

#method_before
@Test
public void addReviewer() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailReplyTo(m, admin.email);
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = c.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
}
#method_after
@Test
public void addReviewer() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailReplyTo(m, admin.email);
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = c.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
    // Change status of reviewer and ensure ETag is updated.
    oldETag = rsrc.getETag();
    gApi.accounts().id(user.id.get()).setStatus("new status");
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
}
#end_block

#method_before
@Test
public void implicitlyCcOnNonVotingReviewGwtStyle() throws Exception {
    PushOneCommit.Result r = createChange();
    setApiUser(user);
    assertThat(getReviewerState(r.getChangeId(), user.id)).isEmpty();
    // Exact request format made by GWT UI at ddc6b7160fe416fed9e7e3180489d44c82fd64f8.
    ReviewInput in = new ReviewInput();
    in.labels = ImmutableMap.of("Code-Review", (short) 0);
    in.strictLabels = true;
    in.drafts = DraftHandling.PUBLISH_ALL_REVISIONS;
    in.message = "comment";
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(in);
    // If we're not reading from NoteDb, then the CCed user will be returned in the REVIEWER state.
    assertThat(getReviewerState(r.getChangeId(), user.id)).hasValue(notesMigration.readChanges() ? CC : REVIEWER);
}
#method_after
@Test
public void implicitlyCcOnNonVotingReviewGwtStyle() throws Exception {
    PushOneCommit.Result r = createChange();
    setApiUser(user);
    assertThat(getReviewerState(r.getChangeId(), user.id)).isEmpty();
    // Exact request format made by GWT UI at ddc6b7160fe416fed9e7e3180489d44c82fd64f8.
    ReviewInput in = new ReviewInput();
    in.labels = ImmutableMap.of("Code-Review", (short) 0);
    in.drafts = DraftHandling.PUBLISH_ALL_REVISIONS;
    in.message = "comment";
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(in);
    // If we're not reading from NoteDb, then the CCed user will be returned in the REVIEWER state.
    assertThat(getReviewerState(r.getChangeId(), user.id)).hasValue(notesMigration.readChanges() ? CC : REVIEWER);
}
#end_block

#method_before
@Test
public void removeReviewerNotPermitted() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    gApi.changes().id(changeId).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("delete reviewer not permitted");
    gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).remove();
}
#method_after
@Test
public void removeReviewerNotPermitted() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    gApi.changes().id(changeId).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("remove reviewer not permitted");
    gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).remove();
}
#end_block

#method_before
@Test
public void queryChangesOptions() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeInfo result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).get());
    assertThat(result.labels).isNull();
    assertThat(result.messages).isNull();
    assertThat(result.actions).isNull();
    assertThat(result.revisions).isNull();
    EnumSet<ListChangesOption> options = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CHANGE_ACTIONS, ListChangesOption.CURRENT_ACTIONS, ListChangesOption.DETAILED_LABELS, ListChangesOption.MESSAGES);
    result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).withOptions(options).get());
    assertThat(Iterables.getOnlyElement(result.labels.keySet())).isEqualTo("Code-Review");
    assertThat(result.messages).hasSize(1);
    assertThat(result.actions).isNotEmpty();
    RevisionInfo rev = Iterables.getOnlyElement(result.revisions.values());
    assertThat(rev._number).isEqualTo(r.getPatchSetId().get());
    assertThat(rev.created).isNotNull();
    assertThat(rev.uploader._accountId).isEqualTo(admin.getId().get());
    assertThat(rev.ref).isEqualTo(r.getPatchSetId().toRefName());
    assertThat(rev.actions).isNotEmpty();
}
#method_after
@Test
public void queryChangesOptions() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeInfo result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).get());
    assertThat(result.labels).isNull();
    assertThat(result.messages).isNull();
    assertThat(result.actions).isNull();
    assertThat(result.revisions).isNull();
    result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).withOptions(ALL_REVISIONS, CHANGE_ACTIONS, CURRENT_ACTIONS, DETAILED_LABELS, MESSAGES).get());
    assertThat(Iterables.getOnlyElement(result.labels.keySet())).isEqualTo("Code-Review");
    assertThat(result.messages).hasSize(1);
    assertThat(result.actions).isNotEmpty();
    RevisionInfo rev = Iterables.getOnlyElement(result.revisions.values());
    assertThat(rev._number).isEqualTo(r.getPatchSetId().get());
    assertThat(rev.created).isNotNull();
    assertThat(rev.uploader._accountId).isEqualTo(admin.getId().get());
    assertThat(rev.ref).isEqualTo(r.getPatchSetId().toRefName());
    assertThat(rev.actions).isNotEmpty();
}
#end_block

#method_before
@Test
public void submitted() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    assertThat(gApi.changes().id(r.getChangeId()).info().submitted).isNull();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    assertThat(gApi.changes().id(r.getChangeId()).info().submitted).isNotNull();
}
#method_after
@Test
public void submitted() throws Exception {
    PushOneCommit.Result r = createChange();
    String id = r.getChangeId();
    ChangeInfo c = gApi.changes().id(r.getChangeId()).info();
    assertThat(c.submitted).isNull();
    assertThat(c.submitter).isNull();
    gApi.changes().id(id).current().review(ReviewInput.approve());
    gApi.changes().id(id).current().submit();
    c = gApi.changes().id(r.getChangeId()).info();
    assertThat(c.submitted).isNotNull();
    assertThat(c.submitter).isNotNull();
    assertThat(c.submitter._accountId).isEqualTo(atrScope.get().getUser().getAccountId().get());
}
#end_block

#method_before
@Test
public void check() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(gApi.changes().id(r.getChangeId()).get().problems).isNull();
    assertThat(gApi.changes().id(r.getChangeId()).get(EnumSet.of(ListChangesOption.CHECK)).problems).isEmpty();
}
#method_after
@Test
public void check() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(gApi.changes().id(r.getChangeId()).get().problems).isNull();
    assertThat(gApi.changes().id(r.getChangeId()).get(CHECK).problems).isEmpty();
}
#end_block

#method_before
@Test
public void commitFooters() throws Exception {
    LabelType verified = category("Verified", value(1, "Passes"), value(0, "No score"), value(-1, "Failed"));
    LabelType custom1 = category("Custom1", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    LabelType custom2 = category("Custom2", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().put(verified.getName(), verified);
    cfg.getLabelSections().put(custom1.getName(), custom1);
    cfg.getLabelSections().put(custom2.getName(), custom2);
    String heads = "refs/heads/*";
    AccountGroup.UUID anon = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel("Verified"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom1"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom2"), -1, 1, anon, heads);
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r1 = createChange();
    r1.assertOkStatus();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "new content", r1.getChangeId()).to("refs/for/master");
    r2.assertOkStatus();
    ReviewInput in = new ReviewInput();
    in.label("Code-Review", 1);
    in.label("Verified", 1);
    in.label("Custom1", -1);
    in.label("Custom2", 1);
    gApi.changes().id(r2.getChangeId()).current().review(in);
    EnumSet<ListChangesOption> options = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.COMMIT_FOOTERS);
    ChangeInfo actual = gApi.changes().id(r2.getChangeId()).get(options);
    assertThat(actual.revisions).hasSize(2);
    // No footers except on latest patch set.
    assertThat(actual.revisions.get(r1.getCommit().getName()).commitWithFooters).isNull();
    List<String> footers = new ArrayList<>(Arrays.asList(actual.revisions.get(r2.getCommit().getName()).commitWithFooters.split("\\n")));
    // remove subject + blank line
    footers.remove(0);
    footers.remove(0);
    List<String> expectedFooters = Arrays.asList("Change-Id: " + r2.getChangeId(), "Reviewed-on: " + canonicalWebUrl.get() + r2.getChange().getId(), "Reviewed-by: Administrator <admin@example.com>", "Custom2: Administrator <admin@example.com>", "Tested-by: Administrator <admin@example.com>");
    assertThat(footers).containsExactlyElementsIn(expectedFooters);
}
#method_after
@Test
public void commitFooters() throws Exception {
    LabelType verified = category("Verified", value(1, "Passes"), value(0, "No score"), value(-1, "Failed"));
    LabelType custom1 = category("Custom1", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    LabelType custom2 = category("Custom2", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().put(verified.getName(), verified);
    cfg.getLabelSections().put(custom1.getName(), custom1);
    cfg.getLabelSections().put(custom2.getName(), custom2);
    String heads = "refs/heads/*";
    AccountGroup.UUID anon = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel("Verified"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom1"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom2"), -1, 1, anon, heads);
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r1 = createChange();
    r1.assertOkStatus();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "new content", r1.getChangeId()).to("refs/for/master");
    r2.assertOkStatus();
    ReviewInput in = new ReviewInput();
    in.label("Code-Review", 1);
    in.label("Verified", 1);
    in.label("Custom1", -1);
    in.label("Custom2", 1);
    gApi.changes().id(r2.getChangeId()).current().review(in);
    ChangeInfo actual = gApi.changes().id(r2.getChangeId()).get(ALL_REVISIONS, COMMIT_FOOTERS);
    assertThat(actual.revisions).hasSize(2);
    // No footers except on latest patch set.
    assertThat(actual.revisions.get(r1.getCommit().getName()).commitWithFooters).isNull();
    List<String> footers = new ArrayList<>(Arrays.asList(actual.revisions.get(r2.getCommit().getName()).commitWithFooters.split("\\n")));
    // remove subject + blank line
    footers.remove(0);
    footers.remove(0);
    List<String> expectedFooters = Arrays.asList("Change-Id: " + r2.getChangeId(), "Reviewed-on: " + canonicalWebUrl.get() + r2.getChange().getId(), "Reviewed-by: Administrator <admin@example.com>", "Custom2: Administrator <admin@example.com>", "Tested-by: Administrator <admin@example.com>");
    assertThat(footers).containsExactlyElementsIn(expectedFooters);
}
#end_block

#method_before
@Test
public void customCommitFooters() throws Exception {
    PushOneCommit.Result change = createChange();
    RegistrationHandle handle = changeMessageModifiers.add(new ChangeMessageModifier() {

        @Override
        public String onSubmit(String newCommitMessage, RevCommit original, RevCommit mergeTip, Branch.NameKey destination) {
            assertThat(original.getName()).isNotEqualTo(mergeTip.getName());
            return newCommitMessage + "Custom: " + destination.get();
        }
    });
    ChangeInfo actual;
    try {
        EnumSet<ListChangesOption> options = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.COMMIT_FOOTERS);
        actual = gApi.changes().id(change.getChangeId()).get(options);
    } finally {
        handle.remove();
    }
    List<String> footers = new ArrayList<>(Arrays.asList(actual.revisions.get(change.getCommit().getName()).commitWithFooters.split("\\n")));
    // remove subject + blank line
    footers.remove(0);
    footers.remove(0);
    List<String> expectedFooters = Arrays.asList("Change-Id: " + change.getChangeId(), "Reviewed-on: " + canonicalWebUrl.get() + change.getChange().getId(), "Custom: refs/heads/master");
    assertThat(footers).containsExactlyElementsIn(expectedFooters);
}
#method_after
@Test
public void customCommitFooters() throws Exception {
    PushOneCommit.Result change = createChange();
    RegistrationHandle handle = changeMessageModifiers.add(new ChangeMessageModifier() {

        @Override
        public String onSubmit(String newCommitMessage, RevCommit original, RevCommit mergeTip, Branch.NameKey destination) {
            assertThat(original.getName()).isNotEqualTo(mergeTip.getName());
            return newCommitMessage + "Custom: " + destination.get();
        }
    });
    ChangeInfo actual;
    try {
        actual = gApi.changes().id(change.getChangeId()).get(ALL_REVISIONS, COMMIT_FOOTERS);
    } finally {
        handle.remove();
    }
    List<String> footers = new ArrayList<>(Arrays.asList(actual.revisions.get(change.getCommit().getName()).commitWithFooters.split("\\n")));
    // remove subject + blank line
    footers.remove(0);
    footers.remove(0);
    List<String> expectedFooters = Arrays.asList("Change-Id: " + change.getChangeId(), "Reviewed-on: " + canonicalWebUrl.get() + change.getChange().getId(), "Custom: refs/heads/master");
    assertThat(footers).containsExactlyElementsIn(expectedFooters);
}
#end_block

#method_before
@Test
public void defaultSearchDoesNotTouchDatabase() throws Exception {
    setApiUser(admin);
    PushOneCommit.Result r1 = createChange();
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).submit();
    createChange();
    createDraftChange();
    setApiUser(user);
    AcceptanceTestRequestScope.Context ctx = disableDb();
    try {
        assertThat(gApi.changes().query().withQuery("project:{" + project.get() + "} (status:open OR status:closed)").withOption(ListChangesOption.LABELS).withOption(ListChangesOption.DETAILED_ACCOUNTS).withOption(ListChangesOption.REVIEWED).get()).hasSize(2);
    } finally {
        enableDb(ctx);
    }
}
#method_after
@Test
public void defaultSearchDoesNotTouchDatabase() throws Exception {
    setApiUser(admin);
    PushOneCommit.Result r1 = createChange();
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).submit();
    createChange();
    setApiUser(user);
    AcceptanceTestRequestScope.Context ctx = disableDb();
    try {
        assertThat(gApi.changes().query().withQuery("project:{" + project.get() + "} (status:open OR status:closed)").withOption(LABELS).withOption(DETAILED_ACCOUNTS).withOption(REVIEWED).get()).hasSize(2);
    } finally {
        enableDb(ctx);
    }
}
#end_block

#method_before
@Test
public void votable() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(triplet).addReviewer(user.username);
    ChangeInfo c = gApi.changes().id(triplet).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
    LabelInfo codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    ApprovalInfo approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.value).isEqualTo(0);
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.blockLabel(cfg, "Code-Review", REGISTERED_USERS, "refs/heads/*");
    saveProjectConfig(project, cfg);
    c = gApi.changes().id(triplet).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
    codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.value).isNull();
}
#method_after
@Test
public void votable() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(triplet).addReviewer(user.username);
    ChangeInfo c = gApi.changes().id(triplet).get(DETAILED_LABELS);
    LabelInfo codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    ApprovalInfo approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.value).isEqualTo(0);
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.blockLabel(cfg, "Code-Review", REGISTERED_USERS, "refs/heads/*");
    saveProjectConfig(project, cfg);
    c = gApi.changes().id(triplet).get(DETAILED_LABELS);
    codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.value).isNull();
}
#end_block

#method_before
@Test
@GerritConfig(name = "gerrit.editGpgKeys", value = "true")
@GerritConfig(name = "receive.enableSignedPush", value = "true")
public void pushCertificates() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = amendChange(r1.getChangeId());
    ChangeInfo info = gApi.changes().id(r1.getChangeId()).get(EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.PUSH_CERTIFICATES));
    RevisionInfo rev1 = info.revisions.get(r1.getCommit().name());
    assertThat(rev1).isNotNull();
    assertThat(rev1.pushCertificate).isNotNull();
    assertThat(rev1.pushCertificate.certificate).isNull();
    assertThat(rev1.pushCertificate.key).isNull();
    RevisionInfo rev2 = info.revisions.get(r2.getCommit().name());
    assertThat(rev2).isNotNull();
    assertThat(rev2.pushCertificate).isNotNull();
    assertThat(rev2.pushCertificate.certificate).isNull();
    assertThat(rev2.pushCertificate.key).isNull();
}
#method_after
@Test
@GerritConfig(name = "gerrit.editGpgKeys", value = "true")
@GerritConfig(name = "receive.enableSignedPush", value = "true")
public void pushCertificates() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = amendChange(r1.getChangeId());
    ChangeInfo info = gApi.changes().id(r1.getChangeId()).get(ALL_REVISIONS, PUSH_CERTIFICATES);
    RevisionInfo rev1 = info.revisions.get(r1.getCommit().name());
    assertThat(rev1).isNotNull();
    assertThat(rev1.pushCertificate).isNotNull();
    assertThat(rev1.pushCertificate.certificate).isNull();
    assertThat(rev1.pushCertificate.key).isNull();
    RevisionInfo rev2 = info.revisions.get(r2.getCommit().name());
    assertThat(rev2).isNotNull();
    assertThat(rev2.pushCertificate).isNotNull();
    assertThat(rev2.pushCertificate.certificate).isNull();
    assertThat(rev2.pushCertificate.key).isNull();
}
#end_block

#method_before
@Test
public void createMergePatchSet() throws Exception {
    PushOneCommit.Result start = pushTo("refs/heads/master");
    start.assertOkStatus();
    // create a change for master
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    String changeId = r.getChangeId();
    testRepo.reset(start.getCommit());
    PushOneCommit.Result currentMaster = pushTo("refs/heads/master");
    currentMaster.assertOkStatus();
    String parent = currentMaster.getCommit().getName();
    // push a commit into dev branch
    createBranch(new Branch.NameKey(project, "dev"));
    PushOneCommit.Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", "A.txt", "A content").to("refs/heads/dev");
    changeA.assertOkStatus();
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = "dev";
    MergePatchSetInput in = new MergePatchSetInput();
    in.merge = mergeInput;
    in.subject = "update change by merge ps2";
    gApi.changes().id(changeId).createMergePatchSet(in);
    ChangeInfo changeInfo = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION));
    assertThat(changeInfo.revisions.size()).isEqualTo(2);
    assertThat(changeInfo.subject).isEqualTo(in.subject);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isEqualTo(parent);
}
#method_after
@Test
public void createMergePatchSet() throws Exception {
    PushOneCommit.Result start = pushTo("refs/heads/master");
    start.assertOkStatus();
    // create a change for master
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    String changeId = r.getChangeId();
    testRepo.reset(start.getCommit());
    PushOneCommit.Result currentMaster = pushTo("refs/heads/master");
    currentMaster.assertOkStatus();
    String parent = currentMaster.getCommit().getName();
    // push a commit into dev branch
    createBranch(new Branch.NameKey(project, "dev"));
    PushOneCommit.Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", "A.txt", "A content").to("refs/heads/dev");
    changeA.assertOkStatus();
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = "dev";
    MergePatchSetInput in = new MergePatchSetInput();
    in.merge = mergeInput;
    in.subject = "update change by merge ps2";
    gApi.changes().id(changeId).createMergePatchSet(in);
    ChangeInfo changeInfo = gApi.changes().id(changeId).get(ALL_REVISIONS, CURRENT_COMMIT, CURRENT_REVISION);
    assertThat(changeInfo.revisions.size()).isEqualTo(2);
    assertThat(changeInfo.subject).isEqualTo(in.subject);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isEqualTo(parent);
}
#end_block

#method_before
@Test
public void createMergePatchSetInheritParent() throws Exception {
    PushOneCommit.Result start = pushTo("refs/heads/master");
    start.assertOkStatus();
    // create a change for master
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    String changeId = r.getChangeId();
    String parent = r.getCommit().getParent(0).getName();
    // advance master branch
    testRepo.reset(start.getCommit());
    PushOneCommit.Result currentMaster = pushTo("refs/heads/master");
    currentMaster.assertOkStatus();
    // push a commit into dev branch
    createBranch(new Branch.NameKey(project, "dev"));
    PushOneCommit.Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", "A.txt", "A content").to("refs/heads/dev");
    changeA.assertOkStatus();
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = "dev";
    MergePatchSetInput in = new MergePatchSetInput();
    in.merge = mergeInput;
    in.subject = "update change by merge ps2 inherit parent of ps1";
    in.inheritParent = true;
    gApi.changes().id(changeId).createMergePatchSet(in);
    ChangeInfo changeInfo = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION));
    assertThat(changeInfo.revisions.size()).isEqualTo(2);
    assertThat(changeInfo.subject).isEqualTo(in.subject);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isEqualTo(parent);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isNotEqualTo(currentMaster.getCommit().getName());
}
#method_after
@Test
public void createMergePatchSetInheritParent() throws Exception {
    PushOneCommit.Result start = pushTo("refs/heads/master");
    start.assertOkStatus();
    // create a change for master
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    String changeId = r.getChangeId();
    String parent = r.getCommit().getParent(0).getName();
    // advance master branch
    testRepo.reset(start.getCommit());
    PushOneCommit.Result currentMaster = pushTo("refs/heads/master");
    currentMaster.assertOkStatus();
    // push a commit into dev branch
    createBranch(new Branch.NameKey(project, "dev"));
    PushOneCommit.Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", "A.txt", "A content").to("refs/heads/dev");
    changeA.assertOkStatus();
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = "dev";
    MergePatchSetInput in = new MergePatchSetInput();
    in.merge = mergeInput;
    in.subject = "update change by merge ps2 inherit parent of ps1";
    in.inheritParent = true;
    gApi.changes().id(changeId).createMergePatchSet(in);
    ChangeInfo changeInfo = gApi.changes().id(changeId).get(ALL_REVISIONS, CURRENT_COMMIT, CURRENT_REVISION);
    assertThat(changeInfo.revisions.size()).isEqualTo(2);
    assertThat(changeInfo.subject).isEqualTo(in.subject);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isEqualTo(parent);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isNotEqualTo(currentMaster.getCommit().getName());
}
#end_block

#method_before
@Test
public void maxPermittedValueAllowed() throws Exception {
    final int minPermittedValue = -2;
    final int maxPermittedValue = +2;
    String heads = "refs/heads/*";
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(triplet).addReviewer(user.username);
    ChangeInfo c = gApi.changes().id(triplet).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
    LabelInfo codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    ApprovalInfo approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.permittedVotingRange).isNotNull();
    // default values
    assertThat(approval.permittedVotingRange.min).isEqualTo(-1);
    assertThat(approval.permittedVotingRange.max).isEqualTo(1);
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.allow(cfg, Permission.forLabel("Code-Review"), minPermittedValue, maxPermittedValue, REGISTERED_USERS, heads);
    saveProjectConfig(project, cfg);
    c = gApi.changes().id(triplet).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
    codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.permittedVotingRange).isNotNull();
    assertThat(approval.permittedVotingRange.min).isEqualTo(minPermittedValue);
    assertThat(approval.permittedVotingRange.max).isEqualTo(maxPermittedValue);
}
#method_after
@Test
public void maxPermittedValueAllowed() throws Exception {
    final int minPermittedValue = -2;
    final int maxPermittedValue = +2;
    String heads = "refs/heads/*";
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(triplet).addReviewer(user.username);
    ChangeInfo c = gApi.changes().id(triplet).get(DETAILED_LABELS);
    LabelInfo codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    ApprovalInfo approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.permittedVotingRange).isNotNull();
    // default values
    assertThat(approval.permittedVotingRange.min).isEqualTo(-1);
    assertThat(approval.permittedVotingRange.max).isEqualTo(1);
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.allow(cfg, Permission.forLabel("Code-Review"), minPermittedValue, maxPermittedValue, REGISTERED_USERS, heads);
    saveProjectConfig(project, cfg);
    c = gApi.changes().id(triplet).get(DETAILED_LABELS);
    codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.permittedVotingRange).isNotNull();
    assertThat(approval.permittedVotingRange.min).isEqualTo(minPermittedValue);
    assertThat(approval.permittedVotingRange.max).isEqualTo(maxPermittedValue);
}
#end_block

#method_before
@Test
public void maxPermittedValueBlocked() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.blockLabel(cfg, "Code-Review", REGISTERED_USERS, "refs/heads/*");
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(triplet).addReviewer(user.username);
    ChangeInfo c = gApi.changes().id(triplet).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
    LabelInfo codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    ApprovalInfo approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.permittedVotingRange).isNull();
}
#method_after
@Test
public void maxPermittedValueBlocked() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.blockLabel(cfg, "Code-Review", REGISTERED_USERS, "refs/heads/*");
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(triplet).addReviewer(user.username);
    ChangeInfo c = gApi.changes().id(triplet).get(DETAILED_LABELS);
    LabelInfo codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    ApprovalInfo approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.permittedVotingRange).isNull();
}
#end_block

#method_before
@Sandboxed
@Test
public void unresolvedCommentsBlocked() throws Exception {
    RevCommit oldHead = getRemoteHead();
    GitUtil.fetch(testRepo, RefNames.REFS_CONFIG + ":config");
    testRepo.reset("config");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, "Configure", "rules.pl", "submit_rule(submit(R)) :- \n" + "gerrit:unresolved_comments_count(0), \n" + "!," + "gerrit:commit_author(A), \n" + "R = label('All-Comments-Resolved', ok(A)).\n" + "submit_rule(submit(R)) :- \n" + "gerrit:unresolved_comments_count(U), \n" + "U > 0," + "R = label('All-Comments-Resolved', need(_)). \n\n");
    push.to(RefNames.REFS_CONFIG);
    testRepo.reset(oldHead);
    oldHead = getRemoteHead();
    PushOneCommit.Result result1 = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    testRepo.reset(oldHead);
    PushOneCommit.Result result2 = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    addComment(result1, "comment 1", true, false, null);
    addComment(result2, "comment 2", true, true, null);
    gApi.changes().id(result1.getChangeId()).current().submit();
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Failed to submit 1 change due to the following problems:\n" + "Change 2: needs All-Comments-Resolved");
    gApi.changes().id(result2.getChangeId()).current().submit();
}
#method_after
@Test
public void unresolvedCommentsBlocked() throws Exception {
    modifySubmitRules("submit_rule(submit(R)) :- \n" + "gerrit:unresolved_comments_count(0), \n" + "!," + "gerrit:commit_author(A), \n" + "R = label('All-Comments-Resolved', ok(A)).\n" + "submit_rule(submit(R)) :- \n" + "gerrit:unresolved_comments_count(U), \n" + "U > 0," + "R = label('All-Comments-Resolved', need(_)). \n\n");
    String oldHead = getRemoteHead().name();
    PushOneCommit.Result result1 = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    testRepo.reset(oldHead);
    PushOneCommit.Result result2 = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    addComment(result1, "comment 1", true, false, null);
    addComment(result2, "comment 2", true, true, null);
    gApi.changes().id(result1.getChangeId()).current().submit();
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Failed to submit 1 change due to the following problems");
    exception.expectMessage("needs All-Comments-Resolved");
    gApi.changes().id(result2.getChangeId()).current().submit();
}
#end_block

#method_before
public void submittableAfterLosingPermissions(String label) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID registered = systemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel(label), -1, +1, registered, "refs/heads/*");
    Util.allow(cfg, Permission.forLabel("Code-Review"), -2, +2, registered, "refs/heads/*");
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    assertThat(gApi.changes().id(changeId).get().submittable).isFalse();
    setApiUser(user);
    ReviewInput input = new ReviewInput();
    input.label("Code-Review", 2);
    input.label(label, 1);
    gApi.changes().id(changeId).current().review(input);
    assertThat(gApi.changes().id(changeId).get().submittable).isTrue();
    // Remove user's permission for 'Label'.
    Util.remove(cfg, Permission.forLabel(label), registered, "refs/heads/*");
    // Update user's permitted range for 'Code-Review' to be -1...+1.
    Util.remove(cfg, Permission.forLabel("Code-Review"), registered, "refs/heads/*");
    Util.allow(cfg, Permission.forLabel("Code-Review"), -1, +1, registered, "refs/heads/*");
    saveProjectConfig(project, cfg);
    assertThat(gApi.changes().id(changeId).get().submittable).isTrue();
    setApiUser(admin);
    gApi.changes().id(changeId).current().submit();
}
#method_after
public void submittableAfterLosingPermissions(String label) throws Exception {
    String codeReviewLabel = "Code-Review";
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID registered = SystemGroupBackend.REGISTERED_USERS;
    Util.allow(cfg, Permission.forLabel(label), -1, +1, registered, "refs/heads/*");
    Util.allow(cfg, Permission.forLabel(codeReviewLabel), -2, +2, registered, "refs/heads/*");
    saveProjectConfig(cfg);
    setApiUser(user);
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    // Verify user's permitted range.
    ChangeInfo change = gApi.changes().id(changeId).get();
    assertPermitted(change, label, -1, 0, 1);
    assertPermitted(change, codeReviewLabel, -2, -1, 0, 1, 2);
    ReviewInput input = new ReviewInput();
    input.label(codeReviewLabel, 2);
    input.label(label, 1);
    gApi.changes().id(changeId).current().review(input);
    assertThat(gApi.changes().id(changeId).current().reviewer(user.email).votes().keySet()).containsExactly(codeReviewLabel, label);
    assertThat(gApi.changes().id(changeId).current().reviewer(user.email).votes().values()).containsExactly((short) 2, (short) 1);
    assertThat(gApi.changes().id(changeId).get().submittable).isTrue();
    setApiUser(admin);
    // Remove user's permission for 'Label'.
    Util.remove(cfg, Permission.forLabel(label), registered, "refs/heads/*");
    // Update user's permitted range for 'Code-Review' to be -1...+1.
    Util.remove(cfg, Permission.forLabel(codeReviewLabel), registered, "refs/heads/*");
    Util.allow(cfg, Permission.forLabel(codeReviewLabel), -1, +1, registered, "refs/heads/*");
    saveProjectConfig(cfg);
    // Verify user's new permitted range.
    setApiUser(user);
    change = gApi.changes().id(changeId).get();
    assertPermitted(change, label);
    assertPermitted(change, codeReviewLabel, -1, 0, 1);
    assertThat(gApi.changes().id(changeId).current().reviewer(user.email).votes().values()).containsExactly((short) 2, (short) 1);
    assertThat(gApi.changes().id(changeId).get().submittable).isTrue();
    setApiUser(admin);
    gApi.changes().id(changeId).current().submit();
}
#end_block

#method_before
private ChangeResource parseResource(PushOneCommit.Result r) throws Exception {
    List<ChangeControl> ctls = changeFinder.find(r.getChangeId(), atrScope.get().getUser());
    assertThat(ctls).hasSize(1);
    return changeResourceFactory.create(ctls.get(0));
}
#method_after
private ChangeResource parseResource(PushOneCommit.Result r) throws Exception {
    return parseChangeResource(r.getChangeId());
}
#end_block

#method_before
private Optional<ReviewerState> getReviewerState(String changeId, Account.Id accountId) throws Exception {
    ChangeInfo c = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
    Set<ReviewerState> states = c.reviewers.entrySet().stream().filter(e -> e.getValue().stream().anyMatch(a -> a._accountId == accountId.get())).map(e -> e.getKey()).collect(toSet());
    assertThat(states.size()).named(states.toString()).isAtMost(1);
    return states.stream().findFirst();
}
#method_after
private Optional<ReviewerState> getReviewerState(String changeId, Account.Id accountId) throws Exception {
    ChangeInfo c = gApi.changes().id(changeId).get(DETAILED_LABELS);
    Set<ReviewerState> states = c.reviewers.entrySet().stream().filter(e -> e.getValue().stream().anyMatch(a -> a._accountId == accountId.get())).map(e -> e.getKey()).collect(toSet());
    assertThat(states.size()).named(states.toString()).isAtMost(1);
    return states.stream().findFirst();
}
#end_block

#method_before
protected void beforeTest(Description description) throws Exception {
    this.description = description;
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.initAndStart(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.initAndStart(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    admin = accountCreator.admin();
    user = accountCreator.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    db = reviewDbProvider.open();
    testRequiresSsh = classDesc.useSshAnnotation() || methodDesc.useSshAnnotation();
    if (testRequiresSsh && SshMode.useSsh() && (adminSshSession == null || userSshSession == null)) {
        // Create Ssh sessions
        initSsh(admin);
        Context ctx = newRequestContext(user);
        atrScope.set(ctx);
        userSshSession = ctx.getSession();
        userSshSession.open();
        ctx = newRequestContext(admin);
        atrScope.set(ctx);
        adminSshSession = ctx.getSession();
        adminSshSession.open();
    }
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#method_after
protected void beforeTest(Description description) throws Exception {
    this.description = description;
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.initAndStart(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.initAndStart(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    db = reviewDbProvider.open();
    // All groups which were added during the server start (e.g. in SchemaCreator) aren't contained
    // in the instance of the group index which is available here and in tests. There are two
    // reasons:
    // 1) No group index is available in SchemaCreator when using an in-memory database. (This could
    // be fixed by using the IndexManagerOnInit in InMemoryDatabase similar as BaseInit uses it.)
    // 2) During the on-init part of the server start, we use another instance of the index than
    // later on. As test indexes are non-permanent, closing an instance and opening another one
    // removes all indexed data.
    // As a workaround, we simply reindex all available groups here.
    Iterable<AccountGroup> allGroups = groups.getAll(db)::iterator;
    for (AccountGroup group : allGroups) {
        groupCache.evict(group.getGroupUUID(), group.getId(), group.getNameKey());
    }
    admin = accountCreator.admin();
    user = accountCreator.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    testRequiresSsh = classDesc.useSshAnnotation() || methodDesc.useSshAnnotation();
    if (testRequiresSsh && SshMode.useSsh() && (adminSshSession == null || userSshSession == null)) {
        // Create Ssh sessions
        initSsh(admin);
        Context ctx = newRequestContext(user);
        atrScope.set(ctx);
        userSshSession = ctx.getSession();
        userSshSession.open();
        ctx = newRequestContext(admin);
        atrScope.set(ctx);
        adminSshSession = ctx.getSession();
        adminSshSession.open();
    }
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#end_block

#method_before
protected ChangeInfo get(String id, ListChangesOption... options) throws RestApiException {
    return gApi.changes().id(id).get(Sets.newEnumSet(Arrays.asList(options), ListChangesOption.class));
}
#method_after
protected ChangeInfo get(String id, ListChangesOption... options) throws RestApiException {
    return gApi.changes().id(id).get(options);
}
#end_block

#method_before
protected void grant(Project.NameKey project, String ref, String permission, boolean force) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    AccountGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators"));
    grant(project, ref, permission, force, adminGroup.getGroupUUID());
}
#method_after
protected void grant(Project.NameKey project, String ref, String permission, boolean force) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    InternalGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null);
    grant(project, ref, permission, force, adminGroup.getGroupUUID());
}
#end_block

#method_before
protected void assertSubmittedTogether(String chId, String... expected) throws Exception {
    List<ChangeInfo> actual = gApi.changes().id(chId).submittedTogether();
    SubmittedTogetherInfo info = gApi.changes().id(chId).submittedTogether(EnumSet.of(NON_VISIBLE_CHANGES));
    assertThat(info.nonVisibleChanges).isEqualTo(0);
    assertThat(actual).hasSize(expected.length);
    assertThat(changeIds(actual)).containsExactly((Object[]) expected).inOrder();
    assertThat(changeIds(info.changes)).containsExactly((Object[]) expected).inOrder();
}
#method_after
protected void assertSubmittedTogether(String chId, String... expected) throws Exception {
    List<ChangeInfo> actual = gApi.changes().id(chId).submittedTogether();
    SubmittedTogetherInfo info = gApi.changes().id(chId).submittedTogether(EnumSet.of(NON_VISIBLE_CHANGES));
    assertThat(info.nonVisibleChanges).isEqualTo(0);
    assertThat(changeIds(actual)).containsExactly((Object[]) expected).inOrder();
    assertThat(changeIds(info.changes)).containsExactly((Object[]) expected).inOrder();
}
#end_block

#method_before
protected ChangeResource parseChangeResource(String changeId) throws Exception {
    List<ChangeControl> ctls = changeFinder.find(changeId, atrScope.get().getUser());
    assertThat(ctls).hasSize(1);
    return changeResourceFactory.create(ctls.get(0));
}
#method_after
protected ChangeResource parseChangeResource(String changeId) throws Exception {
    List<ChangeNotes> notes = changeFinder.find(changeId);
    assertThat(notes).hasSize(1);
    return changeResourceFactory.create(notes.get(0), atrScope.get().getUser());
}
#end_block

#method_before
protected ContributorAgreement configureContributorAgreement(boolean autoVerify) throws Exception {
    ContributorAgreement ca;
    if (autoVerify) {
        String g = createGroup("cla-test-group");
        GroupApi groupApi = gApi.groups().id(g);
        groupApi.description("CLA test group");
        AccountGroup caGroup = groupCache.get(new AccountGroup.UUID(groupApi.detail().id));
        GroupReference groupRef = GroupReference.forGroup(caGroup);
        PermissionRule rule = new PermissionRule(groupRef);
        rule.setAction(PermissionRule.Action.ALLOW);
        ca = new ContributorAgreement("cla-test");
        ca.setAutoVerify(groupRef);
        ca.setAccepted(ImmutableList.of(rule));
    } else {
        ca = new ContributorAgreement("cla-test-no-auto-verify");
    }
    ca.setDescription("description");
    ca.setAgreementUrl("agreement-url");
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    cfg.replace(ca);
    saveProjectConfig(allProjects, cfg);
    return ca;
}
#method_after
protected ContributorAgreement configureContributorAgreement(boolean autoVerify) throws Exception {
    ContributorAgreement ca;
    if (autoVerify) {
        String g = createGroup("cla-test-group");
        GroupApi groupApi = gApi.groups().id(g);
        groupApi.description("CLA test group");
        InternalGroup caGroup = groupCache.get(new AccountGroup.UUID(groupApi.detail().id)).orElse(null);
        GroupReference groupRef = new GroupReference(caGroup.getGroupUUID(), caGroup.getName());
        PermissionRule rule = new PermissionRule(groupRef);
        rule.setAction(PermissionRule.Action.ALLOW);
        ca = new ContributorAgreement("cla-test");
        ca.setAutoVerify(groupRef);
        ca.setAccepted(ImmutableList.of(rule));
    } else {
        ca = new ContributorAgreement("cla-test-no-auto-verify");
    }
    ca.setDescription("description");
    ca.setAgreementUrl("agreement-url");
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    cfg.replace(ca);
    saveProjectConfig(allProjects, cfg);
    return ca;
}
#end_block

#method_before
@Override
protected ChangeInfo applyImpl(BatchUpdate.Factory updateFactory, ChangeResource rsrc, MoveInput input) throws RestApiException, OrmException, UpdateException, PermissionBackendException {
    Change change = rsrc.getChange();
    Project.NameKey project = rsrc.getProject();
    IdentifiedUser caller = rsrc.getUser();
    input.destinationBranch = RefNames.fullName(input.destinationBranch);
    if (change.getStatus().isClosed()) {
        throw new ResourceConflictException("Change is " + ChangeUtil.status(change));
    }
    Branch.NameKey newDest = new Branch.NameKey(project, input.destinationBranch);
    if (change.getDest().equals(newDest)) {
        throw new ResourceConflictException("Change is already destined for the specified branch");
    }
    // Move requires abandoning this change, and creating a new change.
    try {
        rsrc.permissions().database(dbProvider).check(ChangePermission.ABANDON);
        permissionBackend.user(caller).database(dbProvider).ref(newDest).check(RefPermission.CREATE_CHANGE);
    } catch (AuthException denied) {
        throw new AuthException("move not permitted", denied);
    }
    try (BatchUpdate u = updateFactory.create(dbProvider.get(), project, caller, TimeUtil.nowTs())) {
        u.addOp(change.getId(), new Op(input));
        u.execute();
    }
    return json.noOptions().format(project, rsrc.getId());
}
#method_after
@Override
protected ChangeInfo applyImpl(BatchUpdate.Factory updateFactory, ChangeResource rsrc, MoveInput input) throws RestApiException, OrmException, UpdateException, PermissionBackendException {
    Change change = rsrc.getChange();
    Project.NameKey project = rsrc.getProject();
    IdentifiedUser caller = rsrc.getUser().asIdentifiedUser();
    input.destinationBranch = RefNames.fullName(input.destinationBranch);
    if (change.getStatus().isClosed()) {
        throw new ResourceConflictException("Change is " + ChangeUtil.status(change));
    }
    Branch.NameKey newDest = new Branch.NameKey(project, input.destinationBranch);
    if (change.getDest().equals(newDest)) {
        throw new ResourceConflictException("Change is already destined for the specified branch");
    }
    // Move requires abandoning this change, and creating a new change.
    try {
        rsrc.permissions().database(dbProvider).check(ABANDON);
        permissionBackend.user(caller).database(dbProvider).ref(newDest).check(CREATE_CHANGE);
    } catch (AuthException denied) {
        throw new AuthException("move not permitted", denied);
    }
    try (BatchUpdate u = updateFactory.create(dbProvider.get(), project, caller, TimeUtil.nowTs())) {
        u.addOp(change.getId(), new Op(input));
        u.execute();
    }
    return json.noOptions().format(project, rsrc.getId());
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException, RepositoryNotFoundException, IOException {
    change = ctx.getChange();
    if (change.getStatus() != Status.NEW && change.getStatus() != Status.DRAFT) {
        throw new ResourceConflictException("Change is " + ChangeUtil.status(change));
    }
    Project.NameKey projectKey = change.getProject();
    newDestKey = new Branch.NameKey(projectKey, input.destinationBranch);
    Branch.NameKey changePrevDest = change.getDest();
    if (changePrevDest.equals(newDestKey)) {
        throw new ResourceConflictException("Change is already destined for the specified branch");
    }
    final PatchSet.Id patchSetId = change.currentPatchSetId();
    try (Repository repo = repoManager.openRepository(projectKey);
        RevWalk revWalk = new RevWalk(repo)) {
        RevCommit currPatchsetRevCommit = revWalk.parseCommit(ObjectId.fromString(psUtil.current(ctx.getDb(), ctx.getNotes()).getRevision().get()));
        if (currPatchsetRevCommit.getParentCount() > 1) {
            throw new ResourceConflictException("Merge commit cannot be moved");
        }
        ObjectId refId = repo.resolve(input.destinationBranch);
        // Check if destination ref exists in project repo
        if (refId == null) {
            throw new ResourceConflictException("Destination " + input.destinationBranch + " not found in the project");
        }
        RevCommit refCommit = revWalk.parseCommit(refId);
        if (revWalk.isMergedInto(currPatchsetRevCommit, refCommit)) {
            throw new ResourceConflictException("Current patchset revision is reachable from tip of " + input.destinationBranch);
        }
    }
    Change.Key changeKey = change.getKey();
    if (!asChanges(queryProvider.get().byBranchKey(newDestKey, changeKey)).isEmpty()) {
        throw new ResourceConflictException("Destination " + newDestKey.getShortName() + " has a different change with same change key " + changeKey);
    }
    if (!change.currentPatchSetId().equals(patchSetId)) {
        throw new ResourceConflictException("Patch set is not current");
    }
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    update.setBranch(newDestKey.get());
    change.setDest(newDestKey);
    List<PatchSetApproval> approvals = new ArrayList<>();
    for (Map.Entry<PatchSet.Id, PatchSetApproval> entry : approvalsUtil.byChange(ctx.getDb(), ctx.getNotes()).entries()) {
        // remove votes from NoteDb.
        update.removeApprovalFor(entry.getValue().getAccountId(), entry.getValue().getLabel());
        approvals.add(new PatchSetApproval(new PatchSetApproval.Key(entry.getKey(), entry.getValue().getAccountId(), new LabelId(entry.getValue().getLabel())), (short) 0, ctx.getWhen()));
    }
    // Remove all votes from reviewDb.
    ctx.getDb().patchSetApprovals().upsert(approvals);
    StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change destination moved from ");
    msgBuf.append(changePrevDest.getShortName());
    msgBuf.append(" to ");
    msgBuf.append(newDestKey.getShortName());
    if (!Strings.isNullOrEmpty(input.message)) {
        msgBuf.append("\n\n");
        msgBuf.append(input.message);
    }
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, msgBuf.toString(), ChangeMessagesUtil.TAG_MOVE);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException, IOException {
    change = ctx.getChange();
    if (change.getStatus() != Status.NEW) {
        throw new ResourceConflictException("Change is " + ChangeUtil.status(change));
    }
    Project.NameKey projectKey = change.getProject();
    newDestKey = new Branch.NameKey(projectKey, input.destinationBranch);
    Branch.NameKey changePrevDest = change.getDest();
    if (changePrevDest.equals(newDestKey)) {
        throw new ResourceConflictException("Change is already destined for the specified branch");
    }
    final PatchSet.Id patchSetId = change.currentPatchSetId();
    try (Repository repo = repoManager.openRepository(projectKey);
        RevWalk revWalk = new RevWalk(repo)) {
        RevCommit currPatchsetRevCommit = revWalk.parseCommit(ObjectId.fromString(psUtil.current(ctx.getDb(), ctx.getNotes()).getRevision().get()));
        if (currPatchsetRevCommit.getParentCount() > 1) {
            throw new ResourceConflictException("Merge commit cannot be moved");
        }
        ObjectId refId = repo.resolve(input.destinationBranch);
        // Check if destination ref exists in project repo
        if (refId == null) {
            throw new ResourceConflictException("Destination " + input.destinationBranch + " not found in the project");
        }
        RevCommit refCommit = revWalk.parseCommit(refId);
        if (revWalk.isMergedInto(currPatchsetRevCommit, refCommit)) {
            throw new ResourceConflictException("Current patchset revision is reachable from tip of " + input.destinationBranch);
        }
    }
    Change.Key changeKey = change.getKey();
    if (!asChanges(queryProvider.get().byBranchKey(newDestKey, changeKey)).isEmpty()) {
        throw new ResourceConflictException("Destination " + newDestKey.getShortName() + " has a different change with same change key " + changeKey);
    }
    if (!change.currentPatchSetId().equals(patchSetId)) {
        throw new ResourceConflictException("Patch set is not current");
    }
    PatchSet.Id psId = change.currentPatchSetId();
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setBranch(newDestKey.get());
    change.setDest(newDestKey);
    updateApprovals(ctx, update, psId, projectKey);
    StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change destination moved from ");
    msgBuf.append(changePrevDest.getShortName());
    msgBuf.append(" to ");
    msgBuf.append(newDestKey.getShortName());
    if (!Strings.isNullOrEmpty(input.message)) {
        msgBuf.append("\n\n");
        msgBuf.append(input.message);
    }
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, msgBuf.toString(), ChangeMessagesUtil.TAG_MOVE);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
    return true;
}
#end_block

#method_before
@Override
public Optional<InternalGroup> load(AccountGroup.Id key) throws Exception {
    if (groupIndexProvider.get() != null) {
        return groupQueryProvider.get().byId(key);
    }
    try (ReviewDb db = schema.open()) {
        return groups.getGroup(db, key);
    }
}
#method_after
@Override
public Optional<InternalGroup> load(AccountGroup.Id key) throws Exception {
    if (hasGroupIndex) {
        return groupQueryProvider.get().byId(key);
    }
    try (ReviewDb db = schema.open()) {
        return groups.getGroup(db, key);
    }
}
#end_block

#method_before
@Override
public void onEvent(Event event) {
    if (!(event instanceof ProjectEvent)) {
        return;
    }
    ProjectEvent projectEvent = (ProjectEvent) event;
    Config cfg;
    try {
        cfg = configFactory.getProjectPluginConfigWithInheritance(projectEvent.getProjectNameKey(), pluginName);
    } catch (NoSuchProjectException e) {
        log.warn("Ignoring event for a non-existing project {}, {}", projectEvent.getProjectNameKey().get(), projectEvent);
        return;
    }
    for (String name : cfg.getSubsections(SECTION)) {
        String url = cfg.getString(SECTION, name, "url");
        if (Strings.isNullOrEmpty(url)) {
            log.warn("remote.{}.url not defined, skipping this remote", name);
            continue;
        }
        Optional<EventProcessor.Factory> factory = provider.getFactory(cfg, name);
        if (!factory.isPresent()) {
            log.warn("remote.{}.type not recognized, skipping this remote", name);
            continue;
        }
        EventProcessor processor = factory.get().create(projectEvent);
        if (processor.shouldPost(cfg.getStringList(SECTION, name, "event"))) {
            post(url, processor);
        }
    }
}
#method_after
@Override
public void onEvent(Event event) {
    if (!(event instanceof ProjectEvent)) {
        return;
    }
    ProjectEvent projectEvent = (ProjectEvent) event;
    Config cfg;
    try {
        cfg = configFactory.getProjectPluginConfigWithInheritance(projectEvent.getProjectNameKey(), pluginName);
    } catch (NoSuchProjectException e) {
        log.warn("Ignoring event for a non-existing project {}, {}", projectEvent.getProjectNameKey().get(), projectEvent);
        return;
    }
    for (String name : cfg.getSubsections(REMOTE)) {
        RemoteConfig remote = remoteFactory.create(cfg, name);
        if (Strings.isNullOrEmpty(remote.getUrl())) {
            log.warn("remote.{}.url not defined, skipping this remote", name);
            continue;
        }
        taskFactory.create(projectEvent, remote).schedule();
    }
}
#end_block

#method_before
@Before
public void setup() throws NoSuchProjectException {
    when(configFactory.getProjectPluginConfigWithInheritance(PROJECT_NAME, PLUGIN)).thenReturn(config);
    when(provider.getFactory(eq(config), eq(FOO))).thenReturn(Optional.of(factory));
    when(factory.create(any(ProjectEvent.class))).thenReturn(processor);
    when(taskFactory.create(anyString(), eq(processor))).thenReturn(postTask);
    eventHandler = new EventHandler(configFactory, PLUGIN, taskFactory, provider);
}
#method_after
@Before
public void setup() throws NoSuchProjectException {
    when(projectCreated.getProjectNameKey()).thenReturn(PROJECT_NAME);
    when(configFactory.getProjectPluginConfigWithInheritance(PROJECT_NAME, PLUGIN)).thenReturn(config);
    when(remoteFactory.create(eq(config), eq(FOO))).thenReturn(remote);
    when(taskFactory.create(eq(projectCreated), eq(remote))).thenReturn(postTask);
    eventHandler = new EventHandler(configFactory, PLUGIN, remoteFactory, taskFactory);
}
#end_block

#method_before
@Before
public void setup() {
    when(cfg.getRetryInterval()).thenReturn(RETRY_INTERVAL);
    when(cfg.getMaxTries()).thenReturn(MAX_TRIES);
    when(processor.process()).thenReturn(BODY);
    task = new PostTask(executor, session, cfg, WEBHOOK_URL, processor);
}
#method_after
@Before
public void setup() {
    when(cfg.getRetryInterval()).thenReturn(RETRY_INTERVAL);
    when(cfg.getMaxTries()).thenReturn(MAX_TRIES);
    when(remote.getUrl()).thenReturn(WEBHOOK_URL);
    when(processor.process(eq(projectCreated), eq(remote))).thenReturn(BODY);
    task = new PostTask(executor, session, cfg, processor, projectCreated, remote);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ScheduledExecutorService.class).annotatedWith(WebHooksExecutor.class).toProvider(ExecutorProvider.class);
    bind(Configuration.class).in(Scopes.SINGLETON);
    bind(CloseableHttpClient.class).toProvider(HttpClientProvider.class).in(Scopes.SINGLETON);
    factory(PostTask.Factory.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventHandler.class);
    DynamicSet.setOf(binder(), EventProcessor.Factory.class);
    DynamicSet.bind(binder(), EventProcessor.Factory.class).to(JenkinsEventProcessor.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ScheduledExecutorService.class).annotatedWith(WebHooksExecutor.class).toProvider(ExecutorProvider.class);
    bind(CloseableHttpClient.class).toProvider(HttpClientProvider.class).in(Scopes.SINGLETON);
    factory(PostTask.Factory.class);
    factory(RemoteConfig.Factory.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventHandler.class);
    install(processors);
}
#end_block

#method_before
@Inject()
void set(AccountIndexCollection accountIndexCollection) {
    this.accountIndexCollection = accountIndexCollection;
}
#method_after
@Inject
void set(AccountIndexCollection accountIndexCollection) {
    this.accountIndexCollection = accountIndexCollection;
}
#end_block

#method_before
@Inject()
void set(GroupIndexCollection groupIndexCollection) {
    this.groupIndexCollection = groupIndexCollection;
}
#method_after
@Inject
void set(GroupIndexCollection groupIndexCollection) {
    this.groupIndexCollection = groupIndexCollection;
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    Connection connection = ((JdbcSchema) db).getConnection();
    try (PreparedStatement uuidRetrieval = connection.prepareStatement("SELECT group_uuid FROM account_groups WHERE group_id = ?");
        PreparedStatement groupDeletion = connection.prepareStatement("DELETE account_groups WHERE group_id = ?");
        PreparedStatement groupNameDeletion = connection.prepareStatement("DELETE account_group_names WHERE group_id = ?")) {
        for (AccountGroup.Id id : scanSystemGroups(db)) {
            Optional<AccountGroup.UUID> groupUuid = getUuid(uuidRetrieval, id);
            if (groupUuid.filter(SystemGroupBackend::isSystemGroup).isPresent()) {
                groupDeletion.setInt(1, id.get());
                groupDeletion.executeUpdate();
                groupNameDeletion.setInt(1, id.get());
                groupNameDeletion.executeUpdate();
            }
        }
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    try (PreparedStatement uuidRetrieval = prepareStatement(db, "SELECT group_uuid FROM account_groups WHERE group_id = ?");
        PreparedStatement groupDeletion = prepareStatement(db, "DELETE FROM account_groups WHERE group_id = ?");
        PreparedStatement groupNameDeletion = prepareStatement(db, "DELETE FROM account_group_names WHERE group_id = ?")) {
        for (AccountGroup.Id id : scanSystemGroups(db)) {
            Optional<AccountGroup.UUID> groupUuid = getUuid(uuidRetrieval, id);
            if (groupUuid.filter(SystemGroupBackend::isSystemGroup).isPresent()) {
                groupDeletion.setInt(1, id.get());
                groupDeletion.executeUpdate();
                groupNameDeletion.setInt(1, id.get());
                groupNameDeletion.executeUpdate();
            }
        }
    }
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    Connection connection = ((JdbcSchema) db).getConnection();
    try (PreparedStatement groupUpdate = connection.prepareStatement("UPDATE account_groups SET created_on = ? WHERE group_id = ?");
        PreparedStatement addedOnRetrieval = connection.prepareStatement("SELECT added_on FROM account_group_members_audit WHERE group_id = ?" + " ORDER BY added_on ASC")) {
        List<AccountGroup.Id> accountGroups = getAllGroupIds(db);
        for (AccountGroup.Id groupId : accountGroups) {
            Optional<Timestamp> firstTimeMentioned = getFirstTimeMentioned(addedOnRetrieval, groupId);
            Timestamp createdOn = firstTimeMentioned.orElseGet(AccountGroup::auditCreationInstantTs);
            groupUpdate.setTimestamp(1, createdOn);
            groupUpdate.setInt(2, groupId.get());
            groupUpdate.executeUpdate();
        }
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    try (PreparedStatement groupUpdate = prepareStatement(db, "UPDATE account_groups SET created_on = ? WHERE group_id = ?");
        PreparedStatement addedOnRetrieval = prepareStatement(db, "SELECT added_on FROM account_group_members_audit WHERE group_id = ?" + " ORDER BY added_on ASC")) {
        List<AccountGroup.Id> accountGroups = getAllGroupIds(db);
        for (AccountGroup.Id groupId : accountGroups) {
            Optional<Timestamp> firstTimeMentioned = getFirstTimeMentioned(addedOnRetrieval, groupId);
            Timestamp createdOn = firstTimeMentioned.orElseGet(AccountGroup::auditCreationInstantTs);
            groupUpdate.setTimestamp(1, createdOn);
            groupUpdate.setInt(2, groupId.get());
            groupUpdate.executeUpdate();
        }
    }
}
#end_block

#method_before
private void updateSubmodules(Repository repo, String targetRef, URI targetURI, JiriProjects projects, GerritRemoteReader reader) throws IOException, GitAPIException {
    DirCache index = DirCache.newInCore();
    DirCacheBuilder builder = index.builder();
    ObjectInserter inserter = repo.newObjectInserter();
    try (RevWalk rw = new RevWalk(repo)) {
        Config cfg = new Config();
        projects.sortByPath();
        String parent = null;
        for (JiriProjects.Project proj : projects.getProjects()) {
            String path = proj.getPath();
            String nameUri = proj.getRemote();
            if (parent != null) {
                String p1 = StringUtil.stripAndAddCharsAtEnd(path, "/");
                String p2 = StringUtil.stripAndAddCharsAtEnd(parent, "/");
                if (p1.startsWith(p2)) {
                    warn("Skipping project %s(%s) as git doesn't support nested submodules", proj.getName(), path);
                    continue;
                }
            }
            ObjectId objectId;
            String ref = proj.getRef();
            if (ObjectId.isId(ref)) {
                objectId = ObjectId.fromString(ref);
            } else {
                objectId = reader.sha1(nameUri, ref);
                if (objectId == null) {
                    warn("failed to get ref '%s' for '%s', skipping", ref, nameUri);
                    continue;
                }
            }
            // can be branch or tag
            cfg.setString("submodule", path, "branch", ref);
            if (proj.getHistorydepth() > 0) {
                cfg.setBoolean("submodule", path, "shallow", true);
                if (proj.getHistorydepth() != 1) {
                    warn("Project %s(%s) has historydepth other than 1. Submodule only support shallow of depth 1.", proj.getName(), proj.getPath());
                }
            }
            URI submodUrl = URI.create(nameUri);
            // check if repo exists locally then relativize its URL
            try {
                String repoName = submodUrl.getPath();
                while (repoName.startsWith("/")) {
                    repoName = repoName.substring(1);
                }
                reader.openRepository(repoName);
                submodUrl = relativize(targetURI, URI.create(submodUrl.getPath()));
            } catch (RepositoryNotFoundException e) {
            }
            cfg.setString("submodule", path, "path", path);
            cfg.setString("submodule", path, "url", submodUrl.toString());
            // create gitlink
            DirCacheEntry dcEntry = new DirCacheEntry(path);
            dcEntry.setObjectId(objectId);
            dcEntry.setFileMode(FileMode.GITLINK);
            builder.add(dcEntry);
            parent = path;
        }
        String content = cfg.toText();
        // create a new DirCacheEntry for .gitmodules file.
        final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);
        ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));
        dcEntry.setObjectId(objectId);
        dcEntry.setFileMode(FileMode.REGULAR_FILE);
        builder.add(dcEntry);
        builder.finish();
        ObjectId treeId = index.writeTree(inserter);
        // Create a Commit object, populate it and write it
        ObjectId headId = repo.resolve(targetRef + "^{commit}");
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(treeId);
        if (headId != null)
            commit.setParentIds(headId);
        commit.setAuthor(serverIdent);
        commit.setCommitter(serverIdent);
        commit.setMessage(RepoText.get().repoCommitMessage);
        ObjectId commitId = inserter.insert(commit);
        inserter.flush();
        RefUpdate ru = repo.updateRef(targetRef);
        ru.setNewObjectId(commitId);
        ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());
        Result rc = ru.update(rw);
        switch(rc) {
            case NEW:
            case FORCED:
            case FAST_FORWARD:
                // Successful. Do nothing.
                break;
            case REJECTED:
            case LOCK_FAILURE:
                throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetRef), ru.getRef(), rc);
            default:
                throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetRef, commitId.name(), rc));
        }
    }
}
#method_after
private void updateSubmodules(Repository repo, String targetRef, URI targetURI, JiriProjects projects, GerritRemoteReader reader) throws IOException, GitAPIException {
    DirCache index = DirCache.newInCore();
    DirCacheBuilder builder = index.builder();
    ObjectInserter inserter = repo.newObjectInserter();
    try (RevWalk rw = new RevWalk(repo)) {
        Config cfg = new Config();
        projects.sortByPath();
        String parent = null;
        for (JiriProjects.Project proj : projects.getProjects()) {
            String path = proj.getPath();
            String nameUri = proj.getRemote();
            if (parent != null) {
                String p1 = StringUtil.stripAndAddCharsAtEnd(path, "/");
                String p2 = StringUtil.stripAndAddCharsAtEnd(parent, "/");
                if (p1.startsWith(p2)) {
                    warn("Skipping project %s(%s) as git doesn't support nested submodules", proj.getName(), path);
                    continue;
                }
            }
            ObjectId objectId;
            String ref = proj.getRef();
            if (ObjectId.isId(ref)) {
                objectId = ObjectId.fromString(ref);
            } else {
                objectId = reader.sha1(nameUri, ref);
                if (objectId == null) {
                    warn("failed to get ref '%s' for '%s', skipping", ref, nameUri);
                    continue;
                }
            }
            // can be branch or tag
            cfg.setString("submodule", path, "branch", ref);
            if (proj.getHistorydepth() > 0) {
                cfg.setBoolean("submodule", path, "shallow", true);
                if (proj.getHistorydepth() != 1) {
                    warn("Project %s(%s) has historydepth other than 1. Submodule only support shallow of depth 1.", proj.getName(), proj.getPath());
                }
            }
            URI submodUrl = URI.create(nameUri);
            // check if repo exists locally then relativize its URL
            try {
                String repoName = submodUrl.getPath();
                while (repoName.startsWith("/")) {
                    repoName = repoName.substring(1);
                }
                reader.openRepository(repoName);
                submodUrl = relativize(targetURI, URI.create(repoName));
            } catch (RepositoryNotFoundException e) {
            }
            cfg.setString("submodule", path, "path", path);
            cfg.setString("submodule", path, "url", submodUrl.toString());
            // create gitlink
            DirCacheEntry dcEntry = new DirCacheEntry(path);
            dcEntry.setObjectId(objectId);
            dcEntry.setFileMode(FileMode.GITLINK);
            builder.add(dcEntry);
            parent = path;
        }
        String content = cfg.toText();
        // create a new DirCacheEntry for .gitmodules file.
        final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);
        ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));
        dcEntry.setObjectId(objectId);
        dcEntry.setFileMode(FileMode.REGULAR_FILE);
        builder.add(dcEntry);
        builder.finish();
        ObjectId treeId = index.writeTree(inserter);
        // Create a Commit object, populate it and write it
        ObjectId headId = repo.resolve(targetRef + "^{commit}");
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(treeId);
        if (headId != null)
            commit.setParentIds(headId);
        commit.setAuthor(serverIdent);
        commit.setCommitter(serverIdent);
        commit.setMessage(RepoText.get().repoCommitMessage);
        ObjectId commitId = inserter.insert(commit);
        inserter.flush();
        RefUpdate ru = repo.updateRef(targetRef);
        ru.setNewObjectId(commitId);
        ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());
        Result rc = ru.update(rw);
        switch(rc) {
            case NEW:
            case FORCED:
            case FAST_FORWARD:
                // Successful. Do nothing.
                break;
            case REJECTED:
            case LOCK_FAILURE:
                throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetRef), ru.getRef(), rc);
            default:
                throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetRef, commitId.name(), rc));
        }
    }
}
#end_block

#method_before
static URI relativize(URI current, URI target) {
    // We only handle bare paths for now.
    if (!target.toString().equals(target.getPath())) {
        return target;
    }
    if (!current.toString().equals(current.getPath())) {
        return target;
    }
    String cur = current.normalize().getPath();
    String dest = target.normalize().getPath();
    while (cur.startsWith(SLASH)) {
        cur = cur.substring(1);
    }
    while (dest.startsWith(SLASH)) {
        dest = dest.substring(1);
    }
    if (cur.indexOf('/') == -1 || dest.indexOf('/') == -1) {
        // Avoid having to special-casing in the next two ifs.
        String prefix = "prefix/";
        cur = prefix + cur;
        dest = prefix + dest;
    }
    if (!cur.endsWith(SLASH)) {
        // The current file doesn't matter.
        int lastSlash = cur.lastIndexOf('/');
        cur = cur.substring(0, lastSlash);
    }
    String destFile = "";
    if (!dest.endsWith(SLASH)) {
        // We always have to provide the destination file.
        int lastSlash = dest.lastIndexOf('/');
        destFile = dest.substring(lastSlash + 1, dest.length());
        dest = dest.substring(0, dest.lastIndexOf('/'));
    }
    String[] cs = cur.split(SLASH);
    String[] ds = dest.split(SLASH);
    int common = 0;
    while (common < cs.length && common < ds.length && cs[common].equals(ds[common])) {
        common++;
    }
    StringJoiner j = new StringJoiner(SLASH);
    for (int i = common; i < cs.length; i++) {
        j.add("..");
    }
    for (int i = common; i < ds.length; i++) {
        j.add(ds[i]);
    }
    j.add(destFile);
    return URI.create(j.toString());
}
#method_after
static URI relativize(URI current, URI target) {
    // We only handle bare paths for now.
    if (!target.toString().equals(target.getPath())) {
        return target;
    }
    if (!current.toString().equals(current.getPath())) {
        return target;
    }
    String cur = current.normalize().getPath();
    String dest = target.normalize().getPath();
    if (cur.startsWith(SLASH) != dest.startsWith(SLASH)) {
        return target;
    }
    while (cur.startsWith(SLASH)) {
        cur = cur.substring(1);
    }
    while (dest.startsWith(SLASH)) {
        dest = dest.substring(1);
    }
    if (cur.indexOf('/') == -1 || dest.indexOf('/') == -1) {
        // Avoid having to special-casing in the next two ifs.
        String prefix = "prefix/";
        cur = prefix + cur;
        dest = prefix + dest;
    }
    if (!cur.endsWith(SLASH)) {
        // The current file doesn't matter.
        int lastSlash = cur.lastIndexOf('/');
        cur = cur.substring(0, lastSlash);
    }
    String destFile = "";
    if (!dest.endsWith(SLASH)) {
        // We always have to provide the destination file.
        int lastSlash = dest.lastIndexOf('/');
        destFile = dest.substring(lastSlash + 1, dest.length());
        dest = dest.substring(0, dest.lastIndexOf('/'));
    }
    String[] cs = cur.split(SLASH);
    String[] ds = dest.split(SLASH);
    int common = 0;
    while (common < cs.length && common < ds.length && cs[common].equals(ds[common])) {
        common++;
    }
    StringJoiner j = new StringJoiner(SLASH);
    for (int i = common; i < cs.length; i++) {
        j.add("..");
    }
    for (int i = common; i < ds.length; i++) {
        j.add(ds[i]);
    }
    j.add(destFile);
    return URI.create(j.toString());
}
#end_block

#method_before
@Test
public void relativeFetch() throws Exception {
    // Test the setup that Android uses, where the "fetch" field is relative to the location of the
    // manifest repo.
    setupTestRepos("platform/project");
    String realPrefix = testRepoKeys[0].get().split("/")[0];
    Project.NameKey manifestKey = createProject(realPrefix + "/manifest");
    TestRepository<InMemoryRepository> manifestRepo = cloneProject(manifestKey, admin);
    Project.NameKey superKey = createProject("superproject");
    pushConfig("[superproject \"" + superKey.get() + ":refs/heads/destbranch\"]\n" + "  srcRepo = " + manifestKey.get() + "\n" + "  srcRef = refs/heads/srcbranch\n" + "  srcPath = default\n" + "  toolType = jiri\n");
    String url = canonicalWebUrl.get();
    // XML change will trigger commit to superproject.
    String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<manifest>\n<projects>\n" + "<project name=\"" + testRepoKeys[0].get() + "\" remote=\"" + canonicalWebUrl.get() + testRepoKeys[0].get() + "\" path=\"project1\" />\n" + "<project name=\"external\"" + " remote=\"https://external/repo\"" + " revision=\"c438d02cdf08a08fe29550cb11cb6ae8190919f1\"" + " path=\"project2\" />\n" + "</projects>\n</manifest>\n";
    pushFactory.create(db, admin.getIdent(), manifestRepo, "Subject", "default", xml).to("refs/heads/srcbranch").assertOkStatus();
    BranchApi branch = gApi.projects().name(superKey.get()).branch("refs/heads/destbranch");
    assertThat(branch.file("project1").getContentType()).isEqualTo("x-git/gitlink; charset=UTF-8");
    assertThat(branch.file("project2").getContentType()).isEqualTo("x-git/gitlink; charset=UTF-8");
    Config base = new Config();
    BlobBasedConfig cfg = new BlobBasedConfig(base, branch.file(".gitmodules").asString().getBytes(UTF_8));
    String subUrl = cfg.getString("submodule", "project1", "url");
    // URL is valid.
    URI.create(subUrl);
    // The suburl must be interpreted as relative to the parent project as a directory, i.e.
    // to go from superproject/ to platform/project0, you have to do ../platform/project0
    // URL is clean.
    assertThat(subUrl).isEqualTo("../" + realPrefix + "/project0");
    subUrl = cfg.getString("submodule", "project2", "url");
    // URL is valid.
    URI.create(subUrl);
    // The suburl must be absolute as this is external repo
    assertThat(subUrl).isEqualTo("https://external/repo");
}
#method_after
@Test
public void relativeFetch() throws Exception {
    // Test that first party gerrit repos are represented by relative URLs in supermanifest and
    // external repos by their absolute URLs.
    setupTestRepos("platform/project");
    String realPrefix = testRepoKeys[0].get().split("/")[0];
    Project.NameKey manifestKey = createProject(realPrefix + "/manifest");
    TestRepository<InMemoryRepository> manifestRepo = cloneProject(manifestKey, admin);
    Project.NameKey superKey = createProject("superproject");
    pushConfig("[superproject \"" + superKey.get() + ":refs/heads/destbranch\"]\n" + "  srcRepo = " + manifestKey.get() + "\n" + "  srcRef = refs/heads/srcbranch\n" + "  srcPath = default\n" + "  toolType = jiri\n");
    // XML change will trigger commit to superproject.
    String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<manifest>\n<projects>\n" + "<project name=\"" + testRepoKeys[0].get() + "\" remote=\"" + canonicalWebUrl.get() + testRepoKeys[0].get() + "\" path=\"project1\" />\n" + "<project name=\"external\"" + " remote=\"https://external/repo\"" + " revision=\"c438d02cdf08a08fe29550cb11cb6ae8190919f1\"" + " path=\"project2\" />\n" + "</projects>\n</manifest>\n";
    pushFactory.create(db, admin.getIdent(), manifestRepo, "Subject", "default", xml).to("refs/heads/srcbranch").assertOkStatus();
    BranchApi branch = gApi.projects().name(superKey.get()).branch("refs/heads/destbranch");
    assertThat(branch.file("project1").getContentType()).isEqualTo("x-git/gitlink; charset=UTF-8");
    assertThat(branch.file("project2").getContentType()).isEqualTo("x-git/gitlink; charset=UTF-8");
    Config base = new Config();
    BlobBasedConfig cfg = new BlobBasedConfig(base, branch.file(".gitmodules").asString().getBytes(UTF_8));
    String subUrl = cfg.getString("submodule", "project1", "url");
    // URL is valid.
    URI.create(subUrl);
    // The suburl must be interpreted as relative to the parent project as a directory, i.e.
    // to go from superproject/ to platform/project0, you have to do ../platform/project0
    // URL is clean.
    assertThat(subUrl).isEqualTo("../" + realPrefix + "/project0");
    subUrl = cfg.getString("submodule", "project2", "url");
    // URL is valid.
    URI.create(subUrl);
    // The suburl must be absolute as this is external repo
    assertThat(subUrl).isEqualTo("https://external/repo");
}
#end_block

#method_before
@Test
public void listAllGroups() throws Exception {
    List<String> expectedGroups = groupCache.all().stream().map(a -> a.getName()).sorted().collect(toList());
    assertThat(expectedGroups.size()).isAtLeast(2);
    assertThat(gApi.groups().list().getAsMap().keySet()).containsExactlyElementsIn(expectedGroups).inOrder();
}
#method_after
@Test
public void listAllGroups() throws Exception {
    List<String> expectedGroups = groups.getAll(db).map(a -> a.getName()).sorted().collect(toList());
    assertThat(expectedGroups.size()).isAtLeast(2);
    assertThat(gApi.groups().list().getAsMap().keySet()).containsExactlyElementsIn(expectedGroups).inOrder();
}
#end_block

#method_before
@Test
public void getGroupsByOwner() throws Exception {
    String parent = createGroup("test-parent");
    List<String> children = Arrays.asList(createGroup("test-child1", parent), createGroup("test-child2", parent));
    for (String c : children) {
        assertThat(groupCache.get(new AccountGroup.NameKey(c)).isPresent()).isTrue();
        assertThat(gApi.groups().id(c).owner().name).isEqualTo(parent);
    }
    List<GroupInfo> owned = gApi.groups().list().withOwnedBy(getFromCache(parent).getGroupUUID()).get();
    assertThat(owned).hasSize(2);
    assertThat(owned.stream().map(g -> g.name).collect(toList())).containsExactlyElementsIn(children);
}
#method_after
@Test
public void getGroupsByOwner() throws Exception {
    String parent = createGroup("test-parent");
    List<String> children = Arrays.asList(createGroup("test-child1", parent), createGroup("test-child2", parent));
    // By UUID
    List<GroupInfo> owned = gApi.groups().list().withOwnedBy(getFromCache(parent).getGroupUUID().get()).get();
    assertThat(owned.stream().map(g -> g.name).collect(toList())).containsExactlyElementsIn(children);
    // By name
    owned = gApi.groups().list().withOwnedBy(parent).get();
    assertThat(owned.stream().map(g -> g.name).collect(toList())).containsExactlyElementsIn(children);
    // By group that does not own any others
    owned = gApi.groups().list().withOwnedBy(owned.get(0).id).get();
    assertThat(owned).isEmpty();
    // By non-existing group
    exception.expect(UnprocessableEntityException.class);
    exception.expectMessage("Group Not Found: does-not-exist");
    gApi.groups().list().withOwnedBy("does-not-exist").get();
}
#end_block

#method_before
private void assertBadRequest(Groups.ListRequest req) throws Exception {
    try {
        req.get();
        fail("Expected BadRequestException");
    } catch (BadRequestException e) {
    // Expected
    }
}
#method_after
private void assertBadRequest(ListRequest req) throws Exception {
    try {
        req.get();
        fail("Expected BadRequestException");
    } catch (BadRequestException e) {
    // Expected
    }
}
#end_block

#method_before
private SortedMap<String, GroupInfo> list(ListRequest req) throws RestApiException {
    TopLevelResource tlr = TopLevelResource.INSTANCE;
    ListGroups list = listGroups.get();
    list.setOptions(req.getOptions());
    for (String project : req.getProjects()) {
        try {
            list.addProject(projects.parse(tlr, IdString.fromDecoded(project)).getControl());
        } catch (Exception e) {
            throw asRestApiException("Error looking up project " + project, e);
        }
    }
    for (String group : req.getGroups()) {
        list.addGroup(groups.parse(group).getGroupUUID());
    }
    list.setVisibleToAll(req.getVisibleToAll());
    if (req.getOwnedBy() != null) {
        list.setOwnedBy(req.getOwnedBy());
    }
    if (req.getUser() != null) {
        try {
            list.setUser(accounts.parse(req.getUser()).getAccountId());
        } catch (Exception e) {
            throw asRestApiException("Error looking up user " + req.getUser(), e);
        }
    }
    list.setOwned(req.getOwned());
    list.setLimit(req.getLimit());
    list.setStart(req.getStart());
    list.setMatchSubstring(req.getSubstring());
    list.setMatchRegex(req.getRegex());
    list.setSuggest(req.getSuggest());
    try {
        return list.apply(tlr);
    } catch (Exception e) {
        throw asRestApiException("Cannot list groups", e);
    }
}
#method_after
private SortedMap<String, GroupInfo> list(ListRequest req) throws RestApiException {
    TopLevelResource tlr = TopLevelResource.INSTANCE;
    ListGroups list = listGroups.get();
    list.setOptions(req.getOptions());
    for (String project : req.getProjects()) {
        try {
            ProjectResource rsrc = projects.parse(tlr, IdString.fromDecoded(project));
            list.addProject(rsrc.getProjectState());
        } catch (Exception e) {
            throw asRestApiException("Error looking up project " + project, e);
        }
    }
    for (String group : req.getGroups()) {
        list.addGroup(groups.parse(group).getGroupUUID());
    }
    list.setVisibleToAll(req.getVisibleToAll());
    if (req.getOwnedBy() != null) {
        list.setOwnedBy(req.getOwnedBy());
    }
    if (req.getUser() != null) {
        try {
            list.setUser(accounts.parse(req.getUser()).getAccountId());
        } catch (Exception e) {
            throw asRestApiException("Error looking up user " + req.getUser(), e);
        }
    }
    list.setOwned(req.getOwned());
    list.setLimit(req.getLimit());
    list.setStart(req.getStart());
    list.setMatchSubstring(req.getSubstring());
    list.setMatchRegex(req.getRegex());
    list.setSuggest(req.getSuggest());
    try {
        return list.apply(tlr);
    } catch (Exception e) {
        throw asRestApiException("Cannot list groups", e);
    }
}
#end_block

#method_before
@Option(name = "--project", aliases = { "-p" }, usage = "projects for which the groups should be listed")
public void addProject(ProjectControl project) {
    projects.add(project);
}
#method_after
@Option(name = "--project", aliases = { "-p" }, usage = "projects for which the groups should be listed")
public void addProject(ProjectState project) {
    projects.add(project);
}
#end_block

#method_before
@Option(name = "--owned-by", usage = "list groups owned by the given group")
public void setOwnedBy(AccountGroup.UUID ownedBy) {
    this.ownedBy = ownedBy;
}
#method_after
@Option(name = "--owned-by", usage = "list groups owned by the given group uuid")
public void setOwnedBy(String ownedBy) {
    this.ownedBy = ownedBy;
}
#end_block

#method_before
public List<ProjectControl> getProjects() {
    return projects;
}
#method_after
public List<ProjectState> getProjects() {
    return projects;
}
#end_block

#method_before
@Override
public SortedMap<String, GroupInfo> apply(TopLevelResource resource) throws OrmException, BadRequestException {
    SortedMap<String, GroupInfo> output = new TreeMap<>();
    for (GroupInfo info : get()) {
        output.put(MoreObjects.firstNonNull(info.name, "Group " + Url.decode(info.id)), info);
        info.name = null;
    }
    return output;
}
#method_after
@Override
public SortedMap<String, GroupInfo> apply(TopLevelResource resource) throws OrmException, RestApiException {
    SortedMap<String, GroupInfo> output = new TreeMap<>();
    for (GroupInfo info : get()) {
        output.put(MoreObjects.firstNonNull(info.name, "Group " + Url.decode(info.id)), info);
        info.name = null;
    }
    return output;
}
#end_block

#method_before
public List<GroupInfo> get() throws OrmException, BadRequestException {
    if (!Strings.isNullOrEmpty(suggest)) {
        return suggestGroups();
    }
    if (!Strings.isNullOrEmpty(matchSubstring) && !Strings.isNullOrEmpty(matchRegex)) {
        throw new BadRequestException("Specify one of m/r");
    }
    if (ownedBy != null) {
        return getGroupsOwnedBy(ownedBy);
    }
    if (owned) {
        return getGroupsOwnedBy(user != null ? userFactory.create(user) : identifiedUser.get());
    }
    if (user != null) {
        return accountGetGroups.apply(new AccountResource(userFactory.create(user)));
    }
    return getAllGroups();
}
#method_after
public List<GroupInfo> get() throws OrmException, RestApiException {
    if (!Strings.isNullOrEmpty(suggest)) {
        return suggestGroups();
    }
    if (!Strings.isNullOrEmpty(matchSubstring) && !Strings.isNullOrEmpty(matchRegex)) {
        throw new BadRequestException("Specify one of m/r");
    }
    if (ownedBy != null) {
        return getGroupsOwnedBy(ownedBy);
    }
    if (owned) {
        return getGroupsOwnedBy(user != null ? userFactory.create(user) : identifiedUser.get());
    }
    if (user != null) {
        return accountGetGroups.apply(new AccountResource(userFactory.create(user)));
    }
    return getAllGroups();
}
#end_block

#method_before
private List<GroupInfo> getAllGroups() throws OrmException {
    List<GroupInfo> groupInfos;
    List<GroupDescription.Internal> groupList;
    if (!projects.isEmpty()) {
        Map<AccountGroup.UUID, GroupDescription.Internal> groups = new HashMap<>();
        for (ProjectControl projectControl : projects) {
            final Set<GroupReference> groupsRefs = projectControl.getAllGroups();
            for (GroupReference groupRef : groupsRefs) {
                Optional<InternalGroup> internalGroup = groupCache.get(groupRef.getUUID());
                internalGroup.ifPresent(group -> groups.put(group.getGroupUUID(), new InternalGroupDescription(group)));
            }
        }
        groupList = filterGroups(groups.values());
    } else {
        groupList = filterGroups(getAllExistingInternalGroups());
    }
    groupInfos = Lists.newArrayListWithCapacity(groupList.size());
    int found = 0;
    int foundIndex = 0;
    for (GroupDescription.Internal group : groupList) {
        if (foundIndex++ < start) {
            continue;
        }
        if (limit > 0 && ++found > limit) {
            break;
        }
        groupInfos.add(json.addOptions(options).format(group));
    }
    return groupInfos;
}
#method_after
private List<GroupInfo> getAllGroups() throws OrmException {
    Pattern pattern = getRegexPattern();
    Stream<GroupDescription.Internal> existingGroups = getAllExistingGroups().filter(group -> !isNotRelevant(pattern, group)).sorted(GROUP_COMPARATOR).skip(start);
    if (limit > 0) {
        existingGroups = existingGroups.limit(limit);
    }
    List<GroupDescription.Internal> relevantGroups = existingGroups.collect(toImmutableList());
    List<GroupInfo> groupInfos = Lists.newArrayListWithCapacity(relevantGroups.size());
    for (GroupDescription.Internal group : relevantGroups) {
        groupInfos.add(json.addOptions(options).format(group));
    }
    return groupInfos;
}
#end_block

#method_before
private List<GroupInfo> suggestGroups() throws OrmException, BadRequestException {
    if (conflictingSuggestParameters()) {
        throw new BadRequestException("You should only have no more than one --project and -n with --suggest");
    }
    List<GroupReference> groupRefs = Lists.newArrayList(Iterables.limit(groupBackend.suggest(suggest, projects.stream().findFirst().map(pc -> pc.getProjectState()).orElse(null)), limit <= 0 ? 10 : Math.min(limit, 10)));
    List<GroupInfo> groupInfos = Lists.newArrayListWithCapacity(groupRefs.size());
    for (GroupReference ref : groupRefs) {
        GroupDescription.Basic desc = groupBackend.get(ref.getUUID());
        if (desc != null) {
            groupInfos.add(json.addOptions(options).format(desc));
        }
    }
    return groupInfos;
}
#method_after
private List<GroupInfo> suggestGroups() throws OrmException, BadRequestException {
    if (conflictingSuggestParameters()) {
        throw new BadRequestException("You should only have no more than one --project and -n with --suggest");
    }
    List<GroupReference> groupRefs = Lists.newArrayList(Iterables.limit(groupBackend.suggest(suggest, projects.stream().findFirst().orElse(null)), limit <= 0 ? 10 : Math.min(limit, 10)));
    List<GroupInfo> groupInfos = Lists.newArrayListWithCapacity(groupRefs.size());
    for (GroupReference ref : groupRefs) {
        GroupDescription.Basic desc = groupBackend.get(ref.getUUID());
        if (desc != null) {
            groupInfos.add(json.addOptions(options).format(desc));
        }
    }
    return groupInfos;
}
#end_block

#method_before
private boolean conflictingSuggestParameters() {
    if (Strings.isNullOrEmpty(suggest)) {
        return false;
    }
    if (projects.size() > 1) {
        return true;
    }
    if (visibleToAll) {
        return true;
    }
    if (user != null) {
        return true;
    }
    if (owned) {
        return true;
    }
    if (start != 0) {
        return true;
    }
    if (!groupsToInspect.isEmpty()) {
        return true;
    }
    if (!Strings.isNullOrEmpty(matchSubstring)) {
        return true;
    }
    if (!Strings.isNullOrEmpty(matchRegex)) {
        return true;
    }
    return false;
}
#method_after
private boolean conflictingSuggestParameters() {
    if (Strings.isNullOrEmpty(suggest)) {
        return false;
    }
    if (projects.size() > 1) {
        return true;
    }
    if (visibleToAll) {
        return true;
    }
    if (user != null) {
        return true;
    }
    if (owned) {
        return true;
    }
    if (ownedBy != null) {
        return true;
    }
    if (start != 0) {
        return true;
    }
    if (!groupsToInspect.isEmpty()) {
        return true;
    }
    if (!Strings.isNullOrEmpty(matchSubstring)) {
        return true;
    }
    if (!Strings.isNullOrEmpty(matchRegex)) {
        return true;
    }
    return false;
}
#end_block

#method_before
private List<GroupInfo> getGroupsOwnedBy(IdentifiedUser user) throws OrmException {
    List<GroupInfo> groups = new ArrayList<>();
    int found = 0;
    int foundIndex = 0;
    for (GroupDescription.Internal g : filterGroups(getAllExistingInternalGroups())) {
        GroupControl ctl = groupControlFactory.controlFor(g);
        try {
            if (genericGroupControlFactory.controlFor(user, g.getGroupUUID()).isOwner()) {
                if (foundIndex++ < start) {
                    continue;
                }
                if (limit > 0 && ++found > limit) {
                    break;
                }
                groups.add(json.addOptions(options).format(ctl.getGroup()));
            }
        } catch (NoSuchGroupException e) {
            continue;
        }
    }
    return groups;
}
#method_after
private List<GroupInfo> getGroupsOwnedBy(String id) throws OrmException, RestApiException {
    String uuid = groupsCollection.parse(id).getGroupUUID().get();
    return filterGroupsOwnedBy(group -> group.getOwnerGroupUUID().get().equals(uuid));
}
#end_block

#method_before
private List<GroupInfo> getGroupsOwnedBy(IdentifiedUser user) throws OrmException {
    List<GroupInfo> groups = new ArrayList<>();
    int found = 0;
    int foundIndex = 0;
    for (GroupDescription.Internal g : filterGroups(getAllExistingInternalGroups())) {
        GroupControl ctl = groupControlFactory.controlFor(g);
        try {
            if (genericGroupControlFactory.controlFor(user, g.getGroupUUID()).isOwner()) {
                if (foundIndex++ < start) {
                    continue;
                }
                if (limit > 0 && ++found > limit) {
                    break;
                }
                groups.add(json.addOptions(options).format(ctl.getGroup()));
            }
        } catch (NoSuchGroupException e) {
            continue;
        }
    }
    return groups;
}
#method_after
private List<GroupInfo> getGroupsOwnedBy(IdentifiedUser user) throws OrmException {
    return filterGroupsOwnedBy(group -> isOwner(user, group));
}
#end_block

#method_before
public ListRequest withOwnedBy(AccountGroup.UUID ownedBy) {
    this.ownedBy = ownedBy;
    return this;
}
#method_after
public ListRequest withOwnedBy(String ownedBy) {
    this.ownedBy = ownedBy;
    return this;
}
#end_block

#method_before
public AccountGroup.UUID getOwnedBy() {
    return ownedBy;
}
#method_after
public String getOwnedBy() {
    return ownedBy;
}
#end_block

#method_before
@Test
public void outgoingMailHasListHeaders() throws Exception {
    String changeId = createChangeWithReview(user);
    // Check that the mail has the expected headers
    assertThat(sender.getMessages()).hasSize(1);
    Map<String, EmailHeader> headers = sender.getMessages().iterator().next().headers();
    String hostname = URI.create(canonicalWebUrl.get()).getHost();
    String listId = "<gerrit-" + project.get() + "." + hostname + ">";
    String unsubscribeLink = "<" + canonicalWebUrl.get() + "settings>";
    String threadId = "<gerrit." + gApi.changes().id(changeId).get().created.getTime() + "." + changeId + "@" + hostname + ">";
    assertThat(headerString(headers, "List-Id")).isEqualTo(listId);
    assertThat(headerString(headers, "List-Unsubscribe")).isEqualTo(unsubscribeLink);
    assertThat(headerString(headers, "In-Reply-To")).isEqualTo(threadId);
}
#method_after
@Test
public void outgoingMailHasListHeaders() throws Exception {
    String changeId = createChangeWithReview(user);
    // Check that the mail has the expected headers
    assertThat(sender.getMessages()).hasSize(1);
    Map<String, EmailHeader> headers = sender.getMessages().iterator().next().headers();
    String hostname = URI.create(canonicalWebUrl.get()).getHost();
    String listId = String.format("<gerrit-%s.%s>", project.get(), hostname);
    String unsubscribeLink = String.format("<%ssettings>", canonicalWebUrl.get());
    String threadId = String.format("<gerrit.%s.%s@%s>", gApi.changes().id(changeId).get().created.getTime(), changeId, hostname);
    assertThat(headerString(headers, "List-Id")).isEqualTo(listId);
    assertThat(headerString(headers, "List-Unsubscribe")).isEqualTo(unsubscribeLink);
    assertThat(headerString(headers, "In-Reply-To")).isEqualTo(threadId);
}
#end_block

#method_before
static void createAllIndexes(ElasticNodeInfo nodeInfo) {
    Schema<ChangeData> changeSchema = ChangeSchemaDefinitions.INSTANCE.getLatest();
    ChangeMapping openChangesMapping = new ChangeMapping(changeSchema);
    ChangeMapping closedChangesMapping = new ChangeMapping(changeSchema);
    openChangesMapping.closedChanges = null;
    closedChangesMapping.openChanges = null;
    nodeInfo.node.client().admin().indices().prepareCreate(String.format("%s%04d", CHANGES_PREFIX, changeSchema.getVersion())).addMapping(OPEN_CHANGES, gson.toJson(openChangesMapping)).addMapping(CLOSED_CHANGES, gson.toJson(closedChangesMapping)).execute().actionGet();
    Schema<AccountState> accountSchema = AccountSchemaDefinitions.INSTANCE.getLatest();
    AccountMapping accountMapping = new AccountMapping(accountSchema);
    nodeInfo.node.client().admin().indices().prepareCreate(String.format("%s%04d", ACCOUNTS_PREFIX, accountSchema.getVersion())).addMapping(ElasticAccountIndex.ACCOUNTS, gson.toJson(accountMapping)).execute().actionGet();
    Schema<AccountGroup> groupSchema = GroupSchemaDefinitions.INSTANCE.getLatest();
    GroupMapping groupMapping = new GroupMapping(groupSchema);
    nodeInfo.node.client().admin().indices().prepareCreate(String.format("%s%04d", GROUPS_PREFIX, groupSchema.getVersion())).addMapping(ElasticGroupIndex.GROUPS, gson.toJson(groupMapping)).execute().actionGet();
    Schema<ProjectData> projectSchema = ProjectSchemaDefinitions.INSTANCE.getLatest();
    ProjectMapping projectMapping = new ProjectMapping(projectSchema);
    nodeInfo.node.client().admin().indices().prepareCreate(String.format("%s%04d", PROJECTS_PREFIX, projectSchema.getVersion())).addMapping(ElasticProjectIndex.PROJECTS, gson.toJson(projectMapping)).execute().actionGet();
}
#method_after
static void createAllIndexes(ElasticNodeInfo nodeInfo) {
    Schema<ChangeData> changeSchema = ChangeSchemaDefinitions.INSTANCE.getLatest();
    ChangeMapping openChangesMapping = new ChangeMapping(changeSchema);
    ChangeMapping closedChangesMapping = new ChangeMapping(changeSchema);
    openChangesMapping.closedChanges = null;
    closedChangesMapping.openChanges = null;
    nodeInfo.node.client().admin().indices().prepareCreate(String.format("%s%04d", CHANGES_PREFIX, changeSchema.getVersion())).addMapping(OPEN_CHANGES, gson.toJson(openChangesMapping)).addMapping(CLOSED_CHANGES, gson.toJson(closedChangesMapping)).execute().actionGet();
    Schema<AccountState> accountSchema = AccountSchemaDefinitions.INSTANCE.getLatest();
    AccountMapping accountMapping = new AccountMapping(accountSchema);
    nodeInfo.node.client().admin().indices().prepareCreate(String.format("%s%04d", ACCOUNTS_PREFIX, accountSchema.getVersion())).addMapping(ElasticAccountIndex.ACCOUNTS, gson.toJson(accountMapping)).execute().actionGet();
    Schema<InternalGroup> groupSchema = GroupSchemaDefinitions.INSTANCE.getLatest();
    GroupMapping groupMapping = new GroupMapping(groupSchema);
    nodeInfo.node.client().admin().indices().prepareCreate(String.format("%s%04d", GROUPS_PREFIX, groupSchema.getVersion())).addMapping(ElasticGroupIndex.GROUPS, gson.toJson(groupMapping)).execute().actionGet();
    Schema<ProjectData> projectSchema = ProjectSchemaDefinitions.INSTANCE.getLatest();
    ProjectMapping projectMapping = new ProjectMapping(projectSchema);
    nodeInfo.node.client().admin().indices().prepareCreate(String.format("%s%04d", PROJECTS_PREFIX, projectSchema.getVersion())).addMapping(ElasticProjectIndex.PROJECTS, gson.toJson(projectMapping)).execute().actionGet();
}
#end_block

#method_before
@Override
public void replace(ProjectData projectState) throws IOException {
    try {
        // No parts of FillArgs are currently required, just use null.
        replace(idTerm(projectState), toDocument(projectState, null)).get();
    } catch (ExecutionException | InterruptedException e) {
        throw new IOException(e);
    }
}
#method_after
@Override
public void replace(ProjectData projectState) throws IOException {
    try {
        replace(idTerm(projectState), toDocument(projectState)).get();
    } catch (ExecutionException | InterruptedException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
@Override
public GroupIndex create(Schema<AccountGroup> schema) {
    throw new UnsupportedOperationException();
}
#method_after
@Override
public GroupIndex create(Schema<InternalGroup> schema) {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public List<ProjectInfo> apply(TopLevelResource resource) throws BadRequestException, MethodNotAllowedException, OrmException {
    if (Strings.isNullOrEmpty(query)) {
        throw new BadRequestException("missing query field");
    }
    ProjectIndex searchIndex = indexes.getSearchIndex();
    if (searchIndex == null) {
        throw new MethodNotAllowedException("no project index");
    }
    if (start != 0) {
        queryProcessor.setStart(start);
    }
    if (limit != 0) {
        queryProcessor.setLimit(limit);
    }
    try {
        QueryResult<ProjectData> result = queryProcessor.query(queryBuilder.parse(query));
        List<ProjectData> pds = result.entities();
        ArrayList<ProjectInfo> projectInfos = Lists.newArrayListWithCapacity(pds.size());
        for (ProjectData pd : pds) {
            projectInfos.add(json.format(pd.getProject()));
        }
        return projectInfos;
    } catch (QueryParseException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#method_after
@Override
public List<ProjectInfo> apply(TopLevelResource resource) throws BadRequestException, MethodNotAllowedException, OrmException {
    if (Strings.isNullOrEmpty(query)) {
        throw new BadRequestException("missing query field");
    }
    ProjectIndex searchIndex = indexes.getSearchIndex();
    if (searchIndex == null) {
        throw new MethodNotAllowedException("no project index");
    }
    if (start != 0) {
        queryProcessor.setStart(start);
    }
    if (limit != 0) {
        queryProcessor.setUserProvidedLimit(limit);
    }
    try {
        QueryResult<ProjectData> result = queryProcessor.query(queryBuilder.parse(query));
        List<ProjectData> pds = result.entities();
        ArrayList<ProjectInfo> projectInfos = Lists.newArrayListWithCapacity(pds.size());
        for (ProjectData pd : pds) {
            projectInfos.add(json.format(pd.getProject()));
        }
        return projectInfos;
    } catch (QueryParseException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
private boolean isRevisionOutOfDate() {
    try (Repository git = gitMgr.openRepository(getProject().getNameKey())) {
        Ref ref = git.getRefDatabase().exactRef(RefNames.REFS_CONFIG);
        if (ref == null || ref.getObjectId() == null) {
            return true;
        }
        return !ref.getObjectId().equals(config.getRevision());
    } catch (IOException gone) {
        return true;
    }
}
#method_after
private boolean isRevisionOutOfDate() {
    try (Repository git = gitMgr.openRepository(getNameKey())) {
        Ref ref = git.getRefDatabase().exactRef(RefNames.REFS_CONFIG);
        if (ref == null || ref.getObjectId() == null) {
            return true;
        }
        return !ref.getObjectId().equals(config.getRevision());
    } catch (IOException gone) {
        return true;
    }
}
#end_block

#method_before
public PrologEnvironment newPrologEnvironment() throws CompileException {
    PrologMachineCopy pmc = rulesMachine;
    if (pmc == null) {
        pmc = rulesCache.loadMachine(getProject().getNameKey(), config.getRulesId());
        rulesMachine = pmc;
    }
    return envFactory.create(pmc);
}
#method_after
public PrologEnvironment newPrologEnvironment() throws CompileException {
    PrologMachineCopy pmc = rulesMachine;
    if (pmc == null) {
        pmc = rulesCache.loadMachine(getNameKey(), config.getRulesId());
        rulesMachine = pmc;
    }
    return envFactory.create(pmc);
}
#end_block

#method_before
public ProjectLevelConfig getConfig(String fileName) {
    if (configs.containsKey(fileName)) {
        return configs.get(fileName);
    }
    ProjectLevelConfig cfg = new ProjectLevelConfig(fileName, this);
    try (Repository git = gitMgr.openRepository(getProject().getNameKey())) {
        cfg.load(git);
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Failed to load " + fileName + " for " + getProject().getName(), e);
    }
    configs.put(fileName, cfg);
    return cfg;
}
#method_after
public ProjectLevelConfig getConfig(String fileName) {
    if (configs.containsKey(fileName)) {
        return configs.get(fileName);
    }
    ProjectLevelConfig cfg = new ProjectLevelConfig(fileName, this);
    try (Repository git = gitMgr.openRepository(getNameKey())) {
        cfg.load(git);
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Failed to load " + fileName + " for " + getName(), e);
    }
    configs.put(fileName, cfg);
    return cfg;
}
#end_block

#method_before
List<SectionMatcher> getLocalAccessSections() {
    List<SectionMatcher> sm = localAccessSections;
    if (sm == null) {
        Collection<AccessSection> fromConfig = config.getAccessSections();
        sm = new ArrayList<>(fromConfig.size());
        for (AccessSection section : fromConfig) {
            if (isAllProjects) {
                List<Permission> copy = Lists.newArrayListWithCapacity(section.getPermissions().size());
                for (Permission p : section.getPermissions()) {
                    if (Permission.canBeOnAllProjects(section.getName(), p.getName())) {
                        copy.add(p);
                    }
                }
                section = new AccessSection(section.getName());
                section.setPermissions(copy);
            }
            SectionMatcher matcher = SectionMatcher.wrap(getProject().getNameKey(), section);
            if (matcher != null) {
                sm.add(matcher);
            }
        }
        localAccessSections = sm;
    }
    return sm;
}
#method_after
List<SectionMatcher> getLocalAccessSections() {
    List<SectionMatcher> sm = localAccessSections;
    if (sm == null) {
        Collection<AccessSection> fromConfig = config.getAccessSections();
        sm = new ArrayList<>(fromConfig.size());
        for (AccessSection section : fromConfig) {
            if (isAllProjects) {
                List<Permission> copy = Lists.newArrayListWithCapacity(section.getPermissions().size());
                for (Permission p : section.getPermissions()) {
                    if (Permission.canBeOnAllProjects(section.getName(), p.getName())) {
                        copy.add(p);
                    }
                }
                section = new AccessSection(section.getName());
                section.setPermissions(copy);
            }
            SectionMatcher matcher = SectionMatcher.wrap(getNameKey(), section);
            if (matcher != null) {
                sm.add(matcher);
            }
        }
        localAccessSections = sm;
    }
    return sm;
}
#end_block

#method_before
public LabelTypes getLabelTypes() {
    Map<String, LabelType> types = new LinkedHashMap<>();
    for (ProjectState s : treeInOrder()) {
        for (LabelType type : s.getConfig().getLabelSections().values()) {
            String lower = type.getName().toLowerCase();
            LabelType old = types.get(lower);
            if (old == null || old.canOverride()) {
                types.put(lower, type);
            }
        }
    }
    List<LabelType> all = Lists.newArrayListWithCapacity(types.size());
    for (LabelType type : types.values()) {
        if (!type.getValues().isEmpty()) {
            all.add(type);
        }
    }
    return new LabelTypes(Collections.unmodifiableList(all));
}
#method_after
public LabelTypes getLabelTypes() {
    if (labelTypes == null) {
        labelTypes = loadLabelTypes();
    }
    return labelTypes;
}
#end_block

#method_before
public LabelTypes getLabelTypes() {
    Map<String, LabelType> types = new LinkedHashMap<>();
    for (ProjectState s : treeInOrder()) {
        for (LabelType type : s.getConfig().getLabelSections().values()) {
            String lower = type.getName().toLowerCase();
            LabelType old = types.get(lower);
            if (old == null || old.canOverride()) {
                types.put(lower, type);
            }
        }
    }
    List<LabelType> all = Lists.newArrayListWithCapacity(types.size());
    for (LabelType type : types.values()) {
        if (!type.getValues().isEmpty()) {
            all.add(type);
        }
    }
    return new LabelTypes(Collections.unmodifiableList(all));
}
#method_after
public LabelTypes getLabelTypes(ChangeNotes notes, CurrentUser user) {
    return getLabelTypes(notes.getChange().getDest(), user);
}
#end_block

#method_before
FilteredRepository create(Project.NameKey name) throws NoSuchProjectException, IOException {
    ProjectControl ctl = projectControlFactory.controlFor(name, userProvider.get());
    if (ctl.getProject().getState().equals(HIDDEN)) {
        throw new NoSuchProjectException(name);
    }
    return new FilteredRepository(ctl, repoManager.openRepository(name), visibleRefFilterFactory, userProvider, permissionBackend, projectState);
}
#method_after
FilteredRepository create(Project.NameKey name) throws NoSuchProjectException, IOException, PermissionBackendException {
    ProjectControl ctl = projectControlFactory.controlFor(name, userProvider.get());
    if (ctl.getProject().getState().equals(ProjectState.HIDDEN)) {
        throw new NoSuchProjectException(name);
    }
    return new FilteredRepository(ctl, repoManager.openRepository(name), visibleRefFilterFactory, permissionBackend);
}
#end_block

#method_before
private boolean can(ProjectPermission perm) throws PermissionBackendException {
    switch(perm) {
        case ACCESS:
            return (!isHidden() && (user.isInternalUser() || canPerformOnAnyRef(Permission.READ))) || isOwner();
        case READ:
            return !isHidden() && allRefsAreVisible(Collections.emptySet());
        case READ_NO_CONFIG:
            return !isHidden() && allRefsAreVisible(ImmutableSet.of(RefNames.REFS_CONFIG));
        case CREATE_REF:
            return canAddRefs();
        case CREATE_CHANGE:
            return canCreateChanges();
        case RUN_RECEIVE_PACK:
            return canRunReceivePack();
        case RUN_UPLOAD_PACK:
            return canRunUploadPack();
        case BAN_COMMIT:
        case READ_REF_LOG:
        case SET_DEFAULT_DASHBOARD:
        case READ_ACCESS:
        case WRITE_ACCESS:
            return isOwner();
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#method_after
private boolean can(ProjectPermission perm) throws PermissionBackendException {
    switch(perm) {
        case ACCESS:
            return (!isHidden() && (user.isInternalUser() || canPerformOnAnyRef(Permission.READ))) || isOwner();
        case READ:
            return !isHidden() && allRefsAreVisible(Collections.emptySet());
        case READ_NO_CONFIG:
            return !isHidden() && allRefsAreVisible(ImmutableSet.of(RefNames.REFS_CONFIG));
        case CREATE_REF:
            return canAddRefs();
        case CREATE_CHANGE:
            return canCreateChanges();
        case RUN_RECEIVE_PACK:
            return canRunReceivePack();
        case RUN_UPLOAD_PACK:
            return canRunUploadPack();
        case BAN_COMMIT:
        case READ_REFLOG:
        case READ_CONFIG:
        case WRITE_CONFIG:
            return isOwner();
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#end_block

#method_before
@Test
public void nonOwnerCannotSetConfig() throws Exception {
    ConfigInput input = createTestConfigInput();
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("write access not permitted");
    gApi.projects().name(project.get()).config(input);
}
#method_after
@Test
public void nonOwnerCannotSetConfig() throws Exception {
    ConfigInput input = createTestConfigInput();
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("write config not permitted");
    gApi.projects().name(project.get()).config(input);
}
#end_block

#method_before
@Override
public final T call() throws NoSuchProjectException, IOException, ConfigInvalidException, InvalidNameException, NoSuchGroupException, OrmException, UpdateParentFailedException, PermissionDeniedException, PermissionBackendException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    this.user = projectControl.getUser();
    try {
        contributorAgreements.check(projectName, projectControl.getUser());
    } catch (AuthException e) {
        throw new PermissionDeniedException(e.getMessage());
    }
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        ProjectConfig config = ProjectConfig.read(md, base);
        Set<String> toDelete = scanSectionNames(config);
        for (AccessSection section : mergeSections(sectionList)) {
            String name = section.getName();
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (checkIfOwner && !canWriteConfig()) {
                    continue;
                }
                replace(config, toDelete, section);
            } else if (AccessSection.isValid(name)) {
                if (checkIfOwner && !projectControl.controlForRef(name).isOwner()) {
                    continue;
                }
                RefPattern.validate(name);
                replace(config, toDelete, section);
            }
        }
        for (String name : toDelete) {
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (!checkIfOwner || canWriteConfig()) {
                    config.remove(config.getAccessSection(name));
                }
            } else if (!checkIfOwner || projectControl.controlForRef(name).isOwner()) {
                config.remove(config.getAccessSection(name));
            }
        }
        boolean parentProjectUpdate = false;
        if (!config.getProject().getNameKey().equals(allProjects) && !config.getProject().getParent(allProjects).equals(parentProjectName)) {
            parentProjectUpdate = true;
            try {
                setParent.get().validateParentUpdate(projectControl.getProject().getNameKey(), projectControl.getUser().asIdentifiedUser(), MoreObjects.firstNonNull(parentProjectName, allProjects).get(), checkIfOwner);
            } catch (AuthException e) {
                throw new UpdateParentFailedException("You are not allowed to change the parent project since you are " + "not an administrator. You may save the modifications for review " + "so that an administrator can approve them.", e);
            } catch (ResourceConflictException | UnprocessableEntityException e) {
                throw new UpdateParentFailedException(e.getMessage(), e);
            }
            config.getProject().setParentName(parentProjectName);
        }
        if (message != null && !message.isEmpty()) {
            if (!message.endsWith("\n")) {
                message += "\n";
            }
            md.setMessage(message);
        } else {
            md.setMessage("Modify access rules\n");
        }
        return updateProjectConfig(projectControl, config, md, parentProjectUpdate);
    } catch (RepositoryNotFoundException notFound) {
        throw new NoSuchProjectException(projectName);
    }
}
#method_after
@Override
public final T call() throws NoSuchProjectException, IOException, ConfigInvalidException, InvalidNameException, NoSuchGroupException, OrmException, UpdateParentFailedException, PermissionDeniedException, PermissionBackendException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    this.user = projectControl.getUser();
    try {
        contributorAgreements.check(projectName, projectControl.getUser());
    } catch (AuthException e) {
        throw new PermissionDeniedException(e.getMessage());
    }
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        ProjectConfig config = ProjectConfig.read(md, base);
        Set<String> toDelete = scanSectionNames(config);
        PermissionBackend.ForProject forProject = permissionBackend.user(user).project(projectName);
        for (AccessSection section : mergeSections(sectionList)) {
            String name = section.getName();
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (checkIfOwner && !canWriteConfig()) {
                    continue;
                }
                replace(config, toDelete, section);
            } else if (AccessSection.isValid(name)) {
                if (checkIfOwner && !forProject.ref(name).test(RefPermission.WRITE_CONFIG)) {
                    continue;
                }
                RefPattern.validate(name);
                replace(config, toDelete, section);
            }
        }
        for (String name : toDelete) {
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (!checkIfOwner || canWriteConfig()) {
                    config.remove(config.getAccessSection(name));
                }
            } else if (!checkIfOwner || forProject.ref(name).test(RefPermission.WRITE_CONFIG)) {
                config.remove(config.getAccessSection(name));
            }
        }
        boolean parentProjectUpdate = false;
        if (!config.getProject().getNameKey().equals(allProjects) && !config.getProject().getParent(allProjects).equals(parentProjectName)) {
            parentProjectUpdate = true;
            try {
                setParent.get().validateParentUpdate(projectControl.getProject().getNameKey(), projectControl.getUser().asIdentifiedUser(), MoreObjects.firstNonNull(parentProjectName, allProjects).get(), checkIfOwner);
            } catch (AuthException e) {
                throw new UpdateParentFailedException("You are not allowed to change the parent project since you are " + "not an administrator. You may save the modifications for review " + "so that an administrator can approve them.", e);
            } catch (ResourceConflictException | UnprocessableEntityException e) {
                throw new UpdateParentFailedException(e.getMessage(), e);
            }
            config.getProject().setParentName(parentProjectName);
        }
        if (message != null && !message.isEmpty()) {
            if (!message.endsWith("\n")) {
                message += "\n";
            }
            md.setMessage(message);
        } else {
            md.setMessage("Modify access rules\n");
        }
        return updateProjectConfig(projectControl, config, md, parentProjectUpdate);
    } catch (RepositoryNotFoundException notFound) {
        throw new NoSuchProjectException(projectName);
    }
}
#end_block

#method_before
private boolean canWriteConfig() throws PermissionBackendException {
    checkNotNull(user);
    if (canWriteConfig != null) {
        return canWriteConfig;
    }
    try {
        permissionBackend.user(user).project(projectName).check(ProjectPermission.WRITE_ACCESS);
        canWriteConfig = true;
    } catch (AuthException e) {
        canWriteConfig = false;
    }
    return canWriteConfig;
}
#method_after
private boolean canWriteConfig() throws PermissionBackendException {
    checkNotNull(user);
    if (canWriteConfig != null) {
        return canWriteConfig;
    }
    try {
        permissionBackend.user(user).project(projectName).check(ProjectPermission.WRITE_CONFIG);
        canWriteConfig = true;
    } catch (AuthException e) {
        canWriteConfig = false;
    }
    return canWriteConfig;
}
#end_block

#method_before
@Override
protected BanResultInfo applyImpl(BatchUpdate.Factory updateFactory, ProjectResource rsrc, Input input) throws RestApiException, UpdateException, IOException, PermissionBackendException {
    BanResultInfo r = new BanResultInfo();
    if (input != null && input.commits != null && !input.commits.isEmpty()) {
        List<ObjectId> commitsToBan = new ArrayList<>(input.commits.size());
        for (String c : input.commits) {
            try {
                commitsToBan.add(ObjectId.fromString(c));
            } catch (IllegalArgumentException e) {
                throw new UnprocessableEntityException(e.getMessage());
            }
        }
        try {
            BanCommitResult result = banCommit.ban(rsrc.getControl(), commitsToBan, input.reason);
            r.newlyBanned = transformCommits(result.getNewlyBannedCommits());
            r.alreadyBanned = transformCommits(result.getAlreadyBannedCommits());
            r.ignored = transformCommits(result.getIgnoredObjectIds());
        } catch (PermissionDeniedException e) {
            throw new AuthException(e.getMessage());
        }
    }
    return r;
}
#method_after
@Override
protected BanResultInfo applyImpl(BatchUpdate.Factory updateFactory, ProjectResource rsrc, Input input) throws RestApiException, UpdateException, IOException, PermissionBackendException {
    BanResultInfo r = new BanResultInfo();
    if (input != null && input.commits != null && !input.commits.isEmpty()) {
        List<ObjectId> commitsToBan = new ArrayList<>(input.commits.size());
        for (String c : input.commits) {
            try {
                commitsToBan.add(ObjectId.fromString(c));
            } catch (IllegalArgumentException e) {
                throw new UnprocessableEntityException(e.getMessage());
            }
        }
        BanCommitResult result = banCommit.ban(rsrc.getControl(), commitsToBan, input.reason);
        r.newlyBanned = transformCommits(result.getNewlyBannedCommits());
        r.alreadyBanned = transformCommits(result.getAlreadyBannedCommits());
        r.ignored = transformCommits(result.getIgnoredObjectIds());
    }
    return r;
}
#end_block

#method_before
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException, PermissionBackendException {
    ProjectControl pc = checkProjectControl();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            config.commit(md);
            projectCache.evict(config.getProject());
            pc = checkProjectControl();
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = checkProjectControl();
        }
    }
    List<AccessSection> local = new ArrayList<>();
    Set<String> ownerOf = new HashSet<>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<>();
    PermissionBackend.ForProject perm = permissionBackend.user(user).project(projectName);
    boolean checkReadConfig = check(perm, RefNames.REFS_CONFIG, READ);
    boolean canWriteProjectConfig = true;
    try {
        perm.check(ProjectPermission.WRITE_ACCESS);
    } catch (AuthException e) {
        canWriteProjectConfig = false;
    }
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (canWriteProjectConfig) {
                local.add(section);
                ownerOf.add(name);
            } else if (checkReadConfig) {
                local.add(section);
            }
        } else if (RefConfigSection.isValid(name)) {
            if (pc.controlForRef(name).isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (checkReadConfig) {
                local.add(section);
            } else if (check(perm, name, READ)) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && isAdmin()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Fall back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    if (config.getRevision() != null) {
        detail.setRevision(config.getRevision().name());
    }
    detail.setInheritsFrom(config.getProject().getParent(allProjectsName));
    if (projectName.equals(allProjectsName) && permissionBackend.user(user).testOrFalse(ADMINISTRATE_SERVER)) {
        ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setCanUpload(canWriteProjectConfig || (checkReadConfig && perm.ref(RefNames.REFS_CONFIG).testOrFalse(CREATE_CHANGE)));
    detail.setConfigVisible(canWriteProjectConfig || checkReadConfig);
    detail.setGroupInfo(buildGroupInfo(local));
    detail.setLabelTypes(pc.getProjectState().getLabelTypes());
    detail.setFileHistoryLinks(getConfigFileLogLinks(projectName.get()));
    return detail;
}
#method_after
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException, PermissionBackendException {
    ProjectControl pc = checkProjectControl();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            config.commit(md);
            projectCache.evict(config.getProject());
            pc = checkProjectControl();
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = checkProjectControl();
        }
    }
    List<AccessSection> local = new ArrayList<>();
    Set<String> ownerOf = new HashSet<>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<>();
    PermissionBackend.ForProject perm = permissionBackend.user(user).project(projectName);
    boolean checkReadConfig = check(perm, RefNames.REFS_CONFIG, READ);
    boolean canWriteProjectConfig = true;
    try {
        perm.check(ProjectPermission.WRITE_CONFIG);
    } catch (AuthException e) {
        canWriteProjectConfig = false;
    }
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (canWriteProjectConfig) {
                local.add(section);
                ownerOf.add(name);
            } else if (checkReadConfig) {
                local.add(section);
            }
        } else if (RefConfigSection.isValid(name)) {
            if (check(perm, name, WRITE_CONFIG)) {
                local.add(section);
                ownerOf.add(name);
            } else if (checkReadConfig) {
                local.add(section);
            } else if (check(perm, name, READ)) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && isAdmin()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Fall back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    if (config.getRevision() != null) {
        detail.setRevision(config.getRevision().name());
    }
    detail.setInheritsFrom(config.getProject().getParent(allProjectsName));
    if (projectName.equals(allProjectsName) && permissionBackend.user(user).testOrFalse(ADMINISTRATE_SERVER)) {
        ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setCanUpload(canWriteProjectConfig || (checkReadConfig && perm.ref(RefNames.REFS_CONFIG).testOrFalse(CREATE_CHANGE)));
    detail.setConfigVisible(canWriteProjectConfig || checkReadConfig);
    detail.setGroupInfo(buildGroupInfo(local));
    detail.setLabelTypes(pc.getProjectState().getLabelTypes());
    detail.setFileHistoryLinks(getConfigFileLogLinks(projectName.get()));
    return detail;
}
#end_block

#method_before
public void checkRemoveReviewer(ChangeNotes notes, CurrentUser currentUser, PatchSetApproval approval) throws PermissionBackendException, AuthException, NoSuchChangeException, OrmException {
    if (canRemoveReviewerWithoutPermissionCheck(notes.getChange(), currentUser, approval.getAccountId(), approval.getValue())) {
        return;
    }
    permissionBackend.user(currentUser).change(notes).database(dbProvider).check(ChangePermission.REMOVE_REVIEWER);
}
#method_after
public void checkRemoveReviewer(ChangeNotes notes, CurrentUser currentUser, PatchSetApproval approval) throws PermissionBackendException, AuthException, NoSuchProjectException, IOException {
    if (canRemoveReviewerWithoutPermissionCheck(notes.getChange(), currentUser, approval.getAccountId(), approval.getValue())) {
        return;
    }
    permissionBackend.user(currentUser).change(notes).database(dbProvider).check(ChangePermission.REMOVE_REVIEWER);
}
#end_block

#method_before
public boolean testRemoveReviewer(ChangeData cd, CurrentUser currentUser, Account.Id reviewer, int value) throws PermissionBackendException, NoSuchChangeException, OrmException {
    if (canRemoveReviewerWithoutPermissionCheck(cd.change(), currentUser, reviewer, value)) {
        return true;
    }
    return permissionBackend.user(currentUser).change(cd).database(dbProvider).test(ChangePermission.REMOVE_REVIEWER);
}
#method_after
public boolean testRemoveReviewer(ChangeData cd, CurrentUser currentUser, Account.Id reviewer, int value) throws PermissionBackendException, NoSuchProjectException, OrmException, IOException {
    if (canRemoveReviewerWithoutPermissionCheck(cd.change(), currentUser, reviewer, value)) {
        return true;
    }
    return permissionBackend.user(currentUser).change(cd).database(dbProvider).test(ChangePermission.REMOVE_REVIEWER);
}
#end_block

#method_before
private boolean canRemoveReviewerWithoutPermissionCheck(Change change, CurrentUser currentUser, Account.Id reviewer, int value) throws NoSuchChangeException, OrmException {
    if (!change.getStatus().isOpen()) {
        return false;
    }
    if (currentUser.isIdentifiedUser()) {
        Account.Id aId = currentUser.getAccountId();
        if (aId.equals(reviewer)) {
            // A user can always remove themselves.
            return true;
        } else if (aId.equals(change.getOwner()) && 0 <= value) {
            // The change owner may remove any zero or positive score.
            return true;
        }
    }
    // Users with the remove reviewer permission, the branch owner, project
    // owner and site admin can remove anyone
    // TODO(hiesel): Remove all Control usage
    ChangeControl changeControl = changeControlFactory.controlFor(dbProvider.get(), change, currentUser);
    if (// branch owner
    changeControl.getRefControl().isOwner() || // project owner
    changeControl.getProjectControl().isOwner() || changeControl.getProjectControl().isAdmin()) {
        // project admin
        return true;
    }
    return false;
}
#method_after
private boolean canRemoveReviewerWithoutPermissionCheck(Change change, CurrentUser currentUser, Account.Id reviewer, int value) throws NoSuchProjectException, IOException {
    if (!change.getStatus().isOpen()) {
        return false;
    }
    if (currentUser.isIdentifiedUser()) {
        Account.Id aId = currentUser.getAccountId();
        if (aId.equals(reviewer)) {
            // A user can always remove themselves.
            return true;
        } else if (aId.equals(change.getOwner()) && 0 <= value) {
            // The change owner may remove any zero or positive score.
            return true;
        }
    }
    // Users with the remove reviewer permission, the branch owner, project
    // owner and site admin can remove anyone
    // TODO(hiesel): Remove all Control usage
    ProjectControl ctl = projectControlFactory.controlFor(change.getProject(), currentUser);
    if (// branch owner
    ctl.controlForRef(change.getDest()).isOwner() || // project owner
    ctl.isOwner() || ctl.isAdmin()) {
        // project admin
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
public Response<ChangeInfo> apply(ChangeResource rsrc, FixInput input) throws RestApiException, OrmException, PermissionBackendException, NoSuchProjectException, IOException {
    PermissionBackend.WithUser perm = permissionBackend.user(user);
    if (!rsrc.isUserOwner()) {
        perm.project(rsrc.getProject()).check(ProjectPermission.READ_ACCESS);
    }
    return Response.withMustRevalidate(newChangeJson().fix(input).format(rsrc));
}
#method_after
@Override
public Response<ChangeInfo> apply(ChangeResource rsrc, FixInput input) throws RestApiException, OrmException, PermissionBackendException, NoSuchProjectException, IOException {
    PermissionBackend.WithUser perm = permissionBackend.user(user);
    if (!rsrc.isUserOwner()) {
        perm.project(rsrc.getProject()).check(ProjectPermission.READ_CONFIG);
    }
    return Response.withMustRevalidate(newChangeJson().fix(input).format(rsrc));
}
#end_block

#method_before
@Override
public Response<DashboardInfo> apply(DashboardResource resource, SetDashboardInput input) throws RestApiException, IOException, PermissionBackendException {
    if (input == null) {
        // Delete would set input to null.
        input = new SetDashboardInput();
    }
    input.id = Strings.emptyToNull(input.id);
    ProjectControl ctl = resource.getControl();
    permissionBackend.user(ctl.getUser()).project(ctl.getProject().getNameKey()).check(ProjectPermission.SET_DEFAULT_DASHBOARD);
    DashboardResource target = null;
    if (input.id != null) {
        try {
            target = dashboards.parse(new ProjectResource(ctl), IdString.fromUrl(input.id));
        } catch (ResourceNotFoundException e) {
            throw new BadRequestException("dashboard " + input.id + " not found");
        } catch (ConfigInvalidException e) {
            throw new ResourceConflictException(e.getMessage());
        }
    }
    try (MetaDataUpdate md = updateFactory.create(ctl.getProject().getNameKey())) {
        ProjectConfig config = ProjectConfig.read(md);
        Project project = config.getProject();
        if (inherited) {
            project.setDefaultDashboard(input.id);
        } else {
            project.setLocalDefaultDashboard(input.id);
        }
        String msg = MoreObjects.firstNonNull(Strings.emptyToNull(input.commitMessage), input.id == null ? "Removed default dashboard.\n" : String.format("Changed default dashboard to %s.\n", input.id));
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        md.setAuthor(ctl.getUser().asIdentifiedUser());
        md.setMessage(msg);
        config.commit(md);
        cache.evict(ctl.getProject());
        if (target != null) {
            DashboardInfo info = get.get().apply(target);
            info.isDefault = true;
            return Response.ok(info);
        }
        return Response.none();
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(ctl.getProject().getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#method_after
@Override
public Response<DashboardInfo> apply(DashboardResource resource, SetDashboardInput input) throws RestApiException, IOException, PermissionBackendException {
    if (input == null) {
        // Delete would set input to null.
        input = new SetDashboardInput();
    }
    input.id = Strings.emptyToNull(input.id);
    ProjectControl ctl = resource.getControl();
    permissionBackend.user(ctl.getUser()).project(ctl.getProject().getNameKey()).check(ProjectPermission.WRITE_CONFIG);
    DashboardResource target = null;
    if (input.id != null) {
        try {
            target = dashboards.parse(new ProjectResource(ctl), IdString.fromUrl(input.id));
        } catch (ResourceNotFoundException e) {
            throw new BadRequestException("dashboard " + input.id + " not found");
        } catch (ConfigInvalidException e) {
            throw new ResourceConflictException(e.getMessage());
        }
    }
    try (MetaDataUpdate md = updateFactory.create(ctl.getProject().getNameKey())) {
        ProjectConfig config = ProjectConfig.read(md);
        Project project = config.getProject();
        if (inherited) {
            project.setDefaultDashboard(input.id);
        } else {
            project.setLocalDefaultDashboard(input.id);
        }
        String msg = MoreObjects.firstNonNull(Strings.emptyToNull(input.commitMessage), input.id == null ? "Removed default dashboard.\n" : String.format("Changed default dashboard to %s.\n", input.id));
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        md.setAuthor(ctl.getUser().asIdentifiedUser());
        md.setMessage(msg);
        config.commit(md);
        cache.evict(ctl.getProject());
        if (target != null) {
            DashboardInfo info = get.get().apply(target);
            info.isDefault = true;
            return Response.ok(info);
        }
        return Response.none();
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(ctl.getProject().getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#end_block

#method_before
@Override
public ProjectAccessInfo apply(ProjectResource rsrc) throws ResourceNotFoundException, ResourceConflictException, IOException, PermissionBackendException, OrmException {
    // Load the current configuration from the repository, ensuring it's the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    Project.NameKey projectName = rsrc.getNameKey();
    ProjectAccessInfo info = new ProjectAccessInfo();
    ProjectControl pc = createProjectControl(projectName);
    PermissionBackend.ForProject perm = permissionBackend.user(user).project(projectName);
    ProjectConfig config;
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            config.commit(md);
            projectCache.evict(config.getProject());
            pc = createProjectControl(projectName);
            perm = permissionBackend.user(user).project(projectName);
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = createProjectControl(projectName);
            perm = permissionBackend.user(user).project(projectName);
        }
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(e.getMessage());
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    }
    info.local = new HashMap<>();
    info.ownerOf = new HashSet<>();
    Map<AccountGroup.UUID, GroupInfo> visibleGroups = new HashMap<>();
    boolean canReadConfig = check(perm, ProjectPermission.READ_ACCESS);
    boolean canWriteConfig = check(perm, ProjectPermission.WRITE_ACCESS);
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (canWriteConfig) {
                info.local.put(name, createAccessSection(visibleGroups, section));
                info.ownerOf.add(name);
            } else if (canReadConfig) {
                info.local.put(section.getName(), createAccessSection(visibleGroups, section));
            }
        } else if (RefConfigSection.isValid(name)) {
            if (pc.controlForRef(name).isOwner()) {
                info.local.put(name, createAccessSection(visibleGroups, section));
                info.ownerOf.add(name);
            } else if (canReadConfig) {
                info.local.put(name, createAccessSection(visibleGroups, section));
            } else if (check(perm, name, READ)) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID groupId = srcRule.getGroup().getUUID();
                        if (groupId == null) {
                            continue;
                        }
                        GroupInfo group = loadGroup(visibleGroups, groupId);
                        if (group != INVISIBLE_SENTINEL) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    info.local.put(name, createAccessSection(visibleGroups, dst));
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (info.ownerOf.isEmpty() && permissionBackend.user(user).test(GlobalPermission.ADMINISTRATE_SERVER)) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Fall back to site administrators.
        info.ownerOf.add(AccessSection.ALL);
    }
    if (config.getRevision() != null) {
        info.revision = config.getRevision().name();
    }
    ProjectState parent = Iterables.getFirst(pc.getProjectState().parents(), null);
    if (parent != null) {
        info.inheritsFrom = projectJson.format(parent.getProject());
    }
    if (projectName.equals(allProjectsName) && permissionBackend.user(user).testOrFalse(ADMINISTRATE_SERVER)) {
        info.ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
    }
    info.isOwner = toBoolean(canWriteConfig);
    info.canUpload = toBoolean(canWriteConfig || (canReadConfig && perm.ref(RefNames.REFS_CONFIG).testOrFalse(CREATE_CHANGE)));
    info.canAdd = toBoolean(perm.testOrFalse(CREATE_REF));
    info.configVisible = canReadConfig || canWriteConfig;
    info.groups = visibleGroups.entrySet().stream().filter(e -> e.getValue() != INVISIBLE_SENTINEL).collect(toMap(e -> e.getKey().get(), e -> e.getValue()));
    return info;
}
#method_after
@Override
public ProjectAccessInfo apply(ProjectResource rsrc) throws ResourceNotFoundException, ResourceConflictException, IOException, PermissionBackendException, OrmException {
    // Load the current configuration from the repository, ensuring it's the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    Project.NameKey projectName = rsrc.getNameKey();
    ProjectAccessInfo info = new ProjectAccessInfo();
    ProjectControl pc = createProjectControl(projectName);
    PermissionBackend.ForProject perm = permissionBackend.user(user).project(projectName);
    ProjectConfig config;
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            config.commit(md);
            projectCache.evict(config.getProject());
            pc = createProjectControl(projectName);
            perm = permissionBackend.user(user).project(projectName);
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = createProjectControl(projectName);
            perm = permissionBackend.user(user).project(projectName);
        }
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(e.getMessage());
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    }
    info.local = new HashMap<>();
    info.ownerOf = new HashSet<>();
    Map<AccountGroup.UUID, GroupInfo> visibleGroups = new HashMap<>();
    boolean canReadConfig = check(perm, ProjectPermission.READ_CONFIG);
    boolean canWriteConfig = check(perm, ProjectPermission.WRITE_CONFIG);
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (canWriteConfig) {
                info.local.put(name, createAccessSection(visibleGroups, section));
                info.ownerOf.add(name);
            } else if (canReadConfig) {
                info.local.put(section.getName(), createAccessSection(visibleGroups, section));
            }
        } else if (RefConfigSection.isValid(name)) {
            if (pc.controlForRef(name).isOwner()) {
                info.local.put(name, createAccessSection(visibleGroups, section));
                info.ownerOf.add(name);
            } else if (canReadConfig) {
                info.local.put(name, createAccessSection(visibleGroups, section));
            } else if (check(perm, name, READ)) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID groupId = srcRule.getGroup().getUUID();
                        if (groupId == null) {
                            continue;
                        }
                        GroupInfo group = loadGroup(visibleGroups, groupId);
                        if (group != INVISIBLE_SENTINEL) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    info.local.put(name, createAccessSection(visibleGroups, dst));
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (info.ownerOf.isEmpty() && permissionBackend.user(user).test(GlobalPermission.ADMINISTRATE_SERVER)) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Fall back to site administrators.
        info.ownerOf.add(AccessSection.ALL);
    }
    if (config.getRevision() != null) {
        info.revision = config.getRevision().name();
    }
    ProjectState parent = Iterables.getFirst(pc.getProjectState().parents(), null);
    if (parent != null) {
        info.inheritsFrom = projectJson.format(parent.getProject());
    }
    if (projectName.equals(allProjectsName) && permissionBackend.user(user).testOrFalse(ADMINISTRATE_SERVER)) {
        info.ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
    }
    info.isOwner = toBoolean(canWriteConfig);
    info.canUpload = toBoolean(canWriteConfig || (canReadConfig && perm.ref(RefNames.REFS_CONFIG).testOrFalse(CREATE_CHANGE)));
    info.canAdd = toBoolean(perm.testOrFalse(CREATE_REF));
    info.configVisible = canReadConfig || canWriteConfig;
    info.groups = visibleGroups.entrySet().stream().filter(e -> e.getValue() != INVISIBLE_SENTINEL).collect(toMap(e -> e.getKey().get(), e -> e.getValue()));
    return info;
}
#end_block

#method_before
// TODO(dborowitz): Hack MetaDataUpdate so it can be created within a BatchUpdate and we can avoid
@SuppressWarnings("deprecation")
@Override
protected Change.Id updateProjectConfig(ProjectControl projectControl, ProjectConfig config, MetaDataUpdate md, boolean parentProjectUpdate) throws IOException, OrmException, PermissionDeniedException, PermissionBackendException {
    PermissionBackend.ForProject perm = permissionBackend.user(projectControl.getUser()).project(projectControl.getProject().getNameKey());
    if (!check(perm, ProjectPermission.READ_ACCESS)) {
        throw new PermissionDeniedException(RefNames.REFS_CONFIG + " not visible");
    }
    if (!check(perm, ProjectPermission.WRITE_ACCESS) && !check(perm.ref(RefNames.REFS_CONFIG), RefPermission.CREATE_CHANGE)) {
        throw new PermissionDeniedException("cannot create change for " + RefNames.REFS_CONFIG);
    }
    md.setInsertChangeId(true);
    Change.Id changeId = new Change.Id(seq.nextChangeId());
    RevCommit commit = config.commitToNewRef(md, new PatchSet.Id(changeId, Change.INITIAL_PATCH_SET_ID).toRefName());
    if (commit.getId().equals(base)) {
        return null;
    }
    try (ObjectInserter objInserter = md.getRepository().newObjectInserter();
        ObjectReader objReader = objInserter.newReader();
        RevWalk rw = new RevWalk(objReader);
        BatchUpdate bu = updateFactory.create(db, config.getProject().getNameKey(), projectControl.getUser(), TimeUtil.nowTs())) {
        bu.setRepository(md.getRepository(), rw, objInserter);
        bu.insertChange(changeInserterFactory.create(changeId, commit, RefNames.REFS_CONFIG).setValidate(false).setUpdateRef(// Created by commitToNewRef.
        false));
        bu.execute();
    } catch (UpdateException | RestApiException e) {
        throw new IOException(e);
    }
    ChangeResource rsrc;
    try {
        rsrc = changes.parse(changeId);
    } catch (ResourceNotFoundException e) {
        throw new IOException(e);
    }
    addProjectOwnersAsReviewers(rsrc);
    if (parentProjectUpdate) {
        addAdministratorsAsReviewers(rsrc);
    }
    return changeId;
}
#method_after
// TODO(dborowitz): Hack MetaDataUpdate so it can be created within a BatchUpdate and we can avoid
@SuppressWarnings("deprecation")
@Override
protected Change.Id updateProjectConfig(ProjectControl projectControl, ProjectConfig config, MetaDataUpdate md, boolean parentProjectUpdate) throws IOException, OrmException, PermissionDeniedException, PermissionBackendException {
    PermissionBackend.ForProject perm = permissionBackend.user(projectControl.getUser()).project(projectControl.getProject().getNameKey());
    if (!check(perm, ProjectPermission.READ_CONFIG)) {
        throw new PermissionDeniedException(RefNames.REFS_CONFIG + " not visible");
    }
    if (!check(perm, ProjectPermission.WRITE_CONFIG) && !check(perm.ref(RefNames.REFS_CONFIG), RefPermission.CREATE_CHANGE)) {
        throw new PermissionDeniedException("cannot create change for " + RefNames.REFS_CONFIG);
    }
    md.setInsertChangeId(true);
    Change.Id changeId = new Change.Id(seq.nextChangeId());
    RevCommit commit = config.commitToNewRef(md, new PatchSet.Id(changeId, Change.INITIAL_PATCH_SET_ID).toRefName());
    if (commit.getId().equals(base)) {
        return null;
    }
    try (ObjectInserter objInserter = md.getRepository().newObjectInserter();
        ObjectReader objReader = objInserter.newReader();
        RevWalk rw = new RevWalk(objReader);
        BatchUpdate bu = updateFactory.create(db, config.getProject().getNameKey(), projectControl.getUser(), TimeUtil.nowTs())) {
        bu.setRepository(md.getRepository(), rw, objInserter);
        bu.insertChange(changeInserterFactory.create(changeId, commit, RefNames.REFS_CONFIG).setValidate(false).setUpdateRef(// Created by commitToNewRef.
        false));
        bu.execute();
    } catch (UpdateException | RestApiException e) {
        throw new IOException(e);
    }
    ChangeResource rsrc;
    try {
        rsrc = changes.parse(changeId);
    } catch (ResourceNotFoundException e) {
        throw new IOException(e);
    }
    addProjectOwnersAsReviewers(rsrc);
    if (parentProjectUpdate) {
        addAdministratorsAsReviewers(rsrc);
    }
    return changeId;
}
#end_block

#method_before
private void reportMessages() {
    List<CreateRequest> created = newChanges.stream().filter(r -> r.change != null).collect(toList());
    if (!created.isEmpty()) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(changeFormatter.newChange(ChangeReportFormatter.Input.builder().setChange(c.change).build()));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = replaceByChange.values().stream().filter(r -> !r.skip && r.inputCommand.getResult() == OK).sorted(comparingInt(r -> r.notes.getChangeId().get())).collect(toList());
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && (magicBranch.edit || magicBranch.draft);
        Boolean isPrivate = null;
        Boolean wip = null;
        if (magicBranch != null) {
            if (magicBranch.isPrivate) {
                isPrivate = true;
            } else if (magicBranch.removePrivate) {
                isPrivate = false;
            }
            if (magicBranch.workInProgress) {
                wip = true;
            } else if (magicBranch.ready) {
                wip = false;
            }
        }
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            if (isPrivate == null) {
                isPrivate = u.notes.getChange().isPrivate();
            }
            if (wip == null) {
                wip = u.notes.getChange().isWorkInProgress();
            }
            ChangeReportFormatter.Input input = ChangeReportFormatter.Input.builder().setChange(u.notes.getChange()).setSubject(subject).setIsEdit(edit).setIsPrivate(isPrivate).setIsWorkInProgress(wip).build();
            addMessage(changeFormatter.changeUpdated(input));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    List<CreateRequest> created = newChanges.stream().filter(r -> r.change != null).collect(toList());
    if (!created.isEmpty()) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(changeFormatter.newChange(ChangeReportFormatter.Input.builder().setChange(c.change).build()));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = replaceByChange.values().stream().filter(r -> !r.skip && r.inputCommand.getResult() == OK).sorted(comparingInt(r -> r.notes.getChangeId().get())).collect(toList());
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && (magicBranch.edit || magicBranch.draft);
        Boolean isPrivate = null;
        Boolean wip = null;
        if (magicBranch != null) {
            if (magicBranch.isPrivate) {
                isPrivate = true;
            } else if (magicBranch.removePrivate) {
                isPrivate = false;
            }
            if (magicBranch.workInProgress) {
                wip = true;
            } else if (magicBranch.ready) {
                wip = false;
            }
        }
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            if (isPrivate == null) {
                isPrivate = u.notes.getChange().isPrivate();
            }
            if (wip == null) {
                wip = u.notes.getChange().isWorkInProgress();
            }
            ChangeReportFormatter.Input input = ChangeReportFormatter.Input.builder().setChange(u.notes.getChange()).setSubject(subject).setIsEdit(edit).setIsPrivate(isPrivate).setIsWorkInProgress(wip).build();
            addMessage(changeFormatter.changeUpdated(input));
        }
        addMessage("");
    }
    // TODO(xchangcheng): remove after migrating tools which are using this magic branch.
    if (magicBranch != null && magicBranch.publish) {
        addMessage("Pushing to refs/publish/* is deprecated, use refs/for/* instead.");
    }
}
#end_block

#method_before
private void parseCommands(Collection<ReceiveCommand> commands) throws PermissionBackendException, NoSuchProjectException, IOException {
    List<String> optionList = rp.getPushOptions();
    if (optionList != null) {
        for (String option : optionList) {
            int e = option.indexOf('=');
            if (e > 0) {
                pushOptions.put(option.substring(0, e), option.substring(e + 1));
            } else {
                pushOptions.put(option, "");
            }
        }
    }
    logDebug("Parsing {} commands", commands.size());
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // Already rejected by the core receive process.
            logDebug("Already processed by core: {} {}", cmd.getResult(), cmd);
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            String newName = RefNames.refsUsers(user.getAccountId());
            logDebug("Swapping out command for {} to {}", RefNames.REFS_USERS_SELF, newName);
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), newName, cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET_PATTERN.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd, "prohibited by Gerrit: unknown command type " + cmd.getType());
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            logDebug("Processing {} command", cmd.getRefName());
            try {
                permissions.check(ProjectPermission.WRITE_ACCESS);
            } catch (AuthException e) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent)) {
                                try {
                                    permissionBackend.user(user).check(GlobalPermission.ADMINISTRATE_SERVER);
                                } catch (AuthException e) {
                                    reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                    continue;
                                }
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                oldValue = Arrays.stream(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName())).collect(joining("\n"));
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd, "prohibited by Gerrit: don't know how to handle config update of type " + cmd.getType());
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) throws PermissionBackendException, NoSuchProjectException, IOException {
    List<String> optionList = rp.getPushOptions();
    if (optionList != null) {
        for (String option : optionList) {
            int e = option.indexOf('=');
            if (e > 0) {
                pushOptions.put(option.substring(0, e), option.substring(e + 1));
            } else {
                pushOptions.put(option, "");
            }
        }
    }
    logDebug("Parsing {} commands", commands.size());
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // Already rejected by the core receive process.
            logDebug("Already processed by core: {} {}", cmd.getResult(), cmd);
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            String newName = RefNames.refsUsers(user.getAccountId());
            logDebug("Swapping out command for {} to {}", RefNames.REFS_USERS_SELF, newName);
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), newName, cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET_PATTERN.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd, "prohibited by Gerrit: unknown command type " + cmd.getType());
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            logDebug("Processing {} command", cmd.getRefName());
            try {
                permissions.check(ProjectPermission.WRITE_CONFIG);
            } catch (AuthException e) {
                reject(cmd, String.format("must be either project owner or have %s permission", ProjectPermission.WRITE_CONFIG.describeForException()));
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent)) {
                                try {
                                    permissionBackend.user(user).check(GlobalPermission.ADMINISTRATE_SERVER);
                                } catch (AuthException e) {
                                    reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                    continue;
                                }
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                oldValue = Arrays.stream(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName())).collect(joining("\n"));
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd, "prohibited by Gerrit: don't know how to handle config update of type " + cmd.getType());
                    continue;
            }
        }
    }
}
#end_block

#method_before
@Override
public Response<String> apply(ProjectResource resource, DescriptionInput input) throws AuthException, ResourceConflictException, ResourceNotFoundException, IOException, PermissionBackendException {
    if (input == null) {
        // Delete would set description to null.
        input = new DescriptionInput();
    }
    ProjectControl ctl = resource.getControl();
    IdentifiedUser user = ctl.getUser().asIdentifiedUser();
    permissionBackend.user(user).project(resource.getNameKey()).check(ProjectPermission.WRITE_ACCESS);
    try (MetaDataUpdate md = updateFactory.create(resource.getNameKey())) {
        ProjectConfig config = ProjectConfig.read(md);
        Project project = config.getProject();
        project.setDescription(Strings.emptyToNull(input.description));
        String msg = MoreObjects.firstNonNull(Strings.emptyToNull(input.commitMessage), "Updated description.\n");
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        md.setAuthor(user);
        md.setMessage(msg);
        config.commit(md);
        cache.evict(ctl.getProject());
        md.getRepository().setGitwebDescription(project.getDescription());
        return Strings.isNullOrEmpty(project.getDescription()) ? Response.<String>none() : Response.ok(project.getDescription());
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(resource.getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#method_after
@Override
public Response<String> apply(ProjectResource resource, DescriptionInput input) throws AuthException, ResourceConflictException, ResourceNotFoundException, IOException, PermissionBackendException {
    if (input == null) {
        // Delete would set description to null.
        input = new DescriptionInput();
    }
    ProjectControl ctl = resource.getControl();
    IdentifiedUser user = ctl.getUser().asIdentifiedUser();
    permissionBackend.user(user).project(resource.getNameKey()).check(ProjectPermission.WRITE_CONFIG);
    try (MetaDataUpdate md = updateFactory.create(resource.getNameKey())) {
        ProjectConfig config = ProjectConfig.read(md);
        Project project = config.getProject();
        project.setDescription(Strings.emptyToNull(input.description));
        String msg = MoreObjects.firstNonNull(Strings.emptyToNull(input.commitMessage), "Updated description.\n");
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        md.setAuthor(user);
        md.setMessage(msg);
        config.commit(md);
        cache.evict(ctl.getProject());
        md.getRepository().setGitwebDescription(project.getDescription());
        return Strings.isNullOrEmpty(project.getDescription()) ? Response.<String>none() : Response.ok(project.getDescription());
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(resource.getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#end_block

#method_before
public BanCommitResult ban(ProjectControl projectControl, List<ObjectId> commitsToBan, String reason) throws PermissionDeniedException, LockFailureException, IOException, PermissionBackendException {
    try {
        permissionBackend.user(projectControl.getUser()).project(projectControl.getProject().getNameKey()).check(ProjectPermission.BAN_COMMIT);
    } catch (AuthException e) {
        throw new PermissionDeniedException("Not project owner: not permitted to ban commits");
    }
    final BanCommitResult result = new BanCommitResult();
    NoteMap banCommitNotes = NoteMap.newEmptyMap();
    // Add a note for each banned commit to notes.
    final Project.NameKey project = projectControl.getProject().getNameKey();
    try (Repository repo = repoManager.openRepository(project);
        RevWalk revWalk = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter()) {
        ObjectId noteId = null;
        for (ObjectId commitToBan : commitsToBan) {
            try {
                revWalk.parseCommit(commitToBan);
            } catch (MissingObjectException e) {
            // Ignore exception, non-existing commits can be banned.
            } catch (IncorrectObjectTypeException e) {
                result.notACommit(commitToBan);
                continue;
            }
            if (noteId == null) {
                noteId = createNoteContent(reason, inserter);
            }
            banCommitNotes.set(commitToBan, noteId);
        }
        NotesBranchUtil notesBranchUtil = notesBranchUtilFactory.create(project, repo, inserter);
        NoteMap newlyCreated = notesBranchUtil.commitNewNotes(banCommitNotes, REFS_REJECT_COMMITS, createPersonIdent(), buildCommitMessage(commitsToBan, reason));
        for (Note n : banCommitNotes) {
            if (newlyCreated.contains(n)) {
                result.commitBanned(n);
            } else {
                result.commitAlreadyBanned(n);
            }
        }
        return result;
    }
}
#method_after
public BanCommitResult ban(ProjectControl projectControl, List<ObjectId> commitsToBan, String reason) throws AuthException, LockFailureException, IOException, PermissionBackendException {
    permissionBackend.user(projectControl.getUser()).project(projectControl.getProject().getNameKey()).check(ProjectPermission.BAN_COMMIT);
    final BanCommitResult result = new BanCommitResult();
    NoteMap banCommitNotes = NoteMap.newEmptyMap();
    // Add a note for each banned commit to notes.
    final Project.NameKey project = projectControl.getProject().getNameKey();
    try (Repository repo = repoManager.openRepository(project);
        RevWalk revWalk = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter()) {
        ObjectId noteId = null;
        for (ObjectId commitToBan : commitsToBan) {
            try {
                revWalk.parseCommit(commitToBan);
            } catch (MissingObjectException e) {
            // Ignore exception, non-existing commits can be banned.
            } catch (IncorrectObjectTypeException e) {
                result.notACommit(commitToBan);
                continue;
            }
            if (noteId == null) {
                noteId = createNoteContent(reason, inserter);
            }
            banCommitNotes.set(commitToBan, noteId);
        }
        NotesBranchUtil notesBranchUtil = notesBranchUtilFactory.create(project, repo, inserter);
        NoteMap newlyCreated = notesBranchUtil.commitNewNotes(banCommitNotes, REFS_REJECT_COMMITS, createPersonIdent(), buildCommitMessage(commitsToBan, reason));
        for (Note n : banCommitNotes) {
            if (newlyCreated.contains(n)) {
                result.commitBanned(n);
            } else {
                result.commitAlreadyBanned(n);
            }
        }
        return result;
    }
}
#end_block

#method_before
public String getRefName() {
    return refName;
}
#method_after
String getRefName() {
    return refName;
}
#end_block

#method_before
public ProjectControl getProjectControl() {
    return projectControl;
}
#method_after
ProjectControl getProjectControl() {
    return projectControl;
}
#end_block

#method_before
public CurrentUser getUser() {
    return projectControl.getUser();
}
#method_after
CurrentUser getUser() {
    return projectControl.getUser();
}
#end_block

#method_before
public RefControl forUser(CurrentUser who) {
    ProjectControl newCtl = projectControl.forUser(who);
    if (relevant.isUserSpecific()) {
        return newCtl.controlForRef(getRefName());
    }
    return new RefControl(newCtl, getRefName(), relevant);
}
#method_after
RefControl forUser(CurrentUser who) {
    ProjectControl newCtl = projectControl.forUser(who);
    if (relevant.isUserSpecific()) {
        return newCtl.controlForRef(getRefName());
    }
    return new RefControl(newCtl, getRefName(), relevant);
}
#end_block

#method_before
public boolean isOwner() {
    if (owner == null) {
        if (canPerform(Permission.OWNER)) {
            owner = true;
        } else {
            owner = projectControl.isOwner();
        }
    }
    return owner;
}
#method_after
boolean isOwner() {
    if (owner == null) {
        if (canPerform(Permission.OWNER)) {
            owner = true;
        } else {
            owner = projectControl.isOwner();
        }
    }
    return owner;
}
#end_block

#method_before
public boolean isBlocked(String permissionName) {
    return !doCanPerform(permissionName, false, true);
}
#method_after
boolean isBlocked(String permissionName) {
    return !doCanPerform(permissionName, false, true);
}
#end_block

#method_before
private boolean can(RefPermission perm) throws PermissionBackendException {
    switch(perm) {
        case READ:
            return isVisible();
        case CREATE:
            // TODO This isn't an accurate test.
            return canPerform(perm.permissionName().get());
        case DELETE:
            return canDelete();
        case UPDATE:
            return canUpdate();
        case FORCE_UPDATE:
            return canForceUpdate();
        case SET_HEAD:
            return projectControl.isOwner();
        case FORGE_AUTHOR:
            return canForgeAuthor();
        case FORGE_COMMITTER:
            return canForgeCommitter();
        case FORGE_SERVER:
            return canForgeGerritServerIdentity();
        case MERGE:
            return canUploadMerges();
        case CREATE_CHANGE:
            return canUpload();
        case UPDATE_BY_SUBMIT:
            return projectControl.controlForRef("refs/for/" + getRefName()).canSubmit(true);
        case SKIP_VALIDATION:
            return canForgeAuthor() && canForgeCommitter() && canForgeGerritServerIdentity() && canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy();
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#method_after
private boolean can(RefPermission perm) throws PermissionBackendException {
    switch(perm) {
        case READ:
            return isVisible();
        case CREATE:
            // TODO This isn't an accurate test.
            return canPerform(perm.permissionName().get());
        case DELETE:
            return canDelete();
        case UPDATE:
            return canUpdate();
        case FORCE_UPDATE:
            return canForceUpdate();
        case SET_HEAD:
            return projectControl.isOwner();
        case FORGE_AUTHOR:
            return canForgeAuthor();
        case FORGE_COMMITTER:
            return canForgeCommitter();
        case FORGE_SERVER:
            return canForgeGerritServerIdentity();
        case MERGE:
            return canUploadMerges();
        case CREATE_CHANGE:
            return canUpload();
        case UPDATE_BY_SUBMIT:
            return projectControl.controlForRef("refs/for/" + getRefName()).canSubmit(true);
        case READ_PRIVATE_CHANGES:
            return canViewPrivateChanges();
        case READ_CONFIG:
            return projectControl.controlForRef(RefNames.REFS_CONFIG).canPerform(RefPermission.READ.name());
        case WRITE_CONFIG:
            return isOwner();
        case SKIP_VALIDATION:
            return canForgeAuthor() && canForgeCommitter() && canForgeGerritServerIdentity() && canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy();
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#end_block

#method_before
@Override
public String apply(ProjectResource rsrc) throws AuthException, ResourceNotFoundException, IOException, PermissionBackendException {
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        Ref head = repo.getRefDatabase().exactRef(Constants.HEAD);
        if (head == null) {
            throw new ResourceNotFoundException(Constants.HEAD);
        } else if (head.isSymbolic()) {
            String n = head.getTarget().getName();
            permissionBackend.user(rsrc.getUser()).project(rsrc.getNameKey()).ref(n).check(RefPermission.READ);
            return n;
        } else if (head.getObjectId() != null) {
            try (RevWalk rw = new RevWalk(repo)) {
                RevCommit commit = rw.parseCommit(head.getObjectId());
                if (commits.canRead(rsrc.getProjectState(), repo, commit)) {
                    return head.getObjectId().name();
                }
                throw new AuthException("not allowed to see HEAD");
            } catch (MissingObjectException | IncorrectObjectTypeException e) {
                throw new AuthException("not allowed to see HEAD");
            }
        }
        throw new ResourceNotFoundException(Constants.HEAD);
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    }
}
#method_after
@Override
public String apply(ProjectResource rsrc) throws AuthException, ResourceNotFoundException, IOException, PermissionBackendException {
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        Ref head = repo.getRefDatabase().exactRef(Constants.HEAD);
        if (head == null) {
            throw new ResourceNotFoundException(Constants.HEAD);
        } else if (head.isSymbolic()) {
            String n = head.getTarget().getName();
            permissionBackend.user(rsrc.getUser()).project(rsrc.getNameKey()).ref(n).check(RefPermission.READ);
            return n;
        } else if (head.getObjectId() != null) {
            try (RevWalk rw = new RevWalk(repo)) {
                RevCommit commit = rw.parseCommit(head.getObjectId());
                if (commits.canRead(rsrc.getProjectState(), repo, commit)) {
                    return head.getObjectId().name();
                }
                throw new AuthException("not allowed to see HEAD");
            } catch (MissingObjectException | IncorrectObjectTypeException e) {
                try {
                    permissionBackend.user(rsrc.getUser()).project(rsrc.getNameKey()).check(ProjectPermission.WRITE_CONFIG);
                } catch (AuthException ae) {
                    throw new AuthException("not allowed to see HEAD");
                }
            }
        }
        throw new ResourceNotFoundException(Constants.HEAD);
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    }
}
#end_block

#method_before
@Override
public ConfigInfo apply(ProjectResource rsrc, ConfigInput input) throws RestApiException, PermissionBackendException {
    permissionBackend.user(user).project(rsrc.getNameKey()).check(ProjectPermission.WRITE_ACCESS);
    return apply(rsrc.getProjectState(), input);
}
#method_after
@Override
public ConfigInfo apply(ProjectResource rsrc, ConfigInput input) throws RestApiException, PermissionBackendException {
    permissionBackend.user(user).project(rsrc.getNameKey()).check(ProjectPermission.WRITE_CONFIG);
    return apply(rsrc.getProjectState(), input);
}
#end_block

#method_before
@Override
public Response<ChangeInfo> apply(ProjectResource rsrc, ProjectAccessInput input) throws PermissionBackendException, PermissionDeniedException, IOException, ConfigInvalidException, OrmException, InvalidNameException, UpdateException, RestApiException {
    PermissionBackend.ForProject forProject = permissionBackend.user(rsrc.getUser()).project(rsrc.getNameKey());
    if (!check(forProject, ProjectPermission.READ_ACCESS)) {
        throw new PermissionDeniedException(RefNames.REFS_CONFIG + " not visible");
    }
    if (!check(forProject, ProjectPermission.WRITE_ACCESS)) {
        try {
            forProject.ref(RefNames.REFS_CONFIG).check(RefPermission.CREATE_CHANGE);
        } catch (AuthException denied) {
            throw new PermissionDeniedException("cannot create change for " + RefNames.REFS_CONFIG);
        }
    }
    MetaDataUpdate.User metaDataUpdateUser = metaDataUpdateFactory.get();
    List<AccessSection> removals = setAccess.getAccessSections(input.remove);
    List<AccessSection> additions = setAccess.getAccessSections(input.add);
    Project.NameKey newParentProjectName = input.parent == null ? null : new Project.NameKey(input.parent);
    try (MetaDataUpdate md = metaDataUpdateUser.create(rsrc.getNameKey())) {
        ProjectConfig config = ProjectConfig.read(md);
        setAccess.validateChanges(config, removals, additions);
        setAccess.applyChanges(config, removals, additions);
        try {
            setAccess.setParentName(rsrc.getUser().asIdentifiedUser(), config, rsrc.getNameKey(), newParentProjectName, false);
        } catch (AuthException e) {
            throw new IllegalStateException(e);
        }
        md.setMessage("Review access change");
        md.setInsertChangeId(true);
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        RevCommit commit = config.commitToNewRef(md, new PatchSet.Id(changeId, Change.INITIAL_PATCH_SET_ID).toRefName());
        try (ObjectInserter objInserter = md.getRepository().newObjectInserter();
            ObjectReader objReader = objInserter.newReader();
            RevWalk rw = new RevWalk(objReader);
            BatchUpdate bu = updateFactory.create(db.get(), rsrc.getNameKey(), rsrc.getUser(), TimeUtil.nowTs())) {
            bu.setRepository(md.getRepository(), rw, objInserter);
            ChangeInserter ins = newInserter(changeId, commit);
            bu.insertChange(ins);
            bu.execute();
            return Response.created(jsonFactory.noOptions().format(ins.getChange()));
        }
    }
}
#method_after
@Override
public Response<ChangeInfo> apply(ProjectResource rsrc, ProjectAccessInput input) throws PermissionBackendException, PermissionDeniedException, IOException, ConfigInvalidException, OrmException, InvalidNameException, UpdateException, RestApiException {
    PermissionBackend.ForProject forProject = permissionBackend.user(rsrc.getUser()).project(rsrc.getNameKey());
    if (!check(forProject, ProjectPermission.READ_CONFIG)) {
        throw new PermissionDeniedException(RefNames.REFS_CONFIG + " not visible");
    }
    if (!check(forProject, ProjectPermission.WRITE_CONFIG)) {
        try {
            forProject.ref(RefNames.REFS_CONFIG).check(RefPermission.CREATE_CHANGE);
        } catch (AuthException denied) {
            throw new PermissionDeniedException("cannot create change for " + RefNames.REFS_CONFIG);
        }
    }
    MetaDataUpdate.User metaDataUpdateUser = metaDataUpdateFactory.get();
    List<AccessSection> removals = setAccess.getAccessSections(input.remove);
    List<AccessSection> additions = setAccess.getAccessSections(input.add);
    Project.NameKey newParentProjectName = input.parent == null ? null : new Project.NameKey(input.parent);
    try (MetaDataUpdate md = metaDataUpdateUser.create(rsrc.getNameKey())) {
        ProjectConfig config = ProjectConfig.read(md);
        setAccess.validateChanges(config, removals, additions);
        setAccess.applyChanges(config, removals, additions);
        try {
            setAccess.setParentName(rsrc.getUser().asIdentifiedUser(), config, rsrc.getNameKey(), newParentProjectName, false);
        } catch (AuthException e) {
            throw new IllegalStateException(e);
        }
        md.setMessage("Review access change");
        md.setInsertChangeId(true);
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        RevCommit commit = config.commitToNewRef(md, new PatchSet.Id(changeId, Change.INITIAL_PATCH_SET_ID).toRefName());
        try (ObjectInserter objInserter = md.getRepository().newObjectInserter();
            ObjectReader objReader = objInserter.newReader();
            RevWalk rw = new RevWalk(objReader);
            BatchUpdate bu = updateFactory.create(db.get(), rsrc.getNameKey(), rsrc.getUser(), TimeUtil.nowTs())) {
            bu.setRepository(md.getRepository(), rw, objInserter);
            ChangeInserter ins = newInserter(changeId, commit);
            bu.insertChange(ins);
            bu.execute();
            return Response.created(jsonFactory.noOptions().format(ins.getChange()));
        }
    }
}
#end_block

#method_before
@Override
public List<ReflogEntryInfo> apply(BranchResource rsrc) throws RestApiException, IOException, PermissionBackendException {
    permissionBackend.user(rsrc.getUser()).project(rsrc.getNameKey()).check(ProjectPermission.READ_REF_LOG);
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        ReflogReader r;
        try {
            r = repo.getReflogReader(rsrc.getRef());
        } catch (UnsupportedOperationException e) {
            String msg = "reflog not supported on repo " + rsrc.getNameKey().get();
            log.error(msg);
            throw new MethodNotAllowedException(msg);
        }
        if (r == null) {
            throw new ResourceNotFoundException(rsrc.getRef());
        }
        List<ReflogEntry> entries;
        if (from == null && to == null) {
            entries = limit > 0 ? r.getReverseEntries(limit) : r.getReverseEntries();
        } else {
            entries = limit > 0 ? new ArrayList<>(limit) : new ArrayList<>();
            for (ReflogEntry e : r.getReverseEntries()) {
                Timestamp timestamp = new Timestamp(e.getWho().getWhen().getTime());
                if ((from == null || from.before(timestamp)) && (to == null || to.after(timestamp))) {
                    entries.add(e);
                }
                if (limit > 0 && entries.size() >= limit) {
                    break;
                }
            }
        }
        return Lists.transform(entries, e -> newReflogEntryInfo(e));
    }
}
#method_after
@Override
public List<ReflogEntryInfo> apply(BranchResource rsrc) throws RestApiException, IOException, PermissionBackendException {
    permissionBackend.user(rsrc.getUser()).project(rsrc.getNameKey()).check(ProjectPermission.READ_REFLOG);
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        ReflogReader r;
        try {
            r = repo.getReflogReader(rsrc.getRef());
        } catch (UnsupportedOperationException e) {
            String msg = "reflog not supported on repo " + rsrc.getNameKey().get();
            log.error(msg);
            throw new MethodNotAllowedException(msg);
        }
        if (r == null) {
            throw new ResourceNotFoundException(rsrc.getRef());
        }
        List<ReflogEntry> entries;
        if (from == null && to == null) {
            entries = limit > 0 ? r.getReverseEntries(limit) : r.getReverseEntries();
        } else {
            entries = limit > 0 ? new ArrayList<>(limit) : new ArrayList<>();
            for (ReflogEntry e : r.getReverseEntries()) {
                Timestamp timestamp = new Timestamp(e.getWho().getWhen().getTime());
                if ((from == null || from.before(timestamp)) && (to == null || to.after(timestamp))) {
                    entries.add(e);
                }
                if (limit > 0 && entries.size() >= limit) {
                    break;
                }
            }
        }
        return Lists.transform(entries, e -> newReflogEntryInfo(e));
    }
}
#end_block

#method_before
private Optional<ChangedLines> computeChangedLines() throws OrmException {
    Change c = change();
    if (c == null) {
        return Optional.empty();
    }
    PatchSet ps = currentPatchSet();
    if (ps == null) {
        return Optional.empty();
    }
    return getPatchList(c, ps).map(p -> new ChangedLines(p.getInsertions(), p.getDeletions()));
}
#method_after
private Optional<ChangedLines> computeChangedLines() throws OrmException {
    Change c = change();
    if (c == null) {
        return Optional.empty();
    }
    PatchSet ps = currentPatchSet();
    if (ps == null) {
        return Optional.empty();
    }
    Optional<DiffSummary> ds = getDiffSummary(c, ps);
    if (ds.isPresent()) {
        return Optional.of(ds.get().getChangedLines());
    }
    return Optional.empty();
}
#end_block

#method_before
public ImmutableListMultimap<Account.Id, String> stars() throws OrmException {
    if (stars == null) {
        if (!lazyLoad) {
            return ImmutableListMultimap.of();
        }
        ImmutableListMultimap.Builder<Account.Id, String> b = ImmutableListMultimap.builder();
        for (Map.Entry<Account.Id, StarRef> e : starRefs().entrySet()) {
            b.putAll(e.getKey(), e.getValue().labels());
        }
        return b.build();
    }
    return stars;
}
#method_after
public Set<String> stars(Account.Id accountId) throws OrmException {
    if (starsOf != null) {
        if (!starsOf.accountId().equals(accountId)) {
            starsOf = null;
        }
    }
    if (starsOf == null) {
        if (stars != null) {
            starsOf = StarsOf.create(accountId, stars.get(accountId));
        } else {
            if (!lazyLoad) {
                return ImmutableSet.of();
            }
            starsOf = StarsOf.create(accountId, starredChangesUtil.getLabels(accountId, legacyId));
        }
    }
    return starsOf.stars();
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> has(String value) throws QueryParseException {
    if ("star".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("stars".equalsIgnoreCase(value)) {
        return new HasStarsPredicate(self());
    }
    if ("draft".equalsIgnoreCase(value)) {
        return draftby(self());
    }
    if ("edit".equalsIgnoreCase(value)) {
        return new EditByPredicate(self());
    }
    // for plugins the value will be operandName_pluginName
    String[] names = value.split("_");
    if (names.length == 2) {
        ChangeHasOperandFactory op = args.hasOperands.get(names[1], names[0]);
        if (op != null) {
            return op.create(this);
        }
    }
    throw new IllegalArgumentException();
}
#method_after
@Operator
public Predicate<ChangeData> has(String value) throws QueryParseException {
    if ("star".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("stars".equalsIgnoreCase(value)) {
        return new HasStarsPredicate(self());
    }
    if ("draft".equalsIgnoreCase(value)) {
        return draftby(self());
    }
    if ("edit".equalsIgnoreCase(value)) {
        return new EditByPredicate(self());
    }
    if ("unresolved".equalsIgnoreCase(value)) {
        return new IsUnresolvedPredicate();
    }
    // for plugins the value will be operandName_pluginName
    String[] names = value.split("_");
    if (names.length == 2) {
        ChangeHasOperandFactory op = args.hasOperands.get(names[1], names[0]);
        if (op != null) {
            return op.create(this);
        }
    }
    throw new IllegalArgumentException();
}
#end_block

#method_before
private ChangeData toChangeData(ListMultimap<String, IndexableField> doc, Set<String> fields, String idFieldName) {
    ChangeData cd;
    // Either change or the ID field was guaranteed to be included in the call
    // to fields() above.
    IndexableField cb = Iterables.getFirst(doc.get(CHANGE_FIELD), null);
    if (cb != null) {
        BytesRef proto = cb.binaryValue();
        cd = changeDataFactory.create(db.get(), ChangeProtoField.CODEC.decode(proto.bytes, proto.offset, proto.length));
    } else {
        IndexableField f = Iterables.getFirst(doc.get(idFieldName), null);
        Change.Id id = new Change.Id(f.numericValue().intValue());
        IndexableField project = Iterables.getFirst(doc.get(PROJECT.getName()), null);
        if (project == null) {
            // Old schema without project field: we can safely assume NoteDb is
            // disabled.
            cd = changeDataFactory.createOnlyWhenNoteDbDisabled(db.get(), id);
        } else {
            cd = changeDataFactory.create(db.get(), new Project.NameKey(project.stringValue()), id);
        }
    }
    if (fields.contains(PATCH_SET_FIELD)) {
        decodePatchSets(doc, cd);
    }
    if (fields.contains(APPROVAL_FIELD)) {
        decodeApprovals(doc, cd);
    }
    if (fields.contains(ADDED_FIELD) && fields.contains(DELETED_FIELD)) {
        decodeChangedLines(doc, cd);
    }
    if (fields.contains(MERGEABLE_FIELD)) {
        decodeMergeable(doc, cd);
    }
    if (fields.contains(REVIEWEDBY_FIELD)) {
        decodeReviewedBy(doc, cd);
    }
    if (fields.contains(HASHTAG_FIELD)) {
        decodeHashtags(doc, cd);
    }
    if (fields.contains(STAR_FIELD)) {
        decodeStar(doc, cd);
    }
    if (fields.contains(REVIEWER_FIELD)) {
        decodeReviewers(doc, cd);
    }
    decodeSubmitRecords(doc, SUBMIT_RECORD_STRICT_FIELD, ChangeField.SUBMIT_RULE_OPTIONS_STRICT, cd);
    decodeSubmitRecords(doc, SUBMIT_RECORD_LENIENT_FIELD, ChangeField.SUBMIT_RULE_OPTIONS_LENIENT, cd);
    if (fields.contains(REF_STATE_FIELD)) {
        decodeRefStates(doc, cd);
    }
    if (fields.contains(REF_STATE_PATTERN_FIELD)) {
        decodeRefStatePatterns(doc, cd);
    }
    if (fields.contains(UNRESOLVED_COMMENTS_NUM_FIELD)) {
        decodeUnresolvedCommentsNum(doc, cd);
    }
    return cd;
}
#method_after
private ChangeData toChangeData(ListMultimap<String, IndexableField> doc, Set<String> fields, String idFieldName) {
    ChangeData cd;
    // Either change or the ID field was guaranteed to be included in the call
    // to fields() above.
    IndexableField cb = Iterables.getFirst(doc.get(CHANGE_FIELD), null);
    if (cb != null) {
        BytesRef proto = cb.binaryValue();
        cd = changeDataFactory.create(db.get(), ChangeProtoField.CODEC.decode(proto.bytes, proto.offset, proto.length));
    } else {
        IndexableField f = Iterables.getFirst(doc.get(idFieldName), null);
        Change.Id id = new Change.Id(f.numericValue().intValue());
        IndexableField project = Iterables.getFirst(doc.get(PROJECT.getName()), null);
        if (project == null) {
            // Old schema without project field: we can safely assume NoteDb is
            // disabled.
            cd = changeDataFactory.createOnlyWhenNoteDbDisabled(db.get(), id);
        } else {
            cd = changeDataFactory.create(db.get(), new Project.NameKey(project.stringValue()), id);
        }
    }
    if (fields.contains(PATCH_SET_FIELD)) {
        decodePatchSets(doc, cd);
    }
    if (fields.contains(APPROVAL_FIELD)) {
        decodeApprovals(doc, cd);
    }
    if (fields.contains(ADDED_FIELD) && fields.contains(DELETED_FIELD)) {
        decodeChangedLines(doc, cd);
    }
    if (fields.contains(MERGEABLE_FIELD)) {
        decodeMergeable(doc, cd);
    }
    if (fields.contains(REVIEWEDBY_FIELD)) {
        decodeReviewedBy(doc, cd);
    }
    if (fields.contains(HASHTAG_FIELD)) {
        decodeHashtags(doc, cd);
    }
    if (fields.contains(STAR_FIELD)) {
        decodeStar(doc, cd);
    }
    if (fields.contains(REVIEWER_FIELD)) {
        decodeReviewers(doc, cd);
    }
    decodeSubmitRecords(doc, SUBMIT_RECORD_STRICT_FIELD, ChangeField.SUBMIT_RULE_OPTIONS_STRICT, cd);
    decodeSubmitRecords(doc, SUBMIT_RECORD_LENIENT_FIELD, ChangeField.SUBMIT_RULE_OPTIONS_LENIENT, cd);
    if (fields.contains(REF_STATE_FIELD)) {
        decodeRefStates(doc, cd);
    }
    if (fields.contains(REF_STATE_PATTERN_FIELD)) {
        decodeRefStatePatterns(doc, cd);
    }
    decodeUnresolvedCommentCount(doc, cd);
    return cd;
}
#end_block

#method_before
void cacheVisibleTo(ChangeControl ctl) {
    visibleTo = ctl.getUser();
}
#method_after
void cacheVisibleTo(ChangeControl ctl) {
    visibleTo = ctl.getUser();
    changeControl = ctl;
}
#end_block

#method_before
public Boolean isMergeable() throws OrmException {
    if (mergeable == null) {
        Change c = change();
        if (c == null) {
            return null;
        }
        if (c.getStatus() == Change.Status.MERGED) {
            mergeable = true;
        } else if (c.getStatus() == Change.Status.ABANDONED) {
            return null;
        } else if (c.isWorkInProgress()) {
            return null;
        } else {
            if (!lazyLoad) {
                return null;
            }
            PatchSet ps = currentPatchSet();
            try {
                if (ps == null || !changeControlFactory.controlFor(db, change(), userFactory.create(c.getOwner())).isPatchVisible(ps, db)) {
                    return null;
                }
            } catch (OrmException e) {
                if (e.getCause() instanceof NoSuchChangeException) {
                    return null;
                }
                throw e;
            }
            try (Repository repo = repoManager.openRepository(project())) {
                Ref ref = repo.getRefDatabase().exactRef(c.getDest().get());
                SubmitTypeRecord str = submitTypeRecord();
                if (!str.isOk()) {
                    // No need to log, as SubmitRuleEvaluator already did it for us.
                    return false;
                }
                String mergeStrategy = mergeUtilFactory.create(projectCache.get(project())).mergeStrategyName();
                mergeable = mergeabilityCache.get(ObjectId.fromString(ps.getRevision().get()), ref, str.type, mergeStrategy, c.getDest(), repo);
            } catch (IOException e) {
                throw new OrmException(e);
            }
        }
    }
    return mergeable;
}
#method_after
public Boolean isMergeable() throws OrmException {
    if (mergeable == null) {
        Change c = change();
        if (c == null) {
            return null;
        }
        if (c.getStatus() == Change.Status.MERGED) {
            mergeable = true;
        } else if (c.getStatus() == Change.Status.ABANDONED) {
            return null;
        } else if (c.isWorkInProgress()) {
            return null;
        } else {
            if (!lazyLoad) {
                return null;
            }
            PatchSet ps = currentPatchSet();
            try {
                if (ps == null || !changeControl().isPatchVisible(ps, db)) {
                    return null;
                }
            } catch (OrmException e) {
                if (e.getCause() instanceof NoSuchChangeException) {
                    return null;
                }
                throw e;
            }
            try (Repository repo = repoManager.openRepository(project())) {
                Ref ref = repo.getRefDatabase().exactRef(c.getDest().get());
                SubmitTypeRecord str = submitTypeRecord();
                if (!str.isOk()) {
                    // No need to log, as SubmitRuleEvaluator already did it for us.
                    return false;
                }
                String mergeStrategy = mergeUtilFactory.create(projectCache.get(project())).mergeStrategyName();
                mergeable = mergeabilityCache.get(ObjectId.fromString(ps.getRevision().get()), ref, str.type, mergeStrategy, c.getDest(), repo);
            } catch (IOException e) {
                throw new OrmException(e);
            }
        }
    }
    return mergeable;
}
#end_block

#method_before
private ChangeSet completeChangeSetWithoutTopic(ReviewDb db, ChangeSet changes, CurrentUser user) throws IOException, OrmException, PermissionBackendException {
    Collection<ChangeData> visibleChanges = new ArrayList<>();
    Collection<ChangeData> nonVisibleChanges = new ArrayList<>();
    // For each target branch we run a separate rev walk to find open changes
    // reachable from changes already in the merge super set.
    ImmutableListMultimap<Branch.NameKey, ChangeData> bc = byBranch(Iterables.concat(changes.changes(), changes.nonVisibleChanges()));
    for (Branch.NameKey b : bc.keySet()) {
        OpenRepo or = getRepo(b.getParentKey());
        List<RevCommit> visibleCommits = new ArrayList<>();
        List<RevCommit> nonVisibleCommits = new ArrayList<>();
        for (ChangeData cd : bc.get(b)) {
            boolean visible = changes.ids().contains(cd.getId());
            if (visible && !canRead(db, user, cd)) {
                // We thought the change was visible, but it isn't.
                // This can happen if the ACL changes during the
                // completeChangeSet computation, for example.
                visible = false;
            }
            Collection<RevCommit> toWalk = visible ? visibleCommits : nonVisibleCommits;
            // Pick a revision to use for traversal.  If any of the patch sets
            // is visible, we use the most recent one.  Otherwise, use the current
            // patch set.
            PatchSet ps = cd.currentPatchSet();
            boolean visiblePatchSet = visible;
            ChangeControl ctl = changeControlFactory.controlFor(cd.notes(), user);
            if (!ctl.isPatchVisible(ps, cd)) {
                Iterable<PatchSet> visiblePatchSets = ctl.getVisiblePatchSets(cd.patchSets(), db);
                if (Iterables.isEmpty(visiblePatchSets)) {
                    visiblePatchSet = false;
                } else {
                    ps = Iterables.getLast(visiblePatchSets);
                }
            }
            if (submitType(user, cd, ps, visiblePatchSet) == SubmitType.CHERRY_PICK) {
                if (visible) {
                    visibleChanges.add(cd);
                } else {
                    nonVisibleChanges.add(cd);
                }
                continue;
            }
            // Get the underlying git commit object
            String objIdStr = ps.getRevision().get();
            RevCommit commit = or.rw.parseCommit(ObjectId.fromString(objIdStr));
            // Always include the input, even if merged. This allows
            // SubmitStrategyOp to correct the situation later, assuming it gets
            // returned by byCommitsOnBranchNotMerged below.
            toWalk.add(commit);
        }
        Set<String> emptySet = Collections.emptySet();
        Set<String> visibleHashes = walkChangesByHashes(visibleCommits, emptySet, or, b);
        List<ChangeData> cds = byCommitsOnBranchNotMerged(or, db, b, visibleHashes);
        for (ChangeData chd : cds) {
            visibleChanges.add(chd);
        }
        Set<String> nonVisibleHashes = walkChangesByHashes(nonVisibleCommits, visibleHashes, or, b);
        Iterables.addAll(nonVisibleChanges, byCommitsOnBranchNotMerged(or, db, b, nonVisibleHashes));
    }
    return new ChangeSet(visibleChanges, nonVisibleChanges);
}
#method_after
private ChangeSet completeChangeSetWithoutTopic(ReviewDb db, ChangeSet changes, CurrentUser user) throws IOException, OrmException, PermissionBackendException {
    Collection<ChangeData> visibleChanges = new ArrayList<>();
    Collection<ChangeData> nonVisibleChanges = new ArrayList<>();
    // For each target branch we run a separate rev walk to find open changes
    // reachable from changes already in the merge super set.
    ImmutableListMultimap<Branch.NameKey, ChangeData> bc = byBranch(Iterables.concat(changes.changes(), changes.nonVisibleChanges()));
    for (Branch.NameKey b : bc.keySet()) {
        OpenRepo or = getRepo(b.getParentKey());
        List<RevCommit> visibleCommits = new ArrayList<>();
        List<RevCommit> nonVisibleCommits = new ArrayList<>();
        for (ChangeData cd : bc.get(b)) {
            boolean visible = changes.ids().contains(cd.getId());
            if (visible && !canRead(db, user, cd)) {
                // We thought the change was visible, but it isn't.
                // This can happen if the ACL changes during the
                // completeChangeSet computation, for example.
                visible = false;
            }
            // Pick a revision to use for traversal.  If any of the patch sets
            // is visible, we use the most recent one.  Otherwise, use the current
            // patch set.
            PatchSet ps = cd.currentPatchSet();
            boolean visiblePatchSet = visible;
            ChangeControl ctl = changeControlFactory.controlFor(cd.notes(), user);
            if (!ctl.isPatchVisible(ps, cd)) {
                Iterable<PatchSet> visiblePatchSets = ctl.getVisiblePatchSets(cd.patchSets(), db);
                if (Iterables.isEmpty(visiblePatchSets)) {
                    visiblePatchSet = false;
                } else {
                    ps = Iterables.getLast(visiblePatchSets);
                }
            }
            if (submitType(user, cd, ps, visiblePatchSet) == SubmitType.CHERRY_PICK) {
                if (visible) {
                    visibleChanges.add(cd);
                } else {
                    nonVisibleChanges.add(cd);
                }
                continue;
            }
            // Get the underlying git commit object
            String objIdStr = ps.getRevision().get();
            RevCommit commit = or.rw.parseCommit(ObjectId.fromString(objIdStr));
            // returned by byCommitsOnBranchNotMerged below.
            if (visible) {
                visibleCommits.add(commit);
            } else {
                nonVisibleCommits.add(commit);
            }
        }
        Set<String> visibleHashes = walkChangesByHashes(visibleCommits, Collections.emptySet(), or, b);
        Iterables.addAll(visibleChanges, byCommitsOnBranchNotMerged(or, db, b, visibleHashes));
        Set<String> nonVisibleHashes = walkChangesByHashes(nonVisibleCommits, visibleHashes, or, b);
        Iterables.addAll(nonVisibleChanges, byCommitsOnBranchNotMerged(or, db, b, nonVisibleHashes));
    }
    return new ChangeSet(visibleChanges, nonVisibleChanges);
}
#end_block

#method_before
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, Optional.empty());
            } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | PermissionBackendException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#method_after
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, Optional.empty());
            } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | PermissionBackendException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else if (e instanceof NoSuchChangeException) {
                    log.info("NoSuchChangeException: Omitting corrupt change " + cd.getId() + " from results. Seems to be stale in the index.");
                    continue;
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException, PermissionBackendException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.notes(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    PermissionBackend.WithUser withUser = permissionBackend.user(user).database(db);
    PermissionBackend.ForChange perm = lazyLoad ? withUser.change(cd) : withUser.indexedChange(cd, notesFactory.createFromIndexedChange(cd.change()));
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate() ? true : null;
    out.workInProgress = in.isWorkInProgress() ? true : null;
    out.hasReviewStarted = in.hasReviewStarted();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        out.muted = stars.contains(StarredChangesUtil.MUTE_LABEL + "/" + cd.currentPatchSet().getPatchSetId()) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        if (out.muted != null) {
            out.reviewed = true;
        } else {
            out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
        }
    }
    out.labels = labelsFor(perm, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (user.isIdentifiedUser() && (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId()))) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(perm, cd) : ImmutableMap.of();
        }
        out.reviewers = reviewerMap(cd.reviewers(), cd.reviewersByEmail(), false);
        out.pendingReviewers = reviewerMap(cd.pendingReviewers(), cd.pendingReviewersByEmail(), true);
        out.removableReviewers = removableReviewers(cd, out);
    }
    setSubmitter(cd, out);
    out.plugins = pluginDefinedAttributesFactory != null ? pluginDefinedAttributesFactory.create(cd) : null;
    out.revertOf = cd.change().getRevertOf() != null ? cd.change().getRevertOf().get() : null;
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(cd, src);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(cd, src, limitToPsId, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, cd.notes());
    }
    if (has(TRACKING_IDS)) {
        ListMultimap<String, String> set = trackingFooters.extract(cd.commitFooters());
        out.trackingIds = set.entries().stream().map(e -> new TrackingIdInfo(e.getKey(), e.getValue())).collect(toList());
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException, PermissionBackendException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.notes(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    PermissionBackend.WithUser withUser = permissionBackend.user(user).database(db);
    PermissionBackend.ForChange perm = lazyLoad ? withUser.change(cd) : withUser.indexedChange(cd, notesFactory.createFromIndexedChange(cd.change()));
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate() ? true : null;
    out.workInProgress = in.isWorkInProgress() ? true : null;
    out.hasReviewStarted = in.hasReviewStarted();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        out.muted = stars.contains(StarredChangesUtil.MUTE_LABEL + "/" + cd.currentPatchSet().getPatchSetId()) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        if (out.muted != null) {
            out.reviewed = true;
        } else {
            out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
        }
    }
    out.labels = labelsFor(perm, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (user.isIdentifiedUser() && (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId()))) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(perm, cd) : ImmutableMap.of();
        }
        out.reviewers = reviewerMap(cd.reviewers(), cd.reviewersByEmail(), false);
        out.pendingReviewers = reviewerMap(cd.pendingReviewers(), cd.pendingReviewersByEmail(), true);
        out.removableReviewers = removableReviewers(cd, out);
    }
    setSubmitter(cd, out);
    out.plugins = pluginDefinedAttributesFactory != null ? pluginDefinedAttributesFactory.create(cd) : null;
    out.revertOf = cd.change().getRevertOf() != null ? cd.change().getRevertOf().get() : null;
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    ChangeControl ctl = null;
    if (needMessages || needRevisions) {
        ctl = changeControlFactory.controlFor(db.get(), cd.change(), userProvider.get());
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src, limitToPsId, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, cd.notes());
    }
    if (has(TRACKING_IDS)) {
        ListMultimap<String, String> set = trackingFooters.extract(cd.commitFooters());
        out.trackingIds = set.entries().stream().map(e -> new TrackingIdInfo(e.getKey(), e.getValue())).collect(toList());
    }
    return out;
}
#end_block

#method_before
private Map<String, Short> currentLabels(PermissionBackend.ForChange perm, ChangeData cd) throws OrmException {
    IdentifiedUser user = perm.user().asIdentifiedUser();
    Map<String, Short> result = new HashMap<>();
    for (PatchSetApproval psa : approvalsUtil.byPatchSetUser(db.get(), cd.notes(), user, cd.change().currentPatchSetId(), user.getAccountId(), null, null)) {
        result.put(psa.getLabel(), psa.getValue());
    }
    return result;
}
#method_after
private Map<String, Short> currentLabels(PermissionBackend.ForChange perm, ChangeData cd) throws OrmException {
    IdentifiedUser user = perm.user().asIdentifiedUser();
    Map<String, Short> result = new HashMap<>();
    for (PatchSetApproval psa : approvalsUtil.byPatchSetUser(db.get(), lazyLoad ? cd.notes() : notesFactory.createFromIndexedChange(cd.change()), user, cd.change().currentPatchSetId(), user.getAccountId(), null, null)) {
        result.put(psa.getLabel(), psa.getValue());
    }
    return result;
}
#end_block

#method_before
private Collection<ChangeMessageInfo> messages(ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws OrmException {
    List<ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes());
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    ChangeControl ctl = changeControlFactory.controlFor(db.get(), cd.change(), userProvider.get());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        PatchSet ps = patchNum != null ? map.get(patchNum) : null;
        if (patchNum == null || ctl.isPatchVisible(ps, db.get())) {
            ChangeMessageInfo cmi = new ChangeMessageInfo();
            cmi.id = message.getKey().get();
            cmi.author = accountLoader.get(message.getAuthor());
            cmi.date = message.getWrittenOn();
            cmi.message = message.getMessage();
            cmi.tag = message.getTag();
            cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
            Account.Id realAuthor = message.getRealAuthor();
            if (realAuthor != null) {
                cmi.realAuthor = accountLoader.get(realAuthor);
            }
            result.add(cmi);
        }
    }
    return result;
}
#method_after
private Collection<ChangeMessageInfo> messages(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws OrmException {
    List<ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes());
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        PatchSet ps = patchNum != null ? map.get(patchNum) : null;
        if (patchNum == null || ctl.isPatchVisible(ps, db.get())) {
            ChangeMessageInfo cmi = new ChangeMessageInfo();
            cmi.id = message.getKey().get();
            cmi.author = accountLoader.get(message.getAuthor());
            cmi.date = message.getWrittenOn();
            cmi.message = message.getMessage();
            cmi.tag = message.getTag();
            cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
            Account.Id realAuthor = message.getRealAuthor();
            if (realAuthor != null) {
                cmi.realAuthor = accountLoader.get(realAuthor);
            }
            result.add(cmi);
        }
    }
    return result;
}
#end_block

#method_before
private Map<String, RevisionInfo> revisions(ChangeData cd, Map<PatchSet.Id, PatchSet> map, Optional<PatchSet.Id> limitToPsId, ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    ChangeControl ctl = changeControlFactory.controlFor(db.get(), cd.change(), userProvider.get());
    try (Repository repo = openRepoIfNecessary(cd.project());
        RevWalk rw = newRevWalk(repo)) {
        for (PatchSet in : map.values()) {
            PatchSet.Id id = in.getId();
            boolean want = false;
            if (has(ALL_REVISIONS)) {
                want = true;
            } else if (limitToPsId.isPresent()) {
                want = id.equals(limitToPsId.get());
            } else {
                want = id.equals(cd.change().currentPatchSetId());
            }
            if (want && ctl.isPatchVisible(in, db.get())) {
                res.put(in.getRevision().get(), toRevisionInfo(cd, in, repo, rw, false, changeInfo));
            }
        }
        return res;
    }
}
#method_after
private Map<String, RevisionInfo> revisions(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map, Optional<PatchSet.Id> limitToPsId, ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    try (Repository repo = openRepoIfNecessary(cd.project());
        RevWalk rw = newRevWalk(repo)) {
        for (PatchSet in : map.values()) {
            PatchSet.Id id = in.getId();
            boolean want = false;
            if (has(ALL_REVISIONS)) {
                want = true;
            } else if (limitToPsId.isPresent()) {
                want = id.equals(limitToPsId.get());
            } else {
                want = id.equals(cd.change().currentPatchSetId());
            }
            if (want && ctl.isPatchVisible(in, db.get())) {
                res.put(in.getRevision().get(), toRevisionInfo(cd, in, repo, rw, false, changeInfo));
            }
        }
        return res;
    }
}
#end_block

#method_before
@Test
public void pushToPublishMagicBranchIsAllowed() throws Exception {
    // Push to "refs/publish/*" will be a synonym of "refs/for/*".
    createChange("refs/publish/master");
    PushOneCommit.Result result = pushTo("refs/publish/master");
    result.assertOkStatus();
    assertThat(result.getMessage()).endsWith("Pushing to refs/publish/* will be deprecated, use refs/for/* instead.\n");
}
#method_after
@Test
public void pushToPublishMagicBranchIsAllowed() throws Exception {
    // Push to "refs/publish/*" will be a synonym of "refs/for/*".
    createChange("refs/publish/master");
    PushOneCommit.Result result = pushTo("refs/publish/master");
    result.assertOkStatus();
    assertThat(result.getMessage()).endsWith("Pushing to refs/publish/* is deprecated, use refs/for/* instead.\n");
}
#end_block

#method_before
private void reportMessages() {
    List<CreateRequest> created = newChanges.stream().filter(r -> r.change != null).collect(toList());
    if (!created.isEmpty()) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(changeFormatter.newChange(ChangeReportFormatter.Input.builder().setChange(c.change).build()));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = replaceByChange.values().stream().filter(r -> !r.skip && r.inputCommand.getResult() == OK).sorted(comparingInt(r -> r.notes.getChangeId().get())).collect(toList());
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && (magicBranch.edit || magicBranch.draft);
        Boolean isPrivate = null;
        Boolean wip = null;
        if (magicBranch != null) {
            if (magicBranch.isPrivate) {
                isPrivate = true;
            } else if (magicBranch.removePrivate) {
                isPrivate = false;
            }
            if (magicBranch.workInProgress) {
                wip = true;
            } else if (magicBranch.ready) {
                wip = false;
            }
        }
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            if (isPrivate == null) {
                isPrivate = u.notes.getChange().isPrivate();
            }
            if (wip == null) {
                wip = u.notes.getChange().isWorkInProgress();
            }
            ChangeReportFormatter.Input input = ChangeReportFormatter.Input.builder().setChange(u.notes.getChange()).setSubject(subject).setIsEdit(edit).setIsPrivate(isPrivate).setIsWorkInProgress(wip).build();
            addMessage(changeFormatter.changeUpdated(input));
        }
        addMessage("");
    }
    // TODO: remove after migrating tools which are using this magic branch.
    if (magicBranch.publish) {
        addMessage("Pushing to refs/publish/* will be deprecated, use refs/for/* instead.");
    }
}
#method_after
private void reportMessages() {
    List<CreateRequest> created = newChanges.stream().filter(r -> r.change != null).collect(toList());
    if (!created.isEmpty()) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(changeFormatter.newChange(ChangeReportFormatter.Input.builder().setChange(c.change).build()));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = replaceByChange.values().stream().filter(r -> !r.skip && r.inputCommand.getResult() == OK).sorted(comparingInt(r -> r.notes.getChangeId().get())).collect(toList());
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && (magicBranch.edit || magicBranch.draft);
        Boolean isPrivate = null;
        Boolean wip = null;
        if (magicBranch != null) {
            if (magicBranch.isPrivate) {
                isPrivate = true;
            } else if (magicBranch.removePrivate) {
                isPrivate = false;
            }
            if (magicBranch.workInProgress) {
                wip = true;
            } else if (magicBranch.ready) {
                wip = false;
            }
        }
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            if (isPrivate == null) {
                isPrivate = u.notes.getChange().isPrivate();
            }
            if (wip == null) {
                wip = u.notes.getChange().isWorkInProgress();
            }
            ChangeReportFormatter.Input input = ChangeReportFormatter.Input.builder().setChange(u.notes.getChange()).setSubject(subject).setIsEdit(edit).setIsPrivate(isPrivate).setIsWorkInProgress(wip).build();
            addMessage(changeFormatter.changeUpdated(input));
        }
        addMessage("");
    }
    // TODO(xchangcheng): remove after migrating tools which are using this magic branch.
    if (magicBranch != null && magicBranch.publish) {
        addMessage("Pushing to refs/publish/* is deprecated, use refs/for/* instead.");
    }
}
#end_block

#method_before
public static Predicate<ProjectState> name(Project.NameKey nameKey) {
    return new ProjectPredicate(ProjectField.NAME, ProjectQueryBuilder.FIELD_NAME, nameKey.get());
}
#method_after
public static Predicate<ProjectState> name(Project.NameKey nameKey) {
    return new ProjectPredicate(ProjectField.NAME, nameKey.get());
}
#end_block

#method_before
@Override
public SiteIndexer.Result indexAll(final ProjectIndex index) {
    ProgressMonitor progress = new TextProgressMonitor(new PrintWriter(progressOut));
    progress.start(2);
    Stopwatch sw = Stopwatch.createStarted();
    List<Project.NameKey> names;
    try {
        names = collectProjects(progress);
    } catch (OrmException e) {
        log.error("Error collecting accounts", e);
        return new SiteIndexer.Result(sw, false, 0, 0);
    }
    return reindexProjects(index, names, progress);
}
#method_after
@Override
public SiteIndexer.Result indexAll(final ProjectIndex index) {
    ProgressMonitor progress = new TextProgressMonitor(new PrintWriter(progressOut));
    progress.start(2);
    Stopwatch sw = Stopwatch.createStarted();
    List<Project.NameKey> names;
    try {
        names = collectProjects(progress);
    } catch (OrmException e) {
        log.error("Error collecting projects", e);
        return new SiteIndexer.Result(sw, false, 0, 0);
    }
    return reindexProjects(index, names, progress);
}
#end_block

#method_before
private SiteIndexer.Result reindexProjects(ProjectIndex index, List<Project.NameKey> names, ProgressMonitor progress) {
    progress.beginTask("Reindexing projects", names.size());
    List<ListenableFuture<?>> futures = new ArrayList<>(names.size());
    AtomicBoolean ok = new AtomicBoolean(true);
    AtomicInteger done = new AtomicInteger();
    AtomicInteger failed = new AtomicInteger();
    Stopwatch sw = Stopwatch.createStarted();
    for (Project.NameKey name : names) {
        String desc = "project " + name;
        ListenableFuture<?> future = executor.submit(() -> {
            try {
                projectCache.evict(name);
                index.replace(projectCache.get(name));
                verboseWriter.println("Reindexed " + desc);
                done.incrementAndGet();
            } catch (Exception e) {
                failed.incrementAndGet();
                throw e;
            }
            return null;
        });
        addErrorListener(future, desc, progress, ok);
        futures.add(future);
    }
    try {
        Futures.successfulAsList(futures).get();
    } catch (ExecutionException | InterruptedException e) {
        log.error("Error waiting on account futures", e);
        return new SiteIndexer.Result(sw, false, 0, 0);
    }
    progress.endTask();
    return new SiteIndexer.Result(sw, ok.get(), done.get(), failed.get());
}
#method_after
private SiteIndexer.Result reindexProjects(ProjectIndex index, List<Project.NameKey> names, ProgressMonitor progress) {
    progress.beginTask("Reindexing projects", names.size());
    List<ListenableFuture<?>> futures = new ArrayList<>(names.size());
    AtomicBoolean ok = new AtomicBoolean(true);
    AtomicInteger done = new AtomicInteger();
    AtomicInteger failed = new AtomicInteger();
    Stopwatch sw = Stopwatch.createStarted();
    for (Project.NameKey name : names) {
        String desc = "project " + name;
        ListenableFuture<?> future = executor.submit(() -> {
            try {
                projectCache.evict(name);
                index.replace(projectCache.get(name));
                verboseWriter.println("Reindexed " + desc);
                done.incrementAndGet();
            } catch (Exception e) {
                failed.incrementAndGet();
                throw e;
            }
            return null;
        });
        addErrorListener(future, desc, progress, ok);
        futures.add(future);
    }
    try {
        Futures.successfulAsList(futures).get();
    } catch (ExecutionException | InterruptedException e) {
        log.error("Error waiting on project futures", e);
        return new SiteIndexer.Result(sw, false, 0, 0);
    }
    progress.endTask();
    return new SiteIndexer.Result(sw, ok.get(), done.get(), failed.get());
}
#end_block

#method_before
private List<Project.NameKey> collectProjects(ProgressMonitor progress) throws OrmException {
    progress.beginTask("Collecting projects", ProgressMonitor.UNKNOWN);
    List<Project.NameKey> names = new ArrayList<>();
    // there. Is getting all the name keys from projectcache the right approach?
    for (Project.NameKey nameKey : projectCache.all()) {
        names.add(nameKey);
    }
    progress.endTask();
    return names;
}
#method_after
private List<Project.NameKey> collectProjects(ProgressMonitor progress) throws OrmException {
    progress.beginTask("Collecting projects", ProgressMonitor.UNKNOWN);
    List<Project.NameKey> names = new ArrayList<>();
    for (Project.NameKey nameKey : projectCache.all()) {
        names.add(nameKey);
    }
    progress.endTask();
    return names;
}
#end_block

#method_before
@Override
public Description getDescription(ChangeResource rsrc) {
    return new UiAction.Description().setLabel("Mark as Unreviewed").setTitle("Mark the change as unreviewed to highlight it in the dashboard").setVisible(isReviewed(rsrc));
}
#method_after
@Override
public Description getDescription(ChangeResource rsrc) {
    return new UiAction.Description().setLabel("Mark Unreviewed").setTitle("Mark the change as unreviewed to highlight it in the dashboard").setVisible(isReviewed(rsrc));
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(RevisionReviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Fixes.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FIX_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(ChangeIncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "robotcomments").to(ListChangeRobotComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    get(CHANGE_KIND, "pure_revert").to(GetPureRevert.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "private").to(PostPrivate.class);
    post(CHANGE_KIND, "private.delete").to(DeletePrivateByPost.class);
    delete(CHANGE_KIND, "private").to(DeletePrivate.class);
    put(CHANGE_KIND, "ignore").to(Ignore.class);
    put(CHANGE_KIND, "unignore").to(Unignore.class);
    put(CHANGE_KIND, "reviewed").to(MarkAsReviewed.class);
    put(CHANGE_KIND, "unreviewed").to(MarkAsUnreviewed.class);
    post(CHANGE_KIND, "wip").to(SetWorkInProgress.class);
    post(CHANGE_KIND, "ready").to(SetReadyForReview.class);
    put(CHANGE_KIND, "message").to(PutMessage.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    put(REVISION_KIND, "description").to(PutDescription.class);
    get(REVISION_KIND, "description").to(GetDescription.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "reviewers").to(RevisionReviewers.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    delete(COMMENT_KIND).to(DeleteComment.class);
    post(COMMENT_KIND, "delete").to(DeleteComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "fixes").to(Fixes.class);
    post(FIX_KIND, "apply").to(ApplyFix.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(ChangeResource.Factory.class);
    factory(DeleteReviewerByEmailOp.Factory.class);
    factory(DeleteReviewerOp.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(PostReviewersOp.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(WorkInProgressOp.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(RevisionReviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Fixes.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FIX_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(ChangeIncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "robotcomments").to(ListChangeRobotComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    get(CHANGE_KIND, "pure_revert").to(GetPureRevert.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "private").to(PostPrivate.class);
    post(CHANGE_KIND, "private.delete").to(DeletePrivateByPost.class);
    delete(CHANGE_KIND, "private").to(DeletePrivate.class);
    put(CHANGE_KIND, "ignore").to(Ignore.class);
    put(CHANGE_KIND, "unignore").to(Unignore.class);
    put(CHANGE_KIND, "mute").to(Mute.class);
    put(CHANGE_KIND, "unmute").to(Unmute.class);
    put(CHANGE_KIND, "reviewed").to(MarkAsReviewed.class);
    put(CHANGE_KIND, "unreviewed").to(MarkAsUnreviewed.class);
    post(CHANGE_KIND, "wip").to(SetWorkInProgress.class);
    post(CHANGE_KIND, "ready").to(SetReadyForReview.class);
    put(CHANGE_KIND, "message").to(PutMessage.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    put(REVISION_KIND, "description").to(PutDescription.class);
    get(REVISION_KIND, "description").to(GetDescription.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "reviewers").to(RevisionReviewers.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    delete(COMMENT_KIND).to(DeleteComment.class);
    post(COMMENT_KIND, "delete").to(DeleteComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "fixes").to(Fixes.class);
    post(FIX_KIND, "apply").to(ApplyFix.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(ChangeResource.Factory.class);
    factory(DeleteReviewerByEmailOp.Factory.class);
    factory(DeleteReviewerOp.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(PostReviewersOp.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(WorkInProgressOp.Factory.class);
}
#end_block

#method_before
@Override
public void rebase() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Deprecated
@Override
public void rebase() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException, PermissionBackendException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.notes(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    PermissionBackend.WithUser withUser = permissionBackend.user(user).database(db);
    PermissionBackend.ForChange perm = lazyLoad ? withUser.change(cd) : withUser.indexedChange(cd, notesFactory.createFromIndexedChange(cd.change()));
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate() ? true : null;
    out.workInProgress = in.isWorkInProgress() ? true : null;
    out.hasReviewStarted = in.hasReviewStarted();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        out.reviewed = cd.isReviewedBy(user.getAccountId()) ? true : null;
    }
    out.labels = labelsFor(perm, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (user.isIdentifiedUser() && (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId()))) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(perm, cd) : ImmutableMap.of();
        }
        out.reviewers = reviewerMap(cd.reviewers(), cd.reviewersByEmail(), false);
        out.pendingReviewers = reviewerMap(cd.pendingReviewers(), cd.pendingReviewersByEmail(), true);
        out.removableReviewers = removableReviewers(cd, out);
    }
    setSubmitter(cd, out);
    out.plugins = pluginDefinedAttributesFactory != null ? pluginDefinedAttributesFactory.create(cd) : null;
    out.revertOf = cd.change().getRevertOf() != null ? cd.change().getRevertOf().get() : null;
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    ChangeControl ctl = null;
    if (needMessages || needRevisions) {
        ctl = changeControlFactory.controlFor(db.get(), cd.change(), userProvider.get());
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src, limitToPsId, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, cd.notes());
    }
    if (has(TRACKING_IDS)) {
        ListMultimap<String, String> set = trackingFooters.extract(cd.commitFooters());
        out.trackingIds = set.entries().stream().map(e -> new TrackingIdInfo(e.getKey(), e.getValue())).collect(toList());
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException, PermissionBackendException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.notes(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    PermissionBackend.WithUser withUser = permissionBackend.user(user).database(db);
    PermissionBackend.ForChange perm = lazyLoad ? withUser.change(cd) : withUser.indexedChange(cd, notesFactory.createFromIndexedChange(cd.change()));
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate() ? true : null;
    out.workInProgress = in.isWorkInProgress() ? true : null;
    out.hasReviewStarted = in.hasReviewStarted();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        out.muted = stars.contains(StarredChangesUtil.MUTE_LABEL + "/" + cd.currentPatchSet().getPatchSetId()) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        if (out.muted != null) {
            out.reviewed = true;
        } else {
            out.reviewed = cd.isReviewedBy(user.getAccountId()) ? true : null;
        }
    }
    out.labels = labelsFor(perm, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (user.isIdentifiedUser() && (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId()))) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(perm, cd) : ImmutableMap.of();
        }
        out.reviewers = reviewerMap(cd.reviewers(), cd.reviewersByEmail(), false);
        out.pendingReviewers = reviewerMap(cd.pendingReviewers(), cd.pendingReviewersByEmail(), true);
        out.removableReviewers = removableReviewers(cd, out);
    }
    setSubmitter(cd, out);
    out.plugins = pluginDefinedAttributesFactory != null ? pluginDefinedAttributesFactory.create(cd) : null;
    out.revertOf = cd.change().getRevertOf() != null ? cd.change().getRevertOf().get() : null;
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    ChangeControl ctl = null;
    if (needMessages || needRevisions) {
        ctl = changeControlFactory.controlFor(db.get(), cd.change(), userProvider.get());
    }
    if (needMessages) {
        out.messages = messages(ctl, cd);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src, limitToPsId, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, cd.notes());
    }
    if (has(TRACKING_IDS)) {
        ListMultimap<String, String> set = trackingFooters.extract(cd.commitFooters());
        out.trackingIds = set.entries().stream().map(e -> new TrackingIdInfo(e.getKey(), e.getValue())).collect(toList());
    }
    return out;
}
#end_block

#method_before
private Collection<ChangeMessageInfo> messages(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws OrmException {
    List<ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes());
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        PatchSet ps = patchNum != null ? map.get(patchNum) : null;
        if (patchNum == null || ctl.isPatchVisible(ps, db.get())) {
            ChangeMessageInfo cmi = new ChangeMessageInfo();
            cmi.id = message.getKey().get();
            cmi.author = accountLoader.get(message.getAuthor());
            cmi.date = message.getWrittenOn();
            cmi.message = message.getMessage();
            cmi.tag = message.getTag();
            cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
            Account.Id realAuthor = message.getRealAuthor();
            if (realAuthor != null) {
                cmi.realAuthor = accountLoader.get(realAuthor);
            }
            result.add(cmi);
        }
    }
    return result;
}
#method_after
private Collection<ChangeMessageInfo> messages(ChangeControl ctl, ChangeData cd) throws OrmException {
    List<ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes());
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        if (patchNum == null || ctl.isVisible(db.get())) {
            ChangeMessageInfo cmi = new ChangeMessageInfo();
            cmi.id = message.getKey().get();
            cmi.author = accountLoader.get(message.getAuthor());
            cmi.date = message.getWrittenOn();
            cmi.message = message.getMessage();
            cmi.tag = message.getTag();
            cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
            Account.Id realAuthor = message.getRealAuthor();
            if (realAuthor != null) {
                cmi.realAuthor = accountLoader.get(realAuthor);
            }
            result.add(cmi);
        }
    }
    return result;
}
#end_block

#method_before
private Map<String, RevisionInfo> revisions(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map, Optional<PatchSet.Id> limitToPsId, ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    try (Repository repo = openRepoIfNecessary(cd.project());
        RevWalk rw = newRevWalk(repo)) {
        for (PatchSet in : map.values()) {
            PatchSet.Id id = in.getId();
            boolean want = false;
            if (has(ALL_REVISIONS)) {
                want = true;
            } else if (limitToPsId.isPresent()) {
                want = id.equals(limitToPsId.get());
            } else {
                want = id.equals(cd.change().currentPatchSetId());
            }
            if (want && ctl.isPatchVisible(in, db.get())) {
                res.put(in.getRevision().get(), toRevisionInfo(cd, in, repo, rw, false, changeInfo));
            }
        }
        return res;
    }
}
#method_after
private Map<String, RevisionInfo> revisions(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map, Optional<PatchSet.Id> limitToPsId, ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    try (Repository repo = openRepoIfNecessary(cd.project());
        RevWalk rw = newRevWalk(repo)) {
        for (PatchSet in : map.values()) {
            PatchSet.Id id = in.getId();
            boolean want = false;
            if (has(ALL_REVISIONS)) {
                want = true;
            } else if (limitToPsId.isPresent()) {
                want = id.equals(limitToPsId.get());
            } else {
                want = id.equals(cd.change().currentPatchSetId());
            }
            if (want && ctl.isVisible(db.get())) {
                res.put(in.getRevision().get(), toRevisionInfo(cd, in, repo, rw, false, changeInfo));
            }
        }
        return res;
    }
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeData cd, PatchSet in, @Nullable Repository repo, @Nullable RevWalk rw, boolean fillCommit, @Nullable ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = cd.change();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(cd, in);
    out.kind = changeKindCache.getChangeKind(rw, repo != null ? repo.getConfig() : null, cd, in);
    out.description = in.getDescription();
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        checkState(rw != null);
        checkState(repo != null);
        Project.NameKey project = c.getProject();
        String rev = in.getRevision().get();
        RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
        rw.parseBody(commit);
        if (setCommit) {
            out.commit = toCommit(project, rw, commit, has(WEB_LINKS), fillCommit);
        }
        if (addFooters) {
            Ref ref = repo.exactRef(cd.change().getDest().get());
            RevCommit mergeTip = null;
            if (ref != null) {
                mergeTip = rw.parseCommit(ref.getObjectId());
                rw.parseBody(mergeTip);
            }
            out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCommitMessageOnSubmit(commit, mergeTip, cd.notes(), userProvider.get(), in.getId());
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
        out.files.remove(Patch.MERGE_LIST);
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(changeInfo, out, new RevisionResource(changeResourceFactory.create(cd.notes(), userProvider.get()), in));
    }
    if (gpgApi.isEnabled() && has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeData cd, PatchSet in, @Nullable Repository repo, @Nullable RevWalk rw, boolean fillCommit, @Nullable ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = cd.change();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.fetch = makeFetchMap(cd, in);
    out.kind = changeKindCache.getChangeKind(rw, repo != null ? repo.getConfig() : null, cd, in);
    out.description = in.getDescription();
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        checkState(rw != null);
        checkState(repo != null);
        Project.NameKey project = c.getProject();
        String rev = in.getRevision().get();
        RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
        rw.parseBody(commit);
        if (setCommit) {
            out.commit = toCommit(project, rw, commit, has(WEB_LINKS), fillCommit);
        }
        if (addFooters) {
            Ref ref = repo.exactRef(cd.change().getDest().get());
            RevCommit mergeTip = null;
            if (ref != null) {
                mergeTip = rw.parseCommit(ref.getObjectId());
                rw.parseBody(mergeTip);
            }
            out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCommitMessageOnSubmit(commit, mergeTip, cd.notes(), userProvider.get(), in.getId());
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
        out.files.remove(Patch.MERGE_LIST);
    }
    if (out.isCurrent && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(changeInfo, out, new RevisionResource(changeResourceFactory.create(cd.notes(), userProvider.get()), in));
    }
    if (gpgApi.isEnabled() && has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#end_block

#method_before
private Map<String, FetchInfo> makeFetchMap(ChangeData cd, PatchSet in) throws OrmException {
    Map<String, FetchInfo> r = new LinkedHashMap<>();
    ChangeControl ctl = changeControlFactory.controlFor(db.get(), cd.change(), anonymous);
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        String schemeName = e.getExportName();
        DownloadScheme scheme = e.getProvider().get();
        if (!scheme.isEnabled() || (scheme.isAuthRequired() && !userProvider.get().isIdentifiedUser())) {
            continue;
        }
        if (!scheme.isAuthSupported() && !ctl.isPatchVisible(in, db.get())) {
            continue;
        }
        String projectName = cd.project().get();
        String url = scheme.getUrl(projectName);
        String refName = in.getRefName();
        FetchInfo fetchInfo = new FetchInfo(url, refName);
        r.put(schemeName, fetchInfo);
        if (has(DOWNLOAD_COMMANDS)) {
            populateFetchMap(scheme, downloadCommands, projectName, refName, fetchInfo);
        }
    }
    return r;
}
#method_after
private Map<String, FetchInfo> makeFetchMap(ChangeData cd, PatchSet in) throws OrmException {
    Map<String, FetchInfo> r = new LinkedHashMap<>();
    ChangeControl ctl = changeControlFactory.controlFor(db.get(), cd.change(), anonymous);
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        String schemeName = e.getExportName();
        DownloadScheme scheme = e.getProvider().get();
        if (!scheme.isEnabled() || (scheme.isAuthRequired() && !userProvider.get().isIdentifiedUser())) {
            continue;
        }
        if (!scheme.isAuthSupported() && !ctl.isVisible(db.get())) {
            continue;
        }
        String projectName = cd.project().get();
        String url = scheme.getUrl(projectName);
        String refName = in.getRefName();
        FetchInfo fetchInfo = new FetchInfo(url, refName);
        r.put(schemeName, fetchInfo);
        if (has(DOWNLOAD_COMMANDS)) {
            populateFetchMap(scheme, downloadCommands, projectName, refName, fetchInfo);
        }
    }
    return r;
}
#end_block

#method_before
public Boolean isMergeable() throws OrmException {
    if (mergeable == null) {
        Change c = change();
        if (c == null) {
            return null;
        }
        if (c.getStatus() == Change.Status.MERGED) {
            mergeable = true;
        } else if (c.getStatus() == Change.Status.ABANDONED) {
            return null;
        } else if (c.isWorkInProgress()) {
            return null;
        } else {
            if (!lazyLoad) {
                return null;
            }
            PatchSet ps = currentPatchSet();
            try {
                if (ps == null || !changeControl().isPatchVisible(ps, db)) {
                    return null;
                }
            } catch (OrmException e) {
                if (e.getCause() instanceof NoSuchChangeException) {
                    return null;
                }
                throw e;
            }
            try (Repository repo = repoManager.openRepository(project())) {
                Ref ref = repo.getRefDatabase().exactRef(c.getDest().get());
                SubmitTypeRecord str = submitTypeRecord();
                if (!str.isOk()) {
                    // No need to log, as SubmitRuleEvaluator already did it for us.
                    return false;
                }
                String mergeStrategy = mergeUtilFactory.create(projectCache.get(project())).mergeStrategyName();
                mergeable = mergeabilityCache.get(ObjectId.fromString(ps.getRevision().get()), ref, str.type, mergeStrategy, c.getDest(), repo);
            } catch (IOException e) {
                throw new OrmException(e);
            }
        }
    }
    return mergeable;
}
#method_after
public Boolean isMergeable() throws OrmException {
    if (mergeable == null) {
        Change c = change();
        if (c == null) {
            return null;
        }
        if (c.getStatus() == Change.Status.MERGED) {
            mergeable = true;
        } else if (c.getStatus() == Change.Status.ABANDONED) {
            return null;
        } else if (c.isWorkInProgress()) {
            return null;
        } else {
            if (!lazyLoad) {
                return null;
            }
            PatchSet ps = currentPatchSet();
            try {
                if (ps == null || !changeControl().isVisible(db)) {
                    return null;
                }
            } catch (OrmException e) {
                if (e.getCause() instanceof NoSuchChangeException) {
                    return null;
                }
                throw e;
            }
            try (Repository repo = repoManager.openRepository(project())) {
                Ref ref = repo.getRefDatabase().exactRef(c.getDest().get());
                SubmitTypeRecord str = submitTypeRecord();
                if (!str.isOk()) {
                    // No need to log, as SubmitRuleEvaluator already did it for us.
                    return false;
                }
                String mergeStrategy = mergeUtilFactory.create(projectCache.get(project())).mergeStrategyName();
                mergeable = mergeabilityCache.get(ObjectId.fromString(ps.getRevision().get()), ref, str.type, mergeStrategy, c.getDest(), repo);
            } catch (IOException e) {
                throw new OrmException(e);
            }
        }
    }
    return mergeable;
}
#end_block

#method_before
@Test
public void defaultSearchDoesNotTouchDatabase() throws Exception {
    setApiUser(admin);
    PushOneCommit.Result r1 = createChange();
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).submit();
    createChange();
    createDraftChange();
    setApiUser(user);
    AcceptanceTestRequestScope.Context ctx = disableDb();
    try {
        assertThat(gApi.changes().query().withQuery("project:{" + project.get() + "} (status:open OR status:closed)").withOption(LABELS).withOption(DETAILED_ACCOUNTS).withOption(REVIEWED).get()).hasSize(2);
    } finally {
        enableDb(ctx);
    }
}
#method_after
@Test
public void defaultSearchDoesNotTouchDatabase() throws Exception {
    setApiUser(admin);
    PushOneCommit.Result r1 = createChange();
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).submit();
    createChange();
    setApiUser(user);
    AcceptanceTestRequestScope.Context ctx = disableDb();
    try {
        assertThat(gApi.changes().query().withQuery("project:{" + project.get() + "} (status:open OR status:closed)").withOption(LABELS).withOption(DETAILED_ACCOUNTS).withOption(REVIEWED).get()).hasSize(2);
    } finally {
        enableDb(ctx);
    }
}
#end_block

#method_before
private static String getReviewedLabel(Change change) {
    return REVIEWED_LABEL + "/" + change.currentPatchSetId().get();
}
#method_after
private static String getReviewedLabel(Change change) {
    return getReviewedLabel(change.currentPatchSetId().get());
}
#end_block

#method_before
private static String getReviewedLabel(Change change) {
    return REVIEWED_LABEL + "/" + change.currentPatchSetId().get();
}
#method_after
private static String getReviewedLabel(int ps) {
    return REVIEWED_LABEL + "/" + ps;
}
#end_block

#method_before
private static String getUnreviewedLabel(Change change) {
    return UNREVIEWED_LABEL + "/" + change.currentPatchSetId().get();
}
#method_after
private static String getUnreviewedLabel(Change change) {
    return getUnreviewedLabel(change.currentPatchSetId().get());
}
#end_block

#method_before
private static String getUnreviewedLabel(Change change) {
    return UNREVIEWED_LABEL + "/" + change.currentPatchSetId().get();
}
#method_after
private static String getUnreviewedLabel(int ps) {
    return UNREVIEWED_LABEL + "/" + ps;
}
#end_block

#method_before
public static StarRef readLabels(Repository repo, String refName) throws IOException {
    Ref ref = repo.exactRef(refName);
    if (ref == null) {
        return StarRef.MISSING;
    }
    try (ObjectReader reader = repo.newObjectReader()) {
        ObjectLoader obj = reader.open(ref.getObjectId(), Constants.OBJ_BLOB);
        return StarRef.create(ref, Splitter.on(CharMatcher.whitespace()).omitEmptyStrings().split(new String(obj.getCachedBytes(Integer.MAX_VALUE), UTF_8)));
    }
}
#method_after
private static StarRef readLabels(Repository repo, String refName) throws IOException {
    Ref ref = repo.exactRef(refName);
    if (ref == null) {
        return StarRef.MISSING;
    }
    try (ObjectReader reader = repo.newObjectReader()) {
        ObjectLoader obj = reader.open(ref.getObjectId(), Constants.OBJ_BLOB);
        return StarRef.create(ref, Splitter.on(CharMatcher.whitespace()).omitEmptyStrings().split(new String(obj.getCachedBytes(Integer.MAX_VALUE), UTF_8)));
    }
}
#end_block

#method_before
private static void checkMutuallyExclusiveLabels(Set<String> labels) throws MutuallyExclusiveLabelsException {
    if (labels.containsAll(ImmutableSet.of(DEFAULT_LABEL, IGNORE_LABEL))) {
        throw new MutuallyExclusiveLabelsException(DEFAULT_LABEL, IGNORE_LABEL);
    }
    if (labels.stream().filter(l -> l.startsWith(REVIEWED_LABEL)).findAny().isPresent() && labels.stream().filter(l -> l.startsWith(UNREVIEWED_LABEL)).findAny().isPresent()) {
        throw new MutuallyExclusiveLabelsException(REVIEWED_LABEL, UNREVIEWED_LABEL);
    }
}
#method_after
private static void checkMutuallyExclusiveLabels(Set<String> labels) throws MutuallyExclusiveLabelsException {
    if (labels.containsAll(ImmutableSet.of(DEFAULT_LABEL, IGNORE_LABEL))) {
        throw new MutuallyExclusiveLabelsException(DEFAULT_LABEL, IGNORE_LABEL);
    }
    Set<Integer> reviewedPatchSets = labels.stream().filter(l -> l.startsWith(REVIEWED_LABEL)).map(l -> Integer.valueOf(l.substring(REVIEWED_LABEL.length() + 1))).collect(toSet());
    Set<Integer> unreviewedPatchSets = labels.stream().filter(l -> l.startsWith(UNREVIEWED_LABEL)).map(l -> Integer.valueOf(l.substring(UNREVIEWED_LABEL.length() + 1))).collect(toSet());
    Optional<Integer> ps = Sets.intersection(reviewedPatchSets, unreviewedPatchSets).stream().findFirst();
    if (ps.isPresent()) {
        throw new MutuallyExclusiveLabelsException(getReviewedLabel(ps.get()), getUnreviewedLabel(ps.get()));
    }
}
#end_block

#method_before
@Override
public void publish() throws RestApiException {
    try {
        publishDraftChange.apply(change, null);
    } catch (Exception e) {
        throw asRestApiException("Cannot publish change", e);
    }
}
#method_after
@Deprecated
@Override
public void publish() throws RestApiException {
    throw new UnsupportedOperationException("draft workflow is discontinued");
}
#end_block

#method_before
@Override
public void markAsReviewed(boolean reviewed) throws RestApiException {
    // StarredChangesUtil.
    try {
        if (reviewed) {
            this.markAsReviewed.apply(change, new MarkAsReviewed.Input());
        } else {
            markAsUnreviewed.apply(change, new MarkAsUnreviewed.Input());
        }
    } catch (OrmException | IllegalLabelException e) {
        throw asRestApiException("Cannot mark change as " + (reviewed ? "reviewed" : "unreviewed"), e);
    }
}
#method_after
@Override
public void markAsReviewed(boolean reviewed) throws RestApiException {
    // StarredChangesUtil.
    try {
        if (reviewed) {
            markAsReviewed.apply(change, new MarkAsReviewed.Input());
        } else {
            markAsUnreviewed.apply(change, new MarkAsUnreviewed.Input());
        }
    } catch (OrmException | IllegalLabelException e) {
        throw asRestApiException("Cannot mark change as " + (reviewed ? "reviewed" : "unreviewed"), e);
    }
}
#end_block

#method_before
@Override
public Description getDescription(ChangeResource rsrc) {
    return new UiAction.Description().setLabel("Mark as Reviewed").setTitle("Mark the change as reviewed to unhighlight it in the dashboard").setVisible(!isReviewed(rsrc));
}
#method_after
@Override
public Description getDescription(ChangeResource rsrc) {
    return new UiAction.Description().setLabel("Mark Reviewed").setTitle("Mark the change as reviewed to unhighlight it in the dashboard").setVisible(!isReviewed(rsrc));
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    // Plugin module needs to be inserted *before* the index module.
    // There is the concept of LifecycleModule, in Gerrit's own extension
    // to Guice, which has these:
    // listener().to(SomeClassImplementingLifecycleListener.class);
    // and the start() methods of each such listener are executed in the
    // order they are declared.
    // Makes sure that PluginLoader.start() is executed before the
    // LuceneIndexModule.start() so that plugins get loaded and the respective
    // Guice modules installed so that the on-line reindexing will happen
    // with the proper classes (e.g. group backends, custom Prolog
    // predicates) and the associated rules ready to be evaluated.
    modules.add(new PluginModule());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new EventBroker.Module());
    modules.add(inMemoryTest ? new H2AccountPatchReviewStore.InMemoryModule() : new JdbcAccountPatchReviewStore.Module(config));
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new SearchingChangeCacheImpl.Module(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultPermissionBackendModule());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(cfgInjector.getInstance(MailReceiver.Module.class));
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    modules.add(new StartupChecks.Module());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, headless, slave, polyGerritDev));
            if (inMemoryTest) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    modules.add(new AccountDeactivator.Module());
    if (!slave) {
        modules.add(new ChangeCleanupRunner.Module());
    }
    modules.addAll(LibModuleLoader.loadModules(cfgInjector));
    if (migrateToNoteDb()) {
        modules.add(new OnlineNoteDbMigrator.Module());
    }
    if (testSysModule != null) {
        modules.add(testSysModule);
    }
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    // Plugin module needs to be inserted *before* the index module.
    // There is the concept of LifecycleModule, in Gerrit's own extension
    // to Guice, which has these:
    // listener().to(SomeClassImplementingLifecycleListener.class);
    // and the start() methods of each such listener are executed in the
    // order they are declared.
    // Makes sure that PluginLoader.start() is executed before the
    // LuceneIndexModule.start() so that plugins get loaded and the respective
    // Guice modules installed so that the on-line reindexing will happen
    // with the proper classes (e.g. group backends, custom Prolog
    // predicates) and the associated rules ready to be evaluated.
    modules.add(new PluginModule());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new EventBroker.Module());
    modules.add(inMemoryTest ? new InMemoryAccountPatchReviewStore.Module() : new JdbcAccountPatchReviewStore.Module(config));
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new SearchingChangeCacheImpl.Module(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultPermissionBackendModule());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(cfgInjector.getInstance(MailReceiver.Module.class));
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    modules.add(new StartupChecks.Module());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, headless, slave, polyGerritDev));
            if (inMemoryTest) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    if (!slave) {
        modules.add(new AccountDeactivator.Module());
        modules.add(new ChangeCleanupRunner.Module());
    }
    modules.addAll(LibModuleLoader.loadModules(cfgInjector));
    if (migrateToNoteDb()) {
        modules.add(new OnlineNoteDbMigrator.Module(trial));
    }
    if (testSysModule != null) {
        modules.add(testSysModule);
    }
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(BatchUpdate.module());
    install(ChangeKindCacheImpl.module());
    install(ChangeFinder.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new ExternalIdModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.AssistedFactory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(SetAssigneeSender.Factory.class);
    factory(VisibleRefFilter.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(AccountDeactivatorConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    bind(UiActions.class);
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), AssigneeChangedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), AccountIndexedListener.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), GroupIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterRefUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), ChangeMessageModifier.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), OnSubmitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ReviewerSuggestion.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), ParentWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicSet.setOf(binder(), TagWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    DynamicSet.setOf(binder(), AssigneeValidationListener.class);
    DynamicSet.setOf(binder(), ActionVisitor.class);
    DynamicMap.mapOf(binder(), MailFilter.class);
    bind(MailFilter.class).annotatedWith(Exports.named("ListMailFilter")).to(ListMailFilter.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeHasOperandFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryProcessor.ChangeAttributeFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(AbandonOp.Factory.class);
    factory(AccountValidator.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(OnSubmitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountCacheImpl.module());
    install(BatchUpdate.module());
    install(ChangeKindCacheImpl.module());
    install(ChangeFinder.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new ExternalIdModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new ReceiveCommitsModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(ChangeData.AssistedFactory.class);
    factory(ChangeJson.AssistedFactory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(SetAssigneeSender.Factory.class);
    factory(VisibleRefFilter.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    factory(SubmitRuleEvaluator.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(AccountDeactivator.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    bind(UiActions.class);
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), AssigneeChangedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), AccountIndexedListener.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), GroupIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterRefUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), ChangeMessageModifier.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), OnSubmitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ReviewerSuggestion.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), ParentWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicSet.setOf(binder(), TagWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    DynamicSet.setOf(binder(), AssigneeValidationListener.class);
    DynamicSet.setOf(binder(), ActionVisitor.class);
    DynamicMap.mapOf(binder(), MailFilter.class);
    bind(MailFilter.class).annotatedWith(Exports.named("ListMailFilter")).to(ListMailFilter.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeHasOperandFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryProcessor.ChangeAttributeFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(AbandonOp.Factory.class);
    factory(AccountMergeValidator.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(OnSubmitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
public void start() {
    if (!supportAutomaticAccountActivityUpdate) {
        return;
    }
    ScheduleConfig scheduleConfig = cfg.getScheduleConfig();
    long interval = scheduleConfig.getInterval();
    long delay = scheduleConfig.getInitialDelay();
    if (delay == MISSING_CONFIG && interval == MISSING_CONFIG) {
        log.info("Ignoring missing accountDeactivator schedule configuration");
    } else if (delay < 0 || interval <= 0) {
        log.warn(String.format("Ignoring invalid accountDeactivator schedule configuration: %s", scheduleConfig));
    } else {
        @SuppressWarnings("unused")
        Future<?> possiblyIgnoredError = queue.getDefaultQueue().scheduleAtFixedRate(deactivator, delay, interval, TimeUnit.MILLISECONDS);
    }
}
#method_after
@Override
public void start() {
    if (!supportAutomaticAccountActivityUpdate) {
        return;
    }
    long interval = scheduleConfig.getInterval();
    long delay = scheduleConfig.getInitialDelay();
    if (delay == MISSING_CONFIG && interval == MISSING_CONFIG) {
        log.info("Ignoring missing accountDeactivator schedule configuration");
    } else if (delay < 0 || interval <= 0) {
        log.warn(String.format("Ignoring invalid accountDeactivator schedule configuration: %s", scheduleConfig));
    } else {
        queue.getDefaultQueue().scheduleAtFixedRate(deactivator, delay, interval, TimeUnit.MILLISECONDS);
    }
}
#end_block

#method_before
@Override
public void run() {
    log.info("Running account deactivations.");
    try (ManualRequestContext ctx = oneOffRequestContext.open()) {
        deactivationUtil.deactivateInactiveAccounts();
    } catch (Exception e) {
        log.error("Failed to deactivate inactive accounts.", e);
    }
}
#method_after
@Override
public void run() {
    log.debug("Running account deactivations");
    try {
        int numberOfAccountsDeactivated = 0;
        for (AccountState acc : accountQueryProvider.get().query(AccountPredicates.isActive())) {
            log.debug("processing account " + acc.getUserName());
            if (acc.getUserName() != null && !realm.isActive(acc.getUserName())) {
                sif.deactivate(acc.getAccount().getId());
                log.debug("deactivated accout " + acc.getUserName());
                numberOfAccountsDeactivated++;
            }
        }
        log.info("Deactivations complete, {} account(s) were deactivated", numberOfAccountsDeactivated);
    } catch (Exception e) {
        log.error("Failed to deactivate inactive accounts " + e.getMessage(), e);
    }
}
#end_block

#method_before
default Boolean isActive(String username) throws LoginException, NamingException, AccountException {
    return true;
}
#method_after
default boolean isActive(@SuppressWarnings("unused") String username) throws LoginException, NamingException, AccountException {
    return true;
}
#end_block

#method_before
@Override
public AuthRequest authenticate(AuthRequest who) throws AccountException {
    if (config.getBoolean("ldap", "localUsernameToLowerCase", false)) {
        who.setLocalUser(who.getLocalUser().toLowerCase(Locale.US));
    }
    final String username = who.getLocalUser();
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = helper.authenticate(username, who.getPassword());
        } else {
            ctx = helper.open();
        }
        try {
            final Helper.LdapSchema schema = helper.getSchema(ctx);
            final LdapQuery.Result m = helper.findAccount(schema, ctx, username, fetchMemberOfEagerly);
            helper.updateRequestActiveStatus(schema, ctx, username, who);
            if (authConfig.getAuthType() == AuthType.LDAP && !who.isSkipAuthentication()) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                helper.authenticate(m.getDN(), who.getPassword()).close();
            }
            who.setDisplayName(apply(schema.accountFullName, m));
            who.setUserName(apply(schema.accountSshUserName, m));
            if (schema.accountEmailAddress != null) {
                who.setEmailAddress(apply(schema.accountEmailAddress, m));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // 
            if (fetchMemberOfEagerly || mandatoryGroup != null) {
                Set<AccountGroup.UUID> groups = helper.queryForGroups(ctx, username, m);
                if (mandatoryGroup != null) {
                    GroupReference mandatoryGroupRef = GroupBackends.findExactSuggestion(groupBackend, mandatoryGroup);
                    if (mandatoryGroupRef == null) {
                        throw new AccountException("Could not identify mandatory group: " + mandatoryGroup);
                    }
                    if (!groups.contains(mandatoryGroupRef.getUUID())) {
                        throw new AccountException("Not member of mandatory LDAP group: " + mandatoryGroupRef.getName());
                    }
                }
                // Regardless if we enabled fetchMemberOfEagerly, we already have the
                // groups and it would be a waste not to cache them.
                membershipCache.put(username, groups);
            }
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to authenticate user", e);
        throw new AuthenticationUnavailableException("Cannot query LDAP for account", e);
    } catch (LoginException e) {
        log.error("Cannot authenticate server via JAAS", e);
        throw new AuthenticationUnavailableException("Cannot query LDAP for account", e);
    }
}
#method_after
@Override
public AuthRequest authenticate(AuthRequest who) throws AccountException {
    if (config.getBoolean("ldap", "localUsernameToLowerCase", false)) {
        who.setLocalUser(who.getLocalUser().toLowerCase(Locale.US));
    }
    final String username = who.getLocalUser();
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = helper.authenticate(username, who.getPassword());
        } else {
            ctx = helper.open();
        }
        try {
            final Helper.LdapSchema schema = helper.getSchema(ctx);
            LdapQuery.Result m;
            who.setAuthProvidesAccountActiveStatus(true);
            try {
                m = helper.findAccount(schema, ctx, username, fetchMemberOfEagerly);
                who.setActive(true);
            } catch (NoSuchUserException e) {
                who.setActive(false);
                return who;
            }
            if (authConfig.getAuthType() == AuthType.LDAP && !who.isSkipAuthentication()) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                helper.authenticate(m.getDN(), who.getPassword()).close();
            }
            who.setDisplayName(apply(schema.accountFullName, m));
            who.setUserName(apply(schema.accountSshUserName, m));
            if (schema.accountEmailAddress != null) {
                who.setEmailAddress(apply(schema.accountEmailAddress, m));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // 
            if (fetchMemberOfEagerly || mandatoryGroup != null) {
                Set<AccountGroup.UUID> groups = helper.queryForGroups(ctx, username, m);
                if (mandatoryGroup != null) {
                    GroupReference mandatoryGroupRef = GroupBackends.findExactSuggestion(groupBackend, mandatoryGroup);
                    if (mandatoryGroupRef == null) {
                        throw new AccountException("Could not identify mandatory group: " + mandatoryGroup);
                    }
                    if (!groups.contains(mandatoryGroupRef.getUUID())) {
                        throw new AccountException("Not member of mandatory LDAP group: " + mandatoryGroupRef.getName());
                    }
                }
                // Regardless if we enabled fetchMemberOfEagerly, we already have the
                // groups and it would be a waste not to cache them.
                membershipCache.put(username, groups);
            }
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to authenticate user", e);
        throw new AuthenticationUnavailableException("Cannot query LDAP for account", e);
    } catch (LoginException e) {
        log.error("Cannot authenticate server via JAAS", e);
        throw new AuthenticationUnavailableException("Cannot query LDAP for account", e);
    }
}
#end_block

#method_before
@Override
public Boolean isActive(String username) throws NamingException, AccountException, LoginException {
    try {
        final DirContext ctx = helper.open();
        final Helper.LdapSchema schema = helper.getSchema(ctx);
        helper.findAccount(schema, ctx, username, false);
    } catch (NoSuchUserException e) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean isActive(String username) throws LoginException, NamingException, AccountException {
    try {
        DirContext ctx = helper.open();
        Helper.LdapSchema schema = helper.getSchema(ctx);
        helper.findAccount(schema, ctx, username, false);
    } catch (NoSuchUserException e) {
        return false;
    }
    return true;
}
#end_block

#method_before
public AuthResult authenticate(AuthRequest who) throws AccountException, IOException {
    IdentifiedUser user;
    who = realm.authenticate(who);
    try {
        try (ReviewDb db = schema.open()) {
            ExternalId id = externalIds.get(who.getExternalIdKey());
            if (id == null) {
                // 
                return create(db, who);
            }
            // Account exists
            Account act = byIdCache.get(id.accountId()).getAccount();
            if (supportAutomaticAccountActivityUpdate.get()) {
                user = genericUserFactory.create(act.getId());
                if (who.isActive() && !act.isActive()) {
                    try {
                        setInactiveFlag.activate(user);
                    } catch (ResourceNotFoundException e) {
                        throw new AccountException("Unable to activate account.", e);
                    }
                } else if (!who.isActive() && act.isActive()) {
                    try {
                        setInactiveFlag.deactivate(user);
                    } catch (RestApiException e) {
                        throw new AccountException("Unable to deactivate account.", e);
                    }
                }
            }
            act = byIdCache.get(id.accountId()).getAccount();
            if (!act.isActive()) {
                throw new AccountException("Authentication error, account inactive");
            }
            // return the identity to the caller.
            update(db, who, id);
            return new AuthResult(id.accountId(), who.getExternalIdKey(), false);
        }
    } catch (OrmException | ConfigInvalidException e) {
        throw new AccountException("Authentication error", e);
    }
}
#method_after
public AuthResult authenticate(AuthRequest who) throws AccountException, IOException {
    who = realm.authenticate(who);
    try {
        try (ReviewDb db = schema.open()) {
            ExternalId id = externalIds.get(who.getExternalIdKey());
            if (id == null) {
                // 
                return create(db, who);
            }
            // Account exists
            Account act = byIdCache.get(id.accountId()).getAccount();
            if (autoUpdateAccountActiveStatus && who.authProvidesAccountActiveStatus()) {
                if (who.isActive() && !act.isActive()) {
                    try {
                        setInactiveFlag.activate(act.getId());
                        act = byIdCache.get(id.accountId()).getAccount();
                    } catch (ResourceNotFoundException e) {
                        throw new AccountException("Unable to activate account " + act.getId(), e);
                    }
                } else if (!who.isActive() && act.isActive()) {
                    try {
                        setInactiveFlag.deactivate(act.getId());
                        act = byIdCache.get(id.accountId()).getAccount();
                    } catch (RestApiException e) {
                        throw new AccountException("Unable to deactivate account " + act.getId(), e);
                    }
                }
            }
            if (!act.isActive()) {
                throw new AccountException("Authentication error, account inactive");
            }
            // return the identity to the caller.
            update(who, id);
            return new AuthResult(id.accountId(), who.getExternalIdKey(), false);
        }
    } catch (OrmException | ConfigInvalidException e) {
        throw new AccountException("Authentication error", e);
    }
}
#end_block

#method_before
private void update(ReviewDb db, AuthRequest who, ExternalId extId) throws OrmException, IOException, ConfigInvalidException {
    IdentifiedUser user = userFactory.create(extId.accountId());
    Account toUpdate = null;
    // If the email address was modified by the authentication provider,
    // update our records to match the changed email.
    // 
    String newEmail = who.getEmailAddress();
    String oldEmail = extId.email();
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        if (oldEmail != null && oldEmail.equals(user.getAccount().getPreferredEmail())) {
            toUpdate = load(toUpdate, user.getAccountId(), db);
            toUpdate.setPreferredEmail(newEmail);
        }
        externalIdsUpdateFactory.create().replace(extId, ExternalId.create(extId.key(), extId.accountId(), newEmail, extId.password()));
    }
    if (!realm.allowsEdit(AccountFieldName.FULL_NAME) && !Strings.isNullOrEmpty(who.getDisplayName()) && !eq(user.getAccount().getFullName(), who.getDisplayName())) {
        toUpdate = load(toUpdate, user.getAccountId(), db);
        toUpdate.setFullName(who.getDisplayName());
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME) && who.getUserName() != null && !eq(user.getUserName(), who.getUserName())) {
        log.warn(String.format("Not changing already set username %s to %s", user.getUserName(), who.getUserName()));
    }
    if (toUpdate != null) {
        accountsUpdateFactory.create().update(db, toUpdate);
    }
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        byEmailCache.evict(oldEmail);
        byEmailCache.evict(newEmail);
    }
}
#method_after
private void update(AuthRequest who, ExternalId extId) throws OrmException, IOException, ConfigInvalidException {
    IdentifiedUser user = userFactory.create(extId.accountId());
    List<Consumer<Account>> accountUpdates = new ArrayList<>();
    // If the email address was modified by the authentication provider,
    // update our records to match the changed email.
    // 
    String newEmail = who.getEmailAddress();
    String oldEmail = extId.email();
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        if (oldEmail != null && oldEmail.equals(user.getAccount().getPreferredEmail())) {
            accountUpdates.add(a -> a.setPreferredEmail(newEmail));
        }
        externalIdsUpdateFactory.create().replace(extId, ExternalId.create(extId.key(), extId.accountId(), newEmail, extId.password()));
    }
    if (!realm.allowsEdit(AccountFieldName.FULL_NAME) && !Strings.isNullOrEmpty(who.getDisplayName()) && !eq(user.getAccount().getFullName(), who.getDisplayName())) {
        accountUpdates.add(a -> a.setFullName(who.getDisplayName()));
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME) && who.getUserName() != null && !eq(user.getUserName(), who.getUserName())) {
        log.warn(String.format("Not changing already set username %s to %s", user.getUserName(), who.getUserName()));
    }
    if (!accountUpdates.isEmpty()) {
        Account account = accountsUpdateFactory.create().update(user.getAccountId(), accountUpdates);
        if (account == null) {
            throw new OrmException("Account " + user.getAccountId() + " has been deleted");
        }
    }
}
#end_block

#method_before
private AuthResult create(ReviewDb db, AuthRequest who) throws OrmException, AccountException, IOException, ConfigInvalidException {
    Account.Id newId = new Account.Id(db.nextAccountId());
    Account account = new Account(newId, TimeUtil.nowTs());
    ExternalId extId = ExternalId.createWithEmail(who.getExternalIdKey(), newId, who.getEmailAddress());
    account.setFullName(who.getDisplayName());
    account.setPreferredEmail(extId.email());
    boolean isFirstAccount = awaitsFirstAccountCheck.getAndSet(false) && !accounts.hasAnyAccount();
    try {
        AccountsUpdate accountsUpdate = accountsUpdateFactory.create();
        accountsUpdate.upsert(db, account);
        ExternalId existingExtId = externalIds.get(extId.key());
        if (existingExtId != null && !existingExtId.accountId().equals(extId.accountId())) {
            // external ID is assigned to another account, do not overwrite
            accountsUpdate.delete(db, account);
            throw new AccountException("Cannot assign external ID \"" + extId.key().get() + "\" to account " + newId + "; external ID already in use.");
        }
        externalIdsUpdateFactory.create().upsert(extId);
    } finally {
        // If adding the account failed, it may be that it actually was the
        // first account. So we reset the 'check for first account'-guard, as
        // otherwise the first account would not get administration permissions.
        awaitsFirstAccountCheck.set(isFirstAccount);
    }
    if (isFirstAccount) {
        // This is the first user account on our site. Assume this user
        // is going to be the site's administrator and just make them that
        // to bootstrap the authentication database.
        // 
        Permission admin = projectCache.getAllProjects().getConfig().getAccessSection(AccessSection.GLOBAL_CAPABILITIES).getPermission(GlobalCapability.ADMINISTRATE_SERVER);
        AccountGroup.UUID uuid = admin.getRules().get(0).getGroup().getUUID();
        AccountGroup g = db.accountGroups().byUUID(uuid).iterator().next();
        AccountGroup.Id adminId = g.getId();
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(newId, adminId));
        auditService.dispatchAddAccountsToGroup(newId, Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (who.getUserName() != null) {
        // Only set if the name hasn't been used yet, but was given to us.
        // 
        IdentifiedUser user = userFactory.create(newId);
        try {
            changeUserNameFactory.create(user, who.getUserName()).call();
        } catch (NameAlreadyUsedException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name already in use.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (InvalidUserNameException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name does not conform.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (OrmException e) {
            String message = "Cannot assign user name";
            handleSettingUserNameFailure(db, account, extId, message, e, true);
        }
    }
    byEmailCache.evict(account.getPreferredEmail());
    realm.onCreateAccount(who, account);
    return new AuthResult(newId, extId.key(), true);
}
#method_after
private AuthResult create(ReviewDb db, AuthRequest who) throws OrmException, AccountException, IOException, ConfigInvalidException {
    Account.Id newId = new Account.Id(sequences.nextAccountId());
    ExternalId extId = ExternalId.createWithEmail(who.getExternalIdKey(), newId, who.getEmailAddress());
    boolean isFirstAccount = awaitsFirstAccountCheck.getAndSet(false) && !accounts.hasAnyAccount();
    Account account;
    try {
        AccountsUpdate accountsUpdate = accountsUpdateFactory.create();
        account = accountsUpdate.insert(newId, a -> {
            a.setFullName(who.getDisplayName());
            a.setPreferredEmail(extId.email());
        });
        ExternalId existingExtId = externalIds.get(extId.key());
        if (existingExtId != null && !existingExtId.accountId().equals(extId.accountId())) {
            // external ID is assigned to another account, do not overwrite
            accountsUpdate.delete(account);
            throw new AccountException("Cannot assign external ID \"" + extId.key().get() + "\" to account " + newId + "; external ID already in use.");
        }
        externalIdsUpdateFactory.create().upsert(extId);
    } finally {
        // If adding the account failed, it may be that it actually was the
        // first account. So we reset the 'check for first account'-guard, as
        // otherwise the first account would not get administration permissions.
        awaitsFirstAccountCheck.set(isFirstAccount);
    }
    IdentifiedUser user = userFactory.create(newId);
    if (isFirstAccount) {
        // This is the first user account on our site. Assume this user
        // is going to be the site's administrator and just make them that
        // to bootstrap the authentication database.
        // 
        Permission admin = projectCache.getAllProjects().getConfig().getAccessSection(AccessSection.GLOBAL_CAPABILITIES).getPermission(GlobalCapability.ADMINISTRATE_SERVER);
        AccountGroup.UUID uuid = admin.getRules().get(0).getGroup().getUUID();
        // The user initiated this request by logging in. -> Attribute all modifications to that user.
        GroupsUpdate groupsUpdate = groupsUpdateFactory.create(user);
        try {
            groupsUpdate.addGroupMember(db, uuid, newId);
        } catch (NoSuchGroupException e) {
            throw new AccountException(String.format("Group %s not found", uuid));
        }
    }
    if (who.getUserName() != null) {
        // 
        try {
            changeUserNameFactory.create(user, who.getUserName()).call();
        } catch (NameAlreadyUsedException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name already in use.";
            handleSettingUserNameFailure(account, extId, message, e, false);
        } catch (InvalidUserNameException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name does not conform.";
            handleSettingUserNameFailure(account, extId, message, e, false);
        } catch (OrmException e) {
            String message = "Cannot assign user name";
            handleSettingUserNameFailure(account, extId, message, e, true);
        }
    }
    realm.onCreateAccount(who, account);
    return new AuthResult(newId, extId.key(), true);
}
#end_block

#method_before
private void handleSettingUserNameFailure(ReviewDb db, Account account, ExternalId extId, String errorMessage, Exception e, boolean logException) throws AccountUserNameException, OrmException, IOException, ConfigInvalidException {
    if (logException) {
        log.error(errorMessage, e);
    } else {
        log.error(errorMessage);
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME)) {
        // setting the given user name has failed, but the realm does not
        // allow the user to manually set a user name,
        // this means we would end with an account without user name
        // (without 'username:<USERNAME>' entry in
        // account_external_ids table),
        // such an account cannot be used for uploading changes,
        // this is why the best we can do here is to fail early and cleanup
        // the database
        accountsUpdateFactory.create().delete(db, account);
        externalIdsUpdateFactory.create().delete(extId);
        throw new AccountUserNameException(errorMessage, e);
    }
}
#method_after
private void handleSettingUserNameFailure(Account account, ExternalId extId, String errorMessage, Exception e, boolean logException) throws AccountUserNameException, OrmException, IOException, ConfigInvalidException {
    if (logException) {
        log.error(errorMessage, e);
    } else {
        log.error(errorMessage);
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME)) {
        // setting the given user name has failed, but the realm does not
        // allow the user to manually set a user name,
        // this means we would end with an account without user name
        // (without 'username:<USERNAME>' external ID),
        // such an account cannot be used for uploading changes,
        // this is why the best we can do here is to fail early and cleanup
        // the database
        accountsUpdateFactory.create().delete(account);
        externalIdsUpdateFactory.create().delete(extId);
        throw new AccountUserNameException(errorMessage, e);
    }
}
#end_block

#method_before
public AuthResult link(Account.Id to, AuthRequest who) throws AccountException, OrmException, IOException, ConfigInvalidException {
    try (ReviewDb db = schema.open()) {
        ExternalId extId = externalIds.get(who.getExternalIdKey());
        if (extId != null) {
            if (!extId.accountId().equals(to)) {
                throw new AccountException("Identity in use by another account");
            }
            update(db, who, extId);
        } else {
            externalIdsUpdateFactory.create().insert(ExternalId.createWithEmail(who.getExternalIdKey(), to, who.getEmailAddress()));
            if (who.getEmailAddress() != null) {
                Account a = accounts.get(db, to);
                if (a.getPreferredEmail() == null) {
                    a.setPreferredEmail(who.getEmailAddress());
                    accountsUpdateFactory.create().update(db, a);
                }
                byEmailCache.evict(who.getEmailAddress());
            }
        }
        return new AuthResult(to, who.getExternalIdKey(), false);
    }
}
#method_after
public AuthResult link(Account.Id to, AuthRequest who) throws AccountException, OrmException, IOException, ConfigInvalidException {
    ExternalId extId = externalIds.get(who.getExternalIdKey());
    if (extId != null) {
        if (!extId.accountId().equals(to)) {
            throw new AccountException("Identity '" + extId.key().get() + "' in use by another account");
        }
        update(who, extId);
    } else {
        externalIdsUpdateFactory.create().insert(ExternalId.createWithEmail(who.getExternalIdKey(), to, who.getEmailAddress()));
        if (who.getEmailAddress() != null) {
            accountsUpdateFactory.create().update(to, a -> {
                if (a.getPreferredEmail() == null) {
                    a.setPreferredEmail(who.getEmailAddress());
                }
            });
        }
    }
    return new AuthResult(to, who.getExternalIdKey(), false);
}
#end_block

#method_before
public AuthResult unlink(Account.Id from, AuthRequest who) throws AccountException, OrmException, IOException, ConfigInvalidException {
    try (ReviewDb db = schema.open()) {
        ExternalId extId = externalIds.get(who.getExternalIdKey());
        if (extId != null) {
            if (!extId.accountId().equals(from)) {
                throw new AccountException("Identity '" + who.getExternalIdKey().get() + "' in use by another account");
            }
            externalIdsUpdateFactory.create().delete(extId);
            if (who.getEmailAddress() != null) {
                Account a = accounts.get(db, from);
                if (a.getPreferredEmail() != null && a.getPreferredEmail().equals(who.getEmailAddress())) {
                    a.setPreferredEmail(null);
                    accountsUpdateFactory.create().update(db, a);
                }
                byEmailCache.evict(who.getEmailAddress());
            }
        } else {
            throw new AccountException("Identity '" + who.getExternalIdKey().get() + "' not found");
        }
        return new AuthResult(from, who.getExternalIdKey(), false);
    }
}
#method_after
public void unlink(Account.Id from, ExternalId.Key extIdKey) throws AccountException, OrmException, IOException, ConfigInvalidException {
    unlink(from, ImmutableList.of(extIdKey));
}
#end_block

#method_before
public Boolean isActive() {
    return active;
}
#method_after
public boolean isActive() {
    return active;
}
#end_block

#method_before
@Override
public AuthRequest authenticate(AuthRequest who) throws AccountException {
    if (config.getBoolean("ldap", "localUsernameToLowerCase", false)) {
        who.setLocalUser(who.getLocalUser().toLowerCase(Locale.US));
    }
    final String username = who.getLocalUser();
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = helper.authenticate(username, who.getPassword());
        } else {
            ctx = helper.open();
        }
        try {
            final Helper.LdapSchema schema = helper.getSchema(ctx);
            final LdapQuery.Result m = helper.findAccount(schema, ctx, username, fetchMemberOfEagerly);
            helper.updateAccountActiveStatus(schema, ctx, username, who);
            if (authConfig.getAuthType() == AuthType.LDAP && !who.isSkipAuthentication()) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                helper.authenticate(m.getDN(), who.getPassword()).close();
            }
            who.setDisplayName(apply(schema.accountFullName, m));
            who.setUserName(apply(schema.accountSshUserName, m));
            if (schema.accountEmailAddress != null) {
                who.setEmailAddress(apply(schema.accountEmailAddress, m));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // 
            if (fetchMemberOfEagerly || mandatoryGroup != null) {
                Set<AccountGroup.UUID> groups = helper.queryForGroups(ctx, username, m);
                if (mandatoryGroup != null) {
                    GroupReference mandatoryGroupRef = GroupBackends.findExactSuggestion(groupBackend, mandatoryGroup);
                    if (mandatoryGroupRef == null) {
                        throw new AccountException("Could not identify mandatory group: " + mandatoryGroup);
                    }
                    if (!groups.contains(mandatoryGroupRef.getUUID())) {
                        throw new AccountException("Not member of mandatory LDAP group: " + mandatoryGroupRef.getName());
                    }
                }
                // Regardless if we enabled fetchMemberOfEagerly, we already have the
                // groups and it would be a waste not to cache them.
                membershipCache.put(username, groups);
            }
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to authenticate user", e);
        throw new AuthenticationUnavailableException("Cannot query LDAP for account", e);
    } catch (LoginException e) {
        log.error("Cannot authenticate server via JAAS", e);
        throw new AuthenticationUnavailableException("Cannot query LDAP for account", e);
    }
}
#method_after
@Override
public AuthRequest authenticate(AuthRequest who) throws AccountException {
    if (config.getBoolean("ldap", "localUsernameToLowerCase", false)) {
        who.setLocalUser(who.getLocalUser().toLowerCase(Locale.US));
    }
    final String username = who.getLocalUser();
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = helper.authenticate(username, who.getPassword());
        } else {
            ctx = helper.open();
        }
        try {
            final Helper.LdapSchema schema = helper.getSchema(ctx);
            LdapQuery.Result m;
            who.setAuthProvidesAccountActiveStatus(true);
            try {
                m = helper.findAccount(schema, ctx, username, fetchMemberOfEagerly);
                who.setActive(true);
            } catch (NoSuchUserException e) {
                who.setActive(false);
                return who;
            }
            if (authConfig.getAuthType() == AuthType.LDAP && !who.isSkipAuthentication()) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                helper.authenticate(m.getDN(), who.getPassword()).close();
            }
            who.setDisplayName(apply(schema.accountFullName, m));
            who.setUserName(apply(schema.accountSshUserName, m));
            if (schema.accountEmailAddress != null) {
                who.setEmailAddress(apply(schema.accountEmailAddress, m));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // 
            if (fetchMemberOfEagerly || mandatoryGroup != null) {
                Set<AccountGroup.UUID> groups = helper.queryForGroups(ctx, username, m);
                if (mandatoryGroup != null) {
                    GroupReference mandatoryGroupRef = GroupBackends.findExactSuggestion(groupBackend, mandatoryGroup);
                    if (mandatoryGroupRef == null) {
                        throw new AccountException("Could not identify mandatory group: " + mandatoryGroup);
                    }
                    if (!groups.contains(mandatoryGroupRef.getUUID())) {
                        throw new AccountException("Not member of mandatory LDAP group: " + mandatoryGroupRef.getName());
                    }
                }
                // Regardless if we enabled fetchMemberOfEagerly, we already have the
                // groups and it would be a waste not to cache them.
                membershipCache.put(username, groups);
            }
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to authenticate user", e);
        throw new AuthenticationUnavailableException("Cannot query LDAP for account", e);
    } catch (LoginException e) {
        log.error("Cannot authenticate server via JAAS", e);
        throw new AuthenticationUnavailableException("Cannot query LDAP for account", e);
    }
}
#end_block

#method_before
public static void tryRecursiveDelete(Path dir) {
    try {
        Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {

            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                tryDelete(file);
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult postVisitDirectory(Path dir, IOException e) throws IOException {
                tryDelete(dir);
                return FileVisitResult.CONTINUE;
            }
        });
    } catch (IOException e) {
    }
}
#method_after
public static void tryRecursiveDelete(Path dir) {
    try {
        Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {

            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                tryDelete(file);
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult postVisitDirectory(Path dir, IOException e) throws IOException {
                tryDelete(dir);
                return FileVisitResult.CONTINUE;
            }
        });
    } catch (IOException e) {
    // Intent of 'try' function is to ignore these.
    }
}
#end_block

#method_before
public static void tryDelete(Path path) {
    try {
        Files.delete(path);
    } catch (IOException e) {
    }
}
#method_after
public static void tryDelete(Path path) {
    try {
        Files.delete(path);
    } catch (IOException e) {
    // Intent of 'try' function is to ignore these.
    }
}
#end_block

#method_before
public static void unsafeRecursiveRmdir(File dir) {
    try {
        while (unsafeRmdir(dir)) {
            dir = dir.getParentFile();
        }
    } catch (IOException e) {
    }
}
#method_after
public static void unsafeRecursiveRmdir(File dir) {
    try {
        while (unsafeRmdir(dir)) {
            dir = dir.getParentFile();
        }
    } catch (IOException e) {
    // Intent of 'try' function is to ignore these.
    }
}
#end_block

#method_before
public static void throwIfNotStaleFileHandle(IOException e) throws IOException {
    if (!isStaleFileHandle(e)) {
        throw e;
    }
}
#method_after
public static <T extends Throwable> void throwIfNotStaleFileHandle(T e) throws T {
    if (!isStaleFileHandleInCausalChain(e)) {
        throw e;
    }
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    try {
        try (Repository repo = repoManager.openRepository(allUsersName)) {
            ProgressMonitor pm = new TextProgressMonitor();
            pm.beginTask("Removing \"My Drafts\" menu items", ProgressMonitor.UNKNOWN);
            for (Account.Id id : Accounts.allIds(repo)) {
                if (removeMyDrafts(repo, id)) {
                    pm.update(1);
                }
            }
            pm.endTask();
        }
    } catch (IOException | ConfigInvalidException e) {
        throw new OrmException("Removing \"My Drafts\" menu items failed", e);
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    try {
        try (Repository repo = repoManager.openRepository(allUsersName)) {
            ProgressMonitor pm = new TextProgressMonitor();
            pm.beginTask("Removing \"My Drafts\" menu items", ProgressMonitor.UNKNOWN);
            for (Account.Id id : (Iterable<Account.Id>) Accounts.readUserRefs(repo)::iterator) {
                if (removeMyDrafts(repo, id)) {
                    pm.update(1);
                }
            }
            pm.endTask();
        }
    } catch (IOException | ConfigInvalidException e) {
        throw new OrmException("Removing \"My Drafts\" menu items failed", e);
    }
}
#end_block

#method_before
private static Stream<Account.Id> readUserRefs(Repository repo) throws IOException {
    return repo.getRefDatabase().getRefs(RefNames.REFS_USERS).values().stream().map(r -> Account.Id.fromRef(r.getName())).filter(Objects::nonNull);
}
#method_after
public static Stream<Account.Id> readUserRefs(Repository repo) throws IOException {
    return repo.getRefDatabase().getRefs(RefNames.REFS_USERS).values().stream().map(r -> Account.Id.fromRef(r.getName())).filter(Objects::nonNull);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    index = new FakeChangeIndex(FakeChangeIndex.V2);
    indexes = new ChangeIndexCollection();
    indexes.setSearchIndex(index);
    queryBuilder = new FakeQueryBuilder(indexes);
    rewrite = new ChangeIndexRewriter(indexes, IndexConfig.create(0, 0, 3));
}
#method_after
@Before
public void setUp() throws Exception {
    index = new FakeChangeIndex(FakeChangeIndex.V2);
    indexes = new ChangeIndexCollection();
    indexes.setSearchIndex(index);
    queryBuilder = new FakeQueryBuilder(indexes);
    rewrite = new ChangeIndexRewriter(indexes, IndexConfig.builder().maxTerms(3).build());
}
#end_block

#method_before
@Test
public void unsupportedIndexOperator() throws Exception {
    Predicate<ChangeData> in = parse("status:merged file:a");
    assertThat(rewrite(in)).isEqualTo(query(in));
    indexes.setSearchIndex(new FakeChangeIndex(FakeChangeIndex.V1));
    Predicate<ChangeData> out = rewrite(in);
    assertThat(out).isInstanceOf(AndPredicate.class);
    assertThat(out.getChildren()).containsExactly(query(in.getChild(0)), in.getChild(1)).inOrder();
}
#method_after
@Test
public void unsupportedIndexOperator() throws Exception {
    Predicate<ChangeData> in = parse("status:merged file:a");
    assertThat(rewrite(in)).isEqualTo(query(in));
    indexes.setSearchIndex(new FakeChangeIndex(FakeChangeIndex.V1));
    exception.expect(QueryParseException.class);
    exception.expectMessage("Unsupported index predicate: file:a");
    rewrite(in);
}
#end_block

#method_before
@Override
public void review(ReviewInput in) {
    throw new NotImplementedException();
}
#method_after
@Override
public ReviewResult review(ReviewInput in) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void submit() {
    throw new NotImplementedException();
}
#method_after
@Override
public void submit() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void submit(SubmitInput in) {
    throw new NotImplementedException();
}
#method_after
@Override
public void submit(SubmitInput in) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeApi cherryPick(CherryPickInput in) {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeApi cherryPick(CherryPickInput in) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeApi rebase() {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeApi rebase() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeApi rebase(RebaseInput in) {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeApi rebase(RebaseInput in) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public boolean canRebase() {
    throw new NotImplementedException();
}
#method_after
@Override
public boolean canRebase() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public RevisionReviewerApi reviewer(String id) {
    throw new NotImplementedException();
}
#method_after
@Override
public RevisionReviewerApi reviewer(String id) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void setReviewed(String path, boolean reviewed) {
    throw new NotImplementedException();
}
#method_after
@Override
public void setReviewed(String path, boolean reviewed) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Set<String> reviewed() {
    throw new NotImplementedException();
}
#method_after
@Override
public Set<String> reviewed() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public MergeableInfo mergeable() {
    throw new NotImplementedException();
}
#method_after
@Override
public MergeableInfo mergeable() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public MergeableInfo mergeableOtherBranches() {
    throw new NotImplementedException();
}
#method_after
@Override
public MergeableInfo mergeableOtherBranches() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, FileInfo> files(String base) {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, FileInfo> files(String base) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, FileInfo> files(int parentNum) {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, FileInfo> files(int parentNum) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, FileInfo> files() {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, FileInfo> files() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> comments() {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, List<CommentInfo>> comments() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, List<RobotCommentInfo>> robotComments() {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, List<RobotCommentInfo>> robotComments() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<CommentInfo> commentsAsList() {
    throw new NotImplementedException();
}
#method_after
@Override
public List<CommentInfo> commentsAsList() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<CommentInfo> draftsAsList() {
    throw new NotImplementedException();
}
#method_after
@Override
public List<CommentInfo> draftsAsList() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<RobotCommentInfo> robotCommentsAsList() {
    throw new NotImplementedException();
}
#method_after
@Override
public List<RobotCommentInfo> robotCommentsAsList() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> drafts() {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, List<CommentInfo>> drafts() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public DraftApi createDraft(DraftInput in) {
    throw new NotImplementedException();
}
#method_after
@Override
public DraftApi createDraft(DraftInput in) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public DraftApi draft(String id) {
    throw new NotImplementedException();
}
#method_after
@Override
public DraftApi draft(String id) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public CommentApi comment(String id) {
    throw new NotImplementedException();
}
#method_after
@Override
public CommentApi comment(String id) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public RobotCommentApi robotComment(String id) {
    throw new NotImplementedException();
}
#method_after
@Override
public RobotCommentApi robotComment(String id) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public BinaryResult patch() {
    throw new NotImplementedException();
}
#method_after
@Override
public BinaryResult patch() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public BinaryResult patch(String path) {
    throw new NotImplementedException();
}
#method_after
@Override
public BinaryResult patch(String path) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, ActionInfo> actions() {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, ActionInfo> actions() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public SubmitType submitType() {
    throw new NotImplementedException();
}
#method_after
@Override
public SubmitType submitType() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public BinaryResult submitPreview() {
    throw new NotImplementedException();
}
#method_after
@Override
public BinaryResult submitPreview() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public BinaryResult submitPreview(String format) {
    throw new NotImplementedException();
}
#method_after
@Override
public BinaryResult submitPreview(String format) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public SubmitType testSubmitType(TestSubmitRuleInput in) {
    throw new NotImplementedException();
}
#method_after
@Override
public SubmitType testSubmitType(TestSubmitRuleInput in) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public MergeListRequest getMergeList() {
    throw new NotImplementedException();
}
#method_after
@Override
public MergeListRequest getMergeList() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void description(String description) {
    throw new NotImplementedException();
}
#method_after
@Override
public void description(String description) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public String description() {
    throw new NotImplementedException();
}
#method_after
@Override
public String description() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public String etag() {
    throw new NotImplementedException();
}
#method_after
@Override
public String etag() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Test
public void submitChangesAcrossRepos() throws Exception {
    Project.NameKey p1 = createProject("project-where-we-submit");
    Project.NameKey p2 = createProject("project-impacted-via-topic");
    Project.NameKey p3 = createProject("project-impacted-indirectly-via-topic");
    RevCommit initialHead2 = getRemoteHead(p2, "master");
    RevCommit initialHead3 = getRemoteHead(p3, "master");
    TestRepository<?> repo1 = cloneProject(p1);
    TestRepository<?> repo2 = cloneProject(p2);
    TestRepository<?> repo3 = cloneProject(p3);
    PushOneCommit.Result change1a = createChange(repo1, "master", "An ancestor of the change we want to submit", "a.txt", "1", "dependent-topic");
    PushOneCommit.Result change1b = createChange(repo1, "master", "We're interested in submitting this change", "a.txt", "2", "topic-to-submit");
    PushOneCommit.Result change2a = createChange(repo2, "master", "indirection level 1", "a.txt", "1", "topic-indirect");
    PushOneCommit.Result change2b = createChange(repo2, "master", "should go in with first change", "a.txt", "2", "dependent-topic");
    PushOneCommit.Result change3 = createChange(repo3, "master", "indirection level 2", "a.txt", "1", "topic-indirect");
    approve(change1a.getChangeId());
    approve(change2a.getChangeId());
    approve(change2b.getChangeId());
    approve(change3.getChangeId());
    // get a preview before submitting:
    BinaryResult request = submitPreview(change1b.getChangeId());
    Map<Branch.NameKey, RevTree> preview = fetchFromBundles(request);
    submit(change1b.getChangeId());
    RevCommit tip1 = getRemoteLog(p1, "master").get(0);
    RevCommit tip2 = getRemoteLog(p2, "master").get(0);
    RevCommit tip3 = getRemoteLog(p3, "master").get(0);
    assertThat(tip1.getShortMessage()).isEqualTo(change1b.getCommit().getShortMessage());
    if (isSubmitWholeTopicEnabled()) {
        assertThat(tip2.getShortMessage()).isEqualTo(change2b.getCommit().getShortMessage());
        assertThat(tip3.getShortMessage()).isEqualTo(change3.getCommit().getShortMessage());
        // check that the preview matched what happened:
        assertThat(preview).hasSize(3);
        assertThat(preview).containsKey(new Branch.NameKey(p1, "refs/heads/master"));
        assertRevTrees(p1, preview);
        assertThat(preview).containsKey(new Branch.NameKey(p2, "refs/heads/master"));
        assertRevTrees(p2, preview);
        assertThat(preview).containsKey(new Branch.NameKey(p3, "refs/heads/master"));
        assertRevTrees(p3, preview);
    } else {
        assertThat(tip2.getShortMessage()).isEqualTo(initialHead2.getShortMessage());
        assertThat(tip3.getShortMessage()).isEqualTo(initialHead3.getShortMessage());
        assertThat(preview).hasSize(1);
        assertThat(preview.get(new Branch.NameKey(p1, "refs/heads/master"))).isNotNull();
    }
}
#method_after
@Test
public void submitChangesAcrossRepos() throws Exception {
    Project.NameKey p1 = createProject("project-where-we-submit");
    Project.NameKey p2 = createProject("project-impacted-via-topic");
    Project.NameKey p3 = createProject("project-impacted-indirectly-via-topic");
    RevCommit initialHead2 = getRemoteHead(p2, "master");
    RevCommit initialHead3 = getRemoteHead(p3, "master");
    TestRepository<?> repo1 = cloneProject(p1);
    TestRepository<?> repo2 = cloneProject(p2);
    TestRepository<?> repo3 = cloneProject(p3);
    PushOneCommit.Result change1a = createChange(repo1, "master", "An ancestor of the change we want to submit", "a.txt", "1", "dependent-topic");
    PushOneCommit.Result change1b = createChange(repo1, "master", "We're interested in submitting this change", "a.txt", "2", "topic-to-submit");
    PushOneCommit.Result change2a = createChange(repo2, "master", "indirection level 1", "a.txt", "1", "topic-indirect");
    PushOneCommit.Result change2b = createChange(repo2, "master", "should go in with first change", "a.txt", "2", "dependent-topic");
    PushOneCommit.Result change3 = createChange(repo3, "master", "indirection level 2", "a.txt", "1", "topic-indirect");
    approve(change1a.getChangeId());
    approve(change2a.getChangeId());
    approve(change2b.getChangeId());
    approve(change3.getChangeId());
    // get a preview before submitting:
    Map<Branch.NameKey, ObjectId> preview = fetchFromSubmitPreview(change1b.getChangeId());
    submit(change1b.getChangeId());
    RevCommit tip1 = getRemoteLog(p1, "master").get(0);
    RevCommit tip2 = getRemoteLog(p2, "master").get(0);
    RevCommit tip3 = getRemoteLog(p3, "master").get(0);
    assertThat(tip1.getShortMessage()).isEqualTo(change1b.getCommit().getShortMessage());
    if (isSubmitWholeTopicEnabled()) {
        assertThat(tip2.getShortMessage()).isEqualTo(change2b.getCommit().getShortMessage());
        assertThat(tip3.getShortMessage()).isEqualTo(change3.getCommit().getShortMessage());
        // check that the preview matched what happened:
        assertThat(preview).hasSize(3);
        assertThat(preview).containsKey(new Branch.NameKey(p1, "refs/heads/master"));
        assertTrees(p1, preview);
        assertThat(preview).containsKey(new Branch.NameKey(p2, "refs/heads/master"));
        assertTrees(p2, preview);
        assertThat(preview).containsKey(new Branch.NameKey(p3, "refs/heads/master"));
        assertTrees(p3, preview);
    } else {
        assertThat(tip2.getShortMessage()).isEqualTo(initialHead2.getShortMessage());
        assertThat(tip3.getShortMessage()).isEqualTo(initialHead3.getShortMessage());
        assertThat(preview).hasSize(1);
        assertThat(preview.get(new Branch.NameKey(p1, "refs/heads/master"))).isNotNull();
    }
}
#end_block

#method_before
@Test
public void submitChangesAcrossReposBlocked() throws Exception {
    Project.NameKey p1 = createProject("project-where-we-submit");
    Project.NameKey p2 = createProject("project-impacted-via-topic");
    Project.NameKey p3 = createProject("project-impacted-indirectly-via-topic");
    TestRepository<?> repo1 = cloneProject(p1);
    TestRepository<?> repo2 = cloneProject(p2);
    TestRepository<?> repo3 = cloneProject(p3);
    RevCommit initialHead1 = getRemoteHead(p1, "master");
    RevCommit initialHead2 = getRemoteHead(p2, "master");
    RevCommit initialHead3 = getRemoteHead(p3, "master");
    PushOneCommit.Result change1a = createChange(repo1, "master", "An ancestor of the change we want to submit", "a.txt", "1", "dependent-topic");
    PushOneCommit.Result change1b = createChange(repo1, "master", "we're interested to submit this change", "a.txt", "2", "topic-to-submit");
    PushOneCommit.Result change2a = createChange(repo2, "master", "indirection level 2a", "a.txt", "1", "topic-indirect");
    PushOneCommit.Result change2b = createChange(repo2, "master", "should go in with first change", "a.txt", "2", "dependent-topic");
    PushOneCommit.Result change3 = createChange(repo3, "master", "indirection level 2b", "a.txt", "1", "topic-indirect");
    // Create a merge conflict for change3 which is only indirectly related
    // via topics.
    repo3.reset(initialHead3);
    PushOneCommit.Result change3Conflict = createChange(repo3, "master", "conflicting change", "a.txt", "2\n2", "conflicting-topic");
    submit(change3Conflict.getChangeId());
    RevCommit tipConflict = getRemoteLog(p3, "master").get(0);
    assertThat(tipConflict.getShortMessage()).isEqualTo(change3Conflict.getCommit().getShortMessage());
    approve(change1a.getChangeId());
    approve(change2a.getChangeId());
    approve(change2b.getChangeId());
    approve(change3.getChangeId());
    if (isSubmitWholeTopicEnabled()) {
        String msg = "Failed to submit 5 changes due to the following problems:\n" + "Change " + change3.getChange().getId() + ": Change could not be " + "merged due to a path conflict. Please rebase the change locally " + "and upload the rebased commit for review.";
        // Get a preview before submitting:
        try {
            // We cannot just use the ExpectedException infrastructure as provided
            // by AbstractDaemonTest, as then we'd stop early and not test the
            // actual submit.
            submitPreview(change1b.getChangeId());
            fail("expected failure");
        } catch (RestApiException e) {
            assertThat(e.getMessage()).isEqualTo(msg);
        }
        submitWithConflict(change1b.getChangeId(), msg);
    } else {
        submit(change1b.getChangeId());
    }
    RevCommit tip1 = getRemoteLog(p1, "master").get(0);
    RevCommit tip2 = getRemoteLog(p2, "master").get(0);
    RevCommit tip3 = getRemoteLog(p3, "master").get(0);
    if (isSubmitWholeTopicEnabled()) {
        assertThat(tip1.getShortMessage()).isEqualTo(initialHead1.getShortMessage());
        assertThat(tip2.getShortMessage()).isEqualTo(initialHead2.getShortMessage());
        assertThat(tip3.getShortMessage()).isEqualTo(change3Conflict.getCommit().getShortMessage());
        assertNoSubmitter(change1a.getChangeId(), 1);
        assertNoSubmitter(change2a.getChangeId(), 1);
        assertNoSubmitter(change2b.getChangeId(), 1);
        assertNoSubmitter(change3.getChangeId(), 1);
    } else {
        assertThat(tip1.getShortMessage()).isEqualTo(change1b.getCommit().getShortMessage());
        assertThat(tip2.getShortMessage()).isEqualTo(initialHead2.getShortMessage());
        assertThat(tip3.getShortMessage()).isEqualTo(change3Conflict.getCommit().getShortMessage());
        assertNoSubmitter(change2a.getChangeId(), 1);
        assertNoSubmitter(change2b.getChangeId(), 1);
        assertNoSubmitter(change3.getChangeId(), 1);
    }
}
#method_after
@Test
public void submitChangesAcrossReposBlocked() throws Exception {
    Project.NameKey p1 = createProject("project-where-we-submit");
    Project.NameKey p2 = createProject("project-impacted-via-topic");
    Project.NameKey p3 = createProject("project-impacted-indirectly-via-topic");
    TestRepository<?> repo1 = cloneProject(p1);
    TestRepository<?> repo2 = cloneProject(p2);
    TestRepository<?> repo3 = cloneProject(p3);
    RevCommit initialHead1 = getRemoteHead(p1, "master");
    RevCommit initialHead2 = getRemoteHead(p2, "master");
    RevCommit initialHead3 = getRemoteHead(p3, "master");
    PushOneCommit.Result change1a = createChange(repo1, "master", "An ancestor of the change we want to submit", "a.txt", "1", "dependent-topic");
    PushOneCommit.Result change1b = createChange(repo1, "master", "we're interested to submit this change", "a.txt", "2", "topic-to-submit");
    PushOneCommit.Result change2a = createChange(repo2, "master", "indirection level 2a", "a.txt", "1", "topic-indirect");
    PushOneCommit.Result change2b = createChange(repo2, "master", "should go in with first change", "a.txt", "2", "dependent-topic");
    PushOneCommit.Result change3 = createChange(repo3, "master", "indirection level 2b", "a.txt", "1", "topic-indirect");
    // Create a merge conflict for change3 which is only indirectly related
    // via topics.
    repo3.reset(initialHead3);
    PushOneCommit.Result change3Conflict = createChange(repo3, "master", "conflicting change", "a.txt", "2\n2", "conflicting-topic");
    submit(change3Conflict.getChangeId());
    RevCommit tipConflict = getRemoteLog(p3, "master").get(0);
    assertThat(tipConflict.getShortMessage()).isEqualTo(change3Conflict.getCommit().getShortMessage());
    approve(change1a.getChangeId());
    approve(change2a.getChangeId());
    approve(change2b.getChangeId());
    approve(change3.getChangeId());
    if (isSubmitWholeTopicEnabled()) {
        String msg = "Failed to submit 5 changes due to the following problems:\n" + "Change " + change3.getChange().getId() + ": Change could not be " + "merged due to a path conflict. Please rebase the change locally " + "and upload the rebased commit for review.";
        // Get a preview before submitting:
        try (BinaryResult r = submitPreview(change1b.getChangeId())) {
            // We cannot just use the ExpectedException infrastructure as provided
            // by AbstractDaemonTest, as then we'd stop early and not test the
            // actual submit.
            fail("expected failure");
        } catch (RestApiException e) {
            assertThat(e.getMessage()).isEqualTo(msg);
        }
        submitWithConflict(change1b.getChangeId(), msg);
    } else {
        submit(change1b.getChangeId());
    }
    RevCommit tip1 = getRemoteLog(p1, "master").get(0);
    RevCommit tip2 = getRemoteLog(p2, "master").get(0);
    RevCommit tip3 = getRemoteLog(p3, "master").get(0);
    if (isSubmitWholeTopicEnabled()) {
        assertThat(tip1.getShortMessage()).isEqualTo(initialHead1.getShortMessage());
        assertThat(tip2.getShortMessage()).isEqualTo(initialHead2.getShortMessage());
        assertThat(tip3.getShortMessage()).isEqualTo(change3Conflict.getCommit().getShortMessage());
        assertNoSubmitter(change1a.getChangeId(), 1);
        assertNoSubmitter(change2a.getChangeId(), 1);
        assertNoSubmitter(change2b.getChangeId(), 1);
        assertNoSubmitter(change3.getChangeId(), 1);
    } else {
        assertThat(tip1.getShortMessage()).isEqualTo(change1b.getCommit().getShortMessage());
        assertThat(tip2.getShortMessage()).isEqualTo(initialHead2.getShortMessage());
        assertThat(tip3.getShortMessage()).isEqualTo(change3Conflict.getCommit().getShortMessage());
        assertNoSubmitter(change2a.getChangeId(), 1);
        assertNoSubmitter(change2b.getChangeId(), 1);
        assertNoSubmitter(change3.getChangeId(), 1);
    }
}
#end_block

#method_before
@Test
public void submitWithOpenAncestorsOnOtherBranch() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change1 = createChange(testRepo, "master", "base commit", "a.txt", "1", "");
    submit(change1.getChangeId());
    RevCommit headAfterFirstSubmit = getRemoteHead();
    gApi.projects().name(project.get()).branch("branch").create(new BranchInput());
    PushOneCommit.Result change2 = createChange(testRepo, "master", "We want to commit this to master first", "a.txt", "2", "");
    approve(change2.getChangeId());
    RevCommit tip1 = getRemoteLog(project, "master").get(0);
    assertThat(tip1.getShortMessage()).isEqualTo(change1.getCommit().getShortMessage());
    RevCommit tip2 = getRemoteLog(project, "branch").get(0);
    assertThat(tip2.getShortMessage()).isEqualTo(change1.getCommit().getShortMessage());
    PushOneCommit.Result change3a = createChange(testRepo, "branch", "This commit is based on change2 pending for master, " + "but is targeted itself at branch, which doesn't include it.", "a.txt", "3", "a-topic-here");
    Project.NameKey p3 = createProject("project-related-to-change3");
    TestRepository<?> repo3 = cloneProject(p3);
    RevCommit repo3Head = getRemoteHead(p3, "master");
    PushOneCommit.Result change3b = createChange(repo3, "master", "some accompanying changes for change3a in another repo " + "tied together via topic", "a.txt", "1", "a-topic-here");
    approve(change3b.getChangeId());
    String cnt = isSubmitWholeTopicEnabled() ? "2 changes" : "1 change";
    submitWithConflict(change3a.getChangeId(), "Failed to submit " + cnt + " due to the following problems:\n" + "Change " + change3a.getChange().getId() + ": depends on change that" + " was not submitted");
    RevCommit tipbranch = getRemoteLog(project, "branch").get(0);
    assertThat(tipbranch.getShortMessage()).isEqualTo(change1.getCommit().getShortMessage());
    RevCommit tipmaster = getRemoteLog(p3, "master").get(0);
    assertThat(tipmaster.getShortMessage()).isEqualTo(repo3Head.getShortMessage());
    assertRefUpdatedEvents(initialHead, headAfterFirstSubmit);
    assertChangeMergedEvents(change1.getChangeId(), headAfterFirstSubmit.name());
}
#method_after
@Test
public void submitWithOpenAncestorsOnOtherBranch() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change1 = createChange(testRepo, "master", "base commit", "a.txt", "1", "");
    submit(change1.getChangeId());
    RevCommit headAfterFirstSubmit = getRemoteHead();
    gApi.projects().name(project.get()).branch("branch").create(new BranchInput());
    PushOneCommit.Result change2 = createChange(testRepo, "master", "We want to commit this to master first", "a.txt", "2", "");
    approve(change2.getChangeId());
    RevCommit tip1 = getRemoteLog(project, "master").get(0);
    assertThat(tip1.getShortMessage()).isEqualTo(change1.getCommit().getShortMessage());
    RevCommit tip2 = getRemoteLog(project, "branch").get(0);
    assertThat(tip2.getShortMessage()).isEqualTo(change1.getCommit().getShortMessage());
    PushOneCommit.Result change3a = createChange(testRepo, "branch", "This commit is based on change2 pending for master, " + "but is targeted itself at branch, which doesn't include it.", "a.txt", "3", "a-topic-here");
    Project.NameKey p3 = createProject("project-related-to-change3");
    TestRepository<?> repo3 = cloneProject(p3);
    RevCommit repo3Head = getRemoteHead(p3, "master");
    PushOneCommit.Result change3b = createChange(repo3, "master", "some accompanying changes for change3a in another repo tied together via topic", "a.txt", "1", "a-topic-here");
    approve(change3b.getChangeId());
    String cnt = isSubmitWholeTopicEnabled() ? "2 changes" : "1 change";
    submitWithConflict(change3a.getChangeId(), "Failed to submit " + cnt + " due to the following problems:\n" + "Change " + change3a.getChange().getId() + ": depends on change that" + " was not submitted");
    RevCommit tipbranch = getRemoteLog(project, "branch").get(0);
    assertThat(tipbranch.getShortMessage()).isEqualTo(change1.getCommit().getShortMessage());
    RevCommit tipmaster = getRemoteLog(p3, "master").get(0);
    assertThat(tipmaster.getShortMessage()).isEqualTo(repo3Head.getShortMessage());
    assertRefUpdatedEvents(initialHead, headAfterFirstSubmit);
    assertChangeMergedEvents(change1.getChangeId(), headAfterFirstSubmit.name());
}
#end_block

#method_before
@Test
public void testPreviewSubmitTgz() throws Exception {
    Project.NameKey p1 = createProject("project-name");
    TestRepository<?> repo1 = cloneProject(p1);
    PushOneCommit.Result change1 = createChange(repo1, "master", "test", "a.txt", "1", "topic");
    approve(change1.getChangeId());
    // get a preview before submitting:
    BinaryResult request = submitPreview(change1.getChangeId(), "tgz");
    assertThat(request.getContentType()).isEqualTo("application/x-gzip");
    File tempfile = File.createTempFile("test", null);
    request.writeTo(new FileOutputStream(tempfile));
    InputStream is = new GZIPInputStream(new FileInputStream(tempfile));
    List<String> untarredFiles = new ArrayList<>();
    try (TarArchiveInputStream tarInputStream = (TarArchiveInputStream) new ArchiveStreamFactory().createArchiveInputStream("tar", is)) {
        TarArchiveEntry entry = null;
        while ((entry = (TarArchiveEntry) tarInputStream.getNextEntry()) != null) {
            untarredFiles.add(entry.getName());
        }
    }
    assertThat(untarredFiles).containsExactly(name("project-name") + ".git");
}
#method_after
@Test
public void testPreviewSubmitTgz() throws Exception {
    Project.NameKey p1 = createProject("project-name");
    TestRepository<?> repo1 = cloneProject(p1);
    PushOneCommit.Result change1 = createChange(repo1, "master", "test", "a.txt", "1", "topic");
    approve(change1.getChangeId());
    // get a preview before submitting:
    File tempfile;
    try (BinaryResult request = submitPreview(change1.getChangeId(), "tgz")) {
        assertThat(request.getContentType()).isEqualTo("application/x-gzip");
        tempfile = File.createTempFile("test", null);
        request.writeTo(Files.newOutputStream(tempfile.toPath()));
    }
    InputStream is = new GZIPInputStream(Files.newInputStream(tempfile.toPath()));
    List<String> untarredFiles = new ArrayList<>();
    try (TarArchiveInputStream tarInputStream = (TarArchiveInputStream) new ArchiveStreamFactory().createArchiveInputStream("tar", is)) {
        TarArchiveEntry entry = null;
        while ((entry = (TarArchiveEntry) tarInputStream.getNextEntry()) != null) {
            untarredFiles.add(entry.getName());
        }
    }
    assertThat(untarredFiles).containsExactly(name("project-name") + ".git");
}
#end_block

#method_before
public PatchSetInserter setNotify(NotifyHandling notify) {
    this.notify = notify;
    return this;
}
#method_after
public PatchSetInserter setNotify(NotifyHandling notify) {
    this.notify = Preconditions.checkNotNull(notify);
    return this;
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws AuthException, ResourceConflictException, IOException, OrmException {
    validate(ctx);
    ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commit, getPatchSetId().toRefName(), ReceiveCommand.Type.CREATE));
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws AuthException, ResourceConflictException, IOException, OrmException, PermissionBackendException {
    validate(ctx);
    ctx.addRefUpdate(ObjectId.zeroId(), commitId, getPatchSetId().toRefName());
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceConflictException, OrmException, IOException {
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setSubjectForCommit("Create patch set " + psId.get());
    if (!change.getStatus().isOpen() && !allowClosed) {
        throw new ResourceConflictException(String.format("Cannot create new patch set of change %s because it is %s", change.getId(), change.getStatus().name().toLowerCase()));
    }
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        PatchSet prevPs = psUtil.current(db, ctx.getNotes());
        if (prevPs != null) {
            newGroups = prevPs.getGroups();
        }
    }
    patchSet = psUtil.insert(db, ctx.getRevWalk(), ctx.getUpdate(psId), psId, commit, newGroups, null, description);
    if (notify != NotifyHandling.NONE) {
        oldReviewers = approvalsUtil.getReviewers(db, ctl.getNotes());
    }
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(patchSet.getId(), ctx.getUser(), ctx.getWhen(), message, ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
        changeMessage.setMessage(message);
    }
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    if (!allowClosed) {
        change.setStatus(Change.Status.NEW);
    }
    change.setCurrentPatchSet(patchSetInfo);
    if (copyApprovals) {
        approvalCopier.copy(db, ctl, patchSet);
    }
    if (changeMessage != null) {
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceConflictException, OrmException, IOException {
    ReviewDb db = ctx.getDb();
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setSubjectForCommit("Create patch set " + psId.get());
    if (!change.getStatus().isOpen() && !allowClosed) {
        throw new ResourceConflictException(String.format("Cannot create new patch set of change %s because it is %s", change.getId(), ChangeUtil.status(change)));
    }
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        PatchSet prevPs = psUtil.current(db, ctx.getNotes());
        if (prevPs != null) {
            newGroups = prevPs.getGroups();
        }
    }
    patchSet = psUtil.insert(db, ctx.getRevWalk(), ctx.getUpdate(psId), psId, commitId, newGroups, null, description);
    if (notify != NotifyHandling.NONE) {
        oldReviewers = approvalsUtil.getReviewers(db, ctx.getNotes());
    }
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(patchSet.getId(), ctx.getUser(), ctx.getWhen(), message, ChangeMessagesUtil.uploadedPatchSetTag(change.isWorkInProgress()));
        changeMessage.setMessage(message);
    }
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), ctx.getRevWalk().parseCommit(commitId), psId);
    if (!allowClosed) {
        change.setStatus(Change.Status.NEW);
    }
    change.setCurrentPatchSet(patchSetInfo);
    if (copyApprovals) {
        approvalCopier.copyInReviewDb(db, ctx.getNotes(), ctx.getUser(), patchSet, ctx.getRevWalk(), ctx.getRepoView().getConfig());
    }
    if (changeMessage != null) {
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
private void validate(RepoContext ctx) throws AuthException, ResourceConflictException, IOException, OrmException {
    if (checkAddPatchSetPermission && !origCtl.canAddPatchSet(ctx.getDb())) {
        throw new AuthException("cannot add patch set");
    }
    if (validatePolicy == CommitValidators.Policy.NONE) {
        return;
    }
    String refName = getPatchSetId().toRefName();
    CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commit.getId(), refName.substring(0, refName.lastIndexOf('/') + 1) + "new"), origCtl.getProjectControl().getProject(), origCtl.getRefControl().getRefName(), commit, ctx.getIdentifiedUser());
    try {
        commitValidatorsFactory.create(validatePolicy, origCtl.getRefControl(), new NoSshInfo(), ctx.getRepository()).validate(event);
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    }
}
#method_after
private void validate(RepoContext ctx) throws AuthException, ResourceConflictException, IOException, PermissionBackendException {
    if (checkAddPatchSetPermission) {
        permissionBackend.user(ctx.getUser()).database(ctx.getDb()).change(origNotes).check(ChangePermission.ADD_PATCH_SET);
    }
    if (!validate) {
        return;
    }
    PermissionBackend.ForRef perm = permissionBackend.user(ctx.getUser()).ref(origNotes.getChange().getDest());
    String refName = getPatchSetId().toRefName();
    try (CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commitId, refName.substring(0, refName.lastIndexOf('/') + 1) + "new"), projectCache.checkedGet(origNotes.getProjectName()).getProject(), origNotes.getChange().getDest().get(), ctx.getRevWalk().getObjectReader(), commitId, ctx.getIdentifiedUser())) {
        commitValidatorsFactory.forGerritCommits(perm, origNotes.getChange().getDest(), ctx.getIdentifiedUser(), new NoSshInfo(), ctx.getRevWalk()).validate(event);
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    }
}
#end_block

#method_before
public ChangeInfo format(ChangeResource rsrc) throws OrmException {
    return format(changeDataFactory.create(db.get(), rsrc.getControl()));
}
#method_after
public ChangeInfo format(ChangeResource rsrc) throws OrmException {
    return format(changeDataFactory.create(db.get(), rsrc.getNotes()));
}
#end_block

#method_before
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId, boolean fillAccountLoader) throws OrmException {
    try {
        if (fillAccountLoader) {
            accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
            ChangeInfo res = toChangeInfo(cd, limitToPsId);
            accountLoader.fill();
            return res;
        }
        return toChangeInfo(cd, limitToPsId);
    } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
        if (!has(CHECK)) {
            Throwables.throwIfInstanceOf(e, OrmException.class);
            throw new OrmException(e);
        }
        return checkOnly(cd);
    }
}
#method_after
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId, boolean fillAccountLoader) throws OrmException {
    try {
        if (fillAccountLoader) {
            accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
            ChangeInfo res = toChangeInfo(cd, limitToPsId);
            accountLoader.fill();
            return res;
        }
        return toChangeInfo(cd, limitToPsId);
    } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | PermissionBackendException | RuntimeException e) {
        if (!has(CHECK)) {
            Throwables.throwIfInstanceOf(e, OrmException.class);
            throw new OrmException(e);
        }
        return checkOnly(cd);
    }
}
#end_block

#method_before
public ChangeInfo format(RevisionResource rsrc) throws OrmException {
    ChangeData cd = changeDataFactory.create(db.get(), rsrc.getControl());
    return format(cd, Optional.of(rsrc.getPatchSet().getId()), true);
}
#method_after
public ChangeInfo format(RevisionResource rsrc) throws OrmException {
    ChangeData cd = changeDataFactory.create(db.get(), rsrc.getNotes());
    return format(cd, Optional.of(rsrc.getPatchSet().getId()), true);
}
#end_block

#method_before
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, Optional.empty());
            } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#method_after
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, Optional.empty());
            } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | PermissionBackendException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else if (e instanceof NoSuchChangeException) {
                    log.info("NoSuchChangeException: Omitting corrupt change " + cd.getId() + " from results. Seems to be stale in the index.");
                    continue;
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#end_block

#method_before
private ChangeInfo checkOnly(ChangeData cd) {
    ChangeControl ctl;
    try {
        ctl = cd.changeControl().forUser(userProvider.get());
    } catch (OrmException e) {
        String msg = "Error loading change";
        log.warn(msg + " " + cd.getId(), e);
        ChangeInfo info = new ChangeInfo();
        info._number = cd.getId().get();
        ProblemInfo p = new ProblemInfo();
        p.message = msg;
        info.problems = Lists.newArrayList(p);
        return info;
    }
    ConsistencyChecker.Result result = checkerProvider.get().check(ctl, fix);
    ChangeInfo info;
    Change c = result.change();
    if (c != null) {
        info = new ChangeInfo();
        info.project = c.getProject().get();
        info.branch = c.getDest().getShortName();
        info.topic = c.getTopic();
        info.changeId = c.getKey().get();
        info.subject = c.getSubject();
        info.status = c.getStatus().asChangeStatus();
        info.owner = new AccountInfo(c.getOwner().get());
        info.created = c.getCreatedOn();
        info.updated = c.getLastUpdatedOn();
        info._number = c.getId().get();
        info.problems = result.problems();
        finish(info);
    } else {
        info = new ChangeInfo();
        info._number = result.id().get();
        info.problems = result.problems();
    }
    return info;
}
#method_after
private ChangeInfo checkOnly(ChangeData cd) {
    ChangeNotes notes;
    try {
        notes = cd.notes();
    } catch (OrmException e) {
        String msg = "Error loading change";
        log.warn(msg + " " + cd.getId(), e);
        ChangeInfo info = new ChangeInfo();
        info._number = cd.getId().get();
        ProblemInfo p = new ProblemInfo();
        p.message = msg;
        info.problems = Lists.newArrayList(p);
        return info;
    }
    ConsistencyChecker.Result result = checkerProvider.get().check(notes, fix);
    ChangeInfo info;
    Change c = result.change();
    if (c != null) {
        info = new ChangeInfo();
        info.project = c.getProject().get();
        info.branch = c.getDest().getShortName();
        info.topic = c.getTopic();
        info.changeId = c.getKey().get();
        info.subject = c.getSubject();
        info.status = c.getStatus().asChangeStatus();
        info.owner = new AccountInfo(c.getOwner().get());
        info.created = c.getCreatedOn();
        info.updated = c.getLastUpdatedOn();
        info._number = c.getId().get();
        info.problems = result.problems();
        info.isPrivate = c.isPrivate() ? true : null;
        info.workInProgress = c.isWorkInProgress() ? true : null;
        info.hasReviewStarted = c.hasReviewStarted();
        finish(info);
    } else {
        info = new ChangeInfo();
        info._number = result.id().get();
        info.problems = result.problems();
    }
    return info;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(ctl, cd) : ImmutableMap.of();
        }
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
        out.removableReviewers = removableReviewers(ctl, out);
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException, PermissionBackendException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.notes(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    PermissionBackend.WithUser withUser = permissionBackend.user(user).database(db);
    PermissionBackend.ForChange perm = lazyLoad ? withUser.change(cd) : withUser.indexedChange(cd, notesFactory.createFromIndexedChange(cd.change()));
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate() ? true : null;
    out.workInProgress = in.isWorkInProgress() ? true : null;
    out.hasReviewStarted = in.hasReviewStarted();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        out.muted = stars.contains(StarredChangesUtil.MUTE_LABEL + "/" + cd.currentPatchSet().getPatchSetId()) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        if (out.muted != null) {
            out.reviewed = true;
        } else {
            out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
        }
    }
    out.labels = labelsFor(perm, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (user.isIdentifiedUser() && (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId()))) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(perm, cd) : ImmutableMap.of();
        }
        out.reviewers = reviewerMap(cd.reviewers(), cd.reviewersByEmail(), false);
        out.pendingReviewers = reviewerMap(cd.pendingReviewers(), cd.pendingReviewersByEmail(), true);
        out.removableReviewers = removableReviewers(cd, out);
    }
    setSubmitter(cd, out);
    out.plugins = pluginDefinedAttributesFactory != null ? pluginDefinedAttributesFactory.create(cd) : null;
    out.revertOf = cd.change().getRevertOf() != null ? cd.change().getRevertOf().get() : null;
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    ChangeControl ctl = null;
    if (needMessages || needRevisions) {
        ctl = changeControlFactory.controlFor(db.get(), cd.change(), userProvider.get());
    }
    if (needMessages) {
        out.messages = messages(ctl, cd);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src, limitToPsId, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, cd.notes());
    }
    if (has(TRACKING_IDS)) {
        ListMultimap<String, String> set = trackingFooters.extract(cd.commitFooters());
        out.trackingIds = set.entries().stream().map(e -> new TrackingIdInfo(e.getKey(), e.getValue())).collect(toList());
    }
    return out;
}
#end_block

#method_before
private Map<String, LabelInfo> labelsFor(ChangeControl ctl, ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    if (!standard && !detailed) {
        return null;
    }
    if (ctl == null) {
        return null;
    }
    LabelTypes labelTypes = ctl.getLabelTypes();
    Map<String, LabelWithStatus> withStatus = cd.change().getStatus().isOpen() ? labelsForOpenChange(ctl, cd, labelTypes, standard, detailed) : labelsForClosedChange(ctl, cd, labelTypes, standard, detailed);
    return ImmutableMap.copyOf(Maps.transformValues(withStatus, LabelWithStatus::label));
}
#method_after
private Map<String, LabelInfo> labelsFor(PermissionBackend.ForChange perm, ChangeData cd, boolean standard, boolean detailed) throws OrmException, PermissionBackendException {
    if (!standard && !detailed) {
        return null;
    }
    LabelTypes labelTypes = cd.getLabelTypes();
    Map<String, LabelWithStatus> withStatus = cd.change().getStatus() == Change.Status.MERGED ? labelsForSubmittedChange(perm, cd, labelTypes, standard, detailed) : labelsForUnsubmittedChange(perm, cd, labelTypes, standard, detailed);
    return ImmutableMap.copyOf(Maps.transformValues(withStatus, LabelWithStatus::label));
}
#end_block

#method_before
private Map<String, LabelWithStatus> initLabels(ChangeData cd, LabelTypes labelTypes, boolean standard) throws OrmException {
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelWithStatus> labels = new TreeMap<>(labelTypes.nameComparator());
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelWithStatus p = labels.get(r.label);
            if (p == null || p.status().compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                if (standard) {
                    switch(r.status) {
                        case OK:
                            n.approved = accountLoader.get(r.appliedBy);
                            break;
                        case REJECT:
                            n.rejected = accountLoader.get(r.appliedBy);
                            n.blocking = true;
                            break;
                        case IMPOSSIBLE:
                        case MAY:
                        case NEED:
                        default:
                            break;
                    }
                }
                n.optional = r.status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, LabelWithStatus.create(n, r.status));
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelWithStatus> initLabels(ChangeData cd, LabelTypes labelTypes, boolean standard) throws OrmException {
    Map<String, LabelWithStatus> labels = new TreeMap<>(labelTypes.nameComparator());
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelWithStatus p = labels.get(r.label);
            if (p == null || p.status().compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                if (standard) {
                    switch(r.status) {
                        case OK:
                            n.approved = accountLoader.get(r.appliedBy);
                            break;
                        case REJECT:
                            n.rejected = accountLoader.get(r.appliedBy);
                            n.blocking = true;
                            break;
                        case IMPOSSIBLE:
                        case MAY:
                        case NEED:
                        default:
                            break;
                    }
                }
                n.optional = r.status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, LabelWithStatus.create(n, r.status));
            }
        }
    }
    return labels;
}
#end_block

#method_before
private void setAllApprovals(ChangeControl baseCtrl, ChangeData cd, Map<String, LabelWithStatus> labels) throws OrmException {
    Change.Status status = cd.change().getStatus();
    checkState(status.isOpen(), "should not call setAllApprovals on %s change", status);
    // Include a user in the output for this label if either:
    // - They are an explicit reviewer.
    // - They ever voted on this change.
    Set<Account.Id> allUsers = new HashSet<>();
    allUsers.addAll(cd.reviewers().byState(ReviewerStateInternal.REVIEWER));
    for (PatchSetApproval psa : cd.approvals().values()) {
        allUsers.add(psa.getAccountId());
    }
    Table<Account.Id, String, PatchSetApproval> current = HashBasedTable.create(allUsers.size(), baseCtrl.getLabelTypes().getLabelTypes().size());
    for (PatchSetApproval psa : cd.currentApprovals()) {
        current.put(psa.getAccountId(), psa.getLabel(), psa);
    }
    for (Account.Id accountId : allUsers) {
        IdentifiedUser user = userFactory.create(accountId);
        ChangeControl ctl = baseCtrl.forUser(user);
        Map<String, VotingRangeInfo> pvr = getPermittedVotingRanges(permittedLabels(ctl, cd));
        for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
            LabelType lt = ctl.getLabelTypes().byLabel(e.getKey());
            if (lt == null) {
                // author didn't intend for the label to show up in the table.
                continue;
            }
            Integer value;
            VotingRangeInfo permittedVotingRange = pvr.getOrDefault(lt.getName(), null);
            String tag = null;
            Timestamp date = null;
            PatchSetApproval psa = current.get(accountId, lt.getName());
            if (psa != null) {
                value = Integer.valueOf(psa.getValue());
                if (value == 0) {
                    // This may be a dummy approval that was inserted when the reviewer
                    // was added. Explicitly check whether the user can vote on this
                    // label.
                    value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
                }
                tag = psa.getTag();
                date = psa.getGranted();
                if (psa.isPostSubmit()) {
                    log.warn("unexpected post-submit approval on open change: {}", psa);
                }
            } else {
                // Either the user cannot vote on this label, or they were added as a
                // reviewer but have not responded yet. Explicitly check whether the
                // user can vote on this label.
                value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
            }
            addApproval(e.getValue().label(), approvalInfo(accountId, value, permittedVotingRange, tag, date));
        }
    }
}
#method_after
private void setAllApprovals(PermissionBackend.ForChange basePerm, ChangeData cd, Map<String, LabelWithStatus> labels) throws OrmException, PermissionBackendException {
    Change.Status status = cd.change().getStatus();
    checkState(status != Change.Status.MERGED, "should not call setAllApprovals on %s change", status);
    // Include a user in the output for this label if either:
    // - They are an explicit reviewer.
    // - They ever voted on this change.
    Set<Account.Id> allUsers = new HashSet<>();
    allUsers.addAll(cd.reviewers().byState(ReviewerStateInternal.REVIEWER));
    for (PatchSetApproval psa : cd.approvals().values()) {
        allUsers.add(psa.getAccountId());
    }
    Table<Account.Id, String, PatchSetApproval> current = HashBasedTable.create(allUsers.size(), cd.getLabelTypes().getLabelTypes().size());
    for (PatchSetApproval psa : cd.currentApprovals()) {
        current.put(psa.getAccountId(), psa.getLabel(), psa);
    }
    LabelTypes labelTypes = cd.getLabelTypes();
    for (Account.Id accountId : allUsers) {
        PermissionBackend.ForChange perm = basePerm.user(userFactory.create(accountId));
        Map<String, VotingRangeInfo> pvr = getPermittedVotingRanges(permittedLabels(perm, cd));
        for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
            LabelType lt = labelTypes.byLabel(e.getKey());
            if (lt == null) {
                // author didn't intend for the label to show up in the table.
                continue;
            }
            Integer value;
            VotingRangeInfo permittedVotingRange = pvr.getOrDefault(lt.getName(), null);
            String tag = null;
            Timestamp date = null;
            PatchSetApproval psa = current.get(accountId, lt.getName());
            if (psa != null) {
                value = Integer.valueOf(psa.getValue());
                if (value == 0) {
                    // This may be a dummy approval that was inserted when the reviewer
                    // was added. Explicitly check whether the user can vote on this
                    // label.
                    value = perm.test(new LabelPermission(lt)) ? 0 : null;
                }
                tag = psa.getTag();
                date = psa.getGranted();
                if (psa.isPostSubmit()) {
                    log.warn("unexpected post-submit approval on open change: {}", psa);
                }
            } else {
                // Either the user cannot vote on this label, or they were added as a
                // reviewer but have not responded yet. Explicitly check whether the
                // user can vote on this label.
                value = perm.test(new LabelPermission(lt)) ? 0 : null;
            }
            addApproval(e.getValue().label(), approvalInfo(accountId, value, permittedVotingRange, tag, date));
        }
    }
}
#end_block

#method_before
private Map<String, Collection<String>> permittedLabels(ChangeControl ctl, ChangeData cd) throws OrmException {
    if (ctl == null || !ctl.getUser().isIdentifiedUser()) {
        return null;
    }
    Map<String, Short> labels = null;
    boolean isMerged = ctl.getChange().getStatus() == Change.Status.MERGED;
    LabelTypes labelTypes = ctl.getLabelTypes();
    SetMultimap<String, String> permitted = LinkedHashMultimap.create();
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelType type = labelTypes.byLabel(r.label);
            if (type == null || (isMerged && !type.allowPostSubmit())) {
                continue;
            }
            PermissionRange range = ctl.getRange(Permission.forLabel(r.label));
            for (LabelValue v : type.getValues()) {
                boolean ok = range.contains(v.getValue());
                if (isMerged) {
                    if (labels == null) {
                        labels = currentLabels(ctl);
                    }
                    short prev = labels.getOrDefault(type.getName(), (short) 0);
                    ok &= v.getValue() >= prev;
                }
                if (ok) {
                    permitted.put(r.label, v.formatValue());
                }
            }
        }
    }
    List<String> toClear = Lists.newArrayListWithCapacity(permitted.keySet().size());
    for (Map.Entry<String, Collection<String>> e : permitted.asMap().entrySet()) {
        if (isOnlyZero(e.getValue())) {
            toClear.add(e.getKey());
        }
    }
    for (String label : toClear) {
        permitted.removeAll(label);
    }
    return permitted.asMap();
}
#method_after
private Map<String, Collection<String>> permittedLabels(PermissionBackend.ForChange perm, ChangeData cd) throws OrmException, PermissionBackendException {
    boolean isMerged = cd.change().getStatus() == Change.Status.MERGED;
    LabelTypes labelTypes = cd.getLabelTypes();
    Map<String, LabelType> toCheck = new HashMap<>();
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels != null) {
            for (SubmitRecord.Label r : rec.labels) {
                LabelType type = labelTypes.byLabel(r.label);
                if (type != null && (!isMerged || type.allowPostSubmit())) {
                    toCheck.put(type.getName(), type);
                }
            }
        }
    }
    Map<String, Short> labels = null;
    Set<LabelPermission.WithValue> can = perm.testLabels(toCheck.values());
    SetMultimap<String, String> permitted = LinkedHashMultimap.create();
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelType type = labelTypes.byLabel(r.label);
            if (type == null || (isMerged && !type.allowPostSubmit())) {
                continue;
            }
            for (LabelValue v : type.getValues()) {
                boolean ok = can.contains(new LabelPermission.WithValue(type, v));
                if (isMerged) {
                    if (labels == null) {
                        labels = currentLabels(perm, cd);
                    }
                    short prev = labels.getOrDefault(type.getName(), (short) 0);
                    ok &= v.getValue() >= prev;
                }
                if (ok) {
                    permitted.put(r.label, v.formatValue());
                }
            }
        }
    }
    List<String> toClear = Lists.newArrayListWithCapacity(permitted.keySet().size());
    for (Map.Entry<String, Collection<String>> e : permitted.asMap().entrySet()) {
        if (isOnlyZero(e.getValue())) {
            toClear.add(e.getKey());
        }
    }
    for (String label : toClear) {
        permitted.removeAll(label);
    }
    return permitted.asMap();
}
#end_block

#method_before
private Map<String, Short> currentLabels(ChangeControl ctl) throws OrmException {
    Map<String, Short> result = new HashMap<>();
    for (PatchSetApproval psa : approvalsUtil.byPatchSetUser(db.get(), ctl, ctl.getChange().currentPatchSetId(), ctl.getUser().getAccountId())) {
        result.put(psa.getLabel(), psa.getValue());
    }
    return result;
}
#method_after
private Map<String, Short> currentLabels(PermissionBackend.ForChange perm, ChangeData cd) throws OrmException {
    IdentifiedUser user = perm.user().asIdentifiedUser();
    Map<String, Short> result = new HashMap<>();
    for (PatchSetApproval psa : approvalsUtil.byPatchSetUser(db.get(), lazyLoad ? cd.notes() : notesFactory.createFromIndexedChange(cd.change()), user, cd.change().currentPatchSetId(), user.getAccountId(), null, null)) {
        result.put(psa.getLabel(), psa.getValue());
    }
    return result;
}
#end_block

#method_before
private Collection<ChangeMessageInfo> messages(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws OrmException {
    List<ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes());
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        PatchSet ps = patchNum != null ? map.get(patchNum) : null;
        if (patchNum == null || ctl.isPatchVisible(ps, db.get())) {
            ChangeMessageInfo cmi = new ChangeMessageInfo();
            cmi.id = message.getKey().get();
            cmi.author = accountLoader.get(message.getAuthor());
            cmi.date = message.getWrittenOn();
            cmi.message = message.getMessage();
            cmi.tag = message.getTag();
            cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
            result.add(cmi);
        }
    }
    return result;
}
#method_after
private Collection<ChangeMessageInfo> messages(ChangeControl ctl, ChangeData cd) throws OrmException {
    List<ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes());
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        if (patchNum == null || ctl.isVisible(db.get())) {
            ChangeMessageInfo cmi = new ChangeMessageInfo();
            cmi.id = message.getKey().get();
            cmi.author = accountLoader.get(message.getAuthor());
            cmi.date = message.getWrittenOn();
            cmi.message = message.getMessage();
            cmi.tag = message.getTag();
            cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
            Account.Id realAuthor = message.getRealAuthor();
            if (realAuthor != null) {
                cmi.realAuthor = accountLoader.get(realAuthor);
            }
            result.add(cmi);
        }
    }
    return result;
}
#end_block

#method_before
private Collection<AccountInfo> removableReviewers(ChangeControl ctl, ChangeInfo out) {
    // Although this is called removableReviewers, this method also determines
    // which CCs are removable.
    // 
    // For reviewers, we need to look at each approval, because the reviewer
    // should only be considered removable if *all* of their approvals can be
    // removed. First, add all reviewers with *any* removable approval to the
    // "removable" set. Along the way, if we encounter a non-removable approval,
    // add the reviewer to the "fixed" set. Before we return, remove all members
    // of "fixed" from "removable", because not all of their approvals can be
    // removed.
    Collection<LabelInfo> labels = out.labels.values();
    Set<Account.Id> fixed = Sets.newHashSetWithExpectedSize(labels.size());
    Set<Account.Id> removable = Sets.newHashSetWithExpectedSize(labels.size());
    for (LabelInfo label : labels) {
        if (label.all == null) {
            continue;
        }
        for (ApprovalInfo ai : label.all) {
            Account.Id id = new Account.Id(ai._accountId);
            if (ctl.canRemoveReviewer(id, MoreObjects.firstNonNull(ai.value, 0))) {
                removable.add(id);
            } else {
                fixed.add(id);
            }
        }
    }
    // CCs are simpler than reviewers. They are removable if the ChangeControl
    // would permit a non-negative approval by that account to be removed, in
    // which case add them to removable. We don't need to add unremovable CCs to
    // "fixed" because we only visit each CC once here.
    Collection<AccountInfo> ccs = out.reviewers.get(ReviewerState.CC);
    if (ccs != null) {
        for (AccountInfo ai : ccs) {
            Account.Id id = new Account.Id(ai._accountId);
            if (ctl.canRemoveReviewer(id, 0)) {
                removable.add(id);
            }
        }
    }
    // Subtract any reviewers with non-removable approvals from the "removable"
    // set. This also subtracts any CCs that for some reason also hold
    // unremovable approvals.
    removable.removeAll(fixed);
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    return result;
}
#method_after
private Collection<AccountInfo> removableReviewers(ChangeData cd, ChangeInfo out) throws PermissionBackendException, NoSuchChangeException, OrmException {
    // Although this is called removableReviewers, this method also determines
    // which CCs are removable.
    // 
    // For reviewers, we need to look at each approval, because the reviewer
    // should only be considered removable if *all* of their approvals can be
    // removed. First, add all reviewers with *any* removable approval to the
    // "removable" set. Along the way, if we encounter a non-removable approval,
    // add the reviewer to the "fixed" set. Before we return, remove all members
    // of "fixed" from "removable", because not all of their approvals can be
    // removed.
    Collection<LabelInfo> labels = out.labels.values();
    Set<Account.Id> fixed = Sets.newHashSetWithExpectedSize(labels.size());
    Set<Account.Id> removable = Sets.newHashSetWithExpectedSize(labels.size());
    for (LabelInfo label : labels) {
        if (label.all == null) {
            continue;
        }
        for (ApprovalInfo ai : label.all) {
            Account.Id id = new Account.Id(ai._accountId);
            if (removeReviewerControl.testRemoveReviewer(cd, userProvider.get(), id, MoreObjects.firstNonNull(ai.value, 0))) {
                removable.add(id);
            } else {
                fixed.add(id);
            }
        }
    }
    // CCs are simpler than reviewers. They are removable if the ChangeControl
    // would permit a non-negative approval by that account to be removed, in
    // which case add them to removable. We don't need to add unremovable CCs to
    // "fixed" because we only visit each CC once here.
    Collection<AccountInfo> ccs = out.reviewers.get(ReviewerState.CC);
    if (ccs != null) {
        for (AccountInfo ai : ccs) {
            if (ai._accountId != null) {
                Account.Id id = new Account.Id(ai._accountId);
                if (removeReviewerControl.testRemoveReviewer(cd, userProvider.get(), id, 0)) {
                    removable.add(id);
                }
            }
        }
    }
    // Subtract any reviewers with non-removable approvals from the "removable"
    // set. This also subtracts any CCs that for some reason also hold
    // unremovable approvals.
    removable.removeAll(fixed);
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    // Reviewers added by email are always removable
    for (Collection<AccountInfo> infos : out.reviewers.values()) {
        for (AccountInfo info : infos) {
            if (info._accountId == null) {
                result.add(info);
            }
        }
    }
    return result;
}
#end_block

#method_before
@Nullable
private Repository openRepoIfNecessary(ChangeControl ctl) throws IOException {
    if (has(ALL_COMMITS) || has(CURRENT_COMMIT) || has(COMMIT_FOOTERS)) {
        return repoManager.openRepository(ctl.getProject().getNameKey());
    }
    return null;
}
#method_after
@Nullable
private Repository openRepoIfNecessary(Project.NameKey project) throws IOException {
    if (has(ALL_COMMITS) || has(CURRENT_COMMIT) || has(COMMIT_FOOTERS)) {
        return repoManager.openRepository(project);
    }
    return null;
}
#end_block

#method_before
private Map<String, RevisionInfo> revisions(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map, ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    try (Repository repo = openRepoIfNecessary(ctl)) {
        for (PatchSet in : map.values()) {
            if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
                res.put(in.getRevision().get(), toRevisionInfo(ctl, cd, in, repo, false, changeInfo));
            }
        }
        return res;
    }
}
#method_after
private Map<String, RevisionInfo> revisions(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map, Optional<PatchSet.Id> limitToPsId, ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    try (Repository repo = openRepoIfNecessary(cd.project());
        RevWalk rw = newRevWalk(repo)) {
        for (PatchSet in : map.values()) {
            PatchSet.Id id = in.getId();
            boolean want = false;
            if (has(ALL_REVISIONS)) {
                want = true;
            } else if (limitToPsId.isPresent()) {
                want = id.equals(limitToPsId.get());
            } else {
                want = id.equals(cd.change().currentPatchSetId());
            }
            if (want && ctl.isVisible(db.get())) {
                res.put(in.getRevision().get(), toRevisionInfo(cd, in, repo, rw, false, changeInfo));
            }
        }
        return res;
    }
}
#end_block

#method_before
public RevisionInfo getRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    try (Repository repo = openRepoIfNecessary(ctl)) {
        RevisionInfo rev = toRevisionInfo(ctl, changeDataFactory.create(db.get(), ctl), in, repo, true, null);
        accountLoader.fill();
        return rev;
    }
}
#method_after
public RevisionInfo getRevisionInfo(ChangeData cd, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    try (Repository repo = openRepoIfNecessary(cd.project());
        RevWalk rw = newRevWalk(repo)) {
        RevisionInfo rev = toRevisionInfo(cd, in, repo, rw, true, null);
        accountLoader.fill();
        return rev;
    }
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in, @Nullable Repository repo, boolean fillCommit, @Nullable ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.fetch = makeFetchMap(ctl, in);
    out.kind = changeKindCache.getChangeKind(repo, cd, in);
    out.description = in.getDescription();
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        Project.NameKey project = c.getProject();
        try (RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            if (setCommit) {
                out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS), fillCommit);
            }
            if (addFooters) {
                Ref ref = repo.exactRef(ctl.getChange().getDest().get());
                RevCommit mergeTip = null;
                if (ref != null) {
                    mergeTip = rw.parseCommit(ref.getObjectId());
                    rw.parseBody(mergeTip);
                }
                out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCommitMessageOnSubmit(commit, mergeTip, ctl, in.getId());
            }
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
        out.files.remove(Patch.MERGE_LIST);
    }
    if ((out.isCurrent) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(changeInfo, out, new RevisionResource(changeResourceFactory.create(ctl), in));
    }
    if (gpgApi.isEnabled() && has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeData cd, PatchSet in, @Nullable Repository repo, @Nullable RevWalk rw, boolean fillCommit, @Nullable ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = cd.change();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.fetch = makeFetchMap(cd, in);
    out.kind = changeKindCache.getChangeKind(rw, repo != null ? repo.getConfig() : null, cd, in);
    out.description = in.getDescription();
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        checkState(rw != null);
        checkState(repo != null);
        Project.NameKey project = c.getProject();
        String rev = in.getRevision().get();
        RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
        rw.parseBody(commit);
        if (setCommit) {
            out.commit = toCommit(project, rw, commit, has(WEB_LINKS), fillCommit);
        }
        if (addFooters) {
            Ref ref = repo.exactRef(cd.change().getDest().get());
            RevCommit mergeTip = null;
            if (ref != null) {
                mergeTip = rw.parseCommit(ref.getObjectId());
                rw.parseBody(mergeTip);
            }
            out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCommitMessageOnSubmit(commit, mergeTip, cd.notes(), userProvider.get(), in.getId());
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
        out.files.remove(Patch.MERGE_LIST);
    }
    if (out.isCurrent && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(changeInfo, out, new RevisionResource(changeResourceFactory.create(cd.notes(), userProvider.get()), in));
    }
    if (gpgApi.isEnabled() && has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#end_block

#method_before
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks, boolean fillCommit) throws IOException {
    Project.NameKey project = ctl.getProject().getNameKey();
    CommitInfo info = new CommitInfo();
    if (fillCommit) {
        info.commit = commit.name();
    }
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        List<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links;
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        if (addLinks) {
            List<WebLinkInfo> parentLinks = webLinks.getParentLinks(project, parent.name());
            i.webLinks = parentLinks.isEmpty() ? null : parentLinks;
        }
        info.parents.add(i);
    }
    return info;
}
#method_after
CommitInfo toCommit(Project.NameKey project, RevWalk rw, RevCommit commit, boolean addLinks, boolean fillCommit) throws IOException {
    CommitInfo info = new CommitInfo();
    if (fillCommit) {
        info.commit = commit.name();
    }
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        List<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links;
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        if (addLinks) {
            List<WebLinkInfo> parentLinks = webLinks.getParentLinks(project, parent.name());
            i.webLinks = parentLinks.isEmpty() ? null : parentLinks;
        }
        info.parents.add(i);
    }
    return info;
}
#end_block

#method_before
private Map<String, FetchInfo> makeFetchMap(ChangeControl ctl, PatchSet in) {
    Map<String, FetchInfo> r = new LinkedHashMap<>();
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        String schemeName = e.getExportName();
        DownloadScheme scheme = e.getProvider().get();
        if (!scheme.isEnabled() || (scheme.isAuthRequired() && !userProvider.get().isIdentifiedUser())) {
            continue;
        }
        if (!scheme.isAuthSupported() && !ctl.forUser(anonymous).isPatchVisible(in, db.get())) {
            continue;
        }
        String projectName = ctl.getProject().getNameKey().get();
        String url = scheme.getUrl(projectName);
        String refName = in.getRefName();
        FetchInfo fetchInfo = new FetchInfo(url, refName);
        r.put(schemeName, fetchInfo);
        if (has(DOWNLOAD_COMMANDS)) {
            populateFetchMap(scheme, downloadCommands, projectName, refName, fetchInfo);
        }
    }
    return r;
}
#method_after
private Map<String, FetchInfo> makeFetchMap(ChangeData cd, PatchSet in) throws OrmException {
    Map<String, FetchInfo> r = new LinkedHashMap<>();
    ChangeControl ctl = changeControlFactory.controlFor(db.get(), cd.change(), anonymous);
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        String schemeName = e.getExportName();
        DownloadScheme scheme = e.getProvider().get();
        if (!scheme.isEnabled() || (scheme.isAuthRequired() && !userProvider.get().isIdentifiedUser())) {
            continue;
        }
        if (!scheme.isAuthSupported() && !ctl.isVisible(db.get())) {
            continue;
        }
        String projectName = cd.project().get();
        String url = scheme.getUrl(projectName);
        String refName = in.getRefName();
        FetchInfo fetchInfo = new FetchInfo(url, refName);
        r.put(schemeName, fetchInfo);
        if (has(DOWNLOAD_COMMANDS)) {
            populateFetchMap(scheme, downloadCommands, projectName, refName, fetchInfo);
        }
    }
    return r;
}
#end_block

#method_before
private List<ChangeAttribute> executeSuccessfulQuery(String params, SshSession session) throws Exception {
    String rawResponse = session.exec("gerrit query --format=JSON " + params);
    assert_().withFailureMessage(session.getError()).that(session.hasError()).isFalse();
    return getChanges(rawResponse);
}
#method_after
private List<ChangeAttribute> executeSuccessfulQuery(String params, SshSession session) throws Exception {
    String rawResponse = session.exec("gerrit query --format=JSON " + params);
    assertWithMessage(session.getError()).that(session.hasError()).isFalse();
    return getChanges(rawResponse);
}
#end_block

#method_before
public ImmutableCollection<PatchSet> byChange(ReviewDb db, ChangeNotes notes) throws OrmException {
    if (!migration.readChanges()) {
        return ChangeUtil.PS_ID_ORDER.immutableSortedCopy(db.patchSets().byChange(notes.getChangeId()));
    }
    return notes.load().getPatchSets().values();
}
#method_after
public ImmutableCollection<PatchSet> byChange(ReviewDb db, ChangeNotes notes) throws OrmException {
    if (!migration.readChanges()) {
        return PS_ID_ORDER.immutableSortedCopy(db.patchSets().byChange(notes.getChangeId()));
    }
    return notes.load().getPatchSets().values();
}
#end_block

#method_before
public ImmutableMap<PatchSet.Id, PatchSet> byChangeAsMap(ReviewDb db, ChangeNotes notes) throws OrmException {
    if (!migration.readChanges()) {
        ImmutableMap.Builder<PatchSet.Id, PatchSet> result = ImmutableMap.builder();
        for (PatchSet ps : ChangeUtil.PS_ID_ORDER.sortedCopy(db.patchSets().byChange(notes.getChangeId()))) {
            result.put(ps.getId(), ps);
        }
        return result.build();
    }
    return notes.load().getPatchSets();
}
#method_after
public ImmutableMap<PatchSet.Id, PatchSet> byChangeAsMap(ReviewDb db, ChangeNotes notes) throws OrmException {
    if (!migration.readChanges()) {
        ImmutableMap.Builder<PatchSet.Id, PatchSet> result = ImmutableMap.builder();
        for (PatchSet ps : PS_ID_ORDER.sortedCopy(db.patchSets().byChange(notes.getChangeId()))) {
            result.put(ps.getId(), ps);
        }
        return result.build();
    }
    return notes.load().getPatchSets();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(RevisionReviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(ChangeIncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "robotcomments").to(ListChangeRobotComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    put(REVISION_KIND, "description").to(PutDescription.class);
    get(REVISION_KIND, "description").to(GetDescription.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "reviewers").to(RevisionReviewers.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(RevisionReviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Fixes.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FIX_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(ChangeIncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "robotcomments").to(ListChangeRobotComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    get(CHANGE_KIND, "pure_revert").to(GetPureRevert.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "private").to(PostPrivate.class);
    post(CHANGE_KIND, "private.delete").to(DeletePrivateByPost.class);
    delete(CHANGE_KIND, "private").to(DeletePrivate.class);
    put(CHANGE_KIND, "ignore").to(Ignore.class);
    put(CHANGE_KIND, "unignore").to(Unignore.class);
    put(CHANGE_KIND, "mute").to(Mute.class);
    put(CHANGE_KIND, "unmute").to(Unmute.class);
    post(CHANGE_KIND, "wip").to(SetWorkInProgress.class);
    post(CHANGE_KIND, "ready").to(SetReadyForReview.class);
    put(CHANGE_KIND, "message").to(PutMessage.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    put(REVISION_KIND, "description").to(PutDescription.class);
    get(REVISION_KIND, "description").to(GetDescription.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "reviewers").to(RevisionReviewers.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    delete(COMMENT_KIND).to(DeleteComment.class);
    post(COMMENT_KIND, "delete").to(DeleteComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "fixes").to(Fixes.class);
    post(FIX_KIND, "apply").to(ApplyFix.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(ChangeResource.Factory.class);
    factory(DeleteReviewerByEmailOp.Factory.class);
    factory(DeleteReviewerOp.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(PostReviewersOp.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(WorkInProgressOp.Factory.class);
}
#end_block

#method_before
@Argument(index = 0, required = true, multiValued = true, metaVar = "{COMMIT | CHANGE,PATCHSET}", usage = "list of commits or patch sets to review")
void addPatchSetId(final String token) {
    try {
        PatchSet ps = psParser.parsePatchSet(token, projectControl, branch);
        patchSets.add(ps);
    } catch (UnloggedFailure e) {
        throw new IllegalArgumentException(e.getMessage(), e);
    } catch (OrmException e) {
        throw new IllegalArgumentException("database error", e);
    }
}
#method_after
@Argument(index = 0, required = true, multiValued = true, metaVar = "{COMMIT | CHANGE,PATCHSET}", usage = "list of commits or patch sets to review")
void addPatchSetId(String token) {
    try {
        PatchSet ps = psParser.parsePatchSet(token, projectControl, branch);
        patchSets.add(ps);
    } catch (UnloggedFailure e) {
        throw new IllegalArgumentException(e.getMessage(), e);
    } catch (OrmException e) {
        throw new IllegalArgumentException("database error", e);
    }
}
#end_block

#method_before
@Option(name = "--label", aliases = "-l", usage = "custom label(s) to assign", metaVar = "LABEL=VALUE")
void addLabel(final String token) {
    LabelVote v = LabelVote.parseWithEquals(token);
    // Disallow SUBM.
    LabelType.checkName(v.label());
    customLabels.put(v.label(), v.value());
}
#method_after
@Option(name = "--label", aliases = "-l", usage = "custom label(s) to assign", metaVar = "LABEL=VALUE")
void addLabel(String token) {
    LabelVote v = LabelVote.parseWithEquals(token);
    // Disallow SUBM.
    LabelType.checkName(v.label());
    customLabels.put(v.label(), v.value());
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure {
    if (abandonChange) {
        if (restoreChange) {
            throw die("abandon and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("abandon and submit actions are mutually exclusive");
        }
        if (rebaseChange) {
            throw die("abandon and rebase actions are mutually exclusive");
        }
        if (moveToBranch != null) {
            throw die("abandon and move actions are mutually exclusive");
        }
    }
    if (json) {
        if (restoreChange) {
            throw die("json and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("json and submit actions are mutually exclusive");
        }
        if (abandonChange) {
            throw die("json and abandon actions are mutually exclusive");
        }
        if (changeComment != null) {
            throw die("json and message are mutually exclusive");
        }
        if (rebaseChange) {
            throw die("json and rebase actions are mutually exclusive");
        }
        if (moveToBranch != null) {
            throw die("json and move actions are mutually exclusive");
        }
        if (changeTag != null) {
            throw die("json and tag actions are mutually exclusive");
        }
    }
    if (rebaseChange) {
        if (submitChange) {
            throw die("rebase and submit actions are mutually exclusive");
        }
    }
    boolean ok = true;
    ReviewInput input = null;
    if (json) {
        input = reviewFromJson();
    }
    for (final PatchSet patchSet : patchSets) {
        try {
            if (input != null) {
                applyReview(patchSet, input);
            } else {
                reviewPatchSet(patchSet);
            }
        } catch (RestApiException | UnloggedFailure e) {
            ok = false;
            writeError("error", e.getMessage() + "\n");
        } catch (NoSuchChangeException e) {
            ok = false;
            writeError("error", "no such change " + patchSet.getId().getParentKey().get());
        } catch (Exception e) {
            ok = false;
            writeError("fatal", "internal server error while reviewing " + patchSet.getId() + "\n");
            log.error("internal error while reviewing " + patchSet.getId(), e);
        }
    }
    if (!ok) {
        throw die("one or more reviews failed; review output above");
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    if (abandonChange) {
        if (restoreChange) {
            throw die("abandon and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("abandon and submit actions are mutually exclusive");
        }
        if (rebaseChange) {
            throw die("abandon and rebase actions are mutually exclusive");
        }
        if (moveToBranch != null) {
            throw die("abandon and move actions are mutually exclusive");
        }
    }
    if (json) {
        if (restoreChange) {
            throw die("json and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("json and submit actions are mutually exclusive");
        }
        if (abandonChange) {
            throw die("json and abandon actions are mutually exclusive");
        }
        if (changeComment != null) {
            throw die("json and message are mutually exclusive");
        }
        if (rebaseChange) {
            throw die("json and rebase actions are mutually exclusive");
        }
        if (moveToBranch != null) {
            throw die("json and move actions are mutually exclusive");
        }
        if (changeTag != null) {
            throw die("json and tag actions are mutually exclusive");
        }
    }
    if (rebaseChange) {
        if (submitChange) {
            throw die("rebase and submit actions are mutually exclusive");
        }
    }
    boolean ok = true;
    ReviewInput input = null;
    if (json) {
        input = reviewFromJson();
    }
    for (PatchSet patchSet : patchSets) {
        try {
            if (input != null) {
                applyReview(patchSet, input);
            } else {
                reviewPatchSet(patchSet);
            }
        } catch (RestApiException | UnloggedFailure e) {
            ok = false;
            writeError("error", e.getMessage() + "\n");
        } catch (NoSuchChangeException e) {
            ok = false;
            writeError("error", "no such change " + patchSet.getId().getParentKey().get());
        } catch (Exception e) {
            ok = false;
            writeError("fatal", "internal server error while reviewing " + patchSet.getId() + "\n");
            log.error("internal error while reviewing " + patchSet.getId(), e);
        }
    }
    if (!ok) {
        throw die("one or more reviews failed; review output above");
    }
}
#end_block

#method_before
private void applyReview(PatchSet patchSet, final ReviewInput review) throws RestApiException {
    gApi.changes().id(patchSet.getId().getParentKey().get()).revision(patchSet.getRevision().get()).review(review);
}
#method_after
private void applyReview(PatchSet patchSet, ReviewInput review) throws RestApiException {
    gApi.changes().id(patchSet.getId().getParentKey().get()).revision(patchSet.getRevision().get()).review(review);
}
#end_block

#method_before
private void reviewPatchSet(final PatchSet patchSet) throws Exception {
    if (notify == null) {
        notify = NotifyHandling.ALL;
    }
    ReviewInput review = new ReviewInput();
    review.message = Strings.emptyToNull(changeComment);
    review.tag = Strings.emptyToNull(changeTag);
    review.notify = notify;
    review.labels = new TreeMap<>();
    review.drafts = ReviewInput.DraftHandling.PUBLISH;
    review.strictLabels = strictLabels;
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            review.labels.put(ao.getLabelName(), v);
        }
    }
    review.labels.putAll(customLabels);
    // We don't need to add the review comment when abandoning/restoring.
    if (abandonChange || restoreChange || moveToBranch != null) {
        review.message = null;
    }
    try {
        if (abandonChange) {
            AbandonInput input = new AbandonInput();
            input.message = Strings.emptyToNull(changeComment);
            applyReview(patchSet, review);
            changeApi(patchSet).abandon(input);
        } else if (restoreChange) {
            RestoreInput input = new RestoreInput();
            input.message = Strings.emptyToNull(changeComment);
            changeApi(patchSet).restore(input);
            applyReview(patchSet, review);
        } else {
            applyReview(patchSet, review);
        }
        if (moveToBranch != null) {
            MoveInput moveInput = new MoveInput();
            moveInput.destinationBranch = moveToBranch;
            moveInput.message = Strings.emptyToNull(changeComment);
            changeApi(patchSet).move(moveInput);
        }
        if (rebaseChange) {
            revisionApi(patchSet).rebase();
        }
        if (submitChange) {
            revisionApi(patchSet).submit();
        }
    } catch (IllegalStateException | RestApiException e) {
        throw die(e);
    }
}
#method_after
private void reviewPatchSet(PatchSet patchSet) throws Exception {
    if (notify == null) {
        notify = NotifyHandling.ALL;
    }
    ReviewInput review = new ReviewInput();
    review.message = Strings.emptyToNull(changeComment);
    review.tag = Strings.emptyToNull(changeTag);
    review.notify = notify;
    review.labels = new TreeMap<>();
    review.drafts = ReviewInput.DraftHandling.PUBLISH;
    review.strictLabels = strictLabels;
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            review.labels.put(ao.getLabelName(), v);
        }
    }
    review.labels.putAll(customLabels);
    // We don't need to add the review comment when abandoning/restoring.
    if (abandonChange || restoreChange || moveToBranch != null) {
        review.message = null;
    }
    try {
        if (abandonChange) {
            AbandonInput input = new AbandonInput();
            input.message = Strings.emptyToNull(changeComment);
            applyReview(patchSet, review);
            changeApi(patchSet).abandon(input);
        } else if (restoreChange) {
            RestoreInput input = new RestoreInput();
            input.message = Strings.emptyToNull(changeComment);
            changeApi(patchSet).restore(input);
            applyReview(patchSet, review);
        } else {
            applyReview(patchSet, review);
        }
        if (moveToBranch != null) {
            MoveInput moveInput = new MoveInput();
            moveInput.destinationBranch = moveToBranch;
            moveInput.message = Strings.emptyToNull(changeComment);
            changeApi(patchSet).move(moveInput);
        }
        if (rebaseChange) {
            revisionApi(patchSet).rebase();
        }
        if (submitChange) {
            revisionApi(patchSet).submit();
        }
    } catch (IllegalStateException | RestApiException e) {
        throw die(e);
    }
}
#end_block

#method_before
@Override
protected void parseCommandLine() throws UnloggedFailure {
    optionList = new ArrayList<>();
    customLabels = new HashMap<>();
    ProjectControl allProjectsControl;
    try {
        allProjectsControl = projectControlFactory.controlFor(allProjects);
    } catch (NoSuchProjectException e) {
        throw die("missing " + allProjects.get());
    }
    for (LabelType type : allProjectsControl.getLabelTypes().getLabelTypes()) {
        StringBuilder usage = new StringBuilder("score for ").append(type.getName()).append("\n");
        for (LabelValue v : type.getValues()) {
            usage.append(v.format()).append("\n");
        }
        final String name = "--" + type.getName().toLowerCase();
        optionList.add(new ApproveOption(name, usage.toString(), type));
    }
    super.parseCommandLine();
}
#method_after
@Override
protected void parseCommandLine() throws UnloggedFailure {
    optionList = new ArrayList<>();
    customLabels = new HashMap<>();
    ProjectState allProjectsState;
    try {
        allProjectsState = projectCache.checkedGet(allProjects);
    } catch (IOException e) {
        throw die("missing " + allProjects.get());
    }
    for (LabelType type : allProjectsState.getLabelTypes().getLabelTypes()) {
        StringBuilder usage = new StringBuilder("score for ").append(type.getName()).append("\n");
        for (LabelValue v : type.getValues()) {
            usage.append(v.format()).append("\n");
        }
        final String name = "--" + type.getName().toLowerCase();
        optionList.add(new ApproveOption(name, usage.toString(), type));
    }
    super.parseCommandLine();
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    change = ctx.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ChangeUpdate update = ctx.getUpdate(psId);
    if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    }
    patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    change.setStatus(Change.Status.ABANDONED);
    change.setLastUpdatedOn(ctx.getWhen());
    update.setStatus(change.getStatus());
    message = newMessage(ctx);
    cmUtil.addChangeMessage(ctx.getDb(), update, message);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    change = ctx.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ChangeUpdate update = ctx.getUpdate(psId);
    if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + ChangeUtil.status(change));
    }
    patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    change.setStatus(Change.Status.ABANDONED);
    change.setLastUpdatedOn(ctx.getWhen());
    update.setStatus(change.getStatus());
    message = newMessage(ctx);
    cmUtil.addChangeMessage(ctx.getDb(), update, message);
    return true;
}
#end_block

#method_before
@Override
protected void onLoad() {
    if (!loaded) {
        RestApi call = ChangeApi.detail(changeId.get());
        ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_COMMITS, ListChangesOption.ALL_REVISIONS));
        call.get(new AsyncCallback<ChangeInfo>() {

            @Override
            public void onSuccess(ChangeInfo result) {
                if (edit != null) {
                    edit.setName(edit.commit().commit());
                    result.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
                }
                render(result.revisions());
                loaded = true;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
    }
}
#method_after
@Override
protected void onLoad() {
    if (!loaded) {
        RestApi call = ChangeApi.detail(project.get(), changeId.get());
        ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_COMMITS, ListChangesOption.ALL_REVISIONS));
        call.get(new AsyncCallback<ChangeInfo>() {

            @Override
            public void onSuccess(ChangeInfo result) {
                if (edit != null) {
                    edit.setName(edit.commit().commit());
                    result.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
                }
                render(result.revisions());
                loaded = true;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
    }
}
#end_block

#method_before
private String url(RevisionInfo r) {
    return PageLinks.toChange(changeId, r.id());
}
#method_after
private String url(RevisionInfo r) {
    return PageLinks.toChange(project, changeId, r.id());
}
#end_block

#method_before
@Test
@TestProjectInput(createEmptyCommit = false)
public void submitToEmptyRepo() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    BinaryResult request = submitPreview(change.getChangeId());
    RevCommit headAfterSubmitPreview = getRemoteHead();
    assertThat(headAfterSubmitPreview).isEqualTo(initialHead);
    Map<Branch.NameKey, RevTree> actual = fetchFromBundles(request);
    assertThat(actual).hasSize(1);
    submit(change.getChangeId());
    assertThat(getRemoteHead().getId()).isEqualTo(change.getCommit());
    assertRevTrees(project, actual);
}
#method_after
@Test
@TestProjectInput(createEmptyCommit = false)
public void submitToEmptyRepo() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    Map<Branch.NameKey, ObjectId> actual = fetchFromSubmitPreview(change.getChangeId());
    RevCommit headAfterSubmitPreview = getRemoteHead();
    assertThat(headAfterSubmitPreview).isEqualTo(initialHead);
    assertThat(actual).hasSize(1);
    submit(change.getChangeId());
    assertThat(getRemoteHead().getId()).isEqualTo(change.getCommit());
    assertTrees(project, actual);
}
#end_block

#method_before
@Test
public void submitSingleChange() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    BinaryResult request = submitPreview(change.getChangeId());
    RevCommit headAfterSubmit = getRemoteHead();
    assertThat(headAfterSubmit).isEqualTo(initialHead);
    assertRefUpdatedEvents();
    assertChangeMergedEvents();
    Map<Branch.NameKey, RevTree> actual = fetchFromBundles(request);
    if ((getSubmitType() == SubmitType.CHERRY_PICK) || (getSubmitType() == SubmitType.REBASE_ALWAYS)) {
        // The change is updated as well:
        assertThat(actual).hasSize(2);
    } else {
        assertThat(actual).hasSize(1);
    }
    submit(change.getChangeId());
    assertRevTrees(project, actual);
}
#method_after
@Test
public void submitSingleChange() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    Map<Branch.NameKey, ObjectId> actual = fetchFromSubmitPreview(change.getChangeId());
    RevCommit headAfterSubmit = getRemoteHead();
    assertThat(headAfterSubmit).isEqualTo(initialHead);
    assertRefUpdatedEvents();
    assertChangeMergedEvents();
    if ((getSubmitType() == SubmitType.CHERRY_PICK) || (getSubmitType() == SubmitType.REBASE_ALWAYS)) {
        // The change is updated as well:
        assertThat(actual).hasSize(2);
    } else {
        assertThat(actual).hasSize(1);
    }
    submit(change.getChangeId());
    assertTrees(project, actual);
}
#end_block

#method_before
@Test
public void submitMultipleChangesOtherMergeConflictPreview() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit headAfterFirstSubmit = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "a.txt", "other content");
    PushOneCommit.Result change3 = createChange("Change 3", "d", "d");
    PushOneCommit.Result change4 = createChange("Change 4", "e", "e");
    // change 2 is not approved, but we ignore labels
    approve(change3.getChangeId());
    BinaryResult request = null;
    String msg = null;
    try {
        request = submitPreview(change4.getChangeId());
    } catch (Exception e) {
        msg = e.getMessage();
    }
    if (getSubmitType() == SubmitType.CHERRY_PICK) {
        Map<Branch.NameKey, RevTree> s = fetchFromBundles(request);
        submit(change4.getChangeId());
        assertRevTrees(project, s);
    } else if (getSubmitType() == SubmitType.FAST_FORWARD_ONLY) {
        assertThat(msg).isEqualTo("Failed to submit 3 changes due to the following problems:\n" + "Change " + change2.getChange().getId() + ": internal error: " + "change not processed by merge strategy\n" + "Change " + change3.getChange().getId() + ": internal error: " + "change not processed by merge strategy\n" + "Change " + change4.getChange().getId() + ": Project policy " + "requires all submissions to be a fast-forward. Please " + "rebase the change locally and upload again for review.");
        RevCommit headAfterSubmit = getRemoteHead();
        assertThat(headAfterSubmit).isEqualTo(headAfterFirstSubmit);
        assertRefUpdatedEvents(initialHead, headAfterFirstSubmit);
        assertChangeMergedEvents(change.getChangeId(), headAfterFirstSubmit.name());
    } else if ((getSubmitType() == SubmitType.REBASE_IF_NECESSARY) || (getSubmitType() == SubmitType.REBASE_ALWAYS)) {
        String change2hash = change2.getChange().currentPatchSet().getRevision().get();
        assertThat(msg).isEqualTo("Cannot rebase " + change2hash + ": The change could " + "not be rebased due to a conflict during merge.");
        RevCommit headAfterSubmit = getRemoteHead();
        assertThat(headAfterSubmit).isEqualTo(headAfterFirstSubmit);
        assertRefUpdatedEvents(initialHead, headAfterFirstSubmit);
        assertChangeMergedEvents(change.getChangeId(), headAfterFirstSubmit.name());
    } else {
        assertThat(msg).isEqualTo("Failed to submit 3 changes due to the following problems:\n" + "Change " + change2.getChange().getId() + ": Change could not be " + "merged due to a path conflict. Please rebase the change " + "locally and upload the rebased commit for review.\n" + "Change " + change3.getChange().getId() + ": Change could not be " + "merged due to a path conflict. Please rebase the change " + "locally and upload the rebased commit for review.\n" + "Change " + change4.getChange().getId() + ": Change could not be " + "merged due to a path conflict. Please rebase the change " + "locally and upload the rebased commit for review.");
        RevCommit headAfterSubmit = getRemoteHead();
        assertThat(headAfterSubmit).isEqualTo(headAfterFirstSubmit);
        assertRefUpdatedEvents(initialHead, headAfterFirstSubmit);
        assertChangeMergedEvents(change.getChangeId(), headAfterFirstSubmit.name());
    }
}
#method_after
@Test
public void submitMultipleChangesOtherMergeConflictPreview() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit headAfterFirstSubmit = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "a.txt", "other content");
    PushOneCommit.Result change3 = createChange("Change 3", "d", "d");
    PushOneCommit.Result change4 = createChange("Change 4", "e", "e");
    // change 2 is not approved, but we ignore labels
    approve(change3.getChangeId());
    try (BinaryResult request = submitPreview(change4.getChangeId())) {
        assertThat(getSubmitType()).isEqualTo(SubmitType.CHERRY_PICK);
        submit(change4.getChangeId());
    } catch (RestApiException e) {
        switch(getSubmitType()) {
            case FAST_FORWARD_ONLY:
                assertThat(e.getMessage()).isEqualTo("Failed to submit 3 changes due to the following problems:\n" + "Change " + change2.getChange().getId() + ": internal error: " + "change not processed by merge strategy\n" + "Change " + change3.getChange().getId() + ": internal error: " + "change not processed by merge strategy\n" + "Change " + change4.getChange().getId() + ": Project policy " + "requires all submissions to be a fast-forward. Please " + "rebase the change locally and upload again for review.");
                break;
            case REBASE_IF_NECESSARY:
            case REBASE_ALWAYS:
                String change2hash = change2.getChange().currentPatchSet().getRevision().get();
                assertThat(e.getMessage()).isEqualTo("Cannot rebase " + change2hash + ": The change could " + "not be rebased due to a conflict during merge.");
                break;
            case MERGE_ALWAYS:
            case MERGE_IF_NECESSARY:
                assertThat(e.getMessage()).isEqualTo("Failed to submit 3 changes due to the following problems:\n" + "Change " + change2.getChange().getId() + ": Change could not be " + "merged due to a path conflict. Please rebase the change " + "locally and upload the rebased commit for review.\n" + "Change " + change3.getChange().getId() + ": Change could not be " + "merged due to a path conflict. Please rebase the change " + "locally and upload the rebased commit for review.\n" + "Change " + change4.getChange().getId() + ": Change could not be " + "merged due to a path conflict. Please rebase the change " + "locally and upload the rebased commit for review.");
                break;
            case CHERRY_PICK:
            default:
                fail("Should not reach here.");
                break;
        }
        RevCommit headAfterSubmit = getRemoteHead();
        assertThat(headAfterSubmit).isEqualTo(headAfterFirstSubmit);
        assertRefUpdatedEvents(initialHead, headAfterFirstSubmit);
        assertChangeMergedEvents(change.getChangeId(), headAfterFirstSubmit.name());
    }
}
#end_block

#method_before
@Test
public void submitMultipleChangesPreview() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change2 = createChange("Change 2", "a.txt", "other content");
    PushOneCommit.Result change3 = createChange("Change 3", "d", "d");
    PushOneCommit.Result change4 = createChange("Change 4", "e", "e");
    // change 2 is not approved, but we ignore labels
    approve(change3.getChangeId());
    BinaryResult request = submitPreview(change4.getChangeId());
    Map<String, Map<String, Integer>> expected = new HashMap<>();
    expected.put(project.get(), new HashMap<String, Integer>());
    expected.get(project.get()).put("refs/heads/master", 3);
    Map<Branch.NameKey, RevTree> actual = fetchFromBundles(request);
    assertThat(actual).containsKey(new Branch.NameKey(project, "refs/heads/master"));
    if (getSubmitType() == SubmitType.CHERRY_PICK) {
        // CherryPick ignores dependencies, thus only change and destination
        // branch refs are modified.
        assertThat(actual).hasSize(2);
    } else if (getSubmitType() == SubmitType.REBASE_ALWAYS) {
        // RebaseAlways takes care of dependencies, therefore Change{2,3,4} and
        // destination branch will be modified.
        assertThat(actual).hasSize(4);
    } else {
        assertThat(actual).hasSize(1);
    }
    // check that the submit preview did not actually submit
    RevCommit headAfterSubmit = getRemoteHead();
    assertThat(headAfterSubmit).isEqualTo(initialHead);
    assertRefUpdatedEvents();
    assertChangeMergedEvents();
    // now check we actually have the same content:
    approve(change2.getChangeId());
    submit(change4.getChangeId());
    assertRevTrees(project, actual);
}
#method_after
@Test
public void submitMultipleChangesPreview() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change2 = createChange("Change 2", "a.txt", "other content");
    PushOneCommit.Result change3 = createChange("Change 3", "d", "d");
    PushOneCommit.Result change4 = createChange("Change 4", "e", "e");
    // change 2 is not approved, but we ignore labels
    approve(change3.getChangeId());
    Map<Branch.NameKey, ObjectId> actual = fetchFromSubmitPreview(change4.getChangeId());
    Map<String, Map<String, Integer>> expected = new HashMap<>();
    expected.put(project.get(), new HashMap<>());
    expected.get(project.get()).put("refs/heads/master", 3);
    assertThat(actual).containsKey(new Branch.NameKey(project, "refs/heads/master"));
    if (getSubmitType() == SubmitType.CHERRY_PICK) {
        // CherryPick ignores dependencies, thus only change and destination
        // branch refs are modified.
        assertThat(actual).hasSize(2);
    } else if (getSubmitType() == SubmitType.REBASE_ALWAYS) {
        // RebaseAlways takes care of dependencies, therefore Change{2,3,4} and
        // destination branch will be modified.
        assertThat(actual).hasSize(4);
    } else {
        assertThat(actual).hasSize(1);
    }
    // check that the submit preview did not actually submit
    RevCommit headAfterSubmit = getRemoteHead();
    assertThat(headAfterSubmit).isEqualTo(initialHead);
    assertRefUpdatedEvents();
    assertChangeMergedEvents();
    // now check we actually have the same content:
    approve(change2.getChangeId());
    submit(change4.getChangeId());
    assertTrees(project, actual);
}
#end_block

#method_before
@Test
public void submitNoPermission() throws Exception {
    // create project where submit is blocked
    Project.NameKey p = createProject("p");
    block(Permission.SUBMIT, REGISTERED_USERS, "refs/*", p);
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    submit(result.getChangeId(), new SubmitInput(), AuthException.class, "submit not permitted");
}
#method_after
@Test
public void submitNoPermission() throws Exception {
    // create project where submit is blocked
    Project.NameKey p = createProject("p");
    block(p, "refs/*", Permission.SUBMIT, REGISTERED_USERS);
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    submit(result.getChangeId(), new SubmitInput(), AuthException.class, "submit not permitted");
}
#end_block

#method_before
@Test
public void submitWholeTopic() throws Exception {
    assume().that(isSubmitWholeTopicEnabled()).isTrue();
    String topic = "test-topic";
    PushOneCommit.Result change1 = createChange("Change 1", "a.txt", "content", topic);
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "content", topic);
    PushOneCommit.Result change3 = createChange("Change 3", "c.txt", "content", topic);
    approve(change1.getChangeId());
    approve(change2.getChangeId());
    approve(change3.getChangeId());
    submit(change3.getChangeId());
    String expectedTopic = name(topic);
    change1.assertChange(Change.Status.MERGED, expectedTopic, admin);
    change2.assertChange(Change.Status.MERGED, expectedTopic, admin);
    change3.assertChange(Change.Status.MERGED, expectedTopic, admin);
    // Check for the exact change to have the correct submitter.
    assertSubmitter(change3);
    // Also check submitters for changes submitted via the topic relationship.
    assertSubmitter(change1);
    assertSubmitter(change2);
    // Check that the repo has the expected commits
    List<RevCommit> log = getRemoteLog();
    List<String> commitsInRepo = log.stream().map(c -> c.getShortMessage()).collect(Collectors.toList());
    int expectedCommitCount = getSubmitType() == SubmitType.MERGE_ALWAYS ? // initial commit + 3 commits + merge commit
    5 : // initial commit + 3 commits
    4;
    assertThat(log).hasSize(expectedCommitCount);
    assertThat(commitsInRepo).containsAllOf("Initial empty repository", "Change 1", "Change 2", "Change 3");
    if (getSubmitType() == SubmitType.MERGE_ALWAYS) {
        assertThat(commitsInRepo).contains("Merge changes from topic '" + expectedTopic + "'");
    }
}
#method_after
@Test
public void submitWholeTopic() throws Exception {
    assume().that(isSubmitWholeTopicEnabled()).isTrue();
    String topic = "test-topic";
    PushOneCommit.Result change1 = createChange("Change 1", "a.txt", "content", topic);
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "content", topic);
    PushOneCommit.Result change3 = createChange("Change 3", "c.txt", "content", topic);
    approve(change1.getChangeId());
    approve(change2.getChangeId());
    approve(change3.getChangeId());
    submit(change3.getChangeId());
    String expectedTopic = name(topic);
    change1.assertChange(Change.Status.MERGED, expectedTopic, admin);
    change2.assertChange(Change.Status.MERGED, expectedTopic, admin);
    change3.assertChange(Change.Status.MERGED, expectedTopic, admin);
    // Check for the exact change to have the correct submitter.
    assertSubmitter(change3);
    // Also check submitters for changes submitted via the topic relationship.
    assertSubmitter(change1);
    assertSubmitter(change2);
    // Check that the repo has the expected commits
    List<RevCommit> log = getRemoteLog();
    List<String> commitsInRepo = log.stream().map(c -> c.getShortMessage()).collect(toList());
    int expectedCommitCount = getSubmitType() == SubmitType.MERGE_ALWAYS ? // initial commit + 3 commits + merge commit
    5 : // initial commit + 3 commits
    4;
    assertThat(log).hasSize(expectedCommitCount);
    assertThat(commitsInRepo).containsAllOf("Initial empty repository", "Change 1", "Change 2", "Change 3");
    if (getSubmitType() == SubmitType.MERGE_ALWAYS) {
        assertThat(commitsInRepo).contains("Merge changes from topic \"" + expectedTopic + "\"");
    }
}
#end_block

#method_before
@Test
public void submitWithValidationMultiRepo() throws Exception {
    assume().that(isSubmitWholeTopicEnabled()).isTrue();
    String topic = "test-topic";
    // Create test projects
    TestRepository<?> repoA = createProjectWithPush("project-a", null, getSubmitType());
    TestRepository<?> repoB = createProjectWithPush("project-b", null, getSubmitType());
    // Create changes on project-a
    PushOneCommit.Result change1 = createChange(repoA, "master", "Change 1", "a.txt", "content", topic);
    PushOneCommit.Result change2 = createChange(repoA, "master", "Change 2", "b.txt", "content", topic);
    // Create changes on project-b
    PushOneCommit.Result change3 = createChange(repoB, "master", "Change 3", "a.txt", "content", topic);
    PushOneCommit.Result change4 = createChange(repoB, "master", "Change 4", "b.txt", "content", topic);
    List<PushOneCommit.Result> changes = Lists.newArrayList(change1, change2, change3, change4);
    for (PushOneCommit.Result change : changes) {
        approve(change.getChangeId());
    }
    // Construct validator which will throw on a second call.
    // Since there are 2 repos, first submit attempt will fail, the second will
    // succeed.
    List<String> projectsCalled = new ArrayList<>(4);
    this.addOnSubmitValidationListener(new OnSubmitValidationListener() {

        @Override
        public void preBranchUpdate(Arguments args) throws ValidationException {
            assertThat(args.getCommands().keySet()).contains("refs/heads/master");
            try (RevWalk rw = args.newRevWalk()) {
                rw.parseBody(rw.parseCommit(args.getCommands().get("refs/heads/master").getNewId()));
            } catch (IOException e) {
                assertThat(e).isNull();
            }
            projectsCalled.add(args.getProject().get());
            if (projectsCalled.size() == 2) {
                throw new ValidationException("time to fail");
            }
        }
    });
    submitWithConflict(change4.getChangeId(), "time to fail");
    assertThat(projectsCalled).containsExactly(name("project-a"), name("project-b"));
    for (PushOneCommit.Result change : changes) {
        change.assertChange(Change.Status.NEW, name(topic), admin);
    }
    submit(change4.getChangeId());
    assertThat(projectsCalled).containsExactly(name("project-a"), name("project-b"), name("project-a"), name("project-b"));
    for (PushOneCommit.Result change : changes) {
        change.assertChange(Change.Status.MERGED, name(topic), admin);
    }
}
#method_after
@Test
public void submitWithValidationMultiRepo() throws Exception {
    assume().that(isSubmitWholeTopicEnabled()).isTrue();
    String topic = "test-topic";
    // Create test projects
    TestRepository<?> repoA = createProjectWithPush("project-a", null, getSubmitType());
    TestRepository<?> repoB = createProjectWithPush("project-b", null, getSubmitType());
    // Create changes on project-a
    PushOneCommit.Result change1 = createChange(repoA, "master", "Change 1", "a.txt", "content", topic);
    PushOneCommit.Result change2 = createChange(repoA, "master", "Change 2", "b.txt", "content", topic);
    // Create changes on project-b
    PushOneCommit.Result change3 = createChange(repoB, "master", "Change 3", "a.txt", "content", topic);
    PushOneCommit.Result change4 = createChange(repoB, "master", "Change 4", "b.txt", "content", topic);
    List<PushOneCommit.Result> changes = Lists.newArrayList(change1, change2, change3, change4);
    for (PushOneCommit.Result change : changes) {
        approve(change.getChangeId());
    }
    // Construct validator which will throw on a second call.
    // Since there are 2 repos, first submit attempt will fail, the second will
    // succeed.
    List<String> projectsCalled = new ArrayList<>(4);
    this.addOnSubmitValidationListener(new OnSubmitValidationListener() {

        @Override
        public void preBranchUpdate(Arguments args) throws ValidationException {
            String master = "refs/heads/master";
            assertThat(args.getCommands()).containsKey(master);
            ReceiveCommand cmd = args.getCommands().get(master);
            ObjectId newMasterId = cmd.getNewId();
            try (Repository repo = repoManager.openRepository(args.getProject())) {
                assertThat(repo.exactRef(master).getObjectId()).isEqualTo(cmd.getOldId());
                assertThat(args.getRef(master)).hasValue(newMasterId);
                args.getRevWalk().parseBody(args.getRevWalk().parseCommit(newMasterId));
            } catch (IOException e) {
                throw new AssertionError("failed checking new ref value", e);
            }
            projectsCalled.add(args.getProject().get());
            if (projectsCalled.size() == 2) {
                throw new ValidationException("time to fail");
            }
        }
    });
    submitWithConflict(change4.getChangeId(), "time to fail");
    assertThat(projectsCalled).containsExactly(name("project-a"), name("project-b"));
    for (PushOneCommit.Result change : changes) {
        change.assertChange(Change.Status.NEW, name(topic), admin);
    }
    submit(change4.getChangeId());
    assertThat(projectsCalled).containsExactly(name("project-a"), name("project-b"), name("project-a"), name("project-b"));
    for (PushOneCommit.Result change : changes) {
        change.assertChange(Change.Status.MERGED, name(topic), admin);
    }
}
#end_block

#method_before
private void setChangeStatusToNew(PushOneCommit.Result... changes) throws Exception {
    for (PushOneCommit.Result change : changes) {
        try (BatchUpdate bu = updateFactory.create(db, project, userFactory.create(admin.id), TimeUtil.nowTs())) {
            bu.addOp(change.getChange().getId(), new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) throws OrmException {
                    ctx.getChange().setStatus(Change.Status.NEW);
                    ctx.getUpdate(ctx.getChange().currentPatchSetId()).setStatus(Change.Status.NEW);
                    return true;
                }
            });
            bu.execute();
        }
    }
}
#method_after
private void setChangeStatusToNew(PushOneCommit.Result... changes) throws Exception {
    for (PushOneCommit.Result change : changes) {
        try (BatchUpdate bu = batchUpdateFactory.create(db, project, userFactory.create(admin.id), TimeUtil.nowTs())) {
            bu.addOp(change.getChange().getId(), new BatchUpdateOp() {

                @Override
                public boolean updateChange(ChangeContext ctx) throws OrmException {
                    ctx.getChange().setStatus(Change.Status.NEW);
                    ctx.getUpdate(ctx.getChange().currentPatchSetId()).setStatus(Change.Status.NEW);
                    return true;
                }
            });
            bu.execute();
        }
    }
}
#end_block

#method_before
protected void assertRebase(TestRepository<?> testRepo, boolean contentMerge) throws Exception {
    Repository repo = testRepo.getRepository();
    RevCommit localHead = getHead(repo);
    RevCommit remoteHead = getRemoteHead();
    assert_().withFailureMessage(String.format("%s not equal %s", localHead.name(), remoteHead.name())).that(localHead.getId()).isNotEqualTo(remoteHead.getId());
    assertThat(remoteHead.getParentCount()).isEqualTo(1);
    if (!contentMerge) {
        assertThat(getLatestRemoteDiff()).isEqualTo(getLatestDiff(repo));
    }
    assertThat(remoteHead.getShortMessage()).isEqualTo(localHead.getShortMessage());
}
#method_after
protected void assertRebase(TestRepository<?> testRepo, boolean contentMerge) throws Exception {
    Repository repo = testRepo.getRepository();
    RevCommit localHead = getHead(repo);
    RevCommit remoteHead = getRemoteHead();
    assertThat(localHead.getId()).isNotEqualTo(remoteHead.getId());
    assertThat(remoteHead.getParentCount()).isEqualTo(1);
    if (!contentMerge) {
        assertThat(getLatestRemoteDiff()).isEqualTo(getLatestDiff(repo));
    }
    assertThat(remoteHead.getShortMessage()).isEqualTo(localHead.getShortMessage());
}
#end_block

#method_before
ChangeNotesState parseAll() throws ConfigInvalidException, IOException {
    // Don't include initial parse in timer, as this might do more I/O to page
    // in the block containing most commits. Later reads are not guaranteed to
    // avoid I/O, but often should.
    walk.reset();
    walk.markStart(walk.parseCommit(tip));
    try (Timer1.Context timer = metrics.parseLatency.start(CHANGES)) {
        ChangeNotesCommit commit;
        while ((commit = walk.next()) != null) {
            parse(commit);
        }
        parseNotes();
        allPastReviewers.addAll(reviewers.rowKeySet());
        pruneReviewers();
        updatePatchSetStates();
        checkMandatoryFooters();
    }
    return buildState();
}
#method_after
ChangeNotesState parseAll() throws ConfigInvalidException, IOException {
    // Don't include initial parse in timer, as this might do more I/O to page
    // in the block containing most commits. Later reads are not guaranteed to
    // avoid I/O, but often should.
    walk.reset();
    walk.markStart(walk.parseCommit(tip));
    try (Timer1.Context timer = metrics.parseLatency.start(CHANGES)) {
        ChangeNotesCommit commit;
        while ((commit = walk.next()) != null) {
            parse(commit);
        }
        if (hasReviewStarted == null) {
            if (previousWorkInProgressFooter == null) {
                hasReviewStarted = true;
            } else {
                hasReviewStarted = !previousWorkInProgressFooter;
            }
        }
        parseNotes();
        allPastReviewers.addAll(reviewers.rowKeySet());
        pruneReviewers();
        pruneReviewersByEmail();
        updatePatchSetStates();
        checkMandatoryFooters();
    }
    return buildState();
}
#end_block

#method_before
private ChangeNotesState buildState() {
    return ChangeNotesState.create(tip.copy(), id, new Change.Key(changeId), createdOn, lastUpdatedOn, ownerId, branch, buildCurrentPatchSetId(), subject, topic, originalSubject, submissionId, assignee != null ? assignee.orElse(null) : null, status, Sets.newLinkedHashSet(Lists.reverse(pastAssignees)), hashtags, patchSets, buildApprovals(), ReviewerSet.fromTable(Tables.transpose(reviewers)), allPastReviewers, buildReviewerUpdates(), submitRecords, buildAllMessages(), buildMessagesByPatchSet(), comments);
}
#method_after
private ChangeNotesState buildState() {
    return ChangeNotesState.create(tip.copy(), id, new Change.Key(changeId), createdOn, lastUpdatedOn, ownerId, branch, buildCurrentPatchSetId(), subject, topic, originalSubject, submissionId, assignee != null ? assignee.orElse(null) : null, status, Sets.newLinkedHashSet(Lists.reverse(pastAssignees)), hashtags, patchSets, buildApprovals(), ReviewerSet.fromTable(Tables.transpose(reviewers)), ReviewerByEmailSet.fromTable(Tables.transpose(reviewersByEmail)), pendingReviewers, pendingReviewersByEmail, allPastReviewers, buildReviewerUpdates(), submitRecords, buildAllMessages(), buildMessagesByPatchSet(), comments, readOnlyUntil, isPrivate, workInProgress, hasReviewStarted, revertOf);
}
#end_block

#method_before
private void parse(ChangeNotesCommit commit) throws ConfigInvalidException {
    Timestamp ts = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
    createdOn = ts;
    parseTag(commit);
    if (branch == null) {
        branch = parseBranch(commit);
    }
    PatchSet.Id psId = parsePatchSetId(commit);
    PatchSetState psState = parsePatchSetState(commit);
    if (psState != null) {
        if (!patchSetStates.containsKey(psId)) {
            patchSetStates.put(psId, psState);
        }
        if (psState == PatchSetState.DELETED) {
            deletedPatchSets.add(psId);
        }
    }
    Account.Id accountId = parseIdent(commit);
    if (accountId != null) {
        ownerId = accountId;
    }
    Account.Id realAccountId = parseRealAccountId(commit, accountId);
    if (changeId == null) {
        changeId = parseChangeId(commit);
    }
    String currSubject = parseSubject(commit);
    if (currSubject != null) {
        if (subject == null) {
            subject = currSubject;
        }
        originalSubject = currSubject;
    }
    parseChangeMessage(psId, accountId, realAccountId, commit, ts);
    if (topic == null) {
        topic = parseTopic(commit);
    }
    parseHashtags(commit);
    parseAssignee(commit);
    if (submissionId == null) {
        submissionId = parseSubmissionId(commit);
    }
    ObjectId currRev = parseRevision(commit);
    if (currRev != null) {
        parsePatchSet(psId, currRev, accountId, ts);
    }
    parseGroups(psId, commit);
    parseCurrentPatchSet(psId, commit);
    if (submitRecords.isEmpty()) {
        // Only parse the most recent set of submit records; any older ones are
        // still there, but not currently used.
        parseSubmitRecords(commit.getFooterLineValues(FOOTER_SUBMITTED_WITH));
    }
    if (status == null) {
        status = parseStatus(commit);
    }
    // "Status: merged" as non-post-submit.
    for (String line : commit.getFooterLineValues(FOOTER_LABEL)) {
        parseApproval(psId, accountId, realAccountId, ts, line);
    }
    for (ReviewerStateInternal state : ReviewerStateInternal.values()) {
        for (String line : commit.getFooterLineValues(state.getFooterKey())) {
            parseReviewer(ts, state, line);
        }
    // Don't update timestamp when a reviewer was added, matching RevewDb
    // behavior.
    }
    if (lastUpdatedOn == null || ts.after(lastUpdatedOn)) {
        lastUpdatedOn = ts;
    }
    parseDescription(psId, commit);
}
#method_after
private void parse(ChangeNotesCommit commit) throws ConfigInvalidException {
    Timestamp ts = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
    createdOn = ts;
    parseTag(commit);
    if (branch == null) {
        branch = parseBranch(commit);
    }
    PatchSet.Id psId = parsePatchSetId(commit);
    PatchSetState psState = parsePatchSetState(commit);
    if (psState != null) {
        if (!patchSetStates.containsKey(psId)) {
            patchSetStates.put(psId, psState);
        }
        if (psState == PatchSetState.DELETED) {
            deletedPatchSets.add(psId);
        }
    }
    Account.Id accountId = parseIdent(commit);
    if (accountId != null) {
        ownerId = accountId;
    }
    Account.Id realAccountId = parseRealAccountId(commit, accountId);
    if (changeId == null) {
        changeId = parseChangeId(commit);
    }
    String currSubject = parseSubject(commit);
    if (currSubject != null) {
        if (subject == null) {
            subject = currSubject;
        }
        originalSubject = currSubject;
    }
    parseChangeMessage(psId, accountId, realAccountId, commit, ts);
    if (topic == null) {
        topic = parseTopic(commit);
    }
    parseHashtags(commit);
    parseAssignee(commit);
    if (submissionId == null) {
        submissionId = parseSubmissionId(commit);
    }
    ObjectId currRev = parseRevision(commit);
    if (currRev != null) {
        parsePatchSet(psId, currRev, accountId, ts);
    }
    parseGroups(psId, commit);
    parseCurrentPatchSet(psId, commit);
    if (submitRecords.isEmpty()) {
        // Only parse the most recent set of submit records; any older ones are
        // still there, but not currently used.
        parseSubmitRecords(commit.getFooterLineValues(FOOTER_SUBMITTED_WITH));
    }
    if (status == null) {
        status = parseStatus(commit);
    }
    // "Status: merged" as non-post-submit.
    for (String line : commit.getFooterLineValues(FOOTER_LABEL)) {
        parseApproval(psId, accountId, realAccountId, ts, line);
    }
    for (ReviewerStateInternal state : ReviewerStateInternal.values()) {
        for (String line : commit.getFooterLineValues(state.getFooterKey())) {
            parseReviewer(ts, state, line);
        }
        for (String line : commit.getFooterLineValues(state.getByEmailFooterKey())) {
            parseReviewerByEmail(ts, state, line);
        }
    // Don't update timestamp when a reviewer was added, matching RevewDb
    // behavior.
    }
    if (readOnlyUntil == null) {
        parseReadOnlyUntil(commit);
    }
    if (isPrivate == null) {
        parseIsPrivate(commit);
    }
    if (revertOf == null) {
        revertOf = parseRevertOf(commit);
    }
    previousWorkInProgressFooter = null;
    parseWorkInProgress(commit);
    if (lastUpdatedOn == null || ts.after(lastUpdatedOn)) {
        lastUpdatedOn = ts;
    }
    parseDescription(psId, commit);
}
#end_block

#method_before
@Test
public void hashtagCommit() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    LinkedHashSet<String> hashtags = new LinkedHashSet<>();
    hashtags.add("tag1");
    hashtags.add("tag2");
    update.setHashtags(hashtags);
    update.commit();
    try (RevWalk walk = new RevWalk(repo)) {
        RevCommit commit = walk.parseCommit(update.getResult());
        walk.parseBody(commit);
        assertThat(commit.getFullMessage()).endsWith("Hashtags: tag1,tag2\n");
    }
}
#method_after
@Test
public void hashtagCommit() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    LinkedHashSet<String> hashtags = new LinkedHashSet<>();
    hashtags.add("tag1");
    hashtags.add("tag2");
    update.setHashtags(hashtags);
    update.commit();
    try (RevWalk walk = new RevWalk(repo)) {
        RevCommit commit = walk.parseCommit(update.getResult());
        walk.parseBody(commit);
        assertThat(commit.getFullMessage()).contains("Hashtags: tag1,tag2\n");
    }
}
#end_block

#method_before
@Test
public void changeMessageWithTrailingDoubleNewline() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Testing trailing double newline\n" + "\n");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    ChangeNotes notes = newNotes(c);
    ListMultimap<PatchSet.Id, ChangeMessage> changeMessages = notes.getChangeMessagesByPatchSet();
    assertThat(changeMessages).hasSize(1);
    ChangeMessage cm1 = Iterables.getOnlyElement(changeMessages.get(ps1));
    assertThat(cm1.getMessage()).isEqualTo("Testing trailing double newline\n" + "\n");
    assertThat(cm1.getAuthor()).isEqualTo(changeOwner.getAccount().getId());
}
#method_after
@Test
public void changeMessageWithTrailingDoubleNewline() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Testing trailing double newline\n\n");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    ChangeNotes notes = newNotes(c);
    ListMultimap<PatchSet.Id, ChangeMessage> changeMessages = notes.getChangeMessagesByPatchSet();
    assertThat(changeMessages).hasSize(1);
    ChangeMessage cm1 = Iterables.getOnlyElement(changeMessages.get(ps1));
    assertThat(cm1.getMessage()).isEqualTo("Testing trailing double newline\n\n");
    assertThat(cm1.getAuthor()).isEqualTo(changeOwner.getAccount().getId());
}
#end_block

#method_before
@Test
public void changeMessageWithMultipleParagraphs() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Testing paragraph 1\n" + "\n" + "Testing paragraph 2\n" + "\n" + "Testing paragraph 3");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    ChangeNotes notes = newNotes(c);
    ListMultimap<PatchSet.Id, ChangeMessage> changeMessages = notes.getChangeMessagesByPatchSet();
    assertThat(changeMessages).hasSize(1);
    ChangeMessage cm1 = Iterables.getOnlyElement(changeMessages.get(ps1));
    assertThat(cm1.getMessage()).isEqualTo("Testing paragraph 1\n" + "\n" + "Testing paragraph 2\n" + "\n" + "Testing paragraph 3");
    assertThat(cm1.getAuthor()).isEqualTo(changeOwner.getAccount().getId());
}
#method_after
@Test
public void changeMessageWithMultipleParagraphs() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Testing paragraph 1\n\nTesting paragraph 2\n\nTesting paragraph 3");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    ChangeNotes notes = newNotes(c);
    ListMultimap<PatchSet.Id, ChangeMessage> changeMessages = notes.getChangeMessagesByPatchSet();
    assertThat(changeMessages).hasSize(1);
    ChangeMessage cm1 = Iterables.getOnlyElement(changeMessages.get(ps1));
    assertThat(cm1.getMessage()).isEqualTo("Testing paragraph 1\n" + "\n" + "Testing paragraph 2\n" + "\n" + "Testing paragraph 3");
    assertThat(cm1.getAuthor()).isEqualTo(changeOwner.getAccount().getId());
}
#end_block

#method_before
public static void abandon(int id, String msg, AsyncCallback<ChangeInfo> cb) {
    MessageInput input = MessageInput.create();
    input.message(emptyToNull(msg));
    call(id, "abandon").post(input, cb);
}
#method_after
public static void abandon(@Nullable String project, int id, String msg, AsyncCallback<ChangeInfo> cb) {
    MessageInput input = MessageInput.create();
    input.message(emptyToNull(msg));
    call(project, id, "abandon").post(input, cb);
}
#end_block

#method_before
public static void createChange(String project, String branch, String topic, String subject, String base, AsyncCallback<ChangeInfo> cb) {
    CreateChangeInput input = CreateChangeInput.create();
    input.project(emptyToNull(project));
    input.branch(emptyToNull(branch));
    input.topic(emptyToNull(topic));
    input.subject(emptyToNull(subject));
    input.baseChange(emptyToNull(base));
    new RestApi("/changes/").post(input, cb);
}
#method_after
public static void createChange(String project, String branch, String topic, String subject, String base, AsyncCallback<ChangeInfo> cb) {
    CreateChangeInput input = CreateChangeInput.create();
    input.project(emptyToNull(project));
    input.branch(emptyToNull(branch));
    input.topic(emptyToNull(topic));
    input.subject(emptyToNull(subject));
    input.baseChange(emptyToNull(base));
    input.workInProgress(true);
    new RestApi("/changes/").post(input, cb);
}
#end_block

#method_before
public static void restore(int id, String msg, AsyncCallback<ChangeInfo> cb) {
    MessageInput input = MessageInput.create();
    input.message(emptyToNull(msg));
}
#method_after
public static void restore(@Nullable String project, int id, String msg, AsyncCallback<ChangeInfo> cb) {
    MessageInput input = MessageInput.create();
    input.message(emptyToNull(msg));
    call(project, id, "restore").post(input, cb);
}
#end_block

#method_before
public static void revert(int id, String msg, AsyncCallback<ChangeInfo> cb) {
    MessageInput input = MessageInput.create();
    input.message(emptyToNull(msg));
    call(id, "revert").post(input, cb);
}
#method_after
public static void revert(@Nullable String project, int id, String msg, AsyncCallback<ChangeInfo> cb) {
    MessageInput input = MessageInput.create();
    input.message(emptyToNull(msg));
    call(project, id, "revert").post(input, cb);
}
#end_block

#method_before
public static void topic(int id, String topic, AsyncCallback<String> cb) {
    RestApi call = call(id, "topic");
    topic = emptyToNull(topic);
    if (topic != null) {
        TopicInput input = TopicInput.create();
        input.topic(topic);
        call.put(input, NativeString.unwrap(cb));
    } else {
        call.delete(NativeString.unwrap(cb));
    }
}
#method_after
public static void topic(@Nullable String project, int id, String topic, AsyncCallback<String> cb) {
    RestApi call = call(project, id, "topic");
    topic = emptyToNull(topic);
    if (topic != null) {
        TopicInput input = TopicInput.create();
        input.topic(topic);
        call.put(input, NativeString.unwrap(cb));
    } else {
        call.delete(NativeString.unwrap(cb));
    }
}
#end_block

#method_before
public static RestApi detail(int id) {
    return call(id, "detail");
}
#method_after
public static void detail(@Nullable String project, int id, AsyncCallback<ChangeInfo> cb) {
    detail(project, id).get(cb);
}
#end_block

#method_before
public static RestApi blame(PatchSet.Id id, String path, boolean base) {
    return revision(id).view("files").id(path).view("blame").addParameter("base", base);
}
#method_after
public static RestApi blame(@Nullable String project, PatchSet.Id id, String path, boolean base) {
    return revision(project, id).view("files").id(path).view("blame").addParameter("base", base);
}
#end_block

#method_before
public static RestApi actions(int id, String revision) {
    if (revision == null || revision.equals("")) {
        revision = "current";
    }
    return call(id, revision, "actions");
}
#method_after
public static RestApi actions(@Nullable String project, int id, String revision) {
    if (revision == null || revision.equals("")) {
        revision = "current";
    }
    return call(project, id, revision, "actions");
}
#end_block

#method_before
public static void deleteAssignee(int id, AsyncCallback<AccountInfo> cb) {
    change(id).view("assignee").delete(cb);
}
#method_after
public static void deleteAssignee(@Nullable String project, int id, AsyncCallback<AccountInfo> cb) {
    change(project, id).view("assignee").delete(cb);
}
#end_block

#method_before
public static void setAssignee(int id, String user, AsyncCallback<AccountInfo> cb) {
    AssigneeInput input = AssigneeInput.create();
    input.assignee(user);
    change(id).view("assignee").put(input, cb);
}
#method_after
public static void setAssignee(@Nullable String project, int id, String user, AsyncCallback<AccountInfo> cb) {
    AssigneeInput input = AssigneeInput.create();
    input.assignee(user);
    change(project, id).view("assignee").put(input, cb);
}
#end_block

#method_before
public static RestApi comments(int id) {
    return call(id, "comments");
}
#method_after
public static RestApi comments(@Nullable String project, int id) {
    return call(project, id, "comments");
}
#end_block

#method_before
public static RestApi drafts(int id) {
    return call(id, "drafts");
}
#method_after
public static RestApi drafts(@Nullable String project, int id) {
    return call(project, id, "drafts");
}
#end_block

#method_before
public static RestApi edit(int id) {
    return change(id).view("edit");
}
#method_after
public static void edit(@Nullable String project, int id, AsyncCallback<EditInfo> cb) {
    edit(project, id).get(cb);
}
#end_block

#method_before
public static void editWithFiles(int id, AsyncCallback<EditInfo> cb) {
    edit(id).addParameterTrue("list").get(cb);
}
#method_after
public static void editWithFiles(@Nullable String project, int id, AsyncCallback<EditInfo> cb) {
    edit(project, id).addParameterTrue("list").get(cb);
}
#end_block

#method_before
public static RestApi editWithCommands(int id) {
    return edit(id).addParameterTrue("download-commands");
}
#method_after
public static RestApi editWithCommands(@Nullable String project, int id) {
    return edit(project, id).addParameterTrue("download-commands");
}
#end_block

#method_before
public static void includedIn(int id, AsyncCallback<IncludedInInfo> cb) {
    call(id, "in").get(cb);
}
#method_after
public static void includedIn(@Nullable String project, int id, AsyncCallback<IncludedInInfo> cb) {
    call(project, id, "in").get(cb);
}
#end_block

#method_before
public static RestApi revision(PatchSet.Id id) {
    int cn = id.getParentKey().get();
    String revision = RevisionInfoCache.get(id);
    if (revision != null) {
        return revision(cn, revision);
    }
    return change(cn).view("revisions").id(id.get());
}
#method_after
public static RestApi revision(@Nullable String project, int id, String revision) {
    return change(project, id).view("revisions").id(revision);
}
#end_block

#method_before
public static RestApi reviewers(int id) {
    return change(id).view("reviewers");
}
#method_after
public static RestApi reviewers(@Nullable String project, int id) {
    return change(project, id).view("reviewers");
}
#end_block

#method_before
public static RestApi suggestReviewers(int id, String q, int n, boolean e) {
    RestApi api = change(id).view("suggest_reviewers").addParameter("n", n).addParameter("e", e);
    if (q != null) {
        api.addParameter("q", q);
    }
    return api;
}
#method_after
public static RestApi suggestReviewers(@Nullable String project, int id, String q, int n, boolean e) {
    RestApi api = change(project, id).view("suggest_reviewers").addParameter("n", n).addParameter("e", e);
    if (q != null) {
        api.addParameter("q", q);
    }
    return api;
}
#end_block

#method_before
public static RestApi vote(int id, int reviewer, String vote) {
    return reviewer(id, reviewer).view("votes").id(vote);
}
#method_after
public static RestApi vote(@Nullable String project, int id, int reviewer, String vote) {
    return reviewer(project, id, reviewer).view("votes").id(vote);
}
#end_block

#method_before
public static RestApi reviewer(int id, String reviewer) {
    return change(id).view("reviewers").id(reviewer);
}
#method_after
public static RestApi reviewer(@Nullable String project, int id, int reviewer) {
    return change(project, id).view("reviewers").id(reviewer);
}
#end_block

#method_before
public static RestApi hashtags(int changeId) {
    return change(changeId).view("hashtags");
}
#method_after
public static RestApi hashtags(@Nullable String project, int changeId) {
    return change(project, changeId).view("hashtags");
}
#end_block

#method_before
public static RestApi hashtag(int changeId, String hashtag) {
    return change(changeId).view("hashtags").id(hashtag);
}
#method_after
public static RestApi hashtag(@Nullable String project, int changeId, String hashtag) {
    return change(project, changeId).view("hashtags").id(hashtag);
}
#end_block

#method_before
public static void cherrypick(int id, String commit, String destination, String message, AsyncCallback<ChangeInfo> cb) {
    CherryPickInput cherryPickInput = CherryPickInput.create();
    cherryPickInput.setMessage(message);
    cherryPickInput.setDestination(destination);
    call(id, commit, "cherrypick").post(cherryPickInput, cb);
}
#method_after
public static void cherrypick(String project, int id, String commit, String destination, String message, AsyncCallback<ChangeInfo> cb) {
    CherryPickInput cherryPickInput = CherryPickInput.create();
    cherryPickInput.setMessage(message);
    cherryPickInput.setDestination(destination);
    call(project, id, commit, "cherrypick").post(cherryPickInput, cb);
}
#end_block

#method_before
public static void message(int id, String commit, String message, AsyncCallback<JavaScriptObject> cb) {
    CherryPickInput input = CherryPickInput.create();
    input.setMessage(message);
    call(id, commit, "message").post(input, cb);
}
#method_after
public static void message(@Nullable String project, int id, String commit, String message, AsyncCallback<JavaScriptObject> cb) {
    CherryPickInput input = CherryPickInput.create();
    input.setMessage(message);
    call(project, id, commit, "message").post(input, cb);
}
#end_block

#method_before
public static void submit(int id, String commit, AsyncCallback<SubmitInfo> cb) {
    JavaScriptObject in = JavaScriptObject.createObject();
    call(id, commit, "submit").post(in, cb);
}
#method_after
public static void submit(@Nullable String project, int id, String commit, AsyncCallback<SubmitInfo> cb) {
    JavaScriptObject in = JavaScriptObject.createObject();
    call(project, id, commit, "submit").post(in, cb);
}
#end_block

#method_before
public static void deleteEdit(int id, AsyncCallback<JavaScriptObject> cb) {
    edit(id).delete(cb);
}
#method_after
public static void deleteEdit(@Nullable String project, int id, AsyncCallback<JavaScriptObject> cb) {
    edit(project, id).delete(cb);
}
#end_block

#method_before
public static void publishEdit(int id, AsyncCallback<JavaScriptObject> cb) {
    JavaScriptObject in = JavaScriptObject.createObject();
    change(id).view("edit:publish").post(in, cb);
}
#method_after
public static void publishEdit(@Nullable String project, int id, AsyncCallback<JavaScriptObject> cb) {
    JavaScriptObject in = JavaScriptObject.createObject();
    change(project, id).view("edit:publish").post(in, cb);
}
#end_block

#method_before
public static void rebaseEdit(int id, AsyncCallback<JavaScriptObject> cb) {
    JavaScriptObject in = JavaScriptObject.createObject();
    change(id).view("edit:rebase").post(in, cb);
}
#method_after
public static void rebaseEdit(@Nullable String project, int id, AsyncCallback<JavaScriptObject> cb) {
    JavaScriptObject in = JavaScriptObject.createObject();
    change(project, id).view("edit:rebase").post(in, cb);
}
#end_block

#method_before
public static void rebase(int id, String commit, String base, AsyncCallback<ChangeInfo> cb) {
    RebaseInput rebaseInput = RebaseInput.create();
    rebaseInput.setBase(base);
    call(id, commit, "rebase").post(rebaseInput, cb);
}
#method_after
public static void rebase(@Nullable String project, int id, String commit, String base, AsyncCallback<ChangeInfo> cb) {
    RebaseInput rebaseInput = RebaseInput.create();
    rebaseInput.setBase(base);
    call(project, id, commit, "rebase").post(rebaseInput, cb);
}
#end_block

#method_before
private static RestApi call(int id, String commit, String action) {
    return change(id).view("revisions").id(commit).view(action);
}
#method_after
private static RestApi call(@Nullable String project, int id, String action) {
    return change(project, id).view(action);
}
#end_block

#method_before
public static RestApi change(int id) {
    // TODO Switch to triplet project~branch~id format in URI.
    return new RestApi("/changes/").id(String.valueOf(id));
}
#method_after
public static RestApi change(@Nullable String project, int id) {
    if (project == null) {
        return new RestApi("/changes/").id(String.valueOf(id));
    }
    return new RestApi("/changes/").id(project, id);
}
#end_block

#method_before
public static void commitWithLinks(int changeId, String revision, Callback<CommitInfo> callback) {
    revision(changeId, revision).view("commit").addParameterTrue("links").get(callback);
}
#method_after
public static void commitWithLinks(@Nullable String project, int changeId, String revision, Callback<CommitInfo> callback) {
    revision(project, changeId, revision).view("commit").addParameterTrue("links").get(callback);
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException, NoSuchChangeException {
    checkState(ctx.getOrder() == BatchUpdate.Order.DB_BEFORE_REPO, "must use DeleteChangeOp with DB_BEFORE_REPO");
    checkState(id == null, "cannot reuse DeleteChangeOp");
    id = ctx.getChange().getId();
    Collection<PatchSet> patchSets = psUtil.byChange(ctx.getDb(), ctx.getNotes());
    ensureDeletable(ctx, id, patchSets);
    // Cleaning up is only possible as long as the change and its elements are
    // still part of the database.
    cleanUpReferences(ctx, id, patchSets);
    deleteChangeElementsFromDb(ctx, id);
    ctx.deleteChange();
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException, NoSuchChangeException {
    checkState(ctx.getOrder() == Order.DB_BEFORE_REPO, "must use DeleteChangeOp with DB_BEFORE_REPO");
    checkState(id == null, "cannot reuse DeleteChangeOp");
    id = ctx.getChange().getId();
    Collection<PatchSet> patchSets = psUtil.byChange(ctx.getDb(), ctx.getNotes());
    ensureDeletable(ctx, id, patchSets);
    // Cleaning up is only possible as long as the change and its elements are
    // still part of the database.
    cleanUpReferences(ctx, id, patchSets);
    deleteChangeElementsFromDb(ctx, id);
    ctx.deleteChange();
    return true;
}
#end_block

#method_before
private void ensureDeletable(ChangeContext ctx, Change.Id id, Collection<PatchSet> patchSets) throws ResourceConflictException, MethodNotAllowedException, AuthException, IOException {
    Change.Status status = ctx.getChange().getStatus();
    if (status == Change.Status.MERGED) {
        throw new MethodNotAllowedException("Deleting merged change " + id + " is not allowed");
    }
    for (PatchSet patchSet : patchSets) {
        if (isPatchSetMerged(ctx, patchSet)) {
            throw new ResourceConflictException(String.format("Cannot delete change %s: patch set %s is already merged", id, patchSet.getPatchSetId()));
        }
    }
    if (!ctx.getControl().canDelete(ctx.getDb(), status)) {
        throw new AuthException("Deleting change " + id + " is not permitted");
    }
}
#method_after
private void ensureDeletable(ChangeContext ctx, Change.Id id, Collection<PatchSet> patchSets) throws ResourceConflictException, MethodNotAllowedException, IOException {
    Change.Status status = ctx.getChange().getStatus();
    if (status == Change.Status.MERGED) {
        throw new MethodNotAllowedException("Deleting merged change " + id + " is not allowed");
    }
    for (PatchSet patchSet : patchSets) {
        if (isPatchSetMerged(ctx, patchSet)) {
            throw new ResourceConflictException(String.format("Cannot delete change %s: patch set %s is already merged", id, patchSet.getPatchSetId()));
        }
    }
}
#end_block

#method_before
private boolean isPatchSetMerged(ChangeContext ctx, PatchSet patchSet) throws IOException {
    Repository repository = ctx.getRepository();
    Ref destinationRef = repository.exactRef(ctx.getChange().getDest().get());
    if (destinationRef == null) {
        return false;
    }
    RevWalk revWalk = ctx.getRevWalk();
    ObjectId objectId = ObjectId.fromString(patchSet.getRevision().get());
    RevCommit revCommit = revWalk.parseCommit(objectId);
    return IncludedInResolver.includedInOne(repository, revWalk, revCommit, Collections.singletonList(destinationRef));
}
#method_after
private boolean isPatchSetMerged(ChangeContext ctx, PatchSet patchSet) throws IOException {
    Optional<ObjectId> destId = ctx.getRepoView().getRef(ctx.getChange().getDest().get());
    if (!destId.isPresent()) {
        return false;
    }
    RevWalk revWalk = ctx.getRevWalk();
    ObjectId objectId = ObjectId.fromString(patchSet.getRevision().get());
    return revWalk.isMergedInto(revWalk.parseCommit(objectId), revWalk.parseCommit(destId.get()));
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws IOException {
    String prefix = new PatchSet.Id(id, 1).toRefName();
    prefix = prefix.substring(0, prefix.length() - 1);
    for (Ref ref : ctx.getRepository().getRefDatabase().getRefs(prefix).values()) {
        ctx.addRefUpdate(new ReceiveCommand(ref.getObjectId(), ObjectId.zeroId(), ref.getName()));
    }
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws IOException {
    String prefix = new PatchSet.Id(id, 1).toRefName();
    prefix = prefix.substring(0, prefix.length() - 1);
    for (Map.Entry<String, ObjectId> e : ctx.getRepoView().getRefs(prefix).entrySet()) {
        ctx.addRefUpdate(e.getValue(), ObjectId.zeroId(), prefix + e.getKey());
    }
}
#end_block

#method_before
void set(ChangeInfo info, String commit, ReplyAction action) {
    if (!info.hasPermittedLabels() || !info.status().isOpen()) {
        // Quick approve needs at least one label on an open change.
        setVisible(false);
        return;
    }
    if (info.revision(commit).isEdit()) {
        setVisible(false);
        return;
    }
    String qName = null;
    String qValueStr = null;
    short qValue = 0;
    int index = info.getMissingLabelIndex();
    if (index != -1) {
        LabelInfo label = Natives.asList(info.allLabels().values()).get(index);
        JsArrayString values = info.permittedValues(label.name());
        String s = values.get(values.length() - 1);
        short v = LabelInfo.parseValue(s);
        if (v > 0 && s.equals(label.maxValue())) {
            qName = label.name();
            qValueStr = s;
            qValue = v;
        }
    }
    if (qName != null) {
        changeId = info.legacyId();
        revision = commit;
        input = ReviewInput.create();
        input.drafts(DraftHandling.PUBLISH_ALL_REVISIONS);
        input.label(qName, qValue);
        replyAction = action;
        setText(qName + qValueStr);
        setVisible(true);
    } else {
        setVisible(false);
    }
}
#method_after
void set(ChangeInfo info, String commit, ReplyAction action) {
    if (!info.hasPermittedLabels() || !info.status().isOpen()) {
        // Quick approve needs at least one label on an open change.
        setVisible(false);
        return;
    }
    if (info.revision(commit).isEdit()) {
        setVisible(false);
        return;
    }
    String qName = null;
    String qValueStr = null;
    short qValue = 0;
    int index = info.getMissingLabelIndex();
    if (index != -1) {
        LabelInfo label = Natives.asList(info.allLabels().values()).get(index);
        JsArrayString values = info.permittedValues(label.name());
        String s = values.get(values.length() - 1);
        short v = LabelInfo.parseValue(s);
        if (v > 0 && s.equals(label.maxValue())) {
            qName = label.name();
            qValueStr = s;
            qValue = v;
        }
    }
    if (qName != null) {
        changeId = info.legacyId();
        project = info.projectNameKey();
        revision = commit;
        input = ReviewInput.create();
        input.drafts(DraftHandling.PUBLISH_ALL_REVISIONS);
        input.label(qName, qValue);
        replyAction = action;
        setText(qName + qValueStr);
        setVisible(true);
    } else {
        setVisible(false);
    }
}
#end_block

#method_before
@Override
public void onClick(ClickEvent event) {
    if (replyAction != null && replyAction.isVisible()) {
        replyAction.quickApprove(input);
    } else {
        ChangeApi.revision(changeId.get(), revision).view("review").post(input, new GerritCallback<ReviewInput>() {

            @Override
            public void onSuccess(ReviewInput result) {
                Gerrit.display(PageLinks.toChange(changeId));
            }
        });
    }
}
#method_after
@Override
public void onClick(ClickEvent event) {
    if (replyAction != null && replyAction.isVisible()) {
        replyAction.quickApprove(input);
    } else {
        ChangeApi.revision(project.get(), changeId.get(), revision).view("review").post(input, new GerritCallback<ReviewInput>() {

            @Override
            public void onSuccess(ReviewInput result) {
                Gerrit.display(PageLinks.toChange(project, changeId));
            }
        });
    }
}
#end_block

#method_before
public Optional<ChangeEdit> byChange(ChangeControl ctl) throws AuthException, IOException {
    if (!ctl.getUser().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser u = ctl.getUser().asIdentifiedUser();
    Change change = ctl.getChange();
    try (Repository repo = gitManager.openRepository(change.getProject())) {
        int n = change.currentPatchSetId().get();
        String[] refNames = new String[n];
        for (int i = n; i > 0; i--) {
            refNames[i - 1] = RefNames.refsEdit(u.getAccountId(), change.getId(), new PatchSet.Id(change.getId(), i));
        }
        Ref ref = repo.getRefDatabase().firstExactRef(refNames);
        if (ref == null) {
            return Optional.empty();
        }
        try (RevWalk rw = new RevWalk(repo)) {
            RevCommit commit = rw.parseCommit(ref.getObjectId());
            PatchSet basePs = getBasePatchSet(ctl, ref);
            return Optional.of(new ChangeEdit(u, change, ref, commit, basePs));
        }
    }
}
#method_after
public Optional<ChangeEdit> byChange(ChangeNotes notes) throws AuthException, IOException {
    return byChange(notes, userProvider.get());
}
#end_block

#method_before
public void publish(final ChangeEdit edit, NotifyHandling notify, ListMultimap<RecipientType, Account.Id> accountsToNotify) throws IOException, OrmException, RestApiException, UpdateException {
    Change change = edit.getChange();
    try (Repository repo = gitManager.openRepository(change.getProject());
        RevWalk rw = new RevWalk(repo);
        ObjectInserter oi = repo.newObjectInserter()) {
        PatchSet basePatchSet = edit.getBasePatchSet();
        if (!basePatchSet.getId().equals(change.currentPatchSetId())) {
            throw new ResourceConflictException("only edit for current patch set can be published");
        }
        RevCommit squashed = squashEdit(rw, oi, edit.getEditCommit(), basePatchSet);
        ChangeControl ctl = changeControlFactory.controlFor(db.get(), change, edit.getUser());
        PatchSet.Id psId = ChangeUtil.nextPatchSetId(repo, change.currentPatchSetId());
        PatchSetInserter inserter = patchSetInserterFactory.create(ctl, psId, squashed).setNotify(notify).setAccountsToNotify(accountsToNotify);
        StringBuilder message = new StringBuilder("Patch Set ").append(inserter.getPatchSetId().get()).append(": ");
        // Previously checked that the base patch set is the current patch set.
        ObjectId prior = ObjectId.fromString(basePatchSet.getRevision().get());
        ChangeKind kind = changeKindCache.getChangeKind(change.getProject(), repo, prior, squashed);
        if (kind == ChangeKind.NO_CODE_CHANGE) {
            message.append("Commit message was updated.");
            inserter.setDescription("Edit commit message");
        } else {
            message.append("Published edit on patch set ").append(basePatchSet.getPatchSetId()).append(".");
        }
        try (BatchUpdate bu = updateFactory.create(db.get(), change.getProject(), ctl.getUser(), TimeUtil.nowTs())) {
            bu.setRepository(repo, rw, oi);
            bu.addOp(change.getId(), inserter.setMessage(message.toString()));
            bu.addOp(change.getId(), new BatchUpdate.Op() {

                @Override
                public void updateRepo(RepoContext ctx) throws Exception {
                    deleteRef(ctx.getRepository(), edit);
                }
            });
            bu.execute();
        } catch (UpdateException e) {
            if (e.getCause() instanceof IOException && e.getMessage().equals(String.format("%s: Failed to delete ref %s: %s", IOException.class.getName(), edit.getRefName(), RefUpdate.Result.LOCK_FAILURE.name()))) {
                throw new ResourceConflictException("edit ref was updated");
            }
        }
        indexer.index(db.get(), inserter.getChange());
    }
}
#method_after
public void publish(BatchUpdate.Factory updateFactory, ChangeNotes notes, CurrentUser user, final ChangeEdit edit, NotifyHandling notify, ListMultimap<RecipientType, Account.Id> accountsToNotify) throws IOException, OrmException, RestApiException, UpdateException {
    Change change = edit.getChange();
    try (Repository repo = gitManager.openRepository(change.getProject());
        ObjectInserter oi = repo.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        PatchSet basePatchSet = edit.getBasePatchSet();
        if (!basePatchSet.getId().equals(change.currentPatchSetId())) {
            throw new ResourceConflictException("only edit for current patch set can be published");
        }
        RevCommit squashed = squashEdit(rw, oi, edit.getEditCommit(), basePatchSet);
        PatchSet.Id psId = ChangeUtil.nextPatchSetId(repo, change.currentPatchSetId());
        PatchSetInserter inserter = patchSetInserterFactory.create(notes, psId, squashed).setNotify(notify).setAccountsToNotify(accountsToNotify);
        StringBuilder message = new StringBuilder("Patch Set ").append(inserter.getPatchSetId().get()).append(": ");
        // Previously checked that the base patch set is the current patch set.
        ObjectId prior = ObjectId.fromString(basePatchSet.getRevision().get());
        ChangeKind kind = changeKindCache.getChangeKind(change.getProject(), rw, repo.getConfig(), prior, squashed);
        if (kind == ChangeKind.NO_CODE_CHANGE) {
            message.append("Commit message was updated.");
            inserter.setDescription("Edit commit message");
        } else {
            message.append("Published edit on patch set ").append(basePatchSet.getPatchSetId()).append(".");
        }
        try (BatchUpdate bu = updateFactory.create(db.get(), change.getProject(), user, TimeUtil.nowTs())) {
            bu.setRepository(repo, rw, oi);
            bu.addOp(change.getId(), inserter.setMessage(message.toString()));
            bu.addOp(change.getId(), new BatchUpdateOp() {

                @Override
                public void updateRepo(RepoContext ctx) throws Exception {
                    ctx.addRefUpdate(edit.getEditCommit().copy(), ObjectId.zeroId(), edit.getRefName());
                }
            });
            bu.execute();
        }
    }
}
#end_block

#method_before
private PatchSet getBasePatchSet(ChangeControl ctl, Ref ref) throws IOException {
    try {
        int pos = ref.getName().lastIndexOf("/");
        checkArgument(pos > 0, "invalid edit ref: %s", ref.getName());
        String psId = ref.getName().substring(pos + 1);
        return psUtil.get(db.get(), ctl.getNotes(), new PatchSet.Id(ctl.getId(), Integer.parseInt(psId)));
    } catch (OrmException | NumberFormatException e) {
        throw new IOException(e);
    }
}
#method_after
private PatchSet getBasePatchSet(ChangeNotes notes, Ref ref) throws IOException {
    try {
        int pos = ref.getName().lastIndexOf("/");
        checkArgument(pos > 0, "invalid edit ref: %s", ref.getName());
        String psId = ref.getName().substring(pos + 1);
        return psUtil.get(db.get(), notes, new PatchSet.Id(notes.getChange().getId(), Integer.parseInt(psId)));
    } catch (OrmException | NumberFormatException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
private static void deleteRef(Repository repo, ChangeEdit edit) throws IOException {
    String refName = edit.getRefName();
    RefUpdate ru = repo.updateRef(refName, true);
    ru.setExpectedOldObjectId(edit.getRef().getObjectId());
    ru.setForceUpdate(true);
    RefUpdate.Result result = ru.delete();
    switch(result) {
        case FORCED:
        case NEW:
        case NO_CHANGE:
            break;
        case FAST_FORWARD:
        case IO_FAILURE:
        case LOCK_FAILURE:
        case NOT_ATTEMPTED:
        case REJECTED:
        case REJECTED_CURRENT_BRANCH:
        case RENAMED:
        default:
            throw new IOException(String.format("Failed to delete ref %s: %s", refName, result));
    }
}
#method_after
private static void deleteRef(Repository repo, ChangeEdit edit) throws IOException {
    String refName = edit.getRefName();
    RefUpdate ru = repo.updateRef(refName, true);
    ru.setExpectedOldObjectId(edit.getEditCommit());
    ru.setForceUpdate(true);
    RefUpdate.Result result = ru.delete();
    switch(result) {
        case FORCED:
        case NEW:
        case NO_CHANGE:
            break;
        case FAST_FORWARD:
        case IO_FAILURE:
        case LOCK_FAILURE:
        case NOT_ATTEMPTED:
        case REJECTED:
        case REJECTED_CURRENT_BRANCH:
        case RENAMED:
        case REJECTED_MISSING_OBJECT:
        case REJECTED_OTHER_REASON:
        default:
            throw new IOException(String.format("Failed to delete ref %s: %s", refName, result));
    }
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws MergeConflictException, InvalidChangeOperationException, RestApiException, IOException, OrmException, NoSuchChangeException {
    // Ok that originalPatchSet was not read in a transaction, since we just
    // need its revision.
    RevId oldRev = originalPatchSet.getRevision();
    RevWalk rw = ctx.getRevWalk();
    RevCommit original = rw.parseCommit(ObjectId.fromString(oldRev.get()));
    rw.parseBody(original);
    RevCommit baseCommit;
    if (baseCommitish != null) {
        baseCommit = rw.parseCommit(ctx.getRepository().resolve(baseCommitish));
    } else {
        baseCommit = rw.parseCommit(rebaseUtil.findBaseRevision(originalPatchSet, ctl.getChange().getDest(), ctx.getRepository(), ctx.getRevWalk()));
    }
    String newCommitMessage;
    if (detailedCommitMessage) {
        rw.parseBody(baseCommit);
        newCommitMessage = newMergeUtil().createCommitMessageOnSubmit(original, baseCommit, ctl, originalPatchSet.getId());
    } else {
        newCommitMessage = original.getFullMessage();
    }
    rebasedCommit = rebaseCommit(ctx, original, baseCommit, newCommitMessage);
    RevId baseRevId = new RevId((baseCommitish != null) ? baseCommitish : ObjectId.toString(baseCommit.getId()));
    Base base = rebaseUtil.parseBase(new RevisionResource(changeResourceFactory.create(ctl), originalPatchSet), baseRevId.get());
    rebasedPatchSetId = ChangeUtil.nextPatchSetId(ctx.getRepository(), ctl.getChange().currentPatchSetId());
    patchSetInserter = patchSetInserterFactory.create(ctl, rebasedPatchSetId, rebasedCommit).setDescription("Rebase").setNotify(NotifyHandling.NONE).setFireRevisionCreated(fireRevisionCreated).setCopyApprovals(copyApprovals).setCheckAddPatchSetPermission(checkAddPatchSetPermission);
    if (postMessage) {
        patchSetInserter.setMessage("Patch Set " + rebasedPatchSetId.get() + ": Patch Set " + originalPatchSet.getId().get() + " was rebased");
    }
    if (base != null) {
        patchSetInserter.setGroups(base.patchSet().getGroups());
    }
    if (validate != null) {
        patchSetInserter.setValidatePolicy(validate);
    }
    patchSetInserter.updateRepo(ctx);
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws MergeConflictException, InvalidChangeOperationException, RestApiException, IOException, OrmException, NoSuchChangeException, PermissionBackendException {
    // Ok that originalPatchSet was not read in a transaction, since we just
    // need its revision.
    RevId oldRev = originalPatchSet.getRevision();
    RevWalk rw = ctx.getRevWalk();
    RevCommit original = rw.parseCommit(ObjectId.fromString(oldRev.get()));
    rw.parseBody(original);
    RevCommit baseCommit = rw.parseCommit(baseCommitId);
    CurrentUser changeOwner = identifiedUserFactory.create(notes.getChange().getOwner());
    String newCommitMessage;
    if (detailedCommitMessage) {
        rw.parseBody(baseCommit);
        newCommitMessage = newMergeUtil().createCommitMessageOnSubmit(original, baseCommit, notes, changeOwner, originalPatchSet.getId());
    } else {
        newCommitMessage = original.getFullMessage();
    }
    rebasedCommit = rebaseCommit(ctx, original, baseCommit, newCommitMessage);
    Base base = rebaseUtil.parseBase(new RevisionResource(changeResourceFactory.create(notes, changeOwner), originalPatchSet), baseCommitId.name());
    rebasedPatchSetId = ChangeUtil.nextPatchSetIdFromChangeRefsMap(ctx.getRepoView().getRefs(originalPatchSet.getId().getParentKey().toRefPrefix()), notes.getChange().currentPatchSetId());
    patchSetInserter = patchSetInserterFactory.create(notes, rebasedPatchSetId, rebasedCommit).setDescription("Rebase").setNotify(NotifyHandling.NONE).setFireRevisionCreated(fireRevisionCreated).setCopyApprovals(copyApprovals).setCheckAddPatchSetPermission(checkAddPatchSetPermission).setValidate(validate);
    if (postMessage) {
        patchSetInserter.setMessage("Patch Set " + rebasedPatchSetId.get() + ": Patch Set " + originalPatchSet.getId().get() + " was rebased");
    }
    if (base != null) {
        patchSetInserter.setGroups(base.patchSet().getGroups());
    }
    patchSetInserter.updateRepo(ctx);
}
#end_block

#method_before
private MergeUtil newMergeUtil() {
    ProjectState project = ctl.getProjectControl().getProjectState();
    return forceContentMerge ? mergeUtilFactory.create(project, true) : mergeUtilFactory.create(project);
}
#method_after
private MergeUtil newMergeUtil() throws IOException {
    ProjectState project = projectCache.checkedGet(notes.getProjectName());
    return forceContentMerge ? mergeUtilFactory.create(project, true) : mergeUtilFactory.create(project);
}
#end_block

#method_before
private RevCommit rebaseCommit(RepoContext ctx, RevCommit original, ObjectId base, String commitMessage) throws ResourceConflictException, IOException {
    RevCommit parentCommit = original.getParent(0);
    if (base.equals(parentCommit)) {
        throw new ResourceConflictException("Change is already up to date.");
    }
    ThreeWayMerger merger = newMergeUtil().newThreeWayMerger(ctx.getRepository(), ctx.getInserter());
    merger.setBase(parentCommit);
    merger.merge(original, base);
    if (merger.getResultTreeId() == null) {
        throw new MergeConflictException("The change could not be rebased due to a conflict during merge.");
    }
    CommitBuilder cb = new CommitBuilder();
    cb.setTreeId(merger.getResultTreeId());
    cb.setParentId(base);
    cb.setAuthor(original.getAuthorIdent());
    cb.setMessage(commitMessage);
    if (committerIdent != null) {
        cb.setCommitter(committerIdent);
    } else {
        cb.setCommitter(ctx.getIdentifiedUser().newCommitterIdent(ctx.getWhen(), ctx.getTimeZone()));
    }
    ObjectId objectId = ctx.getInserter().insert(cb);
    ctx.getInserter().flush();
    return ctx.getRevWalk().parseCommit(objectId);
}
#method_after
private RevCommit rebaseCommit(RepoContext ctx, RevCommit original, ObjectId base, String commitMessage) throws ResourceConflictException, IOException {
    RevCommit parentCommit = original.getParent(0);
    if (base.equals(parentCommit)) {
        throw new ResourceConflictException("Change is already up to date.");
    }
    ThreeWayMerger merger = newMergeUtil().newThreeWayMerger(ctx.getInserter(), ctx.getRepoView().getConfig());
    merger.setBase(parentCommit);
    merger.merge(original, base);
    if (merger.getResultTreeId() == null) {
        throw new MergeConflictException("The change could not be rebased due to a conflict during merge.");
    }
    CommitBuilder cb = new CommitBuilder();
    cb.setTreeId(merger.getResultTreeId());
    cb.setParentId(base);
    cb.setAuthor(original.getAuthorIdent());
    cb.setMessage(commitMessage);
    if (committerIdent != null) {
        cb.setCommitter(committerIdent);
    } else {
        cb.setCommitter(ctx.getIdentifiedUser().newCommitterIdent(ctx.getWhen(), ctx.getTimeZone()));
    }
    if (matchAuthorToCommitterDate) {
        cb.setAuthor(new PersonIdent(cb.getAuthor(), cb.getCommitter().getWhen(), cb.getCommitter().getTimeZone()));
    }
    ObjectId objectId = ctx.getInserter().insert(cb);
    ctx.getInserter().flush();
    return ctx.getRevWalk().parseCommit(objectId);
}
#end_block

#method_before
private ChangeJson changeJson() {
    return changeJsonFactory.create(EnumSet.noneOf(ListChangesOption.class));
}
#method_after
private ChangeJson changeJson() {
    return changeJsonFactory.noOptions();
}
#end_block

#method_before
public ChangeInfo addChangeActions(ChangeInfo to, ChangeControl ctl) {
    List<ActionVisitor> visitors = visitors();
    to.actions = toActionMap(ctl, visitors, copy(visitors, to));
    return to;
}
#method_after
public ChangeInfo addChangeActions(ChangeInfo to, ChangeNotes notes) {
    List<ActionVisitor> visitors = visitors();
    to.actions = toActionMap(notes, visitors, copy(visitors, to));
    return to;
}
#end_block

#method_before
private ChangeInfo copy(List<ActionVisitor> visitors, ChangeInfo changeInfo) {
    if (visitors.isEmpty()) {
        return null;
    }
    // Include all fields from ChangeJson#toChangeInfo that are not protected by
    // any ListChangesOptions.
    ChangeInfo copy = new ChangeInfo();
    copy.project = changeInfo.project;
    copy.branch = changeInfo.branch;
    copy.topic = changeInfo.topic;
    copy.assignee = changeInfo.assignee;
    copy.hashtags = changeInfo.hashtags;
    copy.changeId = changeInfo.changeId;
    copy.submitType = changeInfo.submitType;
    copy.mergeable = changeInfo.mergeable;
    copy.insertions = changeInfo.insertions;
    copy.deletions = changeInfo.deletions;
    copy.subject = changeInfo.subject;
    copy.status = changeInfo.status;
    copy.owner = changeInfo.owner;
    copy.created = changeInfo.created;
    copy.updated = changeInfo.updated;
    copy._number = changeInfo._number;
    copy.starred = changeInfo.starred;
    copy.stars = changeInfo.stars;
    copy.submitted = changeInfo.submitted;
    copy.id = changeInfo.id;
    return copy;
}
#method_after
private ChangeInfo copy(List<ActionVisitor> visitors, ChangeInfo changeInfo) {
    if (visitors.isEmpty()) {
        return null;
    }
    // Include all fields from ChangeJson#toChangeInfo that are not protected by
    // any ListChangesOptions.
    ChangeInfo copy = new ChangeInfo();
    copy.project = changeInfo.project;
    copy.branch = changeInfo.branch;
    copy.topic = changeInfo.topic;
    copy.assignee = changeInfo.assignee;
    copy.hashtags = changeInfo.hashtags;
    copy.changeId = changeInfo.changeId;
    copy.submitType = changeInfo.submitType;
    copy.mergeable = changeInfo.mergeable;
    copy.insertions = changeInfo.insertions;
    copy.deletions = changeInfo.deletions;
    copy.isPrivate = changeInfo.isPrivate;
    copy.subject = changeInfo.subject;
    copy.status = changeInfo.status;
    copy.owner = changeInfo.owner;
    copy.created = changeInfo.created;
    copy.updated = changeInfo.updated;
    copy._number = changeInfo._number;
    copy.starred = changeInfo.starred;
    copy.stars = changeInfo.stars;
    copy.submitted = changeInfo.submitted;
    copy.submitter = changeInfo.submitter;
    copy.id = changeInfo.id;
    return copy;
}
#end_block

#method_before
private Map<String, ActionInfo> toActionMap(RevisionResource rsrc, List<ActionVisitor> visitors, ChangeInfo changeInfo, RevisionInfo revisionInfo) {
    if (!rsrc.getControl().getUser().isIdentifiedUser()) {
        return ImmutableMap.of();
    }
    Map<String, ActionInfo> out = new LinkedHashMap<>();
    Provider<CurrentUser> userProvider = Providers.of(rsrc.getControl().getUser());
    ACTION: for (UiAction.Description d : UiActions.from(revisions, rsrc, userProvider)) {
        ActionInfo actionInfo = new ActionInfo(d);
        for (ActionVisitor visitor : visitors) {
            if (!visitor.visit(d.getId(), actionInfo, changeInfo, revisionInfo)) {
                continue ACTION;
            }
        }
        out.put(d.getId(), actionInfo);
    }
    return out;
}
#method_after
private Map<String, ActionInfo> toActionMap(ChangeNotes notes, List<ActionVisitor> visitors, ChangeInfo changeInfo) {
    CurrentUser user = userProvider.get();
    Map<String, ActionInfo> out = new LinkedHashMap<>();
    if (!user.isIdentifiedUser()) {
        return out;
    }
    Iterable<UiAction.Description> descs = uiActions.from(changeViews, changeResourceFactory.create(notes, user));
    // The followup action is a client-side only operation that does not
    // have a server side handler. It must be manually registered into the
    // resulting action map.
    Status status = notes.getChange().getStatus();
    if (status.isOpen() || status.equals(Status.MERGED)) {
        UiAction.Description descr = new UiAction.Description();
        PrivateInternals_UiActionDescription.setId(descr, "followup");
        PrivateInternals_UiActionDescription.setMethod(descr, "POST");
        descr.setTitle("Create follow-up change");
        descr.setLabel("Follow-Up");
        descs = Iterables.concat(descs, Collections.singleton(descr));
    }
    ACTION: for (UiAction.Description d : descs) {
        ActionInfo actionInfo = new ActionInfo(d);
        for (ActionVisitor visitor : visitors) {
            if (!visitor.visit(d.getId(), actionInfo, changeInfo)) {
                continue ACTION;
            }
        }
        out.put(d.getId(), actionInfo);
    }
    return out;
}
#end_block

#method_before
private Map<String, ActionInfo> toActionMap(RevisionResource rsrc, List<ActionVisitor> visitors, ChangeInfo changeInfo, RevisionInfo revisionInfo) {
    if (!rsrc.getControl().getUser().isIdentifiedUser()) {
        return ImmutableMap.of();
    }
    Map<String, ActionInfo> out = new LinkedHashMap<>();
    Provider<CurrentUser> userProvider = Providers.of(rsrc.getControl().getUser());
    ACTION: for (UiAction.Description d : UiActions.from(revisions, rsrc, userProvider)) {
        ActionInfo actionInfo = new ActionInfo(d);
        for (ActionVisitor visitor : visitors) {
            if (!visitor.visit(d.getId(), actionInfo, changeInfo, revisionInfo)) {
                continue ACTION;
            }
        }
        out.put(d.getId(), actionInfo);
    }
    return out;
}
#method_after
private Map<String, ActionInfo> toActionMap(RevisionResource rsrc, List<ActionVisitor> visitors, ChangeInfo changeInfo, RevisionInfo revisionInfo) {
    if (!rsrc.getUser().isIdentifiedUser()) {
        return ImmutableMap.of();
    }
    Map<String, ActionInfo> out = new LinkedHashMap<>();
    ACTION: for (UiAction.Description d : uiActions.from(revisions, rsrc)) {
        ActionInfo actionInfo = new ActionInfo(d);
        for (ActionVisitor visitor : visitors) {
            if (!visitor.visit(d.getId(), actionInfo, changeInfo, revisionInfo)) {
                continue ACTION;
            }
        }
        out.put(d.getId(), actionInfo);
    }
    return out;
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(ChangeResource rsrc) {
    Change.Status status = rsrc.getChange().getStatus();
    ChangeControl changeControl = rsrc.getControl();
    boolean visible = isActionAllowed(changeControl) && changeControl.canDelete(db.get(), status);
    return new UiAction.Description().setLabel("Delete").setTitle("Delete change " + rsrc.getId()).setVisible(visible);
}
#method_after
@Override
public UiAction.Description getDescription(ChangeResource rsrc) {
    Change.Status status = rsrc.getChange().getStatus();
    PermissionBackend.ForChange perm = rsrc.permissions().database(db);
    return new UiAction.Description().setLabel("Delete").setTitle("Delete change " + rsrc.getId()).setVisible(and(couldDeleteWhenIn(status), perm.testCond(ChangePermission.DELETE)));
}
#end_block

#method_before
@Override
public RevisionApi revision(String id) throws RestApiException {
    try {
        return revisionApi.create(revisions.parse(change, IdString.fromDecoded(id)));
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot parse revision", e);
    }
}
#method_after
@Override
public RevisionApi revision(String id) throws RestApiException {
    try {
        return revisionApi.create(revisions.parse(change, IdString.fromDecoded(id)));
    } catch (Exception e) {
        throw asRestApiException("Cannot parse revision", e);
    }
}
#end_block

#method_before
@Override
public ReviewerApi reviewer(String id) throws RestApiException {
    try {
        return reviewerApi.create(reviewers.parse(change, IdString.fromDecoded(id)));
    } catch (OrmException e) {
        throw new RestApiException("Cannot parse reviewer", e);
    }
}
#method_after
@Override
public ReviewerApi reviewer(String id) throws RestApiException {
    try {
        return reviewerApi.create(reviewers.parse(change, IdString.fromDecoded(id)));
    } catch (Exception e) {
        throw asRestApiException("Cannot parse reviewer", e);
    }
}
#end_block

#method_before
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.apply(change, in);
    } catch (OrmException | UpdateException e) {
        throw new RestApiException("Cannot abandon change", e);
    }
}
#method_after
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.apply(change, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot abandon change", e);
    }
}
#end_block

#method_before
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.apply(change, in);
    } catch (OrmException | UpdateException e) {
        throw new RestApiException("Cannot restore change", e);
    }
}
#method_after
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.apply(change, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot restore change", e);
    }
}
#end_block

#method_before
@Override
public void move(MoveInput in) throws RestApiException {
    try {
        move.apply(change, in);
    } catch (OrmException | UpdateException e) {
        throw new RestApiException("Cannot move change", e);
    }
}
#method_after
@Override
public void move(MoveInput in) throws RestApiException {
    try {
        move.apply(change, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot move change", e);
    }
}
#end_block

#method_before
@Override
public ChangeApi revert(RevertInput in) throws RestApiException {
    try {
        return changeApi.id(revert.apply(change, in)._number);
    } catch (OrmException | IOException | UpdateException e) {
        throw new RestApiException("Cannot revert change", e);
    }
}
#method_after
@Override
public ChangeApi revert(RevertInput in) throws RestApiException {
    try {
        return changeApi.id(revert.apply(change, in)._number);
    } catch (Exception e) {
        throw asRestApiException("Cannot revert change", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo createMergePatchSet(MergePatchSetInput in) throws RestApiException {
    try {
        return updateByMerge.apply(change, in).value();
    } catch (IOException | UpdateException | InvalidChangeOperationException | OrmException e) {
        throw new RestApiException("Cannot update change by merge", e);
    }
}
#method_after
@Override
public ChangeInfo createMergePatchSet(MergePatchSetInput in) throws RestApiException {
    try {
        return updateByMerge.apply(change, in).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot update change by merge", e);
    }
}
#end_block

#method_before
@Override
public SubmittedTogetherInfo submittedTogether(EnumSet<ListChangesOption> listOptions, EnumSet<SubmittedTogetherOption> submitOptions) throws RestApiException {
    try {
        return submittedTogether.get().addListChangesOption(listOptions).addSubmittedTogetherOption(submitOptions).applyInfo(change);
    } catch (IOException | OrmException e) {
        throw new RestApiException("Cannot query submittedTogether", e);
    }
}
#method_after
@Override
public SubmittedTogetherInfo submittedTogether(EnumSet<ListChangesOption> listOptions, EnumSet<SubmittedTogetherOption> submitOptions) throws RestApiException {
    try {
        return submittedTogether.get().addListChangesOption(listOptions).addSubmittedTogetherOption(submitOptions).applyInfo(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot query submittedTogether", e);
    }
}
#end_block

#method_before
@Override
public void delete() throws RestApiException {
    try {
        deleteChange.apply(change, null);
    } catch (UpdateException e) {
        throw new RestApiException("Cannot delete change", e);
    }
}
#method_after
@Override
public void delete() throws RestApiException {
    try {
        deleteChange.apply(change, null);
    } catch (Exception e) {
        throw asRestApiException("Cannot delete change", e);
    }
}
#end_block

#method_before
@Override
public void topic(String topic) throws RestApiException {
    PutTopic.Input in = new PutTopic.Input();
    in.topic = topic;
    try {
        putTopic.apply(change, in);
    } catch (UpdateException e) {
        throw new RestApiException("Cannot set topic", e);
    }
}
#method_after
@Override
public void topic(String topic) throws RestApiException {
    PutTopic.Input in = new PutTopic.Input();
    in.topic = topic;
    try {
        putTopic.apply(change, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot set topic", e);
    }
}
#end_block

#method_before
@Override
public IncludedInInfo includedIn() throws RestApiException {
    try {
        return includedIn.apply(change);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Could not extract IncludedIn data", e);
    }
}
#method_after
@Override
public IncludedInInfo includedIn() throws RestApiException {
    try {
        return includedIn.apply(change);
    } catch (Exception e) {
        throw asRestApiException("Could not extract IncludedIn data", e);
    }
}
#end_block

#method_before
@Override
public void addReviewer(String reviewer) throws RestApiException {
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = reviewer;
    addReviewer(in);
}
#method_after
@Override
public AddReviewerResult addReviewer(String reviewer) throws RestApiException {
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = reviewer;
    return addReviewer(in);
}
#end_block

#method_before
@Override
public void addReviewer(AddReviewerInput in) throws RestApiException {
    try {
        postReviewers.apply(change, in);
    } catch (OrmException | IOException | UpdateException e) {
        throw new RestApiException("Cannot add change reviewer", e);
    }
}
#method_after
@Override
public AddReviewerResult addReviewer(AddReviewerInput in) throws RestApiException {
    try {
        return postReviewers.apply(change, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot add change reviewer", e);
    }
}
#end_block

#method_before
private List<SuggestedReviewerInfo> suggestReviewers(SuggestedReviewersRequest r) throws RestApiException {
    try {
        suggestReviewers.setQuery(r.getQuery());
        suggestReviewers.setLimit(r.getLimit());
        return suggestReviewers.apply(change);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot retrieve suggested reviewers", e);
    }
}
#method_after
private List<SuggestedReviewerInfo> suggestReviewers(SuggestedReviewersRequest r) throws RestApiException {
    try {
        suggestReviewers.setQuery(r.getQuery());
        suggestReviewers.setLimit(r.getLimit());
        return suggestReviewers.apply(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve suggested reviewers", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo get(EnumSet<ListChangesOption> s) throws RestApiException {
    try {
        return changeJson.create(s).format(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve change", e);
    }
}
#method_after
@Override
public ChangeInfo get(EnumSet<ListChangesOption> s) throws RestApiException {
    try {
        return changeJson.create(s).format(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve change", e);
    }
}
#end_block

#method_before
@Override
public void setHashtags(HashtagsInput input) throws RestApiException {
    try {
        postHashtags.apply(change, input);
    } catch (RestApiException | UpdateException e) {
        throw new RestApiException("Cannot post hashtags", e);
    }
}
#method_after
@Override
public void setHashtags(HashtagsInput input) throws RestApiException {
    try {
        postHashtags.apply(change, input);
    } catch (Exception e) {
        throw asRestApiException("Cannot post hashtags", e);
    }
}
#end_block

#method_before
@Override
public Set<String> getHashtags() throws RestApiException {
    try {
        return getHashtags.apply(change).value();
    } catch (IOException | OrmException e) {
        throw new RestApiException("Cannot get hashtags", e);
    }
}
#method_after
@Override
public Set<String> getHashtags() throws RestApiException {
    try {
        return getHashtags.apply(change).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot get hashtags", e);
    }
}
#end_block

#method_before
@Override
public AccountInfo setAssignee(AssigneeInput input) throws RestApiException {
    try {
        return putAssignee.apply(change, input).value();
    } catch (UpdateException | IOException | OrmException e) {
        throw new RestApiException("Cannot set assignee", e);
    }
}
#method_after
@Override
public AccountInfo setAssignee(AssigneeInput input) throws RestApiException {
    try {
        return putAssignee.apply(change, input);
    } catch (Exception e) {
        throw asRestApiException("Cannot set assignee", e);
    }
}
#end_block

#method_before
@Override
public AccountInfo getAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = getAssignee.apply(change);
        return r.isNone() ? null : r.value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot get assignee", e);
    }
}
#method_after
@Override
public AccountInfo getAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = getAssignee.apply(change);
        return r.isNone() ? null : r.value();
    } catch (Exception e) {
        throw asRestApiException("Cannot get assignee", e);
    }
}
#end_block

#method_before
@Override
public List<AccountInfo> getPastAssignees() throws RestApiException {
    try {
        return getPastAssignees.apply(change).value();
    } catch (Exception e) {
        throw new RestApiException("Cannot get past assignees", e);
    }
}
#method_after
@Override
public List<AccountInfo> getPastAssignees() throws RestApiException {
    try {
        return getPastAssignees.apply(change).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot get past assignees", e);
    }
}
#end_block

#method_before
@Override
public AccountInfo deleteAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = deleteAssignee.apply(change, null);
        return r.isNone() ? null : r.value();
    } catch (UpdateException | OrmException e) {
        throw new RestApiException("Cannot delete assignee", e);
    }
}
#method_after
@Override
public AccountInfo deleteAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = deleteAssignee.apply(change, null);
        return r.isNone() ? null : r.value();
    } catch (Exception e) {
        throw asRestApiException("Cannot delete assignee", e);
    }
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> comments() throws RestApiException {
    try {
        return listComments.apply(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get comments", e);
    }
}
#method_after
@Override
public Map<String, List<CommentInfo>> comments() throws RestApiException {
    try {
        return listComments.apply(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot get comments", e);
    }
}
#end_block

#method_before
@Override
public Map<String, List<RobotCommentInfo>> robotComments() throws RestApiException {
    try {
        return listChangeRobotComments.apply(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get robot comments", e);
    }
}
#method_after
@Override
public Map<String, List<RobotCommentInfo>> robotComments() throws RestApiException {
    try {
        return listChangeRobotComments.apply(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot get robot comments", e);
    }
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> drafts() throws RestApiException {
    try {
        return listDrafts.apply(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get drafts", e);
    }
}
#method_after
@Override
public Map<String, List<CommentInfo>> drafts() throws RestApiException {
    try {
        return listDrafts.apply(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot get drafts", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo check() throws RestApiException {
    try {
        return check.apply(change).value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot check change", e);
    }
}
#method_after
@Override
public ChangeInfo check() throws RestApiException {
    try {
        return check.apply(change).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot check change", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo check(FixInput fix) throws RestApiException {
    try {
        return check.apply(change, fix).value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot check change", e);
    }
}
#method_after
@Override
public ChangeInfo check(FixInput fix) throws RestApiException {
    try {
        // ConsistencyChecker.
        return check.apply(change, fix).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot check change", e);
    }
}
#end_block

#method_before
@Override
public void index() throws RestApiException {
    try {
        index.apply(change, new Index.Input());
    } catch (IOException | OrmException e) {
        throw new RestApiException("Cannot index change", e);
    }
}
#method_after
@Override
public void index() throws RestApiException {
    try {
        index.apply(change, new Index.Input());
    } catch (Exception e) {
        throw asRestApiException("Cannot index change", e);
    }
}
#end_block

#method_before
@Override
protected void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    // If there is only one parent, a cherry-pick can be done by taking the
    // delta relative to that one parent and redoing that on the current merge
    // tip.
    args.rw.parseBody(toMerge);
    psId = ChangeUtil.nextPatchSetId(args.repo, toMerge.change().currentPatchSetId());
    RevCommit mergeTip = args.mergeTip.getCurrentTip();
    args.rw.parseBody(mergeTip);
    String cherryPickCmtMsg = args.mergeUtil.createCommitMessageOnSubmit(toMerge, mergeTip);
    PersonIdent committer = args.caller.newCommitterIdent(ctx.getWhen(), args.serverIdent.getTimeZone());
    try {
        newCommit = args.mergeUtil.createCherryPickFromCommit(args.repo, args.inserter, args.mergeTip.getCurrentTip(), toMerge, committer, cherryPickCmtMsg, args.rw, 0, false);
    } catch (MergeConflictException mce) {
        // Keep going in the case of a single merge failure; the goal is to
        // cherry-pick as many commits as possible.
        toMerge.setStatusCode(CommitMergeStatus.PATH_CONFLICT);
        return;
    } catch (MergeIdenticalTreeException mie) {
        toMerge.setStatusCode(SKIPPED_IDENTICAL_TREE);
        return;
    }
    // Initial copy doesn't have new patch set ID since change hasn't been
    // updated yet.
    newCommit = amendGitlink(newCommit);
    newCommit.copyFrom(toMerge);
    newCommit.setPatchsetId(psId);
    newCommit.setStatusCode(CommitMergeStatus.CLEAN_PICK);
    args.mergeTip.moveTipTo(newCommit, newCommit);
    args.commitStatus.put(newCommit);
    ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), newCommit, psId.toRefName()));
    patchSetInfo = args.patchSetInfoFactory.get(ctx.getRevWalk(), newCommit, psId);
}
#method_after
@Override
protected void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException, OrmException {
    // If there is only one parent, a cherry-pick can be done by taking the
    // delta relative to that one parent and redoing that on the current merge
    // tip.
    args.rw.parseBody(toMerge);
    psId = ChangeUtil.nextPatchSetIdFromChangeRefsMap(ctx.getRepoView().getRefs(getId().toRefPrefix()), toMerge.change().currentPatchSetId());
    RevCommit mergeTip = args.mergeTip.getCurrentTip();
    args.rw.parseBody(mergeTip);
    String cherryPickCmtMsg = args.mergeUtil.createCommitMessageOnSubmit(toMerge, mergeTip);
    PersonIdent committer = args.caller.newCommitterIdent(ctx.getWhen(), args.serverIdent.getTimeZone());
    try {
        newCommit = args.mergeUtil.createCherryPickFromCommit(ctx.getInserter(), ctx.getRepoView().getConfig(), args.mergeTip.getCurrentTip(), toMerge, committer, cherryPickCmtMsg, args.rw, 0, false);
    } catch (MergeConflictException mce) {
        // Keep going in the case of a single merge failure; the goal is to
        // cherry-pick as many commits as possible.
        toMerge.setStatusCode(CommitMergeStatus.PATH_CONFLICT);
        return;
    } catch (MergeIdenticalTreeException mie) {
        toMerge.setStatusCode(SKIPPED_IDENTICAL_TREE);
        return;
    }
    // Initial copy doesn't have new patch set ID since change hasn't been
    // updated yet.
    newCommit = amendGitlink(newCommit);
    newCommit.copyFrom(toMerge);
    newCommit.setPatchsetId(psId);
    newCommit.setStatusCode(CommitMergeStatus.CLEAN_PICK);
    args.mergeTip.moveTipTo(newCommit, newCommit);
    args.commitStatus.put(newCommit);
    ctx.addRefUpdate(ObjectId.zeroId(), newCommit, psId.toRefName());
    patchSetInfo = args.patchSetInfoFactory.get(ctx.getRevWalk(), newCommit, psId);
}
#end_block

#method_before
@Override
public PatchSet updateChangeImpl(ChangeContext ctx) throws OrmException, NoSuchChangeException, IOException {
    if (newCommit == null && toMerge.getStatusCode() == SKIPPED_IDENTICAL_TREE) {
        return null;
    }
    checkNotNull(newCommit, "no new commit produced by CherryPick of %s, expected to fail fast", toMerge.change().getId());
    PatchSet prevPs = args.psUtil.current(ctx.getDb(), ctx.getNotes());
    PatchSet newPs = args.psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(psId), psId, newCommit, prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of(), null, null);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    // Don't copy approvals, as this is already taken care of by
    // SubmitStrategyOp.
    newCommit.setControl(ctx.getControl());
    return newPs;
}
#method_after
@Override
public PatchSet updateChangeImpl(ChangeContext ctx) throws OrmException, NoSuchChangeException, IOException {
    if (newCommit == null && toMerge.getStatusCode() == SKIPPED_IDENTICAL_TREE) {
        return null;
    }
    checkNotNull(newCommit, "no new commit produced by CherryPick of %s, expected to fail fast", toMerge.change().getId());
    PatchSet prevPs = args.psUtil.current(ctx.getDb(), ctx.getNotes());
    PatchSet newPs = args.psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(psId), psId, newCommit, prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of(), null, null);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    // Don't copy approvals, as this is already taken care of by
    // SubmitStrategyOp.
    newCommit.setNotes(ctx.getNotes());
    return newPs;
}
#end_block

#method_before
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    if (args.mergeUtil.hasMissingDependencies(args.mergeSorter, toMerge)) {
        // on the commit so we have nothing further to perform at this time.
        return;
    }
    // There are multiple parents, so this is a merge commit. We don't want
    // to cherry-pick the merge as clients can't easily rebase their history
    // with that merge present and replaced by an equivalent merge with a
    // different first parent. So instead behave as though MERGE_IF_NECESSARY
    // was configured.
    MergeTip mergeTip = args.mergeTip;
    if (args.rw.isMergedInto(mergeTip.getCurrentTip(), toMerge) && !args.submoduleOp.hasSubscription(args.destBranch)) {
        mergeTip.moveTipTo(toMerge, toMerge);
    } else {
        PersonIdent myIdent = new PersonIdent(args.serverIdent, ctx.getWhen());
        CodeReviewCommit result = args.mergeUtil.mergeOneCommit(myIdent, myIdent, args.repo, args.rw, args.inserter, args.destBranch, mergeTip.getCurrentTip(), toMerge);
        result = amendGitlink(result);
        mergeTip.moveTipTo(result, toMerge);
        args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted);
    }
}
#method_after
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    if (args.mergeUtil.hasMissingDependencies(args.mergeSorter, toMerge)) {
        // on the commit so we have nothing further to perform at this time.
        return;
    }
    // There are multiple parents, so this is a merge commit. We don't want
    // to cherry-pick the merge as clients can't easily rebase their history
    // with that merge present and replaced by an equivalent merge with a
    // different first parent. So instead behave as though MERGE_IF_NECESSARY
    // was configured.
    MergeTip mergeTip = args.mergeTip;
    if (args.rw.isMergedInto(mergeTip.getCurrentTip(), toMerge) && !args.submoduleOp.hasSubscription(args.destBranch)) {
        mergeTip.moveTipTo(toMerge, toMerge);
    } else {
        PersonIdent myIdent = new PersonIdent(args.serverIdent, ctx.getWhen());
        CodeReviewCommit result = args.mergeUtil.mergeOneCommit(myIdent, myIdent, args.rw, ctx.getInserter(), ctx.getRepoView().getConfig(), args.destBranch, mergeTip.getCurrentTip(), toMerge);
        result = amendGitlink(result);
        mergeTip.moveTipTo(result, toMerge);
        args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted);
    }
}
#end_block

#method_before
@Test
public void parseAuthor() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Subject: This is a test change\n");
    assertParseFails(writeCommit("Update change\n" + "\n" + "Patch-set: 1\n", new PersonIdent("Change Owner", "owner@example.com", serverIdent.getWhen(), serverIdent.getTimeZone())));
    assertParseFails(writeCommit("Update change\n" + "\n" + "Patch-set: 1\n", new PersonIdent("Change Owner", "x@gerrit", serverIdent.getWhen(), serverIdent.getTimeZone())));
    assertParseFails(writeCommit("Update change\n" + "\n" + "Patch-set: 1\n", new PersonIdent("Change\n\u1234<Owner>", "\n\nx<@>\u0002gerrit", serverIdent.getWhen(), serverIdent.getTimeZone())));
}
#method_after
@Test
public void parseAuthor() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Subject: This is a test change\n");
    assertParseFails(writeCommit("Update change\n\nPatch-set: 1\n", new PersonIdent("Change Owner", "owner@example.com", serverIdent.getWhen(), serverIdent.getTimeZone())));
    assertParseFails(writeCommit("Update change\n\nPatch-set: 1\n", new PersonIdent("Change Owner", "x@gerrit", serverIdent.getWhen(), serverIdent.getTimeZone())));
    assertParseFails(writeCommit("Update change\n\nPatch-set: 1\n", new PersonIdent("Change\n\u1234<Owner>", "\n\nx<@>\u0002gerrit", serverIdent.getWhen(), serverIdent.getTimeZone())));
}
#end_block

#method_before
@Test
public void parseStatus() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Status: NEW\n" + "Subject: This is a test change\n");
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Status: new\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Status: OOPS\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Status: NEW\n" + "Status: NEW\n");
}
#method_after
@Test
public void parseStatus() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Status: NEW\n" + "Subject: This is a test change\n");
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Status: new\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n\nPatch-set: 1\nStatus: OOPS\n");
    assertParseFails("Update change\n\nPatch-set: 1\nStatus: NEW\nStatus: NEW\n");
}
#end_block

#method_before
@Test
public void parsePatchSetId() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n" + "\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Patch-set: 1\n");
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: x\n");
}
#method_after
@Test
public void parsePatchSetId() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n\n");
    assertParseFails("Update change\n\nPatch-set: 1\nPatch-set: 1\n");
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n\nPatch-set: x\n");
}
#end_block

#method_before
@Test
public void parseApproval() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Label: Label1=+1\n" + "Label: Label2=1\n" + "Label: Label3=0\n" + "Label: Label4=-1\n" + "Subject: This is a test change\n");
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Label: -Label1\n" + "Label: -Label1 Other Account <2@gerrit>\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Label: Label1=X\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Label: Label1 = 1\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Label: X+Y\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Label: Label1 Other Account <2@gerrit>\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Label: -Label!1\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Label: -Label!1 Other Account <2@gerrit>\n");
}
#method_after
@Test
public void parseApproval() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Label: Label1=+1\n" + "Label: Label2=1\n" + "Label: Label3=0\n" + "Label: Label4=-1\n" + "Subject: This is a test change\n");
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Label: -Label1\n" + "Label: -Label1 Other Account <2@gerrit>\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n\nPatch-set: 1\nLabel: Label1=X\n");
    assertParseFails("Update change\n\nPatch-set: 1\nLabel: Label1 = 1\n");
    assertParseFails("Update change\n\nPatch-set: 1\nLabel: X+Y\n");
    assertParseFails("Update change\n\nPatch-set: 1\nLabel: Label1 Other Account <2@gerrit>\n");
    assertParseFails("Update change\n\nPatch-set: 1\nLabel: -Label!1\n");
    assertParseFails("Update change\n\nPatch-set: 1\nLabel: -Label!1 Other Account <2@gerrit>\n");
}
#end_block

#method_before
@Test
public void parseSubmitRecords() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Subject: This is a test change\n" + "Submitted-with: NOT_READY\n" + "Submitted-with: OK: Verified: Change Owner <1@gerrit>\n" + "Submitted-with: NEED: Code-Review\n" + "Submitted-with: NOT_READY\n" + "Submitted-with: OK: Verified: Change Owner <1@gerrit>\n" + "Submitted-with: NEED: Alternative-Code-Review\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Submitted-with: OOPS\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Submitted-with: NEED: X+Y\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Submitted-with: OK: X+Y: Change Owner <1@gerrit>\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Submitted-with: OK: Code-Review: 1@gerrit\n");
}
#method_after
@Test
public void parseSubmitRecords() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Subject: This is a test change\n" + "Submitted-with: NOT_READY\n" + "Submitted-with: OK: Verified: Change Owner <1@gerrit>\n" + "Submitted-with: NEED: Code-Review\n" + "Submitted-with: NOT_READY\n" + "Submitted-with: OK: Verified: Change Owner <1@gerrit>\n" + "Submitted-with: NEED: Alternative-Code-Review\n");
    assertParseFails("Update change\n\nPatch-set: 1\nSubmitted-with: OOPS\n");
    assertParseFails("Update change\n\nPatch-set: 1\nSubmitted-with: NEED: X+Y\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Submitted-with: OK: X+Y: Change Owner <1@gerrit>\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Submitted-with: OK: Code-Review: 1@gerrit\n");
}
#end_block

#method_before
@Test
public void parseReviewer() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Reviewer: Change Owner <1@gerrit>\n" + "CC: Other Account <2@gerrit>\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Reviewer: 1@gerrit\n");
}
#method_after
@Test
public void parseReviewer() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Reviewer: Change Owner <1@gerrit>\n" + "CC: Other Account <2@gerrit>\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n\nPatch-set: 1\nReviewer: 1@gerrit\n");
}
#end_block

#method_before
@Test
public void parseTopic() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Topic: Some Topic\n" + "Subject: This is a test change\n");
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Topic:\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Topic: Some Topic\n" + "Topic: Other Topic");
}
#method_after
@Test
public void parseTopic() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Topic: Some Topic\n" + "Subject: This is a test change\n");
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Topic:\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n\nPatch-set: 1\nTopic: Some Topic\nTopic: Other Topic");
}
#end_block

#method_before
@Test
public void parsePatchSetState() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-set: 1 (PUBLISHED)\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Subject: Some subject of a change\n");
    assertParseSucceeds("Update change\n" + "\n" + "Patch-set: 1 (DELETED)\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Subject: Some subject of a change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1 (NOT A STATUS)\n" + "Branch: refs/heads/master\n" + "Subject: Some subject of a change\n");
}
#method_after
@Test
public void parsePatchSetState() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-set: 1 (PUBLISHED)\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Subject: Some subject of a change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1 (DRAFT)\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Subject: Some subject of a change\n");
    assertParseSucceeds("Update change\n" + "\n" + "Patch-set: 1 (DELETED)\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Subject: Some subject of a change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1 (NOT A STATUS)\n" + "Branch: refs/heads/master\n" + "Subject: Some subject of a change\n");
}
#end_block

#method_before
@Test
public void currentPatchSet() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-set: 1\n" + "Current: true");
    assertParseSucceeds("Update change\n" + "\n" + "Patch-set: 1\n" + "Current: tRUe");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Current: false");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Current: blah");
}
#method_after
@Test
public void currentPatchSet() throws Exception {
    assertParseSucceeds("Update change\n\nPatch-set: 1\nCurrent: true");
    assertParseSucceeds("Update change\n\nPatch-set: 1\nCurrent: tRUe");
    assertParseFails("Update change\n\nPatch-set: 1\nCurrent: false");
    assertParseFails("Update change\n\nPatch-set: 1\nCurrent: blah");
}
#end_block

#method_before
private RevCommit writeCommit(String body) throws Exception {
    ChangeNoteUtil noteUtil = injector.getInstance(ChangeNoteUtil.class);
    return writeCommit(body, noteUtil.newIdent(changeOwner.getAccount(), TimeUtil.nowTs(), serverIdent, "Anonymous Coward"));
}
#method_after
private RevCommit writeCommit(String body) throws Exception {
    ChangeNoteUtil noteUtil = injector.getInstance(ChangeNoteUtil.class);
    return writeCommit(body, noteUtil.newIdent(changeOwner.getAccount(), TimeUtil.nowTs(), serverIdent, "Anonymous Coward"), false);
}
#end_block

#method_before
private RevCommit writeCommit(String body, PersonIdent author) throws Exception {
    Change change = newChange();
    ChangeNotes notes = newNotes(change).load();
    try (ObjectInserter ins = testRepo.getRepository().newObjectInserter()) {
        CommitBuilder cb = new CommitBuilder();
        cb.setParentId(notes.getRevision());
        cb.setAuthor(author);
        cb.setCommitter(new PersonIdent(serverIdent, author.getWhen()));
        cb.setTreeId(testRepo.tree());
        cb.setMessage(body);
        ObjectId id = ins.insert(cb);
        ins.flush();
        RevCommit commit = walk.parseCommit(id);
        walk.parseBody(commit);
        return commit;
    }
}
#method_after
private RevCommit writeCommit(String body, PersonIdent author) throws Exception {
    return writeCommit(body, author, false);
}
#end_block

#method_before
private RevCommit writeCommit(String body, PersonIdent author) throws Exception {
    Change change = newChange();
    ChangeNotes notes = newNotes(change).load();
    try (ObjectInserter ins = testRepo.getRepository().newObjectInserter()) {
        CommitBuilder cb = new CommitBuilder();
        cb.setParentId(notes.getRevision());
        cb.setAuthor(author);
        cb.setCommitter(new PersonIdent(serverIdent, author.getWhen()));
        cb.setTreeId(testRepo.tree());
        cb.setMessage(body);
        ObjectId id = ins.insert(cb);
        ins.flush();
        RevCommit commit = walk.parseCommit(id);
        walk.parseBody(commit);
        return commit;
    }
}
#method_after
private RevCommit writeCommit(String body, boolean initWorkInProgress) throws Exception {
    ChangeNoteUtil noteUtil = injector.getInstance(ChangeNoteUtil.class);
    return writeCommit(body, noteUtil.newIdent(changeOwner.getAccount(), TimeUtil.nowTs(), serverIdent, "Anonymous Coward"), initWorkInProgress);
}
#end_block

#method_before
private void assertParseSucceeds(String body) throws Exception {
    assertParseSucceeds(writeCommit(body));
}
#method_after
private ChangeNotesState assertParseSucceeds(String body) throws Exception {
    return assertParseSucceeds(writeCommit(body));
}
#end_block

#method_before
private void assertParseSucceeds(RevCommit commit) throws Exception {
    newParser(commit).parseAll();
}
#method_after
private ChangeNotesState assertParseSucceeds(RevCommit commit) throws Exception {
    return newParser(commit).parseAll();
}
#end_block

#method_before
public static Id parse(final String str) {
    final Id r = new Id();
    r.fromString(str);
    return r;
}
#method_after
public static Id parse(String str) {
    final Id r = new Id();
    r.fromString(str);
    return r;
}
#end_block

#method_before
public static Key parse(final String str) {
    final Key r = new Key();
    r.fromString(str);
    return r;
}
#method_after
public static Key parse(String str) {
    final Key r = new Key();
    r.fromString(str);
    return r;
}
#end_block

#method_before
public void setKey(final Change.Key k) {
    changeKey = k;
}
#method_after
public void setKey(Change.Key k) {
    changeKey = k;
}
#end_block

#method_before
public void setCurrentPatchSet(final PatchSetInfo ps) {
    if (originalSubject == null && subject != null) {
        // Change was created before schema upgrade. Use the last subject
        // associated with this change, as the most recent discussion will
        // be under that thread in an email client such as GMail.
        originalSubject = subject;
    }
    currentPatchSetId = ps.getKey().get();
    subject = ps.getSubject();
    if (originalSubject == null) {
        // Newly created changes remember the first commit's subject.
        originalSubject = subject;
    }
}
#method_after
public void setCurrentPatchSet(PatchSetInfo ps) {
    if (originalSubject == null && subject != null) {
        // Change was created before schema upgrade. Use the last subject
        // associated with this change, as the most recent discussion will
        // be under that thread in an email client such as GMail.
        originalSubject = subject;
    }
    currentPatchSetId = ps.getKey().get();
    subject = ps.getSubject();
    if (originalSubject == null) {
        // Newly created changes remember the first commit's subject.
        originalSubject = subject;
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    if (Gerrit.isSignedIn()) {
        ChangeList.query("change:" + changeId.get() + " has:draft", Collections.<ListChangesOption>emptySet(), group.add(new AsyncCallback<ChangeList>() {

            @Override
            public void onSuccess(ChangeList result) {
                hasDraftComments = result.length() > 0;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
        ChangeApi.editWithFiles(changeId.get(), group.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    loadChangeInfo(true, group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(final ChangeInfo info) {
            info.init();
            addExtensionPoints(info, initCurrentRevision(info));
            final RevisionInfo rev = info.revision(revision);
            CallbackGroup group = new CallbackGroup();
            loadCommit(rev, group);
            group.addListener(new GerritCallback<Void>() {

                @Override
                public void onSuccess(Void result) {
                    if (base.isBase() && rev.isMerge()) {
                        base = DiffObject.parse(info.legacyId(), Gerrit.getUserPreferences().defaultBaseForMerges().getBase());
                    }
                    loadConfigInfo(info, base);
                    JsArray<MessageInfo> mAr = info.messages();
                    for (int i = 0; i < mAr.length(); i++) {
                        if (mAr.get(i).tag() != null) {
                            hideTaggedComments.setVisible(true);
                            break;
                        }
                    }
                }
            });
            group.done();
        }
    }));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    if (Gerrit.isSignedIn()) {
        ChangeList.query("change:" + changeId.get() + " has:draft", Collections.<ListChangesOption>emptySet(), group.add(new AsyncCallback<ChangeList>() {

            @Override
            public void onSuccess(ChangeList result) {
                hasDraftComments = result.length() > 0;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
        ChangeApi.editWithFiles(Project.NameKey.asStringOrNull(project), changeId.get(), group.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    loadChangeInfo(true, group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            if (project == null) {
                // Update Project when the first API call succeeded if it wasn't already present.
                // This is the case when the user used a URL that doesn't include the project.
                // Setting it here will rewrite the URL token to include the project (visible to
                // the user) and all future API calls made from the change screen will use
                // project/+/changeId to identify the change.
                project = info.projectNameKey();
            }
            initCurrentRevision(info);
            final RevisionInfo rev = info.revision(revision);
            CallbackGroup group = new CallbackGroup();
            loadCommit(rev, group);
            group.addListener(new GerritCallback<Void>() {

                @Override
                public void onSuccess(Void result) {
                    if (base.isBase() && rev.isMerge()) {
                        base = DiffObject.parse(info.legacyId(), Gerrit.getUserPreferences().defaultBaseForMerges().getBase());
                    }
                    loadConfigInfo(info, base);
                    JsArray<MessageInfo> mAr = info.messages();
                    for (int i = 0; i < mAr.length(); i++) {
                        if (mAr.get(i).tag() != null) {
                            hideTaggedComments.setVisible(true);
                            break;
                        }
                    }
                }
            });
            group.done();
        }
    }));
}
#end_block

#method_before
private void addExtensionPoints(ChangeInfo change, RevisionInfo rev) {
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER, headerExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_BUTTONS, headerExtensionMiddle, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_POP_DOWNS, headerExtensionRight, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK, changeExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_RELATED_INFO_BLOCK, relatedExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_COMMIT_INFO_BLOCK, commitExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HISTORY_RIGHT_OF_BUTTONS, historyExtensionRight, change, rev);
}
#method_after
private void addExtensionPoints(ChangeInfo change, RevisionInfo rev, Entry result) {
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER, headerExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_BUTTONS, headerExtensionMiddle, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_POP_DOWNS, headerExtensionRight, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK, changeExtension, change, rev, result.getExtensionPanelNames(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK.toString()));
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_RELATED_INFO_BLOCK, relatedExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_COMMIT_INFO_BLOCK, commitExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HISTORY_RIGHT_OF_BUTTONS, historyExtensionRight, change, rev);
}
#end_block

#method_before
private void addExtensionPoint(GerritUiExtensionPoint extensionPoint, Panel p, ChangeInfo change, RevisionInfo rev) {
    ExtensionPanel extensionPanel = new ExtensionPanel(extensionPoint);
    extensionPanel.putObject(GerritUiExtensionPoint.Key.CHANGE_INFO, change);
    extensionPanel.putObject(GerritUiExtensionPoint.Key.REVISION_INFO, rev);
    p.add(extensionPanel);
}
#method_after
private void addExtensionPoint(GerritUiExtensionPoint extensionPoint, Panel p, ChangeInfo change, RevisionInfo rev, List<String> panelNames) {
    ExtensionPanel extensionPanel = new ExtensionPanel(extensionPoint, panelNames);
    extensionPanel.putObject(GerritUiExtensionPoint.Key.CHANGE_INFO, change);
    extensionPanel.putObject(GerritUiExtensionPoint.Key.REVISION_INFO, rev);
    p.add(extensionPanel);
}
#end_block

#method_before
private void addExtensionPoint(GerritUiExtensionPoint extensionPoint, Panel p, ChangeInfo change, RevisionInfo rev) {
    ExtensionPanel extensionPanel = new ExtensionPanel(extensionPoint);
    extensionPanel.putObject(GerritUiExtensionPoint.Key.CHANGE_INFO, change);
    extensionPanel.putObject(GerritUiExtensionPoint.Key.REVISION_INFO, rev);
    p.add(extensionPanel);
}
#method_after
private void addExtensionPoint(GerritUiExtensionPoint extensionPoint, Panel p, ChangeInfo change, RevisionInfo rev) {
    addExtensionPoint(extensionPoint, p, change, rev, Collections.emptyList());
}
#end_block

#method_before
void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    EnumSet<ListChangesOption> opts = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CHANGE_ACTIONS);
    if (enableSignedPush()) {
        opts.add(ListChangesOption.PUSH_CERTIFICATES);
    }
    ChangeList.addOptions(call, opts);
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#method_after
void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(Project.NameKey.asStringOrNull(project), changeId.get());
    EnumSet<ListChangesOption> opts = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CHANGE_ACTIONS);
    if (enableSignedPush()) {
        opts.add(ListChangesOption.PUSH_CERTIFICATES);
    }
    ChangeList.addOptions(call, opts);
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#end_block

#method_before
void loadRevisionInfo() {
    RestApi call = ChangeApi.actions(changeId.get(), revision);
    call.background();
    call.get(new GerritCallback<NativeMap<ActionInfo>>() {

        @Override
        public void onSuccess(NativeMap<ActionInfo> actionMap) {
            actionMap.copyKeysIntoChildren("id");
            renderRevisionInfo(changeInfo, actionMap);
        }
    });
}
#method_after
void loadRevisionInfo() {
    RestApi call = ChangeApi.actions(getProject().get(), changeId.get(), revision);
    call.background();
    call.get(new GerritCallback<NativeMap<ActionInfo>>() {

        @Override
        public void onSuccess(NativeMap<ActionInfo> actionMap) {
            actionMap.copyKeysIntoChildren("id");
            renderRevisionInfo(changeInfo, actionMap);
        }
    });
}
#end_block

#method_before
private void gotoSibling(int offset) {
    if (offset > 0 && changeInfo.currentRevision() != null && changeInfo.currentRevision().equals(revision)) {
        return;
    }
    if (offset < 0 && changeInfo.revision(revision)._number() == 1) {
        return;
    }
    JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(revisions);
    for (int i = 0; i < revisions.length(); i++) {
        if (revision.equals(revisions.get(i).name())) {
            if (0 <= i + offset && i + offset < revisions.length()) {
                Gerrit.display(PageLinks.toChange(new PatchSet.Id(changeInfo.legacyId(), revisions.get(i + offset)._number())));
                return;
            }
            return;
        }
    }
}
#method_after
private void gotoSibling(int offset) {
    if (offset > 0 && changeInfo.currentRevision() != null && changeInfo.currentRevision().equals(revision)) {
        return;
    }
    if (offset < 0 && changeInfo.revision(revision)._number() == 1) {
        return;
    }
    JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(revisions);
    for (int i = 0; i < revisions.length(); i++) {
        if (revision.equals(revisions.get(i).name())) {
            if (0 <= i + offset && i + offset < revisions.length()) {
                Gerrit.display(PageLinks.toChange(project, new PatchSet.Id(changeInfo.legacyId(), revisions.get(i + offset)._number())));
                return;
            }
            return;
        }
    }
}
#end_block

#method_before
private void initIncludedInAction(ChangeInfo info) {
    if (info.status() == Status.MERGED) {
        includedInAction = new IncludedInAction(info.legacyId(), style, headerLine, includedIn);
        includedIn.setVisible(true);
    }
}
#method_after
private void initIncludedInAction(ChangeInfo info) {
    if (info.status() == Status.MERGED) {
        includedInAction = new IncludedInAction(info.projectNameKey(), info.legacyId(), style, headerLine, includedIn);
        includedIn.setVisible(true);
    }
}
#end_block

#method_before
private void initRevisionsAction(ChangeInfo info, String revision) {
    int currentPatchSet;
    if (info.currentRevision() != null && info.revisions().containsKey(info.currentRevision())) {
        currentPatchSet = info.revision(info.currentRevision())._number();
    } else {
        JsArray<RevisionInfo> revList = info.revisions().values();
        RevisionInfo.sortRevisionInfoByNumber(revList);
        currentPatchSet = revList.get(revList.length() - 1)._number();
    }
    String currentlyViewedPatchSet;
    boolean isPatchSetCurrent = true;
    String revisionId = info.revision(revision).id();
    if (revisionId.equals("edit")) {
        currentlyViewedPatchSet = Resources.M.editPatchSet(RevisionInfo.findEditParent(info.revisions().values()));
        currentPatchSet = info.revisions().values().length() - 1;
    } else {
        currentlyViewedPatchSet = revisionId;
        if (!currentlyViewedPatchSet.equals(Integer.toString(currentPatchSet))) {
            isPatchSetCurrent = false;
        }
    }
    patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet));
    updatePatchSetsTextStyle(isPatchSetCurrent);
    patchSetsAction = new PatchSetsAction(info.legacyId(), revision, edit, style, headerLine, patchSets);
}
#method_after
private void initRevisionsAction(ChangeInfo info, String revision) {
    int currentPatchSet;
    if (info.currentRevision() != null && info.revisions().containsKey(info.currentRevision())) {
        currentPatchSet = info.revision(info.currentRevision())._number();
    } else {
        JsArray<RevisionInfo> revList = info.revisions().values();
        RevisionInfo.sortRevisionInfoByNumber(revList);
        currentPatchSet = revList.get(revList.length() - 1)._number();
    }
    String currentlyViewedPatchSet;
    boolean isPatchSetCurrent = true;
    String revisionId = info.revision(revision).id();
    if (revisionId.equals("edit")) {
        currentlyViewedPatchSet = Resources.M.editPatchSet(RevisionInfo.findEditParent(info.revisions().values()));
        currentPatchSet = info.revisions().values().length() - 1;
    } else {
        currentlyViewedPatchSet = revisionId;
        if (!currentlyViewedPatchSet.equals(Integer.toString(currentPatchSet))) {
            isPatchSetCurrent = false;
        }
    }
    patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet));
    updatePatchSetsTextStyle(isPatchSetCurrent);
    patchSetsAction = new PatchSetsAction(info.projectNameKey(), info.legacyId(), revision, edit, style, headerLine, patchSets);
}
#end_block

#method_before
private void initProjectLinks(final ChangeInfo info) {
    projectSettingsLink.setHref("#" + PageLinks.toProject(info.projectNameKey()));
    projectSettings.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (Hyperlink.impl.handleAsClick((Event) event.getNativeEvent())) {
                event.stopPropagation();
                event.preventDefault();
                Gerrit.display(PageLinks.toProject(info.projectNameKey()));
            }
        }
    }, ClickEvent.getType());
    projectDashboard.setText(info.project());
    projectDashboard.setTargetHistoryToken(PageLinks.toProjectDefaultDashboard(info.projectNameKey()));
}
#method_after
private void initProjectLinks(ChangeInfo info) {
    projectSettingsLink.setHref("#" + PageLinks.toProject(info.projectNameKey()));
    projectSettings.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (Hyperlink.impl.handleAsClick((Event) event.getNativeEvent())) {
                event.stopPropagation();
                event.preventDefault();
                Gerrit.display(PageLinks.toProject(info.projectNameKey()));
            }
        }
    }, ClickEvent.getType());
    projectDashboard.setText(info.project());
    projectDashboard.setTargetHistoryToken(PageLinks.toProjectDefaultDashboard(info.projectNameKey()));
}
#end_block

#method_before
private void initEditMode(ChangeInfo info, String revision) {
    if (Gerrit.isSignedIn()) {
        RevisionInfo rev = info.revision(revision);
        if (info.status().isOpen()) {
            if (isEditModeEnabled(info, rev)) {
                editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
                addFile.setVisible(!editMode.isVisible());
                deleteFile.setVisible(!editMode.isVisible());
                renameFile.setVisible(!editMode.isVisible());
                reviewMode.setVisible(!editMode.isVisible());
                addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile, files);
                deleteFileAction = new DeleteFileAction(changeId, info.revision(revision), style, addFile);
                renameFileAction = new RenameFileAction(changeId, info.revision(revision), style, addFile);
            } else {
                editMode.setVisible(false);
                addFile.setVisible(false);
                reviewMode.setVisible(false);
            }
            if (rev.isEdit()) {
                if (info.hasEditBasedOnCurrentPatchSet()) {
                    publishEdit.setVisible(true);
                } else {
                    rebaseEdit.setVisible(true);
                }
                deleteEdit.setVisible(true);
            }
        } else if (rev.isEdit()) {
            deleteEdit.setStyleName(style.highlight());
            deleteEdit.setVisible(true);
        }
    }
}
#method_after
private void initEditMode(ChangeInfo info, String revision) {
    if (Gerrit.isSignedIn()) {
        RevisionInfo rev = info.revision(revision);
        if (info.status().isOpen()) {
            if (isEditModeEnabled(info, rev)) {
                editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
                addFile.setVisible(!editMode.isVisible());
                deleteFile.setVisible(!editMode.isVisible());
                renameFile.setVisible(!editMode.isVisible());
                reviewMode.setVisible(!editMode.isVisible());
                addFileAction = new AddFileAction(info.projectNameKey(), changeId, info.revision(revision), style, addFile, files);
                deleteFileAction = new DeleteFileAction(info.projectNameKey(), changeId, info.revision(revision), style, addFile);
                renameFileAction = new RenameFileAction(info.projectNameKey(), changeId, info.revision(revision), style, addFile);
            } else {
                editMode.setVisible(false);
                addFile.setVisible(false);
                reviewMode.setVisible(false);
            }
            if (rev.isEdit()) {
                if (info.hasEditBasedOnCurrentPatchSet()) {
                    publishEdit.setVisible(true);
                } else {
                    rebaseEdit.setVisible(true);
                }
                deleteEdit.setVisible(true);
            }
        } else if (rev.isEdit()) {
            deleteEdit.setStyleName(style.highlight());
            deleteEdit.setVisible(true);
        }
    }
}
#end_block

#method_before
@UiHandler("publishEdit")
void onPublishEdit(@SuppressWarnings("unused") ClickEvent e) {
    EditActions.publishEdit(changeId, publishEdit, rebaseEdit, deleteEdit);
}
#method_after
@UiHandler("publishEdit")
void onPublishEdit(@SuppressWarnings("unused") ClickEvent e) {
    EditActions.publishEdit(getProject(), changeId, publishEdit, rebaseEdit, deleteEdit);
}
#end_block

#method_before
@UiHandler("rebaseEdit")
void onRebaseEdit(@SuppressWarnings("unused") ClickEvent e) {
    EditActions.rebaseEdit(changeId, publishEdit, rebaseEdit, deleteEdit);
}
#method_after
@UiHandler("rebaseEdit")
void onRebaseEdit(@SuppressWarnings("unused") ClickEvent e) {
    EditActions.rebaseEdit(getProject(), changeId, publishEdit, rebaseEdit, deleteEdit);
}
#end_block

#method_before
@UiHandler("deleteEdit")
void onDeleteEdit(@SuppressWarnings("unused") ClickEvent e) {
    if (Window.confirm(Resources.C.deleteChangeEdit())) {
        EditActions.deleteEdit(changeId, publishEdit, rebaseEdit, deleteEdit);
    }
}
#method_after
@UiHandler("deleteEdit")
void onDeleteEdit(@SuppressWarnings("unused") ClickEvent e) {
    if (Window.confirm(Resources.C.deleteChangeEdit())) {
        EditActions.deleteEdit(getProject(), changeId, publishEdit, rebaseEdit, deleteEdit);
    }
}
#end_block

#method_before
@Override
public void registerKeys() {
    super.registerKeys();
    KeyCommandSet keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', Util.C.upToChangeList()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            Gerrit.displayLastChangeList();
        }
    });
    keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadChange()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            Gerrit.display(PageLinks.toChange(changeId));
        }
    });
    keysNavigation.add(new KeyCommand(0, 'n', Util.C.keyNextPatchSet()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            gotoSibling(1);
        }
    }, new KeyCommand(0, 'p', Util.C.keyPreviousPatchSet()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            gotoSibling(-1);
        }
    });
    handlers.add(GlobalKey.add(this, keysNavigation));
    KeyCommandSet keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new KeyCommand(0, 'a', Util.C.keyPublishComments()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                onReply(null);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'x', Util.C.keyExpandAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onExpandAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 'z', Util.C.keyCollapseAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onCollapseAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 's', Util.C.changeTableStar()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                star.setValue(!star.getValue(), true);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'c', Util.C.keyAddReviewers()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                reviewers.onOpenForm();
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                // differentiate F5 from 't' by checking the charCode(F5=0, t=116).
                if (event.getNativeEvent().getCharCode() == 0) {
                    Window.Location.reload();
                    return;
                }
                if (topic.canEdit()) {
                    topic.onEdit();
                }
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    handlers.add(GlobalKey.add(this, keysAction));
    files.registerKeys();
}
#method_after
@Override
public void registerKeys() {
    super.registerKeys();
    KeyCommandSet keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', Util.C.upToChangeList()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            Gerrit.displayLastChangeList();
        }
    });
    keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadChange()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            Gerrit.display(PageLinks.toChange(project, changeId));
        }
    });
    keysNavigation.add(new KeyCommand(0, 'n', Util.C.keyNextPatchSet()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            gotoSibling(1);
        }
    }, new KeyCommand(0, 'p', Util.C.keyPreviousPatchSet()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            gotoSibling(-1);
        }
    });
    handlers.add(GlobalKey.add(this, keysNavigation));
    KeyCommandSet keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new KeyCommand(0, 'a', Util.C.keyPublishComments()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                onReply(null);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'x', Util.C.keyExpandAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onExpandAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 'z', Util.C.keyCollapseAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onCollapseAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 's', Util.C.changeTableStar()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                star.setValue(!star.getValue(), true);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'c', Util.C.keyAddReviewers()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                reviewers.onOpenForm();
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                // differentiate F5 from 't' by checking the charCode(F5=0, t=116).
                if (event.getNativeEvent().getCharCode() == 0) {
                    Window.Location.reload();
                    return;
                }
                if (topic.canEdit()) {
                    topic.onEdit();
                }
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    handlers.add(GlobalKey.add(this, keysAction));
    files.registerKeys();
}
#end_block

#method_before
private void scrollToPath(String token) {
    int s = token.indexOf('/');
    try {
        String c = token.substring(0, s);
        int editIndex = c.indexOf(",edit");
        if (editIndex > 0) {
            c = c.substring(0, editIndex);
        }
        if (s < 0 || !changeId.equals(Change.Id.parse(c))) {
            // Unrelated URL, do not scroll.
            return;
        }
    } catch (IllegalArgumentException e) {
        return;
    }
    s = token.indexOf('/', s + 1);
    if (s < 0) {
        // URL does not name a file.
        return;
    }
    int c = token.lastIndexOf(',');
    if (0 <= c) {
        token = token.substring(s + 1, c);
    } else {
        token = token.substring(s + 1);
    }
    if (!token.isEmpty()) {
        files.scrollToPath(KeyUtil.decode(token));
    }
}
#method_after
private void scrollToPath(String token) {
    ProjectChangeId cId;
    try {
        cId = ProjectChangeId.create(token);
    } catch (IllegalArgumentException e) {
        // Scrolling is best-effort.
        return;
    }
    if (!changeId.equals(cId.getChangeId())) {
        // Unrelated URL, do not scroll.
        return;
    }
    // Extract the start of a file path. The patch set is always contained in the URL and separated
    // by from the changeId by a forward slash. Example: /c/project/+/123/1/folder/file.txt
    int s = token.indexOf('/', cId.identifierLength() + 1);
    if (s < 0) {
        // URL does not name a file.
        return;
    }
    int c = token.lastIndexOf(',');
    if (0 <= c) {
        token = token.substring(s + 1, c);
    } else {
        token = token.substring(s + 1);
    }
    if (!token.isEmpty()) {
        files.scrollToPath(KeyUtil.decode(token));
    }
}
#end_block

#method_before
@UiHandler("permalink")
void onReload(ClickEvent e) {
    e.preventDefault();
    Gerrit.display(PageLinks.toChange(changeId));
}
#method_after
@UiHandler("permalink")
void onReload(ClickEvent e) {
    e.preventDefault();
    Gerrit.display(PageLinks.toChange(project, changeId));
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, DiffObject base) {
    final RevisionInfo rev = info.revision(revision);
    if (base.isAutoMerge() && !initCurrentRevision(info).isMerge()) {
        Gerrit.display(getToken(), new NotFoundScreen());
    }
    updateToken(info, base, rev);
    RevisionInfo baseRev = resolveRevisionOrPatchSetId(info, base.asString(), null);
    CallbackGroup group = new CallbackGroup();
    Timestamp lastReply = myLastReply(info);
    if (rev.isEdit()) {
        // Comments are filtered for the current revision. Use parent
        // patch set for edits, as edits themself can never have comments.
        RevisionInfo p = RevisionInfo.findEditParentRevision(info.revisions().values());
        List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(p, group);
        loadFileList(base, baseRev, rev, lastReply, group, comments, null);
    } else {
        loadDiff(base, baseRev, rev, lastReply, group);
    }
    group.addListener(new AsyncCallback<Void>() {

        @Override
        public void onSuccess(Void result) {
            loadConfigInfo(info, rev);
        }

        @Override
        public void onFailure(Throwable caught) {
            logger.log(Level.SEVERE, "Loading file list and inline comments failed: " + caught.getMessage());
            loadConfigInfo(info, rev);
        }
    });
    group.done();
}
#method_after
private void loadConfigInfo(ChangeInfo info, DiffObject base) {
    final RevisionInfo rev = info.revision(revision);
    if (base.isAutoMerge() && !initCurrentRevision(info).isMerge()) {
        Gerrit.display(getToken(), new NotFoundScreen());
    }
    updateToken(info, base, rev);
    RevisionInfo baseRev = resolveRevisionOrPatchSetId(info, base.asString(), null);
    CallbackGroup group = new CallbackGroup();
    Timestamp lastReply = myLastReply(info);
    if (rev.isEdit()) {
        // Comments are filtered for the current revision. Use parent
        // patch set for edits, as edits themself can never have comments.
        RevisionInfo p = RevisionInfo.findEditParentRevision(info.revisions().values());
        List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(p, group);
        loadFileList(base, baseRev, rev, lastReply, group, comments, null);
    } else {
        loadDiff(base, baseRev, rev, lastReply, group);
    }
    group.addListener(new AsyncCallback<Void>() {

        @Override
        public void onSuccess(Void result) {
            loadConfigInfo(info, rev);
        }

        @Override
        public void onFailure(Throwable caught) {
            logger.log(Level.SEVERE, "Loading file list and inline comments failed: " + caught.getMessage());
            loadConfigInfo(info, rev);
        }
    });
    group.done();
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, RevisionInfo rev) {
    if (loaded) {
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.projectNameKey(), new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
            loadRevisionInfo();
        }
    });
}
#method_after
private void loadConfigInfo(ChangeInfo info, RevisionInfo rev) {
    if (loaded) {
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.projectNameKey(), new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
            loadRevisionInfo();
        }
    });
    ConfigInfoCache.get(info.projectNameKey(), new GerritCallback<Entry>() {

        @Override
        public void onSuccess(Entry entry) {
            addExtensionPoints(info, rev, entry);
        }
    });
}
#end_block

#method_before
private void updateToken(ChangeInfo info, DiffObject base, RevisionInfo rev) {
    StringBuilder token = new StringBuilder("/c/").append(info._number()).append("/");
    if (base.asString() != null) {
        token.append(base.asString()).append("..");
    }
    if (base.asString() != null || !rev.name().equals(info.currentRevision())) {
        token.append(rev._number());
    }
    setToken(token.toString());
}
#method_after
private void updateToken(ChangeInfo info, DiffObject base, RevisionInfo rev) {
    StringBuilder token = new StringBuilder("/c/").append(PageLinks.toChangeId(info.projectNameKey(), info.legacyId())).append("/");
    if (base.asString() != null) {
        token.append(base.asString()).append("..");
    }
    if (base.asString() != null || !rev.name().equals(info.currentRevision())) {
        token.append(rev._number());
    }
    setToken(token.toString());
}
#end_block

#method_before
private void loadDiff(DiffObject base, RevisionInfo baseRev, RevisionInfo rev, Timestamp myLastReply, CallbackGroup group) {
    List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    loadFileList(base, baseRev, rev, myLastReply, group, comments, drafts);
    if (Gerrit.isSignedIn() && fileTableMode == FileTable.Mode.REVIEW) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#method_after
private void loadDiff(DiffObject base, RevisionInfo baseRev, RevisionInfo rev, Timestamp myLastReply, CallbackGroup group) {
    List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    loadFileList(base, baseRev, rev, myLastReply, group, comments, drafts);
    if (Gerrit.isSignedIn() && fileTableMode == FileTable.Mode.REVIEW) {
        ChangeApi.revision(getProject().get(), changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#end_block

#method_before
private void loadFileList(final DiffObject base, final RevisionInfo baseRev, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group, final List<NativeMap<JsArray<CommentInfo>>> comments, final List<NativeMap<JsArray<CommentInfo>>> drafts) {
    DiffApi.list(changeId.get(), rev.name(), baseRev, group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.set(base, new PatchSet.Id(changeId, rev._number()), style, reply, fileTableMode, edit != null);
            files.setValue(m, myLastReply, comments != null ? comments.get(0) : null, drafts != null ? drafts.get(0) : null);
        }

        @Override
        public void onFailure(Throwable caught) {
            files.showError(caught);
        }
    }));
}
#method_after
private void loadFileList(final DiffObject base, final RevisionInfo baseRev, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group, final List<NativeMap<JsArray<CommentInfo>>> comments, final List<NativeMap<JsArray<CommentInfo>>> drafts) {
    DiffApi.list(getProject().get(), changeId.get(), rev.name(), baseRev, group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.set(base, new PatchSet.Id(changeId, rev._number()), getProject(), style, reply, fileTableMode, edit != null);
            files.setValue(m, myLastReply, comments != null ? comments.get(0) : null, drafts != null ? drafts.get(0) : null);
        }

        @Override
        public void onFailure(Throwable caught) {
            files.showError(caught);
        }
    }));
}
#end_block

#method_before
private List<NativeMap<JsArray<CommentInfo>>> loadComments(final RevisionInfo rev, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<>(1);
    // TODO(dborowitz): Could eliminate this call by adding an option to include
    // inline comments in the change detail.
    ChangeApi.comments(changeId.get()).get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            // Return value is used for populating the file table, so only count
            // comments for the current revision. Still include all comments in
            // the history table.
            r.add(filterForRevision(result, rev._number()));
            history.addComments(result);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    return r;
}
#method_after
private List<NativeMap<JsArray<CommentInfo>>> loadComments(final RevisionInfo rev, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<>(1);
    // TODO(dborowitz): Could eliminate this call by adding an option to include
    // inline comments in the change detail.
    ChangeApi.comments(getProject().get(), changeId.get()).get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            // Return value is used for populating the file table, so only count
            // comments for the current revision. Still include all comments in
            // the history table.
            r.add(filterForRevision(result, rev._number()));
            history.addComments(result);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    return r;
}
#end_block

#method_before
private List<NativeMap<JsArray<CommentInfo>>> loadDrafts(RevisionInfo rev, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<>(1);
    if (Gerrit.isSignedIn()) {
        ChangeApi.revision(changeId.get(), rev.name()).view("drafts").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

            @Override
            public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
                r.add(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    } else {
        r.add(NativeMap.<JsArray<CommentInfo>>create());
    }
    return r;
}
#method_after
private List<NativeMap<JsArray<CommentInfo>>> loadDrafts(RevisionInfo rev, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<>(1);
    if (Gerrit.isSignedIn()) {
        ChangeApi.revision(getProject().get(), changeId.get(), rev.name()).view("drafts").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

            @Override
            public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
                r.add(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    } else {
        r.add(NativeMap.<JsArray<CommentInfo>>create());
    }
    return r;
}
#end_block

#method_before
private void loadCommit(final RevisionInfo rev, CallbackGroup group) {
    if (rev.isEdit() || rev.commit() != null) {
        return;
    }
    ChangeApi.commitWithLinks(changeId.get(), rev.name(), group.add(new AsyncCallback<CommitInfo>() {

        @Override
        public void onSuccess(CommitInfo info) {
            rev.setCommit(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#method_after
private void loadCommit(RevisionInfo rev, CallbackGroup group) {
    if (rev.isEdit() || rev.commit() != null) {
        return;
    }
    ChangeApi.commitWithLinks(getProject().get(), changeId.get(), rev.name(), group.add(new AsyncCallback<CommitInfo>() {

        @Override
        public void onSuccess(CommitInfo info) {
            rev.setCommit(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    RevisionInfo revisionInfo = info.revision(revision);
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    labels.set(info);
    renderOwner(info);
    renderUploader(info, revisionInfo);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initReplyButton(info, revision);
    initIncludedInAction(info);
    initChangeAction(info);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info, revision);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacyId()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.info().change().showAssignee()) {
        assignee.set(info);
    } else {
        setVisible(assigneeRow, false);
    }
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info, revision);
    } else {
        setVisible(hashtagTableRow, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.idAbbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
    // render it faster.
    if (!info.status().isOpen() || !revision.equals(info.currentRevision()) || revisionInfo.isEdit()) {
        setVisible(strategy, false);
    }
    // Properly render revision actions initially while waiting for
    // the callback to populate them correctly.
    NativeMap<ActionInfo> emptyMap = NativeMap.<ActionInfo>create();
    initRevisionsAction(info, revision);
    quickApprove.setVisible(false);
    actions.reloadRevisionActions(emptyMap);
    boolean current = revision.equals(info.currentRevision()) && !revisionInfo.isEdit();
    if (revisionInfo.isEdit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, hasDraftComments, style, commentLinkProcessor, reply, quickApprove);
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current && info.status().isOpen()) {
        quickApprove.set(info, revision, replyAction);
        renderSubmitType(info.status(), isSubmittable(info), info.submitType());
    } else {
        quickApprove.setVisible(false);
    }
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    RevisionInfo revisionInfo = info.revision(revision);
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    labels.set(info);
    renderOwner(info);
    renderUploader(info, revisionInfo);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initReplyButton(info, revision);
    initIncludedInAction(info);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info, revision);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacyId()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    assignee.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info, revision);
    } else {
        setVisible(hashtagTableRow, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.idAbbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
    // render it faster.
    if (!info.status().isOpen() || !revision.equals(info.currentRevision()) || revisionInfo.isEdit()) {
        setVisible(strategy, false);
    }
    // Properly render revision actions initially while waiting for
    // the callback to populate them correctly.
    NativeMap<ActionInfo> emptyMap = NativeMap.<ActionInfo>create();
    initRevisionsAction(info, revision);
    quickApprove.setVisible(false);
    actions.reloadRevisionActions(emptyMap);
    boolean current = revision.equals(info.currentRevision()) && !revisionInfo.isEdit();
    if (revisionInfo.isEdit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    if (info.isPrivate()) {
        privateText.setInnerText(Util.C.isPrivate());
    }
    if (info.isWorkInProgress()) {
        wipText.setInnerText(Util.C.isWorkInProgress());
    }
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, hasDraftComments, style, commentLinkProcessor, reply, quickApprove);
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current && info.status().isOpen()) {
        quickApprove.set(info, revision, replyAction);
        renderSubmitType(info.status(), isSubmittable(info), info.submitType());
    } else {
        quickApprove.setVisible(false);
    }
}
#end_block

#method_before
void showUpdates(ChangeInfo newInfo) {
    if (!isAttached() || newInfo.updated().equals(lastDisplayedUpdate)) {
        return;
    }
    JsArray<MessageInfo> om = changeInfo.messages();
    JsArray<MessageInfo> nm = newInfo.messages();
    if (om == null) {
        om = JsArray.createArray().cast();
    }
    if (nm == null) {
        nm = JsArray.createArray().cast();
    }
    if (updateAvailable == null) {
        updateAvailable = new UpdateAvailableBar() {

            @Override
            void onShow() {
                Gerrit.display(PageLinks.toChange(changeId));
            }

            @Override
            void onIgnore(Timestamp newTime) {
                lastDisplayedUpdate = newTime;
            }
        };
    }
    updateAvailable.set(Natives.asList(nm).subList(om.length(), nm.length()), newInfo.updated());
    if (!updateAvailable.isAttached()) {
        add(updateAvailable);
    }
}
#method_after
void showUpdates(ChangeInfo newInfo) {
    if (!isAttached() || newInfo.updated().equals(lastDisplayedUpdate)) {
        return;
    }
    JsArray<MessageInfo> om = changeInfo.messages();
    JsArray<MessageInfo> nm = newInfo.messages();
    if (om == null) {
        om = JsArray.createArray().cast();
    }
    if (nm == null) {
        nm = JsArray.createArray().cast();
    }
    if (om.length() == nm.length()) {
        return;
    }
    if (updateAvailable == null) {
        updateAvailable = new UpdateAvailableBar() {

            @Override
            void onShow() {
                Gerrit.display(PageLinks.toChange(project, changeId));
            }

            @Override
            void onIgnore(Timestamp newTime) {
                lastDisplayedUpdate = newTime;
            }
        };
    }
    updateAvailable.set(Natives.asList(nm).subList(om.length(), nm.length()), newInfo.updated());
    if (!updateAvailable.isAttached()) {
        add(updateAvailable);
    }
}
#end_block

#method_before
public ChangeControl validateFor(ReviewDb db, ChangeNotes notes, CurrentUser user) throws OrmException {
    return controlFor(notes, user);
}
#method_after
public ChangeControl validateFor(Change.Id changeId, CurrentUser user) throws OrmException {
    return validateFor(notesFactory.createChecked(changeId), user);
}
#end_block

#method_before
public ChangeControl forUser(final CurrentUser who) {
    if (getUser().equals(who)) {
        return this;
    }
    return new ChangeControl(changeDataFactory, approvalsUtil, getRefControl().forUser(who), notes, patchSetUtil);
}
#method_after
public ChangeControl forUser(CurrentUser who) {
    if (getUser().equals(who)) {
        return this;
    }
    return new ChangeControl(changeDataFactory, approvalsUtil, getRefControl().forUser(who), notes, patchSetUtil);
}
#end_block

#method_before
public boolean isVisible(ReviewDb db) {
    return isVisible(db, null);
}
#method_after
public boolean isVisible(ReviewDb db) throws OrmException {
    return isVisible(db, null);
}
#end_block

#method_before
public boolean isVisible(ReviewDb db, @Nullable ChangeData cd) {
    return isRefVisible();
}
#method_after
private boolean isVisible(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getChange().isPrivate() && !isPrivateVisible(db, cd)) {
        return false;
    }
    return isRefVisible();
}
#end_block

#method_before
public boolean isPatchVisible(PatchSet ps, ChangeData cd) {
    checkArgument(cd.getId().equals(ps.getId().getParentKey()), "%s not for change %s", ps, cd.getId());
    return isVisible(cd.db());
}
#method_after
public boolean isPatchVisible(PatchSet ps, ChangeData cd) throws OrmException {
    // TODO(hiesel) These don't need to be migrated, just remove after support for drafts is removed
    checkArgument(cd.getId().equals(ps.getId().getParentKey()), "%s not for change %s", ps, cd.getId());
    return isVisible(cd.db());
}
#end_block

#method_before
public boolean canAbandon(ReviewDb db) throws OrmException {
    return (// owner (aka creator) of the change can abandon
    isOwner() || // branch owner can abandon
    getRefControl().isOwner() || // project owner can abandon
    getProjectControl().isOwner() || // site administers are god
    getUser().getCapabilities().canAdministrateServer() || // user can abandon a specific ref
    getRefControl().canAbandon()) && !isPatchSetLocked(db);
}
#method_after
private boolean canAbandon(ReviewDb db) throws OrmException {
    return (// owner (aka creator) of the change can abandon
    isOwner() || // branch owner can abandon
    getRefControl().isOwner() || // project owner can abandon
    getProjectControl().isOwner() || // user can abandon a specific ref
    getRefControl().canAbandon() || getProjectControl().isAdmin()) && !isPatchSetLocked(db);
}
#end_block

#method_before
public boolean canDelete(ReviewDb db, Change.Status status) {
    switch(status) {
        case NEW:
        case ABANDONED:
            return isAdmin();
        case MERGED:
        default:
            return false;
    }
}
#method_after
public boolean canDelete(Change.Status status) {
    switch(status) {
        case NEW:
        case ABANDONED:
            return (isOwner() && getRefControl().canDeleteOwnChanges()) || getProjectControl().isAdmin();
        case MERGED:
        default:
            return false;
    }
}
#end_block

#method_before
public boolean canRebase(ReviewDb db) throws OrmException {
    return (isOwner() || getRefControl().canSubmit(isOwner()) || getRefControl().canRebase()) && !isPatchSetLocked(db);
}
#method_after
private boolean canRebase(ReviewDb db) throws OrmException {
    return (isOwner() || getRefControl().canSubmit(isOwner()) || getRefControl().canRebase()) && refControl.asForRef().testOrFalse(RefPermission.CREATE_CHANGE) && !isPatchSetLocked(db);
}
#end_block

#method_before
public boolean canRestore(ReviewDb db) throws OrmException {
    return // Anyone who can abandon the change can restore it back
    canAbandon(db) && // as long as you can upload too
    getRefControl().canUpload();
}
#method_after
private boolean canRestore(ReviewDb db) throws OrmException {
    // Anyone who can abandon the change can restore it, as long as they can create changes.
    return canAbandon(db) && refControl.asForRef().testOrFalse(RefPermission.CREATE_CHANGE);
}
#end_block

#method_before
public PermissionRange getRange(String permission) {
    return getRefControl().getRange(permission, isOwner());
}
#method_after
private PermissionRange getRange(String permission) {
    return getRefControl().getRange(permission, isOwner());
}
#end_block

#method_before
public boolean canAddPatchSet(ReviewDb db) throws OrmException {
    if (!getRefControl().canUpload() || isPatchSetLocked(db)) {
        return false;
    }
    if (isOwner()) {
        return true;
    }
    return getRefControl().canAddPatchSet();
}
#method_after
private boolean canAddPatchSet(ReviewDb db) throws OrmException {
    if (!refControl.asForRef().testOrFalse(RefPermission.CREATE_CHANGE) || isPatchSetLocked(db)) {
        return false;
    }
    if (isOwner()) {
        return true;
    }
    return getRefControl().canAddPatchSet();
}
#end_block

#method_before
public boolean isPatchSetLocked(ReviewDb db) throws OrmException {
    if (getChange().getStatus() == Change.Status.MERGED) {
        return false;
    }
    for (PatchSetApproval ap : approvalsUtil.byPatchSet(db, this, getChange().currentPatchSetId())) {
        LabelType type = getLabelTypes().byLabel(ap.getLabel());
        if (type != null && ap.getValue() == 1 && type.getFunctionName().equalsIgnoreCase("PatchSetLock")) {
            return true;
        }
    }
    return false;
}
#method_after
boolean isPatchSetLocked(ReviewDb db) throws OrmException {
    if (getChange().getStatus() == Change.Status.MERGED) {
        return false;
    }
    for (PatchSetApproval ap : approvalsUtil.byPatchSet(db, getNotes(), getUser(), getChange().currentPatchSetId(), null, null)) {
        LabelType type = getProjectControl().getProjectState().getLabelTypes(getNotes(), getUser()).byLabel(ap.getLabel());
        if (type != null && ap.getValue() == 1 && type.getFunctionName().equalsIgnoreCase("PatchSetLock")) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public boolean isOwner() {
    if (getUser().isIdentifiedUser()) {
        Account.Id id = getUser().asIdentifiedUser().getAccountId();
        return id.equals(getChange().getOwner());
    }
    return false;
}
#method_after
private boolean isOwner() {
    if (getUser().isIdentifiedUser()) {
        Account.Id id = getUser().asIdentifiedUser().getAccountId();
        return id.equals(getChange().getOwner());
    }
    return false;
}
#end_block

#method_before
public boolean isAssignee() {
    Account.Id currentAssignee = notes.getChange().getAssignee();
    if (currentAssignee != null && getUser().isIdentifiedUser()) {
        Account.Id id = getUser().getAccountId();
        return id.equals(currentAssignee);
    }
    return false;
}
#method_after
private boolean isAssignee() {
    Account.Id currentAssignee = notes.getChange().getAssignee();
    if (currentAssignee != null && getUser().isIdentifiedUser()) {
        Account.Id id = getUser().getAccountId();
        return id.equals(currentAssignee);
    }
    return false;
}
#end_block

#method_before
public boolean isReviewer(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getUser().isIdentifiedUser()) {
        Collection<Account.Id> results = changeData(db, cd).reviewers().all();
        return results.contains(getUser().getAccountId());
    }
    return false;
}
#method_after
private boolean isReviewer(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getUser().isIdentifiedUser()) {
        Collection<Account.Id> results = changeData(db, cd).reviewers().all();
        return results.contains(getUser().getAccountId());
    }
    return false;
}
#end_block

#method_before
public boolean canEditTopicName() {
    if (getChange().getStatus().isOpen()) {
        return // owner (aka creator) of the change can edit topic
        isOwner() || // branch owner can edit topic
        getRefControl().isOwner() || // project owner can edit topic
        getProjectControl().isOwner() || // site administers are god
        getUser().getCapabilities().canAdministrateServer() || // user can edit topic on a specific ref
        getRefControl().canEditTopicName();
    }
    return getRefControl().canForceEditTopicName();
}
#method_after
private boolean canEditTopicName() {
    if (getChange().getStatus().isOpen()) {
        return // owner (aka creator) of the change can edit topic
        isOwner() || // branch owner can edit topic
        getRefControl().isOwner() || // project owner can edit topic
        getProjectControl().isOwner() || // user can edit topic on a specific ref
        getRefControl().canEditTopicName() || getProjectControl().isAdmin();
    }
    return getRefControl().canForceEditTopicName();
}
#end_block

#method_before
public boolean canEditDescription() {
    if (getChange().getStatus().isOpen()) {
        return // owner (aka creator) of the change can edit desc
        isOwner() || // branch owner can edit desc
        getRefControl().isOwner() || // project owner can edit desc
        getProjectControl().isOwner() || // site administers are god
        getUser().getCapabilities().canAdministrateServer();
    }
    return false;
}
#method_after
private boolean canEditDescription() {
    if (getChange().getStatus().isOpen()) {
        return // owner (aka creator) of the change can edit desc
        isOwner() || // branch owner can edit desc
        getRefControl().isOwner() || // project owner can edit desc
        getProjectControl().isOwner() || getProjectControl().isAdmin();
    }
    return false;
}
#end_block

#method_before
public boolean canEditAssignee() {
    return isOwner() || getProjectControl().isOwner() || getRefControl().canEditAssignee() || isAssignee();
}
#method_after
private boolean canEditAssignee() {
    return isOwner() || getProjectControl().isOwner() || getRefControl().canEditAssignee() || isAssignee();
}
#end_block

#method_before
public boolean canEditHashtags() {
    return // owner (aka creator) of the change can edit hashtags
    isOwner() || // branch owner can edit hashtags
    getRefControl().isOwner() || // project owner can edit hashtags
    getProjectControl().isOwner() || // site administers are god
    getUser().getCapabilities().canAdministrateServer() || // user can edit hashtag on a specific ref
    getRefControl().canEditHashtags();
}
#method_after
private boolean canEditHashtags() {
    return // owner (aka creator) of the change can edit hashtags
    isOwner() || // branch owner can edit hashtags
    getRefControl().isOwner() || // project owner can edit hashtags
    getProjectControl().isOwner() || // user can edit hashtag on a specific ref
    getRefControl().canEditHashtags() || getProjectControl().isAdmin();
}
#end_block

#method_before
private ChangeData changeData(ReviewDb db, @Nullable ChangeData cd) {
    return cd != null ? cd : changeDataFactory.create(db, this);
}
#method_after
private ChangeData changeData(ReviewDb db, @Nullable ChangeData cd) {
    return cd != null ? cd : changeDataFactory.create(db, getNotes());
}
#end_block

#method_before
public Change abandon(ChangeControl control, String msgTxt, NotifyHandling notifyHandling, ListMultimap<RecipientType, Account.Id> accountsToNotify) throws RestApiException, UpdateException {
    CurrentUser user = control.getUser();
    Account account = user.isIdentifiedUser() ? user.asIdentifiedUser().getAccount() : null;
    AbandonOp op = abandonOpFactory.create(account, msgTxt, notifyHandling, accountsToNotify);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), control.getProject().getNameKey(), control.getUser(), TimeUtil.nowTs())) {
        u.addOp(control.getId(), op).execute();
    }
    return op.getChange();
}
#method_after
public Change abandon(BatchUpdate.Factory updateFactory, ChangeNotes notes, CurrentUser user) throws RestApiException, UpdateException {
    return abandon(updateFactory, notes, user, "", defaultNotify(notes.getChange()), ImmutableListMultimap.of());
}
#end_block

#method_before
public void batchAbandon(Project.NameKey project, CurrentUser user, Collection<ChangeControl> controls) throws RestApiException, UpdateException {
    batchAbandon(project, user, controls, "", NotifyHandling.ALL, ImmutableListMultimap.of());
}
#method_after
public void batchAbandon(BatchUpdate.Factory updateFactory, Project.NameKey project, CurrentUser user, Collection<ChangeData> changes, String msgTxt, NotifyHandling notifyHandling, ListMultimap<RecipientType, Account.Id> accountsToNotify) throws RestApiException, UpdateException {
    if (changes.isEmpty()) {
        return;
    }
    Account account = user.isIdentifiedUser() ? user.asIdentifiedUser().getAccount() : null;
    try (BatchUpdate u = updateFactory.create(dbProvider.get(), project, user, TimeUtil.nowTs())) {
        for (ChangeData change : changes) {
            if (!project.equals(change.project())) {
                throw new ResourceConflictException(String.format("Project name \"%s\" doesn't match \"%s\"", change.project().get(), project.get()));
            }
            u.addOp(change.getId(), abandonOpFactory.create(account, msgTxt, notifyHandling, accountsToNotify));
        }
        u.execute();
    }
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(ChangeResource resource) {
    boolean canAbandon = false;
    try {
        canAbandon = resource.getControl().canAbandon(dbProvider.get());
    } catch (OrmException e) {
        log.error("Cannot check canAbandon status. Assuming false.", e);
    }
    return new UiAction.Description().setLabel("Abandon").setTitle("Abandon the change").setVisible(resource.getChange().getStatus().isOpen() && canAbandon);
}
#method_after
@Override
public UiAction.Description getDescription(ChangeResource rsrc) {
    Change change = rsrc.getChange();
    return new UiAction.Description().setLabel("Abandon").setTitle("Abandon the change").setVisible(and(change.getStatus().isOpen(), rsrc.permissions().database(dbProvider).testCond(ChangePermission.ABANDON)));
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException, RepositoryNotFoundException, IOException {
    change = ctx.getChange();
    if (change.getStatus() != Status.NEW) {
        throw new ResourceConflictException("Change is " + status(change));
    }
    Project.NameKey projectKey = change.getProject();
    newDestKey = new Branch.NameKey(projectKey, input.destinationBranch);
    Branch.NameKey changePrevDest = change.getDest();
    if (changePrevDest.equals(newDestKey)) {
        throw new ResourceConflictException("Change is already destined for the specified branch");
    }
    final PatchSet.Id patchSetId = change.currentPatchSetId();
    try (Repository repo = repoManager.openRepository(projectKey);
        RevWalk revWalk = new RevWalk(repo)) {
        RevCommit currPatchsetRevCommit = revWalk.parseCommit(ObjectId.fromString(psUtil.current(ctx.getDb(), ctx.getNotes()).getRevision().get()));
        if (currPatchsetRevCommit.getParentCount() > 1) {
            throw new ResourceConflictException("Merge commit cannot be moved");
        }
        ObjectId refId = repo.resolve(input.destinationBranch);
        // Check if destination ref exists in project repo
        if (refId == null) {
            throw new ResourceConflictException("Destination " + input.destinationBranch + " not found in the project");
        }
        RevCommit refCommit = revWalk.parseCommit(refId);
        if (revWalk.isMergedInto(currPatchsetRevCommit, refCommit)) {
            throw new ResourceConflictException("Current patchset revision is reachable from tip of " + input.destinationBranch);
        }
    }
    Change.Key changeKey = change.getKey();
    if (!asChanges(queryProvider.get().byBranchKey(newDestKey, changeKey)).isEmpty()) {
        throw new ResourceConflictException("Destination " + newDestKey.getShortName() + " has a different change with same change key " + changeKey);
    }
    if (!change.currentPatchSetId().equals(patchSetId)) {
        throw new ResourceConflictException("Patch set is not current");
    }
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    update.setBranch(newDestKey.get());
    change.setDest(newDestKey);
    StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change destination moved from ");
    msgBuf.append(changePrevDest.getShortName());
    msgBuf.append(" to ");
    msgBuf.append(newDestKey.getShortName());
    if (!Strings.isNullOrEmpty(input.message)) {
        msgBuf.append("\n\n");
        msgBuf.append(input.message);
    }
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, msgBuf.toString(), ChangeMessagesUtil.TAG_MOVE);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException, RepositoryNotFoundException, IOException {
    change = ctx.getChange();
    if (change.getStatus() != Status.NEW) {
        throw new ResourceConflictException("Change is " + ChangeUtil.status(change));
    }
    Project.NameKey projectKey = change.getProject();
    newDestKey = new Branch.NameKey(projectKey, input.destinationBranch);
    Branch.NameKey changePrevDest = change.getDest();
    if (changePrevDest.equals(newDestKey)) {
        throw new ResourceConflictException("Change is already destined for the specified branch");
    }
    final PatchSet.Id patchSetId = change.currentPatchSetId();
    try (Repository repo = repoManager.openRepository(projectKey);
        RevWalk revWalk = new RevWalk(repo)) {
        RevCommit currPatchsetRevCommit = revWalk.parseCommit(ObjectId.fromString(psUtil.current(ctx.getDb(), ctx.getNotes()).getRevision().get()));
        if (currPatchsetRevCommit.getParentCount() > 1) {
            throw new ResourceConflictException("Merge commit cannot be moved");
        }
        ObjectId refId = repo.resolve(input.destinationBranch);
        // Check if destination ref exists in project repo
        if (refId == null) {
            throw new ResourceConflictException("Destination " + input.destinationBranch + " not found in the project");
        }
        RevCommit refCommit = revWalk.parseCommit(refId);
        if (revWalk.isMergedInto(currPatchsetRevCommit, refCommit)) {
            throw new ResourceConflictException("Current patchset revision is reachable from tip of " + input.destinationBranch);
        }
    }
    Change.Key changeKey = change.getKey();
    if (!asChanges(queryProvider.get().byBranchKey(newDestKey, changeKey)).isEmpty()) {
        throw new ResourceConflictException("Destination " + newDestKey.getShortName() + " has a different change with same change key " + changeKey);
    }
    if (!change.currentPatchSetId().equals(patchSetId)) {
        throw new ResourceConflictException("Patch set is not current");
    }
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    update.setBranch(newDestKey.get());
    change.setDest(newDestKey);
    StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change destination moved from ");
    msgBuf.append(changePrevDest.getShortName());
    msgBuf.append(" to ");
    msgBuf.append(newDestKey.getShortName());
    if (!Strings.isNullOrEmpty(input.message)) {
        msgBuf.append("\n\n");
        msgBuf.append(input.message);
    }
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, msgBuf.toString(), ChangeMessagesUtil.TAG_MOVE);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
    return true;
}
#end_block

#method_before
@Before
public void assumeSshIfRequired() {
    if (useSsh) {
        // If the test uses ssh, we use assume() to make sure ssh is enabled on
        // the test suite. JUnit will skip tests annotated with @UseSsh if we
        // disable them using the command line flag.
        assume().that(SshMode.useSsh()).isTrue();
    }
}
#method_after
@Before
public void assumeSshIfRequired() {
    if (testRequiresSsh) {
        // If the test uses ssh, we use assume() to make sure ssh is enabled on
        // the test suite. JUnit will skip tests annotated with @UseSsh if we
        // disable them using the command line flag.
        assume().that(SshMode.useSsh()).isTrue();
    }
}
#end_block

#method_before
@AfterClass
public static void stopCommonServer() throws Exception {
    if (commonServer != null) {
        try {
            commonServer.stop();
        } finally {
            commonServer = null;
        }
    }
    TempFileUtil.cleanup();
}
#method_after
@AfterClass
public static void stopCommonServer() throws Exception {
    if (commonServer != null) {
        try {
            commonServer.close();
        } catch (Throwable t) {
            throw new AssertionError("Error stopping common server in " + (firstTest != null ? firstTest.getTestClass().getName() : "unknown test class"), t);
        } finally {
            commonServer = null;
        }
    }
    TempFileUtil.cleanup();
}
#end_block

#method_before
protected void beforeTest(Description description) throws Exception {
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setString("gerrit", null, "tempSiteDir", tempSiteDir.getRoot().getPath());
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.start(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.start(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    notesMigration.setFromEnv();
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    admin = accounts.admin();
    user = accounts.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    db = reviewDbProvider.open();
    if (classDesc.useSsh() || methodDesc.useSsh()) {
        useSsh = true;
        if (SshMode.useSsh() && (adminSshSession == null || userSshSession == null)) {
            // Create Ssh sessions
            initSsh(admin);
            Context ctx = newRequestContext(user);
            atrScope.set(ctx);
            userSshSession = ctx.getSession();
            userSshSession.open();
            ctx = newRequestContext(admin);
            atrScope.set(ctx);
            adminSshSession = ctx.getSession();
            adminSshSession.open();
        }
    } else {
        useSsh = false;
    }
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#method_after
protected void beforeTest(Description description) throws Exception {
    this.description = description;
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.initAndStart(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.initAndStart(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    db = reviewDbProvider.open();
    // As a workaround, we simply reindex all available groups here.
    for (AccountGroup group : groups.getAll(db).collect(toList())) {
        groupCache.evict(group.getGroupUUID(), group.getId(), group.getNameKey());
    }
    admin = accountCreator.admin();
    user = accountCreator.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    testRequiresSsh = classDesc.useSshAnnotation() || methodDesc.useSshAnnotation();
    if (testRequiresSsh && SshMode.useSsh() && (adminSshSession == null || userSshSession == null)) {
        // Create Ssh sessions
        initSsh(admin);
        Context ctx = newRequestContext(user);
        atrScope.set(ctx);
        userSshSession = ctx.getSession();
        userSshSession.open();
        ctx = newRequestContext(admin);
        atrScope.set(ctx);
        adminSshSession = ctx.getSession();
        adminSshSession.open();
    }
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#end_block

#method_before
private TestAccount getCloneAsAccount(Description description) {
    TestProjectInput ann = description.getAnnotation(TestProjectInput.class);
    return accounts.get(ann != null ? ann.cloneAs() : "admin");
}
#method_after
private TestAccount getCloneAsAccount(Description description) {
    TestProjectInput ann = description.getAnnotation(TestProjectInput.class);
    return accountCreator.get(ann != null ? ann.cloneAs() : "admin");
}
#end_block

#method_before
protected TestRepository<InMemoryRepository> cloneProject(Project.NameKey p, TestAccount testAccount) throws Exception {
    InProcessProtocol.Context ctx = new InProcessProtocol.Context(reviewDbProvider, identifiedUserFactory, testAccount.getId(), p);
    Repository repo = repoManager.openRepository(p);
    toClose.add(repo);
    return GitUtil.cloneProject(p, inProcessProtocol.register(ctx, repo).toString());
}
#method_after
protected TestRepository<InMemoryRepository> cloneProject(Project.NameKey p, TestAccount testAccount) throws Exception {
    return GitUtil.cloneProject(p, registerRepoConnection(p, testAccount));
}
#end_block

#method_before
private void afterTest() throws Exception {
    Transport.unregister(inProcessProtocol);
    for (Repository repo : toClose) {
        repo.close();
    }
    db.close();
    if (adminSshSession != null) {
        adminSshSession.close();
    }
    if (userSshSession != null) {
        userSshSession.close();
    }
    if (server != commonServer) {
        server.stop();
    }
}
#method_after
protected void afterTest() throws Exception {
    Transport.unregister(inProcessProtocol);
    for (Repository repo : toClose) {
        repo.close();
    }
    db.close();
    if (adminSshSession != null) {
        adminSshSession.close();
    }
    if (userSshSession != null) {
        userSshSession.close();
    }
    if (server != commonServer) {
        server.close();
        server = null;
    }
    NoteDbMode.resetFromEnv(notesMigration);
}
#end_block

#method_before
protected PushOneCommit.Result amendChange(String changeId, String ref, TestAccount testAccount, TestRepository<?> repo) throws Exception {
    Collections.shuffle(RANDOM);
    PushOneCommit push = pushFactory.create(db, testAccount.getIdent(), repo, PushOneCommit.SUBJECT, PushOneCommit.FILE_NAME, new String(Chars.toArray(RANDOM)), changeId);
    return push.to(ref);
}
#method_after
protected PushOneCommit.Result amendChange(String changeId, String ref, TestAccount testAccount, TestRepository<?> repo) throws Exception {
    Collections.shuffle(RANDOM);
    return amendChange(changeId, ref, testAccount, repo, PushOneCommit.SUBJECT, PushOneCommit.FILE_NAME, new String(Chars.toArray(RANDOM)));
}
#end_block

#method_before
protected PushOneCommit.Result amendChange(String changeId, String ref, TestAccount testAccount, TestRepository<?> repo) throws Exception {
    Collections.shuffle(RANDOM);
    PushOneCommit push = pushFactory.create(db, testAccount.getIdent(), repo, PushOneCommit.SUBJECT, PushOneCommit.FILE_NAME, new String(Chars.toArray(RANDOM)), changeId);
    return push.to(ref);
}
#method_after
protected PushOneCommit.Result amendChange(String changeId, String subject, String fileName, String content) throws Exception {
    return amendChange(changeId, "refs/for/master", admin, testRepo, subject, fileName, content);
}
#end_block

#method_before
protected ChangeInfo get(String id, ListChangesOption... options) throws RestApiException {
    return gApi.changes().id(id).get(Sets.newEnumSet(Arrays.asList(options), ListChangesOption.class));
}
#method_after
protected ChangeInfo get(String id, ListChangesOption... options) throws RestApiException {
    return gApi.changes().id(id).get(options);
}
#end_block

#method_before
protected Context disableDb() {
    notesMigration.setFailOnLoad(true);
    return atrScope.disableDb();
}
#method_after
protected Context disableDb() {
    notesMigration.setFailOnLoadForTest(true);
    return atrScope.disableDb();
}
#end_block

#method_before
protected void enableDb(Context preDisableContext) {
    notesMigration.setFailOnLoad(false);
    atrScope.set(preDisableContext);
}
#method_after
protected void enableDb(Context preDisableContext) {
    notesMigration.setFailOnLoadForTest(false);
    atrScope.set(preDisableContext);
}
#end_block

#method_before
protected void allow(String permission, AccountGroup.UUID id, String ref) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.allow(cfg, permission, id, ref);
    saveProjectConfig(project, cfg);
}
#method_after
protected void allow(String ref, String permission, AccountGroup.UUID id) throws Exception {
    allow(project, ref, permission, id);
}
#end_block

#method_before
protected void deny(Project.NameKey p, String permission, AccountGroup.UUID id, String ref) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.deny(cfg, permission, id, ref);
    saveProjectConfig(p, cfg);
}
#method_after
protected void deny(String ref, String permission, AccountGroup.UUID id) throws Exception {
    deny(project, ref, permission, id);
}
#end_block

#method_before
protected PermissionRule block(String permission, AccountGroup.UUID id, String ref, Project.NameKey project) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    PermissionRule rule = Util.block(cfg, permission, id, ref);
    saveProjectConfig(project, cfg);
    return rule;
}
#method_after
protected PermissionRule block(String ref, String permission, AccountGroup.UUID id) throws Exception {
    return block(project, ref, permission, id);
}
#end_block

#method_before
protected void grant(String permission, Project.NameKey project, String ref, boolean force, AccountGroup.UUID groupUUID) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(project)) {
        md.setMessage(String.format("Grant %s on %s", permission, ref));
        ProjectConfig config = ProjectConfig.read(md);
        AccessSection s = config.getAccessSection(ref, true);
        Permission p = s.getPermission(permission, true);
        PermissionRule rule = Util.newRule(config, groupUUID);
        rule.setForce(force);
        p.add(rule);
        config.commit(md);
        projectCache.evict(config.getProject());
    }
}
#method_after
protected void grant(Project.NameKey project, String ref, String permission) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    grant(project, ref, permission, false);
}
#end_block

#method_before
protected void removePermission(String permission, Project.NameKey project, String ref) throws IOException, ConfigInvalidException {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(project)) {
        md.setMessage(String.format("Remove %s on %s", permission, ref));
        ProjectConfig config = ProjectConfig.read(md);
        AccessSection s = config.getAccessSection(ref, true);
        Permission p = s.getPermission(permission, true);
        p.getRules().clear();
        config.commit(md);
        projectCache.evict(config.getProject());
    }
}
#method_after
protected void removePermission(Project.NameKey project, String ref, String permission) throws IOException, ConfigInvalidException {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(project)) {
        md.setMessage(String.format("Remove %s on %s", permission, ref));
        ProjectConfig config = ProjectConfig.read(md);
        AccessSection s = config.getAccessSection(ref, true);
        Permission p = s.getPermission(permission, true);
        p.getRules().clear();
        config.commit(md);
        projectCache.evict(config.getProject());
    }
}
#end_block

#method_before
protected void blockRead(String ref) throws Exception {
    block(Permission.READ, REGISTERED_USERS, ref);
}
#method_after
protected void blockRead(String ref) throws Exception {
    block(ref, Permission.READ, REGISTERED_USERS);
}
#end_block

#method_before
protected ChangeResource parseChangeResource(String changeId) throws Exception {
    List<ChangeControl> ctls = changeFinder.find(changeId, atrScope.get().getUser());
    assertThat(ctls).hasSize(1);
    return changeResourceFactory.create(ctls.get(0));
}
#method_after
protected ChangeResource parseChangeResource(String changeId) throws Exception {
    List<ChangeNotes> notes = changeFinder.find(changeId);
    assertThat(notes).hasSize(1);
    return changeResourceFactory.create(notes.get(0), atrScope.get().getUser());
}
#end_block

#method_before
protected void grantTagPermissions() throws Exception {
    grant(Permission.CREATE, project, R_TAGS + "*");
    grant(Permission.CREATE_TAG, project, R_TAGS + "*");
    grant(Permission.CREATE_SIGNED_TAG, project, R_TAGS + "*");
}
#method_after
protected void grantTagPermissions() throws Exception {
    grant(project, R_TAGS + "*", Permission.CREATE);
    grant(project, R_TAGS + "", Permission.DELETE);
    grant(project, R_TAGS + "*", Permission.CREATE_TAG);
    grant(project, R_TAGS + "*", Permission.CREATE_SIGNED_TAG);
}
#end_block

#method_before
protected ContributorAgreement configureContributorAgreement(boolean autoVerify) throws Exception {
    ContributorAgreement ca;
    if (autoVerify) {
        String g = createGroup("cla-test-group");
        GroupApi groupApi = gApi.groups().id(g);
        groupApi.description("CLA test group");
        AccountGroup caGroup = groupCache.get(new AccountGroup.UUID(groupApi.detail().id));
        GroupReference groupRef = GroupReference.forGroup(caGroup);
        PermissionRule rule = new PermissionRule(groupRef);
        rule.setAction(PermissionRule.Action.ALLOW);
        ca = new ContributorAgreement("cla-test");
        ca.setAutoVerify(groupRef);
        ca.setAccepted(ImmutableList.of(rule));
    } else {
        ca = new ContributorAgreement("cla-test-no-auto-verify");
    }
    ca.setDescription("description");
    ca.setAgreementUrl("agreement-url");
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    cfg.replace(ca);
    saveProjectConfig(allProjects, cfg);
    return ca;
}
#method_after
protected ContributorAgreement configureContributorAgreement(boolean autoVerify) throws Exception {
    ContributorAgreement ca;
    if (autoVerify) {
        String g = createGroup("cla-test-group");
        GroupApi groupApi = gApi.groups().id(g);
        groupApi.description("CLA test group");
        InternalGroup caGroup = groupCache.get(new AccountGroup.UUID(groupApi.detail().id)).orElse(null);
        GroupReference groupRef = new GroupReference(caGroup.getGroupUUID(), caGroup.getName());
        PermissionRule rule = new PermissionRule(groupRef);
        rule.setAction(PermissionRule.Action.ALLOW);
        ca = new ContributorAgreement("cla-test");
        ca.setAutoVerify(groupRef);
        ca.setAccepted(ImmutableList.of(rule));
    } else {
        ca = new ContributorAgreement("cla-test-no-auto-verify");
    }
    ca.setDescription("description");
    ca.setAgreementUrl("agreement-url");
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    cfg.replace(ca);
    saveProjectConfig(allProjects, cfg);
    return ca;
}
#end_block

#method_before
protected Map<Branch.NameKey, RevTree> fetchFromBundles(BinaryResult bundles) throws Exception {
    assertThat(bundles.getContentType()).isEqualTo("application/x-zip");
    File tempfile = File.createTempFile("test", null);
    bundles.writeTo(new FileOutputStream(tempfile));
    Map<Branch.NameKey, RevTree> ret = new HashMap<>();
    try (ZipFile readback = new ZipFile(tempfile)) {
        for (ZipEntry entry : ImmutableList.copyOf(Iterators.forEnumeration(readback.entries()))) {
            String bundleName = entry.getName();
            InputStream bundleStream = readback.getInputStream(entry);
            int len = bundleName.length();
            assertThat(bundleName).endsWith(".git");
            String repoName = bundleName.substring(0, len - 4);
            Project.NameKey proj = new Project.NameKey(repoName);
            TestRepository<?> localRepo = cloneProject(proj);
            try (TransportBundleStream tbs = new TransportBundleStream(localRepo.getRepository(), new URIish(bundleName), bundleStream)) {
                FetchResult fr = tbs.fetch(NullProgressMonitor.INSTANCE, Arrays.asList(new RefSpec("refs/*:refs/preview/*")));
                for (Ref r : fr.getAdvertisedRefs()) {
                    String branchName = r.getName();
                    Branch.NameKey n = new Branch.NameKey(proj, branchName);
                    RevCommit c = localRepo.getRevWalk().parseCommit(r.getObjectId());
                    ret.put(n, c.getTree());
                }
            }
        }
    }
    return ret;
}
#method_after
protected Map<Branch.NameKey, ObjectId> fetchFromBundles(BinaryResult bundles) throws Exception {
    assertThat(bundles.getContentType()).isEqualTo("application/x-zip");
    FileSystem fs = Jimfs.newFileSystem();
    Path previewPath = fs.getPath("preview.zip");
    try (OutputStream out = Files.newOutputStream(previewPath)) {
        bundles.writeTo(out);
    }
    Map<Branch.NameKey, ObjectId> ret = new HashMap<>();
    try (FileSystem zipFs = FileSystems.newFileSystem(previewPath, null);
        DirectoryStream<Path> dirStream = Files.newDirectoryStream(Iterables.getOnlyElement(zipFs.getRootDirectories()))) {
        for (Path p : dirStream) {
            if (!Files.isRegularFile(p)) {
                continue;
            }
            String bundleName = p.getFileName().toString();
            int len = bundleName.length();
            assertThat(bundleName).endsWith(".git");
            String repoName = bundleName.substring(0, len - 4);
            Project.NameKey proj = new Project.NameKey(repoName);
            TestRepository<?> localRepo = cloneProject(proj);
            try (InputStream bundleStream = Files.newInputStream(p);
                TransportBundleStream tbs = new TransportBundleStream(localRepo.getRepository(), new URIish(bundleName), bundleStream)) {
                FetchResult fr = tbs.fetch(NullProgressMonitor.INSTANCE, Arrays.asList(new RefSpec("refs/*:refs/preview/*")));
                for (Ref r : fr.getAdvertisedRefs()) {
                    String refName = r.getName();
                    if (RefNames.isNoteDbMetaRef(refName)) {
                        continue;
                    }
                    RevCommit c = localRepo.getRevWalk().parseCommit(r.getObjectId());
                    ret.put(new Branch.NameKey(proj, refName), c.getTree().copy());
                }
            }
        }
    }
    assertThat(ret).isNotEmpty();
    return ret;
}
#end_block

#method_before
protected TestRepository<?> createProjectWithPush(String name, @Nullable Project.NameKey parent, SubmitType submitType) throws Exception {
    Project.NameKey project = createProject(name, parent, true, submitType);
    grant(Permission.PUSH, project, "refs/heads/*");
    grant(Permission.SUBMIT, project, "refs/for/refs/heads/*");
    return cloneProject(project);
}
#method_after
protected TestRepository<?> createProjectWithPush(String name, @Nullable Project.NameKey parent, SubmitType submitType) throws Exception {
    Project.NameKey project = createProject(name, parent, true, submitType);
    grant(project, "refs/heads/*", Permission.PUSH);
    grant(project, "refs/for/refs/heads/*", Permission.SUBMIT);
    return cloneProject(project);
}
#end_block

#method_before
protected void assertNotifyTo(TestAccount expected) {
    assertThat(sender.getMessages()).hasSize(1);
    Message m = sender.getMessages().get(0);
    assertThat(m.rcpt()).containsExactly(expected.emailAddress);
    assertThat(((EmailHeader.AddressList) m.headers().get("To")).getAddressList()).containsExactly(expected.emailAddress);
    assertThat(m.headers().get("CC").isEmpty()).isTrue();
}
#method_after
protected void assertNotifyTo(TestAccount expected) {
    assertNotifyTo(expected.emailAddress);
}
#end_block

#method_before
protected void assertNotifyTo(TestAccount expected) {
    assertThat(sender.getMessages()).hasSize(1);
    Message m = sender.getMessages().get(0);
    assertThat(m.rcpt()).containsExactly(expected.emailAddress);
    assertThat(((EmailHeader.AddressList) m.headers().get("To")).getAddressList()).containsExactly(expected.emailAddress);
    assertThat(m.headers().get("CC").isEmpty()).isTrue();
}
#method_after
protected void assertNotifyTo(Address expected) {
    assertThat(sender.getMessages()).hasSize(1);
    Message m = sender.getMessages().get(0);
    assertThat(m.rcpt()).containsExactly(expected);
    assertThat(((EmailHeader.AddressList) m.headers().get("To")).getAddressList()).containsExactly(expected);
    assertThat(m.headers().get("CC").isEmpty()).isTrue();
}
#end_block

#method_before
protected void assertNotifyCc(TestAccount expected) {
    assertThat(sender.getMessages()).hasSize(1);
    Message m = sender.getMessages().get(0);
    assertThat(m.rcpt()).containsExactly(expected.emailAddress);
    assertThat(m.headers().get("To").isEmpty()).isTrue();
    assertThat(((EmailHeader.AddressList) m.headers().get("CC")).getAddressList()).containsExactly(expected.emailAddress);
}
#method_after
protected void assertNotifyCc(TestAccount expected) {
    assertNotifyCc(expected.emailAddress);
}
#end_block

#method_before
protected void assertNotifyCc(TestAccount expected) {
    assertThat(sender.getMessages()).hasSize(1);
    Message m = sender.getMessages().get(0);
    assertThat(m.rcpt()).containsExactly(expected.emailAddress);
    assertThat(m.headers().get("To").isEmpty()).isTrue();
    assertThat(((EmailHeader.AddressList) m.headers().get("CC")).getAddressList()).containsExactly(expected.emailAddress);
}
#method_after
protected void assertNotifyCc(Address expected) {
    assertThat(sender.getMessages()).hasSize(1);
    Message m = sender.getMessages().get(0);
    assertThat(m.rcpt()).containsExactly(expected);
    assertThat(m.headers().get("To").isEmpty()).isTrue();
    assertThat(((EmailHeader.AddressList) m.headers().get("CC")).getAddressList()).containsExactly(expected);
}
#end_block

#method_before
protected void watch(String project, String filter) throws RestApiException {
    List<ProjectWatchInfo> projectsToWatch = new ArrayList<>();
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = project;
    pwi.filter = filter;
    pwi.notifyAbandonedChanges = true;
    pwi.notifyNewChanges = true;
    pwi.notifyAllComments = true;
    projectsToWatch.add(pwi);
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
}
#method_after
protected void watch(String project, ProjectWatchInfoConfiguration config) throws RestApiException {
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = project;
    config.configure(pwi);
    gApi.accounts().self().setWatchedProjects(ImmutableList.of(pwi));
}
#end_block

#method_before
protected void watch(String project, String filter) throws RestApiException {
    List<ProjectWatchInfo> projectsToWatch = new ArrayList<>();
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = project;
    pwi.filter = filter;
    pwi.notifyAbandonedChanges = true;
    pwi.notifyNewChanges = true;
    pwi.notifyAllComments = true;
    projectsToWatch.add(pwi);
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
}
#method_after
protected void watch(String project, String filter) throws RestApiException {
    watch(project, pwi -> {
        pwi.filter = filter;
        pwi.notifyAbandonedChanges = true;
        pwi.notifyNewChanges = true;
        pwi.notifyAllComments = true;
    });
}
#end_block

#method_before
public ChangeAttribute asChangeAttribute(ReviewDb db, Change change) {
    ChangeAttribute a = new ChangeAttribute();
    a.project = change.getProject().get();
    a.branch = change.getDest().getShortName();
    a.topic = change.getTopic();
    a.id = change.getKey().get();
    a.number = change.getId().get();
    a.subject = change.getSubject();
    try {
        a.commitMessage = changeDataFactory.create(db, change).commitMessage();
    } catch (Exception e) {
        log.error("Error while getting full commit message for" + " change " + a.number);
    }
    a.url = getChangeUrl(change);
    a.owner = asAccountAttribute(change.getOwner());
    a.assignee = asAccountAttribute(change.getAssignee());
    a.status = change.getStatus();
    return a;
}
#method_after
public ChangeAttribute asChangeAttribute(ReviewDb db, Change change) {
    ChangeAttribute a = new ChangeAttribute();
    a.project = change.getProject().get();
    a.branch = change.getDest().getShortName();
    a.topic = change.getTopic();
    a.id = change.getKey().get();
    a.number = change.getId().get();
    a.subject = change.getSubject();
    try {
        a.commitMessage = changeDataFactory.create(db, change).commitMessage();
    } catch (Exception e) {
        log.error("Error while getting full commit message for change " + a.number);
    }
    a.url = getChangeUrl(change);
    a.owner = asAccountAttribute(change.getOwner());
    a.assignee = asAccountAttribute(change.getAssignee());
    a.status = change.getStatus();
    return a;
}
#end_block

#method_before
private void addNeededBy(RevWalk rw, ChangeAttribute ca, Change change, PatchSet currentPs) throws OrmException, IOException {
    if (currentPs.getGroups().isEmpty()) {
        return;
    }
    String rev = currentPs.getRevision().get();
    // set whose parent matches this patch set's revision.
    for (ChangeData cd : queryProvider.get().byProjectGroups(change.getProject(), currentPs.getGroups())) {
        patchSets: for (PatchSet ps : cd.patchSets()) {
            RevCommit commit = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
            for (RevCommit p : commit.getParents()) {
                if (!p.name().equals(rev)) {
                    continue;
                }
                ca.neededBy.add(newNeededBy(checkNotNull(cd.change()), ps));
                continue patchSets;
            }
        }
    }
}
#method_after
private void addNeededBy(RevWalk rw, ChangeAttribute ca, Change change, PatchSet currentPs) throws OrmException, IOException {
    if (currentPs.getGroups().isEmpty()) {
        return;
    }
    String rev = currentPs.getRevision().get();
    // set whose parent matches this patch set's revision.
    for (ChangeData cd : queryProvider.get().byProjectGroups(change.getProject(), currentPs.getGroups())) {
        PATCH_SETS: for (PatchSet ps : cd.patchSets()) {
            RevCommit commit = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
            for (RevCommit p : commit.getParents()) {
                if (!p.name().equals(rev)) {
                    continue;
                }
                ca.neededBy.add(newNeededBy(checkNotNull(cd.change()), ps));
                continue PATCH_SETS;
            }
        }
    }
}
#end_block

#method_before
public PatchSetAttribute asPatchSetAttribute(ReviewDb db, RevWalk revWalk, Change change, PatchSet patchSet) {
    PatchSetAttribute p = new PatchSetAttribute();
    p.revision = patchSet.getRevision().get();
    p.number = patchSet.getPatchSetId();
    p.ref = patchSet.getRefName();
    p.uploader = asAccountAttribute(patchSet.getUploader());
    p.createdOn = patchSet.getCreatedOn().getTime() / 1000L;
    PatchSet.Id pId = patchSet.getId();
    try {
        p.parents = new ArrayList<>();
        RevCommit c = revWalk.parseCommit(ObjectId.fromString(p.revision));
        for (RevCommit parent : c.getParents()) {
            p.parents.add(parent.name());
        }
        UserIdentity author = toUserIdentity(c.getAuthorIdent());
        if (author.getAccount() == null) {
            p.author = new AccountAttribute();
            p.author.email = author.getEmail();
            p.author.name = author.getName();
            p.author.username = "";
        } else {
            p.author = asAccountAttribute(author.getAccount());
        }
        List<Patch> list = patchListCache.get(change, patchSet).toPatchList(pId);
        for (Patch pe : list) {
            if (!Patch.isMagic(pe.getFileName())) {
                p.sizeDeletions -= pe.getDeletions();
                p.sizeInsertions += pe.getInsertions();
            }
        }
        p.kind = changeKindCache.getChangeKind(db, change, patchSet);
    } catch (IOException e) {
        log.error("Cannot load patch set data for " + patchSet.getId(), e);
    } catch (PatchListNotAvailableException e) {
        log.error(String.format("Cannot get size information for %s.", pId), e);
    }
    return p;
}
#method_after
public PatchSetAttribute asPatchSetAttribute(ReviewDb db, RevWalk revWalk, Change change, PatchSet patchSet) {
    PatchSetAttribute p = new PatchSetAttribute();
    p.revision = patchSet.getRevision().get();
    p.number = patchSet.getPatchSetId();
    p.ref = patchSet.getRefName();
    p.uploader = asAccountAttribute(patchSet.getUploader());
    p.createdOn = patchSet.getCreatedOn().getTime() / 1000L;
    PatchSet.Id pId = patchSet.getId();
    try {
        p.parents = new ArrayList<>();
        RevCommit c = revWalk.parseCommit(ObjectId.fromString(p.revision));
        for (RevCommit parent : c.getParents()) {
            p.parents.add(parent.name());
        }
        UserIdentity author = toUserIdentity(c.getAuthorIdent());
        if (author.getAccount() == null) {
            p.author = new AccountAttribute();
            p.author.email = author.getEmail();
            p.author.name = author.getName();
            p.author.username = "";
        } else {
            p.author = asAccountAttribute(author.getAccount());
        }
        List<Patch> list = patchListCache.get(change, patchSet).toPatchList(pId);
        for (Patch pe : list) {
            if (!Patch.isMagic(pe.getFileName())) {
                p.sizeDeletions -= pe.getDeletions();
                p.sizeInsertions += pe.getInsertions();
            }
        }
        p.kind = changeKindCache.getChangeKind(db, change, patchSet);
    } catch (IOException | OrmException e) {
        log.error("Cannot load patch set data for " + patchSet.getId(), e);
    } catch (PatchListNotAvailableException e) {
        log.error(String.format("Cannot get size information for %s.", pId), e);
    }
    return p;
}
#end_block

#method_before
// TODO: The same method exists in PatchSetInfoFactory, find a common place
private UserIdentity toUserIdentity(PersonIdent who) {
    UserIdentity u = new UserIdentity();
    u.setName(who.getName());
    u.setEmail(who.getEmailAddress());
    u.setDate(new Timestamp(who.getWhen().getTime()));
    u.setTimeZone(who.getTimeZoneOffset());
    // If only one account has access to this email address, select it
    // as the identity of the user.
    // 
    Set<Account.Id> a = byEmailCache.get(u.getEmail());
    if (a.size() == 1) {
        u.setAccount(a.iterator().next());
    }
    return u;
}
#method_after
// TODO: The same method exists in PatchSetInfoFactory, find a common place
private UserIdentity toUserIdentity(PersonIdent who) throws IOException, OrmException {
    UserIdentity u = new UserIdentity();
    u.setName(who.getName());
    u.setEmail(who.getEmailAddress());
    u.setDate(new Timestamp(who.getWhen().getTime()));
    u.setTimeZone(who.getTimeZoneOffset());
    // If only one account has access to this email address, select it
    // as the identity of the user.
    // 
    Set<Account.Id> a = emails.getAccountFor(u.getEmail());
    if (a.size() == 1) {
        u.setAccount(a.iterator().next());
    }
    return u;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    admins = groupCache.get(new AccountGroup.NameKey("Administrators")).getGroupUUID();
    setUpPermissions();
    setUpChanges();
}
#method_after
@Before
public void setUp() throws Exception {
    admins = groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID();
    setUpPermissions();
    setUpChanges();
}
#end_block

#method_before
private void setUpChanges() throws Exception {
    gApi.projects().name(project.get()).branch("branch").create(new BranchInput());
    // First 2 changes are merged, which means the tags pointing to them are
    // visible.
    allow(Permission.SUBMIT, admins, "refs/for/refs/heads/*");
    PushOneCommit.Result mr = pushFactory.create(db, admin.getIdent(), testRepo).to("refs/for/master%submit");
    mr.assertOkStatus();
    c1 = mr.getChange();
    r1 = changeRefPrefix(c1.getId());
    PushOneCommit.Result br = pushFactory.create(db, admin.getIdent(), testRepo).to("refs/for/branch%submit");
    br.assertOkStatus();
    c2 = br.getChange();
    r2 = changeRefPrefix(c2.getId());
    // Second 2 changes are unmerged.
    mr = pushFactory.create(db, admin.getIdent(), testRepo).to("refs/for/master");
    mr.assertOkStatus();
    c3 = mr.getChange();
    r3 = changeRefPrefix(c3.getId());
    br = pushFactory.create(db, admin.getIdent(), testRepo).to("refs/for/branch");
    br.assertOkStatus();
    c4 = br.getChange();
    r4 = changeRefPrefix(c4.getId());
    try (Repository repo = repoManager.openRepository(project)) {
        // master-tag -> master
        RefUpdate mtu = repo.updateRef("refs/tags/master-tag");
        mtu.setExpectedOldObjectId(ObjectId.zeroId());
        mtu.setNewObjectId(repo.exactRef("refs/heads/master").getObjectId());
        assertThat(mtu.update()).isEqualTo(RefUpdate.Result.NEW);
        // branch-tag -> branch
        RefUpdate btu = repo.updateRef("refs/tags/branch-tag");
        btu.setExpectedOldObjectId(ObjectId.zeroId());
        btu.setNewObjectId(repo.exactRef("refs/heads/branch").getObjectId());
        assertThat(btu.update()).isEqualTo(RefUpdate.Result.NEW);
    }
}
#method_after
private void setUpChanges() throws Exception {
    gApi.projects().name(project.get()).branch("branch").create(new BranchInput());
    // First 2 changes are merged, which means the tags pointing to them are
    // visible.
    allow("refs/for/refs/heads/*", Permission.SUBMIT, admins);
    PushOneCommit.Result mr = pushFactory.create(db, admin.getIdent(), testRepo).to("refs/for/master%submit");
    mr.assertOkStatus();
    c1 = mr.getChange();
    r1 = changeRefPrefix(c1.getId());
    PushOneCommit.Result br = pushFactory.create(db, admin.getIdent(), testRepo).to("refs/for/branch%submit");
    br.assertOkStatus();
    c2 = br.getChange();
    r2 = changeRefPrefix(c2.getId());
    // Second 2 changes are unmerged.
    mr = pushFactory.create(db, admin.getIdent(), testRepo).to("refs/for/master");
    mr.assertOkStatus();
    c3 = mr.getChange();
    r3 = changeRefPrefix(c3.getId());
    br = pushFactory.create(db, admin.getIdent(), testRepo).to("refs/for/branch");
    br.assertOkStatus();
    c4 = br.getChange();
    r4 = changeRefPrefix(c4.getId());
    try (Repository repo = repoManager.openRepository(project)) {
        // master-tag -> master
        RefUpdate mtu = repo.updateRef("refs/tags/master-tag");
        mtu.setExpectedOldObjectId(ObjectId.zeroId());
        mtu.setNewObjectId(repo.exactRef("refs/heads/master").getObjectId());
        assertThat(mtu.update()).isEqualTo(RefUpdate.Result.NEW);
        // branch-tag -> branch
        RefUpdate btu = repo.updateRef("refs/tags/branch-tag");
        btu.setExpectedOldObjectId(ObjectId.zeroId());
        btu.setNewObjectId(repo.exactRef("refs/heads/branch").getObjectId());
        assertThat(btu.update()).isEqualTo(RefUpdate.Result.NEW);
    }
}
#end_block

#method_before
@Test
public void uploadPackAllRefsVisibleWithRefsMetaConfig() throws Exception {
    allow(Permission.READ, REGISTERED_USERS, "refs/*");
    allow(Permission.READ, REGISTERED_USERS, RefNames.REFS_CONFIG);
    assertUploadPackRefs("HEAD", r1 + "1", r1 + "meta", r2 + "1", r2 + "meta", r3 + "1", r3 + "meta", r4 + "1", r4 + "meta", "refs/heads/branch", "refs/heads/master", RefNames.REFS_CONFIG, "refs/tags/branch-tag", "refs/tags/master-tag");
}
#method_after
@Test
public void uploadPackAllRefsVisibleWithRefsMetaConfig() throws Exception {
    allow("refs/*", Permission.READ, REGISTERED_USERS);
    allow(RefNames.REFS_CONFIG, Permission.READ, REGISTERED_USERS);
    assertUploadPackRefs("HEAD", r1 + "1", r1 + "meta", r2 + "1", r2 + "meta", r3 + "1", r3 + "meta", r4 + "1", r4 + "meta", "refs/heads/branch", "refs/heads/master", RefNames.REFS_CONFIG, "refs/tags/branch-tag", "refs/tags/master-tag");
}
#end_block

#method_before
@Test
public void uploadPackSubsetOfBranchesVisibleIncludingHead() throws Exception {
    allow(Permission.READ, REGISTERED_USERS, "refs/heads/master");
    deny(Permission.READ, REGISTERED_USERS, "refs/heads/branch");
    setApiUser(user);
    assertUploadPackRefs("HEAD", r1 + "1", r1 + "meta", r3 + "1", r3 + "meta", "refs/heads/master", "refs/tags/master-tag");
}
#method_after
@Test
public void uploadPackSubsetOfBranchesVisibleIncludingHead() throws Exception {
    allow("refs/heads/master", Permission.READ, REGISTERED_USERS);
    deny("refs/heads/branch", Permission.READ, REGISTERED_USERS);
    setApiUser(user);
    assertUploadPackRefs("HEAD", r1 + "1", r1 + "meta", r3 + "1", r3 + "meta", "refs/heads/master", "refs/tags/master-tag");
}
#end_block

#method_before
@Test
public void uploadPackSubsetOfBranchesVisibleNotIncludingHead() throws Exception {
    deny(Permission.READ, REGISTERED_USERS, "refs/heads/master");
    allow(Permission.READ, REGISTERED_USERS, "refs/heads/branch");
    setApiUser(user);
    assertUploadPackRefs(r2 + "1", r2 + "meta", r4 + "1", r4 + "meta", "refs/heads/branch", "refs/tags/branch-tag", // (since PushOneCommit always bases changes on each other).
    "refs/tags/master-tag");
}
#method_after
@Test
public void uploadPackSubsetOfBranchesVisibleNotIncludingHead() throws Exception {
    deny("refs/heads/master", Permission.READ, REGISTERED_USERS);
    allow("refs/heads/branch", Permission.READ, REGISTERED_USERS);
    setApiUser(user);
    assertUploadPackRefs(r2 + "1", r2 + "meta", r4 + "1", r4 + "meta", "refs/heads/branch", "refs/tags/branch-tag", // (since PushOneCommit always bases changes on each other).
    "refs/tags/master-tag");
}
#end_block

#method_before
@Test
public void uploadPackSubsetOfBranchesVisibleWithEdit() throws Exception {
    allow(Permission.READ, REGISTERED_USERS, "refs/heads/master");
    deny(Permission.READ, REGISTERED_USERS, "refs/heads/branch");
    Change c = notesFactory.createChecked(db, project, c1.getId()).getChange();
    String changeId = c.getKey().get();
    // Admin's edit is not visible.
    setApiUser(admin);
    gApi.changes().id(changeId).edit().create();
    // User's edit is visible.
    setApiUser(user);
    gApi.changes().id(changeId).edit().create();
    assertUploadPackRefs("HEAD", r1 + "1", r1 + "meta", r3 + "1", r3 + "meta", "refs/heads/master", "refs/tags/master-tag", "refs/users/01/1000001/edit-" + c1.getId() + "/1");
}
#method_after
@Test
public void uploadPackSubsetOfBranchesVisibleWithEdit() throws Exception {
    allow("refs/heads/master", Permission.READ, REGISTERED_USERS);
    Change c = notesFactory.createChecked(db, project, c1.getId()).getChange();
    String changeId = c.getKey().get();
    // Admin's edit is not visible.
    setApiUser(admin);
    gApi.changes().id(changeId).edit().create();
    // User's edit is visible.
    setApiUser(user);
    gApi.changes().id(changeId).edit().create();
    assertUploadPackRefs("HEAD", r1 + "1", r1 + "meta", r3 + "1", r3 + "meta", "refs/heads/master", "refs/tags/master-tag", "refs/users/01/1000001/edit-" + c1.getId() + "/1");
}
#end_block

#method_before
@Test
public void uploadPackSubsetOfRefsVisibleWithAccessDatabase() throws Exception {
    allowGlobalCapabilities(REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE);
    try {
        deny(Permission.READ, REGISTERED_USERS, "refs/heads/master");
        allow(Permission.READ, REGISTERED_USERS, "refs/heads/branch");
        String changeId = c1.change().getKey().get();
        setApiUser(admin);
        gApi.changes().id(changeId).edit().create();
        setApiUser(user);
        assertUploadPackRefs(// refs/heads/master is not.
        r1 + "1", r1 + "meta", r2 + "1", r2 + "meta", r3 + "1", r3 + "meta", r4 + "1", r4 + "meta", "refs/heads/branch", "refs/tags/branch-tag", // See comment in subsetOfBranchesVisibleNotIncludingHead.
        "refs/tags/master-tag", // All edits are visible due to accessDatabase capability.
        "refs/users/00/1000000/edit-" + c1.getId() + "/1");
    } finally {
        removeGlobalCapabilities(REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE);
    }
}
#method_after
@Test
public void uploadPackSubsetOfRefsVisibleWithAccessDatabase() throws Exception {
    allowGlobalCapabilities(REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE);
    try {
        deny("refs/heads/master", Permission.READ, REGISTERED_USERS);
        allow("refs/heads/branch", Permission.READ, REGISTERED_USERS);
        String changeId = c1.change().getKey().get();
        setApiUser(admin);
        gApi.changes().id(changeId).edit().create();
        setApiUser(user);
        assertUploadPackRefs(// refs/heads/master is not.
        r1 + "1", r1 + "meta", r2 + "1", r2 + "meta", r3 + "1", r3 + "meta", r4 + "1", r4 + "meta", "refs/heads/branch", "refs/tags/branch-tag", // See comment in subsetOfBranchesVisibleNotIncludingHead.
        "refs/tags/master-tag", // All edits are visible due to accessDatabase capability.
        "refs/users/00/1000000/edit-" + c1.getId() + "/1");
    } finally {
        removeGlobalCapabilities(REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE);
    }
}
#end_block

#method_before
@Test
public void uploadPackNoSearchingChangeCacheImpl() throws Exception {
    allow(Permission.READ, REGISTERED_USERS, "refs/heads/*");
    setApiUser(user);
    try (Repository repo = repoManager.openRepository(project)) {
        assertRefs(repo, new VisibleRefFilter(tagCache, notesFactory, null, repo, projectControl(), db, true), // Can't use stored values from the index so DB must be enabled.
        false, "HEAD", r1 + "1", r1 + "meta", r2 + "1", r2 + "meta", r3 + "1", r3 + "meta", r4 + "1", r4 + "meta", "refs/heads/branch", "refs/heads/master", "refs/tags/branch-tag", "refs/tags/master-tag");
    }
}
#method_after
@Test
public void uploadPackNoSearchingChangeCacheImpl() throws Exception {
    allow("refs/heads/*", Permission.READ, REGISTERED_USERS);
    setApiUser(user);
    try (Repository repo = repoManager.openRepository(project)) {
        assertRefs(repo, refFilterFactory.create(projectCache.get(project), repo), // Can't use stored values from the index so DB must be enabled.
        false, "HEAD", r1 + "1", r1 + "meta", r2 + "1", r2 + "meta", r3 + "1", r3 + "meta", r4 + "1", r4 + "meta", "refs/heads/branch", "refs/heads/master", "refs/tags/branch-tag", "refs/tags/master-tag");
    }
}
#end_block

#method_before
@Test
public void uploadPackSequencesWithAccessDatabase() throws Exception {
    assume().that(notesMigration.readChangeSequence()).isTrue();
    try (Repository repo = repoManager.openRepository(allProjects)) {
        setApiUser(user);
        assertRefs(repo, newFilter(db, repo, allProjects), true);
        allowGlobalCapabilities(REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE);
        try {
            setApiUser(user);
            assertRefs(repo, newFilter(db, repo, allProjects), true, "refs/sequences/changes");
        } finally {
            removeGlobalCapabilities(REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE);
        }
    }
}
#method_after
@Test
public void uploadPackSequencesWithAccessDatabase() throws Exception {
    assume().that(notesMigration.readChangeSequence()).isTrue();
    try (Repository repo = repoManager.openRepository(allProjects)) {
        setApiUser(user);
        assertRefs(repo, newFilter(repo, allProjects), true);
        allowGlobalCapabilities(REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE);
        try {
            setApiUser(user);
            assertRefs(repo, newFilter(repo, allProjects), true, "refs/sequences/changes");
        } finally {
            removeGlobalCapabilities(REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE);
        }
    }
}
#end_block

#method_before
@Test
public void receivePackRespectsVisibilityOfOpenChanges() throws Exception {
    allow(Permission.READ, REGISTERED_USERS, "refs/heads/master");
    deny(Permission.READ, REGISTERED_USERS, "refs/heads/branch");
    setApiUser(user);
    assertThat(getReceivePackRefs().additionalHaves()).containsExactly(obj(c3, 1));
}
#method_after
@Test
public void receivePackRespectsVisibilityOfOpenChanges() throws Exception {
    allow("refs/heads/master", Permission.READ, REGISTERED_USERS);
    deny("refs/heads/branch", Permission.READ, REGISTERED_USERS);
    setApiUser(user);
    assertThat(getReceivePackRefs().additionalHaves()).containsExactly(obj(c3, 1));
}
#end_block

#method_before
private void assertUploadPackRefs(String... expectedWithMeta) throws Exception {
    try (Repository repo = repoManager.openRepository(project)) {
        assertRefs(repo, new VisibleRefFilter(tagCache, notesFactory, changeCache, repo, projectControl(), new DisabledReviewDb(), true), true, expectedWithMeta);
    }
}
#method_after
private void assertUploadPackRefs(String... expectedWithMeta) throws Exception {
    try (Repository repo = repoManager.openRepository(project)) {
        assertRefs(repo, refFilterFactory.create(projectCache.get(project), repo), true, expectedWithMeta);
    }
}
#end_block

#method_before
private void assertRefs(Repository repo, VisibleRefFilter filter, boolean disableDb, String... expectedWithMeta) throws Exception {
    List<String> expected = new ArrayList<>(expectedWithMeta.length);
    for (String r : expectedWithMeta) {
        if (notesMigration.writeChanges() || !r.endsWith(RefNames.META_SUFFIX)) {
            expected.add(r);
        }
    }
    AcceptanceTestRequestScope.Context ctx = null;
    if (disableDb) {
        ctx = disableDb();
    }
    try {
        Map<String, Ref> all = repo.getAllRefs();
        assertThat(filter.filter(all, false).keySet()).containsExactlyElementsIn(expected);
    } finally {
        if (disableDb) {
            enableDb(ctx);
        }
    }
}
#method_after
private void assertRefs(Repository repo, VisibleRefFilter filter, boolean disableDb, String... expectedWithMeta) throws Exception {
    List<String> expected = new ArrayList<>(expectedWithMeta.length);
    for (String r : expectedWithMeta) {
        if (notesMigration.commitChangeWrites() || !r.endsWith(RefNames.META_SUFFIX)) {
            expected.add(r);
        }
    }
    AcceptanceTestRequestScope.Context ctx = null;
    if (disableDb) {
        ctx = disableDb();
    }
    try {
        Map<String, Ref> all = repo.getAllRefs();
        assertThat(filter.filter(all, false).keySet()).containsExactlyElementsIn(expected);
    } finally {
        if (disableDb) {
            enableDb(ctx);
        }
    }
}
#end_block

#method_before
private VisibleRefFilter newFilter(ReviewDb db, Repository repo, Project.NameKey project) throws Exception {
    return new VisibleRefFilter(tagCache, notesFactory, null, repo, projectControlFactory.controlFor(project, userProvider.get()), db, true);
}
#method_after
private VisibleRefFilter newFilter(Repository repo, Project.NameKey project) {
    return refFilterFactory.create(projectCache.get(project), repo);
}
#end_block

#method_before
@Test
public void revert() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo revertChange = gApi.changes().id(r.getChangeId()).revert().get();
    // expected messages on source change:
    // 1. Uploaded patch set 1.
    // 2. Patch Set 1: Code-Review+2
    // 3. Change has been successfully merged by Administrator
    // 4. Patch Set 1: Reverted
    List<ChangeMessageInfo> sourceMessages = new ArrayList<>(gApi.changes().id(r.getChangeId()).get().messages);
    assertThat(sourceMessages).hasSize(4);
    String expectedMessage = String.format("Created a revert of this change as %s", revertChange.changeId);
    assertThat(sourceMessages.get(3).message).isEqualTo(expectedMessage);
    assertThat(revertChange.messages).hasSize(1);
    assertThat(revertChange.messages.iterator().next().message).isEqualTo("Uploaded patch set 1.");
}
#method_after
@Test
public void revert() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo revertChange = gApi.changes().id(r.getChangeId()).revert().get();
    // expected messages on source change:
    // 1. Uploaded patch set 1.
    // 2. Patch Set 1: Code-Review+2
    // 3. Change has been successfully merged by Administrator
    // 4. Patch Set 1: Reverted
    List<ChangeMessageInfo> sourceMessages = new ArrayList<>(gApi.changes().id(r.getChangeId()).get().messages);
    assertThat(sourceMessages).hasSize(4);
    String expectedMessage = String.format("Created a revert of this change as %s", revertChange.changeId);
    assertThat(sourceMessages.get(3).message).isEqualTo(expectedMessage);
    assertThat(revertChange.messages).hasSize(1);
    assertThat(revertChange.messages.iterator().next().message).isEqualTo("Uploaded patch set 1.");
    assertThat(revertChange.revertOf).isEqualTo(gApi.changes().id(r.getChangeId()).get()._number);
}
#end_block

#method_before
@Test
@TestProjectInput(cloneAs = "user")
public void deleteNewChangeAsNormalUser() throws Exception {
    PushOneCommit.Result changeResult = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    String changeId = changeResult.getChangeId();
    Change.Id id = changeResult.getChange().getId();
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage(String.format("Deleting change %s is not permitted", id));
    gApi.changes().id(changeId).delete();
}
#method_after
@Test
@TestProjectInput(cloneAs = "user")
public void deleteNewChangeAsNormalUser() throws Exception {
    PushOneCommit.Result changeResult = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    String changeId = changeResult.getChangeId();
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("delete not permitted");
    gApi.changes().id(changeId).delete();
}
#end_block

#method_before
@Test
@TestProjectInput(cloneAs = "user")
public void deleteAbandonedChangeAsNormalUser() throws Exception {
    PushOneCommit.Result changeResult = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    String changeId = changeResult.getChangeId();
    Change.Id id = changeResult.getChange().getId();
    setApiUser(user);
    gApi.changes().id(changeId).abandon();
    exception.expect(AuthException.class);
    exception.expectMessage(String.format("Deleting change %s is not permitted", id));
    gApi.changes().id(changeId).delete();
}
#method_after
@Test
@TestProjectInput(cloneAs = "user")
public void deleteAbandonedChangeAsNormalUser() throws Exception {
    PushOneCommit.Result changeResult = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    String changeId = changeResult.getChangeId();
    setApiUser(user);
    gApi.changes().id(changeId).abandon();
    exception.expect(AuthException.class);
    exception.expectMessage("delete not permitted");
    gApi.changes().id(changeId).delete();
}
#end_block

#method_before
@Test
public void deleteMergedChange() throws Exception {
    PushOneCommit.Result changeResult = createChange();
    String changeId = changeResult.getChangeId();
    Change.Id id = changeResult.getChange().getId();
    merge(changeResult);
    exception.expect(MethodNotAllowedException.class);
    exception.expectMessage(String.format("Deleting merged change %s is not allowed", id));
    gApi.changes().id(changeId).delete();
}
#method_after
@Test
public void deleteMergedChange() throws Exception {
    PushOneCommit.Result changeResult = createChange();
    String changeId = changeResult.getChangeId();
    merge(changeResult);
    exception.expect(MethodNotAllowedException.class);
    exception.expectMessage("delete not permitted");
    gApi.changes().id(changeId).delete();
}
#end_block

#method_before
@Test
public void pushCommitOfOtherUser() throws Exception {
    // admin pushes commit of user
    PushOneCommit push = pushFactory.create(db, user.getIdent(), testRepo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.owner._accountId).isEqualTo(admin.id.get());
    CommitInfo commit = change.revisions.get(change.currentRevision).commit;
    assertThat(commit.author.email).isEqualTo(user.email);
    assertThat(commit.committer.email).isEqualTo(user.email);
    // check that the author/committer was added as reviewer
    Collection<AccountInfo> reviewers = change.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    assertThat(change.reviewers.get(CC)).isNull();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains(admin.fullName + " has uploaded this change for review");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailFrom(m, admin.email);
}
#method_after
@Test
public void pushCommitOfOtherUser() throws Exception {
    // admin pushes commit of user
    PushOneCommit push = pushFactory.create(db, user.getIdent(), testRepo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.owner._accountId).isEqualTo(admin.id.get());
    CommitInfo commit = change.revisions.get(change.currentRevision).commit;
    assertThat(commit.author.email).isEqualTo(user.email);
    assertThat(commit.committer.email).isEqualTo(user.email);
    // check that the author/committer was added as reviewer
    Collection<AccountInfo> reviewers = change.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    assertThat(change.reviewers.get(CC)).isNull();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains(admin.fullName + " has uploaded this change for review");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailReplyTo(m, admin.email);
}
#end_block

#method_before
@Test
public void pushCommitOfOtherUserThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // admin pushes commit of user
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, user.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.owner._accountId).isEqualTo(admin.id.get());
    CommitInfo commit = change.revisions.get(change.currentRevision).commit;
    assertThat(commit.author.email).isEqualTo(user.email);
    assertThat(commit.committer.email).isEqualTo(user.email);
    // check the user cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // check that the author/committer was NOT added as reviewer (he can't see
    // the change)
    assertThat(change.reviewers.get(REVIEWER)).isNull();
    assertThat(change.reviewers.get(CC)).isNull();
    assertThat(sender.getMessages()).isEmpty();
}
#method_after
@Test
public void pushCommitOfOtherUserThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // admin pushes commit of user
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, user.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.owner._accountId).isEqualTo(admin.id.get());
    CommitInfo commit = change.revisions.get(change.currentRevision).commit;
    assertThat(commit.author.email).isEqualTo(user.email);
    assertThat(commit.committer.email).isEqualTo(user.email);
    // check the user cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // check that the author/committer was NOT added as reviewer (he can't see
    // the change)
    assertThat(change.reviewers.get(REVIEWER)).isNull();
    assertThat(change.reviewers.get(CC)).isNull();
    assertThat(sender.getMessages()).isEmpty();
}
#end_block

#method_before
@Test
public void pushCommitWithFooterOfOtherUser() throws Exception {
    // admin pushes commit that references 'user' in a footer
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT + "\n\n" + FooterConstants.REVIEWED_BY.getName() + ": " + user.getIdent().toExternalString(), PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check that 'user' was added as reviewer
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    Collection<AccountInfo> reviewers = change.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    assertThat(change.reviewers.get(CC)).isNull();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailFrom(m, admin.email);
}
#method_after
@Test
public void pushCommitWithFooterOfOtherUser() throws Exception {
    // admin pushes commit that references 'user' in a footer
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT + "\n\n" + FooterConstants.REVIEWED_BY.getName() + ": " + user.getIdent().toExternalString(), PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check that 'user' was added as reviewer
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    Collection<AccountInfo> reviewers = change.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    assertThat(change.reviewers.get(CC)).isNull();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailReplyTo(m, admin.email);
}
#end_block

#method_before
@Test
public void pushCommitWithFooterOfOtherUserThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // admin pushes commit that references 'user' in a footer
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo, PushOneCommit.SUBJECT + "\n\n" + FooterConstants.REVIEWED_BY.getName() + ": " + user.getIdent().toExternalString(), PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check that 'user' cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // check that 'user' was NOT added as cc ('user' can't see the change)
    setApiUser(admin);
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.reviewers.get(REVIEWER)).isNull();
    assertThat(change.reviewers.get(CC)).isNull();
    assertThat(sender.getMessages()).isEmpty();
}
#method_after
@Test
public void pushCommitWithFooterOfOtherUserThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // admin pushes commit that references 'user' in a footer
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo, PushOneCommit.SUBJECT + "\n\n" + FooterConstants.REVIEWED_BY.getName() + ": " + user.getIdent().toExternalString(), PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check that 'user' cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // check that 'user' was NOT added as cc ('user' can't see the change)
    setApiUser(admin);
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.reviewers.get(REVIEWER)).isNull();
    assertThat(change.reviewers.get(CC)).isNull();
    assertThat(sender.getMessages()).isEmpty();
}
#end_block

#method_before
@Test
public void addReviewerThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // create change
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check the user cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // try to add user as reviewer
    setApiUser(admin);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    exception.expect(UnprocessableEntityException.class);
    exception.expectMessage("Change not visible to " + user.email);
    gApi.changes().id(result.getChangeId()).addReviewer(in);
}
#method_after
@Test
public void addReviewerThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // create change
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check the user cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // try to add user as reviewer
    setApiUser(admin);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    AddReviewerResult r = gApi.changes().id(result.getChangeId()).addReviewer(in);
    assertThat(r.input).isEqualTo(user.email);
    assertThat(r.error).contains("does not have permission to see this change");
    assertThat(r.reviewers).isNull();
}
#end_block

#method_before
@Test
public void addReviewerThatIsInactive() throws Exception {
    PushOneCommit.Result r = createChange();
    String username = name("new-user");
    gApi.accounts().create(username).setActive(false);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = username;
    exception.expect(UnprocessableEntityException.class);
    exception.expectMessage("Account of " + username + " is inactive.");
    gApi.changes().id(r.getChangeId()).addReviewer(in);
}
#method_after
@Test
public void addReviewerThatIsInactive() throws Exception {
    PushOneCommit.Result result = createChange();
    String username = name("new-user");
    gApi.accounts().create(username).setActive(false);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = username;
    AddReviewerResult r = gApi.changes().id(result.getChangeId()).addReviewer(in);
    assertThat(r.input).isEqualTo(username);
    assertThat(r.error).contains("identifies an inactive account");
    assertThat(r.reviewers).isNull();
}
#end_block

#method_before
@Test
public void addReviewer() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailFrom(m, admin.email);
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = c.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
}
#method_after
@Test
public void addReviewer() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailReplyTo(m, admin.email);
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = c.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
    // Change status of reviewer and ensure ETag is updated.
    oldETag = rsrc.getETag();
    gApi.accounts().id(user.id.get()).setStatus("new status");
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
}
#end_block

#method_before
@Test
public void addReviewerWithNoteDbWhenDummyApprovalInReviewDbExists() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    assume().that(notesMigration.changePrimaryStorage()).isEqualTo(PrimaryStorage.REVIEW_DB);
    PushOneCommit.Result r = createChange();
    // insert dummy approval in ReviewDb
    PatchSetApproval psa = new PatchSetApproval(new PatchSetApproval.Key(r.getPatchSetId(), user.id, new LabelId("Code-Review")), (short) 0, TimeUtil.nowTs());
    db.patchSetApprovals().insert(Collections.singleton(psa));
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
}
#method_after
@Test
public void addReviewerWithNoteDbWhenDummyApprovalInReviewDbExists() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    assume().that(notesMigration.changePrimaryStorage()).isEqualTo(PrimaryStorage.REVIEW_DB);
    PushOneCommit.Result r = createChange();
    // insert dummy approval in ReviewDb
    PatchSetApproval psa = new PatchSetApproval(new PatchSetApproval.Key(r.getPatchSetId(), user.id, new LabelId("Code-Review")), (short) 0, TimeUtil.nowTs());
    db.patchSetApprovals().insert(Collections.singleton(psa));
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
}
#end_block

#method_before
@Test
public void removeReviewerNotPermitted() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    gApi.changes().id(changeId).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("delete reviewer not permitted");
    gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).remove();
}
#method_after
@Test
public void removeReviewerNotPermitted() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    gApi.changes().id(changeId).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("remove reviewer not permitted");
    gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).remove();
}
#end_block

#method_before
@Test
public void deleteVote() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote("Code-Review");
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message msg = messages.get(0);
    assertThat(msg.rcpt()).containsExactly(user.emailAddress);
    assertThat(msg.body()).contains(admin.fullName + " has removed a vote on this change.\n");
    assertThat(msg.body()).contains("Removed Code-Review+1 by " + user.fullName + " <" + user.email + ">" + "\n");
    Map<String, Short> m = gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).votes();
    // Dummy 0 approval on the change to block vote copying to this patch set.
    assertThat(m).containsExactly("Code-Review", Short.valueOf((short) 0));
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    ChangeMessageInfo message = Iterables.getLast(c.messages);
    assertThat(message.author._accountId).isEqualTo(admin.getId().get());
    assertThat(message.message).isEqualTo("Removed Code-Review+1 by User <user@example.com>\n");
    assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
}
#method_after
@Test
public void deleteVote() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote("Code-Review");
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message msg = messages.get(0);
    assertThat(msg.rcpt()).containsExactly(user.emailAddress);
    assertThat(msg.body()).contains(admin.fullName + " has removed a vote on this change.\n");
    assertThat(msg.body()).contains("Removed Code-Review+1 by " + user.fullName + " <" + user.email + ">\n");
    Map<String, Short> m = gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).votes();
    // Dummy 0 approval on the change to block vote copying to this patch set.
    assertThat(m).containsExactly("Code-Review", Short.valueOf((short) 0));
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    ChangeMessageInfo message = Iterables.getLast(c.messages);
    assertThat(message.author._accountId).isEqualTo(admin.getId().get());
    assertThat(message.message).isEqualTo("Removed Code-Review+1 by User <user@example.com>\n");
    assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
}
#end_block

#method_before
@Test
public void deleteVoteNotifyAccount() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    DeleteVoteInput in = new DeleteVoteInput();
    in.label = "Code-Review";
    in.notify = NotifyHandling.NONE;
    // notify unrelated account as TO
    TestAccount user2 = accounts.user2();
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.TO, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyTo(user2);
    // notify unrelated account as CC
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.CC, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyCc(user2);
    // notify unrelated account as BCC
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.BCC, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyBcc(user2);
}
#method_after
@Test
public void deleteVoteNotifyAccount() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    DeleteVoteInput in = new DeleteVoteInput();
    in.label = "Code-Review";
    in.notify = NotifyHandling.NONE;
    // notify unrelated account as TO
    TestAccount user2 = accountCreator.user2();
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.TO, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyTo(user2);
    // notify unrelated account as CC
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.CC, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyCc(user2);
    // notify unrelated account as BCC
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.BCC, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyBcc(user2);
}
#end_block

#method_before
@Test
public void queryChangesOptions() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeInfo result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).get());
    assertThat(result.labels).isNull();
    assertThat(result.messages).isNull();
    assertThat(result.actions).isNull();
    assertThat(result.revisions).isNull();
    EnumSet<ListChangesOption> options = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CHANGE_ACTIONS, ListChangesOption.CURRENT_ACTIONS, ListChangesOption.DETAILED_LABELS, ListChangesOption.MESSAGES);
    result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).withOptions(options).get());
    assertThat(Iterables.getOnlyElement(result.labels.keySet())).isEqualTo("Code-Review");
    assertThat(result.messages).hasSize(1);
    assertThat(result.actions).isNotEmpty();
    RevisionInfo rev = Iterables.getOnlyElement(result.revisions.values());
    assertThat(rev._number).isEqualTo(r.getPatchSetId().get());
    assertThat(rev.created).isNotNull();
    assertThat(rev.uploader._accountId).isEqualTo(admin.getId().get());
    assertThat(rev.ref).isEqualTo(r.getPatchSetId().toRefName());
    assertThat(rev.actions).isNotEmpty();
}
#method_after
@Test
public void queryChangesOptions() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeInfo result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).get());
    assertThat(result.labels).isNull();
    assertThat(result.messages).isNull();
    assertThat(result.actions).isNull();
    assertThat(result.revisions).isNull();
    result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).withOptions(ALL_REVISIONS, CHANGE_ACTIONS, CURRENT_ACTIONS, DETAILED_LABELS, MESSAGES).get());
    assertThat(Iterables.getOnlyElement(result.labels.keySet())).isEqualTo("Code-Review");
    assertThat(result.messages).hasSize(1);
    assertThat(result.actions).isNotEmpty();
    RevisionInfo rev = Iterables.getOnlyElement(result.revisions.values());
    assertThat(rev._number).isEqualTo(r.getPatchSetId().get());
    assertThat(rev.created).isNotNull();
    assertThat(rev.uploader._accountId).isEqualTo(admin.getId().get());
    assertThat(rev.ref).isEqualTo(r.getPatchSetId().toRefName());
    assertThat(rev.actions).isNotEmpty();
}
#end_block

#method_before
@Test
public void queryChangesOwnerWithDifferentUsers() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(Iterables.getOnlyElement(query("project:{" + project.get() + "} owner:self")).changeId).isEqualTo(r.getChangeId());
    setApiUser(user);
    assertThat(query("owner:self")).isEmpty();
}
#method_after
@Test
public void queryChangesOwnerWithDifferentUsers() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(Iterables.getOnlyElement(query("project:{" + project.get() + "} owner:self")).changeId).isEqualTo(r.getChangeId());
    setApiUser(user);
    assertThat(query("owner:self project:{" + project.get() + "}")).isEmpty();
}
#end_block

#method_before
@Test
public void submitted() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    assertThat(gApi.changes().id(r.getChangeId()).info().submitted).isNull();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    assertThat(gApi.changes().id(r.getChangeId()).info().submitted).isNotNull();
}
#method_after
@Test
public void submitted() throws Exception {
    PushOneCommit.Result r = createChange();
    String id = r.getChangeId();
    ChangeInfo c = gApi.changes().id(r.getChangeId()).info();
    assertThat(c.submitted).isNull();
    assertThat(c.submitter).isNull();
    gApi.changes().id(id).current().review(ReviewInput.approve());
    gApi.changes().id(id).current().submit();
    c = gApi.changes().id(r.getChangeId()).info();
    assertThat(c.submitted).isNotNull();
    assertThat(c.submitter).isNotNull();
    assertThat(c.submitter._accountId).isEqualTo(atrScope.get().getUser().getAccountId().get());
}
#end_block

#method_before
@Test
public void check() throws Exception {
    // TODO(dborowitz): Re-enable when ConsistencyChecker supports NoteDb.
    assume().that(notesMigration.enabled()).isFalse();
    PushOneCommit.Result r = createChange();
    assertThat(gApi.changes().id(r.getChangeId()).get().problems).isNull();
    assertThat(gApi.changes().id(r.getChangeId()).get(EnumSet.of(ListChangesOption.CHECK)).problems).isEmpty();
}
#method_after
@Test
public void check() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(gApi.changes().id(r.getChangeId()).get().problems).isNull();
    assertThat(gApi.changes().id(r.getChangeId()).get(CHECK).problems).isEmpty();
}
#end_block

#method_before
@Test
public void commitFooters() throws Exception {
    LabelType verified = category("Verified", value(1, "Passes"), value(0, "No score"), value(-1, "Failed"));
    LabelType custom1 = category("Custom1", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    LabelType custom2 = category("Custom2", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().put(verified.getName(), verified);
    cfg.getLabelSections().put(custom1.getName(), custom1);
    cfg.getLabelSections().put(custom2.getName(), custom2);
    String heads = "refs/heads/*";
    AccountGroup.UUID anon = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel("Verified"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom1"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom2"), -1, 1, anon, heads);
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r1 = createChange();
    r1.assertOkStatus();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "new content", r1.getChangeId()).to("refs/for/master");
    r2.assertOkStatus();
    ReviewInput in = new ReviewInput();
    in.label("Code-Review", 1);
    in.label("Verified", 1);
    in.label("Custom1", -1);
    in.label("Custom2", 1);
    gApi.changes().id(r2.getChangeId()).current().review(in);
    EnumSet<ListChangesOption> options = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.COMMIT_FOOTERS);
    ChangeInfo actual = gApi.changes().id(r2.getChangeId()).get(options);
    assertThat(actual.revisions).hasSize(2);
    // No footers except on latest patch set.
    assertThat(actual.revisions.get(r1.getCommit().getName()).commitWithFooters).isNull();
    List<String> footers = new ArrayList<>(Arrays.asList(actual.revisions.get(r2.getCommit().getName()).commitWithFooters.split("\\n")));
    // remove subject + blank line
    footers.remove(0);
    footers.remove(0);
    List<String> expectedFooters = Arrays.asList("Change-Id: " + r2.getChangeId(), "Reviewed-on: " + canonicalWebUrl.get() + r2.getChange().getId(), "Reviewed-by: Administrator <admin@example.com>", "Custom2: Administrator <admin@example.com>", "Tested-by: Administrator <admin@example.com>");
    assertThat(footers).containsExactlyElementsIn(expectedFooters);
}
#method_after
@Test
public void commitFooters() throws Exception {
    LabelType verified = category("Verified", value(1, "Passes"), value(0, "No score"), value(-1, "Failed"));
    LabelType custom1 = category("Custom1", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    LabelType custom2 = category("Custom2", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().put(verified.getName(), verified);
    cfg.getLabelSections().put(custom1.getName(), custom1);
    cfg.getLabelSections().put(custom2.getName(), custom2);
    String heads = "refs/heads/*";
    AccountGroup.UUID anon = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel("Verified"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom1"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom2"), -1, 1, anon, heads);
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r1 = createChange();
    r1.assertOkStatus();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "new content", r1.getChangeId()).to("refs/for/master");
    r2.assertOkStatus();
    ReviewInput in = new ReviewInput();
    in.label("Code-Review", 1);
    in.label("Verified", 1);
    in.label("Custom1", -1);
    in.label("Custom2", 1);
    gApi.changes().id(r2.getChangeId()).current().review(in);
    ChangeInfo actual = gApi.changes().id(r2.getChangeId()).get(ALL_REVISIONS, COMMIT_FOOTERS);
    assertThat(actual.revisions).hasSize(2);
    // No footers except on latest patch set.
    assertThat(actual.revisions.get(r1.getCommit().getName()).commitWithFooters).isNull();
    List<String> footers = new ArrayList<>(Arrays.asList(actual.revisions.get(r2.getCommit().getName()).commitWithFooters.split("\\n")));
    // remove subject + blank line
    footers.remove(0);
    footers.remove(0);
    List<String> expectedFooters = Arrays.asList("Change-Id: " + r2.getChangeId(), "Reviewed-on: " + canonicalWebUrl.get() + r2.getChange().getId(), "Reviewed-by: Administrator <admin@example.com>", "Custom2: Administrator <admin@example.com>", "Tested-by: Administrator <admin@example.com>");
    assertThat(footers).containsExactlyElementsIn(expectedFooters);
}
#end_block

#method_before
@Test
public void customCommitFooters() throws Exception {
    PushOneCommit.Result change = createChange();
    RegistrationHandle handle = changeMessageModifiers.add(new ChangeMessageModifier() {

        @Override
        public String onSubmit(String newCommitMessage, RevCommit original, RevCommit mergeTip, Branch.NameKey destination) {
            assertThat(original.getName()).isNotEqualTo(mergeTip.getName());
            return newCommitMessage + "Custom: " + destination.get();
        }
    });
    ChangeInfo actual;
    try {
        EnumSet<ListChangesOption> options = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.COMMIT_FOOTERS);
        actual = gApi.changes().id(change.getChangeId()).get(options);
    } finally {
        handle.remove();
    }
    List<String> footers = new ArrayList<>(Arrays.asList(actual.revisions.get(change.getCommit().getName()).commitWithFooters.split("\\n")));
    // remove subject + blank line
    footers.remove(0);
    footers.remove(0);
    List<String> expectedFooters = Arrays.asList("Change-Id: " + change.getChangeId(), "Reviewed-on: " + canonicalWebUrl.get() + change.getChange().getId(), "Custom: refs/heads/master");
    assertThat(footers).containsExactlyElementsIn(expectedFooters);
}
#method_after
@Test
public void customCommitFooters() throws Exception {
    PushOneCommit.Result change = createChange();
    RegistrationHandle handle = changeMessageModifiers.add(new ChangeMessageModifier() {

        @Override
        public String onSubmit(String newCommitMessage, RevCommit original, RevCommit mergeTip, Branch.NameKey destination) {
            assertThat(original.getName()).isNotEqualTo(mergeTip.getName());
            return newCommitMessage + "Custom: " + destination.get();
        }
    });
    ChangeInfo actual;
    try {
        actual = gApi.changes().id(change.getChangeId()).get(ALL_REVISIONS, COMMIT_FOOTERS);
    } finally {
        handle.remove();
    }
    List<String> footers = new ArrayList<>(Arrays.asList(actual.revisions.get(change.getCommit().getName()).commitWithFooters.split("\\n")));
    // remove subject + blank line
    footers.remove(0);
    footers.remove(0);
    List<String> expectedFooters = Arrays.asList("Change-Id: " + change.getChangeId(), "Reviewed-on: " + canonicalWebUrl.get() + change.getChange().getId(), "Custom: refs/heads/master");
    assertThat(footers).containsExactlyElementsIn(expectedFooters);
}
#end_block

#method_before
@Test
public void defaultSearchDoesNotTouchDatabase() throws Exception {
    setApiUser(admin);
    PushOneCommit.Result r1 = createChange();
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).submit();
    createChange();
    setApiUser(user);
    AcceptanceTestRequestScope.Context ctx = disableDb();
    try {
        assertThat(gApi.changes().query().withQuery("project:{" + project.get() + "} (status:open OR status:closed)").withOption(ListChangesOption.LABELS).withOption(ListChangesOption.DETAILED_ACCOUNTS).withOption(ListChangesOption.REVIEWED).get()).hasSize(2);
    } finally {
        enableDb(ctx);
    }
}
#method_after
@Test
public void defaultSearchDoesNotTouchDatabase() throws Exception {
    setApiUser(admin);
    PushOneCommit.Result r1 = createChange();
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).submit();
    createChange();
    setApiUser(user);
    AcceptanceTestRequestScope.Context ctx = disableDb();
    try {
        assertThat(gApi.changes().query().withQuery("project:{" + project.get() + "} (status:open OR status:closed)").withOption(LABELS).withOption(DETAILED_ACCOUNTS).withOption(REVIEWED).get()).hasSize(2);
    } finally {
        enableDb(ctx);
    }
}
#end_block

#method_before
@Test
public void votable() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(triplet).addReviewer(user.username);
    ChangeInfo c = gApi.changes().id(triplet).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
    LabelInfo codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    ApprovalInfo approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.value).isEqualTo(0);
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    blockLabel(cfg, "Code-Review", REGISTERED_USERS, "refs/heads/*");
    saveProjectConfig(project, cfg);
    c = gApi.changes().id(triplet).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
    codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.value).isNull();
}
#method_after
@Test
public void votable() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(triplet).addReviewer(user.username);
    ChangeInfo c = gApi.changes().id(triplet).get(DETAILED_LABELS);
    LabelInfo codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    ApprovalInfo approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.value).isEqualTo(0);
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.blockLabel(cfg, "Code-Review", REGISTERED_USERS, "refs/heads/*");
    saveProjectConfig(project, cfg);
    c = gApi.changes().id(triplet).get(DETAILED_LABELS);
    codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.value).isNull();
}
#end_block

#method_before
@Test
@GerritConfig(name = "gerrit.editGpgKeys", value = "true")
@GerritConfig(name = "receive.enableSignedPush", value = "true")
public void pushCertificates() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = amendChange(r1.getChangeId());
    ChangeInfo info = gApi.changes().id(r1.getChangeId()).get(EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.PUSH_CERTIFICATES));
    RevisionInfo rev1 = info.revisions.get(r1.getCommit().name());
    assertThat(rev1).isNotNull();
    assertThat(rev1.pushCertificate).isNotNull();
    assertThat(rev1.pushCertificate.certificate).isNull();
    assertThat(rev1.pushCertificate.key).isNull();
    RevisionInfo rev2 = info.revisions.get(r2.getCommit().name());
    assertThat(rev2).isNotNull();
    assertThat(rev2.pushCertificate).isNotNull();
    assertThat(rev2.pushCertificate.certificate).isNull();
    assertThat(rev2.pushCertificate.key).isNull();
}
#method_after
@Test
@GerritConfig(name = "gerrit.editGpgKeys", value = "true")
@GerritConfig(name = "receive.enableSignedPush", value = "true")
public void pushCertificates() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = amendChange(r1.getChangeId());
    ChangeInfo info = gApi.changes().id(r1.getChangeId()).get(ALL_REVISIONS, PUSH_CERTIFICATES);
    RevisionInfo rev1 = info.revisions.get(r1.getCommit().name());
    assertThat(rev1).isNotNull();
    assertThat(rev1.pushCertificate).isNotNull();
    assertThat(rev1.pushCertificate.certificate).isNull();
    assertThat(rev1.pushCertificate.key).isNull();
    RevisionInfo rev2 = info.revisions.get(r2.getCommit().name());
    assertThat(rev2).isNotNull();
    assertThat(rev2.pushCertificate).isNotNull();
    assertThat(rev2.pushCertificate.certificate).isNull();
    assertThat(rev2.pushCertificate.key).isNull();
}
#end_block

#method_before
@Test
public void createNewPatchSetWithoutPermission() throws Exception {
    // Create new project with clean permissions
    Project.NameKey p = createProject("addPatchSet1");
    // Clone separate repositories of the same project as admin and as user
    TestRepository<InMemoryRepository> adminTestRepo = cloneProject(p, admin);
    TestRepository<InMemoryRepository> userTestRepo = cloneProject(p, user);
    // Block default permission
    block(Permission.ADD_PATCH_SET, REGISTERED_USERS, "refs/for/*", p);
    // Create change as admin
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), adminTestRepo);
    PushOneCommit.Result r1 = push.to("refs/for/master");
    r1.assertOkStatus();
    // Fetch change
    GitUtil.fetch(userTestRepo, r1.getPatchSet().getRefName() + ":ps");
    userTestRepo.reset("ps");
    // Amend change as user
    PushOneCommit.Result r2 = amendChange(r1.getChangeId(), "refs/for/master", user, userTestRepo);
    r2.assertErrorStatus("cannot add patch set to " + r1.getChange().getId().id + ".");
}
#method_after
@Test
public void createNewPatchSetWithoutPermission() throws Exception {
    // Create new project with clean permissions
    Project.NameKey p = createProject("addPatchSet1");
    // Clone separate repositories of the same project as admin and as user
    TestRepository<InMemoryRepository> adminTestRepo = cloneProject(p, admin);
    TestRepository<InMemoryRepository> userTestRepo = cloneProject(p, user);
    // Block default permission
    block(p, "refs/for/*", Permission.ADD_PATCH_SET, REGISTERED_USERS);
    // Create change as admin
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), adminTestRepo);
    PushOneCommit.Result r1 = push.to("refs/for/master");
    r1.assertOkStatus();
    // Fetch change
    GitUtil.fetch(userTestRepo, r1.getPatchSet().getRefName() + ":ps");
    userTestRepo.reset("ps");
    // Amend change as user
    PushOneCommit.Result r2 = amendChange(r1.getChangeId(), "refs/for/master", user, userTestRepo);
    r2.assertErrorStatus("cannot add patch set to " + r1.getChange().getId().id + ".");
}
#end_block

#method_before
@Test
public void createNewPatchSetAsOwnerWithoutPermission() throws Exception {
    // Create new project with clean permissions
    Project.NameKey p = createProject("addPatchSet2");
    // Clone separate repositories of the same project as admin and as user
    TestRepository<?> adminTestRepo = cloneProject(project, admin);
    // Block default permission
    block(Permission.ADD_PATCH_SET, REGISTERED_USERS, "refs/for/*", p);
    // Create change as admin
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), adminTestRepo);
    PushOneCommit.Result r1 = push.to("refs/for/master");
    r1.assertOkStatus();
    // Fetch change
    GitUtil.fetch(adminTestRepo, r1.getPatchSet().getRefName() + ":ps");
    adminTestRepo.reset("ps");
    // Amend change as admin
    PushOneCommit.Result r2 = amendChange(r1.getChangeId(), "refs/for/master", admin, adminTestRepo);
    r2.assertOkStatus();
}
#method_after
@Test
public void createNewPatchSetAsOwnerWithoutPermission() throws Exception {
    // Create new project with clean permissions
    Project.NameKey p = createProject("addPatchSet2");
    // Clone separate repositories of the same project as admin and as user
    TestRepository<?> adminTestRepo = cloneProject(project, admin);
    // Block default permission
    block(p, "refs/for/*", Permission.ADD_PATCH_SET, REGISTERED_USERS);
    // Create change as admin
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), adminTestRepo);
    PushOneCommit.Result r1 = push.to("refs/for/master");
    r1.assertOkStatus();
    // Fetch change
    GitUtil.fetch(adminTestRepo, r1.getPatchSet().getRefName() + ":ps");
    adminTestRepo.reset("ps");
    // Amend change as admin
    PushOneCommit.Result r2 = amendChange(r1.getChangeId(), "refs/for/master", admin, adminTestRepo);
    r2.assertOkStatus();
}
#end_block

#method_before
@Test
public void createMergePatchSet() throws Exception {
    PushOneCommit.Result start = pushTo("refs/heads/master");
    start.assertOkStatus();
    // create a change for master
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    String changeId = r.getChangeId();
    testRepo.reset(start.getCommit());
    PushOneCommit.Result currentMaster = pushTo("refs/heads/master");
    currentMaster.assertOkStatus();
    String parent = currentMaster.getCommit().getName();
    // push a commit into dev branch
    createBranch(new Branch.NameKey(project, "dev"));
    PushOneCommit.Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", "A.txt", "A content").to("refs/heads/dev");
    changeA.assertOkStatus();
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = "dev";
    MergePatchSetInput in = new MergePatchSetInput();
    in.merge = mergeInput;
    in.subject = "update change by merge ps2";
    gApi.changes().id(changeId).createMergePatchSet(in);
    ChangeInfo changeInfo = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION));
    assertThat(changeInfo.revisions.size()).isEqualTo(2);
    assertThat(changeInfo.subject).isEqualTo(in.subject);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isEqualTo(parent);
}
#method_after
@Test
public void createMergePatchSet() throws Exception {
    PushOneCommit.Result start = pushTo("refs/heads/master");
    start.assertOkStatus();
    // create a change for master
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    String changeId = r.getChangeId();
    testRepo.reset(start.getCommit());
    PushOneCommit.Result currentMaster = pushTo("refs/heads/master");
    currentMaster.assertOkStatus();
    String parent = currentMaster.getCommit().getName();
    // push a commit into dev branch
    createBranch(new Branch.NameKey(project, "dev"));
    PushOneCommit.Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", "A.txt", "A content").to("refs/heads/dev");
    changeA.assertOkStatus();
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = "dev";
    MergePatchSetInput in = new MergePatchSetInput();
    in.merge = mergeInput;
    in.subject = "update change by merge ps2";
    gApi.changes().id(changeId).createMergePatchSet(in);
    ChangeInfo changeInfo = gApi.changes().id(changeId).get(ALL_REVISIONS, CURRENT_COMMIT, CURRENT_REVISION);
    assertThat(changeInfo.revisions.size()).isEqualTo(2);
    assertThat(changeInfo.subject).isEqualTo(in.subject);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isEqualTo(parent);
}
#end_block

#method_before
@Test
public void createMergePatchSetInheritParent() throws Exception {
    PushOneCommit.Result start = pushTo("refs/heads/master");
    start.assertOkStatus();
    // create a change for master
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    String changeId = r.getChangeId();
    String parent = r.getCommit().getParent(0).getName();
    // advance master branch
    testRepo.reset(start.getCommit());
    PushOneCommit.Result currentMaster = pushTo("refs/heads/master");
    currentMaster.assertOkStatus();
    // push a commit into dev branch
    createBranch(new Branch.NameKey(project, "dev"));
    PushOneCommit.Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", "A.txt", "A content").to("refs/heads/dev");
    changeA.assertOkStatus();
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = "dev";
    MergePatchSetInput in = new MergePatchSetInput();
    in.merge = mergeInput;
    in.subject = "update change by merge ps2 inherit parent of ps1";
    in.inheritParent = true;
    gApi.changes().id(changeId).createMergePatchSet(in);
    ChangeInfo changeInfo = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION));
    assertThat(changeInfo.revisions.size()).isEqualTo(2);
    assertThat(changeInfo.subject).isEqualTo(in.subject);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isEqualTo(parent);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isNotEqualTo(currentMaster.getCommit().getName());
}
#method_after
@Test
public void createMergePatchSetInheritParent() throws Exception {
    PushOneCommit.Result start = pushTo("refs/heads/master");
    start.assertOkStatus();
    // create a change for master
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    String changeId = r.getChangeId();
    String parent = r.getCommit().getParent(0).getName();
    // advance master branch
    testRepo.reset(start.getCommit());
    PushOneCommit.Result currentMaster = pushTo("refs/heads/master");
    currentMaster.assertOkStatus();
    // push a commit into dev branch
    createBranch(new Branch.NameKey(project, "dev"));
    PushOneCommit.Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", "A.txt", "A content").to("refs/heads/dev");
    changeA.assertOkStatus();
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = "dev";
    MergePatchSetInput in = new MergePatchSetInput();
    in.merge = mergeInput;
    in.subject = "update change by merge ps2 inherit parent of ps1";
    in.inheritParent = true;
    gApi.changes().id(changeId).createMergePatchSet(in);
    ChangeInfo changeInfo = gApi.changes().id(changeId).get(ALL_REVISIONS, CURRENT_COMMIT, CURRENT_REVISION);
    assertThat(changeInfo.revisions.size()).isEqualTo(2);
    assertThat(changeInfo.subject).isEqualTo(in.subject);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isEqualTo(parent);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isNotEqualTo(currentMaster.getCommit().getName());
}
#end_block

#method_before
@Test
public void checkLabelsForMergedChange() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.status).isEqualTo(ChangeStatus.MERGED);
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    assertPermitted(change, "Code-Review", 2);
    // add new label and assert that it's returned for existing changes
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType verified = Util.verified();
    cfg.getLabelSections().put(verified.getName(), verified);
    AccountGroup.UUID registeredUsers = systemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    String heads = RefNames.REFS_HEADS + "*";
    Util.allow(cfg, Permission.forLabel(verified.getName()), -1, 1, registeredUsers, heads);
    saveProjectConfig(project, cfg);
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review", "Verified");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review", "Verified");
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified", 0, 1);
    // ignore the new label by Prolog submit rule and assert that the label is
    // no longer returned
    GitUtil.fetch(testRepo, RefNames.REFS_CONFIG + ":config");
    testRepo.reset("config");
    PushOneCommit push2 = pushFactory.create(db, admin.getIdent(), testRepo, "Ignore Verified", "rules.pl", "submit_rule(submit(CR)) :-\n" + "  gerrit:max_with_block(-2, 2, 'Code-Review', CR).");
    push2.to(RefNames.REFS_CONFIG);
    change = gApi.changes().id(r.getChangeId()).get();
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified");
    // add an approval on the new label and assert that the label is now
    // returned although it is ignored by the Prolog submit rule and hence not
    // included in the submit records
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(new ReviewInput().label(verified.getName(), verified.getMax().getValue()));
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review", "Verified");
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified");
    // remove label and assert that it's no longer returned for existing
    // changes, even if there is an approval for it
    cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().remove(verified.getName());
    Util.remove(cfg, Permission.forLabel(verified.getName()), registeredUsers, heads);
    saveProjectConfig(project, cfg);
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    assertPermitted(change, "Code-Review", 2);
}
#method_after
@Test
public void checkLabelsForMergedChange() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.status).isEqualTo(ChangeStatus.MERGED);
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    assertPermitted(change, "Code-Review", 2);
    // add new label and assert that it's returned for existing changes
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType verified = Util.verified();
    cfg.getLabelSections().put(verified.getName(), verified);
    AccountGroup.UUID registeredUsers = systemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    String heads = RefNames.REFS_HEADS + "*";
    Util.allow(cfg, Permission.forLabel(verified.getName()), -1, 1, registeredUsers, heads);
    saveProjectConfig(project, cfg);
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review", "Verified");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review", "Verified");
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified", 0, 1);
    // ignore the new label by Prolog submit rule and assert that the label is
    // no longer returned
    GitUtil.fetch(testRepo, RefNames.REFS_CONFIG + ":config");
    testRepo.reset("config");
    PushOneCommit push2 = pushFactory.create(db, admin.getIdent(), testRepo, "Ignore Verified", "rules.pl", "submit_rule(submit(CR)) :-\n  gerrit:max_with_block(-2, 2, 'Code-Review', CR).");
    push2.to(RefNames.REFS_CONFIG);
    change = gApi.changes().id(r.getChangeId()).get();
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified");
    // add an approval on the new label and assert that the label is now
    // returned although it is ignored by the Prolog submit rule and hence not
    // included in the submit records
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(new ReviewInput().label(verified.getName(), verified.getMax().getValue()));
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review", "Verified");
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified");
    // remove label and assert that it's no longer returned for existing
    // changes, even if there is an approval for it
    cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().remove(verified.getName());
    Util.remove(cfg, Permission.forLabel(verified.getName()), registeredUsers, heads);
    saveProjectConfig(project, cfg);
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    assertPermitted(change, "Code-Review", 2);
}
#end_block

#method_before
@Test
public void maxPermittedValueAllowed() throws Exception {
    final int minPermittedValue = -2;
    final int maxPermittedValue = +2;
    String heads = "refs/heads/*";
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(triplet).addReviewer(user.username);
    ChangeInfo c = gApi.changes().id(triplet).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
    LabelInfo codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    ApprovalInfo approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.permittedVotingRange).isNotNull();
    // default values
    assertThat(approval.permittedVotingRange.min).isEqualTo(-1);
    assertThat(approval.permittedVotingRange.max).isEqualTo(1);
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.allow(cfg, Permission.forLabel("Code-Review"), minPermittedValue, maxPermittedValue, REGISTERED_USERS, heads);
    saveProjectConfig(project, cfg);
    c = gApi.changes().id(triplet).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
    codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.permittedVotingRange).isNotNull();
    assertThat(approval.permittedVotingRange.min).isEqualTo(minPermittedValue);
    assertThat(approval.permittedVotingRange.max).isEqualTo(maxPermittedValue);
}
#method_after
@Test
public void maxPermittedValueAllowed() throws Exception {
    final int minPermittedValue = -2;
    final int maxPermittedValue = +2;
    String heads = "refs/heads/*";
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(triplet).addReviewer(user.username);
    ChangeInfo c = gApi.changes().id(triplet).get(DETAILED_LABELS);
    LabelInfo codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    ApprovalInfo approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.permittedVotingRange).isNotNull();
    // default values
    assertThat(approval.permittedVotingRange.min).isEqualTo(-1);
    assertThat(approval.permittedVotingRange.max).isEqualTo(1);
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.allow(cfg, Permission.forLabel("Code-Review"), minPermittedValue, maxPermittedValue, REGISTERED_USERS, heads);
    saveProjectConfig(project, cfg);
    c = gApi.changes().id(triplet).get(DETAILED_LABELS);
    codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.permittedVotingRange).isNotNull();
    assertThat(approval.permittedVotingRange.min).isEqualTo(minPermittedValue);
    assertThat(approval.permittedVotingRange.max).isEqualTo(maxPermittedValue);
}
#end_block

#method_before
@Test
public void maxPermittedValueBlocked() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    blockLabel(cfg, "Code-Review", REGISTERED_USERS, "refs/heads/*");
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(triplet).addReviewer(user.username);
    ChangeInfo c = gApi.changes().id(triplet).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
    LabelInfo codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    ApprovalInfo approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.permittedVotingRange).isNull();
}
#method_after
@Test
public void maxPermittedValueBlocked() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.blockLabel(cfg, "Code-Review", REGISTERED_USERS, "refs/heads/*");
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(triplet).addReviewer(user.username);
    ChangeInfo c = gApi.changes().id(triplet).get(DETAILED_LABELS);
    LabelInfo codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    ApprovalInfo approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.permittedVotingRange).isNull();
}
#end_block

#method_before
private ChangeResource parseResource(PushOneCommit.Result r) throws Exception {
    List<ChangeControl> ctls = changeFinder.find(r.getChangeId(), atrScope.get().getUser());
    assertThat(ctls).hasSize(1);
    return changeResourceFactory.create(ctls.get(0));
}
#method_after
private ChangeResource parseResource(PushOneCommit.Result r) throws Exception {
    return parseChangeResource(r.getChangeId());
}
#end_block

#method_before
private Optional<ReviewerState> getReviewerState(String changeId, Account.Id accountId) throws Exception {
    ChangeInfo c = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
    Set<ReviewerState> states = c.reviewers.entrySet().stream().filter(e -> e.getValue().stream().anyMatch(a -> a._accountId == accountId.get())).map(e -> e.getKey()).collect(toSet());
    assertThat(states.size()).named(states.toString()).isAtMost(1);
    return states.stream().findFirst();
}
#method_after
private Optional<ReviewerState> getReviewerState(String changeId, Account.Id accountId) throws Exception {
    ChangeInfo c = gApi.changes().id(changeId).get(DETAILED_LABELS);
    Set<ReviewerState> states = c.reviewers.entrySet().stream().filter(e -> e.getValue().stream().anyMatch(a -> a._accountId == accountId.get())).map(e -> e.getKey()).collect(toSet());
    assertThat(states.size()).named(states.toString()).isAtMost(1);
    return states.stream().findFirst();
}
#end_block

#method_before
private void setChangeStatus(Change.Id id, Change.Status newStatus) throws Exception {
    try (BatchUpdate batchUpdate = updateFactory.create(db, project, atrScope.get().getUser(), TimeUtil.nowTs())) {
        batchUpdate.addOp(id, new ChangeStatusUpdateOp(newStatus));
        batchUpdate.execute();
    }
    ChangeStatus changeStatus = gApi.changes().id(id.get()).get().status;
    assertThat(changeStatus).isEqualTo(newStatus.asChangeStatus());
}
#method_after
private void setChangeStatus(Change.Id id, Change.Status newStatus) throws Exception {
    try (BatchUpdate batchUpdate = batchUpdateFactory.create(db, project, atrScope.get().getUser(), TimeUtil.nowTs())) {
        batchUpdate.addOp(id, new ChangeStatusUpdateOp(newStatus));
        batchUpdate.execute();
    }
    ChangeStatus changeStatus = gApi.changes().id(id.get()).get().status;
    assertThat(changeStatus).isEqualTo(newStatus.asChangeStatus());
}
#end_block

#method_before
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws Exception {
    Change change = ctx.getChange();
    // Change status in database.
    change.setStatus(newStatus);
    // Change status in NoteDb.
    PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    ctx.getUpdate(currentPatchSetId).setStatus(newStatus);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws Exception {
    Change change = ctx.getChange();
    // Change status in database.
    change.setStatus(newStatus);
    // Change status in NoteDb.
    PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    ctx.getUpdate(currentPatchSetId).setStatus(newStatus);
    return true;
}
#end_block

#method_before
@ConfigSuite.Default
public static Config defaultConfig() {
    Config cfg = new Config();
    cfg.setBoolean("noteDb", null, "testRebuilderWrapper", true);
    // Disable async reindex-if-stale check after index update. This avoids
    // unintentional auto-rebuilding of the change in NoteDb during the read
    // path of the reindex-if-stale check. For the purposes of this test, we
    // want precise control over when auto-rebuilding happens.
    cfg.setBoolean("index", null, "testReindexAfterUpdate", false);
    return cfg;
}
#method_after
@ConfigSuite.Default
public static Config defaultConfig() {
    Config cfg = new Config();
    cfg.setBoolean("noteDb", null, "testRebuilderWrapper", true);
    // Disable async reindex-if-stale check after index update. This avoids
    // unintentional auto-rebuilding of the change in NoteDb during the read
    // path of the reindex-if-stale check. For the purposes of this test, we
    // want precise control over when auto-rebuilding happens.
    cfg.setBoolean("index", null, "autoReindexIfStale", false);
    // setNotesMigration tries to keep IDs in sync between ReviewDb and NoteDb, which is behavior
    // unique to this test. This gets prohibitively slow if we use the default sequence gap.
    cfg.setInt("noteDb", "changes", "initialSequenceGap", 0);
    return cfg;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    assume().that(NoteDbMode.readWrite()).isFalse();
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    setNotesMigration(false, false);
}
#method_after
@Before
public void setUp() throws Exception {
    assume().that(NoteDbMode.get()).isEqualTo(NoteDbMode.OFF);
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    setNotesMigration(false, false);
}
#end_block

#method_before
@Test
public void patchSetWithNullGroups() throws Exception {
    Timestamp ts = TimeUtil.nowTs();
    Change c = TestChanges.newChange(project, user.getId(), seq.nextChangeId());
    c.setCreatedOn(ts);
    c.setLastUpdatedOn(ts);
    PatchSet ps = TestChanges.newPatchSet(c.currentPatchSetId(), "deadbeefdeadbeefdeadbeefdeadbeefdeadbeef", user.getId());
    ps.setCreatedOn(ts);
    db.changes().insert(Collections.singleton(c));
    db.patchSets().insert(Collections.singleton(ps));
    assertThat(ps.getGroups()).isEmpty();
    checker.rebuildAndCheckChanges(c.getId());
}
#method_after
@Test
public void patchSetWithNullGroups() throws Exception {
    Timestamp ts = TimeUtil.nowTs();
    Change c = TestChanges.newChange(project, user.getId(), seq.nextChangeId());
    c.setCreatedOn(ts);
    c.setLastUpdatedOn(ts);
    c.setReviewStarted(true);
    PatchSet ps = TestChanges.newPatchSet(c.currentPatchSetId(), "deadbeefdeadbeefdeadbeefdeadbeefdeadbeef", user.getId());
    ps.setCreatedOn(ts);
    db.changes().insert(Collections.singleton(c));
    db.patchSets().insert(Collections.singleton(ps));
    assertThat(ps.getGroups()).isEmpty();
    checker.rebuildAndCheckChanges(c.getId());
}
#end_block

#method_before
@Test
public void rebuildAutomaticallyWithinBatchUpdate() throws Exception {
    setNotesMigration(true, true);
    PushOneCommit.Result r = createChange();
    final Change.Id id = r.getPatchSetId().getParentKey();
    assertChangeUpToDate(true, id);
    // Update ReviewDb and NoteDb, then revert the corresponding NoteDb change
    // to simulate it failing.
    NoteDbChangeState oldState = NoteDbChangeState.parse(getUnwrappedDb().changes().get(id));
    String topic = name("a-topic");
    gApi.changes().id(id.get()).topic(topic);
    try (Repository repo = repoManager.openRepository(project)) {
        new TestRepository<>(repo).update(RefNames.changeMetaRef(id), oldState.getChangeMetaId());
    }
    assertChangeUpToDate(false, id);
    // Next NoteDb read comes inside the transaction started by BatchUpdate. In
    // reality this could be caused by a failed update happening between when
    // the change is parsed by ChangesCollection and when the BatchUpdate
    // executes. We simulate it here by using BatchUpdate directly and not going
    // through an API handler.
    final String msg = "message from BatchUpdate";
    try (BatchUpdate bu = batchUpdateFactory.create(db, project, identifiedUserFactory.create(user.getId()), TimeUtil.nowTs())) {
        bu.addOp(id, new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws OrmException {
                PatchSet.Id psId = ctx.getChange().currentPatchSetId();
                ChangeMessage cm = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUuid()), ctx.getAccountId(), ctx.getWhen(), psId);
                cm.setMessage(msg);
                ctx.getDb().changeMessages().insert(Collections.singleton(cm));
                ctx.getUpdate(psId).setChangeMessage(msg);
                return true;
            }
        });
        try {
            bu.execute();
            fail("expected update to fail");
        } catch (UpdateException e) {
            assertThat(e.getMessage()).contains("cannot copy ChangeNotesState");
        }
    }
// TODO(dborowitz): Re-enable these assertions once we fix auto-rebuilding
// in the BatchUpdate path.
// // As an implementation detail, change wasn't actually rebuilt inside the
// // BatchUpdate transaction, but it was rebuilt during read for the
// // subsequent reindex. Thus it's impossible to actually observe an
// // out-of-date state in the caller.
// assertChangeUpToDate(true, id);
// // Check that the bundles are equal.
// ChangeNotes notes = notesFactory.create(dbProvider.get(), project, id);
// ChangeBundle actual = ChangeBundle.fromNotes(commentsUtil, notes);
// ChangeBundle expected = bundleReader.fromReviewDb(getUnwrappedDb(), id);
// assertThat(actual.differencesFrom(expected)).isEmpty();
// assertThat(
// Iterables.transform(
// notes.getChangeMessages(),
// ChangeMessage::getMessage))
// .contains(msg);
// assertThat(actual.getChange().getTopic()).isEqualTo(topic);
}
#method_after
@Test
public void rebuildAutomaticallyWithinBatchUpdate() throws Exception {
    setNotesMigration(true, true);
    PushOneCommit.Result r = createChange();
    final Change.Id id = r.getPatchSetId().getParentKey();
    assertChangeUpToDate(true, id);
    // Update ReviewDb and NoteDb, then revert the corresponding NoteDb change
    // to simulate it failing.
    NoteDbChangeState oldState = NoteDbChangeState.parse(getUnwrappedDb().changes().get(id));
    String topic = name("a-topic");
    gApi.changes().id(id.get()).topic(topic);
    try (Repository repo = repoManager.openRepository(project)) {
        new TestRepository<>(repo).update(RefNames.changeMetaRef(id), oldState.getChangeMetaId());
    }
    assertChangeUpToDate(false, id);
    // Next NoteDb read comes inside the transaction started by BatchUpdate. In
    // reality this could be caused by a failed update happening between when
    // the change is parsed by ChangesCollection and when the BatchUpdate
    // executes. We simulate it here by using BatchUpdate directly and not going
    // through an API handler.
    final String msg = "message from BatchUpdate";
    try (BatchUpdate bu = batchUpdateFactory.create(db, project, identifiedUserFactory.create(user.getId()), TimeUtil.nowTs())) {
        bu.addOp(id, new BatchUpdateOp() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws OrmException {
                PatchSet.Id psId = ctx.getChange().currentPatchSetId();
                ChangeMessage cm = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUuid()), ctx.getAccountId(), ctx.getWhen(), psId);
                cm.setMessage(msg);
                ctx.getDb().changeMessages().insert(Collections.singleton(cm));
                ctx.getUpdate(psId).setChangeMessage(msg);
                return true;
            }
        });
        try {
            bu.execute();
            fail("expected update to fail");
        } catch (UpdateException e) {
            assertThat(e.getMessage()).contains("cannot copy ChangeNotesState");
        }
    }
// TODO(dborowitz): Re-enable these assertions once we fix auto-rebuilding
// in the BatchUpdate path.
// As an implementation detail, change wasn't actually rebuilt inside the
// BatchUpdate transaction, but it was rebuilt during read for the
// subsequent reindex. Thus it's impossible to actually observe an
// out-of-date state in the caller.
// assertChangeUpToDate(true, id);
// Check that the bundles are equal.
// ChangeNotes notes = notesFactory.create(dbProvider.get(), project, id);
// ChangeBundle actual = ChangeBundle.fromNotes(commentsUtil, notes);
// ChangeBundle expected = bundleReader.fromReviewDb(getUnwrappedDb(), id);
// assertThat(actual.differencesFrom(expected)).isEmpty();
// assertThat(
// Iterables.transform(
// notes.getChangeMessages(),
// ChangeMessage::getMessage))
// .contains(msg);
// assertThat(actual.getChange().getTopic()).isEqualTo(topic);
}
#end_block

#method_before
@Test
public void commentBeforeFirstPatchSet() throws Exception {
    PushOneCommit.Result r = createChange();
    PatchSet.Id psId = r.getPatchSetId();
    Change.Id id = psId.getParentKey();
    Change c = db.changes().get(id);
    c.setCreatedOn(new Timestamp(c.getCreatedOn().getTime() - 5000));
    db.changes().update(Collections.singleton(c));
    indexer.index(db, project, id);
    ReviewInput rin = new ReviewInput();
    rin.message = "comment";
    Timestamp ts = new Timestamp(c.getCreatedOn().getTime() + 2000);
    assertThat(ts).isGreaterThan(c.getCreatedOn());
    assertThat(ts).isLessThan(db.patchSets().get(psId).getCreatedOn());
    RevisionResource revRsrc = parseCurrentRevisionResource(r.getChangeId());
    postReview.get().apply(revRsrc, rin, ts);
    checker.rebuildAndCheckChanges(id);
}
#method_after
@Test
public void commentBeforeFirstPatchSet() throws Exception {
    PushOneCommit.Result r = createChange();
    PatchSet.Id psId = r.getPatchSetId();
    Change.Id id = psId.getParentKey();
    Change c = db.changes().get(id);
    c.setCreatedOn(new Timestamp(c.getCreatedOn().getTime() - 5000));
    db.changes().update(Collections.singleton(c));
    indexer.index(db, project, id);
    ReviewInput rin = new ReviewInput();
    rin.message = "comment";
    Timestamp ts = new Timestamp(c.getCreatedOn().getTime() + 2000);
    assertThat(ts).isGreaterThan(c.getCreatedOn());
    assertThat(ts).isLessThan(db.patchSets().get(psId).getCreatedOn());
    RevisionResource revRsrc = parseCurrentRevisionResource(r.getChangeId());
    postReview.get().apply(batchUpdateFactory, revRsrc, rin, ts);
    checker.rebuildAndCheckChanges(id);
}
#end_block

#method_before
@Test
public void commentPredatingChangeBySomeoneOtherThanOwner() throws Exception {
    PushOneCommit.Result r = createChange();
    PatchSet.Id psId = r.getPatchSetId();
    Change.Id id = psId.getParentKey();
    Change c = db.changes().get(id);
    ReviewInput rin = new ReviewInput();
    rin.message = "comment";
    Timestamp ts = new Timestamp(c.getCreatedOn().getTime() - 10000);
    RevisionResource revRsrc = parseCurrentRevisionResource(r.getChangeId());
    setApiUser(user);
    postReview.get().apply(revRsrc, rin, ts);
    checker.rebuildAndCheckChanges(id);
}
#method_after
@Test
public void commentPredatingChangeBySomeoneOtherThanOwner() throws Exception {
    PushOneCommit.Result r = createChange();
    PatchSet.Id psId = r.getPatchSetId();
    Change.Id id = psId.getParentKey();
    Change c = db.changes().get(id);
    ReviewInput rin = new ReviewInput();
    rin.message = "comment";
    Timestamp ts = new Timestamp(c.getCreatedOn().getTime() - 10000);
    RevisionResource revRsrc = parseCurrentRevisionResource(r.getChangeId());
    setApiUser(user);
    postReview.get().apply(batchUpdateFactory, revRsrc, rin, ts);
    checker.rebuildAndCheckChanges(id);
}
#end_block

#method_before
@Test
public void highestNumberedPatchSetIsNotCurrent() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PatchSet.Id psId1 = r1.getPatchSetId();
    Change.Id id = psId1.getParentKey();
    PushOneCommit.Result r2 = amendChange(r1.getChangeId());
    PatchSet.Id psId2 = r2.getPatchSetId();
    try (BatchUpdate bu = batchUpdateFactory.create(db, project, identifiedUserFactory.create(user.getId()), TimeUtil.nowTs())) {
        bu.addOp(id, new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws PatchSetInfoNotAvailableException {
                ctx.getChange().setCurrentPatchSet(patchSetInfoFactory.get(ctx.getDb(), ctx.getNotes(), psId1));
                return true;
            }
        });
        bu.execute();
    }
    ChangeNotes notes = notesFactory.create(db, project, id);
    assertThat(psUtil.byChangeAsMap(db, notes).keySet()).containsExactly(psId1, psId2);
    assertThat(notes.getChange().currentPatchSetId()).isEqualTo(psId1);
    assertThat(db.changes().get(id).currentPatchSetId()).isEqualTo(psId1);
    checker.rebuildAndCheckChanges(id);
    setNotesMigration(true, true);
    notes = notesFactory.create(db, project, id);
    assertThat(psUtil.byChangeAsMap(db, notes).keySet()).containsExactly(psId1, psId2);
    assertThat(notes.getChange().currentPatchSetId()).isEqualTo(psId1);
}
#method_after
@Test
public void highestNumberedPatchSetIsNotCurrent() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PatchSet.Id psId1 = r1.getPatchSetId();
    Change.Id id = psId1.getParentKey();
    PushOneCommit.Result r2 = amendChange(r1.getChangeId());
    PatchSet.Id psId2 = r2.getPatchSetId();
    try (BatchUpdate bu = batchUpdateFactory.create(db, project, identifiedUserFactory.create(user.getId()), TimeUtil.nowTs())) {
        bu.addOp(id, new BatchUpdateOp() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws PatchSetInfoNotAvailableException {
                ctx.getChange().setCurrentPatchSet(patchSetInfoFactory.get(ctx.getDb(), ctx.getNotes(), psId1));
                return true;
            }
        });
        bu.execute();
    }
    ChangeNotes notes = notesFactory.create(db, project, id);
    assertThat(psUtil.byChangeAsMap(db, notes).keySet()).containsExactly(psId1, psId2);
    assertThat(notes.getChange().currentPatchSetId()).isEqualTo(psId1);
    assertThat(db.changes().get(id).currentPatchSetId()).isEqualTo(psId1);
    checker.rebuildAndCheckChanges(id);
    setNotesMigration(true, true);
    notes = notesFactory.create(db, project, id);
    assertThat(psUtil.byChangeAsMap(db, notes).keySet()).containsExactly(psId1, psId2);
    assertThat(notes.getChange().currentPatchSetId()).isEqualTo(psId1);
}
#end_block

#method_before
private void assertChangesReadOnly(RestApiException e) throws Exception {
    Throwable cause = e.getCause();
    assertThat(cause).isInstanceOf(UpdateException.class);
    assertThat(cause.getCause()).isInstanceOf(OrmException.class);
    assertThat(cause.getCause()).hasMessage(NoteDbUpdateManager.CHANGES_READ_ONLY);
}
#method_after
private void assertChangesReadOnly(RestApiException e) throws Exception {
    Throwable cause = e.getCause();
    assertThat(cause).isInstanceOf(UpdateException.class);
    assertThat(cause.getCause()).isInstanceOf(OrmException.class);
    assertThat(cause.getCause()).hasMessageThat().isEqualTo(NoteDbUpdateManager.CHANGES_READ_ONLY);
}
#end_block

#method_before
@Test
public void revisionActionsTwoChangesInTopic() throws Exception {
    String changeId = createChangeWithTopic().getChangeId();
    approve(changeId);
    String changeId2 = createChangeWithTopic().getChangeId();
    Map<String, ActionInfo> actions = getActions(changeId);
    commonActionsAssertions(actions);
    if (isSubmitWholeTopicEnabled()) {
        ActionInfo info = actions.get("submit");
        assertThat(info.enabled).isNull();
        assertThat(info.label).isEqualTo("Submit whole topic");
        assertThat(info.method).isEqualTo("POST");
        assertThat(info.title).isEqualTo("This change depends on other " + "changes which are not ready");
    } else {
        noSubmitWholeTopicAssertions(actions, 1);
        assertThat(getActions(changeId2).get("submit")).isNull();
        approve(changeId2);
        noSubmitWholeTopicAssertions(getActions(changeId2), 2);
    }
}
#method_after
@Test
public void revisionActionsTwoChangesInTopic() throws Exception {
    String changeId = createChangeWithTopic().getChangeId();
    approve(changeId);
    String changeId2 = createChangeWithTopic().getChangeId();
    Map<String, ActionInfo> actions = getActions(changeId);
    commonActionsAssertions(actions);
    if (isSubmitWholeTopicEnabled()) {
        ActionInfo info = actions.get("submit");
        assertThat(info.enabled).isNull();
        assertThat(info.label).isEqualTo("Submit whole topic");
        assertThat(info.method).isEqualTo("POST");
        assertThat(info.title).isEqualTo("This change depends on other changes which are not ready");
    } else {
        noSubmitWholeTopicAssertions(actions, 1);
        assertThat(getActions(changeId2).get("submit")).isNull();
        approve(changeId2);
        noSubmitWholeTopicAssertions(getActions(changeId2), 2);
    }
}
#end_block

#method_before
@Test
public void revisionActionsTwoChangesInTopic_conflicting() throws Exception {
    String changeId = createChangeWithTopic().getChangeId();
    approve(changeId);
    // create another change with the same topic
    String changeId2 = createChangeWithTopic(testRepo, "foo2", "touching b", "b.txt", "real content").getChangeId();
    approve(changeId2);
    // collide with the other change in the same topic
    testRepo.reset("HEAD~2");
    String collidingChange = createChangeWithTopic(testRepo, "off_topic", "rewriting file b", "b.txt", "garbage\ngarbage\ngarbage").getChangeId();
    gApi.changes().id(collidingChange).current().review(ReviewInput.approve());
    gApi.changes().id(collidingChange).current().submit();
    Map<String, ActionInfo> actions = getActions(changeId);
    commonActionsAssertions(actions);
    if (isSubmitWholeTopicEnabled()) {
        ActionInfo info = actions.get("submit");
        assertThat(info.enabled).isNull();
        assertThat(info.label).isEqualTo("Submit whole topic");
        assertThat(info.method).isEqualTo("POST");
        assertThat(info.title).isEqualTo("Problems with change(s): 2");
    } else {
        noSubmitWholeTopicAssertions(actions, 1);
    }
}
#method_after
@Test
public void revisionActionsTwoChangesInTopic_conflicting() throws Exception {
    String changeId = createChangeWithTopic().getChangeId();
    approve(changeId);
    // create another change with the same topic
    String changeId2 = createChangeWithTopic(testRepo, "topic", "touching b", "b.txt", "real content").getChangeId();
    int changeNum2 = gApi.changes().id(changeId2).info()._number;
    approve(changeId2);
    // collide with the other change in the same topic
    testRepo.reset("HEAD~2");
    String collidingChange = createChangeWithTopic(testRepo, "off_topic", "rewriting file b", "b.txt", "garbage\ngarbage\ngarbage").getChangeId();
    gApi.changes().id(collidingChange).current().review(ReviewInput.approve());
    gApi.changes().id(collidingChange).current().submit();
    Map<String, ActionInfo> actions = getActions(changeId);
    commonActionsAssertions(actions);
    if (isSubmitWholeTopicEnabled()) {
        ActionInfo info = actions.get("submit");
        assertThat(info.enabled).isNull();
        assertThat(info.label).isEqualTo("Submit whole topic");
        assertThat(info.method).isEqualTo("POST");
        assertThat(info.title).isEqualTo("Problems with change(s): " + changeNum2);
    } else {
        noSubmitWholeTopicAssertions(actions, 1);
    }
}
#end_block

#method_before
private void noSubmitWholeTopicAssertions(Map<String, ActionInfo> actions, int nrChanges) {
    ActionInfo info = actions.get("submit");
    assertThat(info.enabled).isTrue();
    if (nrChanges == 1) {
        assertThat(info.label).isEqualTo("Submit");
    } else {
        assertThat(info.label).isEqualTo("Submit including parents");
    }
    assertThat(info.method).isEqualTo("POST");
    if (nrChanges == 1) {
        assertThat(info.title).isEqualTo("Submit patch set 1 into master");
    } else {
        assertThat(info.title).isEqualTo(String.format("Submit patch set 1 and ancestors (%d changes " + "altogether) into master", nrChanges));
    }
}
#method_after
private void noSubmitWholeTopicAssertions(Map<String, ActionInfo> actions, int nrChanges) {
    ActionInfo info = actions.get("submit");
    assertThat(info.enabled).isTrue();
    if (nrChanges == 1) {
        assertThat(info.label).isEqualTo("Submit");
    } else {
        assertThat(info.label).isEqualTo("Submit including parents");
    }
    assertThat(info.method).isEqualTo("POST");
    if (nrChanges == 1) {
        assertThat(info.title).isEqualTo("Submit patch set 1 into master");
    } else {
        assertThat(info.title).isEqualTo(String.format("Submit patch set 1 and ancestors (%d changes altogether) into master", nrChanges));
    }
}
#end_block

#method_before
@Test
public void changeActionVisitor() throws Exception {
    String id = createChange().getChangeId();
    ChangeInfo origChange = gApi.changes().id(id).get(EnumSet.of(ListChangesOption.CHANGE_ACTIONS));
    class Visitor implements ActionVisitor {

        @Override
        public boolean visit(String name, ActionInfo actionInfo, ChangeInfo changeInfo) {
            assertThat(changeInfo).isNotNull();
            assertThat(changeInfo._number).isEqualTo(origChange._number);
            if (name.equals("followup")) {
                return false;
            }
            if (name.equals("abandon")) {
                actionInfo.label = "Abandon All Hope";
            }
            return true;
        }

        @Override
        public boolean visit(String name, ActionInfo actionInfo, ChangeInfo changeInfo, RevisionInfo revisionInfo) {
            throw new UnsupportedOperationException();
        }
    }
    Map<String, ActionInfo> origActions = origChange.actions;
    assertThat(origActions.keySet()).containsAllOf("followup", "abandon");
    assertThat(origActions.get("abandon").label).isEqualTo("Abandon");
    Visitor v = new Visitor();
    visitorHandle = actionVisitors.add(v);
    Map<String, ActionInfo> newActions = gApi.changes().id(id).get(EnumSet.of(ListChangesOption.CHANGE_ACTIONS)).actions;
    Set<String> expectedNames = new TreeSet<>(origActions.keySet());
    expectedNames.remove("followup");
    assertThat(newActions.keySet()).isEqualTo(expectedNames);
    ActionInfo abandon = newActions.get("abandon");
    assertThat(abandon).isNotNull();
    assertThat(abandon.label).isEqualTo("Abandon All Hope");
}
#method_after
@Test
public void changeActionVisitor() throws Exception {
    String id = createChange().getChangeId();
    ChangeInfo origChange = gApi.changes().id(id).get(CHANGE_ACTIONS);
    class Visitor implements ActionVisitor {

        @Override
        public boolean visit(String name, ActionInfo actionInfo, ChangeInfo changeInfo) {
            assertThat(changeInfo).isNotNull();
            assertThat(changeInfo._number).isEqualTo(origChange._number);
            if (name.equals("followup")) {
                return false;
            }
            if (name.equals("abandon")) {
                actionInfo.label = "Abandon All Hope";
            }
            return true;
        }

        @Override
        public boolean visit(String name, ActionInfo actionInfo, ChangeInfo changeInfo, RevisionInfo revisionInfo) {
            throw new UnsupportedOperationException();
        }
    }
    Map<String, ActionInfo> origActions = origChange.actions;
    assertThat(origActions.keySet()).containsAllOf("followup", "abandon");
    assertThat(origActions.get("abandon").label).isEqualTo("Abandon");
    Visitor v = new Visitor();
    visitorHandle = actionVisitors.add(v);
    Map<String, ActionInfo> newActions = gApi.changes().id(id).get(EnumSet.of(ListChangesOption.CHANGE_ACTIONS)).actions;
    Set<String> expectedNames = new TreeSet<>(origActions.keySet());
    expectedNames.remove("followup");
    assertThat(newActions.keySet()).isEqualTo(expectedNames);
    ActionInfo abandon = newActions.get("abandon");
    assertThat(abandon).isNotNull();
    assertThat(abandon.label).isEqualTo("Abandon All Hope");
}
#end_block

#method_before
@Override
public boolean visit(String name, ActionInfo actionInfo, ChangeInfo changeInfo, RevisionInfo revisionInfo) {
    assertThat(changeInfo).isNotNull();
    assertThat(changeInfo._number).isEqualTo(origChange._number);
    assertThat(revisionInfo).isNotNull();
    assertThat(revisionInfo._number).isEqualTo(1);
    if (name.equals("cherrypick")) {
        return false;
    }
    if (name.equals("rebase")) {
        actionInfo.label = "All Your Base";
    }
    return true;
}
#method_after
@Override
public boolean visit(String name, ActionInfo actionInfo, ChangeInfo changeInfo, RevisionInfo revisionInfo) {
    assertThat(changeInfo).isNotNull();
    assertThat(changeInfo._number).isEqualTo(origChange._number);
    assertThat(revisionInfo).isNotNull();
    assertThat(revisionInfo._number).isEqualTo(2);
    if (name.equals("cherrypick")) {
        return false;
    }
    if (name.equals("rebase")) {
        actionInfo.label = "All Your Base";
    }
    return true;
}
#end_block

#method_before
@Override
public boolean visit(String name, ActionInfo actionInfo, ChangeInfo changeInfo, RevisionInfo revisionInfo) {
    assertThat(changeInfo).isNotNull();
    assertThat(changeInfo._number).isEqualTo(origChange._number);
    assertThat(revisionInfo).isNotNull();
    assertThat(revisionInfo._number).isEqualTo(1);
    if (name.equals("cherrypick")) {
        return false;
    }
    if (name.equals("rebase")) {
        actionInfo.label = "All Your Base";
    }
    return true;
}
#method_after
@Override
public boolean visit(String name, ActionInfo actionInfo, ChangeInfo changeInfo) {
    // Do nothing; implicitly called for CURRENT_ACTIONS.
    return true;
}
#end_block

#method_before
@Test
public void submitOnPush() throws Exception {
    grant(Permission.SUBMIT, project, "refs/for/refs/heads/master");
    PushOneCommit.Result r = pushTo("refs/for/master%submit");
    r.assertOkStatus();
    r.assertChange(Change.Status.MERGED, null, admin);
    assertSubmitApproval(r.getPatchSetId());
    assertCommit(project, "refs/heads/master");
}
#method_after
@Test
public void submitOnPush() throws Exception {
    grant(project, "refs/for/refs/heads/master", Permission.SUBMIT);
    PushOneCommit.Result r = pushTo("refs/for/master%submit");
    r.assertOkStatus();
    r.assertChange(Change.Status.MERGED, null, admin);
    assertSubmitApproval(r.getPatchSetId());
    assertCommit(project, "refs/heads/master");
}
#end_block

#method_before
@Test
public void submitOnPushWithTag() throws Exception {
    grant(Permission.SUBMIT, project, "refs/for/refs/heads/master");
    grant(Permission.CREATE, project, "refs/tags/*");
    grant(Permission.PUSH, project, "refs/tags/*");
    PushOneCommit.Tag tag = new PushOneCommit.Tag("v1.0");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo);
    push.setTag(tag);
    PushOneCommit.Result r = push.to("refs/for/master%submit");
    r.assertOkStatus();
    r.assertChange(Change.Status.MERGED, null, admin);
    assertSubmitApproval(r.getPatchSetId());
    assertCommit(project, "refs/heads/master");
    assertTag(project, "refs/heads/master", tag);
}
#method_after
@Test
public void submitOnPushWithTag() throws Exception {
    grant(project, "refs/for/refs/heads/master", Permission.SUBMIT);
    grant(project, "refs/tags/*", Permission.CREATE);
    grant(project, "refs/tags/*", Permission.PUSH);
    PushOneCommit.Tag tag = new PushOneCommit.Tag("v1.0");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo);
    push.setTag(tag);
    PushOneCommit.Result r = push.to("refs/for/master%submit");
    r.assertOkStatus();
    r.assertChange(Change.Status.MERGED, null, admin);
    assertSubmitApproval(r.getPatchSetId());
    assertCommit(project, "refs/heads/master");
    assertTag(project, "refs/heads/master", tag);
}
#end_block

#method_before
@Test
public void submitOnPushWithAnnotatedTag() throws Exception {
    grant(Permission.SUBMIT, project, "refs/for/refs/heads/master");
    grant(Permission.PUSH, project, "refs/tags/*");
    PushOneCommit.AnnotatedTag tag = new PushOneCommit.AnnotatedTag("v1.0", "annotation", admin.getIdent());
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo);
    push.setTag(tag);
    PushOneCommit.Result r = push.to("refs/for/master%submit");
    r.assertOkStatus();
    r.assertChange(Change.Status.MERGED, null, admin);
    assertSubmitApproval(r.getPatchSetId());
    assertCommit(project, "refs/heads/master");
    assertTag(project, "refs/heads/master", tag);
}
#method_after
@Test
public void submitOnPushWithAnnotatedTag() throws Exception {
    grant(project, "refs/for/refs/heads/master", Permission.SUBMIT);
    grant(project, "refs/tags/*", Permission.PUSH);
    PushOneCommit.AnnotatedTag tag = new PushOneCommit.AnnotatedTag("v1.0", "annotation", admin.getIdent());
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo);
    push.setTag(tag);
    PushOneCommit.Result r = push.to("refs/for/master%submit");
    r.assertOkStatus();
    r.assertChange(Change.Status.MERGED, null, admin);
    assertSubmitApproval(r.getPatchSetId());
    assertCommit(project, "refs/heads/master");
    assertTag(project, "refs/heads/master", tag);
}
#end_block

#method_before
@Test
public void submitOnPushToRefsMetaConfig() throws Exception {
    grant(Permission.SUBMIT, project, "refs/for/refs/meta/config");
    git().fetch().setRefSpecs(new RefSpec("refs/meta/config:refs/meta/config")).call();
    testRepo.reset(RefNames.REFS_CONFIG);
    PushOneCommit.Result r = pushTo("refs/for/refs/meta/config%submit");
    r.assertOkStatus();
    r.assertChange(Change.Status.MERGED, null, admin);
    assertSubmitApproval(r.getPatchSetId());
    assertCommit(project, RefNames.REFS_CONFIG);
}
#method_after
@Test
public void submitOnPushToRefsMetaConfig() throws Exception {
    grant(project, "refs/for/refs/meta/config", Permission.SUBMIT);
    git().fetch().setRefSpecs(new RefSpec("refs/meta/config:refs/meta/config")).call();
    testRepo.reset(RefNames.REFS_CONFIG);
    PushOneCommit.Result r = pushTo("refs/for/refs/meta/config%submit");
    r.assertOkStatus();
    r.assertChange(Change.Status.MERGED, null, admin);
    assertSubmitApproval(r.getPatchSetId());
    assertCommit(project, RefNames.REFS_CONFIG);
}
#end_block

#method_before
@Test
public void submitOnPushMergeConflict() throws Exception {
    ObjectId objectId = repo().exactRef("HEAD").getObjectId();
    push("refs/heads/master", "one change", "a.txt", "some content");
    testRepo.reset(objectId);
    grant(Permission.SUBMIT, project, "refs/for/refs/heads/master");
    PushOneCommit.Result r = push("refs/for/master%submit", "other change", "a.txt", "other content");
    r.assertErrorStatus();
    r.assertChange(Change.Status.NEW, null);
    r.assertMessage("Change " + r.getChange().getId() + ": change could not be merged due to a path conflict.");
}
#method_after
@Test
public void submitOnPushMergeConflict() throws Exception {
    ObjectId objectId = repo().exactRef("HEAD").getObjectId();
    push("refs/heads/master", "one change", "a.txt", "some content");
    testRepo.reset(objectId);
    grant(project, "refs/for/refs/heads/master", Permission.SUBMIT);
    PushOneCommit.Result r = push("refs/for/master%submit", "other change", "a.txt", "other content");
    r.assertErrorStatus();
    r.assertChange(Change.Status.NEW, null);
    r.assertMessage("Change " + r.getChange().getId() + ": change could not be merged due to a path conflict.");
}
#end_block

#method_before
@Test
public void submitOnPushSuccessfulMerge() throws Exception {
    String master = "refs/heads/master";
    ObjectId objectId = repo().exactRef("HEAD").getObjectId();
    push(master, "one change", "a.txt", "some content");
    testRepo.reset(objectId);
    grant(Permission.SUBMIT, project, "refs/for/refs/heads/master");
    PushOneCommit.Result r = push("refs/for/master%submit", "other change", "b.txt", "other content");
    r.assertOkStatus();
    r.assertChange(Change.Status.MERGED, null, admin);
    assertMergeCommit(master, "other change");
}
#method_after
@Test
public void submitOnPushSuccessfulMerge() throws Exception {
    String master = "refs/heads/master";
    ObjectId objectId = repo().exactRef("HEAD").getObjectId();
    push(master, "one change", "a.txt", "some content");
    testRepo.reset(objectId);
    grant(project, "refs/for/refs/heads/master", Permission.SUBMIT);
    PushOneCommit.Result r = push("refs/for/master%submit", "other change", "b.txt", "other content");
    r.assertOkStatus();
    r.assertChange(Change.Status.MERGED, null, admin);
    assertMergeCommit(master, "other change");
}
#end_block

#method_before
@Test
public void submitOnPushNewPatchSet() throws Exception {
    PushOneCommit.Result r = push("refs/for/master", PushOneCommit.SUBJECT, "a.txt", "some content");
    grant(Permission.SUBMIT, project, "refs/for/refs/heads/master");
    r = push("refs/for/master%submit", PushOneCommit.SUBJECT, "a.txt", "other content", r.getChangeId());
    r.assertOkStatus();
    r.assertChange(Change.Status.MERGED, null, admin);
    ChangeData cd = Iterables.getOnlyElement(queryProvider.get().byKeyPrefix(r.getChangeId()));
    assertThat(cd.patchSets()).hasSize(2);
    assertSubmitApproval(r.getPatchSetId());
    assertCommit(project, "refs/heads/master");
}
#method_after
@Test
public void submitOnPushNewPatchSet() throws Exception {
    PushOneCommit.Result r = push("refs/for/master", PushOneCommit.SUBJECT, "a.txt", "some content");
    grant(project, "refs/for/refs/heads/master", Permission.SUBMIT);
    r = push("refs/for/master%submit", PushOneCommit.SUBJECT, "a.txt", "other content", r.getChangeId());
    r.assertOkStatus();
    r.assertChange(Change.Status.MERGED, null, admin);
    ChangeData cd = Iterables.getOnlyElement(queryProvider.get().byKeyPrefix(r.getChangeId()));
    assertThat(cd.patchSets()).hasSize(2);
    assertSubmitApproval(r.getPatchSetId());
    assertCommit(project, "refs/heads/master");
}
#end_block

#method_before
@Test
public void submitOnPushNotAllowed_Error() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master%submit");
    r.assertErrorStatus("submit not allowed");
}
#method_after
@Test
public void submitOnPushNotAllowed_Error() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master%submit");
    r.assertErrorStatus("update by submit not permitted");
}
#end_block

#method_before
@Test
public void submitOnPushNewPatchSetNotAllowed_Error() throws Exception {
    PushOneCommit.Result r = push("refs/for/master", PushOneCommit.SUBJECT, "a.txt", "some content");
    r = push("refs/for/master%submit", PushOneCommit.SUBJECT, "a.txt", "other content", r.getChangeId());
    r.assertErrorStatus("submit not allowed");
}
#method_after
@Test
public void submitOnPushNewPatchSetNotAllowed_Error() throws Exception {
    PushOneCommit.Result r = push("refs/for/master", PushOneCommit.SUBJECT, "a.txt", "some content");
    r = push("refs/for/master%submit", PushOneCommit.SUBJECT, "a.txt", "other content", r.getChangeId());
    r.assertErrorStatus("update by submit not permitted");
}
#end_block

#method_before
@Test
public void mergeOnPushToBranch() throws Exception {
    grant(Permission.PUSH, project, "refs/heads/master");
    PushOneCommit.Result r = push("refs/for/master", PushOneCommit.SUBJECT, "a.txt", "some content");
    r.assertOkStatus();
    git().push().setRefSpecs(new RefSpec(r.getCommit().name() + ":refs/heads/master")).call();
    assertCommit(project, "refs/heads/master");
    ChangeData cd = Iterables.getOnlyElement(queryProvider.get().byKey(new Change.Key(r.getChangeId())));
    RevCommit c = r.getCommit();
    PatchSet.Id psId = cd.currentPatchSet().getId();
    assertThat(psId.get()).isEqualTo(1);
    assertThat(cd.change().getStatus()).isEqualTo(Change.Status.MERGED);
    assertSubmitApproval(psId);
    assertThat(cd.patchSets()).hasSize(1);
    assertThat(cd.patchSet(psId).getRevision().get()).isEqualTo(c.name());
}
#method_after
@Test
public void mergeOnPushToBranch() throws Exception {
    grant(project, "refs/heads/master", Permission.PUSH);
    PushOneCommit.Result r = push("refs/for/master", PushOneCommit.SUBJECT, "a.txt", "some content");
    r.assertOkStatus();
    git().push().setRefSpecs(new RefSpec(r.getCommit().name() + ":refs/heads/master")).call();
    assertCommit(project, "refs/heads/master");
    ChangeData cd = Iterables.getOnlyElement(queryProvider.get().byKey(new Change.Key(r.getChangeId())));
    RevCommit c = r.getCommit();
    PatchSet.Id psId = cd.currentPatchSet().getId();
    assertThat(psId.get()).isEqualTo(1);
    assertThat(cd.change().getStatus()).isEqualTo(Change.Status.MERGED);
    assertSubmitApproval(psId);
    assertThat(cd.patchSets()).hasSize(1);
    assertThat(cd.patchSet(psId).getRevision().get()).isEqualTo(c.name());
}
#end_block

#method_before
@Test
public void mergeOnPushToBranchWithNewPatchset() throws Exception {
    grant(Permission.PUSH, project, "refs/heads/master");
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    RevCommit c1 = r.getCommit();
    PatchSet.Id psId1 = r.getPatchSetId();
    assertThat(psId1.get()).isEqualTo(1);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/heads/master");
    r.assertOkStatus();
    ChangeData cd = r.getChange();
    RevCommit c2 = r.getCommit();
    assertThat(cd.change().getStatus()).isEqualTo(Change.Status.MERGED);
    PatchSet.Id psId2 = cd.change().currentPatchSetId();
    assertThat(psId2.get()).isEqualTo(2);
    assertCommit(project, "refs/heads/master");
    assertSubmitApproval(psId2);
    assertThat(cd.patchSets()).hasSize(2);
    assertThat(cd.patchSet(psId1).getRevision().get()).isEqualTo(c1.name());
    assertThat(cd.patchSet(psId2).getRevision().get()).isEqualTo(c2.name());
}
#method_after
@Test
public void mergeOnPushToBranchWithNewPatchset() throws Exception {
    grant(project, "refs/heads/master", Permission.PUSH);
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    RevCommit c1 = r.getCommit();
    PatchSet.Id psId1 = r.getPatchSetId();
    assertThat(psId1.get()).isEqualTo(1);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/heads/master");
    r.assertOkStatus();
    ChangeData cd = r.getChange();
    RevCommit c2 = r.getCommit();
    assertThat(cd.change().getStatus()).isEqualTo(Change.Status.MERGED);
    PatchSet.Id psId2 = cd.change().currentPatchSetId();
    assertThat(psId2.get()).isEqualTo(2);
    assertCommit(project, "refs/heads/master");
    assertSubmitApproval(psId2);
    assertThat(cd.patchSets()).hasSize(2);
    assertThat(cd.patchSet(psId1).getRevision().get()).isEqualTo(c1.name());
    assertThat(cd.patchSet(psId2).getRevision().get()).isEqualTo(c2.name());
}
#end_block

#method_before
@Test
public void mergeOnPushToBranchWithOldPatchset() throws Exception {
    grant(Permission.PUSH, project, "refs/heads/master");
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    RevCommit c1 = r.getCommit();
    PatchSet.Id psId1 = r.getPatchSetId();
    String changeId = r.getChangeId();
    assertThat(psId1.get()).isEqualTo(1);
    r = amendChange(changeId);
    ChangeData cd = r.getChange();
    PatchSet.Id psId2 = cd.change().currentPatchSetId();
    assertThat(psId2.getParentKey()).isEqualTo(psId1.getParentKey());
    assertThat(psId2.get()).isEqualTo(2);
    testRepo.reset(c1);
    assertPushOk(pushHead(testRepo, "refs/heads/master", false), "refs/heads/master");
    cd = changeDataFactory.create(db, project, psId1.getParentKey());
    Change c = cd.change();
    assertThat(c.getStatus()).isEqualTo(Change.Status.MERGED);
    assertThat(c.currentPatchSetId()).isEqualTo(psId1);
    assertThat(cd.patchSets().stream().map(ps -> ps.getId()).collect(toList())).containsExactly(psId1, psId2);
}
#method_after
@Test
public void mergeOnPushToBranchWithOldPatchset() throws Exception {
    grant(project, "refs/heads/master", Permission.PUSH);
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    RevCommit c1 = r.getCommit();
    PatchSet.Id psId1 = r.getPatchSetId();
    String changeId = r.getChangeId();
    assertThat(psId1.get()).isEqualTo(1);
    r = amendChange(changeId);
    ChangeData cd = r.getChange();
    PatchSet.Id psId2 = cd.change().currentPatchSetId();
    assertThat(psId2.getParentKey()).isEqualTo(psId1.getParentKey());
    assertThat(psId2.get()).isEqualTo(2);
    testRepo.reset(c1);
    assertPushOk(pushHead(testRepo, "refs/heads/master", false), "refs/heads/master");
    cd = changeDataFactory.create(db, project, psId1.getParentKey());
    Change c = cd.change();
    assertThat(c.getStatus()).isEqualTo(Change.Status.MERGED);
    assertThat(c.currentPatchSetId()).isEqualTo(psId1);
    assertThat(cd.patchSets().stream().map(ps -> ps.getId()).collect(toList())).containsExactly(psId1, psId2);
}
#end_block

#method_before
@Test
public void mergeMultipleOnPushToBranchWithNewPatchset() throws Exception {
    grant(Permission.PUSH, project, "refs/heads/master");
    // Create 2 changes.
    ObjectId initialHead = getRemoteHead();
    PushOneCommit.Result r1 = createChange("Change 1", "a", "a");
    r1.assertOkStatus();
    PushOneCommit.Result r2 = createChange("Change 2", "b", "b");
    r2.assertOkStatus();
    RevCommit c1_1 = r1.getCommit();
    RevCommit c2_1 = r2.getCommit();
    PatchSet.Id psId1_1 = r1.getPatchSetId();
    PatchSet.Id psId2_1 = r2.getPatchSetId();
    assertThat(c1_1.getParent(0)).isEqualTo(initialHead);
    assertThat(c2_1.getParent(0)).isEqualTo(c1_1);
    // Amend both changes.
    testRepo.reset(initialHead);
    RevCommit c1_2 = testRepo.branch("HEAD").commit().message(c1_1.getShortMessage() + "v2").insertChangeId(r1.getChangeId().substring(1)).create();
    RevCommit c2_2 = testRepo.cherryPick(c2_1);
    // Push directly to branch.
    assertPushOk(pushHead(testRepo, "refs/heads/master", false), "refs/heads/master");
    ChangeData cd2 = r2.getChange();
    assertThat(cd2.change().getStatus()).isEqualTo(Change.Status.MERGED);
    PatchSet.Id psId2_2 = cd2.change().currentPatchSetId();
    assertThat(psId2_2.get()).isEqualTo(2);
    assertThat(cd2.patchSet(psId2_1).getRevision().get()).isEqualTo(c2_1.name());
    assertThat(cd2.patchSet(psId2_2).getRevision().get()).isEqualTo(c2_2.name());
    ChangeData cd1 = r1.getChange();
    assertThat(cd1.change().getStatus()).isEqualTo(Change.Status.MERGED);
    PatchSet.Id psId1_2 = cd1.change().currentPatchSetId();
    assertThat(psId1_2.get()).isEqualTo(2);
    assertThat(cd1.patchSet(psId1_1).getRevision().get()).isEqualTo(c1_1.name());
    assertThat(cd1.patchSet(psId1_2).getRevision().get()).isEqualTo(c1_2.name());
}
#method_after
@Test
public void mergeMultipleOnPushToBranchWithNewPatchset() throws Exception {
    grant(project, "refs/heads/master", Permission.PUSH);
    // Create 2 changes.
    ObjectId initialHead = getRemoteHead();
    PushOneCommit.Result r1 = createChange("Change 1", "a", "a");
    r1.assertOkStatus();
    PushOneCommit.Result r2 = createChange("Change 2", "b", "b");
    r2.assertOkStatus();
    RevCommit c1_1 = r1.getCommit();
    RevCommit c2_1 = r2.getCommit();
    PatchSet.Id psId1_1 = r1.getPatchSetId();
    PatchSet.Id psId2_1 = r2.getPatchSetId();
    assertThat(c1_1.getParent(0)).isEqualTo(initialHead);
    assertThat(c2_1.getParent(0)).isEqualTo(c1_1);
    // Amend both changes.
    testRepo.reset(initialHead);
    RevCommit c1_2 = testRepo.branch("HEAD").commit().message(c1_1.getShortMessage() + "v2").insertChangeId(r1.getChangeId().substring(1)).create();
    RevCommit c2_2 = testRepo.cherryPick(c2_1);
    // Push directly to branch.
    assertPushOk(pushHead(testRepo, "refs/heads/master", false), "refs/heads/master");
    ChangeData cd2 = r2.getChange();
    assertThat(cd2.change().getStatus()).isEqualTo(Change.Status.MERGED);
    PatchSet.Id psId2_2 = cd2.change().currentPatchSetId();
    assertThat(psId2_2.get()).isEqualTo(2);
    assertThat(cd2.patchSet(psId2_1).getRevision().get()).isEqualTo(c2_1.name());
    assertThat(cd2.patchSet(psId2_2).getRevision().get()).isEqualTo(c2_2.name());
    ChangeData cd1 = r1.getChange();
    assertThat(cd1.change().getStatus()).isEqualTo(Change.Status.MERGED);
    PatchSet.Id psId1_2 = cd1.change().currentPatchSetId();
    assertThat(psId1_2.get()).isEqualTo(2);
    assertThat(cd1.patchSet(psId1_1).getRevision().get()).isEqualTo(c1_1.name());
    assertThat(cd1.patchSet(psId1_2).getRevision().get()).isEqualTo(c1_2.name());
}
#end_block

#method_before
Account.Id getAccountId() {
    return id;
}
#method_after
protected Account.Id getAccountId() {
    return id;
}
#end_block

#method_before
@Test
public void notificationsOnChangeCreation() throws Exception {
    setApiUser(user);
    watch(project.get(), null);
    // check that watcher is notified
    setApiUser(admin);
    assertCreateSucceeds(newChangeInput(ChangeStatus.NEW));
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains(admin.fullName + " has uploaded this change for review.");
    // check that watcher is not notified if notify=NONE
    sender.clear();
    ChangeInput input = newChangeInput(ChangeStatus.NEW);
    input.notify = NotifyHandling.NONE;
    assertCreateSucceeds(input);
    assertThat(sender.getMessages()).isEmpty();
}
#method_after
@Test
public void notificationsOnChangeCreation() throws Exception {
    setApiUser(user);
    watch(project.get());
    // check that watcher is notified
    setApiUser(admin);
    assertCreateSucceeds(newChangeInput(ChangeStatus.NEW));
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains(admin.fullName + " has uploaded this change for review.");
    // check that watcher is not notified if notify=NONE
    sender.clear();
    ChangeInput input = newChangeInput(ChangeStatus.NEW);
    input.notify = NotifyHandling.NONE;
    assertCreateSucceeds(input);
    assertThat(sender.getMessages()).isEmpty();
}
#end_block

#method_before
private ChangeInfo assertCreateSucceeds(ChangeInput in) throws Exception {
    ChangeInfo out = gApi.changes().create(in).get();
    assertThat(out.project).isEqualTo(in.project);
    assertThat(out.branch).isEqualTo(in.branch);
    assertThat(out.subject).isEqualTo(in.subject);
    assertThat(out.topic).isEqualTo(in.topic);
    assertThat(out.status).isEqualTo(in.status);
    assertThat(out.revisions).hasSize(1);
    assertThat(out.submitted).isNull();
    return out;
}
#method_after
private ChangeInfo assertCreateSucceeds(ChangeInput in) throws Exception {
    ChangeInfo out = gApi.changes().create(in).get();
    assertThat(out.project).isEqualTo(in.project);
    assertThat(out.branch).isEqualTo(in.branch);
    assertThat(out.subject).isEqualTo(in.subject);
    assertThat(out.topic).isEqualTo(in.topic);
    assertThat(out.status).isEqualTo(in.status);
    assertThat(out.isPrivate).isEqualTo(in.isPrivate);
    assertThat(out.workInProgress).isEqualTo(in.workInProgress);
    assertThat(out.revisions).hasSize(1);
    assertThat(out.submitted).isNull();
    assertThat(in.status).isEqualTo(ChangeStatus.NEW);
    return out;
}
#end_block

#method_before
private void changeInTwoBranches(String branchA, String fileA, String branchB, String fileB) throws Exception {
    // create a initial commit in master
    Result initialCommit = pushFactory.create(db, user.getIdent(), testRepo, "initial commit", "readme.txt", "initial commit").to("refs/heads/master");
    initialCommit.assertOkStatus();
    // create two new branches
    createBranch(new Branch.NameKey(project, branchA));
    createBranch(new Branch.NameKey(project, branchB));
    // create a commit in branchA
    Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", fileA, "A content").to("refs/heads/" + branchA);
    changeA.assertOkStatus();
    // create a commit in branchB
    PushOneCommit commitB = pushFactory.create(db, user.getIdent(), testRepo, "change B", fileB, "B content");
    commitB.setParent(initialCommit.getCommit());
    Result changeB = commitB.to("refs/heads/" + branchB);
    changeB.assertOkStatus();
}
#method_after
private Map<String, Result> changeInTwoBranches(String branchA, String fileA, String branchB, String fileB) throws Exception {
    // create a initial commit in master
    Result initialCommit = pushFactory.create(db, user.getIdent(), testRepo, "initial commit", "readme.txt", "initial commit").to("refs/heads/master");
    initialCommit.assertOkStatus();
    // create two new branches
    createBranch(new Branch.NameKey(project, branchA));
    createBranch(new Branch.NameKey(project, branchB));
    // create a commit in branchA
    Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", fileA, "A content").to("refs/heads/" + branchA);
    changeA.assertOkStatus();
    // create a commit in branchB
    PushOneCommit commitB = pushFactory.create(db, user.getIdent(), testRepo, "change B", fileB, "B content");
    commitB.setParent(initialCommit.getCommit());
    Result changeB = commitB.to("refs/heads/" + branchB);
    changeB.assertOkStatus();
    return ImmutableMap.of("master", initialCommit, branchA, changeA, branchB, changeB);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    patchSetLock = Util.patchSetLock();
    cfg.getLabelSections().put(patchSetLock.getName(), patchSetLock);
    AccountGroup.UUID anonymousUsers = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel(patchSetLock.getName()), 0, 1, anonymousUsers, "refs/heads/*");
    saveProjectConfig(cfg);
    grant(Permission.LABEL + "Patch-Set-Lock", project, "refs/heads/*");
}
#method_after
@Before
public void setUp() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    patchSetLock = Util.patchSetLock();
    cfg.getLabelSections().put(patchSetLock.getName(), patchSetLock);
    AccountGroup.UUID anonymousUsers = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel(patchSetLock.getName()), 0, 1, anonymousUsers, "refs/heads/*");
    saveProjectConfig(cfg);
    grant(project, "refs/heads/*", Permission.LABEL + "Patch-Set-Lock");
}
#end_block

#method_before
@Test
@TestProjectInput(createEmptyCommit = false)
public void pushInitialCommitForMasterBranch() throws Exception {
    RevCommit c = testRepo.commit().message("Initial commit").insertChangeId().create();
    String id = GitUtil.getChangeId(testRepo, c).get();
    testRepo.reset(c);
    String r = "refs/for/master";
    PushResult pr = pushHead(testRepo, r, false);
    assertPushOk(pr, r);
    ChangeInfo change = gApi.changes().id(id).info();
    assertThat(change.branch).isEqualTo("master");
    assertThat(change.status).isEqualTo(ChangeStatus.NEW);
    try (Repository repo = repoManager.openRepository(project)) {
        assertThat(repo.resolve("master")).isNull();
    }
}
#method_after
@Test
@TestProjectInput(createEmptyCommit = false)
public void pushInitialCommitForMasterBranch() throws Exception {
    RevCommit c = testRepo.commit().message("Initial commit").insertChangeId().create();
    String id = GitUtil.getChangeId(testRepo, c).get();
    testRepo.reset(c);
    String r = "refs/for/master";
    PushResult pr = pushHead(testRepo, r, false);
    assertPushOk(pr, r);
    ChangeInfo change = gApi.changes().id(id).info();
    assertThat(change.branch).isEqualTo("master");
    assertThat(change.status).isEqualTo(ChangeStatus.NEW);
    try (Repository repo = repoManager.openRepository(project)) {
        assertThat(repo.resolve("master")).isNull();
    }
    gApi.changes().id(change.id).current().review(ReviewInput.approve());
    gApi.changes().id(change.id).current().submit();
    try (Repository repo = repoManager.openRepository(project)) {
        assertThat(repo.resolve("master")).isEqualTo(c);
    }
}
#end_block

#method_before
@Test
public void output() throws Exception {
    String url = canonicalWebUrl.get();
    ObjectId initialHead = testRepo.getRepository().resolve("HEAD");
    PushOneCommit.Result r1 = pushTo("refs/for/master");
    Change.Id id1 = r1.getChange().getId();
    r1.assertOkStatus();
    r1.assertChange(Change.Status.NEW, null);
    r1.assertMessage("New changes:\n" + "  " + url + id1 + " " + r1.getCommit().getShortMessage() + "\n");
    testRepo.reset(initialHead);
    String newMsg = r1.getCommit().getShortMessage() + " v2";
    testRepo.branch("HEAD").commit().message(newMsg).insertChangeId(r1.getChangeId().substring(1)).create();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, "another commit", "b.txt", "bbb").to("refs/for/master");
    Change.Id id2 = r2.getChange().getId();
    r2.assertOkStatus();
    r2.assertChange(Change.Status.NEW, null);
    r2.assertMessage("New changes:\n" + "  " + url + id2 + " another commit\n" + "\n" + "\n" + "Updated changes:\n" + "  " + url + id1 + " " + newMsg + "\n");
}
#method_after
@Test
public void output() throws Exception {
    String url = canonicalWebUrl.get() + "#/c/" + project.get() + "/+/";
    ObjectId initialHead = testRepo.getRepository().resolve("HEAD");
    PushOneCommit.Result r1 = pushTo("refs/for/master");
    Change.Id id1 = r1.getChange().getId();
    r1.assertOkStatus();
    r1.assertChange(Change.Status.NEW, null);
    r1.assertMessage("New changes:\n  " + url + id1 + " " + r1.getCommit().getShortMessage() + "\n");
    testRepo.reset(initialHead);
    String newMsg = r1.getCommit().getShortMessage() + " v2";
    testRepo.branch("HEAD").commit().message(newMsg).insertChangeId(r1.getChangeId().substring(1)).create();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, "another commit", "b.txt", "bbb").to("refs/for/master");
    Change.Id id2 = r2.getChange().getId();
    r2.assertOkStatus();
    r2.assertChange(Change.Status.NEW, null);
    r2.assertMessage("New changes:\n" + "  " + url + id2 + " another commit\n" + "\n" + "\n" + "Updated changes:\n" + "  " + url + id1 + " " + newMsg + "\n");
}
#end_block

#method_before
@Test
public void pushForMasterWithNotify() throws Exception {
    // create a user that watches the project
    TestAccount user3 = accounts.create("user3", "user3@example.com", "User3");
    List<ProjectWatchInfo> projectsToWatch = new ArrayList<>();
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = project.get();
    pwi.filter = "*";
    pwi.notifyNewChanges = true;
    projectsToWatch.add(pwi);
    setApiUser(user3);
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
    TestAccount user2 = accounts.user2();
    String pushSpec = "refs/for/master" + "%reviewer=" + user.email + ",cc=" + user2.email;
    sender.clear();
    PushOneCommit.Result r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE);
    r.assertOkStatus();
    assertThat(sender.getMessages()).isEmpty();
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.OWNER);
    r.assertOkStatus();
    // no email notification about own changes
    assertThat(sender.getMessages()).isEmpty();
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.OWNER_REVIEWERS);
    r.assertOkStatus();
    assertThat(sender.getMessages()).hasSize(1);
    Message m = sender.getMessages().get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.ALL);
    r.assertOkStatus();
    assertThat(sender.getMessages()).hasSize(1);
    m = sender.getMessages().get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress, user2.emailAddress, user3.emailAddress);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE + ",notify-to=" + user3.email);
    r.assertOkStatus();
    assertNotifyTo(user3);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE + ",notify-cc=" + user3.email);
    r.assertOkStatus();
    assertNotifyCc(user3);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE + ",notify-bcc=" + user3.email);
    r.assertOkStatus();
    assertNotifyBcc(user3);
    // request that sender gets notified as TO, CC and BCC, email should be sent
    // even if the sender is the only recipient
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE + ",notify-to=" + admin.email);
    assertNotifyTo(admin);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE + ",notify-cc=" + admin.email);
    r.assertOkStatus();
    assertNotifyCc(admin);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE + ",notify-bcc=" + admin.email);
    r.assertOkStatus();
    assertNotifyBcc(admin);
}
#method_after
@Test
public void pushForMasterWithNotify() throws Exception {
    // create a user that watches the project
    TestAccount user3 = accountCreator.create("user3", "user3@example.com", "User3");
    List<ProjectWatchInfo> projectsToWatch = new ArrayList<>();
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = project.get();
    pwi.filter = "*";
    pwi.notifyNewChanges = true;
    projectsToWatch.add(pwi);
    setApiUser(user3);
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
    TestAccount user2 = accountCreator.user2();
    String pushSpec = "refs/for/master%reviewer=" + user.email + ",cc=" + user2.email;
    sender.clear();
    PushOneCommit.Result r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE);
    r.assertOkStatus();
    assertThat(sender.getMessages()).isEmpty();
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.OWNER);
    r.assertOkStatus();
    // no email notification about own changes
    assertThat(sender.getMessages()).isEmpty();
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.OWNER_REVIEWERS);
    r.assertOkStatus();
    assertThat(sender.getMessages()).hasSize(1);
    Message m = sender.getMessages().get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.ALL);
    r.assertOkStatus();
    assertThat(sender.getMessages()).hasSize(1);
    m = sender.getMessages().get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress, user2.emailAddress, user3.emailAddress);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE + ",notify-to=" + user3.email);
    r.assertOkStatus();
    assertNotifyTo(user3);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE + ",notify-cc=" + user3.email);
    r.assertOkStatus();
    assertNotifyCc(user3);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE + ",notify-bcc=" + user3.email);
    r.assertOkStatus();
    assertNotifyBcc(user3);
    // request that sender gets notified as TO, CC and BCC, email should be sent
    // even if the sender is the only recipient
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE + ",notify-to=" + admin.email);
    assertNotifyTo(admin);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE + ",notify-cc=" + admin.email);
    r.assertOkStatus();
    assertNotifyCc(admin);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE + ",notify-bcc=" + admin.email);
    r.assertOkStatus();
    assertNotifyBcc(admin);
}
#end_block

#method_before
@Test
public void pushForMasterWithCc() throws Exception {
    // cc one user
    String topic = "my/topic";
    PushOneCommit.Result r = pushTo("refs/for/master/" + topic + "%cc=" + user.email);
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, topic);
    // cc several users
    TestAccount user2 = accounts.create("another-user", "another.user@example.com", "Another User");
    r = pushTo("refs/for/master/" + topic + "%cc=" + admin.email + ",cc=" + user.email + ",cc=" + user2.email);
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, topic);
    // cc non-existing user
    String nonExistingEmail = "non.existing@example.com";
    r = pushTo("refs/for/master/" + topic + "%cc=" + admin.email + ",cc=" + nonExistingEmail + ",cc=" + user.email);
    r.assertErrorStatus("user \"" + nonExistingEmail + "\" not found");
}
#method_after
@Test
public void pushForMasterWithCc() throws Exception {
    // cc one user
    String topic = "my/topic";
    PushOneCommit.Result r = pushTo("refs/for/master/" + topic + "%cc=" + user.email);
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, topic, ImmutableList.of(), ImmutableList.of(user));
    // cc several users
    r = pushTo("refs/for/master/" + topic + "%cc=" + admin.email + ",cc=" + user.email + ",cc=" + accountCreator.user2().email);
    r.assertOkStatus();
    // Check that admin isn't CC'd as they own the change
    r.assertChange(Change.Status.NEW, topic, ImmutableList.of(), ImmutableList.of(user, accountCreator.user2()));
    // cc non-existing user
    String nonExistingEmail = "non.existing@example.com";
    r = pushTo("refs/for/master/" + topic + "%cc=" + admin.email + ",cc=" + nonExistingEmail + ",cc=" + user.email);
    r.assertErrorStatus("user \"" + nonExistingEmail + "\" not found");
}
#end_block

#method_before
@Test
public void pushForMasterWithReviewer() throws Exception {
    // add one reviewer
    String topic = "my/topic";
    PushOneCommit.Result r = pushTo("refs/for/master/" + topic + "%r=" + user.email);
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, topic, user);
    // add several reviewers
    TestAccount user2 = accounts.create("another-user", "another.user@example.com", "Another User");
    r = pushTo("refs/for/master/" + topic + "%r=" + admin.email + ",r=" + user.email + ",r=" + user2.email);
    r.assertOkStatus();
    // admin is the owner of the change and should not appear as reviewer
    r.assertChange(Change.Status.NEW, topic, user, user2);
    // add non-existing user as reviewer
    String nonExistingEmail = "non.existing@example.com";
    r = pushTo("refs/for/master/" + topic + "%r=" + admin.email + ",r=" + nonExistingEmail + ",r=" + user.email);
    r.assertErrorStatus("user \"" + nonExistingEmail + "\" not found");
}
#method_after
@Test
public void pushForMasterWithReviewer() throws Exception {
    // add one reviewer
    String topic = "my/topic";
    PushOneCommit.Result r = pushTo("refs/for/master/" + topic + "%r=" + user.email);
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, topic, user);
    // add several reviewers
    TestAccount user2 = accountCreator.create("another-user", "another.user@example.com", "Another User");
    r = pushTo("refs/for/master/" + topic + "%r=" + admin.email + ",r=" + user.email + ",r=" + user2.email);
    r.assertOkStatus();
    // admin is the owner of the change and should not appear as reviewer
    r.assertChange(Change.Status.NEW, topic, user, user2);
    // add non-existing user as reviewer
    String nonExistingEmail = "non.existing@example.com";
    r = pushTo("refs/for/master/" + topic + "%r=" + admin.email + ",r=" + nonExistingEmail + ",r=" + user.email);
    r.assertErrorStatus("user \"" + nonExistingEmail + "\" not found");
}
#end_block

#method_before
@Test
public void pushForMasterAsEdit() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    Optional<EditInfo> edit = getEdit(r.getChangeId());
    assertThat(edit).isAbsent();
    // specify edit as option
    r = amendChange(r.getChangeId(), "refs/for/master%edit");
    r.assertOkStatus();
    edit = getEdit(r.getChangeId());
    assertThat(edit).isPresent();
    EditInfo editInfo = edit.get();
    r.assertMessage("Updated Changes:\n  " + canonicalWebUrl.get() + r.getChange().getId() + " " + editInfo.commit.subject + " [EDIT]\n");
}
#method_after
@Test
public void pushForMasterAsEdit() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    Optional<EditInfo> edit = getEdit(r.getChangeId());
    assertThat(edit).isAbsent();
    assertThat(query("has:edit")).isEmpty();
    // specify edit as option
    r = amendChange(r.getChangeId(), "refs/for/master%edit");
    r.assertOkStatus();
    edit = getEdit(r.getChangeId());
    assertThat(edit).isPresent();
    EditInfo editInfo = edit.get();
    r.assertMessage("Updated Changes:\n  " + canonicalWebUrl.get() + "#/c/" + project.get() + "/+/" + r.getChange().getId() + " " + editInfo.commit.subject + " [EDIT]\n");
    // verify that the re-indexing was triggered for the change
    assertThat(query("has:edit")).hasSize(1);
}
#end_block

#method_before
@Test
public void pushForMasterWithMessageTwiceWithDifferentMessages() throws Exception {
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    config.getProject().setCreateNewChangeForAllNotInTarget(InheritableBoolean.TRUE);
    saveProjectConfig(project, config);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content");
    PushOneCommit.Result r = push.to("refs/for/master/%m=my_test_message");
    r.assertOkStatus();
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%m=new_test_message");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId());
    Collection<RevisionInfo> revisions = ci.revisions.values();
    assertThat(revisions).hasSize(2);
    for (RevisionInfo ri : revisions) {
        if (ri.isCurrent) {
            assertThat(ri.description).isEqualTo("new test message");
        } else {
            assertThat(ri.description).isEqualTo("my test message");
        }
    }
}
#method_after
@Test
public void pushForMasterWithMessageTwiceWithDifferentMessages() throws Exception {
    enableCreateNewChangeForAllNotInTarget();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content");
    PushOneCommit.Result r = push.to("refs/for/master/%m=my_test_message");
    r.assertOkStatus();
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%m=new_test_message");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId());
    Collection<RevisionInfo> revisions = ci.revisions.values();
    assertThat(revisions).hasSize(2);
    for (RevisionInfo ri : revisions) {
        if (ri.isCurrent) {
            assertThat(ri.description).isEqualTo("new test message");
        } else {
            assertThat(ri.description).isEqualTo("my test message");
        }
    }
}
#end_block

#method_before
@Test
public void pushForMasterWithApprovals() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%l=Code-Review");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(1);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId());
    cr = ci.labels.get("Code-Review");
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2.");
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(2);
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "c.txt", "moreContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId());
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 3.");
}
#method_after
@Test
public void pushForMasterWithApprovals() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%l=Code-Review");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(1);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId());
    cr = ci.labels.get("Code-Review");
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(2);
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "c.txt", "moreContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId());
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 3.");
}
#end_block

#method_before
@Test
public void pushForMasterWithApprovalsForgeCommitterButNoForgeVote() throws Exception {
    // Create a commit with "User" as author and committer
    RevCommit c = commitBuilder().author(user.getIdent()).committer(user.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    // Push this commit as "Administrator" (requires Forge Committer Identity)
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1", false);
    // Expected Code-Review votes:
    // 1. 0 from User (committer):
    // When the committer is forged, the committer is automatically added as
    // reviewer, hence we expect a dummy 0 vote for the committer.
    // 2. +1 from Administrator (uploader):
    // On push Code-Review+1 was specified, hence we expect a +1 vote from
    // the uploader.
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(2);
    int indexAdmin = admin.fullName.equals(cr.all.get(0).name) ? 0 : 1;
    int indexUser = indexAdmin == 0 ? 1 : 0;
    assertThat(cr.all.get(indexAdmin).name).isEqualTo(admin.fullName);
    assertThat(cr.all.get(indexAdmin).value.intValue()).isEqualTo(1);
    assertThat(cr.all.get(indexUser).name).isEqualTo(user.fullName);
    assertThat(cr.all.get(indexUser).value.intValue()).isEqualTo(0);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
}
#method_after
@Test
public void pushForMasterWithApprovalsForgeCommitterButNoForgeVote() throws Exception {
    // Create a commit with "User" as author and committer
    RevCommit c = commitBuilder().author(user.getIdent()).committer(user.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    // Push this commit as "Administrator" (requires Forge Committer Identity)
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1", false);
    // Expected Code-Review votes:
    // 1. 0 from User (committer):
    // When the committer is forged, the committer is automatically added as
    // reviewer, hence we expect a dummy 0 vote for the committer.
    // 2. +1 from Administrator (uploader):
    // On push Code-Review+1 was specified, hence we expect a +1 vote from
    // the uploader.
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(2);
    int indexAdmin = admin.fullName.equals(cr.all.get(0).name) ? 0 : 1;
    int indexUser = indexAdmin == 0 ? 1 : 0;
    assertThat(cr.all.get(indexAdmin).name).isEqualTo(admin.fullName);
    assertThat(cr.all.get(indexAdmin).value.intValue()).isEqualTo(1);
    assertThat(cr.all.get(indexUser).name).isEqualTo(user.fullName);
    assertThat(cr.all.get(indexUser).value.intValue()).isEqualTo(0);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
}
#end_block

#method_before
@Test
public void pushWithMultipleApprovals() throws Exception {
    LabelType Q = category("Custom-Label", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID anon = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    String heads = "refs/heads/*";
    Util.allow(config, Permission.forLabel("Custom-Label"), -1, 1, anon, heads);
    config.getLabelSections().put(Q.getName(), Q);
    saveProjectConfig(project, config);
    RevCommit c = commitBuilder().author(admin.getIdent()).committer(admin.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1,l=Custom-Label-1", false);
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    cr = ci.labels.get("Custom-Label");
    assertThat(cr.all).hasSize(1);
}
#method_after
@Test
public void pushWithMultipleApprovals() throws Exception {
    LabelType Q = category("Custom-Label", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID anon = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    String heads = "refs/heads/*";
    Util.allow(config, Permission.forLabel("Custom-Label"), -1, 1, anon, heads);
    config.getLabelSections().put(Q.getName(), Q);
    saveProjectConfig(project, config);
    RevCommit c = commitBuilder().author(admin.getIdent()).committer(admin.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1,l=Custom-Label-1", false);
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    cr = ci.labels.get("Custom-Label");
    assertThat(cr.all).hasSize(1);
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
}
#end_block

#method_before
@Test
public void pushNewPatchsetToPatchSetLockedChange() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    revision(r).review(new ReviewInput().label("Patch-Set-Lock", 1));
    r = push.to("refs/for/master");
    r.assertErrorStatus("cannot add patch set to " + r.getChange().change().getChangeId() + ". Change is patch set locked.");
}
#method_after
@Test
public void pushNewPatchsetToPatchSetLockedChange() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    revision(r).review(new ReviewInput().label("Patch-Set-Lock", 1));
    r = push.to("refs/for/master");
    r.assertErrorStatus("cannot add patch set to " + r.getChange().change().getChangeId() + ".");
}
#end_block

#method_before
@Test
public void pushSameCommitTwiceUsingMagicBranchBaseOption() throws Exception {
    grant(Permission.PUSH, project, "refs/heads/master");
    PushOneCommit.Result rBase = pushTo("refs/heads/master");
    rBase.assertOkStatus();
    gApi.projects().name(project.get()).branch("foo").create(new BranchInput());
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent");
    PushOneCommit.Result r = push.to("refs/for/master");
    r.assertOkStatus();
    PushResult pr = GitUtil.pushHead(testRepo, "refs/for/foo%base=" + rBase.getCommit().name(), false, false);
    assertThat(pr.getMessages()).contains("changes: new: 1, refs: 1, done");
    assertTwoChangesWithSameRevision(r);
}
#method_after
@Test
public void pushSameCommitTwiceUsingMagicBranchBaseOption() throws Exception {
    grant(project, "refs/heads/master", Permission.PUSH);
    PushOneCommit.Result rBase = pushTo("refs/heads/master");
    rBase.assertOkStatus();
    gApi.projects().name(project.get()).branch("foo").create(new BranchInput());
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent");
    PushOneCommit.Result r = push.to("refs/for/master");
    r.assertOkStatus();
    PushResult pr = GitUtil.pushHead(testRepo, "refs/for/foo%base=" + rBase.getCommit().name(), false, false);
    // BatchUpdate implementations differ in how they hook into progress monitors. We mostly just
    // care that there is a new change.
    assertThat(pr.getMessages()).containsMatch("changes: new: 1,( refs: 1)? done");
    assertTwoChangesWithSameRevision(r);
}
#end_block

#method_before
@Test
public void pushAFewChanges() throws Exception {
    int n = 10;
    String r = "refs/for/master";
    ObjectId initialHead = testRepo.getRepository().resolve("HEAD");
    List<RevCommit> commits = createChanges(n, r);
    // Check that a change was created for each.
    for (RevCommit c : commits) {
        assertThat(byCommit(c).change().getSubject()).named("change for " + c.name()).isEqualTo(c.getShortMessage());
    }
    List<RevCommit> commits2 = amendChanges(initialHead, commits, r);
    // Check that there are correct patch sets.
    for (int i = 0; i < n; i++) {
        RevCommit c = commits.get(i);
        RevCommit c2 = commits2.get(i);
        String name = "change for " + c2.name();
        ChangeData cd = byCommit(c);
        assertThat(cd.change().getSubject()).named(name).isEqualTo(c2.getShortMessage());
        assertThat(getPatchSetRevisions(cd)).named(name).containsExactlyEntriesIn(ImmutableMap.of(1, c.name(), 2, c2.name()));
    }
    // Pushing again results in "no new changes".
    assertPushRejected(pushHead(testRepo, r, false), r, "no new changes");
}
#method_after
@Test
public void pushAFewChanges() throws Exception {
    testPushAFewChanges();
}
#end_block

#method_before
private void testPushWithoutChangeId() throws Exception {
    RevCommit c = createCommit(testRepo, "Message without Change-Id");
    assertThat(GitUtil.getChangeId(testRepo, c).isPresent()).isFalse();
    pushForReviewRejected(testRepo, "missing Change-Id in commit message footer");
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    config.getProject().setRequireChangeID(InheritableBoolean.FALSE);
    saveProjectConfig(project, config);
    pushForReviewOk(testRepo);
}
#method_after
private void testPushWithoutChangeId() throws Exception {
    RevCommit c = createCommit(testRepo, "Message without Change-Id");
    assertThat(GitUtil.getChangeId(testRepo, c)).isEmpty();
    pushForReviewRejected(testRepo, "missing Change-Id in commit message footer");
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    config.getProject().setRequireChangeID(InheritableBoolean.FALSE);
    saveProjectConfig(project, config);
    pushForReviewOk(testRepo);
}
#end_block

#method_before
private void testpushWithInvalidChangeId() throws Exception {
    createCommit(testRepo, "Message with invalid Change-Id\n" + "\n" + "Change-Id: X\n");
    pushForReviewRejected(testRepo, "invalid Change-Id line format in commit message footer");
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    config.getProject().setRequireChangeID(InheritableBoolean.FALSE);
    saveProjectConfig(project, config);
    pushForReviewRejected(testRepo, "invalid Change-Id line format in commit message footer");
}
#method_after
private void testpushWithInvalidChangeId() throws Exception {
    createCommit(testRepo, "Message with invalid Change-Id\n\nChange-Id: X\n");
    pushForReviewRejected(testRepo, "invalid Change-Id line format in commit message footer");
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    config.getProject().setRequireChangeID(InheritableBoolean.FALSE);
    saveProjectConfig(project, config);
    pushForReviewRejected(testRepo, "invalid Change-Id line format in commit message footer");
}
#end_block

#method_before
@Test
public void createChangeForMergedCommit() throws Exception {
    String master = "refs/heads/master";
    grant(Permission.PUSH, project, master, true);
    // Update master with a direct push.
    RevCommit c1 = testRepo.commit().message("Non-change 1").create();
    RevCommit c2 = testRepo.parseBody(testRepo.commit().parent(c1).message("Non-change 2").insertChangeId().create());
    String changeId = Iterables.getOnlyElement(c2.getFooterLines(CHANGE_ID));
    testRepo.reset(c2);
    assertPushOk(pushHead(testRepo, master, false, true), master);
    String q = "commit:" + c1.name() + " OR commit:" + c2.name() + " OR change:" + changeId;
    assertThat(gApi.changes().query(q).get()).isEmpty();
    // Push c2 as a merged change.
    String r = "refs/for/master%merged";
    assertPushOk(pushHead(testRepo, r, false), r);
    EnumSet<ListChangesOption> opts = EnumSet.of(ListChangesOption.CURRENT_REVISION);
    ChangeInfo info = gApi.changes().id(changeId).get(opts);
    assertThat(info.currentRevision).isEqualTo(c2.name());
    assertThat(info.status).isEqualTo(ChangeStatus.MERGED);
    // Only c2 was created as a change.
    String q1 = "commit: " + c1.name();
    assertThat(gApi.changes().query(q1).get()).isEmpty();
    // Push c1 as a merged change.
    testRepo.reset(c1);
    assertPushOk(pushHead(testRepo, r, false), r);
    List<ChangeInfo> infos = gApi.changes().query(q1).withOptions(opts).get();
    assertThat(infos).hasSize(1);
    info = infos.get(0);
    assertThat(info.currentRevision).isEqualTo(c1.name());
    assertThat(info.status).isEqualTo(ChangeStatus.MERGED);
}
#method_after
@Test
public void createChangeForMergedCommit() throws Exception {
    String master = "refs/heads/master";
    grant(project, master, Permission.PUSH, true);
    // Update master with a direct push.
    RevCommit c1 = testRepo.commit().message("Non-change 1").create();
    RevCommit c2 = testRepo.parseBody(testRepo.commit().parent(c1).message("Non-change 2").insertChangeId().create());
    String changeId = Iterables.getOnlyElement(c2.getFooterLines(CHANGE_ID));
    testRepo.reset(c2);
    assertPushOk(pushHead(testRepo, master, false, true), master);
    String q = "commit:" + c1.name() + " OR commit:" + c2.name() + " OR change:" + changeId;
    assertThat(gApi.changes().query(q).get()).isEmpty();
    // Push c2 as a merged change.
    String r = "refs/for/master%merged";
    assertPushOk(pushHead(testRepo, r, false), r);
    EnumSet<ListChangesOption> opts = EnumSet.of(ListChangesOption.CURRENT_REVISION);
    ChangeInfo info = gApi.changes().id(changeId).get(opts);
    assertThat(info.currentRevision).isEqualTo(c2.name());
    assertThat(info.status).isEqualTo(ChangeStatus.MERGED);
    // Only c2 was created as a change.
    String q1 = "commit: " + c1.name();
    assertThat(gApi.changes().query(q1).get()).isEmpty();
    // Push c1 as a merged change.
    testRepo.reset(c1);
    assertPushOk(pushHead(testRepo, r, false), r);
    List<ChangeInfo> infos = gApi.changes().query(q1).withOptions(opts).get();
    assertThat(infos).hasSize(1);
    info = infos.get(0);
    assertThat(info.currentRevision).isEqualTo(c1.name());
    assertThat(info.status).isEqualTo(ChangeStatus.MERGED);
}
#end_block

#method_before
@Test
public void mergedOptionWithExistingChangeInsertsPatchSet() throws Exception {
    String master = "refs/heads/master";
    grant(Permission.PUSH, project, master, true);
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    ObjectId c1 = r.getCommit().copy();
    // Create a PS2 commit directly on master in the server's repo. This
    // simulates the client amending locally and pushing directly to the branch,
    // expecting the change to be auto-closed, but the change metadata update
    // fails.
    ObjectId c2;
    try (Repository repo = repoManager.openRepository(project)) {
        TestRepository<?> tr = new TestRepository<>(repo);
        RevCommit commit2 = tr.amend(c1).message("New subject").insertChangeId(r.getChangeId().substring(1)).create();
        c2 = commit2.copy();
        tr.update(master, c2);
    }
    testRepo.git().fetch().setRefSpecs(new RefSpec("refs/heads/master")).call();
    testRepo.reset(c2);
    String ref = "refs/for/master%merged";
    assertPushOk(pushHead(testRepo, ref, false), ref);
    EnumSet<ListChangesOption> opts = EnumSet.of(ListChangesOption.ALL_REVISIONS);
    ChangeInfo info = gApi.changes().id(r.getChangeId()).get(opts);
    assertThat(info.currentRevision).isEqualTo(c2.name());
    assertThat(info.revisions.keySet()).containsExactly(c1.name(), c2.name());
    // TODO(dborowitz): Fix ReceiveCommits to also auto-close the change.
    assertThat(info.status).isEqualTo(ChangeStatus.NEW);
}
#method_after
@Test
public void mergedOptionWithExistingChangeInsertsPatchSet() throws Exception {
    String master = "refs/heads/master";
    grant(project, master, Permission.PUSH, true);
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    ObjectId c1 = r.getCommit().copy();
    // Create a PS2 commit directly on master in the server's repo. This
    // simulates the client amending locally and pushing directly to the branch,
    // expecting the change to be auto-closed, but the change metadata update
    // fails.
    ObjectId c2;
    try (Repository repo = repoManager.openRepository(project)) {
        TestRepository<?> tr = new TestRepository<>(repo);
        RevCommit commit2 = tr.amend(c1).message("New subject").insertChangeId(r.getChangeId().substring(1)).create();
        c2 = commit2.copy();
        tr.update(master, c2);
    }
    testRepo.git().fetch().setRefSpecs(new RefSpec("refs/heads/master")).call();
    testRepo.reset(c2);
    String ref = "refs/for/master%merged";
    assertPushOk(pushHead(testRepo, ref, false), ref);
    ChangeInfo info = gApi.changes().id(r.getChangeId()).get(ALL_REVISIONS);
    assertThat(info.currentRevision).isEqualTo(c2.name());
    assertThat(info.revisions.keySet()).containsExactly(c1.name(), c2.name());
    // TODO(dborowitz): Fix ReceiveCommits to also auto-close the change.
    assertThat(info.status).isEqualTo(ChangeStatus.NEW);
}
#end_block

#method_before
private List<RevCommit> createChanges(int n, String refsFor) throws Exception {
    return createChanges(n, refsFor, ImmutableList.<String>of());
}
#method_after
private List<RevCommit> createChanges(int n, String refsFor) throws Exception {
    return createChanges(n, refsFor, ImmutableList.of());
}
#end_block

#method_before
private List<RevCommit> createChanges(int n, String refsFor, List<String> footerLines) throws Exception {
    List<RevCommit> commits = new ArrayList<>(n);
    for (int i = 1; i <= n; i++) {
        String msg = "Change " + i;
        if (!footerLines.isEmpty()) {
            StringBuilder sb = new StringBuilder(msg).append("\n\n");
            for (String line : footerLines) {
                sb.append(line).append('\n');
            }
            msg = sb.toString();
        }
        TestRepository<?>.CommitBuilder cb = testRepo.branch("HEAD").commit().message(msg).insertChangeId();
        if (!commits.isEmpty()) {
            cb.parent(commits.get(commits.size() - 1));
        }
        RevCommit c = cb.create();
        testRepo.getRevWalk().parseBody(c);
        commits.add(c);
    }
    assertPushOk(pushHead(testRepo, refsFor, false), refsFor);
    return commits;
}
#method_after
private List<RevCommit> createChanges(int n, String refsFor, List<String> footerLines) throws Exception {
    List<RevCommit> commits = initChanges(n, footerLines);
    assertPushOk(pushHead(testRepo, refsFor, false), refsFor);
    return commits;
}
#end_block

#method_before
@Override
public List<SubmitStrategyOp> buildOps(Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = sort(toMerge);
    List<SubmitStrategyOp> ops = new ArrayList<>(sorted.size());
    boolean first = true;
    for (CodeReviewCommit c : sorted) {
        if (c.getParentCount() > 1) {
            // Since there is a merge commit, sort and prune again using
            // MERGE_IF_NECESSARY semantics to avoid creating duplicate
            // commits.
            // 
            sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, sorted, args.incoming);
            break;
        }
    }
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        if (first && args.mergeTip.getInitialTip() == null) {
            // TODO(tandrii): Cherry-Pick strategy does this too, but it's wrong
            // and can be fixed.
            ops.add(new FastForwardOp(args, n));
        } else if (n.getParentCount() == 0) {
            ops.add(new RebaseRootOp(n));
        } else if (n.getParentCount() == 1) {
            ops.add(new RebaseOneOp(n));
        } else {
            ops.add(new RebaseMultipleParentsOp(n));
        }
        first = false;
    }
    return ops;
}
#method_after
@Override
public List<SubmitStrategyOp> buildOps(Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted;
    try {
        sorted = args.rebaseSorter.sort(toMerge);
    } catch (IOException e) {
        throw new IntegrationException("Commit sorting failed", e);
    }
    List<SubmitStrategyOp> ops = new ArrayList<>(sorted.size());
    boolean first = true;
    for (CodeReviewCommit c : sorted) {
        if (c.getParentCount() > 1) {
            // Since there is a merge commit, sort and prune again using
            // MERGE_IF_NECESSARY semantics to avoid creating duplicate
            // commits.
            // 
            sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, sorted);
            break;
        }
    }
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        if (first && args.mergeTip.getInitialTip() == null) {
            // TODO(tandrii): Cherry-Pick strategy does this too, but it's wrong
            // and can be fixed.
            ops.add(new FastForwardOp(args, n));
        } else if (n.getParentCount() == 0) {
            ops.add(new RebaseRootOp(n));
        } else if (n.getParentCount() == 1) {
            ops.add(new RebaseOneOp(n));
        } else {
            ops.add(new RebaseMultipleParentsOp(n));
        }
        first = false;
    }
    return ops;
}
#end_block

#method_before
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, InvalidChangeOperationException, RestApiException, IOException, OrmException {
    // BatchUpdate how to produce CodeReviewRevWalks.
    if (args.mergeUtil.canFastForward(args.mergeSorter, args.mergeTip.getCurrentTip(), args.rw, toMerge)) {
        if (!rebaseAlways) {
            args.mergeTip.moveTipTo(amendGitlink(toMerge), toMerge);
            toMerge.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
            acceptMergeTip(args.mergeTip);
            return;
        }
        // RebaseAlways means we modify commit message.
        args.rw.parseBody(toMerge);
        newPatchSetId = ChangeUtil.nextPatchSetId(args.repo, toMerge.change().currentPatchSetId());
        RevCommit mergeTip = args.mergeTip.getCurrentTip();
        args.rw.parseBody(mergeTip);
        String cherryPickCmtMsg = args.mergeUtil.createCommitMessageOnSubmit(toMerge, mergeTip);
        PersonIdent committer = args.caller.newCommitterIdent(ctx.getWhen(), args.serverIdent.getTimeZone());
        try {
            newCommit = args.mergeUtil.createCherryPickFromCommit(args.repo, args.inserter, args.mergeTip.getCurrentTip(), toMerge, committer, cherryPickCmtMsg, args.rw, 0, true);
        } catch (MergeConflictException mce) {
            // Unlike in Cherry-pick case, this should never happen.
            toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
            throw new IllegalStateException("MergeConflictException on message edit must not happen");
        } catch (MergeIdenticalTreeException mie) {
            // this should not happen
            toMerge.setStatusCode(SKIPPED_IDENTICAL_TREE);
            return;
        }
        ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSetId.toRefName()));
    } else {
        // Stale read of patch set is ok; see comments in RebaseChangeOp.
        PatchSet origPs = args.psUtil.get(ctx.getDb(), toMerge.getControl().getNotes(), toMerge.getPatchsetId());
        rebaseOp = args.rebaseFactory.create(toMerge.getControl(), origPs, args.mergeTip.getCurrentTip().name()).setFireRevisionCreated(false).setCopyApprovals(false).setValidatePolicy(CommitValidators.Policy.NONE).setCheckAddPatchSetPermission(false).setDetailedCommitMessage(rebaseAlways).setPostMessage(false);
        try {
            rebaseOp.updateRepo(ctx);
        } catch (MergeConflictException | NoSuchChangeException e) {
            toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
            throw new IntegrationException("Cannot rebase " + toMerge.name() + ": " + e.getMessage(), e);
        }
        newCommit = args.rw.parseCommit(rebaseOp.getRebasedCommit());
        newPatchSetId = rebaseOp.getPatchSetId();
    }
    newCommit = amendGitlink(newCommit);
    newCommit.copyFrom(toMerge);
    newCommit.setPatchsetId(newPatchSetId);
    newCommit.setStatusCode(CommitMergeStatus.CLEAN_REBASE);
    args.mergeTip.moveTipTo(newCommit, newCommit);
    args.commitStatus.put(args.mergeTip.getCurrentTip());
    acceptMergeTip(args.mergeTip);
}
#method_after
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, InvalidChangeOperationException, RestApiException, IOException, OrmException, PermissionBackendException {
    if (args.mergeUtil.canFastForward(args.mergeSorter, args.mergeTip.getCurrentTip(), args.rw, toMerge)) {
        if (!rebaseAlways) {
            args.mergeTip.moveTipTo(amendGitlink(toMerge), toMerge);
            toMerge.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
            acceptMergeTip(args.mergeTip);
            return;
        }
        // RebaseAlways means we modify commit message.
        args.rw.parseBody(toMerge);
        newPatchSetId = ChangeUtil.nextPatchSetIdFromChangeRefsMap(ctx.getRepoView().getRefs(getId().toRefPrefix()), toMerge.change().currentPatchSetId());
        RevCommit mergeTip = args.mergeTip.getCurrentTip();
        args.rw.parseBody(mergeTip);
        String cherryPickCmtMsg = args.mergeUtil.createCommitMessageOnSubmit(toMerge, mergeTip);
        PersonIdent committer = args.caller.newCommitterIdent(ctx.getWhen(), args.serverIdent.getTimeZone());
        try {
            newCommit = args.mergeUtil.createCherryPickFromCommit(ctx.getInserter(), ctx.getRepoView().getConfig(), args.mergeTip.getCurrentTip(), toMerge, committer, cherryPickCmtMsg, args.rw, 0, true);
        } catch (MergeConflictException mce) {
            // Unlike in Cherry-pick case, this should never happen.
            toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
            throw new IllegalStateException("MergeConflictException on message edit must not happen");
        } catch (MergeIdenticalTreeException mie) {
            // this should not happen
            toMerge.setStatusCode(SKIPPED_IDENTICAL_TREE);
            return;
        }
        ctx.addRefUpdate(ObjectId.zeroId(), newCommit, newPatchSetId.toRefName());
    } else {
        // Stale read of patch set is ok; see comments in RebaseChangeOp.
        PatchSet origPs = args.psUtil.get(ctx.getDb(), toMerge.getNotes(), toMerge.getPatchsetId());
        rebaseOp = args.rebaseFactory.create(toMerge.notes(), origPs, args.mergeTip.getCurrentTip()).setFireRevisionCreated(false).setCopyApprovals(false).setValidate(false).setCheckAddPatchSetPermission(false).setDetailedCommitMessage(rebaseAlways).setPostMessage(false).setMatchAuthorToCommitterDate(args.project.isMatchAuthorToCommitterDate());
        try {
            rebaseOp.updateRepo(ctx);
        } catch (MergeConflictException | NoSuchChangeException e) {
            toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
            throw new IntegrationException("Cannot rebase " + toMerge.name() + ": " + e.getMessage(), e);
        }
        newCommit = args.rw.parseCommit(rebaseOp.getRebasedCommit());
        newPatchSetId = rebaseOp.getPatchSetId();
    }
    newCommit = amendGitlink(newCommit);
    newCommit.copyFrom(toMerge);
    newCommit.setPatchsetId(newPatchSetId);
    newCommit.setStatusCode(CommitMergeStatus.CLEAN_REBASE);
    args.mergeTip.moveTipTo(newCommit, newCommit);
    args.commitStatus.put(args.mergeTip.getCurrentTip());
    acceptMergeTip(args.mergeTip);
}
#end_block

#method_before
@Override
public PatchSet updateChangeImpl(ChangeContext ctx) throws NoSuchChangeException, ResourceConflictException, OrmException, IOException {
    if (newCommit == null) {
        checkState(!rebaseAlways, "RebaseAlways must never fast forward");
        // otherwise, took the fast-forward option, nothing to do.
        return null;
    }
    PatchSet newPs;
    if (rebaseOp != null) {
        rebaseOp.updateChange(ctx);
        newPs = rebaseOp.getPatchSet();
    } else {
        // CherryPick
        PatchSet prevPs = args.psUtil.current(ctx.getDb(), ctx.getNotes());
        newPs = args.psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(newPatchSetId), newPatchSetId, newCommit, prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of(), null, null);
    }
    ctx.getChange().setCurrentPatchSet(args.patchSetInfoFactory.get(ctx.getRevWalk(), newCommit, newPatchSetId));
    newCommit.setControl(ctx.getControl());
    return newPs;
}
#method_after
@Override
public PatchSet updateChangeImpl(ChangeContext ctx) throws NoSuchChangeException, ResourceConflictException, OrmException, IOException {
    if (newCommit == null) {
        checkState(!rebaseAlways, "RebaseAlways must never fast forward");
        // otherwise, took the fast-forward option, nothing to do.
        return null;
    }
    PatchSet newPs;
    if (rebaseOp != null) {
        rebaseOp.updateChange(ctx);
        newPs = rebaseOp.getPatchSet();
    } else {
        // CherryPick
        PatchSet prevPs = args.psUtil.current(ctx.getDb(), ctx.getNotes());
        newPs = args.psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(newPatchSetId), newPatchSetId, newCommit, prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of(), null, null);
    }
    ctx.getChange().setCurrentPatchSet(args.patchSetInfoFactory.get(ctx.getRevWalk(), newCommit, newPatchSetId));
    newCommit.setNotes(ctx.getNotes());
    return newPs;
}
#end_block

#method_before
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    // There are multiple parents, so this is a merge commit. We don't want
    // to rebase the merge as clients can't easily rebase their history with
    // that merge present and replaced by an equivalent merge with a different
    // first parent. So instead behave as though MERGE_IF_NECESSARY was
    // configured.
    // TODO(tandrii): this is not in spirit of RebaseAlways strategy because
    // the commit messages can not be modified in the process. It's also
    // possible to implement rebasing of merge commits. E.g., the Cherry Pick
    // REST endpoint already supports cherry-picking of merge commits.
    // For now, users of RebaseAlways strategy for whom changed commit footers
    // are important would be well advised to prohibit uploading patches with
    // merge commits.
    MergeTip mergeTip = args.mergeTip;
    if (args.rw.isMergedInto(mergeTip.getCurrentTip(), toMerge) && !args.submoduleOp.hasSubscription(args.destBranch)) {
        mergeTip.moveTipTo(toMerge, toMerge);
    } else {
        CodeReviewCommit newTip = args.mergeUtil.mergeOneCommit(args.serverIdent, args.serverIdent, args.repo, args.rw, args.inserter, args.destBranch, mergeTip.getCurrentTip(), toMerge);
        mergeTip.moveTipTo(amendGitlink(newTip), toMerge);
    }
    args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted);
    acceptMergeTip(mergeTip);
}
#method_after
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    // There are multiple parents, so this is a merge commit. We don't want
    // to rebase the merge as clients can't easily rebase their history with
    // that merge present and replaced by an equivalent merge with a different
    // first parent. So instead behave as though MERGE_IF_NECESSARY was
    // configured.
    // TODO(tandrii): this is not in spirit of RebaseAlways strategy because
    // the commit messages can not be modified in the process. It's also
    // possible to implement rebasing of merge commits. E.g., the Cherry Pick
    // REST endpoint already supports cherry-picking of merge commits.
    // For now, users of RebaseAlways strategy for whom changed commit footers
    // are important would be well advised to prohibit uploading patches with
    // merge commits.
    MergeTip mergeTip = args.mergeTip;
    if (args.rw.isMergedInto(mergeTip.getCurrentTip(), toMerge) && !args.submoduleOp.hasSubscription(args.destBranch)) {
        mergeTip.moveTipTo(toMerge, toMerge);
    } else {
        PersonIdent caller = ctx.getIdentifiedUser().newCommitterIdent(ctx.getWhen(), ctx.getTimeZone());
        CodeReviewCommit newTip = args.mergeUtil.mergeOneCommit(caller, caller, args.rw, ctx.getInserter(), ctx.getRepoView().getConfig(), args.destBranch, mergeTip.getCurrentTip(), toMerge);
        mergeTip.moveTipTo(amendGitlink(newTip), toMerge);
    }
    args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted);
    acceptMergeTip(mergeTip);
}
#end_block

#method_before
static boolean dryRun(SubmitDryRun.Arguments args, CodeReviewCommit mergeTip, CodeReviewCommit toMerge) throws IntegrationException {
    // on commit chains.
    return !args.mergeUtil.hasMissingDependencies(args.mergeSorter, toMerge) && args.mergeUtil.canMerge(args.mergeSorter, args.repo, mergeTip, toMerge);
}
#method_after
static boolean dryRun(SubmitDryRun.Arguments args, Repository repo, CodeReviewCommit mergeTip, CodeReviewCommit toMerge) throws IntegrationException {
    // on commit chains.
    return !args.mergeUtil.hasMissingDependencies(args.mergeSorter, toMerge) && args.mergeUtil.canMerge(args.mergeSorter, repo, mergeTip, toMerge);
}
#end_block

#method_before
@Override
public RevisionResource parse(ChangeResource change, IdString id) throws ResourceNotFoundException, AuthException, OrmException, IOException {
    if (id.equals("current")) {
        PatchSet ps = psUtil.current(dbProvider.get(), change.getNotes());
        if (ps != null && visible(change, ps)) {
            return new RevisionResource(change, ps).doNotCache();
        }
        throw new ResourceNotFoundException(id);
    }
    List<RevisionResource> match = Lists.newArrayListWithExpectedSize(2);
    for (RevisionResource rsrc : find(change, id.get())) {
        if (visible(change, rsrc.getPatchSet())) {
            match.add(rsrc);
        }
    }
    switch(match.size()) {
        case 0:
            throw new ResourceNotFoundException(id);
        case 1:
            return match.get(0);
        default:
            throw new ResourceNotFoundException("Multiple patch sets for \"" + id.get() + "\": " + Joiner.on("; ").join(match));
    }
}
#method_after
@Override
public RevisionResource parse(ChangeResource change, IdString id) throws ResourceNotFoundException, AuthException, OrmException, IOException {
    if (id.get().equals("current")) {
        PatchSet ps = psUtil.current(dbProvider.get(), change.getNotes());
        if (ps != null && visible(change)) {
            return new RevisionResource(change, ps).doNotCache();
        }
        throw new ResourceNotFoundException(id);
    }
    List<RevisionResource> match = Lists.newArrayListWithExpectedSize(2);
    for (RevisionResource rsrc : find(change, id.get())) {
        if (visible(change)) {
            match.add(rsrc);
        }
    }
    switch(match.size()) {
        case 0:
            throw new ResourceNotFoundException(id);
        case 1:
            return match.get(0);
        default:
            throw new ResourceNotFoundException("Multiple patch sets for \"" + id.get() + "\": " + Joiner.on("; ").join(match));
    }
}
#end_block

#method_before
private boolean visible(ChangeResource change, PatchSet ps) {
    return change.getControl().isPatchVisible(ps, dbProvider.get());
}
#method_after
private boolean visible(ChangeResource change) throws OrmException {
    return changeControlFactory.controlFor(change.getNotes(), change.getUser()).isVisible(dbProvider.get());
}
#end_block

#method_before
private List<RevisionResource> loadEdit(ChangeResource change, RevId revid) throws AuthException, IOException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(change.getChange());
    if (edit.isPresent()) {
        PatchSet ps = new PatchSet(new PatchSet.Id(change.getId(), 0));
        ps.setRevision(edit.get().getRevision());
        if (revid == null || edit.get().getRevision().equals(revid)) {
            return Collections.singletonList(new RevisionResource(change, ps, edit));
        }
    }
    return Collections.emptyList();
}
#method_after
private List<RevisionResource> loadEdit(ChangeResource change, RevId revid) throws AuthException, IOException {
    Optional<ChangeEdit> edit = editUtil.byChange(change.getNotes(), change.getUser());
    if (edit.isPresent()) {
        PatchSet ps = new PatchSet(new PatchSet.Id(change.getId(), 0));
        RevId editRevId = new RevId(ObjectId.toString(edit.get().getEditCommit()));
        ps.setRevision(editRevId);
        if (revid == null || editRevId.equals(revid)) {
            return Collections.singletonList(new RevisionResource(change, ps, edit));
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Test
public void postSubmitApproval() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(changeId).current().review(ReviewInput.recommend());
    String label = "Code-Review";
    ApprovalInfo approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Submit by direct push.
    git().push().setRefSpecs(new RefSpec(r.getCommit().name() + ":refs/heads/master")).call();
    assertThat(gApi.changes().id(changeId).get().status).isEqualTo(ChangeStatus.MERGED);
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    assertPermitted(gApi.changes().id(changeId).get(EnumSet.of(DETAILED_LABELS)), "Code-Review", 1, 2);
    // Repeating the current label is allowed. Does not flip the postSubmit bit
    // due to deduplication codepath.
    gApi.changes().id(changeId).current().review(ReviewInput.recommend());
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Reducing vote is not allowed.
    try {
        gApi.changes().id(changeId).current().review(ReviewInput.dislike());
        fail("expected ResourceConflictException");
    } catch (ResourceConflictException e) {
        assertThat(e).hasMessage("Cannot reduce vote on labels for closed change: Code-Review");
    }
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Increasing vote is allowed.
    gApi.changes().id(changeId).current().review(ReviewInput.approve());
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(2);
    assertThat(approval.postSubmit).isTrue();
    assertPermitted(gApi.changes().id(changeId).get(EnumSet.of(DETAILED_LABELS)), "Code-Review", 2);
    // Decreasing to previous post-submit vote is still not allowed.
    try {
        gApi.changes().id(changeId).current().review(ReviewInput.dislike());
        fail("expected ResourceConflictException");
    } catch (ResourceConflictException e) {
        assertThat(e).hasMessage("Cannot reduce vote on labels for closed change: Code-Review");
    }
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(2);
    assertThat(approval.postSubmit).isTrue();
}
#method_after
@Test
public void postSubmitApproval() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(changeId).current().review(ReviewInput.recommend());
    String label = "Code-Review";
    ApprovalInfo approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Submit by direct push.
    git().push().setRefSpecs(new RefSpec(r.getCommit().name() + ":refs/heads/master")).call();
    assertThat(gApi.changes().id(changeId).get().status).isEqualTo(ChangeStatus.MERGED);
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    assertPermitted(gApi.changes().id(changeId).get(DETAILED_LABELS), "Code-Review", 1, 2);
    // Repeating the current label is allowed. Does not flip the postSubmit bit
    // due to deduplication codepath.
    gApi.changes().id(changeId).current().review(ReviewInput.recommend());
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Reducing vote is not allowed.
    try {
        gApi.changes().id(changeId).current().review(ReviewInput.dislike());
        fail("expected ResourceConflictException");
    } catch (ResourceConflictException e) {
        assertThat(e).hasMessageThat().isEqualTo("Cannot reduce vote on labels for closed change: Code-Review");
    }
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Increasing vote is allowed.
    gApi.changes().id(changeId).current().review(ReviewInput.approve());
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(2);
    assertThat(approval.postSubmit).isTrue();
    assertPermitted(gApi.changes().id(changeId).get(DETAILED_LABELS), "Code-Review", 2);
    // Decreasing to previous post-submit vote is still not allowed.
    try {
        gApi.changes().id(changeId).current().review(ReviewInput.dislike());
        fail("expected ResourceConflictException");
    } catch (ResourceConflictException e) {
        assertThat(e).hasMessageThat().isEqualTo("Cannot reduce vote on labels for closed change: Code-Review");
    }
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(2);
    assertThat(approval.postSubmit).isTrue();
}
#end_block

#method_before
@Test
public void postSubmitApprovalAfterVoteRemoved() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = project.get() + "~master~" + r.getChangeId();
    setApiUser(admin);
    revision(r).review(ReviewInput.approve());
    setApiUser(user);
    revision(r).review(ReviewInput.recommend());
    setApiUser(admin);
    gApi.changes().id(changeId).reviewer(user.username).deleteVote("Code-Review");
    Optional<ApprovalInfo> crUser = get(changeId, DETAILED_LABELS).labels.get("Code-Review").all.stream().filter(a -> a._accountId == user.id.get()).findFirst();
    assertThat(crUser.isPresent()).isTrue();
    assertThat(crUser.get().value).isEqualTo(0);
    revision(r).submit();
    setApiUser(user);
    ReviewInput in = new ReviewInput();
    in.label("Code-Review", 1);
    in.message = "Still LGTM";
    revision(r).review(in);
    ApprovalInfo cr = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.DETAILED_LABELS)).labels.get("Code-Review").all.stream().filter(a -> a._accountId == user.getId().get()).findFirst().get();
    assertThat(cr.postSubmit).isTrue();
}
#method_after
@Test
public void postSubmitApprovalAfterVoteRemoved() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = project.get() + "~master~" + r.getChangeId();
    setApiUser(admin);
    revision(r).review(ReviewInput.approve());
    setApiUser(user);
    revision(r).review(ReviewInput.recommend());
    setApiUser(admin);
    gApi.changes().id(changeId).reviewer(user.username).deleteVote("Code-Review");
    Optional<ApprovalInfo> crUser = get(changeId, DETAILED_LABELS).labels.get("Code-Review").all.stream().filter(a -> a._accountId == user.id.get()).findFirst();
    assertThat(crUser).isPresent();
    assertThat(crUser.get().value).isEqualTo(0);
    revision(r).submit();
    setApiUser(user);
    ReviewInput in = new ReviewInput();
    in.label("Code-Review", 1);
    in.message = "Still LGTM";
    revision(r).review(in);
    ApprovalInfo cr = gApi.changes().id(changeId).get(DETAILED_LABELS).labels.get("Code-Review").all.stream().filter(a -> a._accountId == user.getId().get()).findFirst().get();
    assertThat(cr.postSubmit).isTrue();
}
#end_block

#method_before
@Test
public void cherryPickToSameBranchWithRebase() throws Exception {
    // Push a new change, then merge it
    PushOneCommit.Result baseChange = createChange();
    String triplet = project.get() + "~master~" + baseChange.getChangeId();
    RevisionApi baseRevision = gApi.changes().id(triplet).current();
    baseRevision.review(ReviewInput.approve());
    baseRevision.submit();
    // Push a new change (change 1)
    PushOneCommit.Result r1 = createChange();
    // Push another new change (change 2)
    String subject = "Test change\n\n" + "Change-Id: Ideadbeefdeadbeefdeadbeefdeadbeefdeadbeef";
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, subject, "another_file.txt", "another content");
    PushOneCommit.Result r2 = push.to("refs/for/master");
    // Change 2's parent should be change 1
    assertThat(r2.getCommit().getParents()[0].name()).isEqualTo(r1.getCommit().name());
    // Cherry pick change 2 onto the same branch
    triplet = project.get() + "~master~" + r2.getChangeId();
    ChangeApi orig = gApi.changes().id(triplet);
    CherryPickInput in = new CherryPickInput();
    in.destination = "master";
    in.message = subject;
    ChangeApi cherry = orig.revision(r2.getCommit().name()).cherryPick(in);
    ChangeInfo cherryInfo = cherry.get();
    assertThat(cherryInfo.messages).hasSize(2);
    Iterator<ChangeMessageInfo> cherryIt = cherryInfo.messages.iterator();
    assertThat(cherryIt.next().message).isEqualTo("Uploaded patch set 1.");
    assertThat(cherryIt.next().message).isEqualTo("Uploaded patch set 2.");
    // Parent of change 2 should now be the change that was merged, i.e.
    // change 2 is rebased onto the head of the master branch.
    String newParent = cherryInfo.revisions.get(cherryInfo.currentRevision).commit.parents.get(0).commit;
    assertThat(newParent).isEqualTo(baseChange.getCommit().name());
}
#method_after
@Test
public void cherryPickToSameBranchWithRebase() throws Exception {
    // Push a new change, then merge it
    PushOneCommit.Result baseChange = createChange();
    String triplet = project.get() + "~master~" + baseChange.getChangeId();
    RevisionApi baseRevision = gApi.changes().id(triplet).current();
    baseRevision.review(ReviewInput.approve());
    baseRevision.submit();
    // Push a new change (change 1)
    PushOneCommit.Result r1 = createChange();
    // Push another new change (change 2)
    String subject = "Test change\n\nChange-Id: Ideadbeefdeadbeefdeadbeefdeadbeefdeadbeef";
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, subject, "another_file.txt", "another content");
    PushOneCommit.Result r2 = push.to("refs/for/master");
    // Change 2's parent should be change 1
    assertThat(r2.getCommit().getParents()[0].name()).isEqualTo(r1.getCommit().name());
    // Cherry pick change 2 onto the same branch
    triplet = project.get() + "~master~" + r2.getChangeId();
    ChangeApi orig = gApi.changes().id(triplet);
    CherryPickInput in = new CherryPickInput();
    in.destination = "master";
    in.message = subject;
    ChangeApi cherry = orig.revision(r2.getCommit().name()).cherryPick(in);
    ChangeInfo cherryInfo = cherry.get();
    assertThat(cherryInfo.messages).hasSize(2);
    Iterator<ChangeMessageInfo> cherryIt = cherryInfo.messages.iterator();
    assertThat(cherryIt.next().message).isEqualTo("Uploaded patch set 1.");
    assertThat(cherryIt.next().message).isEqualTo("Uploaded patch set 2.");
    // Parent of change 2 should now be the change that was merged, i.e.
    // change 2 is rebased onto the head of the master branch.
    String newParent = cherryInfo.revisions.get(cherryInfo.currentRevision).commit.parents.get(0).commit;
    assertThat(newParent).isEqualTo(baseChange.getCommit().name());
}
#end_block

#method_before
@Test
public void cherryPickMergeUsingInvalidParent() throws Exception {
    String parent1FileName = "a.txt";
    String parent2FileName = "b.txt";
    PushOneCommit.Result mergeChangeResult = createCherryPickableMerge(parent1FileName, parent2FileName);
    String cherryPickBranchName = "branch_for_cherry_pick";
    createBranch(new Branch.NameKey(project, cherryPickBranchName));
    CherryPickInput cherryPickInput = new CherryPickInput();
    cherryPickInput.destination = cherryPickBranchName;
    cherryPickInput.message = "Cherry-pick a merge commit to another branch";
    cherryPickInput.parent = 0;
    exception.expect(BadRequestException.class);
    exception.expectMessage("Cherry Pick: Parent 0 does not exist. Please" + " specify a parent in range [1, 2].");
    gApi.changes().id(mergeChangeResult.getChangeId()).current().cherryPick(cherryPickInput);
}
#method_after
@Test
public void cherryPickMergeUsingInvalidParent() throws Exception {
    String parent1FileName = "a.txt";
    String parent2FileName = "b.txt";
    PushOneCommit.Result mergeChangeResult = createCherryPickableMerge(parent1FileName, parent2FileName);
    String cherryPickBranchName = "branch_for_cherry_pick";
    createBranch(new Branch.NameKey(project, cherryPickBranchName));
    CherryPickInput cherryPickInput = new CherryPickInput();
    cherryPickInput.destination = cherryPickBranchName;
    cherryPickInput.message = "Cherry-pick a merge commit to another branch";
    cherryPickInput.parent = 0;
    exception.expect(BadRequestException.class);
    exception.expectMessage("Cherry Pick: Parent 0 does not exist. Please specify a parent in range [1, 2].");
    gApi.changes().id(mergeChangeResult.getChangeId()).current().cherryPick(cherryPickInput);
}
#end_block

#method_before
@Test
public void cherryPickMergeUsingNonExistentParent() throws Exception {
    String parent1FileName = "a.txt";
    String parent2FileName = "b.txt";
    PushOneCommit.Result mergeChangeResult = createCherryPickableMerge(parent1FileName, parent2FileName);
    String cherryPickBranchName = "branch_for_cherry_pick";
    createBranch(new Branch.NameKey(project, cherryPickBranchName));
    CherryPickInput cherryPickInput = new CherryPickInput();
    cherryPickInput.destination = cherryPickBranchName;
    cherryPickInput.message = "Cherry-pick a merge commit to another branch";
    cherryPickInput.parent = 3;
    exception.expect(BadRequestException.class);
    exception.expectMessage("Cherry Pick: Parent 3 does not exist. Please" + " specify a parent in range [1, 2].");
    gApi.changes().id(mergeChangeResult.getChangeId()).current().cherryPick(cherryPickInput);
}
#method_after
@Test
public void cherryPickMergeUsingNonExistentParent() throws Exception {
    String parent1FileName = "a.txt";
    String parent2FileName = "b.txt";
    PushOneCommit.Result mergeChangeResult = createCherryPickableMerge(parent1FileName, parent2FileName);
    String cherryPickBranchName = "branch_for_cherry_pick";
    createBranch(new Branch.NameKey(project, cherryPickBranchName));
    CherryPickInput cherryPickInput = new CherryPickInput();
    cherryPickInput.destination = cherryPickBranchName;
    cherryPickInput.message = "Cherry-pick a merge commit to another branch";
    cherryPickInput.parent = 3;
    exception.expect(BadRequestException.class);
    exception.expectMessage("Cherry Pick: Parent 3 does not exist. Please specify a parent in range [1, 2].");
    gApi.changes().id(mergeChangeResult.getChangeId()).current().cherryPick(cherryPickInput);
}
#end_block

#method_before
@Test
public void description() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).description()).isEqualTo("");
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).description("test");
    assertThat(gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).description()).isEqualTo("test");
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).description("");
    assertThat(gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).description()).isEqualTo("");
}
#method_after
@Test
public void description() throws Exception {
    PushOneCommit.Result r = createChange();
    assertDescription(r, "");
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).description("test");
    assertDescription(r, "test");
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).description("");
    assertDescription(r, "");
}
#end_block

#method_before
@Test
public void deleteVoteOnNonCurrentPatchSet() throws Exception {
    // patch set 1
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    // patch set 2
    amendChange(r.getChangeId());
    // code-review
    setApiUser(user);
    recommend(r.getChangeId());
    // check if it's blocked to delete a vote on a non-current patch set.
    exception.expect(MethodNotAllowedException.class);
    exception.expectMessage("Cannot access on non-current patch set");
    setApiUser(admin);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().getName()).reviewer(user.getId().toString()).deleteVote("Code-Review");
}
#method_after
@Test
public void deleteVoteOnNonCurrentPatchSet() throws Exception {
    // patch set 1
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    // patch set 2
    amendChange(r.getChangeId());
    // code-review
    setApiUser(user);
    recommend(r.getChangeId());
    // check if it's blocked to delete a vote on a non-current patch set.
    setApiUser(admin);
    exception.expect(MethodNotAllowedException.class);
    exception.expectMessage("Cannot access on non-current patch set");
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().getName()).reviewer(user.getId().toString()).deleteVote("Code-Review");
}
#end_block

#method_before
@Test
public void deleteVoteOnCurrentPatchSet() throws Exception {
    // patch set 1
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    // patch set 2
    amendChange(r.getChangeId());
    // code-review
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    gApi.changes().id(r.getChangeId()).current().reviewer(user.getId().toString()).deleteVote("Code-Review");
    Map<String, Short> m = gApi.changes().id(r.getChangeId()).current().reviewer(user.getId().toString()).votes();
    assertThat(m).containsExactly("Code-Review", Short.valueOf((short) 0));
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    ChangeMessageInfo message = Iterables.getLast(c.messages);
    assertThat(message.author._accountId).isEqualTo(admin.getId().get());
    assertThat(message.message).isEqualTo("Removed Code-Review+1 by User <user@example.com>\n");
    assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
}
#method_after
@Test
public void deleteVoteOnCurrentPatchSet() throws Exception {
    // patch set 1
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    // patch set 2
    amendChange(r.getChangeId());
    // code-review
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    gApi.changes().id(r.getChangeId()).current().reviewer(user.getId().toString()).deleteVote("Code-Review");
    Map<String, Short> m = gApi.changes().id(r.getChangeId()).current().reviewer(user.getId().toString()).votes();
    assertThat(m).containsExactly("Code-Review", Short.valueOf((short) 0));
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    ChangeMessageInfo message = Iterables.getLast(c.messages);
    assertThat(message.author._accountId).isEqualTo(admin.getId().get());
    assertThat(message.message).isEqualTo("Removed Code-Review+1 by User <user@example.com>\n");
    assertThat(getReviewers(c.reviewers.get(ReviewerState.REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
}
#end_block

#method_before
private ApprovalInfo getApproval(String changeId, String label) throws Exception {
    ChangeInfo info = gApi.changes().id(changeId).get(EnumSet.of(DETAILED_LABELS));
    LabelInfo li = info.labels.get(label);
    assertThat(li).isNotNull();
    int accountId = atrScope.get().getUser().getAccountId().get();
    return li.all.stream().filter(a -> a._accountId == accountId).findFirst().get();
}
#method_after
private ApprovalInfo getApproval(String changeId, String label) throws Exception {
    ChangeInfo info = gApi.changes().id(changeId).get(DETAILED_LABELS);
    LabelInfo li = info.labels.get(label);
    assertThat(li).isNotNull();
    int accountId = atrScope.get().getUser().getAccountId().get();
    return li.all.stream().filter(a -> a._accountId == accountId).findFirst().get();
}
#end_block

#method_before
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws RestApiException, RepositoryNotFoundException, IOException, OrmException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = control.getUser().asIdentifiedUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    try (MergeOp op = mergeOpProvider.get()) {
        ReviewDb db = dbProvider.get();
        op.merge(db, change, caller, true, input, false);
        try {
            change = changeNotesFactory.createChecked(db, change.getProject(), change.getId()).getChange();
        } catch (NoSuchChangeException e) {
            throw new ResourceConflictException("change is deleted");
        }
    }
    switch(change.getStatus()) {
        case MERGED:
            return new Output(change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        case ABANDONED:
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#method_after
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws RestApiException, RepositoryNotFoundException, IOException, OrmException, PermissionBackendException, UpdateException, ConfigInvalidException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    IdentifiedUser submitter;
    if (input.onBehalfOf != null) {
        submitter = onBehalfOf(rsrc, input);
    } else {
        rsrc.permissions().check(ChangePermission.SUBMIT);
        submitter = rsrc.getUser().asIdentifiedUser();
    }
    return new Output(mergeChange(rsrc, submitter, input));
}
#end_block

#method_before
private String problemsForSubmittingChangeset(ChangeData cd, ChangeSet cs, CurrentUser user) {
    try {
        @SuppressWarnings("resource")
        ReviewDb db = dbProvider.get();
        if (cs.furtherHiddenChanges()) {
            return BLOCKED_HIDDEN_SUBMIT_TOOLTIP;
        }
        for (ChangeData c : cs.changes()) {
            ChangeControl changeControl = c.changeControl(user);
            if (!changeControl.isVisible(db)) {
                return BLOCKED_HIDDEN_SUBMIT_TOOLTIP;
            }
            if (!changeControl.canSubmit()) {
                return BLOCKED_SUBMIT_TOOLTIP;
            }
            MergeOp.checkSubmitRule(c);
        }
        Collection<ChangeData> unmergeable = unmergeableChanges(cs);
        if (unmergeable == null) {
            return CLICK_FAILURE_TOOLTIP;
        } else if (!unmergeable.isEmpty()) {
            for (ChangeData c : unmergeable) {
                if (c.change().getKey().equals(cd.change().getKey())) {
                    return CHANGE_UNMERGEABLE;
                }
            }
            return CHANGES_NOT_MERGEABLE + unmergeable.stream().map(c -> c.getId().toString()).collect(joining(", "));
        }
    } catch (ResourceConflictException e) {
        return BLOCKED_SUBMIT_TOOLTIP;
    } catch (OrmException | IOException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    return null;
}
#method_after
private String problemsForSubmittingChangeset(ChangeData cd, ChangeSet cs, CurrentUser user) {
    try {
        if (cs.furtherHiddenChanges()) {
            return BLOCKED_HIDDEN_SUBMIT_TOOLTIP;
        }
        for (ChangeData c : cs.changes()) {
            Set<ChangePermission> can = permissionBackend.user(user).database(dbProvider).change(c).test(EnumSet.of(ChangePermission.READ, ChangePermission.SUBMIT));
            if (!can.contains(ChangePermission.READ)) {
                return BLOCKED_HIDDEN_SUBMIT_TOOLTIP;
            }
            if (!can.contains(ChangePermission.SUBMIT)) {
                return BLOCKED_SUBMIT_TOOLTIP;
            }
            if (c.change().isWorkInProgress()) {
                return BLOCKED_WORK_IN_PROGRESS;
            }
            MergeOp.checkSubmitRule(c, false);
        }
        Collection<ChangeData> unmergeable = unmergeableChanges(cs);
        if (unmergeable == null) {
            return CLICK_FAILURE_TOOLTIP;
        } else if (!unmergeable.isEmpty()) {
            for (ChangeData c : unmergeable) {
                if (c.change().getKey().equals(cd.change().getKey())) {
                    return CHANGE_UNMERGEABLE;
                }
            }
            return CHANGES_NOT_MERGEABLE + unmergeable.stream().map(c -> c.getId().toString()).collect(joining(", "));
        }
    } catch (ResourceConflictException e) {
        return BLOCKED_SUBMIT_TOOLTIP;
    } catch (PermissionBackendException | OrmException | IOException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    return null;
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getControl());
    try {
        MergeOp.checkSubmitRule(cd);
    } catch (ResourceConflictException e) {
        visible = false;
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    ChangeSet cs;
    try {
        cs = mergeSuperSet.get().completeChangeSet(db, cd.change(), resource.getControl().getUser());
    } catch (OrmException | IOException e) {
        throw new OrmRuntimeException("Could not determine complete set of " + "changes to be submitted", e);
    }
    int topicSize = 0;
    if (!Strings.isNullOrEmpty(topic)) {
        topicSize = getChangesByTopic(topic).size();
    }
    boolean treatWithTopic = submitWholeTopic && !Strings.isNullOrEmpty(topic) && topicSize > 1;
    String submitProblems = problemsForSubmittingChangeset(cd, cs, resource.getUser());
    Boolean enabled;
    try {
        // Recheck mergeability rather than using value stored in the index,
        // which may be stale.
        // TODO(dborowitz): This is ugly; consider providing a way to not read
        // stored fields from the index in the first place.
        // cd.setMergeable(null);
        // That was done in unmergeableChanges which was called by
        // problemsForSubmittingChangeset, so now it is safe to read from
        // the cache, as it yields the same result.
        enabled = cd.isMergeable();
    } catch (OrmException e) {
        throw new OrmRuntimeException("Could not determine mergeability", e);
    }
    if (submitProblems != null) {
        return new UiAction.Description().setLabel(treatWithTopic ? submitTopicLabel : (cs.size() > 1) ? labelWithParents : label).setTitle(submitProblems).setVisible(true).setEnabled(false);
    }
    if (treatWithTopic) {
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(topicSize), "submitSize", String.valueOf(cs.size()));
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    }
    RevId revId = resource.getPatchSet().getRevision();
    Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name(), "submitSize", String.valueOf(cs.size()));
    ParameterizedString tp = cs.size() > 1 ? titlePatternWithAncestors : titlePattern;
    return new UiAction.Description().setLabel(cs.size() > 1 ? labelWithParents : label).setTitle(Strings.emptyToNull(tp.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    Change change = resource.getChange();
    if (!change.getStatus().isOpen() || !resource.isCurrent() || !resource.permissions().testOrFalse(ChangePermission.SUBMIT)) {
        // submit not visible
        return null;
    }
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getNotes());
    try {
        MergeOp.checkSubmitRule(cd, false);
    } catch (ResourceConflictException e) {
        // submit not visible
        return null;
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    ChangeSet cs;
    try {
        cs = mergeSuperSet.get().completeChangeSet(db, cd.change(), resource.getUser());
    } catch (OrmException | IOException | PermissionBackendException e) {
        throw new OrmRuntimeException("Could not determine complete set of changes to be submitted", e);
    }
    String topic = change.getTopic();
    int topicSize = 0;
    if (!Strings.isNullOrEmpty(topic)) {
        topicSize = getChangesByTopic(topic).size();
    }
    boolean treatWithTopic = submitWholeTopic && !Strings.isNullOrEmpty(topic) && topicSize > 1;
    String submitProblems = problemsForSubmittingChangeset(cd, cs, resource.getUser());
    Boolean enabled;
    try {
        // Recheck mergeability rather than using value stored in the index,
        // which may be stale.
        // TODO(dborowitz): This is ugly; consider providing a way to not read
        // stored fields from the index in the first place.
        // cd.setMergeable(null);
        // That was done in unmergeableChanges which was called by
        // problemsForSubmittingChangeset, so now it is safe to read from
        // the cache, as it yields the same result.
        enabled = cd.isMergeable();
    } catch (OrmException e) {
        throw new OrmRuntimeException("Could not determine mergeability", e);
    }
    if (submitProblems != null) {
        return new UiAction.Description().setLabel(treatWithTopic ? submitTopicLabel : (cs.size() > 1) ? labelWithParents : label).setTitle(submitProblems).setVisible(true).setEnabled(false);
    }
    if (treatWithTopic) {
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(topicSize), "submitSize", String.valueOf(cs.size()));
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    }
    RevId revId = resource.getPatchSet().getRevision();
    Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", change.getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name(), "submitSize", String.valueOf(cs.size()));
    ParameterizedString tp = cs.size() > 1 ? titlePatternWithAncestors : titlePattern;
    return new UiAction.Description().setLabel(cs.size() > 1 ? labelWithParents : label).setTitle(Strings.emptyToNull(tp.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
}
#end_block

#method_before
private RevisionResource onBehalfOf(RevisionResource rsrc, SubmitInput in) throws AuthException, UnprocessableEntityException, OrmException {
    ChangeControl caller = rsrc.getControl();
    if (!caller.canSubmit()) {
        throw new AuthException("submit not permitted");
    }
    if (!caller.canSubmitAs()) {
        throw new AuthException("submit on behalf of not permitted");
    }
    ChangeControl target = caller.forUser(accounts.parseOnBehalfOf(caller.getUser(), in.onBehalfOf));
    if (!target.getRefControl().isVisible()) {
        throw new UnprocessableEntityException(String.format("on_behalf_of account %s cannot see destination ref", target.getUser().getAccountId()));
    }
    return new RevisionResource(changes.parse(target), rsrc.getPatchSet());
}
#method_after
private IdentifiedUser onBehalfOf(RevisionResource rsrc, SubmitInput in) throws AuthException, UnprocessableEntityException, OrmException, PermissionBackendException, IOException, ConfigInvalidException {
    PermissionBackend.ForChange perm = rsrc.permissions().database(dbProvider);
    perm.check(ChangePermission.SUBMIT);
    perm.check(ChangePermission.SUBMIT_AS);
    CurrentUser caller = rsrc.getUser();
    IdentifiedUser submitter = accounts.parseOnBehalfOf(caller, in.onBehalfOf);
    try {
        perm.user(submitter).check(ChangePermission.READ);
    } catch (AuthException e) {
        throw new UnprocessableEntityException(String.format("on_behalf_of account %s cannot see change", submitter.getAccountId()));
    }
    return submitter;
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource rsrc, SubmitInput input) throws RestApiException, RepositoryNotFoundException, IOException, OrmException {
    PatchSet ps = psUtil.current(dbProvider.get(), rsrc.getNotes());
    if (ps == null) {
        throw new ResourceConflictException("current revision is missing");
    } else if (!rsrc.getControl().isPatchVisible(ps, dbProvider.get())) {
        throw new AuthException("current revision not accessible");
    }
    Output out = submit.apply(new RevisionResource(rsrc, ps), input);
    return json.create(ChangeJson.NO_OPTIONS).format(out.change);
}
#method_after
@Override
public ChangeInfo apply(ChangeResource rsrc, SubmitInput input) throws RestApiException, RepositoryNotFoundException, IOException, OrmException, PermissionBackendException, UpdateException, ConfigInvalidException {
    PatchSet ps = psUtil.current(dbProvider.get(), rsrc.getNotes());
    if (ps == null) {
        throw new ResourceConflictException("current revision is missing");
    } else if (!changeControlFactory.controlFor(rsrc.getNotes(), rsrc.getUser()).isVisible(dbProvider.get())) {
        throw new AuthException("current revision not accessible");
    }
    Output out = submit.apply(new RevisionResource(rsrc, ps), input);
    return json.noOptions().format(out.change);
}
#end_block

#method_before
public static Id parse(final String str) {
    final Id r = new Id();
    r.fromString(str);
    return r;
}
#method_after
public static Id parse(String str) {
    final Id r = new Id();
    r.fromString(str);
    return r;
}
#end_block

#method_before
public void setRevision(final RevId i) {
    revision = i;
}
#method_after
public void setRevision(RevId i) {
    revision = i;
}
#end_block

#method_before
public void setUploader(final Account.Id who) {
    uploader = who;
}
#method_after
public void setUploader(Account.Id who) {
    uploader = who;
}
#end_block

#method_before
public void setCreatedOn(final Timestamp ts) {
    createdOn = ts;
}
#method_after
public void setCreatedOn(Timestamp ts) {
    createdOn = ts;
}
#end_block

#method_before
public static String toLongString(final Change.Status status) {
    if (status == null) {
        return "";
    }
    switch(status) {
        case NEW:
            return C.statusLongNew();
        case MERGED:
            return C.statusLongMerged();
        case ABANDONED:
            return C.statusLongAbandoned();
        default:
            return status.name();
    }
}
#method_after
public static String toLongString(Change.Status status) {
    if (status == null) {
        return "";
    }
    switch(status) {
        case NEW:
            return C.statusLongNew();
        case MERGED:
            return C.statusLongMerged();
        case ABANDONED:
            return C.statusLongAbandoned();
        default:
            return status.name();
    }
}
#end_block

#method_before
@SuppressWarnings("deprecation")
public static String cropSubject(final String subject) {
    if (subject.length() > SUBJECT_MAX_LENGTH) {
        final int maxLength = SUBJECT_MAX_LENGTH - SUBJECT_CROP_APPENDIX.length();
        for (int cropPosition = maxLength; cropPosition > maxLength - SUBJECT_CROP_RANGE; cropPosition--) {
            // see https://developers.google.com/web-toolkit/doc/1.6/RefJreEmulation#Package_java_lang
            if (Character.isSpace(subject.charAt(cropPosition - 1))) {
                return subject.substring(0, cropPosition) + SUBJECT_CROP_APPENDIX;
            }
        }
        return subject.substring(0, maxLength) + SUBJECT_CROP_APPENDIX;
    }
    return subject;
}
#method_after
@SuppressWarnings("deprecation")
public static String cropSubject(String subject) {
    if (subject.length() > SUBJECT_MAX_LENGTH) {
        final int maxLength = SUBJECT_MAX_LENGTH - SUBJECT_CROP_APPENDIX.length();
        for (int cropPosition = maxLength; cropPosition > maxLength - SUBJECT_CROP_RANGE; cropPosition--) {
            // see https://developers.google.com/web-toolkit/doc/1.6/RefJreEmulation#Package_java_lang
            if (Character.isSpace(subject.charAt(cropPosition - 1))) {
                return subject.substring(0, cropPosition) + SUBJECT_CROP_APPENDIX;
            }
        }
        return subject.substring(0, maxLength) + SUBJECT_CROP_APPENDIX;
    }
    return subject;
}
#end_block

#method_before
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, notesFactory, changeDataFactory, fillArgs, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, trackingFooters, index, indexConfig, listMembers, starredChangesUtil, accountCache);
}
#method_after
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, Providers.of(otherUser), permissionBackend, changeControlGenericFactory, notesFactory, changeDataFactory, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, index, indexConfig, listMembers, starredChangesUtil, accountCache, allowsDrafts, notesMigration);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> change(String query) throws QueryParseException {
    if (PAT_LEGACY_ID.matcher(query).matches()) {
        return new LegacyChangeIdPredicate(Change.Id.parse(query));
    } else if (PAT_CHANGE_ID.matcher(query).matches()) {
        return new ChangeIdPredicate(parseChangeId(query));
    }
    Optional<ChangeTriplet> triplet = ChangeTriplet.parse(query);
    if (triplet.isPresent()) {
        return Predicate.and(project(triplet.get().project().get()), branch(triplet.get().branch().get()), new ChangeIdPredicate(parseChangeId(triplet.get().id().get())));
    }
    throw new QueryParseException("Invalid change format");
}
#method_after
@Operator
public Predicate<ChangeData> change(String query) throws QueryParseException {
    Optional<ChangeTriplet> triplet = ChangeTriplet.parse(query);
    if (triplet.isPresent()) {
        return Predicate.and(project(triplet.get().project().get()), branch(triplet.get().branch().get()), new ChangeIdPredicate(parseChangeId(triplet.get().id().get())));
    }
    if (PAT_LEGACY_ID.matcher(query).matches()) {
        return new LegacyChangeIdPredicate(Change.Id.parse(query));
    } else if (PAT_CHANGE_ID.matcher(query).matches()) {
        return new ChangeIdPredicate(parseChangeId(query));
    }
    throw new QueryParseException("Invalid change format");
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return ReviewerPredicate.create(self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(args.fillArgs);
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    if ("submittable".equalsIgnoreCase(value)) {
        return new SubmittablePredicate(SubmitRecord.Status.OK);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.WIP)) {
            return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP)), ReviewerPredicate.reviewer(args, self()));
        }
        return ReviewerPredicate.reviewer(args, self());
    }
    if ("cc".equalsIgnoreCase(value)) {
        return ReviewerPredicate.cc(self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.MERGEABLE);
    }
    if ("private".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.PRIVATE)) {
            return new BooleanPredicate(ChangeField.PRIVATE);
        }
        throw new QueryParseException("'is:private' operator is not supported by change index version");
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    if ("submittable".equalsIgnoreCase(value)) {
        return new SubmittablePredicate(SubmitRecord.Status.OK);
    }
    if ("ignored".equalsIgnoreCase(value)) {
        return star("ignore");
    }
    if ("started".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.STARTED)) {
            return new BooleanPredicate(ChangeField.STARTED);
        }
        throw new QueryParseException("'is:started' operator is not supported by change index version");
    }
    if ("wip".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.WIP)) {
            return new BooleanPredicate(ChangeField.WIP);
        }
        throw new QueryParseException("'is:wip' operator is not supported by change index version");
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> conflicts(String value) throws OrmException, QueryParseException {
    return new ConflictsPredicate(args, value, parseChange(value));
}
#method_after
@Operator
public Predicate<ChangeData> conflicts(String value) throws OrmException, QueryParseException {
    List<Change> changes = parseChange(value);
    List<Predicate<ChangeData>> or = new ArrayList<>(changes.size());
    for (Change c : changes) {
        or.add(ConflictsPredicate.create(args, value, c));
    }
    return Predicate.or(or);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException {
    Set<Account.Id> accounts = null;
    AccountGroup.UUID group = null;
    // Parse for:
    // label:CodeReview=1,user=jsmith or
    // label:CodeReview=1,jsmith or
    // label:CodeReview=1,group=android_approvers or
    // label:CodeReview=1,android_approvers
    // user/groups without a label will first attempt to match user
    // Special case: votes by owners can be tracked with ",owner":
    // label:Code-Review+2,owner
    // label:Code-Review+2,user=owner
    String[] splitReviewer = name.split(",", 2);
    // remove all but the vote piece, e.g.'CodeReview=1'
    name = splitReviewer[0];
    if (splitReviewer.length == 2) {
        // process the user/group piece
        PredicateArgs lblArgs = new PredicateArgs(splitReviewer[1]);
        for (Map.Entry<String, String> pair : lblArgs.keyValue.entrySet()) {
            if (pair.getKey().equalsIgnoreCase(ARG_ID_USER)) {
                if (pair.getValue().equals(ARG_ID_OWNER)) {
                    accounts = Collections.singleton(OWNER_ACCOUNT_ID);
                } else {
                    accounts = parseAccount(pair.getValue());
                }
            } else if (pair.getKey().equalsIgnoreCase(ARG_ID_GROUP)) {
                group = parseGroup(pair.getValue()).getUUID();
            } else {
                throw new QueryParseException("Invalid argument identifier '" + pair.getKey() + "'");
            }
        }
        for (String value : lblArgs.positional) {
            if (accounts != null || group != null) {
                throw new QueryParseException("more than one user/group specified (" + value + ")");
            }
            try {
                if (value.equals(ARG_ID_OWNER)) {
                    accounts = Collections.singleton(OWNER_ACCOUNT_ID);
                } else {
                    accounts = parseAccount(value);
                }
            } catch (QueryParseException qpex) {
                // (accounts get precedence)
                try {
                    group = parseGroup(value).getUUID();
                } catch (QueryParseException e) {
                    throw error("Neither user nor group " + value + " found", e);
                }
            }
        }
    }
    // expand a group predicate into multiple user predicates
    if (group != null) {
        Set<Account.Id> allMembers = args.listMembers.get().setRecursive(true).apply(group).stream().map(a -> new Account.Id(a._accountId)).collect(toSet());
        int maxLimit = args.indexConfig.maxLimit();
        if (allMembers.size() > maxLimit) {
            // limit the number of query terms otherwise Gerrit will barf
            accounts = ImmutableSet.copyOf(Iterables.limit(allMembers, maxLimit));
        } else {
            accounts = allMembers;
        }
    }
    // If the vote piece looks like Code-Review=NEED with a valid non-numeric
    // submit record status, interpret as a submit record query.
    int eq = name.indexOf('=');
    if (args.getSchema().hasField(ChangeField.SUBMIT_RECORD) && eq > 0) {
        String statusName = name.substring(eq + 1).toUpperCase();
        if (!isInt(statusName)) {
            SubmitRecord.Label.Status status = Enums.getIfPresent(SubmitRecord.Label.Status.class, statusName).orNull();
            if (status == null) {
                throw error("Invalid label status " + statusName + " in " + name);
            }
            return SubmitRecordPredicate.create(name.substring(0, eq), status, accounts);
        }
    }
    return new LabelPredicate(args, name, accounts, group);
}
#method_after
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    Set<Account.Id> accounts = null;
    AccountGroup.UUID group = null;
    // Parse for:
    // label:CodeReview=1,user=jsmith or
    // label:CodeReview=1,jsmith or
    // label:CodeReview=1,group=android_approvers or
    // label:CodeReview=1,android_approvers
    // user/groups without a label will first attempt to match user
    // Special case: votes by owners can be tracked with ",owner":
    // label:Code-Review+2,owner
    // label:Code-Review+2,user=owner
    String[] splitReviewer = name.split(",", 2);
    // remove all but the vote piece, e.g.'CodeReview=1'
    name = splitReviewer[0];
    if (splitReviewer.length == 2) {
        // process the user/group piece
        PredicateArgs lblArgs = new PredicateArgs(splitReviewer[1]);
        for (Map.Entry<String, String> pair : lblArgs.keyValue.entrySet()) {
            if (pair.getKey().equalsIgnoreCase(ARG_ID_USER)) {
                if (pair.getValue().equals(ARG_ID_OWNER)) {
                    accounts = Collections.singleton(OWNER_ACCOUNT_ID);
                } else {
                    accounts = parseAccount(pair.getValue());
                }
            } else if (pair.getKey().equalsIgnoreCase(ARG_ID_GROUP)) {
                group = parseGroup(pair.getValue()).getUUID();
            } else {
                throw new QueryParseException("Invalid argument identifier '" + pair.getKey() + "'");
            }
        }
        for (String value : lblArgs.positional) {
            if (accounts != null || group != null) {
                throw new QueryParseException("more than one user/group specified (" + value + ")");
            }
            try {
                if (value.equals(ARG_ID_OWNER)) {
                    accounts = Collections.singleton(OWNER_ACCOUNT_ID);
                } else {
                    accounts = parseAccount(value);
                }
            } catch (QueryParseException qpex) {
                // (accounts get precedence)
                try {
                    group = parseGroup(value).getUUID();
                } catch (QueryParseException e) {
                    throw error("Neither user nor group " + value + " found", e);
                }
            }
        }
    }
    // expand a group predicate into multiple user predicates
    if (group != null) {
        Set<Account.Id> allMembers = args.listMembers.get().setRecursive(true).apply(group).stream().map(a -> new Account.Id(a._accountId)).collect(toSet());
        int maxLimit = args.indexConfig.maxLimit();
        if (allMembers.size() > maxLimit) {
            // limit the number of query terms otherwise Gerrit will barf
            accounts = ImmutableSet.copyOf(Iterables.limit(allMembers, maxLimit));
        } else {
            accounts = allMembers;
        }
    }
    // If the vote piece looks like Code-Review=NEED with a valid non-numeric
    // submit record status, interpret as a submit record query.
    int eq = name.indexOf('=');
    if (args.getSchema().hasField(ChangeField.SUBMIT_RECORD) && eq > 0) {
        String statusName = name.substring(eq + 1).toUpperCase();
        if (!isInt(statusName)) {
            SubmitRecord.Label.Status status = Enums.getIfPresent(SubmitRecord.Label.Status.class, statusName).orNull();
            if (status == null) {
                throw error("Invalid label status " + statusName + " in " + name);
            }
            return SubmitRecordPredicate.create(name.substring(0, eq), status, accounts);
        }
    }
    return new LabelPredicate(args, name, accounts, group);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> starredby(String who) throws QueryParseException, OrmException {
    return starredby(parseAccount(who));
}
#method_after
@Operator
public Predicate<ChangeData> starredby(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    return starredby(parseAccount(who));
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> watchedby(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<IsWatchedByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    Account.Id callerId;
    try {
        CurrentUser caller = args.self.get();
        callerId = caller.isIdentifiedUser() ? caller.getAccountId() : null;
    } catch (ProvisionException e) {
        callerId = null;
    }
    for (Account.Id id : m) {
        // Each child IsWatchedByPredicate includes a visibility filter for the
        // corresponding user, to ensure that predicate subtree only returns
        // changes visible to that user. The exception is if one of the users is
        // the caller of this method, in which case visibility is already being
        // checked at the top level.
        p.add(new IsWatchedByPredicate(args.asUser(id), !id.equals(callerId)));
    }
    return Predicate.or(p);
}
#method_after
@Operator
public Predicate<ChangeData> watchedby(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    Set<Account.Id> m = parseAccount(who);
    List<IsWatchedByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    Account.Id callerId;
    try {
        CurrentUser caller = args.self.get();
        callerId = caller.isIdentifiedUser() ? caller.getAccountId() : null;
    } catch (ProvisionException e) {
        callerId = null;
    }
    for (Account.Id id : m) {
        // Each child IsWatchedByPredicate includes a visibility filter for the
        // corresponding user, to ensure that predicate subtree only returns
        // changes visible to that user. The exception is if one of the users is
        // the caller of this method, in which case visibility is already being
        // checked at the top level.
        p.add(new IsWatchedByPredicate(args.asUser(id), !id.equals(callerId)));
    }
    return Predicate.or(p);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> draftby(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        p.add(draftby(id));
    }
    return Predicate.or(p);
}
#method_after
@Operator
public Predicate<ChangeData> draftby(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    Set<Account.Id> m = parseAccount(who);
    List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        p.add(draftby(id));
    }
    return Predicate.or(p);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(args.db.get(), who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(args.capabilityControlFactory, ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#method_after
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    if (isSelf(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(args.db.get(), who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#end_block

#method_before
public Predicate<ChangeData> visibleto(CurrentUser user) {
    return new ChangeIsVisibleToPredicate(args.db, args.notesFactory, args.changeControlGenericFactory, user);
}
#method_after
public Predicate<ChangeData> visibleto(CurrentUser user) {
    return new ChangeIsVisibleToPredicate(args.db, args.notesFactory, args.changeControlGenericFactory, user, args.permissionBackend);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> o(String who) throws QueryParseException, OrmException {
    return owner(who);
}
#method_after
@Operator
public Predicate<ChangeData> o(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    return owner(who);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> owner(String who) throws QueryParseException, OrmException {
    return owner(parseAccount(who));
}
#method_after
@Operator
public Predicate<ChangeData> owner(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    return owner(parseAccount(who));
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> assignee(String who) throws QueryParseException, OrmException {
    return assignee(parseAccount(who));
}
#method_after
@Operator
public Predicate<ChangeData> assignee(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    return assignee(parseAccount(who));
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> r(String who) throws QueryParseException, OrmException {
    return reviewer(who);
}
#method_after
@Operator
public Predicate<ChangeData> r(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    return reviewer(who);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> reviewer(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        p.add(ReviewerPredicate.create(id));
    }
    return Predicate.or(p);
}
#method_after
@Operator
public Predicate<ChangeData> reviewer(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    return reviewer(who, false);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> reviewer(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        p.add(ReviewerPredicate.create(id));
    }
    return Predicate.or(p);
}
#method_after
private Predicate<ChangeData> reviewer(String who, boolean forDefaultField) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    Predicate<ChangeData> byState = reviewerByState(who, ReviewerStateInternal.REVIEWER, forDefaultField);
    if (Objects.equals(byState, Predicate.<ChangeData>any())) {
        return Predicate.any();
    }
    if (args.getSchema().hasField(ChangeField.WIP)) {
        return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP)), byState);
    }
    return byState;
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> tr(String trackingId) {
    return new TrackingIdPredicate(args.trackingFooters, trackingId);
}
#method_after
@Operator
public Predicate<ChangeData> tr(String trackingId) {
    return new TrackingIdPredicate(trackingId);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> commentby(String who) throws QueryParseException, OrmException {
    return commentby(parseAccount(who));
}
#method_after
@Operator
public Predicate<ChangeData> commentby(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    return commentby(parseAccount(who));
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> from(String who) throws QueryParseException, OrmException {
    Set<Account.Id> ownerIds = parseAccount(who);
    return Predicate.or(owner(ownerIds), commentby(ownerIds));
}
#method_after
@Operator
public Predicate<ChangeData> from(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    Set<Account.Id> ownerIds = parseAccount(who);
    return Predicate.or(owner(ownerIds), commentby(ownerIds));
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> reviewedby(String who) throws QueryParseException, OrmException {
    return IsReviewedPredicate.create(parseAccount(who));
}
#method_after
@Operator
public Predicate<ChangeData> reviewedby(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    return IsReviewedPredicate.create(parseAccount(who));
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> author(String who) {
    return new AuthorPredicate(who);
}
#method_after
@Operator
public Predicate<ChangeData> author(String who) throws QueryParseException {
    if (args.getSchema().hasField(ChangeField.EXACT_AUTHOR)) {
        return getAuthorOrCommitterPredicate(who.trim(), ExactAuthorPredicate::new, AuthorPredicate::new);
    }
    return getAuthorOrCommitterFullTextPredicate(who.trim(), AuthorPredicate::new);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> committer(String who) {
    return new CommitterPredicate(who);
}
#method_after
@Operator
public Predicate<ChangeData> committer(String who) throws QueryParseException {
    if (args.getSchema().hasField(ChangeField.EXACT_COMMITTER)) {
        return getAuthorOrCommitterPredicate(who.trim(), ExactCommitterPredicate::new, CommitterPredicate::new);
    }
    return getAuthorOrCommitterFullTextPredicate(who.trim(), CommitterPredicate::new);
}
#end_block

#method_before
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        try {
            return change(query);
        } catch (QueryParseException e) {
        // Skip.
        }
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#method_after
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(2);
        try {
            predicates.add(change(query));
        } catch (QueryParseException e) {
        // Skip.
        }
        // For PAT_LEGACY_ID, it may also be the prefix of some commits.
        if (query.length() >= 6 && PAT_LEGACY_ID.matcher(query).matches()) {
            predicates.add(commit(query));
        }
        return Predicate.or(predicates);
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        Predicate<ChangeData> p = ownerDefaultField(query);
        if (!Objects.equals(p, Predicate.<ChangeData>any())) {
            predicates.add(p);
        }
    } catch (OrmException | IOException | ConfigInvalidException | QueryParseException e) {
    // Skip.
    }
    try {
        Predicate<ChangeData> p = reviewerDefaultField(query);
        if (!Objects.equals(p, Predicate.<ChangeData>any())) {
            predicates.add(p);
        }
    } catch (OrmException | IOException | ConfigInvalidException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | IOException | ConfigInvalidException | QueryParseException e) {
    // Skip.
    }
    predicates.add(commit(query));
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#end_block

#method_before
private Set<Account.Id> parseAccount(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return Collections.singleton(self());
    }
    Set<Account.Id> matches = args.accountResolver.findAll(args.db.get(), who);
    if (matches.isEmpty()) {
        throw error("User " + who + " not found");
    }
    return matches;
}
#method_after
private Set<Account.Id> parseAccount(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    if (isSelf(who)) {
        return Collections.singleton(self());
    }
    Set<Account.Id> matches = args.accountResolver.findAll(args.db.get(), who);
    if (matches.isEmpty()) {
        throw error("User " + who + " not found");
    }
    return matches;
}
#end_block

#method_before
@Override
public Change createChange(Context ctx) {
    change = new Change(getChangeKey(commit), changeId, ctx.getAccountId(), new Branch.NameKey(ctx.getProject(), refName), ctx.getWhen());
    change.setStatus(MoreObjects.firstNonNull(status, Change.Status.NEW));
    change.setTopic(topic);
    return change;
}
#method_after
@Override
public Change createChange(Context ctx) throws IOException {
    change = new Change(getChangeKey(ctx.getRevWalk(), commitId), changeId, ctx.getAccountId(), new Branch.NameKey(ctx.getProject(), refName), ctx.getWhen());
    change.setStatus(MoreObjects.firstNonNull(status, Change.Status.NEW));
    change.setTopic(topic);
    change.setPrivate(isPrivate);
    change.setWorkInProgress(workInProgress);
    change.setReviewStarted(!workInProgress);
    change.setRevertOf(revertOf);
    return change;
}
#end_block

#method_before
private static Change.Key getChangeKey(RevCommit commit) {
    List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    if (!idList.isEmpty()) {
        return new Change.Key(idList.get(idList.size() - 1).trim());
    }
    ObjectId id = ChangeIdUtil.computeChangeId(commit.getTree(), commit, commit.getAuthorIdent(), commit.getCommitterIdent(), commit.getShortMessage());
    StringBuilder changeId = new StringBuilder();
    changeId.append("I").append(ObjectId.toString(id));
    return new Change.Key(changeId.toString());
}
#method_after
private static Change.Key getChangeKey(RevWalk rw, ObjectId id) throws IOException {
    RevCommit commit = rw.parseCommit(id);
    rw.parseBody(commit);
    List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    if (!idList.isEmpty()) {
        return new Change.Key(idList.get(idList.size() - 1).trim());
    }
    ObjectId changeId = ChangeIdUtil.computeChangeId(commit.getTree(), commit, commit.getAuthorIdent(), commit.getCommitterIdent(), commit.getShortMessage());
    StringBuilder changeIdStr = new StringBuilder();
    changeIdStr.append("I").append(ObjectId.toString(changeId));
    return new Change.Key(changeIdStr.toString());
}
#end_block

#method_before
public ChangeInserter setUpdateRef(boolean updateRef) {
    this.updateRef = updateRef;
    return this;
}
#method_after
@Deprecated
public ChangeInserter setUpdateRef(boolean updateRef) {
    this.updateRef = updateRef;
    return this;
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws ResourceConflictException, IOException {
    validate(ctx);
    if (!updateRef) {
        return;
    }
    if (updateRefCommand == null) {
        ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commit, psId.toRefName()));
    } else {
        ctx.addRefUpdate(updateRefCommand);
    }
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws ResourceConflictException, IOException {
    cmd = new ReceiveCommand(ObjectId.zeroId(), commitId, psId.toRefName());
    projectState = projectCache.checkedGet(ctx.getProject());
    validate(ctx);
    if (!updateRef) {
        return;
    }
    ctx.addRefUpdate(cmd);
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setChangeId(change.getKey().get());
    update.setSubjectForCommit("Create change");
    update.setBranch(change.getDest().get());
    update.setTopic(change.getTopic());
    update.setPsDescription(patchSetDescription);
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        newGroups = GroupCollector.getDefaultGroups(commit);
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commit, newGroups, pushCert, patchSetDescription);
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, filterOnChangeVisibility(db, ctx.getNotes(), reviewers), Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovalsForNewPatchSet(db, update, labelTypes, patchSet, ctx.getControl(), approvals);
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(patchSet.getId(), ctx.getUser(), patchSet.getCreatedOn(), message, ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException, PermissionBackendException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), ctx.getRevWalk().parseCommit(commitId), psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setChangeId(change.getKey().get());
    update.setSubjectForCommit("Create change");
    update.setBranch(change.getDest().get());
    update.setTopic(change.getTopic());
    update.setPsDescription(patchSetDescription);
    update.setPrivate(isPrivate);
    update.setWorkInProgress(workInProgress);
    if (revertOf != null) {
        update.setRevertOf(revertOf.get());
    }
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        newGroups = GroupCollector.getDefaultGroups(commitId);
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commitId, newGroups, pushCert, patchSetDescription);
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    Set<Account.Id> reviewersToAdd = new HashSet<>(reviewers);
    if (migration.readChanges()) {
        approvalsUtil.addCcs(ctx.getNotes(), update, filterOnChangeVisibility(db, ctx.getNotes(), extraCC));
    } else {
        reviewersToAdd.addAll(extraCC);
    }
    LabelTypes labelTypes = projectState.getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, filterOnChangeVisibility(db, ctx.getNotes(), reviewersToAdd), Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovalsForNewPatchSet(db, update, labelTypes, patchSet, ctx.getUser(), approvals);
    // reviewer which is needed in several other code paths.
    if (!approvals.isEmpty()) {
        update.putReviewer(ctx.getAccountId(), REVIEWER);
    }
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(patchSet.getId(), ctx.getUser(), patchSet.getCreatedOn(), message, ChangeMessagesUtil.uploadedPatchSetTag(workInProgress));
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
private Set<Account.Id> filterOnChangeVisibility(final ReviewDb db, final ChangeNotes notes, Set<Account.Id> accounts) {
    return accounts.stream().filter(accountId -> {
        try {
            IdentifiedUser user = userFactory.create(accountId);
            return changeControlFactory.controlFor(notes, user).isVisible(db);
        } catch (OrmException e) {
            log.warn(String.format("Failed to check if account %d can see change %d", accountId.get(), notes.getChangeId().get()), e);
            return false;
        }
    }).collect(toSet());
}
#method_after
private Set<Account.Id> filterOnChangeVisibility(final ReviewDb db, ChangeNotes notes, Set<Account.Id> accounts) {
    return accounts.stream().filter(accountId -> {
        try {
            IdentifiedUser user = userFactory.create(accountId);
            return permissionBackend.user(user).change(notes).database(db).test(ChangePermission.READ);
        } catch (PermissionBackendException e) {
            log.warn(String.format("Failed to check if account %d can see change %d", accountId.get(), notes.getChangeId().get()), e);
            return false;
        }
    }).collect(toSet());
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    if (sendMail && (notify != NotifyHandling.NONE || !accountsToNotify.isEmpty())) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    CreateChangeSender cm = createChangeSenderFactory.create(change.getProject(), change.getId());
                    cm.setFrom(change.getOwner());
                    cm.setPatchSet(patchSet, patchSetInfo);
                    cm.setNotify(notify);
                    cm.setAccountsToNotify(accountsToNotify);
                    cm.addReviewers(reviewers);
                    cm.addExtraCC(extraCC);
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new change " + change.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newchange";
            }
        };
        if (requestScopePropagator != null) {
            @SuppressWarnings("unused")
            Future<?> possiblyIgnoredError = sendEmailExecutor.submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    /* For labels that are not set in this operation, show the "current" value
     * of 0, and no oldValue as the value was not modified by this operation.
     * For labels that are set in this operation, the value was modified, so
     * show a transition from an oldValue of 0 to the new value.
     */
    if (fireRevisionCreated) {
        revisionCreated.fire(change, patchSet, ctx.getAccount(), ctx.getWhen(), notify);
        if (approvals != null && !approvals.isEmpty()) {
            ChangeControl changeControl = changeControlFactory.controlFor(ctx.getDb(), change, ctx.getUser());
            List<LabelType> labels = changeControl.getLabelTypes().getLabelTypes();
            Map<String, Short> allApprovals = new HashMap<>();
            Map<String, Short> oldApprovals = new HashMap<>();
            for (LabelType lt : labels) {
                allApprovals.put(lt.getName(), (short) 0);
                oldApprovals.put(lt.getName(), null);
            }
            for (Map.Entry<String, Short> entry : approvals.entrySet()) {
                if (entry.getValue() != 0) {
                    allApprovals.put(entry.getKey(), entry.getValue());
                    oldApprovals.put(entry.getKey(), (short) 0);
                }
            }
            commentAdded.fire(change, patchSet, ctx.getAccount(), null, allApprovals, oldApprovals, ctx.getWhen());
        }
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException, IOException {
    if (sendMail && (notify != NotifyHandling.NONE || !accountsToNotify.isEmpty())) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    CreateChangeSender cm = createChangeSenderFactory.create(change.getProject(), change.getId());
                    cm.setFrom(change.getOwner());
                    cm.setPatchSet(patchSet, patchSetInfo);
                    cm.setNotify(notify);
                    cm.setAccountsToNotify(accountsToNotify);
                    cm.addReviewers(reviewers);
                    cm.addExtraCC(extraCC);
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new change " + change.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newchange";
            }
        };
        if (requestScopePropagator != null) {
            @SuppressWarnings("unused")
            Future<?> possiblyIgnoredError = sendEmailExecutor.submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    /* For labels that are not set in this operation, show the "current" value
     * of 0, and no oldValue as the value was not modified by this operation.
     * For labels that are set in this operation, the value was modified, so
     * show a transition from an oldValue of 0 to the new value.
     */
    if (fireRevisionCreated) {
        revisionCreated.fire(change, patchSet, ctx.getAccount(), ctx.getWhen(), notify);
        if (approvals != null && !approvals.isEmpty()) {
            List<LabelType> labels = projectState.getLabelTypes(change.getDest(), ctx.getUser()).getLabelTypes();
            Map<String, Short> allApprovals = new HashMap<>();
            Map<String, Short> oldApprovals = new HashMap<>();
            for (LabelType lt : labels) {
                allApprovals.put(lt.getName(), (short) 0);
                oldApprovals.put(lt.getName(), null);
            }
            for (Map.Entry<String, Short> entry : approvals.entrySet()) {
                if (entry.getValue() != 0) {
                    allApprovals.put(entry.getKey(), entry.getValue());
                    oldApprovals.put(entry.getKey(), (short) 0);
                }
            }
            commentAdded.fire(change, patchSet, ctx.getAccount(), null, allApprovals, oldApprovals, ctx.getWhen());
        }
    }
}
#end_block

#method_before
private void validate(RepoContext ctx) throws IOException, ResourceConflictException {
    if (validatePolicy == CommitValidators.Policy.NONE) {
        return;
    }
    try {
        RefControl refControl = projectControlFactory.controlFor(ctx.getProject(), ctx.getUser()).controlForRef(refName);
        String refName = psId.toRefName();
        CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commit.getId(), refName), refControl.getProjectControl().getProject(), change.getDest().get(), commit, ctx.getIdentifiedUser());
        commitValidatorsFactory.create(validatePolicy, refControl, new NoSshInfo(), ctx.getRepository()).validate(event);
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    } catch (NoSuchProjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
private void validate(RepoContext ctx) throws IOException, ResourceConflictException {
    if (!validate) {
        return;
    }
    PermissionBackend.ForRef perm = permissionBackend.user(ctx.getUser()).project(ctx.getProject()).ref(refName);
    try {
        try (CommitReceivedEvent event = new CommitReceivedEvent(cmd, projectState.getProject(), change.getDest().get(), ctx.getRevWalk().getObjectReader(), commitId, ctx.getIdentifiedUser())) {
            commitValidatorsFactory.forGerritCommits(perm, new Branch.NameKey(ctx.getProject(), refName), ctx.getIdentifiedUser(), new NoSshInfo(), ctx.getRevWalk()).validate(event);
        }
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    }
}
#end_block

#method_before
void setLimit(int n) {
    queryProcessor.setLimit(n);
}
#method_after
void setLimit(int n) {
    queryProcessor.setUserProvidedLimit(n);
}
#end_block

#method_before
private ChangeAttribute buildChangeAttribute(ChangeData d, Map<Project.NameKey, Repository> repos, Map<Project.NameKey, RevWalk> revWalks) throws OrmException, IOException {
    ChangeControl cc = d.changeControl().forUser(user);
    LabelTypes labelTypes = cc.getLabelTypes();
    ChangeAttribute c = eventFactory.asChangeAttribute(db, d.change());
    eventFactory.extend(c, d.change());
    if (!trackingFooters.isEmpty()) {
        eventFactory.addTrackingIds(c, trackingFooters.extract(d.commitFooters()));
    }
    if (includeAllReviewers) {
        eventFactory.addAllReviewers(db, c, d.notes());
    }
    if (includeSubmitRecords) {
        eventFactory.addSubmitRecords(c, new SubmitRuleEvaluator(d).setAllowClosed(true).evaluate());
    }
    if (includeCommitMessage) {
        eventFactory.addCommitMessage(c, d.commitMessage());
    }
    RevWalk rw = null;
    if (includePatchSets || includeCurrentPatchSet || includeDependencies) {
        Project.NameKey p = d.change().getProject();
        rw = revWalks.get(p);
        // Cache and reuse repos and revwalks.
        if (rw == null) {
            Repository repo = repoManager.openRepository(p);
            checkState(repos.put(p, repo) == null);
            rw = new RevWalk(repo);
            revWalks.put(p, rw);
        }
    }
    if (includePatchSets) {
        eventFactory.addPatchSets(db, rw, c, d.visiblePatchSets(), includeApprovals ? d.approvals().asMap() : null, includeFiles, d.change(), labelTypes);
    }
    if (includeCurrentPatchSet) {
        PatchSet current = d.currentPatchSet();
        if (current != null && cc.isPatchVisible(current, d.db())) {
            c.currentPatchSet = eventFactory.asPatchSetAttribute(db, rw, d.change(), current);
            eventFactory.addApprovals(c.currentPatchSet, d.currentApprovals(), labelTypes);
            if (includeFiles) {
                eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(), d.currentPatchSet());
            }
            if (includeComments) {
                eventFactory.addPatchSetComments(c.currentPatchSet, d.publishedComments());
            }
        }
    }
    if (includeComments) {
        eventFactory.addComments(c, d.messages());
        if (includePatchSets) {
            eventFactory.addPatchSets(db, rw, c, d.visiblePatchSets(), includeApprovals ? d.approvals().asMap() : null, includeFiles, d.change(), labelTypes);
            for (PatchSetAttribute attribute : c.patchSets) {
                eventFactory.addPatchSetComments(attribute, d.publishedComments());
            }
        }
    }
    if (includeDependencies) {
        eventFactory.addDependencies(rw, c, d.change(), d.currentPatchSet());
    }
    return c;
}
#method_after
private ChangeAttribute buildChangeAttribute(ChangeData d, Map<Project.NameKey, Repository> repos, Map<Project.NameKey, RevWalk> revWalks) throws OrmException, IOException {
    LabelTypes labelTypes = d.getLabelTypes();
    ChangeAttribute c = eventFactory.asChangeAttribute(db, d.change());
    eventFactory.extend(c, d.change());
    if (!trackingFooters.isEmpty()) {
        eventFactory.addTrackingIds(c, d.trackingFooters());
    }
    if (includeAllReviewers) {
        eventFactory.addAllReviewers(db, c, d.notes());
    }
    if (includeSubmitRecords) {
        eventFactory.addSubmitRecords(c, submitRuleEvaluatorFactory.create(user, d).setAllowClosed(true).evaluate());
    }
    if (includeCommitMessage) {
        eventFactory.addCommitMessage(c, d.commitMessage());
    }
    RevWalk rw = null;
    if (includePatchSets || includeCurrentPatchSet || includeDependencies) {
        Project.NameKey p = d.change().getProject();
        rw = revWalks.get(p);
        // Cache and reuse repos and revwalks.
        if (rw == null) {
            Repository repo = repoManager.openRepository(p);
            checkState(repos.put(p, repo) == null);
            rw = new RevWalk(repo);
            revWalks.put(p, rw);
        }
    }
    ChangeControl ctl = changeControlFactory.controlFor(db, d.change(), user);
    if (includePatchSets) {
        eventFactory.addPatchSets(db, rw, c, ctl.getVisiblePatchSets(d.patchSets(), db), includeApprovals ? d.approvals().asMap() : null, includeFiles, d.change(), labelTypes);
    }
    if (includeCurrentPatchSet) {
        PatchSet current = d.currentPatchSet();
        if (current != null && ctl.isVisible(d.db())) {
            c.currentPatchSet = eventFactory.asPatchSetAttribute(db, rw, d.change(), current);
            eventFactory.addApprovals(c.currentPatchSet, d.currentApprovals(), labelTypes);
            if (includeFiles) {
                eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(), d.currentPatchSet());
            }
            if (includeComments) {
                eventFactory.addPatchSetComments(c.currentPatchSet, d.publishedComments());
            }
        }
    }
    if (includeComments) {
        eventFactory.addComments(c, d.messages());
        if (includePatchSets) {
            eventFactory.addPatchSets(db, rw, c, ctl.getVisiblePatchSets(d.patchSets(), db), includeApprovals ? d.approvals().asMap() : null, includeFiles, d.change(), labelTypes);
            for (PatchSetAttribute attribute : c.patchSets) {
                eventFactory.addPatchSetComments(attribute, d.publishedComments());
            }
        }
    }
    if (includeDependencies) {
        eventFactory.addDependencies(rw, c, d.change(), d.currentPatchSet());
    }
    c.plugins = queryProcessor.create(d);
    return c;
}
#end_block

#method_before
public List<ReviewerInfo> format(Collection<ReviewerResource> rsrcs) throws OrmException {
    List<ReviewerInfo> infos = Lists.newArrayListWithCapacity(rsrcs.size());
    AccountLoader loader = accountLoaderFactory.create(true);
    for (ReviewerResource rsrc : rsrcs) {
        ReviewerInfo info = format(new ReviewerInfo(rsrc.getReviewerUser().getAccountId().get()), rsrc.getReviewerControl());
        loader.put(info);
        infos.add(info);
    }
    loader.fill();
    return infos;
}
#method_after
public List<ReviewerInfo> format(Collection<ReviewerResource> rsrcs) throws OrmException, PermissionBackendException {
    List<ReviewerInfo> infos = Lists.newArrayListWithCapacity(rsrcs.size());
    AccountLoader loader = accountLoaderFactory.create(true);
    ChangeData cd = null;
    for (ReviewerResource rsrc : rsrcs) {
        if (cd == null || !cd.getId().equals(rsrc.getChangeId())) {
            cd = changeDataFactory.create(db.get(), rsrc.getChangeResource().getNotes());
        }
        ReviewerInfo info = format(rsrc.getChangeResource().getUser(), new ReviewerInfo(rsrc.getReviewerUser().getAccountId().get()), permissionBackend.user(rsrc.getReviewerUser()).database(db).change(cd), cd);
        loader.put(info);
        infos.add(info);
    }
    loader.fill();
    return infos;
}
#end_block

#method_before
public List<ReviewerInfo> format(ReviewerResource rsrc) throws OrmException {
    return format(ImmutableList.<ReviewerResource>of(rsrc));
}
#method_after
public List<ReviewerInfo> format(ReviewerResource rsrc) throws OrmException, PermissionBackendException {
    return format(ImmutableList.<ReviewerResource>of(rsrc));
}
#end_block

#method_before
public ReviewerInfo format(ReviewerInfo out, ChangeControl ctl, Iterable<PatchSetApproval> approvals) throws OrmException {
    LabelTypes labelTypes = ctl.getLabelTypes();
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    out.approvals = new TreeMap<>(labelTypes.nameComparator());
    for (PatchSetApproval ca : approvals) {
        for (PermissionRange pr : ctl.getLabelRanges()) {
            if (!pr.isEmpty()) {
                LabelType at = labelTypes.byLabel(ca.getLabelId());
                if (at != null) {
                    out.approvals.put(at.getName(), formatValue(ca.getValue()));
                }
            }
        }
    }
    // Add dummy approvals for all permitted labels for the user even if they
    // do not exist in the DB.
    ChangeData cd = changeDataFactory.create(db.get(), ctl);
    PatchSet ps = cd.currentPatchSet();
    if (ps != null) {
        for (SubmitRecord rec : new SubmitRuleEvaluator(cd).setFastEvalLabels(true).evaluate()) {
            if (rec.labels == null) {
                continue;
            }
            for (SubmitRecord.Label label : rec.labels) {
                String name = label.label;
                if (!out.approvals.containsKey(name) && !ctl.getRange(Permission.forLabel(name)).isEmpty()) {
                    out.approvals.put(name, formatValue((short) 0));
                }
            }
        }
    }
    if (out.approvals.isEmpty()) {
        out.approvals = null;
    }
    return out;
}
#method_after
public ReviewerInfo format(CurrentUser user, ReviewerInfo out, PermissionBackend.ForChange perm, ChangeData cd) throws OrmException, PermissionBackendException {
    PatchSet.Id psId = cd.change().currentPatchSetId();
    return format(user, out, perm, cd, approvalsUtil.byPatchSetUser(db.get(), cd.notes(), perm.user(), psId, new Account.Id(out._accountId), null, null));
}
#end_block

#method_before
public static MailRecipients getRecipientsFromFooters(ReviewDb db, AccountResolver accountResolver, List<FooterLine> footerLines) throws OrmException {
    MailRecipients recipients = new MailRecipients();
    for (FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                recipients.reviewers.add(toAccountId(db, accountResolver, footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                recipients.cc.add(toAccountId(db, accountResolver, footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    return recipients;
}
#method_after
public static MailRecipients getRecipientsFromFooters(ReviewDb db, AccountResolver accountResolver, List<FooterLine> footerLines) throws OrmException, IOException {
    MailRecipients recipients = new MailRecipients();
    for (FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                recipients.reviewers.add(toAccountId(db, accountResolver, footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                recipients.cc.add(toAccountId(db, accountResolver, footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    return recipients;
}
#end_block

#method_before
private static Account.Id toAccountId(ReviewDb db, AccountResolver accountResolver, String nameOrEmail) throws OrmException, NoSuchAccountException {
    Account a = accountResolver.findByNameOrEmail(db, nameOrEmail);
    if (a == null) {
        throw new NoSuchAccountException("\"" + nameOrEmail + "\" is not registered");
    }
    return a.getId();
}
#method_after
private static Account.Id toAccountId(ReviewDb db, AccountResolver accountResolver, String nameOrEmail) throws OrmException, NoSuchAccountException, IOException {
    Account a = accountResolver.findByNameOrEmail(db, nameOrEmail);
    if (a == null) {
        throw new NoSuchAccountException("\"" + nameOrEmail + "\" is not registered");
    }
    return a.getId();
}
#end_block

#method_before
private static boolean isReviewer(final FooterLine candidateFooterLine) {
    return candidateFooterLine.matches(FooterKey.SIGNED_OFF_BY) || candidateFooterLine.matches(FooterKey.ACKED_BY) || candidateFooterLine.matches(FooterConstants.REVIEWED_BY) || candidateFooterLine.matches(FooterConstants.TESTED_BY);
}
#method_after
private static boolean isReviewer(FooterLine candidateFooterLine) {
    return candidateFooterLine.matches(FooterKey.SIGNED_OFF_BY) || candidateFooterLine.matches(FooterKey.ACKED_BY) || candidateFooterLine.matches(FooterConstants.REVIEWED_BY) || candidateFooterLine.matches(FooterConstants.TESTED_BY);
}
#end_block

#method_before
public void add(final MailRecipients recipients) {
    reviewers.addAll(recipients.reviewers);
    cc.addAll(recipients.cc);
}
#method_after
public void add(MailRecipients recipients) {
    reviewers.addAll(recipients.reviewers);
    cc.addAll(recipients.cc);
}
#end_block

#method_before
public void remove(final Account.Id toRemove) {
    reviewers.remove(toRemove);
    cc.remove(toRemove);
}
#method_after
public void remove(Account.Id toRemove) {
    reviewers.remove(toRemove);
    cc.remove(toRemove);
}
#end_block

#method_before
public Change.Id cherryPick(Change change, PatchSet patch, final String message, final String ref, final RefControl refControl, int parent) throws NoSuchChangeException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, IntegrationException, UpdateException, RestApiException {
    if (Strings.isNullOrEmpty(ref)) {
        throw new InvalidChangeOperationException("Cherry Pick: Destination branch cannot be null or empty");
    }
    Project.NameKey project = change.getProject();
    String destinationBranch = RefNames.shortName(ref);
    IdentifiedUser identifiedUser = user.get();
    try (Repository git = gitManager.openRepository(project);
        // before patch sets are updated.
        ObjectInserter oi = git.newObjectInserter();
        CodeReviewRevWalk revWalk = CodeReviewCommit.newRevWalk(oi.newReader())) {
        Ref destRef = git.getRefDatabase().exactRef(ref);
        if (destRef == null) {
            throw new InvalidChangeOperationException(String.format("Branch %s does not exist.", destinationBranch));
        }
        CodeReviewCommit mergeTip = revWalk.parseCommit(destRef.getObjectId());
        CodeReviewCommit commitToCherryPick = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        if (parent <= 0 || parent > commitToCherryPick.getParentCount()) {
            throw new InvalidChangeOperationException(String.format("Cherry Pick: Parent %s does not exist. Please specify a parent in" + " range [1, %s].", parent, commitToCherryPick.getParentCount()));
        }
        Timestamp now = TimeUtil.nowTs();
        PersonIdent committerIdent = identifiedUser.newCommitterIdent(now, serverTimeZone);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(commitToCherryPick.getTree(), mergeTip, commitToCherryPick.getAuthorIdent(), committerIdent, message);
        String commitMessage = ChangeIdUtil.insertId(message, computedChangeId).trim() + '\n';
        CodeReviewCommit cherryPickCommit;
        try {
            ProjectState projectState = refControl.getProjectControl().getProjectState();
            cherryPickCommit = mergeUtilFactory.create(projectState).createCherryPickFromCommit(git, oi, mergeTip, commitToCherryPick, committerIdent, commitMessage, revWalk, parent - 1, false);
            Change.Key changeKey;
            final List<String> idList = cherryPickCommit.getFooterLines(FooterConstants.CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                changeKey = new Change.Key(idStr);
            } else {
                changeKey = new Change.Key("I" + computedChangeId.name());
            }
            Branch.NameKey newDest = new Branch.NameKey(change.getProject(), destRef.getName());
            List<ChangeData> destChanges = queryProvider.get().setLimit(2).byBranchKey(newDest, changeKey);
            if (destChanges.size() > 1) {
                throw new InvalidChangeOperationException("Several changes with key " + changeKey + " reside on the same branch. " + "Cannot create a new patch set.");
            }
            try (BatchUpdate bu = batchUpdateFactory.create(db.get(), change.getDest().getParentKey(), identifiedUser, now)) {
                bu.setRepository(git, revWalk, oi);
                Change.Id result;
                if (destChanges.size() == 1) {
                    // The change key exists on the destination branch. The cherry pick
                    // will be added as a new patch set.
                    ChangeControl destCtl = refControl.getProjectControl().controlFor(destChanges.get(0).notes());
                    result = insertPatchSet(bu, git, destCtl, cherryPickCommit);
                } else {
                    // Change key not found on destination branch. We can create a new
                    // change.
                    String newTopic = null;
                    if (!Strings.isNullOrEmpty(change.getTopic())) {
                        newTopic = change.getTopic() + "-" + newDest.getShortName();
                    }
                    result = createNewChange(bu, cherryPickCommit, refControl.getRefName(), newTopic, change.getDest());
                    bu.addOp(change.getId(), new AddMessageToSourceChangeOp(changeMessagesUtil, patch.getId(), destinationBranch, cherryPickCommit));
                }
                bu.execute();
                return result;
            }
        } catch (MergeIdenticalTreeException | MergeConflictException e) {
            throw new IntegrationException("Cherry pick failed: " + e.getMessage());
        }
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(change.getId(), e);
    }
}
#method_after
public Change.Id cherryPick(BatchUpdate.Factory batchUpdateFactory, Change change, PatchSet patch, CherryPickInput input, Branch.NameKey dest) throws OrmException, IOException, InvalidChangeOperationException, IntegrationException, UpdateException, RestApiException, ConfigInvalidException, NoSuchProjectException {
    return cherryPick(batchUpdateFactory, change, patch.getId(), change.getProject(), ObjectId.fromString(patch.getRevision().get()), input, dest);
}
#end_block

#method_before
private Change.Id insertPatchSet(BatchUpdate bu, Repository git, ChangeControl destCtl, CodeReviewCommit cherryPickCommit) throws IOException {
    Change destChange = destCtl.getChange();
    PatchSet.Id psId = ChangeUtil.nextPatchSetId(git, destChange.currentPatchSetId());
    PatchSetInserter inserter = patchSetInserterFactory.create(destCtl, psId, cherryPickCommit);
    PatchSet.Id newPatchSetId = inserter.getPatchSetId();
    bu.addOp(destChange.getId(), inserter.setMessage("Uploaded patch set " + newPatchSetId.get() + ".").setNotify(NotifyHandling.NONE));
    return destChange.getId();
}
#method_after
private Change.Id insertPatchSet(BatchUpdate bu, Repository git, ChangeNotes destNotes, CodeReviewCommit cherryPickCommit, CherryPickInput input) throws IOException, OrmException, BadRequestException, ConfigInvalidException {
    Change destChange = destNotes.getChange();
    PatchSet.Id psId = ChangeUtil.nextPatchSetId(git, destChange.currentPatchSetId());
    PatchSetInserter inserter = patchSetInserterFactory.create(destNotes, psId, cherryPickCommit);
    inserter.setMessage("Uploaded patch set " + inserter.getPatchSetId().get() + ".").setNotify(input.notify).setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
    bu.addOp(destChange.getId(), inserter);
    return destChange.getId();
}
#end_block

#method_before
private Change.Id createNewChange(BatchUpdate bu, CodeReviewCommit cherryPickCommit, String refName, String topic, Branch.NameKey sourceBranch) throws OrmException {
    Change.Id changeId = new Change.Id(seq.nextChangeId());
    ChangeInserter ins = changeInserterFactory.create(changeId, cherryPickCommit, refName).setValidatePolicy(CommitValidators.Policy.GERRIT).setTopic(topic);
    ins.setMessage(messageForDestinationChange(ins.getPatchSetId(), sourceBranch));
    bu.insertChange(ins);
    return changeId;
}
#method_after
private Change.Id createNewChange(BatchUpdate bu, CodeReviewCommit cherryPickCommit, String refName, String topic, @Nullable Change sourceChange, ObjectId sourceCommit, CherryPickInput input) throws OrmException, IOException, BadRequestException, ConfigInvalidException {
    Change.Id changeId = new Change.Id(seq.nextChangeId());
    ChangeInserter ins = changeInserterFactory.create(changeId, cherryPickCommit, refName);
    Branch.NameKey sourceBranch = sourceChange == null ? null : sourceChange.getDest();
    ins.setMessage(messageForDestinationChange(ins.getPatchSetId(), sourceBranch, sourceCommit)).setTopic(topic).setNotify(input.notify).setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
    if (input.keepReviewers && sourceChange != null) {
        ReviewerSet reviewerSet = approvalsUtil.getReviewers(dbProvider.get(), changeNotesFactory.createChecked(dbProvider.get(), sourceChange));
        Set<Account.Id> reviewers = new HashSet<>(reviewerSet.byState(ReviewerStateInternal.REVIEWER));
        reviewers.add(sourceChange.getOwner());
        reviewers.remove(user.get().getAccountId());
        Set<Account.Id> ccs = new HashSet<>(reviewerSet.byState(ReviewerStateInternal.CC));
        ccs.remove(user.get().getAccountId());
        ins.setReviewers(reviewers).setExtraCC(ccs);
    }
    bu.insertChange(ins);
    return changeId;
}
#end_block

#method_before
private String messageForDestinationChange(PatchSet.Id patchSetId, Branch.NameKey sourceBranch) {
    return new StringBuilder("Patch Set ").append(patchSetId.get()).append(": Cherry Picked from branch ").append(sourceBranch.getShortName()).append(".").toString();
}
#method_after
private String messageForDestinationChange(PatchSet.Id patchSetId, Branch.NameKey sourceBranch, ObjectId sourceCommit) {
    StringBuilder stringBuilder = new StringBuilder("Patch Set ").append(patchSetId.get());
    if (sourceBranch != null) {
        stringBuilder.append(": Cherry Picked from branch ").append(sourceBranch.getShortName());
    } else {
        stringBuilder.append(": Cherry Picked from commit ").append(sourceCommit.getName());
    }
    return stringBuilder.append(".").toString();
}
#end_block

#method_before
protected void setUpDatabase() throws Exception {
    db = schemaFactory.open();
    schemaCreator.create(db);
    userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    Account userAccount = db.accounts().get(userId);
    userAccount.setPreferredEmail("user@example.com");
    db.accounts().update(ImmutableList.of(userAccount));
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userAccount.getId()));
}
#method_after
protected void setUpDatabase() throws Exception {
    try (ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) {
        schemaCreator.create(underlyingDb);
    }
    db = schemaFactory.open();
    userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    String email = "user@example.com";
    externalIdsUpdate.create().insert(ExternalId.createEmail(userId, email));
    accountsUpdate.create().update(userId, a -> a.setPreferredEmail(email));
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userId));
}
#end_block

#method_before
@After
public void tearDownInjector() {
    if (lifecycle != null) {
        lifecycle.stop();
    }
    requestContext.setContext(null);
    if (db != null) {
        db.close();
    }
    InMemoryDatabase.drop(schemaFactory);
}
#method_after
@After
public void tearDownInjector() {
    if (lifecycle != null) {
        lifecycle.stop();
    }
    requestContext.setContext(null);
    if (db != null) {
        db.close();
    }
    InMemoryDatabase.drop(inMemoryDatabase);
}
#end_block

#method_before
@Test
public void byTriplet() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change = insert(repo, newChangeForBranch(repo, "branch"));
    String k = change.getKey().get();
    assertQuery("repo~branch~" + k, change);
    assertQuery("change:repo~branch~" + k, change);
    assertQuery("repo~refs/heads/branch~" + k, change);
    assertQuery("change:repo~refs/heads/branch~" + k, change);
    assertQuery("repo~branch~" + k.substring(0, 10), change);
    assertQuery("change:repo~branch~" + k.substring(0, 10), change);
    assertQuery("foo~bar");
    assertThatQueryException("change:foo~bar").hasMessage("Invalid change format");
    assertQuery("otherrepo~branch~" + k);
    assertQuery("change:otherrepo~branch~" + k);
    assertQuery("repo~otherbranch~" + k);
    assertQuery("change:repo~otherbranch~" + k);
    assertQuery("repo~branch~I0000000000000000000000000000000000000000");
    assertQuery("change:repo~branch~I0000000000000000000000000000000000000000");
}
#method_after
@Test
public void byTriplet() throws Exception {
    TestRepository<Repo> repo = createProject("iabcde");
    Change change = insert(repo, newChangeForBranch(repo, "branch"));
    String k = change.getKey().get();
    assertQuery("iabcde~branch~" + k, change);
    assertQuery("change:iabcde~branch~" + k, change);
    assertQuery("iabcde~refs/heads/branch~" + k, change);
    assertQuery("change:iabcde~refs/heads/branch~" + k, change);
    assertQuery("iabcde~branch~" + k.substring(0, 10), change);
    assertQuery("change:iabcde~branch~" + k.substring(0, 10), change);
    assertQuery("foo~bar");
    assertThatQueryException("change:foo~bar").hasMessageThat().isEqualTo("Invalid change format");
    assertQuery("otherrepo~branch~" + k);
    assertQuery("change:otherrepo~branch~" + k);
    assertQuery("iabcde~otherbranch~" + k);
    assertQuery("change:iabcde~otherbranch~" + k);
    assertQuery("iabcde~branch~I0000000000000000000000000000000000000000");
    assertQuery("change:iabcde~branch~I0000000000000000000000000000000000000000");
}
#end_block

#method_before
@Test
public void byStatusOpen() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    ChangeInserter ins2 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change2 = insert(repo, ins2);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    Change[] expected = new Change[] { change2, change1 };
    assertQuery("status:open", expected);
    assertQuery("status:OPEN", expected);
    assertQuery("status:o", expected);
    assertQuery("status:op", expected);
    assertQuery("status:ope", expected);
    assertQuery("status:pending", expected);
    assertQuery("status:PENDING", expected);
    assertQuery("status:p", expected);
    assertQuery("status:pe", expected);
    assertQuery("status:pen", expected);
    assertQuery("is:open", expected);
}
#method_after
@Test
public void byStatusOpen() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    Change[] expected = new Change[] { change1 };
    assertQuery("status:open", expected);
    assertQuery("status:OPEN", expected);
    assertQuery("status:o", expected);
    assertQuery("status:op", expected);
    assertQuery("status:ope", expected);
    assertQuery("status:pending", expected);
    assertQuery("status:PENDING", expected);
    assertQuery("status:p", expected);
    assertQuery("status:pe", expected);
    assertQuery("status:pen", expected);
    assertQuery("is:open", expected);
}
#end_block

#method_before
@Test
public void byStatusPrefix() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    assertQuery("status:n", change1);
    assertQuery("status:ne", change1);
    assertQuery("status:new", change1);
    assertQuery("status:N", change1);
    assertQuery("status:nE", change1);
    assertQuery("status:neW", change1);
    assertThatQueryException("status:nx").hasMessage("invalid change status: nx");
    assertThatQueryException("status:newx").hasMessage("invalid change status: newx");
}
#method_after
@Test
public void byStatusPrefix() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    assertQuery("status:n", change1);
    assertQuery("status:ne", change1);
    assertQuery("status:new", change1);
    assertQuery("status:N", change1);
    assertQuery("status:nE", change1);
    assertQuery("status:neW", change1);
    assertThatQueryException("status:nx").hasMessageThat().isEqualTo("invalid change status: nx");
    assertThatQueryException("status:newx").hasMessageThat().isEqualTo("invalid change status: newx");
}
#end_block

#method_before
@Test
public void byCommit() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins = newChange(repo);
    insert(repo, ins);
    String sha = ins.getCommit().name();
    assertQuery("0000000000000000000000000000000000000000");
    for (int i = 0; i <= 36; i++) {
        String q = sha.substring(0, 40 - i);
        assertQuery(q, ins.getChange());
    }
}
#method_after
@Test
public void byCommit() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins = newChange(repo);
    insert(repo, ins);
    String sha = ins.getCommitId().name();
    assertQuery("0000000000000000000000000000000000000000");
    for (int i = 0; i <= 36; i++) {
        String q = sha.substring(0, 40 - i);
        assertQuery(q, ins.getChange());
    }
}
#end_block

#method_before
@Test
public void byLabel() throws Exception {
    accountManager.authenticate(AuthRequest.forUser("anotheruser"));
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins = newChange(repo, null, null, null, null);
    ChangeInserter ins2 = newChange(repo, null, null, null, null);
    ChangeInserter ins3 = newChange(repo, null, null, null, null);
    ChangeInserter ins4 = newChange(repo, null, null, null, null);
    ChangeInserter ins5 = newChange(repo, null, null, null, null);
    Change reviewMinus2Change = insert(repo, ins);
    gApi.changes().id(reviewMinus2Change.getId().get()).current().review(ReviewInput.reject());
    Change reviewMinus1Change = insert(repo, ins2);
    gApi.changes().id(reviewMinus1Change.getId().get()).current().review(ReviewInput.dislike());
    Change noLabelChange = insert(repo, ins3);
    Change reviewPlus1Change = insert(repo, ins4);
    gApi.changes().id(reviewPlus1Change.getId().get()).current().review(ReviewInput.recommend());
    Change reviewPlus2Change = insert(repo, ins5);
    gApi.changes().id(reviewPlus2Change.getId().get()).current().review(ReviewInput.approve());
    Map<String, Short> m = gApi.changes().id(reviewPlus1Change.getId().get()).reviewer(user.getAccountId().toString()).votes();
    assertThat(m).hasSize(1);
    assertThat(m).containsEntry("Code-Review", Short.valueOf((short) 1));
    Map<Integer, Change> changes = new LinkedHashMap<>(5);
    changes.put(2, reviewPlus2Change);
    changes.put(1, reviewPlus1Change);
    changes.put(0, noLabelChange);
    changes.put(-1, reviewMinus1Change);
    changes.put(-2, reviewMinus2Change);
    assertQuery("label:Code-Review=-2", reviewMinus2Change);
    assertQuery("label:Code-Review-2", reviewMinus2Change);
    assertQuery("label:Code-Review=-1", reviewMinus1Change);
    assertQuery("label:Code-Review-1", reviewMinus1Change);
    assertQuery("label:Code-Review=0", noLabelChange);
    assertQuery("label:Code-Review=+1", reviewPlus1Change);
    assertQuery("label:Code-Review=1", reviewPlus1Change);
    assertQuery("label:Code-Review+1", reviewPlus1Change);
    assertQuery("label:Code-Review=+2", reviewPlus2Change);
    assertQuery("label:Code-Review=2", reviewPlus2Change);
    assertQuery("label:Code-Review+2", reviewPlus2Change);
    assertQuery("label:Code-Review>-3", codeReviewInRange(changes, -2, 2));
    assertQuery("label:Code-Review>=-2", codeReviewInRange(changes, -2, 2));
    assertQuery("label:Code-Review>-2", codeReviewInRange(changes, -1, 2));
    assertQuery("label:Code-Review>=-1", codeReviewInRange(changes, -1, 2));
    assertQuery("label:Code-Review>-1", codeReviewInRange(changes, 0, 2));
    assertQuery("label:Code-Review>=0", codeReviewInRange(changes, 0, 2));
    assertQuery("label:Code-Review>0", codeReviewInRange(changes, 1, 2));
    assertQuery("label:Code-Review>=1", codeReviewInRange(changes, 1, 2));
    assertQuery("label:Code-Review>1", reviewPlus2Change);
    assertQuery("label:Code-Review>=2", reviewPlus2Change);
    assertQuery("label:Code-Review>2");
    assertQuery("label:Code-Review<=2", codeReviewInRange(changes, -2, 2));
    assertQuery("label:Code-Review<2", codeReviewInRange(changes, -2, 1));
    assertQuery("label:Code-Review<=1", codeReviewInRange(changes, -2, 1));
    assertQuery("label:Code-Review<1", codeReviewInRange(changes, -2, 0));
    assertQuery("label:Code-Review<=0", codeReviewInRange(changes, -2, 0));
    assertQuery("label:Code-Review<0", codeReviewInRange(changes, -2, -1));
    assertQuery("label:Code-Review<=-1", codeReviewInRange(changes, -2, -1));
    assertQuery("label:Code-Review<-1", reviewMinus2Change);
    assertQuery("label:Code-Review<=-2", reviewMinus2Change);
    assertQuery("label:Code-Review<-2");
    assertQuery("label:Code-Review=+1,anotheruser");
    assertQuery("label:Code-Review=+1,user", reviewPlus1Change);
    assertQuery("label:Code-Review=+1,user=user", reviewPlus1Change);
    assertQuery("label:Code-Review=+1,Administrators", reviewPlus1Change);
    assertQuery("label:Code-Review=+1,group=Administrators", reviewPlus1Change);
    assertQuery("label:Code-Review=+1,user=owner", reviewPlus1Change);
    assertQuery("label:Code-Review=+1,owner", reviewPlus1Change);
    assertQuery("label:Code-Review=+2,owner", reviewPlus2Change);
    assertQuery("label:Code-Review=-2,owner", reviewMinus2Change);
}
#method_after
@Test
public void byLabel() throws Exception {
    accountManager.authenticate(AuthRequest.forUser("anotheruser"));
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins = newChange(repo, null, null, null, null, false);
    ChangeInserter ins2 = newChange(repo, null, null, null, null, false);
    ChangeInserter ins3 = newChange(repo, null, null, null, null, false);
    ChangeInserter ins4 = newChange(repo, null, null, null, null, false);
    ChangeInserter ins5 = newChange(repo, null, null, null, null, false);
    Change reviewMinus2Change = insert(repo, ins);
    gApi.changes().id(reviewMinus2Change.getId().get()).current().review(ReviewInput.reject());
    Change reviewMinus1Change = insert(repo, ins2);
    gApi.changes().id(reviewMinus1Change.getId().get()).current().review(ReviewInput.dislike());
    Change noLabelChange = insert(repo, ins3);
    Change reviewPlus1Change = insert(repo, ins4);
    gApi.changes().id(reviewPlus1Change.getId().get()).current().review(ReviewInput.recommend());
    Change reviewPlus2Change = insert(repo, ins5);
    gApi.changes().id(reviewPlus2Change.getId().get()).current().review(ReviewInput.approve());
    Map<String, Short> m = gApi.changes().id(reviewPlus1Change.getId().get()).reviewer(user.getAccountId().toString()).votes();
    assertThat(m).hasSize(1);
    assertThat(m).containsEntry("Code-Review", Short.valueOf((short) 1));
    Map<Integer, Change> changes = new LinkedHashMap<>(5);
    changes.put(2, reviewPlus2Change);
    changes.put(1, reviewPlus1Change);
    changes.put(0, noLabelChange);
    changes.put(-1, reviewMinus1Change);
    changes.put(-2, reviewMinus2Change);
    assertQuery("label:Code-Review=-2", reviewMinus2Change);
    assertQuery("label:Code-Review-2", reviewMinus2Change);
    assertQuery("label:Code-Review=-1", reviewMinus1Change);
    assertQuery("label:Code-Review-1", reviewMinus1Change);
    assertQuery("label:Code-Review=0", noLabelChange);
    assertQuery("label:Code-Review=+1", reviewPlus1Change);
    assertQuery("label:Code-Review=1", reviewPlus1Change);
    assertQuery("label:Code-Review+1", reviewPlus1Change);
    assertQuery("label:Code-Review=+2", reviewPlus2Change);
    assertQuery("label:Code-Review=2", reviewPlus2Change);
    assertQuery("label:Code-Review+2", reviewPlus2Change);
    assertQuery("label:Code-Review>-3", codeReviewInRange(changes, -2, 2));
    assertQuery("label:Code-Review>=-2", codeReviewInRange(changes, -2, 2));
    assertQuery("label:Code-Review>-2", codeReviewInRange(changes, -1, 2));
    assertQuery("label:Code-Review>=-1", codeReviewInRange(changes, -1, 2));
    assertQuery("label:Code-Review>-1", codeReviewInRange(changes, 0, 2));
    assertQuery("label:Code-Review>=0", codeReviewInRange(changes, 0, 2));
    assertQuery("label:Code-Review>0", codeReviewInRange(changes, 1, 2));
    assertQuery("label:Code-Review>=1", codeReviewInRange(changes, 1, 2));
    assertQuery("label:Code-Review>1", reviewPlus2Change);
    assertQuery("label:Code-Review>=2", reviewPlus2Change);
    assertQuery("label:Code-Review>2");
    assertQuery("label:Code-Review<=2", codeReviewInRange(changes, -2, 2));
    assertQuery("label:Code-Review<2", codeReviewInRange(changes, -2, 1));
    assertQuery("label:Code-Review<=1", codeReviewInRange(changes, -2, 1));
    assertQuery("label:Code-Review<1", codeReviewInRange(changes, -2, 0));
    assertQuery("label:Code-Review<=0", codeReviewInRange(changes, -2, 0));
    assertQuery("label:Code-Review<0", codeReviewInRange(changes, -2, -1));
    assertQuery("label:Code-Review<=-1", codeReviewInRange(changes, -2, -1));
    assertQuery("label:Code-Review<-1", reviewMinus2Change);
    assertQuery("label:Code-Review<=-2", reviewMinus2Change);
    assertQuery("label:Code-Review<-2");
    assertQuery("label:Code-Review=+1,anotheruser");
    assertQuery("label:Code-Review=+1,user", reviewPlus1Change);
    assertQuery("label:Code-Review=+1,user=user", reviewPlus1Change);
    assertQuery("label:Code-Review=+1,Administrators", reviewPlus1Change);
    assertQuery("label:Code-Review=+1,group=Administrators", reviewPlus1Change);
    assertQuery("label:Code-Review=+1,user=owner", reviewPlus1Change);
    assertQuery("label:Code-Review=+1,owner", reviewPlus1Change);
    assertQuery("label:Code-Review=+2,owner", reviewPlus2Change);
    assertQuery("label:Code-Review=-2,owner", reviewMinus2Change);
}
#end_block

#method_before
@Test
public void byLabelNotOwner() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins = newChange(repo, null, null, null, null);
    Account.Id user1 = createAccount("user1");
    Change reviewPlus1Change = insert(repo, ins);
    // post a review with user1
    requestContext.setContext(newRequestContext(user1));
    gApi.changes().id(reviewPlus1Change.getId().get()).current().review(ReviewInput.recommend());
    assertQuery("label:Code-Review=+1,user=user1", reviewPlus1Change);
    assertQuery("label:Code-Review=+1,owner");
}
#method_after
@Test
public void byLabelNotOwner() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins = newChange(repo, null, null, null, null, false);
    Account.Id user1 = createAccount("user1");
    Change reviewPlus1Change = insert(repo, ins);
    // post a review with user1
    requestContext.setContext(newRequestContext(user1));
    gApi.changes().id(reviewPlus1Change.getId().get()).current().review(ReviewInput.recommend());
    assertQuery("label:Code-Review=+1,user=user1", reviewPlus1Change);
    assertQuery("label:Code-Review=+1,owner");
}
#end_block

#method_before
@Test
public void maxPages() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change = insert(repo, newChange(repo));
    QueryRequest query = newQuery("status:new").withLimit(10);
    assertQuery(query, change);
    assertQuery(query.withStart(1));
    assertQuery(query.withStart(99));
    assertThatQueryException(query.withStart(100)).hasMessage("Cannot go beyond page 10 of results");
    assertQuery(query.withLimit(100).withStart(100));
}
#method_after
@Test
public void maxPages() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change = insert(repo, newChange(repo));
    QueryRequest query = newQuery("status:new").withLimit(10);
    assertQuery(query, change);
    assertQuery(query.withStart(1));
    assertQuery(query.withStart(99));
    assertThatQueryException(query.withStart(100)).hasMessageThat().isEqualTo("Cannot go beyond page 10 of results");
    assertQuery(query.withLimit(100).withStart(100));
}
#end_block

#method_before
@Test
public void byStar() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo));
    Change change2 = insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    gApi.accounts().self().setStars(change1.getId().toString(), new StarsInput(new HashSet<>(Arrays.asList("red", "blue"))));
    gApi.accounts().self().setStars(change2.getId().toString(), new StarsInput(new HashSet<>(Arrays.asList(StarredChangesUtil.DEFAULT_LABEL, "green", "blue"))));
    // check labeled stars
    assertQuery("star:red", change1);
    assertQuery("star:blue", change2, change1);
    assertQuery("has:stars", change2, change1);
    // check default star
    assertQuery("has:star", change2);
    assertQuery("is:starred", change2);
    assertQuery("starredby:self", change2);
    assertQuery("star:" + StarredChangesUtil.DEFAULT_LABEL, change2);
}
#method_after
@Test
public void byStar() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo));
    Change change2 = insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    Change change3 = insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    Change change4 = insert(repo, newChange(repo));
    gApi.accounts().self().setStars(change1.getId().toString(), new StarsInput(new HashSet<>(Arrays.asList("red", "blue"))));
    gApi.accounts().self().setStars(change2.getId().toString(), new StarsInput(new HashSet<>(Arrays.asList(StarredChangesUtil.DEFAULT_LABEL, "green", "blue"))));
    gApi.accounts().self().setStars(change4.getId().toString(), new StarsInput(new HashSet<>(Arrays.asList("ignore"))));
    // check labeled stars
    assertQuery("star:red", change1);
    assertQuery("star:blue", change2, change1);
    assertQuery("has:stars", change4, change2, change1);
    // check default star
    assertQuery("has:star", change2);
    assertQuery("is:starred", change2);
    assertQuery("starredby:self", change2);
    assertQuery("star:" + StarredChangesUtil.DEFAULT_LABEL, change2);
    // check ignored
    assertQuery("is:ignored", change4);
    assertQuery("-is:ignored", change3, change2, change1);
}
#end_block

#method_before
@Test
public void byCommitsOnBranchNotMerged() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    int n = 10;
    List<String> shas = new ArrayList<>(n);
    List<Integer> expectedIds = new ArrayList<>(n);
    Branch.NameKey dest = null;
    for (int i = 0; i < n; i++) {
        ChangeInserter ins = newChange(repo);
        insert(repo, ins);
        if (dest == null) {
            dest = ins.getChange().getDest();
        }
        shas.add(ins.getCommit().name());
        expectedIds.add(ins.getChange().getId().get());
    }
    for (int i = 1; i <= 11; i++) {
        Iterable<ChangeData> cds = internalChangeQuery.byCommitsOnBranchNotMerged(repo.getRepository(), db, dest, shas, i);
        Iterable<Integer> ids = FluentIterable.from(cds).transform(in -> in.getId().get());
        String name = "limit " + i;
        assertThat(ids).named(name).hasSize(n);
        assertThat(ids).named(name).containsExactlyElementsIn(expectedIds);
    }
}
#method_after
@Test
public void byCommitsOnBranchNotMerged() throws Exception {
    TestRepository<Repo> tr = createProject("repo");
    testByCommitsOnBranchNotMerged(tr, ImmutableSet.of());
}
#end_block

#method_before
@Test
public void prepopulatedFields() throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    TestRepository<Repo> repo = createProject("repo");
    Change change = insert(repo, newChange(repo));
    db = new DisabledReviewDb();
    requestContext.setContext(newRequestContext(userId));
    // Use QueryProcessor directly instead of API so we get ChangeDatas back.
    List<ChangeData> cds = queryProcessor.query(queryBuilder.parse(change.getId().toString())).entities();
    assertThat(cds).hasSize(1);
    ChangeData cd = cds.get(0);
    cd.change();
    cd.patchSets();
    cd.currentApprovals();
    cd.changedLines();
    cd.reviewedBy();
    cd.reviewers();
    cd.unresolvedCommentCount();
    // TODO(dborowitz): Swap out GitRepositoryManager somehow? Will probably be
    // necessary for NoteDb anyway.
    cd.isMergeable();
    exception.expect(DisabledReviewDb.Disabled.class);
    cd.messages();
}
#method_after
@Test
public void prepopulatedFields() throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    TestRepository<Repo> repo = createProject("repo");
    Change change = insert(repo, newChange(repo));
    db = new DisabledReviewDb();
    requestContext.setContext(newRequestContext(userId));
    // Use QueryProcessor directly instead of API so we get ChangeDatas back.
    List<ChangeData> cds = queryProcessorProvider.get().query(queryBuilder.parse(change.getId().toString())).entities();
    assertThat(cds).hasSize(1);
    ChangeData cd = cds.get(0);
    cd.change();
    cd.patchSets();
    cd.currentApprovals();
    cd.changedLines();
    cd.reviewedBy();
    cd.reviewers();
    cd.unresolvedCommentCount();
    // TODO(dborowitz): Swap out GitRepositoryManager somehow? Will probably be
    // necessary for NoteDb anyway.
    cd.isMergeable();
    exception.expect(DisabledReviewDb.Disabled.class);
    cd.messages();
}
#end_block

#method_before
@Test
public void prepopulateOnlyRequestedFields() throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    TestRepository<Repo> repo = createProject("repo");
    Change change = insert(repo, newChange(repo));
    db = new DisabledReviewDb();
    requestContext.setContext(newRequestContext(userId));
    // Use QueryProcessor directly instead of API so we get ChangeDatas back.
    List<ChangeData> cds = queryProcessor.setRequestedFields(ImmutableSet.of(ChangeField.PATCH_SET.getName(), ChangeField.CHANGE.getName())).query(queryBuilder.parse(change.getId().toString())).entities();
    assertThat(cds).hasSize(1);
    ChangeData cd = cds.get(0);
    cd.change();
    cd.patchSets();
    exception.expect(DisabledReviewDb.Disabled.class);
    cd.currentApprovals();
}
#method_after
@Test
public void prepopulateOnlyRequestedFields() throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    TestRepository<Repo> repo = createProject("repo");
    Change change = insert(repo, newChange(repo));
    db = new DisabledReviewDb();
    requestContext.setContext(newRequestContext(userId));
    // Use QueryProcessor directly instead of API so we get ChangeDatas back.
    List<ChangeData> cds = queryProcessorProvider.get().setRequestedFields(ImmutableSet.of(ChangeField.PATCH_SET.getName(), ChangeField.CHANGE.getName())).query(queryBuilder.parse(change.getId().toString())).entities();
    assertThat(cds).hasSize(1);
    ChangeData cd = cds.get(0);
    cd.change();
    cd.patchSets();
    exception.expect(DisabledReviewDb.Disabled.class);
    cd.currentApprovals();
}
#end_block

#method_before
protected ChangeInserter newChange(TestRepository<Repo> repo) throws Exception {
    return newChange(repo, null, null, null, null);
}
#method_after
protected ChangeInserter newChange(TestRepository<Repo> repo) throws Exception {
    return newChange(repo, null, null, null, null, false);
}
#end_block

#method_before
protected ChangeInserter newChangeForCommit(TestRepository<Repo> repo, RevCommit commit) throws Exception {
    return newChange(repo, commit, null, null, null);
}
#method_after
protected ChangeInserter newChangeForCommit(TestRepository<Repo> repo, RevCommit commit) throws Exception {
    return newChange(repo, commit, null, null, null, false);
}
#end_block

#method_before
protected ChangeInserter newChangeForBranch(TestRepository<Repo> repo, String branch) throws Exception {
    return newChange(repo, null, branch, null, null);
}
#method_after
protected ChangeInserter newChangeForBranch(TestRepository<Repo> repo, String branch) throws Exception {
    return newChange(repo, null, branch, null, null, false);
}
#end_block

#method_before
protected ChangeInserter newChangeWithStatus(TestRepository<Repo> repo, Change.Status status) throws Exception {
    return newChange(repo, null, null, status, null);
}
#method_after
protected ChangeInserter newChangeWithStatus(TestRepository<Repo> repo, Change.Status status) throws Exception {
    return newChange(repo, null, null, status, null, false);
}
#end_block

#method_before
protected ChangeInserter newChangeWithTopic(TestRepository<Repo> repo, String topic) throws Exception {
    return newChange(repo, null, null, null, topic);
}
#method_after
protected ChangeInserter newChangeWithTopic(TestRepository<Repo> repo, String topic) throws Exception {
    return newChange(repo, null, null, null, topic, false);
}
#end_block

#method_before
protected ChangeInserter newChange(TestRepository<Repo> repo, @Nullable RevCommit commit, @Nullable String branch, @Nullable Change.Status status, @Nullable String topic) throws Exception {
    if (commit == null) {
        commit = repo.parseBody(repo.commit().message("message").create());
    }
    branch = MoreObjects.firstNonNull(branch, "refs/heads/master");
    if (!branch.startsWith("refs/heads/")) {
        branch = "refs/heads/" + branch;
    }
    Change.Id id = new Change.Id(seq.nextChangeId());
    ChangeInserter ins = changeFactory.create(id, commit, branch).setValidatePolicy(CommitValidators.Policy.NONE).setStatus(status).setTopic(topic);
    return ins;
}
#method_after
protected ChangeInserter newChange(TestRepository<Repo> repo, @Nullable RevCommit commit, @Nullable String branch, @Nullable Change.Status status, @Nullable String topic, boolean workInProgress) throws Exception {
    if (commit == null) {
        commit = repo.parseBody(repo.commit().message("message").create());
    }
    branch = MoreObjects.firstNonNull(branch, "refs/heads/master");
    if (!branch.startsWith("refs/heads/")) {
        branch = "refs/heads/" + branch;
    }
    Change.Id id = new Change.Id(seq.nextChangeId());
    ChangeInserter ins = changeFactory.create(id, commit, branch).setValidate(false).setStatus(status).setTopic(topic).setWorkInProgress(workInProgress);
    return ins;
}
#end_block

#method_before
protected Change newPatchSet(TestRepository<Repo> repo, Change c) throws Exception {
    // Add a new file so the patch set is not a trivial rebase, to avoid default
    // Code-Review label copying.
    int n = c.currentPatchSetId().get() + 1;
    RevCommit commit = repo.parseBody(repo.commit().message("message").add("file" + n, "contents " + n).create());
    ChangeControl ctl = changeControlFactory.controlFor(db, c, user);
    PatchSetInserter inserter = patchSetFactory.create(ctl, new PatchSet.Id(c.getId(), n), commit).setNotify(NotifyHandling.NONE).setFireRevisionCreated(false).setValidatePolicy(CommitValidators.Policy.NONE);
    try (BatchUpdate bu = updateFactory.create(db, c.getProject(), user, TimeUtil.nowTs());
        ObjectInserter oi = repo.getRepository().newObjectInserter()) {
        bu.setRepository(repo.getRepository(), repo.getRevWalk(), oi);
        bu.addOp(c.getId(), inserter);
        bu.execute();
    }
    return inserter.getChange();
}
#method_after
protected Change newPatchSet(TestRepository<Repo> repo, Change c) throws Exception {
    // Add a new file so the patch set is not a trivial rebase, to avoid default
    // Code-Review label copying.
    int n = c.currentPatchSetId().get() + 1;
    RevCommit commit = repo.parseBody(repo.commit().message("message").add("file" + n, "contents " + n).create());
    PatchSetInserter inserter = patchSetFactory.create(changeNotesFactory.createChecked(db, c), new PatchSet.Id(c.getId(), n), commit).setNotify(NotifyHandling.NONE).setFireRevisionCreated(false).setValidate(false);
    try (BatchUpdate bu = updateFactory.create(db, c.getProject(), user, TimeUtil.nowTs());
        ObjectInserter oi = repo.getRepository().newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo.getRepository(), rw, oi);
        bu.addOp(c.getId(), inserter);
        bu.execute();
    }
    return inserter.getChange();
}
#end_block

#method_before
protected List<ChangeInfo> assertQuery(QueryRequest query, Change... changes) throws Exception {
    List<ChangeInfo> result = query.get();
    Iterable<Integer> ids = ids(result);
    assertThat(ids).named(format(query, ids, changes)).containsExactlyElementsIn(ids(changes)).inOrder();
    return result;
}
#method_after
protected List<ChangeInfo> assertQuery(QueryRequest query, Change... changes) throws Exception {
    return assertQueryByIds(query, Arrays.stream(changes).map(Change::getId).toArray(Change.Id[]::new));
}
#end_block

#method_before
private String format(Iterator<Integer> changeIds) throws RestApiException {
    StringBuilder b = new StringBuilder();
    b.append("[");
    while (changeIds.hasNext()) {
        int id = changeIds.next();
        ChangeInfo c = gApi.changes().id(id).get();
        b.append("{").append(id).append(" (").append(c.changeId).append("), ").append("dest=").append(new Branch.NameKey(new Project.NameKey(c.project), c.branch)).append(", ").append("status=").append(c.status).append(", ").append("lastUpdated=").append(c.updated.getTime()).append("}");
        if (changeIds.hasNext()) {
            b.append(", ");
        }
    }
    b.append("]");
    return b.toString();
}
#method_after
private String format(QueryRequest query, Iterable<Change.Id> actualIds, Change.Id... expectedChanges) throws RestApiException {
    StringBuilder b = new StringBuilder();
    b.append("query '").append(query.getQuery()).append("' with expected changes ");
    b.append(format(Arrays.asList(expectedChanges)));
    b.append(" and result ");
    b.append(format(actualIds));
    return b.toString();
}
#end_block

#method_before
protected static Iterable<Integer> ids(Change... changes) {
    return FluentIterable.from(Arrays.asList(changes)).transform(in -> in.getId().get());
}
#method_after
protected static Iterable<Change.Id> ids(Change... changes) {
    return Arrays.stream(changes).map(c -> c.getId()).collect(toList());
}
#end_block

#method_before
protected static Iterable<Integer> ids(Iterable<ChangeInfo> changes) {
    return FluentIterable.from(changes).transform(in -> in._number);
}
#method_after
protected static Iterable<Change.Id> ids(Iterable<ChangeInfo> changes) {
    return Streams.stream(changes).map(c -> new Change.Id(c._number)).collect(toList());
}
#end_block

#method_before
private Account.Id createAccount(String name) throws Exception {
    return accountManager.authenticate(AuthRequest.forUser(name)).getAccountId();
}
#method_after
private Account.Id createAccount(String username, String fullName, String email, boolean active) throws Exception {
    try (ManualRequestContext ctx = oneOffRequestContext.open()) {
        Account.Id id = accountManager.authenticate(AuthRequest.forUser(username)).getAccountId();
        if (email != null) {
            accountManager.link(id, AuthRequest.forEmail(email));
        }
        accountsUpdate.create().update(id, a -> {
            a.setFullName(fullName);
            a.setPreferredEmail(email);
            a.setActive(active);
        });
        return id;
    }
}
#end_block

#method_before
@Override
public RevisionApi current() {
    throw new NotImplementedException();
}
#method_after
@Override
public RevisionApi current() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public RevisionApi revision(int id) {
    throw new NotImplementedException();
}
#method_after
@Override
public RevisionApi revision(int id) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ReviewerApi reviewer(String id) {
    throw new NotImplementedException();
}
#method_after
@Override
public ReviewerApi reviewer(String id) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public RevisionApi revision(String id) {
    throw new NotImplementedException();
}
#method_after
@Override
public RevisionApi revision(String id) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void abandon() {
    throw new NotImplementedException();
}
#method_after
@Override
public void abandon() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void abandon(AbandonInput in) {
    throw new NotImplementedException();
}
#method_after
@Override
public void abandon(AbandonInput in) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void restore() {
    throw new NotImplementedException();
}
#method_after
@Override
public void restore() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void restore(RestoreInput in) {
    throw new NotImplementedException();
}
#method_after
@Override
public void restore(RestoreInput in) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void move(String destination) {
    throw new NotImplementedException();
}
#method_after
@Override
public void move(String destination) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void move(MoveInput in) {
    throw new NotImplementedException();
}
#method_after
@Override
public void move(MoveInput in) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeApi revert() {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeApi revert() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeApi revert(RevertInput in) {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeApi revert(RevertInput in) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void delete() {
    throw new NotImplementedException();
}
#method_after
@Override
public void delete() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public String topic() {
    throw new NotImplementedException();
}
#method_after
@Override
public String topic() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void topic(String topic) {
    throw new NotImplementedException();
}
#method_after
@Override
public void topic(String topic) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public IncludedInInfo includedIn() {
    throw new NotImplementedException();
}
#method_after
@Override
public IncludedInInfo includedIn() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void addReviewer(AddReviewerInput in) {
    throw new NotImplementedException();
}
#method_after
@Override
public AddReviewerResult addReviewer(AddReviewerInput in) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void addReviewer(String in) {
    throw new NotImplementedException();
}
#method_after
@Override
public AddReviewerResult addReviewer(String in) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public SuggestedReviewersRequest suggestReviewers() {
    throw new NotImplementedException();
}
#method_after
@Override
public SuggestedReviewersRequest suggestReviewers() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public SuggestedReviewersRequest suggestReviewers(String query) {
    throw new NotImplementedException();
}
#method_after
@Override
public SuggestedReviewersRequest suggestReviewers(String query) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeInfo get(EnumSet<ListChangesOption> options) {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeInfo get(EnumSet<ListChangesOption> options) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeInfo get() {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeInfo get() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeInfo info() {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeInfo info() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public EditInfo getEdit() {
    throw new NotImplementedException();
}
#method_after
@Override
public EditInfo getEdit() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeEditApi edit() {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeEditApi edit() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void setHashtags(HashtagsInput input) {
    throw new NotImplementedException();
}
#method_after
@Override
public void setHashtags(HashtagsInput input) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Set<String> getHashtags() {
    throw new NotImplementedException();
}
#method_after
@Override
public Set<String> getHashtags() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public AccountInfo setAssignee(AssigneeInput input) {
    throw new NotImplementedException();
}
#method_after
@Override
public AccountInfo setAssignee(AssigneeInput input) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public AccountInfo getAssignee() {
    throw new NotImplementedException();
}
#method_after
@Override
public AccountInfo getAssignee() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<AccountInfo> getPastAssignees() {
    throw new NotImplementedException();
}
#method_after
@Override
public List<AccountInfo> getPastAssignees() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public AccountInfo deleteAssignee() {
    throw new NotImplementedException();
}
#method_after
@Override
public AccountInfo deleteAssignee() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> comments() {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, List<CommentInfo>> comments() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, List<RobotCommentInfo>> robotComments() {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, List<RobotCommentInfo>> robotComments() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> drafts() {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, List<CommentInfo>> drafts() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeInfo check() {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeInfo check() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeInfo check(FixInput fix) {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeInfo check(FixInput fix) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void index() {
    throw new NotImplementedException();
}
#method_after
@Override
public void index() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<ChangeInfo> submittedTogether() {
    throw new NotImplementedException();
}
#method_after
@Override
public List<ChangeInfo> submittedTogether() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public SubmittedTogetherInfo submittedTogether(EnumSet<SubmittedTogetherOption> options) {
    throw new NotImplementedException();
}
#method_after
@Override
public SubmittedTogetherInfo submittedTogether(EnumSet<SubmittedTogetherOption> options) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public SubmittedTogetherInfo submittedTogether(EnumSet<ListChangesOption> a, EnumSet<SubmittedTogetherOption> b) {
    throw new NotImplementedException();
}
#method_after
@Override
public SubmittedTogetherInfo submittedTogether(EnumSet<ListChangesOption> a, EnumSet<SubmittedTogetherOption> b) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeInfo createMergePatchSet(MergePatchSetInput in) {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeInfo createMergePatchSet(MergePatchSetInput in) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public PatchScript call() throws OrmException, LargeObjectException, AuthException, InvalidChangeOperationException, IOException {
    if (parentNum < 0) {
        validatePatchSetId(psa);
    }
    validatePatchSetId(psb);
    change = control.getChange();
    project = change.getProject();
    PatchSet psEntityA = psa != null ? psUtil.get(db, control.getNotes(), psa) : null;
    PatchSet psEntityB = psb.get() == 0 ? new PatchSet(psb) : psUtil.get(db, control.getNotes(), psb);
    try (Repository git = repoManager.openRepository(project)) {
        bId = toObjectId(psEntityB);
        if (parentNum < 0) {
            aId = psEntityA != null ? toObjectId(psEntityA) : null;
        }
        try {
            final PatchList list = listFor(keyFor(diffPrefs.ignoreWhitespace));
            final PatchScriptBuilder b = newBuilder(list, git);
            final PatchListEntry content = list.get(fileName);
            loadCommentsAndHistory(control.getNotes(), content.getChangeType(), content.getOldName(), content.getNewName());
            return b.toPatchScript(content, comments, history);
        } catch (PatchListNotAvailableException e) {
            throw new NoSuchChangeException(changeId, e);
        } catch (IOException e) {
            log.error("File content unavailable", e);
            throw new NoSuchChangeException(changeId, e);
        } catch (org.eclipse.jgit.errors.LargeObjectException err) {
            throw new LargeObjectException("File content is too large", err);
        }
    } catch (RepositoryNotFoundException e) {
        log.error("Repository " + project + " not found", e);
        throw new NoSuchChangeException(changeId, e);
    } catch (IOException e) {
        log.error("Cannot open repository " + project, e);
        throw new NoSuchChangeException(changeId, e);
    }
}
#method_after
@Override
public PatchScript call() throws OrmException, LargeObjectException, AuthException, InvalidChangeOperationException, IOException {
    if (parentNum < 0) {
        validatePatchSetId(psa);
    }
    validatePatchSetId(psb);
    PatchSet psEntityA = psa != null ? psUtil.get(db, notes, psa) : null;
    PatchSet psEntityB = psb.get() == 0 ? new PatchSet(psb) : psUtil.get(db, notes, psb);
    ChangeControl ctl = changeControlFactory.controlFor(notes, userProvider.get());
    if ((psEntityA != null && !ctl.isVisible(db)) || (psEntityB != null && !ctl.isVisible(db))) {
        throw new NoSuchChangeException(changeId);
    }
    try (Repository git = repoManager.openRepository(notes.getProjectName())) {
        bId = toObjectId(psEntityB);
        if (parentNum < 0) {
            aId = psEntityA != null ? toObjectId(psEntityA) : null;
        }
        try {
            final PatchList list = listFor(keyFor(diffPrefs.ignoreWhitespace));
            final PatchScriptBuilder b = newBuilder(list, git);
            final PatchListEntry content = list.get(fileName);
            loadCommentsAndHistory(ctl, content.getChangeType(), content.getOldName(), content.getNewName());
            return b.toPatchScript(content, comments, history);
        } catch (PatchListNotAvailableException e) {
            throw new NoSuchChangeException(changeId, e);
        } catch (IOException e) {
            log.error("File content unavailable", e);
            throw new NoSuchChangeException(changeId, e);
        } catch (org.eclipse.jgit.errors.LargeObjectException err) {
            throw new LargeObjectException("File content is too large", err);
        }
    } catch (RepositoryNotFoundException e) {
        log.error("Repository " + notes.getProjectName() + " not found", e);
        throw new NoSuchChangeException(changeId, e);
    } catch (IOException e) {
        log.error("Cannot open repository " + notes.getProjectName(), e);
        throw new NoSuchChangeException(changeId, e);
    }
}
#end_block

#method_before
private PatchListKey keyFor(final Whitespace whitespace) {
    if (parentNum < 0) {
        return new PatchListKey(aId, bId, whitespace);
    }
    return PatchListKey.againstParentNum(parentNum + 1, bId, whitespace);
}
#method_after
private PatchListKey keyFor(Whitespace whitespace) {
    if (parentNum < 0) {
        return PatchListKey.againstCommit(aId, bId, whitespace);
    }
    return PatchListKey.againstParentNum(parentNum + 1, bId, whitespace);
}
#end_block

#method_before
private PatchList listFor(final PatchListKey key) throws PatchListNotAvailableException {
    return patchListCache.get(key, project);
}
#method_after
private PatchList listFor(PatchListKey key) throws PatchListNotAvailableException {
    return patchListCache.get(key, notes.getProjectName());
}
#end_block

#method_before
private PatchScriptBuilder newBuilder(final PatchList list, Repository git) {
    final PatchScriptBuilder b = builderFactory.get();
    b.setRepository(git, project);
    b.setChange(change);
    b.setDiffPrefs(diffPrefs);
    b.setTrees(list.getComparisonType(), list.getOldId(), list.getNewId());
    return b;
}
#method_after
private PatchScriptBuilder newBuilder(PatchList list, Repository git) {
    final PatchScriptBuilder b = builderFactory.get();
    b.setRepository(git, notes.getProjectName());
    b.setChange(notes.getChange());
    b.setDiffPrefs(diffPrefs);
    b.setTrees(list.getComparisonType(), list.getOldId(), list.getNewId());
    return b;
}
#end_block

#method_before
private ObjectId toObjectId(PatchSet ps) throws NoSuchChangeException, AuthException, NoSuchChangeException, IOException, OrmException {
    if (ps.getId().get() == 0) {
        return getEditRev();
    }
    if (ps.getRevision() == null || ps.getRevision().get() == null) {
        throw new NoSuchChangeException(changeId);
    }
    try {
        return ObjectId.fromString(ps.getRevision().get());
    } catch (IllegalArgumentException e) {
        log.error("Patch set " + ps.getId() + " has invalid revision");
        throw new NoSuchChangeException(changeId, e);
    }
}
#method_after
private ObjectId toObjectId(PatchSet ps) throws AuthException, IOException, OrmException {
    if (ps.getId().get() == 0) {
        return getEditRev();
    }
    if (ps.getRevision() == null || ps.getRevision().get() == null) {
        throw new NoSuchChangeException(changeId);
    }
    try {
        return ObjectId.fromString(ps.getRevision().get());
    } catch (IllegalArgumentException e) {
        log.error("Patch set " + ps.getId() + " has invalid revision");
        throw new NoSuchChangeException(changeId, e);
    }
}
#end_block

#method_before
private ObjectId getEditRev() throws AuthException, NoSuchChangeException, IOException, OrmException {
    edit = editReader.byChange(change);
    if (edit.isPresent()) {
        return edit.get().getRef().getObjectId();
    }
    throw new NoSuchChangeException(change.getId());
}
#method_after
private ObjectId getEditRev() throws AuthException, IOException, OrmException {
    edit = editReader.byChange(notes);
    if (edit.isPresent()) {
        return edit.get().getEditCommit();
    }
    throw new NoSuchChangeException(notes.getChangeId());
}
#end_block

#method_before
private void validatePatchSetId(final PatchSet.Id psId) throws NoSuchChangeException {
    if (psId == null) {
    // OK, means use base;
    } else if (changeId.equals(psId.getParentKey())) {
    // OK, same change;
    } else {
        throw new NoSuchChangeException(changeId);
    }
}
#method_after
private void validatePatchSetId(PatchSet.Id psId) throws NoSuchChangeException {
    if (psId == null) {
    // OK, means use base;
    } else if (changeId.equals(psId.getParentKey())) {
    // OK, same change;
    } else {
        throw new NoSuchChangeException(changeId);
    }
}
#end_block

#method_before
private void loadCommentsAndHistory(ChangeNotes notes, ChangeType changeType, String oldName, String newName) throws OrmException {
    Map<Patch.Key, Patch> byKey = new HashMap<>();
    if (loadHistory) {
        // This seems like a cheap trick. It doesn't properly account for a
        // file that gets renamed between patch set 1 and patch set 2. We
        // will wind up packing the wrong Patch object because we didn't do
        // proper rename detection between the patch sets.
        // 
        history = new ArrayList<>();
        for (PatchSet ps : psUtil.byChange(db, notes)) {
            String name = fileName;
            if (psa != null) {
                switch(changeType) {
                    case COPIED:
                    case RENAMED:
                        if (ps.getId().equals(psa)) {
                            name = oldName;
                        }
                        break;
                    case MODIFIED:
                    case DELETED:
                    case ADDED:
                    case REWRITE:
                        break;
                }
            }
            Patch p = new Patch(new Patch.Key(ps.getId(), name));
            history.add(p);
            byKey.put(p.getKey(), p);
        }
        if (edit != null && edit.isPresent()) {
            Patch p = new Patch(new Patch.Key(new PatchSet.Id(psb.getParentKey(), 0), fileName));
            history.add(p);
            byKey.put(p.getKey(), p);
        }
    }
    if (loadComments && edit == null) {
        comments = new CommentDetail(psa, psb);
        switch(changeType) {
            case ADDED:
            case MODIFIED:
                loadPublished(byKey, newName);
                break;
            case DELETED:
                loadPublished(byKey, newName);
                break;
            case COPIED:
            case RENAMED:
                if (psa != null) {
                    loadPublished(byKey, oldName);
                }
                loadPublished(byKey, newName);
                break;
            case REWRITE:
                break;
        }
        CurrentUser user = control.getUser();
        if (user.isIdentifiedUser()) {
            Account.Id me = user.getAccountId();
            switch(changeType) {
                case ADDED:
                case MODIFIED:
                    loadDrafts(byKey, me, newName);
                    break;
                case DELETED:
                    loadDrafts(byKey, me, newName);
                    break;
                case COPIED:
                case RENAMED:
                    if (psa != null) {
                        loadDrafts(byKey, me, oldName);
                    }
                    loadDrafts(byKey, me, newName);
                    break;
                case REWRITE:
                    break;
            }
        }
    }
}
#method_after
private void loadCommentsAndHistory(ChangeControl ctl, ChangeType changeType, String oldName, String newName) throws OrmException {
    Map<Patch.Key, Patch> byKey = new HashMap<>();
    if (loadHistory) {
        // This seems like a cheap trick. It doesn't properly account for a
        // file that gets renamed between patch set 1 and patch set 2. We
        // will wind up packing the wrong Patch object because we didn't do
        // proper rename detection between the patch sets.
        // 
        history = new ArrayList<>();
        for (PatchSet ps : psUtil.byChange(db, notes)) {
            if (!ctl.isVisible(db)) {
                continue;
            }
            String name = fileName;
            if (psa != null) {
                switch(changeType) {
                    case COPIED:
                    case RENAMED:
                        if (ps.getId().equals(psa)) {
                            name = oldName;
                        }
                        break;
                    case MODIFIED:
                    case DELETED:
                    case ADDED:
                    case REWRITE:
                        break;
                }
            }
            Patch p = new Patch(new Patch.Key(ps.getId(), name));
            history.add(p);
            byKey.put(p.getKey(), p);
        }
        if (edit != null && edit.isPresent()) {
            Patch p = new Patch(new Patch.Key(new PatchSet.Id(psb.getParentKey(), 0), fileName));
            history.add(p);
            byKey.put(p.getKey(), p);
        }
    }
    if (loadComments && edit == null) {
        comments = new CommentDetail(psa, psb);
        switch(changeType) {
            case ADDED:
            case MODIFIED:
                loadPublished(byKey, newName);
                break;
            case DELETED:
                loadPublished(byKey, newName);
                break;
            case COPIED:
            case RENAMED:
                if (psa != null) {
                    loadPublished(byKey, oldName);
                }
                loadPublished(byKey, newName);
                break;
            case REWRITE:
                break;
        }
        CurrentUser user = userProvider.get();
        if (user.isIdentifiedUser()) {
            Account.Id me = user.getAccountId();
            switch(changeType) {
                case ADDED:
                case MODIFIED:
                    loadDrafts(byKey, me, newName);
                    break;
                case DELETED:
                    loadDrafts(byKey, me, newName);
                    break;
                case COPIED:
                case RENAMED:
                    if (psa != null) {
                        loadDrafts(byKey, me, oldName);
                    }
                    loadDrafts(byKey, me, newName);
                    break;
                case REWRITE:
                    break;
            }
        }
    }
}
#end_block

#method_before
private void loadPublished(Map<Patch.Key, Patch> byKey, String file) throws OrmException {
    ChangeNotes notes = control.getNotes();
    for (Comment c : commentsUtil.publishedByChangeFile(db, notes, changeId, file)) {
        comments.include(change.getId(), c);
        PatchSet.Id psId = new PatchSet.Id(change.getId(), c.key.patchSetId);
        Patch.Key pKey = new Patch.Key(psId, c.key.filename);
        Patch p = byKey.get(pKey);
        if (p != null) {
            p.setCommentCount(p.getCommentCount() + 1);
        }
    }
}
#method_after
private void loadPublished(Map<Patch.Key, Patch> byKey, String file) throws OrmException {
    for (Comment c : commentsUtil.publishedByChangeFile(db, notes, changeId, file)) {
        comments.include(notes.getChangeId(), c);
        PatchSet.Id psId = new PatchSet.Id(notes.getChangeId(), c.key.patchSetId);
        Patch.Key pKey = new Patch.Key(psId, c.key.filename);
        Patch p = byKey.get(pKey);
        if (p != null) {
            p.setCommentCount(p.getCommentCount() + 1);
        }
    }
}
#end_block

#method_before
private void loadDrafts(Map<Patch.Key, Patch> byKey, Account.Id me, String file) throws OrmException {
    for (Comment c : commentsUtil.draftByChangeFileAuthor(db, control.getNotes(), file, me)) {
        comments.include(change.getId(), c);
        PatchSet.Id psId = new PatchSet.Id(change.getId(), c.key.patchSetId);
        Patch.Key pKey = new Patch.Key(psId, c.key.filename);
        Patch p = byKey.get(pKey);
        if (p != null) {
            p.setDraftCount(p.getDraftCount() + 1);
        }
    }
}
#method_after
private void loadDrafts(Map<Patch.Key, Patch> byKey, Account.Id me, String file) throws OrmException {
    for (Comment c : commentsUtil.draftByChangeFileAuthor(db, notes, file, me)) {
        comments.include(notes.getChangeId(), c);
        PatchSet.Id psId = new PatchSet.Id(notes.getChangeId(), c.key.patchSetId);
        Patch.Key pKey = new Patch.Key(psId, c.key.filename);
        Patch p = byKey.get(pKey);
        if (p != null) {
            p.setDraftCount(p.getDraftCount() + 1);
        }
    }
}
#end_block

#method_before
public static String toChangeInEditMode(Change.Id c) {
    return "/c/" + c + ",edit/";
}
#method_after
public static String toChangeInEditMode(@Nullable Project.NameKey project, Change.Id c) {
    return toChangeNoSlash(project, c) + ",edit/";
}
#end_block

#method_before
public static String toChange(final PatchSet.Id ps) {
    return "/c/" + ps.getParentKey() + "/" + ps.getId();
}
#method_after
public static String toChange(@Nullable Project.NameKey project, Change.Id c) {
    return toChangeNoSlash(project, c) + "/";
}
#end_block

#method_before
public static String toProject(final Project.NameKey p) {
    return ADMIN_PROJECTS + p.get();
}
#method_after
public static String toProject(Project.NameKey p) {
    return ADMIN_PROJECTS + p.get();
}
#end_block

#method_before
public static String toProjectAcceess(final Project.NameKey p) {
    return "/admin/projects/" + p.get() + ",access";
}
#method_after
public static String toProjectAcceess(Project.NameKey p) {
    return "/admin/projects/" + p.get() + ",access";
}
#end_block

#method_before
public static String toCustomDashboard(final String params) {
    return "/dashboard/?" + params;
}
#method_after
public static String toCustomDashboard(String params) {
    return "/dashboard/?" + params;
}
#end_block

#method_before
public static GerritCallback<JavaScriptObject> cs(final Change.Id id, final Button... draftButtons) {
    setEnabled(false, draftButtons);
    return new GerritCallback<JavaScriptObject>() {

        @Override
        public void onSuccess(JavaScriptObject result) {
            Gerrit.display(PageLinks.toChange(id));
        }

        @Override
        public void onFailure(Throwable err) {
            setEnabled(true, draftButtons);
            if (SubmitFailureDialog.isConflict(err)) {
                new SubmitFailureDialog(err.getMessage()).center();
                Gerrit.display(PageLinks.toChange(id));
            } else {
                super.onFailure(err);
            }
        }
    };
}
#method_after
public static GerritCallback<JavaScriptObject> cs(Project.NameKey project, final Change.Id id, Button... draftButtons) {
    setEnabled(false, draftButtons);
    return new GerritCallback<JavaScriptObject>() {

        @Override
        public void onSuccess(JavaScriptObject result) {
            Gerrit.display(PageLinks.toChange(project, id));
        }

        @Override
        public void onFailure(Throwable err) {
            setEnabled(true, draftButtons);
            if (SubmitFailureDialog.isConflict(err)) {
                new SubmitFailureDialog(err.getMessage()).center();
                Gerrit.display(PageLinks.toChange(project, id));
            } else {
                super.onFailure(err);
            }
        }
    };
}
#end_block

#method_before
private RevCommit createMergeCommit(MergePatchSetInput in, ProjectControl projectControl, Branch.NameKey dest, Repository git, ObjectInserter oi, RevWalk rw, RevCommit currentPsCommit, RevCommit sourceCommit, PersonIdent author, ObjectId changeId) throws ResourceNotFoundException, MergeIdenticalTreeException, MergeConflictException, IOException {
    ObjectId parentCommit;
    if (in.inheritParent) {
        // inherit first parent from previous patch set
        parentCommit = currentPsCommit.getParent(0);
    } else {
        // get the current branch tip of destination branch
        Ref destRef = git.getRefDatabase().exactRef(dest.get());
        if (destRef != null) {
            parentCommit = destRef.getObjectId();
        } else {
            throw new ResourceNotFoundException("cannot find destination branch");
        }
    }
    RevCommit mergeTip = rw.parseCommit(parentCommit);
    String commitMsg;
    if (Strings.emptyToNull(in.subject) != null) {
        commitMsg = ChangeIdUtil.insertId(in.subject, changeId);
    } else {
        // reuse previous patch set commit message
        commitMsg = currentPsCommit.getFullMessage();
    }
    String mergeStrategy = MoreObjects.firstNonNull(Strings.emptyToNull(in.merge.strategy), mergeUtilFactory.create(projectControl.getProjectState()).mergeStrategyName());
    return MergeUtil.createMergeCommit(git, oi, mergeTip, sourceCommit, mergeStrategy, author, commitMsg, rw);
}
#method_after
private RevCommit createMergeCommit(MergePatchSetInput in, ProjectState projectState, Branch.NameKey dest, Repository git, ObjectInserter oi, RevWalk rw, RevCommit currentPsCommit, RevCommit sourceCommit, PersonIdent author, ObjectId changeId) throws ResourceNotFoundException, MergeIdenticalTreeException, MergeConflictException, IOException {
    ObjectId parentCommit;
    if (in.inheritParent) {
        // inherit first parent from previous patch set
        parentCommit = currentPsCommit.getParent(0);
    } else {
        // get the current branch tip of destination branch
        Ref destRef = git.getRefDatabase().exactRef(dest.get());
        if (destRef != null) {
            parentCommit = destRef.getObjectId();
        } else {
            throw new ResourceNotFoundException("cannot find destination branch");
        }
    }
    RevCommit mergeTip = rw.parseCommit(parentCommit);
    String commitMsg;
    if (Strings.emptyToNull(in.subject) != null) {
        commitMsg = ChangeIdUtil.insertId(in.subject, changeId);
    } else {
        // reuse previous patch set commit message
        commitMsg = currentPsCommit.getFullMessage();
    }
    String mergeStrategy = MoreObjects.firstNonNull(Strings.emptyToNull(in.merge.strategy), mergeUtilFactory.create(projectState).mergeStrategyName());
    return MergeUtil.createMergeCommit(oi, git.getConfig(), mergeTip, sourceCommit, mergeStrategy, author, commitMsg, rw);
}
#end_block

#method_before
@Override
public final void updateRepo(RepoContext ctx) throws Exception {
    logDebug("{}#updateRepo for change {}", getClass().getSimpleName(), toMerge.change().getId());
    // Run the submit strategy implementation and record the merge tip state so
    // we can create the ref update.
    CodeReviewCommit tipBefore = args.mergeTip.getCurrentTip();
    alreadyMerged = getAlreadyMergedCommit(ctx);
    if (alreadyMerged == null) {
        updateRepoImpl(ctx);
    } else {
        logDebug("Already merged as {}", alreadyMerged.name());
    }
    CodeReviewCommit tipAfter = args.mergeTip.getCurrentTip();
    if (Objects.equals(tipBefore, tipAfter)) {
        logDebug("Did not move tip", getClass().getSimpleName());
        return;
    } else if (tipAfter == null) {
        logDebug("No merge tip, no update to perform");
        return;
    }
    logDebug("Moved tip from {} to {}", tipBefore, tipAfter);
    checkProjectConfig(ctx, tipAfter);
    // Needed by postUpdate, at which point mergeTip will have advanced further,
    // so it's easier to just snapshot the command.
    command = new ReceiveCommand(firstNonNull(tipBefore, ObjectId.zeroId()), tipAfter, getDest().get());
    ctx.addRefUpdate(command);
    args.submoduleOp.addBranchTip(getDest(), tipAfter);
}
#method_after
@Override
public final void updateRepo(RepoContext ctx) throws Exception {
    logDebug("{}#updateRepo for change {}", getClass().getSimpleName(), toMerge.change().getId());
    checkState(ctx.getRevWalk() == args.rw, "SubmitStrategyOp requires callers to call BatchUpdate#setRepository with exactly the same" + " CodeReviewRevWalk instance from the SubmitStrategy.Arguments: %s != %s", ctx.getRevWalk(), args.rw);
    // Run the submit strategy implementation and record the merge tip state so
    // we can create the ref update.
    CodeReviewCommit tipBefore = args.mergeTip.getCurrentTip();
    alreadyMergedCommit = getAlreadyMergedCommit(ctx);
    if (alreadyMergedCommit == null) {
        updateRepoImpl(ctx);
    } else {
        logDebug("Already merged as {}", alreadyMergedCommit.name());
    }
    CodeReviewCommit tipAfter = args.mergeTip.getCurrentTip();
    if (Objects.equals(tipBefore, tipAfter)) {
        logDebug("Did not move tip", getClass().getSimpleName());
        return;
    } else if (tipAfter == null) {
        logDebug("No merge tip, no update to perform");
        return;
    }
    logDebug("Moved tip from {} to {}", tipBefore, tipAfter);
    checkProjectConfig(ctx, tipAfter);
    // Needed by postUpdate, at which point mergeTip will have advanced further,
    // so it's easier to just snapshot the command.
    command = new ReceiveCommand(firstNonNull(tipBefore, ObjectId.zeroId()), tipAfter, getDest().get());
    ctx.addRefUpdate(command);
    args.submoduleOp.addBranchTip(getDest(), tipAfter);
}
#end_block

#method_before
private CodeReviewCommit getAlreadyMergedCommit(RepoContext ctx) throws IOException {
    CodeReviewCommit tip = args.mergeTip.getInitialTip();
    if (tip == null) {
        return null;
    }
    CodeReviewRevWalk rw = (CodeReviewRevWalk) ctx.getRevWalk();
    Change.Id id = getId();
    Collection<Ref> refs = ctx.getRepository().getRefDatabase().getRefs(id.toRefPrefix()).values();
    List<CodeReviewCommit> commits = new ArrayList<>(refs.size());
    for (Ref ref : refs) {
        PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
        if (psId == null) {
            continue;
        }
        try {
            CodeReviewCommit c = rw.parseCommit(ref.getObjectId());
            c.setPatchsetId(psId);
            commits.add(c);
        } catch (MissingObjectException | IncorrectObjectTypeException e) {
            // Bogus ref, can't be merged into tip so we don't care.
            continue;
        }
    }
    Collections.sort(commits, ReviewDbUtil.intKeyOrdering().reverse().onResultOf(c -> c.getPatchsetId()));
    CodeReviewCommit result = MergeUtil.findAnyMergedInto(rw, commits, tip);
    if (result == null) {
        return null;
    }
    // Some patch set of this change is actually merged into the target
    // branch, most likely because a previous run of MergeOp failed after
    // updateRepo, during updateChange.
    // 
    // Do the best we can to clean this up: mark the change as merged and set
    // the current patch set. Don't touch the dest branch at all. This can
    // lead to some odd situations like another change in the set merging in
    // a different patch set of this change, but that's unavoidable at this
    // point.  At least the change will end up in the right state.
    // 
    // TODO(dborowitz): Consider deleting later junk patch set refs. They
    // presumably don't have PatchSets pointing to them.
    rw.parseBody(result);
    result.add(args.canMergeFlag);
    PatchSet.Id psId = result.getPatchsetId();
    result.copyFrom(toMerge);
    // Got overwriten by copyFrom.
    result.setPatchsetId(psId);
    result.setStatusCode(CommitMergeStatus.ALREADY_MERGED);
    args.commitStatus.put(result);
    return result;
}
#method_after
private CodeReviewCommit getAlreadyMergedCommit(RepoContext ctx) throws IOException {
    CodeReviewCommit tip = args.mergeTip.getInitialTip();
    if (tip == null) {
        return null;
    }
    CodeReviewRevWalk rw = (CodeReviewRevWalk) ctx.getRevWalk();
    Change.Id id = getId();
    String refPrefix = id.toRefPrefix();
    Map<String, ObjectId> refs = ctx.getRepoView().getRefs(refPrefix);
    List<CodeReviewCommit> commits = new ArrayList<>(refs.size());
    for (Map.Entry<String, ObjectId> e : refs.entrySet()) {
        PatchSet.Id psId = PatchSet.Id.fromRef(refPrefix + e.getKey());
        if (psId == null) {
            continue;
        }
        try {
            CodeReviewCommit c = rw.parseCommit(e.getValue());
            c.setPatchsetId(psId);
            commits.add(c);
        } catch (MissingObjectException | IncorrectObjectTypeException ex) {
            // Bogus ref, can't be merged into tip so we don't care.
            continue;
        }
    }
    Collections.sort(commits, ReviewDbUtil.intKeyOrdering().reverse().onResultOf(c -> c.getPatchsetId()));
    CodeReviewCommit result = MergeUtil.findAnyMergedInto(rw, commits, tip);
    if (result == null) {
        return null;
    }
    // Some patch set of this change is actually merged into the target
    // branch, most likely because a previous run of MergeOp failed after
    // updateRepo, during updateChange.
    // 
    // Do the best we can to clean this up: mark the change as merged and set
    // the current patch set. Don't touch the dest branch at all. This can
    // lead to some odd situations like another change in the set merging in
    // a different patch set of this change, but that's unavoidable at this
    // point.  At least the change will end up in the right state.
    // 
    // TODO(dborowitz): Consider deleting later junk patch set refs. They
    // presumably don't have PatchSets pointing to them.
    rw.parseBody(result);
    result.add(args.canMergeFlag);
    PatchSet.Id psId = result.getPatchsetId();
    result.copyFrom(toMerge);
    // Got overwriten by copyFrom.
    result.setPatchsetId(psId);
    result.setStatusCode(CommitMergeStatus.ALREADY_MERGED);
    args.commitStatus.put(result);
    return result;
}
#end_block

#method_before
@Override
public final boolean updateChange(ChangeContext ctx) throws Exception {
    logDebug("{}#updateChange for change {}", getClass().getSimpleName(), toMerge.change().getId());
    // Update change and notes from ctx.
    toMerge.setControl(ctx.getControl());
    PatchSet.Id oldPsId = checkNotNull(toMerge.getPatchsetId());
    PatchSet.Id newPsId;
    if (alreadyMerged != null) {
        alreadyMerged.setControl(ctx.getControl());
        mergedPatchSet = getOrCreateAlreadyMergedPatchSet(ctx);
        newPsId = mergedPatchSet.getId();
    } else {
        PatchSet newPatchSet = updateChangeImpl(ctx);
        newPsId = checkNotNull(ctx.getChange().currentPatchSetId());
        if (newPatchSet == null) {
            checkState(oldPsId.equals(newPsId), "patch set advanced from %s to %s but updateChangeImpl did not" + " return new patch set instance", oldPsId, newPsId);
            // Ok to use stale notes to get the old patch set, which didn't change
            // during the submit strategy.
            mergedPatchSet = checkNotNull(args.psUtil.get(ctx.getDb(), ctx.getNotes(), oldPsId), "missing old patch set %s", oldPsId);
        } else {
            PatchSet.Id n = newPatchSet.getId();
            checkState(!n.equals(oldPsId) && n.equals(newPsId), "current patch was %s and is now %s, but updateChangeImpl returned" + " new patch set instance at %s", oldPsId, newPsId, n);
            mergedPatchSet = newPatchSet;
        }
    }
    Change c = ctx.getChange();
    Change.Id id = c.getId();
    CodeReviewCommit commit = args.commitStatus.get(id);
    checkNotNull(commit, "missing commit for change " + id);
    CommitMergeStatus s = commit.getStatusCode();
    checkNotNull(s, "status not set for change " + id + " expected to previously fail fast");
    logDebug("Status of change {} ({}) on {}: {}", id, commit.name(), c.getDest(), s);
    setApproval(ctx, args.caller);
    mergeResultRev = alreadyMerged == null ? args.mergeTip.getMergeResults().get(commit) : // ChangeMergedEvent in the fixup case, but we'll just live with that.
    alreadyMerged;
    try {
        setMerged(ctx, message(ctx, commit, s));
    } catch (OrmException err) {
        String msg = "Error updating change status for " + id;
        log.error(msg, err);
        args.commitStatus.logProblem(id, msg);
    // It's possible this happened before updating anything in the db, but
    // it's hard to know for sure, so just return true below to be safe.
    }
    updatedChange = c;
    return true;
}
#method_after
@Override
public final boolean updateChange(ChangeContext ctx) throws Exception {
    logDebug("{}#updateChange for change {}", getClass().getSimpleName(), toMerge.change().getId());
    // Update change and notes from ctx.
    toMerge.setNotes(ctx.getNotes());
    PatchSet.Id oldPsId = checkNotNull(toMerge.getPatchsetId());
    PatchSet.Id newPsId;
    if (ctx.getChange().getStatus() == Change.Status.MERGED) {
        // repo failed with lock failure.
        if (alreadyMergedCommit == null) {
            logDebug("Change is already merged according to its status, but we were unable to find it" + " merged into the current tip ({})", args.mergeTip.getCurrentTip().name());
        } else {
            logDebug("Change is already merged");
        }
        changeAlreadyMerged = true;
        return false;
    }
    if (alreadyMergedCommit != null) {
        alreadyMergedCommit.setNotes(ctx.getNotes());
        mergedPatchSet = getOrCreateAlreadyMergedPatchSet(ctx);
        newPsId = mergedPatchSet.getId();
    } else {
        PatchSet newPatchSet = updateChangeImpl(ctx);
        newPsId = checkNotNull(ctx.getChange().currentPatchSetId());
        if (newPatchSet == null) {
            checkState(oldPsId.equals(newPsId), "patch set advanced from %s to %s but updateChangeImpl did not" + " return new patch set instance", oldPsId, newPsId);
            // Ok to use stale notes to get the old patch set, which didn't change
            // during the submit strategy.
            mergedPatchSet = checkNotNull(args.psUtil.get(ctx.getDb(), ctx.getNotes(), oldPsId), "missing old patch set %s", oldPsId);
        } else {
            PatchSet.Id n = newPatchSet.getId();
            checkState(!n.equals(oldPsId) && n.equals(newPsId), "current patch was %s and is now %s, but updateChangeImpl returned" + " new patch set instance at %s", oldPsId, newPsId, n);
            mergedPatchSet = newPatchSet;
        }
    }
    Change c = ctx.getChange();
    Change.Id id = c.getId();
    CodeReviewCommit commit = args.commitStatus.get(id);
    checkNotNull(commit, "missing commit for change " + id);
    CommitMergeStatus s = commit.getStatusCode();
    checkNotNull(s, "status not set for change " + id + " expected to previously fail fast");
    logDebug("Status of change {} ({}) on {}: {}", id, commit.name(), c.getDest(), s);
    setApproval(ctx, args.caller);
    mergeResultRev = alreadyMergedCommit == null ? args.mergeTip.getMergeResults().get(commit) : // ChangeMergedEvent in the fixup case, but we'll just live with that.
    alreadyMergedCommit;
    try {
        setMerged(ctx, message(ctx, commit, s));
    } catch (OrmException err) {
        String msg = "Error updating change status for " + id;
        log.error(msg, err);
        args.commitStatus.logProblem(id, msg);
    // It's possible this happened before updating anything in the db, but
    // it's hard to know for sure, so just return true below to be safe.
    }
    updatedChange = c;
    return true;
}
#end_block

#method_before
private PatchSet getOrCreateAlreadyMergedPatchSet(ChangeContext ctx) throws IOException, OrmException {
    PatchSet.Id psId = alreadyMerged.getPatchsetId();
    logDebug("Fixing up already-merged patch set {}", psId);
    PatchSet prevPs = args.psUtil.current(ctx.getDb(), ctx.getNotes());
    ctx.getRevWalk().parseBody(alreadyMerged);
    ctx.getChange().setCurrentPatchSet(psId, alreadyMerged.getShortMessage(), ctx.getChange().getOriginalSubject());
    PatchSet existing = args.psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    if (existing != null) {
        logDebug("Patch set row exists, only updating change");
        return existing;
    }
    // No patch set for the already merged commit, although we know it came form
    // a patch set ref. Fix up the database. Note that this uses the current
    // user as the uploader, which is as good a guess as any.
    List<String> groups = prevPs != null ? prevPs.getGroups() : GroupCollector.getDefaultGroups(alreadyMerged);
    return args.psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(psId), psId, alreadyMerged, groups, null, null);
}
#method_after
private PatchSet getOrCreateAlreadyMergedPatchSet(ChangeContext ctx) throws IOException, OrmException {
    PatchSet.Id psId = alreadyMergedCommit.getPatchsetId();
    logDebug("Fixing up already-merged patch set {}", psId);
    PatchSet prevPs = args.psUtil.current(ctx.getDb(), ctx.getNotes());
    ctx.getRevWalk().parseBody(alreadyMergedCommit);
    ctx.getChange().setCurrentPatchSet(psId, alreadyMergedCommit.getShortMessage(), ctx.getChange().getOriginalSubject());
    PatchSet existing = args.psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    if (existing != null) {
        logDebug("Patch set row exists, only updating change");
        return existing;
    }
    // No patch set for the already merged commit, although we know it came form
    // a patch set ref. Fix up the database. Note that this uses the current
    // user as the uploader, which is as good a guess as any.
    List<String> groups = prevPs != null ? prevPs.getGroups() : GroupCollector.getDefaultGroups(alreadyMergedCommit);
    return args.psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(psId), psId, alreadyMergedCommit, groups, null, null);
}
#end_block

#method_before
private void setApproval(ChangeContext ctx, IdentifiedUser user) throws OrmException {
    Change.Id id = ctx.getChange().getId();
    List<SubmitRecord> records = args.commitStatus.getSubmitRecords(id);
    PatchSet.Id oldPsId = toMerge.getPatchsetId();
    PatchSet.Id newPsId = ctx.getChange().currentPatchSetId();
    logDebug("Add approval for " + id);
    ChangeUpdate origPsUpdate = ctx.getUpdate(oldPsId);
    origPsUpdate.putReviewer(user.getAccountId(), REVIEWER);
    LabelNormalizer.Result normalized = approve(ctx, origPsUpdate);
    ChangeUpdate newPsUpdate = ctx.getUpdate(newPsId);
    newPsUpdate.merge(args.submissionId, records);
    // approvals as well.
    if (!newPsId.equals(oldPsId)) {
        saveApprovals(normalized, ctx, newPsUpdate, true);
        submitter = convertPatchSet(newPsId).apply(submitter);
    }
}
#method_after
private void setApproval(ChangeContext ctx, IdentifiedUser user) throws OrmException, IOException, PermissionBackendException {
    Change.Id id = ctx.getChange().getId();
    List<SubmitRecord> records = args.commitStatus.getSubmitRecords(id);
    PatchSet.Id oldPsId = toMerge.getPatchsetId();
    PatchSet.Id newPsId = ctx.getChange().currentPatchSetId();
    logDebug("Add approval for " + id);
    ChangeUpdate origPsUpdate = ctx.getUpdate(oldPsId);
    origPsUpdate.putReviewer(user.getAccountId(), REVIEWER);
    LabelNormalizer.Result normalized = approve(ctx, origPsUpdate);
    ChangeUpdate newPsUpdate = ctx.getUpdate(newPsId);
    newPsUpdate.merge(args.submissionId, records);
    // approvals as well.
    if (!newPsId.equals(oldPsId)) {
        saveApprovals(normalized, ctx, newPsUpdate, true);
        submitter = convertPatchSet(newPsId).apply(submitter);
    }
}
#end_block

#method_before
private LabelNormalizer.Result approve(ChangeContext ctx, ChangeUpdate update) throws OrmException {
    PatchSet.Id psId = update.getPatchSetId();
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = new HashMap<>();
    for (PatchSetApproval psa : args.approvalsUtil.byPatchSet(ctx.getDb(), ctx.getControl(), psId)) {
        byKey.put(psa.getKey(), psa);
    }
    submitter = ApprovalsUtil.newApproval(psId, ctx.getUser(), LabelId.legacySubmit(), 1, ctx.getWhen());
    byKey.put(submitter.getKey(), submitter);
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    LabelNormalizer.Result normalized = args.labelNormalizer.normalize(ctx.getControl(), byKey.values());
    update.putApproval(submitter.getLabel(), submitter.getValue());
    saveApprovals(normalized, ctx, update, false);
    return normalized;
}
#method_after
private LabelNormalizer.Result approve(ChangeContext ctx, ChangeUpdate update) throws OrmException, IOException, PermissionBackendException {
    PatchSet.Id psId = update.getPatchSetId();
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = new HashMap<>();
    for (PatchSetApproval psa : args.approvalsUtil.byPatchSet(ctx.getDb(), ctx.getNotes(), ctx.getUser(), psId, ctx.getRevWalk(), ctx.getRepoView().getConfig())) {
        byKey.put(psa.getKey(), psa);
    }
    submitter = ApprovalsUtil.newApproval(psId, ctx.getUser(), LabelId.legacySubmit(), 1, ctx.getWhen());
    byKey.put(submitter.getKey(), submitter);
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    LabelNormalizer.Result normalized = args.labelNormalizer.normalize(ctx.getNotes(), ctx.getUser(), byKey.values());
    update.putApproval(submitter.getLabel(), submitter.getValue());
    saveApprovals(normalized, ctx, update, false);
    return normalized;
}
#end_block

#method_before
@Override
public final void postUpdate(Context ctx) throws Exception {
    postUpdateImpl(ctx);
    if (command != null) {
        args.tagCache.updateFastForward(getProject(), command.getRefName(), command.getOldId(), command.getNewId());
        // per project even if multiple changes to refs/meta/config are submitted.
        if (RefNames.REFS_CONFIG.equals(getDest().get())) {
            args.projectCache.evict(getProject());
            ProjectState p = args.projectCache.get(getProject());
            try (Repository git = args.repoManager.openRepository(getProject())) {
                git.setGitwebDescription(p.getProject().getDescription());
            } catch (IOException e) {
                log.error("cannot update description of " + p.getProject().getName(), e);
            }
        }
    }
    // have failed fast in one of the other steps.
    try {
        args.mergedSenderFactory.create(ctx.getProject(), getId(), submitter.getAccountId(), args.notifyHandling, args.accountsToNotify).sendAsync();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + getId(), e);
    }
    if (mergeResultRev != null && !args.dryrun) {
        args.changeMerged.fire(updatedChange, mergedPatchSet, args.accountCache.get(submitter.getAccountId()).getAccount(), args.mergeTip.getCurrentTip().name(), ctx.getWhen());
    }
}
#method_after
@Override
public final void postUpdate(Context ctx) throws Exception {
    if (changeAlreadyMerged) {
        // TODO(dborowitz): This is suboptimal behavior in the presence of retries: postUpdate steps
        // will never get run for changes that submitted successfully on any but the final attempt.
        // This is primarily a temporary workaround for the fact that the submitter field is not
        // populated in the changeAlreadyMerged case.
        // 
        // If we naively execute postUpdate even if the change is already merged when updateChange
        // being, then we are subject to a race where postUpdate steps are run twice if two submit
        // processes run at the same time.
        logDebug("Skipping post-update steps for change {}", getId());
        return;
    }
    postUpdateImpl(ctx);
    if (command != null) {
        args.tagCache.updateFastForward(getProject(), command.getRefName(), command.getOldId(), command.getNewId());
        // per project even if multiple changes to refs/meta/config are submitted.
        if (RefNames.REFS_CONFIG.equals(getDest().get())) {
            args.projectCache.evict(getProject());
            ProjectState p = args.projectCache.get(getProject());
            try (Repository git = args.repoManager.openRepository(getProject())) {
                git.setGitwebDescription(p.getProject().getDescription());
            } catch (IOException e) {
                log.error("cannot update description of " + p.getName(), e);
            }
        }
    }
    // have failed fast in one of the other steps.
    try {
        args.mergedSenderFactory.create(ctx.getProject(), getId(), submitter.getAccountId(), args.submitInput.notify, args.accountsToNotify).sendAsync();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + getId(), e);
    }
    if (mergeResultRev != null && !args.dryrun) {
        args.changeMerged.fire(updatedChange, mergedPatchSet, args.accountCache.get(submitter.getAccountId()).getAccount(), args.mergeTip.getCurrentTip().name(), ctx.getWhen());
    }
}
#end_block

#method_before
@Override
public void review(ReviewInput in) throws RestApiException {
    try {
        review.apply(revision, in);
    } catch (OrmException | UpdateException | IOException e) {
        throw new RestApiException("Cannot post review", e);
    }
}
#method_after
@Override
public ReviewResult review(ReviewInput in) throws RestApiException {
    try {
        return review.apply(revision, in).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot post review", e);
    }
}
#end_block

#method_before
@Override
public void submit(SubmitInput in) throws RestApiException {
    try {
        submit.apply(revision, in);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot submit change", e);
    }
}
#method_after
@Override
public void submit(SubmitInput in) throws RestApiException {
    try {
        submit.apply(revision, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot submit change", e);
    }
}
#end_block

#method_before
@Override
public BinaryResult submitPreview(String format) throws RestApiException {
    submitPreview.setFormat(format);
    return submitPreview.apply(revision);
}
#method_after
@Override
public BinaryResult submitPreview(String format) throws RestApiException {
    try {
        submitPreview.setFormat(format);
        return submitPreview.apply(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot get submit preview", e);
    }
}
#end_block

#method_before
@Override
public ChangeApi rebase(RebaseInput in) throws RestApiException {
    try {
        return changes.id(rebase.apply(revision, in)._number);
    } catch (OrmException | EmailException | UpdateException | IOException e) {
        throw new RestApiException("Cannot rebase ps", e);
    }
}
#method_after
@Override
public ChangeApi rebase(RebaseInput in) throws RestApiException {
    try {
        return changes.id(rebase.apply(revision, in)._number);
    } catch (Exception e) {
        throw asRestApiException("Cannot rebase ps", e);
    }
}
#end_block

#method_before
@Override
public boolean canRebase() throws RestApiException {
    try (Repository repo = repoManager.openRepository(revision.getProject());
        RevWalk rw = new RevWalk(repo)) {
        return rebaseUtil.canRebase(revision.getPatchSet(), revision.getChange().getDest(), repo, rw);
    } catch (IOException e) {
        throw new RestApiException("Cannot check if rebase is possible", e);
    }
}
#method_after
@Override
public boolean canRebase() throws RestApiException {
    try (Repository repo = repoManager.openRepository(revision.getProject());
        RevWalk rw = new RevWalk(repo)) {
        return rebaseUtil.canRebase(revision.getPatchSet(), revision.getChange().getDest(), repo, rw);
    } catch (Exception e) {
        throw asRestApiException("Cannot check if rebase is possible", e);
    }
}
#end_block

#method_before
@Override
public ChangeApi cherryPick(CherryPickInput in) throws RestApiException {
    try {
        return changes.id(cherryPick.apply(revision, in)._number);
    } catch (OrmException | IOException | UpdateException e) {
        throw new RestApiException("Cannot cherry pick", e);
    }
}
#method_after
@Override
public ChangeApi cherryPick(CherryPickInput in) throws RestApiException {
    try {
        return changes.id(cherryPick.apply(revision, in)._number);
    } catch (Exception e) {
        throw asRestApiException("Cannot cherry pick", e);
    }
}
#end_block

#method_before
@Override
public RevisionReviewerApi reviewer(String id) throws RestApiException {
    try {
        return revisionReviewerApi.create(revisionReviewers.parse(revision, IdString.fromDecoded(id)));
    } catch (OrmException e) {
        throw new RestApiException("Cannot parse reviewer", e);
    }
}
#method_after
@Override
public RevisionReviewerApi reviewer(String id) throws RestApiException {
    try {
        return revisionReviewerApi.create(revisionReviewers.parse(revision, IdString.fromDecoded(id)));
    } catch (Exception e) {
        throw asRestApiException("Cannot parse reviewer", e);
    }
}
#end_block

#method_before
@Override
public void setReviewed(String path, boolean reviewed) throws RestApiException {
    try {
        RestModifyView<FileResource, Reviewed.Input> view;
        if (reviewed) {
            view = putReviewed;
        } else {
            view = deleteReviewed;
        }
        view.apply(files.parse(revision, IdString.fromDecoded(path)), new Reviewed.Input());
    } catch (Exception e) {
        throw new RestApiException("Cannot update reviewed flag", e);
    }
}
#method_after
@Override
public void setReviewed(String path, boolean reviewed) throws RestApiException {
    try {
        RestModifyView<FileResource, Reviewed.Input> view;
        if (reviewed) {
            view = putReviewed;
        } else {
            view = deleteReviewed;
        }
        view.apply(files.parse(revision, IdString.fromDecoded(path)), new Reviewed.Input());
    } catch (Exception e) {
        throw asRestApiException("Cannot update reviewed flag", e);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public Set<String> reviewed() throws RestApiException {
    try {
        return ImmutableSet.copyOf((Iterable<String>) listFiles.setReviewed(true).apply(revision).value());
    } catch (OrmException | IOException | PatchListNotAvailableException e) {
        throw new RestApiException("Cannot list reviewed files", e);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Set<String> reviewed() throws RestApiException {
    try {
        return ImmutableSet.copyOf((Iterable<String>) listFiles.setReviewed(true).apply(revision).value());
    } catch (Exception e) {
        throw asRestApiException("Cannot list reviewed files", e);
    }
}
#end_block

#method_before
@Override
public MergeableInfo mergeable() throws RestApiException {
    try {
        return mergeable.apply(revision);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot check mergeability", e);
    }
}
#method_after
@Override
public MergeableInfo mergeable() throws RestApiException {
    try {
        return mergeable.apply(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot check mergeability", e);
    }
}
#end_block

#method_before
@Override
public MergeableInfo mergeableOtherBranches() throws RestApiException {
    try {
        mergeable.setOtherBranches(true);
        return mergeable.apply(revision);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot check mergeability", e);
    }
}
#method_after
@Override
public MergeableInfo mergeableOtherBranches() throws RestApiException {
    try {
        mergeable.setOtherBranches(true);
        return mergeable.apply(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot check mergeability", e);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public Map<String, FileInfo> files() throws RestApiException {
    try {
        return (Map<String, FileInfo>) listFiles.apply(revision).value();
    } catch (OrmException | IOException | PatchListNotAvailableException e) {
        throw new RestApiException("Cannot retrieve files", e);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Map<String, FileInfo> files() throws RestApiException {
    try {
        return (Map<String, FileInfo>) listFiles.apply(revision).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve files", e);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public Map<String, FileInfo> files(String base) throws RestApiException {
    try {
        return (Map<String, FileInfo>) listFiles.setBase(base).apply(revision).value();
    } catch (OrmException | IOException | PatchListNotAvailableException e) {
        throw new RestApiException("Cannot retrieve files", e);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Map<String, FileInfo> files(String base) throws RestApiException {
    try {
        return (Map<String, FileInfo>) listFiles.setBase(base).apply(revision).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve files", e);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public Map<String, FileInfo> files(int parentNum) throws RestApiException {
    try {
        return (Map<String, FileInfo>) listFiles.setParent(parentNum).apply(revision).value();
    } catch (OrmException | IOException | PatchListNotAvailableException e) {
        throw new RestApiException("Cannot retrieve files", e);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Map<String, FileInfo> files(int parentNum) throws RestApiException {
    try {
        return (Map<String, FileInfo>) listFiles.setParent(parentNum).apply(revision).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve files", e);
    }
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> comments() throws RestApiException {
    try {
        return listComments.apply(revision);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve comments", e);
    }
}
#method_after
@Override
public Map<String, List<CommentInfo>> comments() throws RestApiException {
    try {
        return listComments.apply(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve comments", e);
    }
}
#end_block

#method_before
@Override
public Map<String, List<RobotCommentInfo>> robotComments() throws RestApiException {
    try {
        return listRobotComments.apply(revision);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve robot comments", e);
    }
}
#method_after
@Override
public Map<String, List<RobotCommentInfo>> robotComments() throws RestApiException {
    try {
        return listRobotComments.apply(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve robot comments", e);
    }
}
#end_block

#method_before
@Override
public List<CommentInfo> commentsAsList() throws RestApiException {
    try {
        return listComments.getComments(revision);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve comments", e);
    }
}
#method_after
@Override
public List<CommentInfo> commentsAsList() throws RestApiException {
    try {
        return listComments.getComments(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve comments", e);
    }
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> drafts() throws RestApiException {
    try {
        return listDrafts.apply(revision);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve drafts", e);
    }
}
#method_after
@Override
public Map<String, List<CommentInfo>> drafts() throws RestApiException {
    try {
        return listDrafts.apply(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve drafts", e);
    }
}
#end_block

#method_before
@Override
public List<RobotCommentInfo> robotCommentsAsList() throws RestApiException {
    try {
        return listRobotComments.getComments(revision);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve robot comments", e);
    }
}
#method_after
@Override
public List<RobotCommentInfo> robotCommentsAsList() throws RestApiException {
    try {
        return listRobotComments.getComments(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve robot comments", e);
    }
}
#end_block

#method_before
@Override
public List<CommentInfo> draftsAsList() throws RestApiException {
    try {
        return listDrafts.getComments(revision);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve drafts", e);
    }
}
#method_after
@Override
public List<CommentInfo> draftsAsList() throws RestApiException {
    try {
        return listDrafts.getComments(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve drafts", e);
    }
}
#end_block

#method_before
@Override
public DraftApi draft(String id) throws RestApiException {
    try {
        return draftFactory.create(drafts.parse(revision, IdString.fromDecoded(id)));
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve draft", e);
    }
}
#method_after
@Override
public DraftApi draft(String id) throws RestApiException {
    try {
        return draftFactory.create(drafts.parse(revision, IdString.fromDecoded(id)));
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve draft", e);
    }
}
#end_block

#method_before
@Override
public DraftApi createDraft(DraftInput in) throws RestApiException {
    try {
        String id = createDraft.apply(revision, in).value().id;
        // Reread change to pick up new notes refs.
        return changes.id(revision.getChange().getId().get()).revision(revision.getPatchSet().getId().get()).draft(id);
    } catch (UpdateException | OrmException e) {
        throw new RestApiException("Cannot create draft", e);
    }
}
#method_after
@Override
public DraftApi createDraft(DraftInput in) throws RestApiException {
    try {
        String id = createDraft.apply(revision, in).value().id;
        // Reread change to pick up new notes refs.
        return changes.id(revision.getChange().getId().get()).revision(revision.getPatchSet().getId().get()).draft(id);
    } catch (Exception e) {
        throw asRestApiException("Cannot create draft", e);
    }
}
#end_block

#method_before
@Override
public CommentApi comment(String id) throws RestApiException {
    try {
        return commentFactory.create(comments.parse(revision, IdString.fromDecoded(id)));
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve comment", e);
    }
}
#method_after
@Override
public CommentApi comment(String id) throws RestApiException {
    try {
        return commentFactory.create(comments.parse(revision, IdString.fromDecoded(id)));
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve comment", e);
    }
}
#end_block

#method_before
@Override
public RobotCommentApi robotComment(String id) throws RestApiException {
    try {
        return robotCommentFactory.create(robotComments.parse(revision, IdString.fromDecoded(id)));
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve robot comment", e);
    }
}
#method_after
@Override
public RobotCommentApi robotComment(String id) throws RestApiException {
    try {
        return robotCommentFactory.create(robotComments.parse(revision, IdString.fromDecoded(id)));
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve robot comment", e);
    }
}
#end_block

#method_before
@Override
public BinaryResult patch() throws RestApiException {
    try {
        return getPatch.apply(revision);
    } catch (IOException e) {
        throw new RestApiException("Cannot get patch", e);
    }
}
#method_after
@Override
public BinaryResult patch() throws RestApiException {
    try {
        return getPatch.apply(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot get patch", e);
    }
}
#end_block

#method_before
@Override
public BinaryResult patch(String path) throws RestApiException {
    try {
        return getPatch.setPath(path).apply(revision);
    } catch (IOException e) {
        throw new RestApiException("Cannot get patch", e);
    }
}
#method_after
@Override
public BinaryResult patch(String path) throws RestApiException {
    try {
        return getPatch.setPath(path).apply(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot get patch", e);
    }
}
#end_block

#method_before
@Override
public Map<String, ActionInfo> actions() throws RestApiException {
    try {
        return revisionActions.apply(revision).value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot get actions", e);
    }
}
#method_after
@Override
public Map<String, ActionInfo> actions() throws RestApiException {
    try {
        return revisionActions.apply(revision).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot get actions", e);
    }
}
#end_block

#method_before
@Override
public SubmitType submitType() throws RestApiException {
    try {
        return getSubmitType.apply(revision);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get submit type", e);
    }
}
#method_after
@Override
public SubmitType submitType() throws RestApiException {
    try {
        return getSubmitType.apply(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot get submit type", e);
    }
}
#end_block

#method_before
@Override
public SubmitType testSubmitType(TestSubmitRuleInput in) throws RestApiException {
    try {
        return testSubmitType.apply(revision, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot test submit type", e);
    }
}
#method_after
@Override
public SubmitType testSubmitType(TestSubmitRuleInput in) throws RestApiException {
    try {
        return testSubmitType.apply(revision, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot test submit type", e);
    }
}
#end_block

#method_before
@Override
public MergeListRequest getMergeList() throws RestApiException {
    return new MergeListRequest() {

        @Override
        public List<CommitInfo> get() throws RestApiException {
            try {
                GetMergeList gml = getMergeList.get();
                gml.setUninterestingParent(getUninterestingParent());
                gml.setAddLinks(getAddLinks());
                return gml.apply(revision).value();
            } catch (IOException e) {
                throw new RestApiException("Cannot get merge list", e);
            }
        }
    };
}
#method_after
@Override
public MergeListRequest getMergeList() throws RestApiException {
    return new MergeListRequest() {

        @Override
        public List<CommitInfo> get() throws RestApiException {
            try {
                GetMergeList gml = getMergeList.get();
                gml.setUninterestingParent(getUninterestingParent());
                gml.setAddLinks(getAddLinks());
                return gml.apply(revision).value();
            } catch (Exception e) {
                throw asRestApiException("Cannot get merge list", e);
            }
        }
    };
}
#end_block

#method_before
@Override
public void description(String description) throws RestApiException {
    PutDescription.Input in = new PutDescription.Input();
    in.description = description;
    try {
        putDescription.apply(revision, in);
    } catch (UpdateException e) {
        throw new RestApiException("Cannot set description", e);
    }
}
#method_after
@Override
public void description(String description) throws RestApiException {
    PutDescription.Input in = new PutDescription.Input();
    in.description = description;
    try {
        putDescription.apply(revision, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot set description", e);
    }
}
#end_block

#method_before
public static Set<String> getFileParts(ChangeData cd) throws OrmException {
    List<String> paths = cd.currentFilePaths();
    if (paths == null) {
        return ImmutableSet.of();
    }
    Splitter s = Splitter.on('/').omitEmptyStrings();
    Set<String> r = new HashSet<>();
    for (String path : paths) {
        for (String part : s.split(path)) {
            r.add(part);
        }
    }
    return r;
}
#method_after
public static Set<String> getFileParts(ChangeData cd) throws OrmException {
    List<String> paths;
    try {
        paths = cd.currentFilePaths();
    } catch (IOException e) {
        throw new OrmException(e);
    }
    Splitter s = Splitter.on('/').omitEmptyStrings();
    Set<String> r = new HashSet<>();
    for (String path : paths) {
        for (String part : s.split(path)) {
            r.add(part);
        }
    }
    return r;
}
#end_block

#method_before
private static Iterable<String> getLabels(ChangeData input, boolean owners) throws OrmException {
    Set<String> allApprovals = new HashSet<>();
    Set<String> distinctApprovals = new HashSet<>();
    for (PatchSetApproval a : input.currentApprovals()) {
        if (a.getValue() != 0 && !a.isLegacySubmit()) {
            allApprovals.add(formatLabel(a.getLabel(), a.getValue(), a.getAccountId()));
            if (owners && input.change().getOwner().equals(a.getAccountId())) {
                allApprovals.add(formatLabel(a.getLabel(), a.getValue(), ChangeQueryBuilder.OWNER_ACCOUNT_ID));
            }
            distinctApprovals.add(formatLabel(a.getLabel(), a.getValue()));
        }
    }
    allApprovals.addAll(distinctApprovals);
    return allApprovals;
}
#method_after
private static Iterable<String> getLabels(ChangeData cd, boolean owners) throws OrmException {
    Set<String> allApprovals = new HashSet<>();
    Set<String> distinctApprovals = new HashSet<>();
    for (PatchSetApproval a : cd.currentApprovals()) {
        if (a.getValue() != 0 && !a.isLegacySubmit()) {
            allApprovals.add(formatLabel(a.getLabel(), a.getValue(), a.getAccountId()));
            if (owners && cd.change().getOwner().equals(a.getAccountId())) {
                allApprovals.add(formatLabel(a.getLabel(), a.getValue(), ChangeQueryBuilder.OWNER_ACCOUNT_ID));
            }
            distinctApprovals.add(formatLabel(a.getLabel(), a.getValue()));
        }
    }
    allApprovals.addAll(distinctApprovals);
    return allApprovals;
}
#end_block

#method_before
public static Set<String> getAuthorParts(ChangeData cd) throws OrmException {
    try {
        return SchemaUtil.getPersonParts(cd.getAuthor());
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
public static Set<String> getAuthorParts(ChangeData cd) throws OrmException, IOException {
    return SchemaUtil.getPersonParts(cd.getAuthor());
}
#end_block

#method_before
public static Set<String> getCommitterParts(ChangeData cd) throws OrmException {
    try {
        return SchemaUtil.getPersonParts(cd.getCommitter());
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
public static Set<String> getCommitterParts(ChangeData cd) throws OrmException, IOException {
    return SchemaUtil.getPersonParts(cd.getCommitter());
}
#end_block

#method_before
private static String getTopic(ChangeData input) throws OrmException {
    Change c = input.change();
    if (c == null) {
        return null;
    }
    return firstNonNull(c.getTopic(), "");
}
#method_after
private static String getTopic(ChangeData cd) throws OrmException {
    Change c = cd.change();
    if (c == null) {
        return null;
    }
    return firstNonNull(c.getTopic(), "");
}
#end_block

#method_before
public List<SubmitRecord> evaluate() {
    initOptions();
    Change c = control.getChange();
    if (!opts.allowClosed() && c.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    List<Term> results;
    try {
        results = evaluateImpl("locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results", control.getUser());
    } catch (RuleEvalException e) {
        return ruleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // whether or not that is actually possible given the permissions.
        return ruleError(String.format("Submit rule '%s' for change %s of %s has " + "no solution.", getSubmitRuleName(), cd.getId(), getProjectName()));
    }
    return resultsToSubmitRecord(getSubmitRule(), results);
}
#method_after
public List<SubmitRecord> evaluate() {
    initOptions();
    try {
        init();
    } catch (OrmException e) {
        return ruleError("Error looking up change " + cd.getId(), e);
    }
    if (!opts.allowClosed() && change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    List<Term> results;
    try {
        results = evaluateImpl("locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results", user);
    } catch (RuleEvalException e) {
        return ruleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // whether or not that is actually possible given the permissions.
        return ruleError(String.format("Submit rule '%s' for change %s of %s has no solution.", getSubmitRuleName(), cd.getId(), getProjectName()));
    }
    return resultsToSubmitRecord(getSubmitRule(), results);
}
#end_block

#method_before
private List<SubmitRecord> invalidResult(Term rule, Term record, String reason) {
    return ruleError(String.format("Submit rule %s for change %s of %s output " + "invalid result: %s%s", rule, cd.getId(), getProjectName(), record, (reason == null ? "" : ". Reason: " + reason)));
}
#method_after
private List<SubmitRecord> invalidResult(Term rule, Term record, String reason) {
    return ruleError(String.format("Submit rule %s for change %s of %s output invalid result: %s%s", rule, cd.getId(), getProjectName(), record, (reason == null ? "" : ". Reason: " + reason)));
}
#end_block

#method_before
public SubmitTypeRecord getSubmitType() {
    initOptions();
    try {
        initPatchSet();
    } catch (OrmException e) {
        return typeError("Error looking up patch set " + control.getChange().currentPatchSetId(), e);
    }
    List<Term> results;
    try {
        results = evaluateImpl("locate_submit_type", "get_submit_type", "locate_submit_type_filter", "filter_submit_type_results", // have a consistent view of the submit type.
        null);
    } catch (RuleEvalException e) {
        return typeError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // Should never occur for a well written rule
        return typeError("Submit rule '" + getSubmitRuleName() + "' for change " + cd.getId() + " of " + getProjectName() + " has no solution.");
    }
    Term typeTerm = results.get(0);
    if (!(typeTerm instanceof SymbolTerm)) {
        return typeError("Submit rule '" + getSubmitRuleName() + "' for change " + cd.getId() + " of " + getProjectName() + " did not return a symbol.");
    }
    String typeName = ((SymbolTerm) typeTerm).name();
    try {
        return SubmitTypeRecord.OK(SubmitType.valueOf(typeName.toUpperCase()));
    } catch (IllegalArgumentException e) {
        return typeError("Submit type rule " + getSubmitRule() + " for change " + cd.getId() + " of " + getProjectName() + " output invalid result: " + typeName);
    }
}
#method_after
public SubmitTypeRecord getSubmitType() {
    initOptions();
    try {
        init();
    } catch (OrmException e) {
        return typeError("Error looking up change " + cd.getId(), e);
    }
    List<Term> results;
    try {
        results = evaluateImpl("locate_submit_type", "get_submit_type", "locate_submit_type_filter", "filter_submit_type_results", // have a consistent view of the submit type.
        null);
    } catch (RuleEvalException e) {
        return typeError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // Should never occur for a well written rule
        return typeError("Submit rule '" + getSubmitRuleName() + "' for change " + cd.getId() + " of " + getProjectName() + " has no solution.");
    }
    Term typeTerm = results.get(0);
    if (!(typeTerm instanceof SymbolTerm)) {
        return typeError("Submit rule '" + getSubmitRuleName() + "' for change " + cd.getId() + " of " + getProjectName() + " did not return a symbol.");
    }
    String typeName = ((SymbolTerm) typeTerm).name();
    try {
        return SubmitTypeRecord.OK(SubmitType.valueOf(typeName.toUpperCase()));
    } catch (IllegalArgumentException e) {
        return typeError("Submit type rule " + getSubmitRule() + " for change " + cd.getId() + " of " + getProjectName() + " output invalid result: " + typeName);
    }
}
#end_block

#method_before
private PrologEnvironment getPrologEnvironment(CurrentUser user) throws RuleEvalException {
    ProjectState projectState = control.getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        if (opts.rule() == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", new StringReader(opts.rule()));
        }
    } catch (CompileException err) {
        String msg;
        if (opts.rule() == null && control.getProjectControl().isOwner()) {
            msg = String.format("Cannot load rules.pl for %s: %s", getProjectName(), err.getMessage());
        } else if (opts.rule() != null) {
            msg = err.getMessage();
        } else {
            msg = String.format("Cannot load rules.pl for %s", getProjectName());
        }
        throw new RuleEvalException(msg, err);
    }
    env.set(StoredValues.REVIEW_DB, cd.db());
    env.set(StoredValues.CHANGE_DATA, cd);
    env.set(StoredValues.CHANGE_CONTROL, control);
    if (user != null) {
        env.set(StoredValues.CURRENT_USER, user);
    }
    return env;
}
#method_after
private PrologEnvironment getPrologEnvironment(CurrentUser user) throws RuleEvalException {
    PrologEnvironment env;
    try {
        if (opts.rule() == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", new StringReader(opts.rule()));
        }
    } catch (CompileException err) {
        String msg;
        if (opts.rule() == null) {
            msg = String.format("Cannot load rules.pl for %s: %s", getProjectName(), err.getMessage());
        } else {
            msg = err.getMessage();
        }
        throw new RuleEvalException(msg, err);
    }
    env.set(StoredValues.ACCOUNTS, accounts);
    env.set(StoredValues.ACCOUNT_CACHE, accountCache);
    env.set(StoredValues.EMAILS, emails);
    env.set(StoredValues.REVIEW_DB, cd.db());
    env.set(StoredValues.CHANGE_DATA, cd);
    if (user != null) {
        env.set(StoredValues.CURRENT_USER, user);
    }
    env.set(StoredValues.PROJECT_STATE, projectState);
    return env;
}
#end_block

#method_before
private Term runSubmitFilters(Term results, PrologEnvironment env, String filterRuleLocatorName, String filterRuleWrapperName) throws RuleEvalException {
    ProjectState projectState = control.getProjectControl().getProjectState();
    PrologEnvironment childEnv = env;
    for (ProjectState parentState : projectState.parents()) {
        PrologEnvironment parentEnv;
        try {
            parentEnv = parentState.newPrologEnvironment();
        } catch (CompileException err) {
            throw new RuleEvalException("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
        }
        parentEnv.copyStoredValues(childEnv);
        Term filterRule = parentEnv.once("gerrit", filterRuleLocatorName, new VariableTerm());
        try {
            if (opts.fastEvalLabels()) {
                env.once("gerrit", "assume_range_from_label");
            }
            Term[] template = parentEnv.once("gerrit", filterRuleWrapperName, filterRule, results, new VariableTerm());
            results = template[2];
        } catch (ReductionLimitException err) {
            throw new RuleEvalException(String.format("%s on change %d of %s", err.getMessage(), cd.getId().get(), parentState.getProject().getName()));
        } catch (RuntimeException err) {
            throw new RuleEvalException(String.format("Exception calling %s on change %d of %s", filterRule, cd.getId().get(), parentState.getProject().getName()), err);
        } finally {
            reductionsConsumed += env.getReductions();
        }
        childEnv = parentEnv;
    }
    return results;
}
#method_after
private Term runSubmitFilters(Term results, PrologEnvironment env, String filterRuleLocatorName, String filterRuleWrapperName) throws RuleEvalException {
    PrologEnvironment childEnv = env;
    for (ProjectState parentState : projectState.parents()) {
        PrologEnvironment parentEnv;
        try {
            parentEnv = parentState.newPrologEnvironment();
        } catch (CompileException err) {
            throw new RuleEvalException("Cannot consult rules.pl for " + parentState.getName(), err);
        }
        parentEnv.copyStoredValues(childEnv);
        Term filterRule = parentEnv.once("gerrit", filterRuleLocatorName, new VariableTerm());
        try {
            if (opts.fastEvalLabels()) {
                env.once("gerrit", "assume_range_from_label");
            }
            Term[] template = parentEnv.once("gerrit", filterRuleWrapperName, filterRule, results, new VariableTerm());
            results = template[2];
        } catch (ReductionLimitException err) {
            throw new RuleEvalException(String.format("%s on change %d of %s", err.getMessage(), cd.getId().get(), parentState.getName()));
        } catch (RuntimeException err) {
            throw new RuleEvalException(String.format("Exception calling %s on change %d of %s", filterRule, cd.getId().get(), parentState.getName()), err);
        } finally {
            reductionsConsumed += env.getReductions();
        }
        childEnv = parentEnv;
    }
    return results;
}
#end_block

#method_before
private String getProjectName() {
    return control.getProjectControl().getProjectState().getProject().getName();
}
#method_after
private String getProjectName() {
    return projectState.getName();
}
#end_block

#method_before
public static String getDestBranchName(String refName) {
    String magicBranch = NEW_CHANGE;
    return refName.substring(magicBranch.length());
}
#method_after
public static String getDestBranchName(String refName) {
    String magicBranch = NEW_CHANGE;
    if (refName.startsWith(NEW_DRAFT_CHANGE)) {
        magicBranch = NEW_DRAFT_CHANGE;
    }
    return refName.substring(magicBranch.length());
}
#end_block

#method_before
public static boolean isMagicBranch(String refName) {
    return refName.startsWith(NEW_CHANGE);
}
#method_after
public static boolean isMagicBranch(String refName) {
    return refName.startsWith(NEW_DRAFT_CHANGE) || refName.startsWith(NEW_CHANGE);
}
#end_block

#method_before
public static String getMagicRefNamePrefix(String refName) {
    if (refName.startsWith(NEW_CHANGE)) {
        return NEW_CHANGE;
    }
    return null;
}
#method_after
public static String getMagicRefNamePrefix(String refName) {
    if (refName.startsWith(NEW_DRAFT_CHANGE)) {
        return NEW_DRAFT_CHANGE;
    }
    if (refName.startsWith(NEW_CHANGE)) {
        return NEW_CHANGE;
    }
    return null;
}
#end_block

#method_before
public static Capable checkMagicBranchRefs(Repository repo, Project project) {
    Capable result = checkMagicBranchRef(NEW_CHANGE, repo, project);
    if (result != Capable.OK) {
        return result;
    }
    return Capable.OK;
}
#method_after
public static Capable checkMagicBranchRefs(Repository repo, Project project) {
    Capable result = checkMagicBranchRef(NEW_CHANGE, repo, project);
    if (result != Capable.OK) {
        return result;
    }
    result = checkMagicBranchRef(NEW_DRAFT_CHANGE, repo, project);
    if (result != Capable.OK) {
        return result;
    }
    return Capable.OK;
}
#end_block

#method_before
@Override
public void onChangeAbandoned(ChangeAbandonedListener.Event event) {
    ChangeInfo change = event.getChange();
    String revision = event.getRevision().commit.commit;
    log.debug("Detected revision {} abandoned on {}.", revision, change.project);
    try {
        abandonDownstream(change, revision);
    } catch (ConfigInvalidException e) {
        log.error("Automerger plugin failed onChangeAbandoned for {}", change.id, e);
    }
}
#method_after
@Override
public void onChangeAbandoned(ChangeAbandonedListener.Event event) {
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(config.getContextUserId())) {
        ChangeInfo change = event.getChange();
        String revision = event.getRevision().commit.commit;
        log.debug("Detected revision {} abandoned on {}.", revision, change.project);
        abandonDownstream(change, revision);
    } catch (ConfigInvalidException | OrmException e) {
        log.error("Automerger plugin failed onChangeAbandoned for {}", event.getChange().id, e);
    }
}
#end_block

#method_before
@Override
public void onTopicEdited(TopicEditedListener.Event event) {
    ChangeInfo eventChange = event.getChange();
    // We have to re-query for this in order to include the current revision
    ChangeInfo change;
    try {
        change = gApi.changes().id(eventChange._number).get(EnumSet.of(ListChangesOption.CURRENT_REVISION));
    } catch (RestApiException e) {
        log.error("Automerger could not get change with current revision for onTopicEdited: ", e);
        return;
    }
    String oldTopic = event.getOldTopic();
    String revision = change.currentRevision;
    Set<String> downstreamBranches;
    try {
        downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
    } catch (RestApiException | IOException | ConfigInvalidException e) {
        log.error("Failed to edit downstream topics of {}", change.id, e);
        return;
    }
    if (downstreamBranches.isEmpty()) {
        log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
        return;
    }
    // If change is empty, prevent someone breaking topic.
    if (isNullOrEmpty(change.topic)) {
        try {
            gApi.changes().id(change._number).topic(oldTopic);
            ReviewInput reviewInput = new ReviewInput();
            reviewInput.message("Automerger prevented the topic from changing. Topic can only be modified on " + "non-automerger-created CLs to a non-empty value.");
            reviewInput.notify = NotifyHandling.NONE;
            gApi.changes().id(change._number).revision(change.currentRevision).review(reviewInput);
        } catch (RestApiException e) {
            log.error("Failed to prevent setting empty topic for automerger plugin.", e);
        }
    } else {
        for (String downstreamBranch : downstreamBranches) {
            try {
                List<Integer> existingDownstream = getExistingMergesOnBranch(revision, oldTopic, downstreamBranch);
                for (Integer changeNumber : existingDownstream) {
                    log.debug("Setting topic {} on {}", change.topic, changeNumber);
                    gApi.changes().id(changeNumber).topic(change.topic);
                }
            } catch (RestApiException | InvalidQueryParameterException e) {
                log.error("Failed to edit downstream topics of {}", change.id, e);
            }
        }
    }
}
#method_after
@Override
public void onTopicEdited(TopicEditedListener.Event event) {
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(config.getContextUserId())) {
        ChangeInfo eventChange = event.getChange();
        // We have to re-query for this in order to include the current revision
        ChangeInfo change;
        try {
            change = gApi.changes().id(eventChange._number).get(EnumSet.of(ListChangesOption.CURRENT_REVISION));
        } catch (RestApiException e) {
            log.error("Automerger could not get change with current revision for onTopicEdited: ", e);
            return;
        }
        String oldTopic = event.getOldTopic();
        String revision = change.currentRevision;
        Set<String> downstreamBranches;
        try {
            downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
        } catch (RestApiException | IOException | ConfigInvalidException e) {
            log.error("Failed to edit downstream topics of {}", change.id, e);
            return;
        }
        if (downstreamBranches.isEmpty()) {
            log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
            return;
        }
        // If change is empty, prevent someone breaking topic.
        if (isNullOrEmpty(change.topic)) {
            try {
                gApi.changes().id(change._number).topic(oldTopic);
                ReviewInput reviewInput = new ReviewInput();
                reviewInput.message("Automerger prevented the topic from changing. Topic can only be modified on " + "non-automerger-created CLs to a non-empty value.");
                reviewInput.notify = NotifyHandling.NONE;
                gApi.changes().id(change._number).revision(CURRENT).review(reviewInput);
            } catch (RestApiException e) {
                log.error("Failed to prevent setting empty topic for automerger plugin.", e);
            }
        } else {
            for (String downstreamBranch : downstreamBranches) {
                try {
                    List<Integer> existingDownstream = getExistingMergesOnBranch(revision, oldTopic, downstreamBranch);
                    for (Integer changeNumber : existingDownstream) {
                        log.debug("Setting topic {} on {}", change.topic, changeNumber);
                        gApi.changes().id(changeNumber).topic(change.topic);
                    }
                } catch (RestApiException | InvalidQueryParameterException e) {
                    log.error("Failed to edit downstream topics of {}", change.id, e);
                }
            }
        }
    } catch (OrmException | ConfigInvalidException e) {
        log.error("Automerger plugin failed onTopicEdited for {}", event.getChange().id, e);
    }
}
#end_block

#method_before
@Override
public void onCommentAdded(CommentAddedListener.Event event) {
    RevisionInfo eventRevision = event.getRevision();
    if (!eventRevision.isCurrent) {
        log.info("Not updating downstream votes since revision {} is not current.", eventRevision._number);
        return;
    }
    ChangeInfo change = event.getChange();
    String revision = change.currentRevision;
    Set<String> downstreamBranches;
    try {
        downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
    } catch (RestApiException | IOException | ConfigInvalidException e) {
        log.error("Failed to update downstream votes of {}", change.id, e);
        return;
    }
    if (downstreamBranches.isEmpty()) {
        log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
        return;
    }
    Map<String, ApprovalInfo> approvals = event.getApprovals();
    for (String downstreamBranch : downstreamBranches) {
        try {
            List<Integer> existingDownstream = getExistingMergesOnBranch(revision, change.topic, downstreamBranch);
            for (Integer changeNumber : existingDownstream) {
                ChangeInfo downstreamChange = gApi.changes().id(changeNumber).get(EnumSet.of(ListChangesOption.CURRENT_REVISION));
                for (Map.Entry<String, ApprovalInfo> label : approvals.entrySet()) {
                    updateVote(downstreamChange, label.getKey(), label.getValue().value.shortValue());
                }
            }
        } catch (RestApiException | InvalidQueryParameterException e) {
            log.error("Exception when updating downstream votes of {}", change.id, e);
        }
    }
}
#method_after
@Override
public void onCommentAdded(CommentAddedListener.Event event) {
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(config.getContextUserId())) {
        RevisionInfo eventRevision = event.getRevision();
        if (!eventRevision.isCurrent) {
            log.info("Not updating downstream votes since revision {} is not current.", eventRevision._number);
            return;
        }
        ChangeInfo change = event.getChange();
        String revision = change.currentRevision;
        Set<String> downstreamBranches;
        downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
        if (downstreamBranches.isEmpty()) {
            log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
            return;
        }
        Map<String, LabelInfo> labels = gApi.changes().id(change._number).get(EnumSet.of(ListChangesOption.DETAILED_LABELS)).labels;
        for (String downstreamBranch : downstreamBranches) {
            try {
                List<Integer> existingDownstream = getExistingMergesOnBranch(revision, change.topic, downstreamBranch);
                for (Integer changeNumber : existingDownstream) {
                    ChangeInfo downstreamChange = gApi.changes().id(changeNumber).get(EnumSet.of(ListChangesOption.CURRENT_REVISION));
                    for (Map.Entry<String, LabelInfo> labelEntry : labels.entrySet()) {
                        if (labelEntry.getValue().all.size() > 0) {
                            OptionalInt maxVote = labelEntry.getValue().all.stream().filter(o -> o.value != null).mapToInt(i -> i.value).max();
                            if (maxVote.isPresent()) {
                                updateVote(downstreamChange, labelEntry.getKey(), (short) maxVote.getAsInt());
                            }
                        }
                    }
                }
            } catch (RestApiException | InvalidQueryParameterException e) {
                log.error("Exception when updating downstream votes of {}", change.id, e);
            }
        }
    } catch (OrmException | ConfigInvalidException | RestApiException | IOException e) {
        log.error("Automerger plugin failed onCommentAdded for {}", event.getChange().id, e);
    }
}
#end_block

#method_before
@Override
public void onChangeRestored(ChangeRestoredListener.Event event) {
    ChangeInfo change = event.getChange();
    try {
        automergeChanges(change, event.getRevision());
    } catch (RestApiException | IOException | ConfigInvalidException | InvalidQueryParameterException e) {
        log.error("Automerger plugin failed onChangeRestored for {}", change.id, e);
    }
}
#method_after
@Override
public void onChangeRestored(ChangeRestoredListener.Event event) {
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(config.getContextUserId())) {
        ChangeInfo change = event.getChange();
        automergeChanges(change, event.getRevision());
    } catch (RestApiException | IOException | ConfigInvalidException | InvalidQueryParameterException | OrmException e) {
        log.error("Automerger plugin failed onChangeRestored for {}", event.getChange().id, e);
    }
}
#end_block

#method_before
@Override
public void onRevisionCreated(RevisionCreatedListener.Event event) {
    ChangeInfo change = event.getChange();
    try {
        automergeChanges(change, event.getRevision());
    } catch (RestApiException | IOException | ConfigInvalidException | InvalidQueryParameterException e) {
        log.error("Automerger plugin failed onRevisionCreated for {}", change.id, e);
    }
}
#method_after
@Override
public void onRevisionCreated(RevisionCreatedListener.Event event) {
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(config.getContextUserId())) {
        ChangeInfo change = event.getChange();
        automergeChanges(change, event.getRevision());
    } catch (RestApiException | IOException | ConfigInvalidException | InvalidQueryParameterException | OrmException e) {
        log.error("Automerger plugin failed onRevisionCreated for {}", event.getChange().id, e);
    }
}
#end_block

#method_before
public void createMergesAndHandleConflicts(MultipleDownstreamMergeInput mdsMergeInput) throws RestApiException, ConfigInvalidException, InvalidQueryParameterException {
    ReviewInput reviewInput = new ReviewInput();
    Map<String, Short> labels = new HashMap<String, Short>();
    try {
        createDownstreamMerges(mdsMergeInput);
        reviewInput.message = "Automerging to " + Joiner.on(", ").join(mdsMergeInput.dsBranchMap.keySet()) + " succeeded!";
        reviewInput.notify = NotifyHandling.NONE;
    } catch (FailedMergeException e) {
        reviewInput.message = e.getDisplayString();
        reviewInput.notify = NotifyHandling.ALL;
        reviewInput.tag = MERGE_CONFLICT_TAG;
        // Vote minAutomergeVote if we hit a conflict.
        if (!config.minAutomergeVoteDisabled()) {
            labels.put(config.getAutomergeLabel(), config.getMinAutomergeVote());
        }
    }
    reviewInput.labels = labels;
    // if this fails, i.e. -2 is restricted, catch it and still post message without a vote.
    try {
        gApi.changes().id(mdsMergeInput.changeNumber).revision(mdsMergeInput.currentRevision).review(reviewInput);
    } catch (AuthException e) {
        reviewInput.labels = null;
        gApi.changes().id(mdsMergeInput.changeNumber).revision(mdsMergeInput.currentRevision).review(reviewInput);
    }
}
#method_after
public void createMergesAndHandleConflicts(MultipleDownstreamMergeInput mdsMergeInput) throws RestApiException, ConfigInvalidException, InvalidQueryParameterException, OrmException {
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(config.getContextUserId())) {
        ReviewInput reviewInput = new ReviewInput();
        Map<String, Short> labels = new HashMap<>();
        try {
            createDownstreamMerges(mdsMergeInput);
            reviewInput.message = "Automerging change " + mdsMergeInput.changeNumber + " to " + Joiner.on(", ").join(mdsMergeInput.dsBranchMap.keySet()) + " succeeded!";
            reviewInput.notify = NotifyHandling.NONE;
        } catch (FailedMergeException e) {
            reviewInput.message = e.getDisplayString();
            reviewInput.notify = NotifyHandling.ALL;
            reviewInput.tag = MERGE_CONFLICT_TAG;
            // Vote minAutomergeVote if we hit a conflict.
            if (!config.minAutomergeVoteDisabled()) {
                labels.put(config.getAutomergeLabel(), config.getMinAutomergeVote());
            }
        }
        reviewInput.labels = labels;
        // Make the vote on the original change
        ChangeInfo originalChange = getOriginalChange(mdsMergeInput.changeNumber, mdsMergeInput.currentRevision);
        // if this fails, i.e. -2 is restricted, catch it and still post message without a vote.
        try {
            gApi.changes().id(originalChange._number).revision(CURRENT).review(reviewInput);
        } catch (AuthException e) {
            reviewInput.labels = null;
            gApi.changes().id(originalChange._number).revision(CURRENT).review(reviewInput);
        }
    }
}
#end_block

#method_before
public void createDownstreamMerges(MultipleDownstreamMergeInput mdsMergeInput) throws RestApiException, FailedMergeException, ConfigInvalidException, InvalidQueryParameterException {
    // Map from branch to error message
    Map<String, String> failedMergeBranchMap = new TreeMap<String, String>();
    List<Integer> existingDownstream;
    for (String downstreamBranch : mdsMergeInput.dsBranchMap.keySet()) {
        // If there are existing downstream merges, update them
        // Otherwise, create them.
        boolean createDownstreams = true;
        if (mdsMergeInput.obsoleteRevision != null) {
            existingDownstream = getExistingMergesOnBranch(mdsMergeInput.obsoleteRevision, mdsMergeInput.topic, downstreamBranch);
            if (!existingDownstream.isEmpty()) {
                log.debug("Attempting to update downstream merge of {} on branch {}", mdsMergeInput.currentRevision, downstreamBranch);
                // it's possible to construct it so that it's not
                for (Integer dsChangeNumber : existingDownstream) {
                    try {
                        updateDownstreamMerge(mdsMergeInput.currentRevision, mdsMergeInput.subject, dsChangeNumber, mdsMergeInput.dsBranchMap.get(downstreamBranch));
                        createDownstreams = false;
                    } catch (MergeConflictException e) {
                        failedMergeBranchMap.put(downstreamBranch, e.getMessage());
                        log.debug("Abandoning existing, obsolete {} due to merge conflict.", dsChangeNumber);
                        abandonChange(dsChangeNumber);
                    }
                }
            }
        }
        if (createDownstreams) {
            log.debug("Attempting to create downstream merge of {} on branch {}", mdsMergeInput.currentRevision, downstreamBranch);
            SingleDownstreamMergeInput sdsMergeInput = new SingleDownstreamMergeInput();
            sdsMergeInput.currentRevision = mdsMergeInput.currentRevision;
            sdsMergeInput.changeNumber = mdsMergeInput.changeNumber;
            sdsMergeInput.project = mdsMergeInput.project;
            sdsMergeInput.topic = mdsMergeInput.topic;
            sdsMergeInput.subject = mdsMergeInput.subject;
            sdsMergeInput.downstreamBranch = downstreamBranch;
            sdsMergeInput.doMerge = mdsMergeInput.dsBranchMap.get(downstreamBranch);
            try {
                createSingleDownstreamMerge(sdsMergeInput);
            } catch (MergeConflictException e) {
                failedMergeBranchMap.put(downstreamBranch, e.getMessage());
            }
        }
    }
    if (!failedMergeBranchMap.isEmpty()) {
        throw new FailedMergeException(failedMergeBranchMap, mdsMergeInput.currentRevision, config.getHostName(), mdsMergeInput.project, mdsMergeInput.changeNumber, mdsMergeInput.patchsetNumber, config.getConflictMessage(), mdsMergeInput.topic);
    }
}
#method_after
public void createDownstreamMerges(MultipleDownstreamMergeInput mdsMergeInput) throws RestApiException, FailedMergeException, ConfigInvalidException, InvalidQueryParameterException, OrmException {
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(config.getContextUserId())) {
        // Map from branch to error message
        Map<String, String> failedMergeBranchMap = new TreeMap<>();
        List<Integer> existingDownstream;
        for (String downstreamBranch : mdsMergeInput.dsBranchMap.keySet()) {
            // If there are existing downstream merges, update them
            // Otherwise, create them.
            boolean createDownstreams = true;
            if (mdsMergeInput.obsoleteRevision != null) {
                existingDownstream = getExistingMergesOnBranch(mdsMergeInput.obsoleteRevision, mdsMergeInput.topic, downstreamBranch);
                if (!existingDownstream.isEmpty()) {
                    log.debug("Attempting to update downstream merge of {} on branch {}", mdsMergeInput.currentRevision, downstreamBranch);
                    // it's possible to construct it so that it's not
                    for (Integer dsChangeNumber : existingDownstream) {
                        try {
                            updateDownstreamMerge(mdsMergeInput.currentRevision, mdsMergeInput.subject, dsChangeNumber, mdsMergeInput.dsBranchMap.get(downstreamBranch));
                            createDownstreams = false;
                        } catch (MergeConflictException e) {
                            failedMergeBranchMap.put(downstreamBranch, e.getMessage());
                            log.debug("Abandoning existing, obsolete {} due to merge conflict.", dsChangeNumber);
                            abandonChange(dsChangeNumber);
                        }
                    }
                }
            }
            if (createDownstreams) {
                log.debug("Attempting to create downstream merge of {} on branch {}", mdsMergeInput.currentRevision, downstreamBranch);
                SingleDownstreamMergeInput sdsMergeInput = new SingleDownstreamMergeInput();
                sdsMergeInput.currentRevision = mdsMergeInput.currentRevision;
                sdsMergeInput.changeNumber = mdsMergeInput.changeNumber;
                sdsMergeInput.project = mdsMergeInput.project;
                sdsMergeInput.topic = mdsMergeInput.topic;
                sdsMergeInput.subject = mdsMergeInput.subject;
                sdsMergeInput.downstreamBranch = downstreamBranch;
                sdsMergeInput.doMerge = mdsMergeInput.dsBranchMap.get(downstreamBranch);
                try {
                    createSingleDownstreamMerge(sdsMergeInput);
                } catch (MergeConflictException e) {
                    failedMergeBranchMap.put(downstreamBranch, e.getMessage());
                }
            }
        }
        if (!failedMergeBranchMap.isEmpty()) {
            throw new FailedMergeException(failedMergeBranchMap, mdsMergeInput.currentRevision, config.getHostName(), mdsMergeInput.project, mdsMergeInput.changeNumber, mdsMergeInput.patchsetNumber, config.getConflictMessage(), mdsMergeInput.topic);
        }
    }
}
#end_block

#method_before
public List<Integer> getExistingMergesOnBranch(String upstreamRevision, String topic, String downstreamBranch) throws RestApiException, InvalidQueryParameterException {
    List<Integer> downstreamChangeNumbers = new ArrayList<Integer>();
    List<ChangeInfo> changes = getChangesInTopicAndBranch(topic, downstreamBranch);
    for (ChangeInfo change : changes) {
        String changeRevision = change.currentRevision;
        RevisionInfo revision = change.revisions.get(changeRevision);
        List<CommitInfo> parents = revision.commit.parents;
        if (parents.size() > 1) {
            String secondParent = parents.get(1).commit;
            if (secondParent.equals(upstreamRevision)) {
                downstreamChangeNumbers.add(change._number);
            }
        }
    }
    return downstreamChangeNumbers;
}
#method_after
public List<Integer> getExistingMergesOnBranch(String upstreamRevision, String topic, String downstreamBranch) throws RestApiException, InvalidQueryParameterException, OrmException, ConfigInvalidException {
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(config.getContextUserId())) {
        List<Integer> downstreamChangeNumbers = new ArrayList<>();
        List<ChangeInfo> changes = getChangesInTopicAndBranch(topic, downstreamBranch);
        for (ChangeInfo change : changes) {
            String changeRevision = change.currentRevision;
            RevisionInfo revision = change.revisions.get(changeRevision);
            List<CommitInfo> parents = revision.commit.parents;
            if (parents.size() > 1) {
                String secondParent = parents.get(1).commit;
                if (secondParent.equals(upstreamRevision)) {
                    downstreamChangeNumbers.add(change._number);
                }
            }
        }
        return downstreamChangeNumbers;
    }
}
#end_block

#method_before
public void createSingleDownstreamMerge(SingleDownstreamMergeInput sdsMergeInput) throws RestApiException, ConfigInvalidException, InvalidQueryParameterException {
    String currentTopic = getOrSetTopic(sdsMergeInput.changeNumber, sdsMergeInput.topic);
    if (isAlreadyMerged(sdsMergeInput, currentTopic)) {
        log.info("Commit {} already merged into {}, not automerging again.", sdsMergeInput.currentRevision, sdsMergeInput.downstreamBranch);
        return;
    }
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = sdsMergeInput.currentRevision;
    mergeInput.strategy = "recursive";
    log.debug("Creating downstream merge for {}", sdsMergeInput.currentRevision);
    ChangeInput downstreamChangeInput = new ChangeInput();
    downstreamChangeInput.project = sdsMergeInput.project;
    downstreamChangeInput.branch = sdsMergeInput.downstreamBranch;
    downstreamChangeInput.subject = getSubjectForDownstreamMerge(sdsMergeInput.subject, sdsMergeInput.currentRevision, false);
    downstreamChangeInput.topic = currentTopic;
    downstreamChangeInput.merge = mergeInput;
    downstreamChangeInput.notify = NotifyHandling.NONE;
    downstreamChangeInput.baseChange = getBaseChangeId(getChangeParents(sdsMergeInput.changeNumber, sdsMergeInput.currentRevision), sdsMergeInput.downstreamBranch);
    if (!sdsMergeInput.doMerge) {
        mergeInput.strategy = "ours";
        downstreamChangeInput.subject = getSubjectForDownstreamMerge(sdsMergeInput.subject, sdsMergeInput.currentRevision, true);
        log.debug("Skipping merge for {} to {}", sdsMergeInput.currentRevision, sdsMergeInput.downstreamBranch);
    }
    ChangeApi downstreamChange = gApi.changes().create(downstreamChangeInput);
    // Vote maxAutomergeVote on the change so we know it was successful.
    if (!config.maxAutomergeVoteDisabled()) {
        updateVote(downstreamChange.get(), config.getAutomergeLabel(), config.getMaxAutomergeVote());
    }
}
#method_after
public void createSingleDownstreamMerge(SingleDownstreamMergeInput sdsMergeInput) throws RestApiException, ConfigInvalidException, InvalidQueryParameterException, OrmException {
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(config.getContextUserId())) {
        String currentTopic = getOrSetTopic(sdsMergeInput.changeNumber, sdsMergeInput.topic);
        if (isAlreadyMerged(sdsMergeInput, currentTopic)) {
            log.info("Commit {} already merged into {}, not automerging again.", sdsMergeInput.currentRevision, sdsMergeInput.downstreamBranch);
            return;
        }
        MergeInput mergeInput = new MergeInput();
        mergeInput.source = sdsMergeInput.currentRevision;
        mergeInput.strategy = "recursive";
        log.debug("Creating downstream merge for {}", sdsMergeInput.currentRevision);
        ChangeInput downstreamChangeInput = new ChangeInput();
        downstreamChangeInput.project = sdsMergeInput.project;
        downstreamChangeInput.branch = sdsMergeInput.downstreamBranch;
        downstreamChangeInput.subject = getSubjectForDownstreamMerge(sdsMergeInput.subject, sdsMergeInput.currentRevision, false);
        downstreamChangeInput.topic = currentTopic;
        downstreamChangeInput.merge = mergeInput;
        downstreamChangeInput.notify = NotifyHandling.NONE;
        downstreamChangeInput.baseChange = getBaseChangeId(getChangeParents(sdsMergeInput.changeNumber, sdsMergeInput.currentRevision), sdsMergeInput.downstreamBranch);
        if (!sdsMergeInput.doMerge) {
            mergeInput.strategy = "ours";
            downstreamChangeInput.subject = getSubjectForDownstreamMerge(sdsMergeInput.subject, sdsMergeInput.currentRevision, true);
            log.debug("Skipping merge for {} to {}", sdsMergeInput.currentRevision, sdsMergeInput.downstreamBranch);
        }
        ChangeApi downstreamChange = gApi.changes().create(downstreamChangeInput);
        tagChange(downstreamChange.get(), "Automerger change created!");
    }
}
#end_block

#method_before
public String getOrSetTopic(int sourceId, String topic) throws RestApiException {
    if (isNullOrEmpty(topic)) {
        topic = "am-" + UUID.randomUUID();
        log.debug("Setting original change {} topic to {}", sourceId, topic);
        gApi.changes().id(sourceId).topic(topic);
    }
    return topic;
}
#method_after
public String getOrSetTopic(int sourceId, String topic) throws RestApiException, OrmException, ConfigInvalidException {
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(config.getContextUserId())) {
        if (isNullOrEmpty(topic)) {
            topic = "am-" + UUID.randomUUID();
            log.debug("Setting original change {} topic to {}", sourceId, topic);
            gApi.changes().id(sourceId).topic(topic);
        }
        return topic;
    }
}
#end_block

#method_before
private void automergeChanges(ChangeInfo change, RevisionInfo revisionInfo) throws RestApiException, IOException, ConfigInvalidException, InvalidQueryParameterException {
    if (revisionInfo.draft != null && revisionInfo.draft) {
        log.debug("Patchset {} is draft change, ignoring.", revisionInfo.commit.commit);
        return;
    }
    String currentRevision = revisionInfo.commit.commit;
    log.debug("Handling patchsetevent with change id {} and revision {}", change.id, currentRevision);
    Set<String> downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
    if (downstreamBranches.isEmpty()) {
        log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
        return;
    }
    // Map whether or not we should merge it or skip it for each downstream
    Map<String, Boolean> dsBranchMap = new HashMap<String, Boolean>();
    for (String downstreamBranch : downstreamBranches) {
        boolean isSkipMerge = config.isSkipMerge(change.branch, downstreamBranch, change.subject);
        dsBranchMap.put(downstreamBranch, !isSkipMerge);
    }
    log.debug("Automerging change {} from branch {}", change.id, change.branch);
    ChangeApi currentChange = gApi.changes().id(change._number);
    String previousRevision = getPreviousRevision(currentChange, revisionInfo._number);
    MultipleDownstreamMergeInput mdsMergeInput = new MultipleDownstreamMergeInput();
    mdsMergeInput.dsBranchMap = dsBranchMap;
    mdsMergeInput.changeNumber = change._number;
    mdsMergeInput.patchsetNumber = revisionInfo._number;
    mdsMergeInput.project = change.project;
    mdsMergeInput.topic = getOrSetTopic(change._number, change.topic);
    mdsMergeInput.subject = change.subject;
    mdsMergeInput.obsoleteRevision = previousRevision;
    mdsMergeInput.currentRevision = currentRevision;
    createMergesAndHandleConflicts(mdsMergeInput);
}
#method_after
private void automergeChanges(ChangeInfo change, RevisionInfo revisionInfo) throws RestApiException, IOException, ConfigInvalidException, InvalidQueryParameterException, OrmException {
    if (revisionInfo.draft != null && revisionInfo.draft) {
        log.debug("Patchset {} is draft change, ignoring.", revisionInfo.commit.commit);
        return;
    }
    String currentRevision = revisionInfo.commit.commit;
    log.debug("Handling patchsetevent with change id {} and revision {}", change.id, currentRevision);
    Set<String> downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
    if (downstreamBranches.isEmpty()) {
        log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
        return;
    }
    // Map whether or not we should merge it or skip it for each downstream
    Map<String, Boolean> dsBranchMap = new HashMap<String, Boolean>();
    for (String downstreamBranch : downstreamBranches) {
        boolean isSkipMerge = config.isSkipMerge(change.branch, downstreamBranch, change.subject);
        dsBranchMap.put(downstreamBranch, !isSkipMerge);
    }
    log.debug("Automerging change {} from branch {}", change.id, change.branch);
    ChangeApi currentChange = gApi.changes().id(change._number);
    String previousRevision = getPreviousRevision(currentChange, revisionInfo._number);
    MultipleDownstreamMergeInput mdsMergeInput = new MultipleDownstreamMergeInput();
    mdsMergeInput.dsBranchMap = dsBranchMap;
    mdsMergeInput.changeNumber = change._number;
    mdsMergeInput.patchsetNumber = revisionInfo._number;
    mdsMergeInput.project = change.project;
    mdsMergeInput.topic = getOrSetTopic(change._number, change.topic);
    mdsMergeInput.subject = change.subject;
    mdsMergeInput.obsoleteRevision = previousRevision;
    mdsMergeInput.currentRevision = currentRevision;
    createMergesAndHandleConflicts(mdsMergeInput);
}
#end_block

#method_before
private void abandonDownstream(ChangeInfo change, String revision) throws ConfigInvalidException {
    try {
        Set<String> downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
        if (downstreamBranches.isEmpty()) {
            log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
            return;
        }
        for (String downstreamBranch : downstreamBranches) {
            List<Integer> existingDownstream = getExistingMergesOnBranch(revision, change.topic, downstreamBranch);
            log.debug("Abandoning existing downstreams: {}", existingDownstream);
            for (Integer changeNumber : existingDownstream) {
                abandonChange(changeNumber);
            }
        }
    } catch (RestApiException | IOException | InvalidQueryParameterException e) {
        log.error("Failed to abandon downstreams of {}", change.id, e);
    }
}
#method_after
private void abandonDownstream(ChangeInfo change, String revision) throws ConfigInvalidException, OrmException {
    try {
        Set<String> downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
        if (downstreamBranches.isEmpty()) {
            log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
            return;
        }
        for (String downstreamBranch : downstreamBranches) {
            List<Integer> existingDownstream = getExistingMergesOnBranch(revision, change.topic, downstreamBranch);
            log.debug("Abandoning existing downstreams: {}", existingDownstream);
            for (Integer changeNumber : existingDownstream) {
                abandonChange(changeNumber);
            }
        }
    } catch (RestApiException | IOException | InvalidQueryParameterException e) {
        log.error("Failed to abandon downstreams of {}", change.id, e);
    }
}
#end_block

#method_before
private void updateVote(ChangeInfo change, String label, short vote) throws RestApiException {
    log.debug("Giving {} for label {} to {}", vote, label, change.id);
    // Vote on all downstream branches unless merge conflict.
    ReviewInput reviewInput = new ReviewInput();
    Map<String, Short> labels = new HashMap<String, Short>();
    labels.put(label, vote);
    reviewInput.labels = labels;
    reviewInput.notify = NotifyHandling.NONE;
    reviewInput.tag = AUTOMERGER_TAG;
    try {
        gApi.changes().id(change.id).revision(change.currentRevision).review(reviewInput);
    } catch (AuthException e) {
        log.error("Automerger could not set label, but still continuing.", e);
    }
}
#method_after
private void updateVote(ChangeInfo change, String label, short vote) throws RestApiException {
    log.debug("Giving {} for label {} to {}", vote, label, change.id);
    // Vote on all downstream branches unless merge conflict.
    ReviewInput reviewInput = new ReviewInput();
    Map<String, Short> labels = new HashMap<String, Short>();
    labels.put(label, vote);
    reviewInput.labels = labels;
    reviewInput.notify = NotifyHandling.NONE;
    reviewInput.tag = AUTOMERGER_TAG;
    try {
        gApi.changes().id(change.id).revision(CURRENT).review(reviewInput);
    } catch (AuthException e) {
        log.error("Automerger could not set label, but still continuing.", e);
    }
}
#end_block

#method_before
private void updateDownstreamMerge(String newParentRevision, String upstreamSubject, Integer sourceNum, boolean doMerge) throws RestApiException, ConfigInvalidException {
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = newParentRevision;
    MergePatchSetInput mergePatchSetInput = new MergePatchSetInput();
    mergePatchSetInput.subject = getSubjectForDownstreamMerge(upstreamSubject, newParentRevision, false);
    if (!doMerge) {
        mergeInput.strategy = "ours";
        mergePatchSetInput.subject = getSubjectForDownstreamMerge(upstreamSubject, newParentRevision, true);
        log.debug("Skipping merge for {} on {}", newParentRevision, sourceNum);
    }
    mergePatchSetInput.merge = mergeInput;
    ChangeApi originalChange = gApi.changes().id(sourceNum);
    if (originalChange.info().status == ChangeStatus.ABANDONED) {
        RestoreInput restoreInput = new RestoreInput();
        restoreInput.message = "Restoring change due to upstream automerge.";
        originalChange.restore(restoreInput);
    }
    ChangeInfo downstreamChange = originalChange.createMergePatchSet(mergePatchSetInput);
    if (!config.maxAutomergeVoteDisabled()) {
        updateVote(downstreamChange, config.getAutomergeLabel(), config.getMaxAutomergeVote());
    }
}
#method_after
private void updateDownstreamMerge(String newParentRevision, String upstreamSubject, Integer sourceNum, boolean doMerge) throws RestApiException {
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = newParentRevision;
    MergePatchSetInput mergePatchSetInput = new MergePatchSetInput();
    mergePatchSetInput.subject = getSubjectForDownstreamMerge(upstreamSubject, newParentRevision, false);
    if (!doMerge) {
        mergeInput.strategy = "ours";
        mergePatchSetInput.subject = getSubjectForDownstreamMerge(upstreamSubject, newParentRevision, true);
        log.debug("Skipping merge for {} on {}", newParentRevision, sourceNum);
    }
    mergePatchSetInput.merge = mergeInput;
    ChangeApi originalChange = gApi.changes().id(sourceNum);
    if (originalChange.info().status == ChangeStatus.ABANDONED) {
        RestoreInput restoreInput = new RestoreInput();
        restoreInput.message = "Restoring change due to upstream automerge.";
        originalChange.restore(restoreInput);
    }
    originalChange.createMergePatchSet(mergePatchSetInput);
}
#end_block

#method_before
private List<ChangeInfo> getChangesInTopicAndBranch(String topic, String downstreamBranch) throws InvalidQueryParameterException, RestApiException {
    QueryBuilder queryBuilder = new QueryBuilder();
    queryBuilder.addParameter("topic", topic);
    queryBuilder.addParameter("branch", downstreamBranch);
    queryBuilder.addParameter("status", "open");
    return gApi.changes().query(queryBuilder.get()).withOptions(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_COMMIT).get();
}
#method_after
private List<ChangeInfo> getChangesInTopicAndBranch(String topic, String downstreamBranch) throws InvalidQueryParameterException, RestApiException {
    QueryBuilder queryBuilder = constructTopicQuery(topic);
    queryBuilder.addParameter("branch", downstreamBranch);
    return gApi.changes().query(queryBuilder.get()).withOptions(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_COMMIT).get();
}
#end_block

#method_before
private String getSubjectForDownstreamMerge(String upstreamSubject, String upstreamRevision, boolean skipped) {
    if (!upstreamSubject.startsWith(SUBJECT_PREFIX)) {
        upstreamSubject = Joiner.on(" ").join(SUBJECT_PREFIX, upstreamSubject);
    }
    String denotationString = skipped ? "skipped:" : "am:";
    return Joiner.on(" ").join(upstreamSubject, denotationString, upstreamRevision.substring(0, 10));
}
#method_after
private String getSubjectForDownstreamMerge(String upstreamSubject, String upstreamRevision, boolean skipped) {
    if (!upstreamSubject.startsWith("[" + SUBJECT_PREFIX)) {
        String prefix = "[" + SUBJECT_PREFIX + "]";
        if (skipped) {
            prefix = "[" + SUBJECT_PREFIX + " " + SKIPPED_PREFIX + "]";
        }
        upstreamSubject = Joiner.on(" ").join(prefix, upstreamSubject);
    }
    String denotationString = skipped ? "skipped:" : "am:";
    return Joiner.on(" ").join(upstreamSubject, denotationString, upstreamRevision.substring(0, 10));
}
#end_block

#method_before
private Stream<GroupDescription.Internal> getAllExistingGroups() throws OrmException {
    if (!projects.isEmpty()) {
        return projects.stream().map(ProjectControl::getAllGroups).flatMap(Collection::stream).map(GroupReference::getUUID).distinct().map(groupCache::get).flatMap(Streams::stream).map(InternalGroupDescription::new);
    } else {
        return groups.getAll(db.get()).map(GroupDescriptions::forAccountGroup);
    }
}
#method_after
private Stream<GroupDescription.Internal> getAllExistingGroups() throws OrmException {
    if (!projects.isEmpty()) {
        return projects.stream().map(ProjectControl::getProjectState).map(ProjectState::getAllGroups).flatMap(Collection::stream).map(GroupReference::getUUID).distinct().map(groupCache::get).flatMap(Streams::stream).map(InternalGroupDescription::new);
    }
    return groups.getAll(db.get()).map(GroupDescriptions::forAccountGroup);
}
#end_block

#method_before
@Override
public void check() throws StartupException {
    Map<AccountGroup.UUID, String> configuredNames = new HashMap<>();
    Map<String, AccountGroup.UUID> byLowerCaseConfiguredName = new HashMap<>();
    for (AccountGroup.UUID uuid : all) {
        String configuredName = cfg.getString("groups", uuid.get(), "name");
        if (configuredName != null) {
            configuredNames.put(uuid, configuredName);
            byLowerCaseConfiguredName.put(configuredName.toLowerCase(Locale.US), uuid);
        }
    }
    if (configuredNames.isEmpty()) {
        return;
    }
    Optional<AccountGroup> conflictingGroup;
    try {
        conflictingGroup = groups.getAll(db.get()).filter(group -> hasConfiguredName(byLowerCaseConfiguredName, group)).findAny();
    } catch (OrmException ignored) {
        return;
    }
    if (conflictingGroup.isPresent()) {
        AccountGroup group = conflictingGroup.get();
        String groupName = group.getName();
        AccountGroup.UUID systemGroupUuid = byLowerCaseConfiguredName.get(groupName);
        throw new StartupException(getAmbiguousNameMessage(groupName, group.getGroupUUID(), systemGroupUuid));
    }
}
#method_after
@Override
public void check() throws StartupException {
    Map<AccountGroup.UUID, String> configuredNames = new HashMap<>();
    Map<String, AccountGroup.UUID> byLowerCaseConfiguredName = new HashMap<>();
    for (AccountGroup.UUID uuid : all) {
        String configuredName = cfg.getString("groups", uuid.get(), "name");
        if (configuredName != null) {
            configuredNames.put(uuid, configuredName);
            byLowerCaseConfiguredName.put(configuredName.toLowerCase(Locale.US), uuid);
        }
    }
    if (configuredNames.isEmpty()) {
        return;
    }
    Optional<AccountGroup> conflictingGroup;
    try {
        conflictingGroup = groups.getAll(schema.open()).filter(group -> hasConfiguredName(byLowerCaseConfiguredName, group)).findAny();
    } catch (OrmException ignored) {
        return;
    }
    if (conflictingGroup.isPresent()) {
        AccountGroup group = conflictingGroup.get();
        String groupName = group.getName();
        AccountGroup.UUID systemGroupUuid = byLowerCaseConfiguredName.get(groupName);
        throw new StartupException(getAmbiguousNameMessage(groupName, group.getGroupUUID(), systemGroupUuid));
    }
}
#end_block

#method_before
void reschedule(PushOne pushOp, RetryReason reason) {
    synchronized (stateLock) {
        URIish uri = pushOp.getURI();
        PushOne pendingPushOp = pending.get(uri);
        if (pendingPushOp != null) {
            if (pendingPushOp.isRetrying()) {
                // The one pending is one already retrying, so it should
                // maintain it and add to it the refs of the one passed
                // as parameter to the method.
                // This scenario would happen if a PushOp has started running
                // and then before it failed due transport exception, another
                // one to same URI started. The first one would fail and would
                // be rescheduled, being present in pending list. When the
                // second one fails, it will also be rescheduled and then,
                // here, find out replication to its URI is already pending
                // for retry (blocking).
                pendingPushOp.addRefs(pushOp.getRefs());
                pendingPushOp.addStates(pushOp.getStates());
                pushOp.removeStates();
            } else {
                // The one pending is one that is NOT retrying, it was just
                // scheduled believing no problem would happen. The one pending
                // should be canceled, and this is done by setting its canceled
                // flag, removing it from pending list, and adding its refs to
                // the pushOp instance that should then, later, in this method,
                // be scheduled for retry.
                // Notice that the PushOp found pending will start running and,
                // when notifying it is starting (with pending lock protection),
                // it will see it was canceled and then it will do nothing with
                // pending list and it will not execute its run implementation.
                pendingPushOp.canceledByReplication();
                pending.remove(uri);
                pushOp.addRefs(pendingPushOp.getRefs());
                pushOp.addStates(pendingPushOp.getStates());
                pendingPushOp.removeStates();
            }
        }
        if (pendingPushOp == null || !pendingPushOp.isRetrying()) {
            pending.put(uri, pushOp);
            switch(reason) {
                case COLLISION:
                    pool.schedule(pushOp, config.getDelay(), TimeUnit.SECONDS);
                    break;
                case TRANSPORT_ERROR:
                case REPOSITORY_MISSING:
                default:
                    pushOp.setToRetry();
                    pool.schedule(pushOp, config.getRetryDelay(), TimeUnit.MINUTES);
                    break;
            }
        }
    }
}
#method_after
void reschedule(PushOne pushOp, RetryReason reason) {
    synchronized (stateLock) {
        URIish uri = pushOp.getURI();
        PushOne pendingPushOp = pending.get(uri);
        if (pendingPushOp != null) {
            if (pendingPushOp.isRetrying()) {
                // The one pending is one already retrying, so it should
                // maintain it and add to it the refs of the one passed
                // as parameter to the method.
                // This scenario would happen if a PushOp has started running
                // and then before it failed due transport exception, another
                // one to same URI started. The first one would fail and would
                // be rescheduled, being present in pending list. When the
                // second one fails, it will also be rescheduled and then,
                // here, find out replication to its URI is already pending
                // for retry (blocking).
                pendingPushOp.addRefs(pushOp.getRefs());
                pendingPushOp.addStates(pushOp.getStates());
                pushOp.removeStates();
            } else {
                // The one pending is one that is NOT retrying, it was just
                // scheduled believing no problem would happen. The one pending
                // should be canceled, and this is done by setting its canceled
                // flag, removing it from pending list, and adding its refs to
                // the pushOp instance that should then, later, in this method,
                // be scheduled for retry.
                // Notice that the PushOp found pending will start running and,
                // when notifying it is starting (with pending lock protection),
                // it will see it was canceled and then it will do nothing with
                // pending list and it will not execute its run implementation.
                pendingPushOp.canceledByReplication();
                pending.remove(uri);
                pushOp.addRefs(pendingPushOp.getRefs());
                pushOp.addStates(pendingPushOp.getStates());
                pendingPushOp.removeStates();
            }
        }
        if (pendingPushOp == null || !pendingPushOp.isRetrying()) {
            pending.put(uri, pushOp);
            switch(reason) {
                case COLLISION:
                    pool.schedule(pushOp, config.getDelay(), TimeUnit.SECONDS);
                    break;
                case TRANSPORT_ERROR:
                case REPOSITORY_MISSING:
                default:
                    if (pushOp.setToRetry()) {
                        pool.schedule(pushOp, config.getRetryDelay(), TimeUnit.MINUTES);
                    } else {
                        pushOp.canceledByReplication();
                        pending.remove(uri);
                        stateLog.error("Push to " + pushOp.getURI() + " cancelled after maximum number of retries", pushOp.getStatesAsArray());
                    }
                    break;
            }
        }
    }
}
#end_block

#method_before
@Override
public ImportStatistic apply(ProjectResource rsrc, Input input) throws RestApiException, OrmException, IOException, ValidationException, GitAPIException, NoSuchChangeException, NoSuchAccountException, UpdateException, ConfigInvalidException {
    if (Strings.isNullOrEmpty(input.name)) {
        throw new BadRequestException("name is required");
    }
    ImportProject.Input in = new ImportProject.Input();
    in.name = rsrc.getName();
    return importProjectFactory.create(new Project.NameKey(input.name)).setCopy(true).setErr(err).apply(new ConfigResource(), in);
}
#method_after
@Override
public ImportStatistic apply(ProjectResource rsrc, Input input) throws RestApiException, OrmException, IOException, ValidationException, GitAPIException, NoSuchChangeException, NoSuchAccountException, UpdateException, ConfigInvalidException, PermissionBackendException {
    if (Strings.isNullOrEmpty(input.name)) {
        throw new BadRequestException("name is required");
    }
    ImportProject.Input in = new ImportProject.Input();
    in.name = rsrc.getName();
    return importProjectFactory.create(new Project.NameKey(input.name)).setCopy(true).setErr(err).apply(new ConfigResource(), in);
}
#end_block

#method_before
private boolean canCopy() {
    CapabilityControl ctl = currentUserProvider.get().getCapabilities();
    return ctl.canAdministrateServer() || ctl.canPerform(pluginName + "-" + CopyProjectCapability.ID);
}
#method_after
private boolean canCopy() {
    return permissionBackend.user(currentUserProvider).testOrFalse(ADMINISTRATE_SERVER) || permissionBackend.user(currentUserProvider).testOrFalse(new PluginPermission(pluginName, CopyProjectCapability.ID));
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), COMMIT_KIND);
    DynamicMap.mapOf(binder(), TAG_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "access").to(GetAccess.class);
    post(PROJECT_KIND, "access").to(SetAccess.class);
    post(PROJECT_KIND, "check.access").to(CheckAccess.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    put(PROJECT_KIND, "ban").to(BanCommit.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    post(PROJECT_KIND, "index").to(Index.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    put(BRANCH_KIND).to(PutBranch.class);
    get(BRANCH_KIND).to(GetBranch.class);
    delete(BRANCH_KIND).to(DeleteBranch.class);
    post(PROJECT_KIND, "branches:delete").to(DeleteBranches.class);
    factory(CreateBranch.Factory.class);
    get(BRANCH_KIND, "mergeable").to(CheckMergeability.class);
    factory(RefValidationHelper.Factory.class);
    get(BRANCH_KIND, "reflog").to(GetReflog.class);
    child(BRANCH_KIND, "files").to(FilesCollection.class);
    get(FILE_KIND, "content").to(GetContent.class);
    child(PROJECT_KIND, "commits").to(CommitsCollection.class);
    get(COMMIT_KIND).to(GetCommit.class);
    get(COMMIT_KIND, "in").to(CommitIncludedIn.class);
    child(COMMIT_KIND, "files").to(FilesInCommitCollection.class);
    child(PROJECT_KIND, "tags").to(TagsCollection.class);
    get(TAG_KIND).to(GetTag.class);
    put(TAG_KIND).to(PutTag.class);
    delete(TAG_KIND).to(DeleteTag.class);
    post(PROJECT_KIND, "tags:delete").to(DeleteTags.class);
    factory(CreateTag.Factory.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    factory(CreateProject.Factory.class);
    get(PROJECT_KIND, "config").to(GetConfig.class);
    put(PROJECT_KIND, "config").to(PutConfig.class);
    post(COMMIT_KIND, "cherrypick").to(CherryPickCommit.class);
    factory(DeleteRef.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), COMMIT_KIND);
    DynamicMap.mapOf(binder(), TAG_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "access").to(GetAccess.class);
    post(PROJECT_KIND, "access").to(SetAccess.class);
    put(PROJECT_KIND, "access:review").to(CreateAccessChange.class);
    post(PROJECT_KIND, "check.access").to(CheckAccess.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    put(PROJECT_KIND, "ban").to(BanCommit.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    post(PROJECT_KIND, "index").to(Index.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    put(BRANCH_KIND).to(PutBranch.class);
    get(BRANCH_KIND).to(GetBranch.class);
    delete(BRANCH_KIND).to(DeleteBranch.class);
    post(PROJECT_KIND, "branches:delete").to(DeleteBranches.class);
    factory(CreateBranch.Factory.class);
    get(BRANCH_KIND, "mergeable").to(CheckMergeability.class);
    factory(RefValidationHelper.Factory.class);
    get(BRANCH_KIND, "reflog").to(GetReflog.class);
    child(BRANCH_KIND, "files").to(FilesCollection.class);
    get(FILE_KIND, "content").to(GetContent.class);
    child(PROJECT_KIND, "commits").to(CommitsCollection.class);
    get(COMMIT_KIND).to(GetCommit.class);
    get(COMMIT_KIND, "in").to(CommitIncludedIn.class);
    child(COMMIT_KIND, "files").to(FilesInCommitCollection.class);
    child(PROJECT_KIND, "tags").to(TagsCollection.class);
    get(TAG_KIND).to(GetTag.class);
    put(TAG_KIND).to(PutTag.class);
    delete(TAG_KIND).to(DeleteTag.class);
    post(PROJECT_KIND, "tags:delete").to(DeleteTags.class);
    factory(CreateTag.Factory.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    factory(CreateProject.Factory.class);
    get(PROJECT_KIND, "config").to(GetConfig.class);
    put(PROJECT_KIND, "config").to(PutConfig.class);
    post(COMMIT_KIND, "cherrypick").to(CherryPickCommit.class);
    factory(DeleteRef.Factory.class);
}
#end_block

#method_before
@Override
public AccessCheckInfo checkAccess(AccessCheckInput in) throws RestApiException {
    try {
        ProjectResource r = checkExists();
        return checkAccess.apply(r, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot post check access", e);
    }
}
#method_after
@Override
public AccessCheckInfo checkAccess(AccessCheckInput in) throws RestApiException {
    try {
        return checkAccess.apply(checkExists(), in);
    } catch (Exception e) {
        throw asRestApiException("Cannot check access rights", e);
    }
}
#end_block

#method_before
@Override
public ListRefsRequest<BranchInfo> branches() {
    return new ListRefsRequest<BranchInfo>() {

        @Override
        public List<BranchInfo> get() throws RestApiException {
            return listBranches(this);
        }
    };
}
#method_after
@Override
public ListRefsRequest<BranchInfo> branches() {
    return new ListRefsRequest<BranchInfo>() {

        @Override
        public List<BranchInfo> get() throws RestApiException {
            try {
                return listBranches.get().request(this).apply(checkExists());
            } catch (Exception e) {
                throw asRestApiException("Cannot list branches", e);
            }
        }
    };
}
#end_block

#method_before
@Override
public ListRefsRequest<TagInfo> tags() {
    return new ListRefsRequest<TagInfo>() {

        @Override
        public List<TagInfo> get() throws RestApiException {
            return listTags(this);
        }
    };
}
#method_after
@Override
public ListRefsRequest<TagInfo> tags() {
    return new ListRefsRequest<TagInfo>() {

        @Override
        public List<TagInfo> get() throws RestApiException {
            try {
                return listTags.get().request(this).apply(checkExists());
            } catch (Exception e) {
                throw asRestApiException("Cannot list tags", e);
            }
        }
    };
}
#end_block

#method_before
@Override
public AccessCheckInfo apply(ProjectResource rsrc, AccessCheckInput input) throws OrmException, PermissionBackendException, RestApiException, IOException, ConfigInvalidException {
    permissionBackend.user(currentUser.get()).check(GlobalPermission.ADMINISTRATE_SERVER);
    if (input == null) {
        throw new BadRequestException("input is required");
    }
    if (Strings.isNullOrEmpty(input.account)) {
        throw new BadRequestException("input requires 'account'");
    }
    Account match = accountResolver.find(db.get(), input.account);
    if (match == null) {
        throw new BadRequestException(String.format("cannot find account %s", input.account));
    }
    AccessCheckInfo info = new AccessCheckInfo();
    IdentifiedUser user = userFactory.create(match.getId());
    try {
        permissionBackend.user(user).project(rsrc.getNameKey()).check(ProjectPermission.ACCESS);
    } catch (AuthException | PermissionBackendException e) {
        info.message = String.format("user %s (%s) cannot see project %s", user.getNameEmail(), user.getAccount().getId(), rsrc.getName());
        info.status = HttpServletResponse.SC_FORBIDDEN;
        return info;
    }
    if (!Strings.isNullOrEmpty(input.ref)) {
        try {
            permissionBackend.user(user).ref(new Branch.NameKey(rsrc.getNameKey(), input.ref)).check(RefPermission.READ);
        } catch (AuthException | PermissionBackendException e) {
            info.status = HttpServletResponse.SC_FORBIDDEN;
            info.message = String.format("user %s (%s) cannot see ref %s in project %s", user.getNameEmail(), user.getAccount().getId(), input.ref, rsrc.getName());
            return info;
        }
    }
    info.status = HttpServletResponse.SC_OK;
    return info;
}
#method_after
@Override
public AccessCheckInfo apply(ProjectResource rsrc, AccessCheckInput input) throws OrmException, PermissionBackendException, RestApiException, IOException, ConfigInvalidException {
    permissionBackend.user(rsrc.getUser()).check(GlobalPermission.ADMINISTRATE_SERVER);
    if (input == null) {
        throw new BadRequestException("input is required");
    }
    if (Strings.isNullOrEmpty(input.account)) {
        throw new BadRequestException("input requires 'account'");
    }
    Account match = accountResolver.find(db.get(), input.account);
    if (match == null) {
        throw new UnprocessableEntityException(String.format("cannot find account %s", input.account));
    }
    AccessCheckInfo info = new AccessCheckInfo();
    IdentifiedUser user = userFactory.create(match.getId());
    try {
        permissionBackend.user(user).project(rsrc.getNameKey()).check(ProjectPermission.ACCESS);
    } catch (AuthException | PermissionBackendException e) {
        info.message = String.format("user %s (%s) cannot see project %s", user.getNameEmail(), user.getAccount().getId(), rsrc.getName());
        info.status = HttpServletResponse.SC_FORBIDDEN;
        return info;
    }
    if (!Strings.isNullOrEmpty(input.ref)) {
        try {
            permissionBackend.user(user).ref(new Branch.NameKey(rsrc.getNameKey(), input.ref)).check(RefPermission.READ);
        } catch (AuthException | PermissionBackendException e) {
            info.status = HttpServletResponse.SC_FORBIDDEN;
            info.message = String.format("user %s (%s) cannot see ref %s in project %s", user.getNameEmail(), user.getAccount().getId(), input.ref, rsrc.getName());
            return info;
        }
    }
    info.status = HttpServletResponse.SC_OK;
    return info;
}
#end_block

#method_before
@Override
public Object apply(ChangeResource rsrc, DeleteEdit.Input input) throws AuthException, ResourceConflictException, BadRequestException, IOException, OrmException, InvalidChangeOperationException {
    return deleteEditFactory.create(rsrc.getChange(), null).apply(rsrc, input);
}
#method_after
@Override
public Response<?> apply(ChangeResource rsrc, Input input) throws AuthException, BadRequestException, IOException, InvalidChangeOperationException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (edit.isPresent()) {
        editUtil.delete(edit.get());
    } else {
        throw new BadRequestException("change edit doesn't exist");
    }
    return Response.none();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    child(CHANGE_KIND, "publish_edit").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "rebase_edit").to(RebaseChangeEdit.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
            factory(ChangeEdits.DeleteEdit.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "publish_edit").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "rebase_edit").to(RebaseChangeEdit.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
            factory(ChangeEdits.DeleteEdit.Factory.class);
        }
    });
}
#end_block

#method_before
@Override
public OAuthService createService(OAuthConfig config) {
    // return new OAuth20ServiceImpl(this,config); // TODO can't use this until updating to newer scribe lib
    return new DexOAuthService(this, config);
}
#method_after
@Override
public OAuthService createService(OAuthConfig config) {
    // return new OAuth20ServiceImpl(this,config);
    return new DexOAuthService(this, config);
}
#end_block

#method_before
private void reportMessages() {
    List<CreateRequest> created = newChanges.stream().filter(r -> r.change != null).collect(toList());
    if (!created.isEmpty()) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(changeFormatter.newChange(ChangeReportFormatter.Input.builder().change(c.change).build()));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = replaceByChange.values().stream().filter(r -> !r.skip && r.inputCommand.getResult() == OK).sorted(comparingInt(r -> r.notes.getChangeId().get())).collect(toList());
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        Boolean isPrivate = null;
        Boolean wip = null;
        if (magicBranch != null) {
            if (magicBranch.isPrivate) {
                isPrivate = true;
            } else if (magicBranch.removePrivate) {
                isPrivate = false;
            }
            if (magicBranch.workInProgress) {
                wip = true;
            } else if (magicBranch.ready) {
                wip = false;
            }
        }
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            if (isPrivate == null) {
                isPrivate = u.notes.getChange().isPrivate();
            }
            if (wip == null) {
                wip = u.notes.getChange().isWorkInProgress();
            }
            ChangeReportFormatter.Input input = ChangeReportFormatter.Input.builder().change(u.notes.getChange()).subject(subject).draft(u.replaceOp != null && u.replaceOp.getPatchSet().isDraft()).edit(edit)._private(isPrivate).wip(wip).build();
            addMessage(changeFormatter.changeUpdated(input));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    List<CreateRequest> created = newChanges.stream().filter(r -> r.change != null).collect(toList());
    if (!created.isEmpty()) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(changeFormatter.newChange(ChangeReportFormatter.Input.builder().setChange(c.change).build()));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = replaceByChange.values().stream().filter(r -> !r.skip && r.inputCommand.getResult() == OK).sorted(comparingInt(r -> r.notes.getChangeId().get())).collect(toList());
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        Boolean isPrivate = null;
        Boolean wip = null;
        if (magicBranch != null) {
            if (magicBranch.isPrivate) {
                isPrivate = true;
            } else if (magicBranch.removePrivate) {
                isPrivate = false;
            }
            if (magicBranch.workInProgress) {
                wip = true;
            } else if (magicBranch.ready) {
                wip = false;
            }
        }
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            if (isPrivate == null) {
                isPrivate = u.notes.getChange().isPrivate();
            }
            if (wip == null) {
                wip = u.notes.getChange().isWorkInProgress();
            }
            ChangeReportFormatter.Input input = ChangeReportFormatter.Input.builder().setChange(u.notes.getChange()).setSubject(subject).setIsDraft(u.replaceOp != null && u.replaceOp.getPatchSet().isDraft()).setIsEdit(edit).setIsPrivate(isPrivate).setIsWorkInProgress(wip).build();
            addMessage(changeFormatter.changeUpdated(input));
        }
        addMessage("");
    }
}
#end_block

#method_before
private boolean requestReplace(ReceiveCommand cmd, boolean checkMergedInto, Change change, RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, changeFormatter.changeClosed(ChangeReportFormatter.Input.builder().change(change).build()));
        return false;
    }
    ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#method_after
private boolean requestReplace(ReceiveCommand cmd, boolean checkMergedInto, Change change, RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, changeFormatter.changeClosed(ChangeReportFormatter.Input.builder().setChange(change).build()));
        return false;
    }
    ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#end_block

#method_before
private MergeableFileBasedConfig newConfig() {
    return new MergeableFileBasedConfig(new File(tempDir, counter.incrementAndGet() + ".config"), FS.detect());
}
#method_after
private MergeableFileBasedConfig newConfig() throws Exception {
    File f = File.createTempFile(getClass().getSimpleName(), ".config");
    f.deleteOnExit();
    return new MergeableFileBasedConfig(f, FS.detect());
}
#end_block

#method_before
private String formatChangeUrl(String url, Input input) {
    Change change = input.getChange();
    StringBuilder m = new StringBuilder().append("  ").append(ChangeUtil.formatChangeUrl(url, change)).append(" ").append(ChangeUtil.cropSubject(input.getSubject()));
    if (input.isDraft()) {
        m.append(" [DRAFT]");
    }
    if (input.isEdit()) {
        m.append(" [EDIT]");
    }
    if (input.isPrivate()) {
        m.append(" [PRIVATE]");
    }
    if (input.isWorkInProgress()) {
        m.append(" [WIP]");
    }
    return m.toString();
}
#method_after
private String formatChangeUrl(String url, Input input) {
    StringBuilder m = new StringBuilder().append("  ").append(ChangeUtil.formatChangeUrl(url, input.getChange())).append(" ").append(ChangeUtil.cropSubject(input.getSubject()));
    if (input.isDraft()) {
        m.append(" [DRAFT]");
    }
    if (input.isEdit()) {
        m.append(" [EDIT]");
    }
    if (input.isPrivate()) {
        m.append(" [PRIVATE]");
    }
    if (input.isWorkInProgress()) {
        m.append(" [WIP]");
    }
    return m.toString();
}
#end_block

#method_before
@Override
public IncludedInInfo apply(ChangeResource rsrc) throws RestApiException, OrmException, IOException {
    PatchSet ps = psUtil.current(db.get(), rsrc.getNotes());
    Project.NameKey project = rsrc.getProject();
    return includedIn.apply(project, ps.getRevision().get());
}
#method_after
@Override
public IncludedInInfo apply(ChangeResource rsrc) throws RestApiException, OrmException, IOException {
    PatchSet ps = psUtil.current(db.get(), rsrc.getNotes());
    return includedIn.apply(rsrc.getProject(), ps.getRevision().get());
}
#end_block

#method_before
private ObjectId getEditRev() throws AuthException, IOException, OrmException {
    edit = editReader.byChange(control.getNotes(), control.getUser());
    if (edit.isPresent()) {
        return edit.get().getEditCommit();
    }
    throw new NoSuchChangeException(change.getId());
}
#method_after
private ObjectId getEditRev() throws AuthException, IOException, OrmException {
    edit = editReader.byChange(control.getNotes());
    if (edit.isPresent()) {
        return edit.get().getEditCommit();
    }
    throw new NoSuchChangeException(change.getId());
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    String keyStr = req.getPathInfo();
    // We shouldn't have to do this extra decode pass, but somehow we
    // are now receiving our "^1" suffix as "%5E1", which confuses us
    // downstream. Other times we get our embedded "," as "%2C", which
    // is equally bad. And yet when these happen a "%2F" is left as-is,
    // rather than escaped as "%252F", which makes me feel really really
    // uncomfortable with a blind decode right here.
    // 
    keyStr = Url.decode(keyStr);
    if (!keyStr.startsWith("/")) {
        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    keyStr = keyStr.substring(1);
    final Patch.Key patchKey;
    final int side;
    {
        final int c = keyStr.lastIndexOf('^');
        if (c == 0) {
            rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
            return;
        }
        if (c < 0) {
            side = 0;
        } else {
            try {
                side = Integer.parseInt(keyStr.substring(c + 1));
                keyStr = keyStr.substring(0, c);
            } catch (NumberFormatException e) {
                rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
                return;
            }
        }
        try {
            patchKey = Patch.Key.parse(keyStr);
        } catch (NumberFormatException e) {
            rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
            return;
        }
    }
    final Change.Id changeId = patchKey.getParentKey().getParentKey();
    String revision;
    try {
        ChangeNotes notes = changeNotesFactory.createChecked(changeId);
        permissionBackend.user(userProvider).change(notes).database(requestDb).check(ChangePermission.READ);
        if (patchKey.getParentKey().get() == 0) {
            // change edit
            Optional<ChangeEdit> edit = changeEditUtil.byChange(notes, userProvider.get());
            if (edit.isPresent()) {
                revision = ObjectId.toString(edit.get().getEditCommit());
            } else {
                rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
                return;
            }
        } else {
            PatchSet patchSet = psUtil.get(requestDb.get(), notes, patchKey.getParentKey());
            if (patchSet == null) {
                rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
                return;
            }
            revision = patchSet.getRevision().get();
        }
    } catch (NoSuchChangeException | AuthException e) {
        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    } catch (OrmException | PermissionBackendException e) {
        getServletContext().log("Cannot query database", e);
        rsp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        return;
    }
    String path = patchKey.getFileName();
    String restUrl = String.format("%s/changes/%d/revisions/%s/files/%s/download?parent=%d", req.getContextPath(), changeId.get(), revision, Url.encode(path), side);
    rsp.sendRedirect(restUrl);
}
#method_after
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    String keyStr = req.getPathInfo();
    // We shouldn't have to do this extra decode pass, but somehow we
    // are now receiving our "^1" suffix as "%5E1", which confuses us
    // downstream. Other times we get our embedded "," as "%2C", which
    // is equally bad. And yet when these happen a "%2F" is left as-is,
    // rather than escaped as "%252F", which makes me feel really really
    // uncomfortable with a blind decode right here.
    // 
    keyStr = Url.decode(keyStr);
    if (!keyStr.startsWith("/")) {
        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    keyStr = keyStr.substring(1);
    final Patch.Key patchKey;
    final int side;
    {
        final int c = keyStr.lastIndexOf('^');
        if (c == 0) {
            rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
            return;
        }
        if (c < 0) {
            side = 0;
        } else {
            try {
                side = Integer.parseInt(keyStr.substring(c + 1));
                keyStr = keyStr.substring(0, c);
            } catch (NumberFormatException e) {
                rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
                return;
            }
        }
        try {
            patchKey = Patch.Key.parse(keyStr);
        } catch (NumberFormatException e) {
            rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
            return;
        }
    }
    final Change.Id changeId = patchKey.getParentKey().getParentKey();
    String revision;
    try {
        ChangeNotes notes = changeNotesFactory.createChecked(changeId);
        permissionBackend.user(userProvider).change(notes).database(requestDb).check(ChangePermission.READ);
        if (patchKey.getParentKey().get() == 0) {
            // change edit
            Optional<ChangeEdit> edit = changeEditUtil.byChange(notes);
            if (edit.isPresent()) {
                revision = ObjectId.toString(edit.get().getEditCommit());
            } else {
                rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
                return;
            }
        } else {
            PatchSet patchSet = psUtil.get(requestDb.get(), notes, patchKey.getParentKey());
            if (patchSet == null) {
                rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
                return;
            }
            revision = patchSet.getRevision().get();
        }
    } catch (NoSuchChangeException | AuthException e) {
        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    } catch (OrmException | PermissionBackendException e) {
        getServletContext().log("Cannot query database", e);
        rsp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        return;
    }
    String path = patchKey.getFileName();
    String restUrl = String.format("%s/changes/%d/revisions/%s/files/%s/download?parent=%d", req.getContextPath(), changeId.get(), revision, Url.encode(path), side);
    rsp.sendRedirect(restUrl);
}
#end_block

#method_before
public Optional<ChangeEdit> byChange(ChangeNotes notes, CurrentUser user) throws AuthException, IOException {
    if (!user.isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser u = user.asIdentifiedUser();
    Change change = notes.getChange();
    try (Repository repo = gitManager.openRepository(change.getProject())) {
        int n = change.currentPatchSetId().get();
        String[] refNames = new String[n];
        for (int i = n; i > 0; i--) {
            refNames[i - 1] = RefNames.refsEdit(u.getAccountId(), change.getId(), new PatchSet.Id(change.getId(), i));
        }
        Ref ref = repo.getRefDatabase().firstExactRef(refNames);
        if (ref == null) {
            return Optional.empty();
        }
        try (RevWalk rw = new RevWalk(repo)) {
            RevCommit commit = rw.parseCommit(ref.getObjectId());
            PatchSet basePs = getBasePatchSet(notes, ref);
            return Optional.of(new ChangeEdit(change, ref.getName(), commit, basePs));
        }
    }
}
#method_after
public Optional<ChangeEdit> byChange(ChangeNotes notes) throws AuthException, IOException {
    return byChange(notes, userProvider.get());
}
#end_block

#method_before
private List<RevisionResource> loadEdit(ChangeResource change, RevId revid) throws AuthException, IOException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(change.getNotes(), change.getUser());
    if (edit.isPresent()) {
        PatchSet ps = new PatchSet(new PatchSet.Id(change.getId(), 0));
        RevId editRevId = new RevId(ObjectId.toString(edit.get().getEditCommit()));
        ps.setRevision(editRevId);
        if (revid == null || editRevId.equals(revid)) {
            return Collections.singletonList(new RevisionResource(change, ps, edit));
        }
    }
    return Collections.emptyList();
}
#method_after
private List<RevisionResource> loadEdit(ChangeResource change, RevId revid) throws AuthException, IOException {
    Optional<ChangeEdit> edit = editUtil.byChange(change.getNotes(), change.getUser());
    if (edit.isPresent()) {
        PatchSet ps = new PatchSet(new PatchSet.Id(change.getId(), 0));
        RevId editRevId = new RevId(ObjectId.toString(edit.get().getEditCommit()));
        ps.setRevision(editRevId);
        if (revid == null || editRevId.equals(revid)) {
            return Collections.singletonList(new RevisionResource(change, ps, edit));
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
private Optional<ChangeEdit> lookupChangeEdit(ChangeNotes notes) throws AuthException, IOException {
    return changeEditUtil.byChange(notes, currentUser.get());
}
#method_after
private Optional<ChangeEdit> lookupChangeEdit(ChangeNotes notes) throws AuthException, IOException {
    return changeEditUtil.byChange(notes);
}
#end_block

#method_before
@Override
public ChangeInfo apply(ProjectResource rsrc, ProjectAccessInput input) throws PermissionBackendException, PermissionDeniedException, IOException, ConfigInvalidException, OrmException, UnprocessableEntityException, BadRequestException, InvalidNameException, ResourceConflictException {
    ProjectControl projectControl = rsrc.getControl();
    MetaDataUpdate.User metaDataUpdateUser = metaDataUpdateFactory.get();
    List<AccessSection> removals = setAccess.getAccessSections(input.remove);
    List<AccessSection> additions = setAccess.getAccessSections(input.add);
    PermissionBackend.ForRef metaRef = permissionBackend.user(projectControl.getUser()).project(projectControl.getProject().getNameKey()).ref(RefNames.REFS_CONFIG);
    try {
        metaRef.check(RefPermission.READ);
    } catch (AuthException denied) {
        throw new PermissionDeniedException(RefNames.REFS_CONFIG + " not visible");
    }
    if (!projectControl.isOwner()) {
        try {
            metaRef.check(RefPermission.CREATE_CHANGE);
        } catch (AuthException denied) {
            throw new PermissionDeniedException("cannot create change for " + RefNames.REFS_CONFIG);
        }
    }
    Project.NameKey newParentProjectName = input.parent == null ? null : new Project.NameKey(input.parent);
    try (MetaDataUpdate md = metaDataUpdateUser.create(rsrc.getNameKey())) {
        ProjectConfig config = ProjectConfig.read(md);
        setAccess.validityChecks(projectControl, config, newParentProjectName, additions, removals);
        setAccess.cleanupPermissions(config, removals, additions);
        try {
            setAccess.updateParent(projectControl, config, newParentProjectName, false);
        } catch (AuthException e) {
            throw new IllegalStateException(e);
        }
        md.setInsertChangeId(true);
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        RevCommit commit = config.commitToNewRef(md, new PatchSet.Id(changeId, Change.INITIAL_PATCH_SET_ID).toRefName());
        try (ObjectInserter objInserter = md.getRepository().newObjectInserter();
            ObjectReader objReader = objInserter.newReader();
            RevWalk rw = new RevWalk(objReader);
            BatchUpdate bu = updateFactory.create(db.get(), config.getProject().getNameKey(), projectControl.getUser(), TimeUtil.nowTs())) {
            bu.setRepository(md.getRepository(), rw, objInserter);
            bu.insertChange(changeInserterFactory.create(changeId, commit, RefNames.REFS_CONFIG).setValidate(false).setUpdateRef(// Created by commitToNewRef.
            false));
            bu.execute();
        } catch (UpdateException | RestApiException e) {
            throw new IOException(e);
        }
        // TODO: add reviewers
        ChangeInfo result = new ChangeInfo();
        result._number = changeId.get();
        result.project = projectControl.getProject().getName();
        return result;
    }
}
#method_after
@Override
public Response<ChangeInfo> apply(ProjectResource rsrc, ProjectAccessInput input) throws PermissionBackendException, PermissionDeniedException, IOException, ConfigInvalidException, OrmException, InvalidNameException, UpdateException, RestApiException {
    MetaDataUpdate.User metaDataUpdateUser = metaDataUpdateFactory.get();
    List<AccessSection> removals = setAccess.getAccessSections(input.remove);
    List<AccessSection> additions = setAccess.getAccessSections(input.add);
    PermissionBackend.ForRef metaRef = permissionBackend.user(rsrc.getUser()).project(rsrc.getNameKey()).ref(RefNames.REFS_CONFIG);
    try {
        metaRef.check(RefPermission.READ);
    } catch (AuthException denied) {
        throw new PermissionDeniedException(RefNames.REFS_CONFIG + " not visible");
    }
    if (!rsrc.getControl().isOwner()) {
        try {
            metaRef.check(RefPermission.CREATE_CHANGE);
        } catch (AuthException denied) {
            throw new PermissionDeniedException("cannot create change for " + RefNames.REFS_CONFIG);
        }
    }
    Project.NameKey newParentProjectName = input.parent == null ? null : new Project.NameKey(input.parent);
    try (MetaDataUpdate md = metaDataUpdateUser.create(rsrc.getNameKey())) {
        ProjectConfig config = ProjectConfig.read(md);
        setAccess.validateChanges(config, removals, additions);
        setAccess.applyChanges(config, removals, additions);
        try {
            setAccess.setParentName(rsrc.getUser().asIdentifiedUser(), config, rsrc.getNameKey(), newParentProjectName, false);
        } catch (AuthException e) {
            throw new IllegalStateException(e);
        }
        md.setMessage("Review access change");
        md.setInsertChangeId(true);
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        RevCommit commit = config.commitToNewRef(md, new PatchSet.Id(changeId, Change.INITIAL_PATCH_SET_ID).toRefName());
        try (ObjectInserter objInserter = md.getRepository().newObjectInserter();
            ObjectReader objReader = objInserter.newReader();
            RevWalk rw = new RevWalk(objReader);
            BatchUpdate bu = updateFactory.create(db.get(), rsrc.getNameKey(), rsrc.getUser(), TimeUtil.nowTs())) {
            bu.setRepository(md.getRepository(), rw, objInserter);
            ChangeInserter ins = changeInserterFactory.create(changeId, commit, RefNames.REFS_CONFIG);
            ins.setMessage("First patchset").setValidate(false).setUpdateRef(false);
            bu.insertChange(ins);
            bu.execute();
            return Response.created(jsonFactory.noOptions().format(ins.getChange()));
        }
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), COMMIT_KIND);
    DynamicMap.mapOf(binder(), TAG_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "access").to(GetAccess.class);
    post(PROJECT_KIND, "access").to(SetAccess.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    put(PROJECT_KIND, "ban").to(BanCommit.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    post(PROJECT_KIND, "index").to(Index.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    put(BRANCH_KIND).to(PutBranch.class);
    get(BRANCH_KIND).to(GetBranch.class);
    delete(BRANCH_KIND).to(DeleteBranch.class);
    post(PROJECT_KIND, "branches:delete").to(DeleteBranches.class);
    factory(CreateBranch.Factory.class);
    get(BRANCH_KIND, "mergeable").to(CheckMergeability.class);
    factory(RefValidationHelper.Factory.class);
    get(BRANCH_KIND, "reflog").to(GetReflog.class);
    child(BRANCH_KIND, "files").to(FilesCollection.class);
    get(FILE_KIND, "content").to(GetContent.class);
    child(PROJECT_KIND, "commits").to(CommitsCollection.class);
    get(COMMIT_KIND).to(GetCommit.class);
    get(COMMIT_KIND, "in").to(CommitIncludedIn.class);
    child(COMMIT_KIND, "files").to(FilesInCommitCollection.class);
    child(PROJECT_KIND, "tags").to(TagsCollection.class);
    get(TAG_KIND).to(GetTag.class);
    put(TAG_KIND).to(PutTag.class);
    delete(TAG_KIND).to(DeleteTag.class);
    post(PROJECT_KIND, "tags:delete").to(DeleteTags.class);
    factory(CreateTag.Factory.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    factory(CreateProject.Factory.class);
    get(PROJECT_KIND, "config").to(GetConfig.class);
    put(PROJECT_KIND, "config").to(PutConfig.class);
    put(PROJECT_KIND, "config:review").to(CreateAccessChange.class);
    post(COMMIT_KIND, "cherrypick").to(CherryPickCommit.class);
    factory(DeleteRef.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), COMMIT_KIND);
    DynamicMap.mapOf(binder(), TAG_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "access").to(GetAccess.class);
    post(PROJECT_KIND, "access").to(SetAccess.class);
    put(PROJECT_KIND, "access:review").to(CreateAccessChange.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    put(PROJECT_KIND, "ban").to(BanCommit.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    post(PROJECT_KIND, "index").to(Index.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    put(BRANCH_KIND).to(PutBranch.class);
    get(BRANCH_KIND).to(GetBranch.class);
    delete(BRANCH_KIND).to(DeleteBranch.class);
    post(PROJECT_KIND, "branches:delete").to(DeleteBranches.class);
    factory(CreateBranch.Factory.class);
    get(BRANCH_KIND, "mergeable").to(CheckMergeability.class);
    factory(RefValidationHelper.Factory.class);
    get(BRANCH_KIND, "reflog").to(GetReflog.class);
    child(BRANCH_KIND, "files").to(FilesCollection.class);
    get(FILE_KIND, "content").to(GetContent.class);
    child(PROJECT_KIND, "commits").to(CommitsCollection.class);
    get(COMMIT_KIND).to(GetCommit.class);
    get(COMMIT_KIND, "in").to(CommitIncludedIn.class);
    child(COMMIT_KIND, "files").to(FilesInCommitCollection.class);
    child(PROJECT_KIND, "tags").to(TagsCollection.class);
    get(TAG_KIND).to(GetTag.class);
    put(TAG_KIND).to(PutTag.class);
    delete(TAG_KIND).to(DeleteTag.class);
    post(PROJECT_KIND, "tags:delete").to(DeleteTags.class);
    factory(CreateTag.Factory.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    factory(CreateProject.Factory.class);
    get(PROJECT_KIND, "config").to(GetConfig.class);
    put(PROJECT_KIND, "config").to(PutConfig.class);
    post(COMMIT_KIND, "cherrypick").to(CherryPickCommit.class);
    factory(DeleteRef.Factory.class);
}
#end_block

#method_before
@Override
protected ChangeInfo applyImpl(BatchUpdate.Factory updateFactory, ChangeResource rsrc, MoveInput input) throws RestApiException, OrmException, UpdateException, PermissionBackendException {
    Change change = rsrc.getChange();
    Project.NameKey project = rsrc.getProject();
    IdentifiedUser caller = rsrc.getUser();
    input.destinationBranch = RefNames.fullName(input.destinationBranch);
    if (change.getStatus().isClosed()) {
        throw new ResourceConflictException("Change is " + ChangeUtil.status(change));
    }
    Branch.NameKey newDest = new Branch.NameKey(project, input.destinationBranch);
    if (change.getDest().equals(newDest)) {
        throw new ResourceConflictException("Change is already destined for the specified branch");
    }
    // Move requires abandoning this change, and creating a new change.
    try {
        rsrc.permissions().database(dbProvider).check(ChangePermission.ABANDON);
        permissionBackend.user(caller).database(dbProvider).ref(newDest).check(RefPermission.CREATE_CHANGE);
    } catch (AuthException denied) {
        throw new AuthException("move not permitted", denied);
    }
    try (BatchUpdate u = updateFactory.create(dbProvider.get(), project, caller, TimeUtil.nowTs())) {
        u.addOp(change.getId(), new Op(input));
        u.execute();
    }
    return json.noOptions().format(project, rsrc.getId());
}
#method_after
@Override
protected ChangeInfo applyImpl(BatchUpdate.Factory updateFactory, ChangeResource rsrc, MoveInput input) throws RestApiException, OrmException, UpdateException, PermissionBackendException {
    Change change = rsrc.getChange();
    Project.NameKey project = rsrc.getProject();
    IdentifiedUser caller = rsrc.getUser();
    input.destinationBranch = RefNames.fullName(input.destinationBranch);
    if (change.getStatus().isClosed()) {
        throw new ResourceConflictException("Change is " + ChangeUtil.status(change));
    }
    Branch.NameKey newDest = new Branch.NameKey(project, input.destinationBranch);
    if (change.getDest().equals(newDest)) {
        throw new ResourceConflictException("Change is already destined for the specified branch");
    }
    // Move requires abandoning this change, and creating a new change.
    try {
        rsrc.permissions().database(dbProvider).check(ABANDON);
        permissionBackend.user(caller).database(dbProvider).ref(newDest).check(CREATE_CHANGE);
    } catch (AuthException denied) {
        throw new AuthException("move not permitted", denied);
    }
    try (BatchUpdate u = updateFactory.create(dbProvider.get(), project, caller, TimeUtil.nowTs())) {
        u.addOp(change.getId(), new Op(input));
        u.execute();
    }
    return json.noOptions().format(project, rsrc.getId());
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(ChangeResource rsrc) {
    Change change = rsrc.getChange();
    return new UiAction.Description().setLabel("Move Change").setTitle("Move change to a different branch").setVisible(!(change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) && permissionBackend.user(rsrc.getUser()).ref(change.getDest()).testOrFalse(CREATE_CHANGE) && rsrc.permissions().database(dbProvider).testOrFalse(ChangePermission.ABANDON));
}
#method_after
@Override
public UiAction.Description getDescription(ChangeResource rsrc) {
    Change change = rsrc.getChange();
    return new UiAction.Description().setLabel("Move Change").setTitle("Move change to a different branch").setVisible(change.getStatus().isOpen() && permissionBackend.user(rsrc.getUser()).ref(change.getDest()).testOrFalse(CREATE_CHANGE) && rsrc.permissions().database(dbProvider).testOrFalse(ABANDON));
}
#end_block

#method_before
@Override
protected void configure() {
    bind(new TypeLiteral<Optional<PeerInfo>>() {
    }).toProvider(JGroupsPeerInfoProvider.class);
    listener().to(JGroupsPeerInfoProvider.class);
}
#method_after
@Override
protected void configure() {
    bind(new TypeLiteral<Optional<PeerInfo>>() {
    }).toProvider(PeerInfoProvider.class);
    if (strategy == Configuration.PeerInfoStrategy.JGROUPS) {
        listener().to(JGroupsPeerInfoProvider.class);
    }
}
#end_block

#method_before
private int getInt(PluginConfig cfg, String name, int defaultValue) {
    try {
        return cfg.getInt(name, defaultValue);
    } catch (IllegalArgumentException e) {
        log.error(String.format("invalid value for %s; using default value %d", name, defaultValue));
        log.debug("Failed retrieve integer value: " + e.getMessage(), e);
        return defaultValue;
    }
}
#method_after
private static int getInt(Config cfg, String section, String name, int defaultValue) {
    try {
        return cfg.getInt(section, name, defaultValue);
    } catch (IllegalArgumentException e) {
        log.error(String.format("invalid value for %s; using default value %d", name, defaultValue));
        log.debug("Failed to retrieve integer value: " + e.getMessage(), e);
        return defaultValue;
    }
}
#end_block

#method_before
List<AccessSection> getAccessSections(Map<String, AccessSectionInfo> sectionInfos) throws UnprocessableEntityException {
    if (sectionInfos == null) {
        return Collections.emptyList();
    }
    List<AccessSection> sections = new ArrayList<>(sectionInfos.size());
    for (Map.Entry<String, AccessSectionInfo> entry : sectionInfos.entrySet()) {
        AccessSection accessSection = new AccessSection(entry.getKey());
        if (entry.getValue().permissions == null) {
            continue;
        }
        for (Map.Entry<String, PermissionInfo> permissionEntry : entry.getValue().permissions.entrySet()) {
            Permission p = new Permission(permissionEntry.getKey());
            if (permissionEntry.getValue().exclusive != null) {
                p.setExclusiveGroup(permissionEntry.getValue().exclusive);
            }
            if (permissionEntry.getValue().rules == null) {
                continue;
            }
            for (Map.Entry<String, PermissionRuleInfo> permissionRuleInfoEntry : permissionEntry.getValue().rules.entrySet()) {
                PermissionRuleInfo pri = permissionRuleInfoEntry.getValue();
                GroupDescription.Basic group = groupsCollection.parseId(permissionRuleInfoEntry.getKey());
                if (group == null) {
                    throw new UnprocessableEntityException(permissionRuleInfoEntry.getKey() + " is not a valid group ID");
                }
                PermissionRule r = new PermissionRule(GroupReference.forGroup(group));
                if (pri != null) {
                    if (pri.max != null) {
                        r.setMax(pri.max);
                    }
                    if (pri.min != null) {
                        r.setMin(pri.min);
                    }
                    r.setAction(GetAccess.ACTION_TYPE.inverse().get(pri.action));
                    if (pri.force != null) {
                        r.setForce(pri.force);
                    }
                }
                p.add(r);
            }
            accessSection.getPermissions().add(p);
        }
        sections.add(accessSection);
    }
    return sections;
}
#method_after
List<AccessSection> getAccessSections(Map<String, AccessSectionInfo> sectionInfos) throws UnprocessableEntityException {
    if (sectionInfos == null) {
        return Collections.emptyList();
    }
    List<AccessSection> sections = new ArrayList<>(sectionInfos.size());
    for (Map.Entry<String, AccessSectionInfo> entry : sectionInfos.entrySet()) {
        if (entry.getValue().permissions == null) {
            continue;
        }
        AccessSection accessSection = new AccessSection(entry.getKey());
        for (Map.Entry<String, PermissionInfo> permissionEntry : entry.getValue().permissions.entrySet()) {
            if (permissionEntry.getValue().rules == null) {
                continue;
            }
            Permission p = new Permission(permissionEntry.getKey());
            if (permissionEntry.getValue().exclusive != null) {
                p.setExclusiveGroup(permissionEntry.getValue().exclusive);
            }
            for (Map.Entry<String, PermissionRuleInfo> permissionRuleInfoEntry : permissionEntry.getValue().rules.entrySet()) {
                GroupDescription.Basic group = groupsCollection.parseId(permissionRuleInfoEntry.getKey());
                if (group == null) {
                    throw new UnprocessableEntityException(permissionRuleInfoEntry.getKey() + " is not a valid group ID");
                }
                PermissionRuleInfo pri = permissionRuleInfoEntry.getValue();
                PermissionRule r = new PermissionRule(GroupReference.forGroup(group));
                if (pri != null) {
                    if (pri.max != null) {
                        r.setMax(pri.max);
                    }
                    if (pri.min != null) {
                        r.setMin(pri.min);
                    }
                    r.setAction(GetAccess.ACTION_TYPE.inverse().get(pri.action));
                    if (pri.force != null) {
                        r.setForce(pri.force);
                    }
                }
                p.add(r);
            }
            accessSection.getPermissions().add(p);
        }
        sections.add(accessSection);
    }
    return sections;
}
#end_block

#method_before
void validateChanges(ProjectControl projectControl, ProjectConfig config, List<AccessSection> removals, List<AccessSection> additions) throws BadRequestException, AuthException, InvalidNameException, PermissionBackendException {
    // Perform permission checks.
    for (AccessSection section : Iterables.concat(additions, removals)) {
        boolean isGlobalCapabilities = AccessSection.GLOBAL_CAPABILITIES.equals(section.getName());
        if (isGlobalCapabilities) {
            if (!allProjects.equals(config.getName())) {
                throw new BadRequestException("Cannot edit global capabilities for projects other than " + allProjects.get());
            }
        }
    }
    // Perform addition checks
    for (AccessSection section : additions) {
        String name = section.getName();
        boolean isGlobalCapabilities = AccessSection.GLOBAL_CAPABILITIES.equals(name);
        if (!isGlobalCapabilities) {
            if (!AccessSection.isValid(name)) {
                throw new BadRequestException("invalid section name");
            }
            RefPattern.validate(name);
        }
        // Check all permissions for soundness
        for (Permission p : section.getPermissions()) {
            if (isGlobalCapabilities && !GlobalCapability.isCapability(p.getName())) {
                throw new BadRequestException("Cannot add non-global capability " + p.getName() + " to global capabilities");
            }
        }
    }
}
#method_after
void validateChanges(ProjectConfig config, List<AccessSection> removals, List<AccessSection> additions) throws BadRequestException, AuthException, InvalidNameException, PermissionBackendException {
    // Perform permission checks
    for (AccessSection section : Iterables.concat(additions, removals)) {
        boolean isGlobalCapabilities = AccessSection.GLOBAL_CAPABILITIES.equals(section.getName());
        if (isGlobalCapabilities) {
            if (!allProjects.equals(config.getName())) {
                throw new BadRequestException("Cannot edit global capabilities for projects other than " + allProjects.get());
            }
        }
    }
    // Perform addition checks
    for (AccessSection section : additions) {
        String name = section.getName();
        boolean isGlobalCapabilities = AccessSection.GLOBAL_CAPABILITIES.equals(name);
        if (!isGlobalCapabilities) {
            if (!AccessSection.isValid(name)) {
                throw new BadRequestException("invalid section name");
            }
            RefPattern.validate(name);
        } else {
            // Check all permissions for soundness
            for (Permission p : section.getPermissions()) {
                if (!GlobalCapability.isCapability(p.getName())) {
                    throw new BadRequestException("Cannot add non-global capability " + p.getName() + " to global capabilities");
                }
            }
        }
    }
}
#end_block

#method_before
void setParentName(ProjectControl projectControl, ProjectConfig config, Project.NameKey newParentProjectName, boolean checkPermissions) throws ResourceConflictException, AuthException, PermissionBackendException {
    if (newParentProjectName != null && !config.getProject().getNameKey().equals(allProjects) && !config.getProject().getParent(allProjects).equals(newParentProjectName)) {
        try {
            setParent.get().validateParentUpdate(projectControl.getProject().getNameKey(), projectControl.getUser().asIdentifiedUser(), MoreObjects.firstNonNull(newParentProjectName, allProjects).get(), checkPermissions);
        } catch (UnprocessableEntityException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
        config.getProject().setParentName(newParentProjectName);
    }
}
#method_after
void setParentName(IdentifiedUser identifiedUser, ProjectConfig config, Project.NameKey projectName, Project.NameKey newParentProjectName, boolean checkAdmin) throws ResourceConflictException, AuthException, PermissionBackendException {
    if (newParentProjectName != null && !config.getProject().getNameKey().equals(allProjects) && !config.getProject().getParent(allProjects).equals(newParentProjectName)) {
        try {
            setParent.get().validateParentUpdate(projectName, identifiedUser, newParentProjectName.get(), checkAdmin);
        } catch (UnprocessableEntityException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
        config.getProject().setParentName(newParentProjectName);
    }
}
#end_block

#method_before
@Override
public ProjectAccessInfo apply(ProjectResource rsrc, ProjectAccessInput input) throws ResourceNotFoundException, ResourceConflictException, IOException, AuthException, BadRequestException, UnprocessableEntityException, OrmException, PermissionBackendException {
    List<AccessSection> removals = accessUtil.getAccessSections(input.remove);
    List<AccessSection> additions = accessUtil.getAccessSections(input.add);
    MetaDataUpdate.User metaDataUpdateUser = metaDataUpdateFactory.get();
    ProjectControl projectControl = rsrc.getControl();
    ProjectConfig config;
    Project.NameKey newParentProjectName = input.parent == null ? null : new Project.NameKey(input.parent);
    try (MetaDataUpdate md = metaDataUpdateUser.create(rsrc.getNameKey())) {
        config = ProjectConfig.read(md);
        accessUtil.validateChanges(projectControl, config, removals, additions);
        // Check that the user has the right permissions.
        for (AccessSection section : Iterables.concat(additions, removals)) {
            boolean isGlobalCapabilities = AccessSection.GLOBAL_CAPABILITIES.equals(section.getName());
            if (isGlobalCapabilities) {
                permissionBackend.user(identifiedUser).check(GlobalPermission.ADMINISTRATE_SERVER);
            } else if (!projectControl.controlForRef(section.getName()).isOwner()) {
                throw new AuthException("You are not allowed to edit permissions for ref: " + section.getName());
            }
        }
        accessUtil.cleanupPermissions(config, removals, additions);
        accessUtil.setParentName(projectControl, config, newParentProjectName, true);
        if (!Strings.isNullOrEmpty(input.message)) {
            if (!input.message.endsWith("\n")) {
                input.message += "\n";
            }
            md.setMessage(input.message);
        } else {
            md.setMessage("Modify access rules\n");
        }
        config.commit(md);
        projectCache.evict(config.getProject());
    } catch (InvalidNameException e) {
        throw new BadRequestException(e.toString());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(rsrc.getName());
    }
    return getAccess.apply(rsrc.getNameKey());
}
#method_after
@Override
public ProjectAccessInfo apply(ProjectResource rsrc, ProjectAccessInput input) throws ResourceNotFoundException, ResourceConflictException, IOException, AuthException, BadRequestException, UnprocessableEntityException, OrmException, PermissionBackendException {
    MetaDataUpdate.User metaDataUpdateUser = metaDataUpdateFactory.get();
    ProjectConfig config;
    List<AccessSection> removals = accessUtil.getAccessSections(input.remove);
    List<AccessSection> additions = accessUtil.getAccessSections(input.add);
    try (MetaDataUpdate md = metaDataUpdateUser.create(rsrc.getNameKey())) {
        config = ProjectConfig.read(md);
        // Check that the user has the right permissions.
        boolean checkedAdmin = false;
        for (AccessSection section : Iterables.concat(additions, removals)) {
            boolean isGlobalCapabilities = AccessSection.GLOBAL_CAPABILITIES.equals(section.getName());
            if (isGlobalCapabilities) {
                if (!checkedAdmin) {
                    permissionBackend.user(identifiedUser).check(GlobalPermission.ADMINISTRATE_SERVER);
                    checkedAdmin = true;
                }
            } else if (!rsrc.getControl().controlForRef(section.getName()).isOwner()) {
                throw new AuthException("You are not allowed to edit permissions for ref: " + section.getName());
            }
        }
        accessUtil.validateChanges(config, removals, additions);
        accessUtil.applyChanges(config, removals, additions);
        accessUtil.setParentName(identifiedUser.get(), config, rsrc.getNameKey(), input.parent == null ? null : new Project.NameKey(input.parent), !checkedAdmin);
        if (!Strings.isNullOrEmpty(input.message)) {
            if (!input.message.endsWith("\n")) {
                input.message += "\n";
            }
            md.setMessage(input.message);
        } else {
            md.setMessage("Modify access rules\n");
        }
        config.commit(md);
        projectCache.evict(config.getProject());
    } catch (InvalidNameException e) {
        throw new BadRequestException(e.toString());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(rsrc.getName());
    }
    return getAccess.apply(rsrc.getNameKey());
}
#end_block

#method_before
@Override
synchronized public void onEvent(final Event event) {
    if (event instanceof TopicChangedEvent) {
        onTopicChanged((TopicChangedEvent) event);
    } else if (event instanceof PatchSetCreatedEvent) {
        onPatchSetCreated((PatchSetCreatedEvent) event);
    } else if (event instanceof CommentAddedEvent) {
        onCommentAdded((CommentAddedEvent) event);
    }
    // trigger others on the whole project/branch
    if (event instanceof RefEvent) {
        onRefEvent((RefEvent) event);
    }
}
#method_after
@Override
synchronized public void onEvent(final Event event) {
    if (event instanceof TopicChangedEvent) {
        onTopicChanged((TopicChangedEvent) event);
    } else if (event instanceof PatchSetCreatedEvent) {
        onPatchSetCreated((PatchSetCreatedEvent) event);
    } else if (event instanceof CommentAddedEvent) {
        onCommentAdded((CommentAddedEvent) event);
    }
    // trigger others on the whole project/branch
    if (event instanceof RefUpdatedEvent) {
        onRefUpdatedEvent((RefUpdatedEvent) event);
    }
}
#end_block

#method_before
@Override
public OAuthUserInfo getUserInfo(OAuthToken token) throws IOException {
    final String protectedResourceUrl = String.format(PROTECTED_RESOURCE_URL, rootUrl);
    OAuthRequest request = new OAuthRequest(Verb.GET, protectedResourceUrl);
    Token t = new Token(token.getToken(), token.getSecret(), token.getRaw());
    service.signRequest(t, request);
    Response response = request.send();
    if (response.getCode() != HttpServletResponse.SC_OK) {
        throw new IOException(String.format("Status %s (%s) for request %s", response.getCode(), response.getBody(), request.getUrl()));
    }
    if (log.isDebugEnabled()) {
        log.debug("User info response: {}", response.getBody());
    }
    JsonElement userJson = OutputFormat.JSON.newGson().fromJson(response.getBody(), JsonElement.class);
    if (!userJson.isJsonObject()) {
        throw new IOException(String.format("Invalid JSON '%s': not a JSON Object", userJson));
    }
    JsonObject jsonObject = userJson.getAsJsonObject();
    JsonElement id = jsonObject.get("id");
    if (id == null || id.isJsonNull()) {
        throw new IOException(String.format("Response doesn't contain %s field", "id"));
    }
    JsonElement attrListJson = jsonObject.get("attributes");
    String email = null, name = null, login = null;
    if (attrListJson != null && attrListJson.isJsonArray()) {
        JsonArray attrJson = attrListJson.getAsJsonArray();
        for (JsonElement elem : attrJson) {
            if (elem == null || !elem.isJsonObject()) {
                throw new IOException(String.format("Invalid JSON '%s': not a JSON Object", elem));
            }
            JsonObject obj = elem.getAsJsonObject();
            String property = getStringElement(obj, "email");
            if (property != null)
                email = property;
            property = getStringElement(obj, "name");
            if (property != null)
                name = property;
            property = getStringElement(obj, "login");
            if (property != null)
                login = property;
        }
    }
    return new OAuthUserInfo(CAS_PROVIDER_PREFIX + id.getAsString(), login, email, name, fixLegacyUserId ? id.getAsString() : null);
}
#method_after
@Override
public OAuthUserInfo getUserInfo(OAuthToken token) throws IOException {
    final String protectedResourceUrl = String.format(PROTECTED_RESOURCE_URL, rootUrl);
    OAuthRequest request = new OAuthRequest(Verb.GET, protectedResourceUrl);
    Token t = new Token(token.getToken(), token.getSecret(), token.getRaw());
    service.signRequest(t, request);
    Response response = request.send();
    if (response.getCode() != HttpServletResponse.SC_OK) {
        throw new IOException(String.format("Status %s (%s) for request %s", response.getCode(), response.getBody(), request.getUrl()));
    }
    if (log.isDebugEnabled()) {
        log.debug("User info response: {}", response.getBody());
    }
    JsonElement userJson = OutputFormat.JSON.newGson().fromJson(response.getBody(), JsonElement.class);
    if (!userJson.isJsonObject()) {
        throw new IOException(String.format("Invalid JSON '%s': not a JSON Object", userJson));
    }
    JsonObject jsonObject = userJson.getAsJsonObject();
    JsonElement id = jsonObject.get("id");
    if (id == null || id.isJsonNull()) {
        throw new IOException(String.format("CAS response missing id: %s", response.getBody()));
    }
    JsonElement attrListJson = jsonObject.get("attributes");
    if (attrListJson == null) {
        throw new IOException(String.format("CAS response missing attributes: %s", response.getBody()));
    }
    String email = null, name = null, login = null;
    if (attrListJson != null && attrListJson.isJsonArray()) {
        // It is possible for CAS to be configured to not return any attributes (email, name, login), in which case,
        // CAS returns an empty JSON object "attributes":{}, rather than "null" or an empty JSON array "attributes": []
        JsonArray attrJson = attrListJson.getAsJsonArray();
        for (JsonElement elem : attrJson) {
            if (elem == null || !elem.isJsonObject()) {
                throw new IOException(String.format("Invalid JSON '%s': not a JSON Object", elem));
            }
            JsonObject obj = elem.getAsJsonObject();
            String property = getStringElement(obj, "email");
            if (property != null)
                email = property;
            property = getStringElement(obj, "name");
            if (property != null)
                name = property;
            property = getStringElement(obj, "login");
            if (property != null)
                login = property;
        }
    }
    return new OAuthUserInfo(CAS_PROVIDER_PREFIX + id.getAsString(), login, email, name, fixLegacyUserId ? id.getAsString() : null);
}
#end_block

#method_before
public IdentifiedUser getUser() {
    return getControl().getUser().asIdentifiedUser();
}
#method_after
public CurrentUser getUser() {
    return getControl().getUser();
}
#end_block

#method_before
// This includes all information relevant for ETag computation
public void prepareETag(Hasher h, CurrentUser user) {
    h.putInt(JSON_FORMAT_VERSION).putLong(getChange().getLastUpdatedOn().getTime()).putInt(getChange().getRowVersion()).putInt(user.isIdentifiedUser() ? user.getAccountId().get() : 0);
    if (user.isIdentifiedUser()) {
        for (AccountGroup.UUID uuid : user.getEffectiveGroups().getKnownGroups()) {
            h.putBytes(uuid.get().getBytes(UTF_8));
        }
    }
    byte[] buf = new byte[20];
    Set<Account.Id> accounts = new HashSet<>();
    accounts.add(getChange().getOwner());
    try {
        ListMultimap<PatchSet.Id, PatchSetApproval> approvals = approvalUtil.byChange(db.get(), getNotes());
        ReviewerSet reviewers = approvalUtil.getReviewers(getNotes(), approvals.values());
        accounts.addAll(approvals.values().stream().map(a -> a.getAccountId()).collect(toSet()));
        accounts.addAll(reviewers.byState(ReviewerStateInternal.REVIEWER));
        accounts.addAll(reviewers.byState(ReviewerStateInternal.CC));
    } catch (OrmException e) {
    // This ETag will be invalidated if it loads next time.
    }
    accounts.stream().forEach(a -> hashObjectId(h, ObjectId.fromString(accountCache.get(a).getAccount().getMetaId()), buf));
    ObjectId noteId;
    try {
        noteId = getNotes().loadRevision();
    } catch (OrmException e) {
        // This ETag will be invalidated if it loads next time.
        noteId = null;
    }
    hashObjectId(h, noteId, buf);
    for (ProjectState p : control.getProjectControl().getProjectState().tree()) {
        hashObjectId(h, p.getConfig().getRevision(), buf);
    }
}
#method_after
// This includes all information relevant for ETag computation
public void prepareETag(Hasher h, CurrentUser user) {
    h.putInt(JSON_FORMAT_VERSION).putLong(getChange().getLastUpdatedOn().getTime()).putInt(getChange().getRowVersion()).putInt(user.isIdentifiedUser() ? user.getAccountId().get() : 0);
    if (user.isIdentifiedUser()) {
        for (AccountGroup.UUID uuid : user.getEffectiveGroups().getKnownGroups()) {
            h.putBytes(uuid.get().getBytes(UTF_8));
        }
    }
    byte[] buf = new byte[20];
    Set<Account.Id> accounts = new HashSet<>();
    accounts.add(getChange().getOwner());
    if (getChange().getAssignee() != null) {
        accounts.add(getChange().getAssignee());
    }
    try {
        patchSetUtil.byChange(db.get(), getNotes()).stream().map(ps -> ps.getUploader()).forEach(accounts::add);
        // It's intentional to include the states for *all* reviewers into the ETag computation.
        // We need the states of all current reviewers and CCs because they are part of ChangeInfo.
        // Including removed reviewers is a cheap way of making sure that the states of accounts that
        // posted a message on the change are included. Loading all change messages to find the exact
        // set of accounts that posted a message is too expensive. However everyone who posts a
        // message is automatically added as reviewer. Hence if we include removed reviewers we can
        // be sure that we have all accounts that posted messages on the change.
        accounts.addAll(approvalUtil.getReviewers(db.get(), getNotes()).all());
    } catch (OrmException e) {
    // This ETag will be invalidated if it loads next time.
    }
    accounts.stream().forEach(a -> hashAccount(h, accountCache.get(a), buf));
    ObjectId noteId;
    try {
        noteId = getNotes().loadRevision();
    } catch (OrmException e) {
        // This ETag will be invalidated if it loads next time.
        noteId = null;
    }
    hashObjectId(h, noteId, buf);
    for (ProjectState p : control.getProjectControl().getProjectState().tree()) {
        hashObjectId(h, p.getConfig().getRevision(), buf);
    }
}
#end_block

#method_before
@Test
public void removeReviewerNotPermitted() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    gApi.changes().id(changeId).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("delete reviewer not permitted");
    gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).remove();
}
#method_after
@Test
public void removeReviewerNotPermitted() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    gApi.changes().id(changeId).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("remove reviewer not permitted");
    gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).remove();
}
#end_block

#method_before
private Map<Change.Id, Branch.NameKey> visibleChangesByScan() {
    Project.NameKey p = projectCtl.getProject().getNameKey();
    Stream<ChangeNotesResult> s;
    try {
        s = changeNotesFactory.scan(git, db.get(), p);
    } catch (IOException e) {
        log.error("Cannot load changes for project " + p + ", assuming no changes are visible", e);
        return Collections.emptyMap();
    }
    return s.map(r -> {
        if (r.error().isPresent()) {
            log.warn("Failed to load change " + r.id() + " in " + p, r.error().get());
            return null;
        }
        try {
            if (permissionBackend.user(user).change(r.notes()).database(db).test(ChangePermission.READ)) {
                return r.notes();
            }
        } catch (PermissionBackendException e) {
            log.warn("Failed to check permission for " + r.id() + " in " + p, e);
        }
        return null;
    }).filter(Objects::nonNull).collect(toMap(n -> n.getChangeId(), n -> n.getChange().getDest()));
}
#method_after
private Map<Change.Id, Branch.NameKey> visibleChangesByScan() {
    Project.NameKey p = projectCtl.getProject().getNameKey();
    Stream<ChangeNotesResult> s;
    try {
        s = changeNotesFactory.scan(git, db.get(), p);
    } catch (IOException e) {
        log.error("Cannot load changes for project " + p + ", assuming no changes are visible", e);
        return Collections.emptyMap();
    }
    return s.map(r -> toNotes(p, r)).filter(Objects::nonNull).collect(toMap(n -> n.getChangeId(), n -> n.getChange().getDest()));
}
#end_block

#method_before
private Map<Change.Id, Branch.NameKey> visibleChangesByScan() {
    Project.NameKey project = projectCtl.getProject().getNameKey();
    try {
        Map<Change.Id, Branch.NameKey> visibleChanges = new HashMap<>();
        ChangeNotesIterator it = changeNotesFactory.scan(git, db.get(), project);
        while (it.hasNext()) {
            ChangeNotes cn = it.next();
            if (permissionBackend.user(user).change(cn).database(db).test(ChangePermission.READ)) {
                visibleChanges.put(cn.getChangeId(), cn.getChange().getDest());
            }
        }
        return visibleChanges;
    } catch (IOException | OrmException | PermissionBackendException e) {
        log.error("Cannot load changes for project " + project + ", assuming no changes are visible", e);
        return Collections.emptyMap();
    }
}
#method_after
private Map<Change.Id, Branch.NameKey> visibleChangesByScan() {
    Project.NameKey project = projectCtl.getProject().getNameKey();
    try {
        Map<Change.Id, Branch.NameKey> visibleChanges = new HashMap<>();
        // avoid this ugly foreach loop.
        for (ChangeNotesResult r : (Iterable<ChangeNotesResult>) changeNotesFactory.scan(git, db.get(), project)::iterator) {
            if (r.error().isPresent()) {
                throw new OrmException(r.error().get());
            }
            ChangeNotes cn = r.notes();
            if (permissionBackend.user(user).change(cn).database(db).test(ChangePermission.READ)) {
                visibleChanges.put(cn.getChangeId(), cn.getChange().getDest());
            }
        }
        return visibleChanges;
    } catch (IOException | OrmException | PermissionBackendException e) {
        log.error("Cannot load changes for project " + project + ", assuming no changes are visible", e);
        return Collections.emptyMap();
    }
}
#end_block

#method_before
@Override
public Void call() throws Exception {
    try (Repository repo = repoManager.openRepository(project);
        ReviewDb db = schemaFactory.open()) {
        // Order of scanning changes is undefined. This is ok if we assume that packfile locality is
        // not important for indexing, since sites should have a fully populated DiffSummary cache.
        // It does mean that reindexing after invalidating the DiffSummary cache will be expensive,
        // but the goal is to invalidate that cache as infrequently as we possibly can.
        ChangeNotesIterator it = notesFactory.scan(repo, db, project);
        while (true) {
            ChangeNotes notes = null;
            try {
                notes = it.next();
                indexer.index(changeDataFactory.create(db, notes));
                done.update(1);
                verboseWriter.println("Reindexed change " + notes.getChangeId());
            } catch (NoSuchElementException e) {
                break;
            } catch (RejectedExecutionException e) {
                // Server shutdown, don't spam the logs.
                failSilently();
            } catch (NextChangeNotesException e) {
                fail("Failed to index change " + e.getId(), true, e);
            } catch (Exception e) {
                String msg = notes != null ? "Failed to index change " + notes.getChangeId() : "Failed to index unknown change";
                fail(msg, true, e);
            }
        }
    }
    return null;
}
#method_after
@Override
public Void call() throws Exception {
    try (Repository repo = repoManager.openRepository(project);
        ReviewDb db = schemaFactory.open()) {
        // Order of scanning changes is undefined. This is ok if we assume that packfile locality is
        // not important for indexing, since sites should have a fully populated DiffSummary cache.
        // It does mean that reindexing after invalidating the DiffSummary cache will be expensive,
        // but the goal is to invalidate that cache as infrequently as we possibly can. And besides,
        // we don't have concrete proof that improving packfile locality would help.
        notesFactory.scan(repo, db, project).forEach(r -> index(db, r));
    } catch (RepositoryNotFoundException rnfe) {
        log.error(rnfe.getMessage());
    }
    return null;
}
#end_block

#method_before
// TODO(ekempin): Remove when database backend is deleted
ChangeNotes createFromChangeOnlyWhenNoteDbDisabled(Change change) throws OrmException {
    checkState(!args.migration.readChanges(), "do not call createFromChangeWhenNoteDbDisabled when NoteDb is enabled");
    return new ChangeNotes(args, change).load();
}
#method_after
// TODO(ekempin): Remove when database backend is deleted
private ChangeNotes createFromChangeOnlyWhenNoteDbDisabled(Change change) throws OrmException {
    checkState(!args.migration.readChanges(), "do not call createFromChangeWhenNoteDbDisabled when NoteDb is enabled");
    return new ChangeNotes(args, change).load();
}
#end_block

#method_before
public ListMultimap<Project.NameKey, ChangeNotes> create(ReviewDb db, Predicate<ChangeNotes> predicate) throws IOException, OrmException {
    ListMultimap<Project.NameKey, ChangeNotes> m = MultimapBuilder.hashKeys().arrayListValues().build();
    if (args.migration.readChanges()) {
        for (Project.NameKey project : projectCache.all()) {
            try (Repository repo = args.repoManager.openRepository(project)) {
                ChangeNotesIterator it = scanNoteDb(repo, db, project);
                while (it.hasNext()) {
                    ChangeNotes cn = it.next();
                    if (predicate.test(cn)) {
                        m.put(project, cn);
                    }
                }
            }
        }
    } else {
        for (Change change : ReviewDbUtil.unwrapDb(db).changes().all()) {
            ChangeNotes notes = createFromChangeOnlyWhenNoteDbDisabled(change);
            if (predicate.test(notes)) {
                m.put(change.getProject(), notes);
            }
        }
    }
    return ImmutableListMultimap.copyOf(m);
}
#method_after
public ListMultimap<Project.NameKey, ChangeNotes> create(ReviewDb db, Predicate<ChangeNotes> predicate) throws IOException, OrmException {
    ListMultimap<Project.NameKey, ChangeNotes> m = MultimapBuilder.hashKeys().arrayListValues().build();
    if (args.migration.readChanges()) {
        for (Project.NameKey project : projectCache.all()) {
            try (Repository repo = args.repoManager.openRepository(project)) {
                scanNoteDb(repo, db, project).filter(r -> !r.error().isPresent()).map(ChangeNotesResult::notes).filter(predicate).forEach(n -> m.put(n.getProjectName(), n));
            }
        }
    } else {
        for (Change change : ReviewDbUtil.unwrapDb(db).changes().all()) {
            ChangeNotes notes = createFromChangeOnlyWhenNoteDbDisabled(change);
            if (predicate.test(notes)) {
                m.put(change.getProject(), notes);
            }
        }
    }
    return ImmutableListMultimap.copyOf(m);
}
#end_block

#method_before
public ChangeNotesIterator scan(Repository repo, ReviewDb db, Project.NameKey project) {
    return args.migration.readChanges() ? scanNoteDb(repo, db, project) : new ReviewDbChangeNotesIterator(this, repo, db);
}
#method_after
public Stream<ChangeNotesResult> scan(Repository repo, ReviewDb db, Project.NameKey project) throws IOException {
    return args.migration.readChanges() ? scanNoteDb(repo, db, project) : scanReviewDb(repo, db);
}
#end_block

#method_before
private NoteDbChangeNotesIterator scanNoteDb(Repository repo, ReviewDb db, Project.NameKey project) {
    return new NoteDbChangeNotesIterator(this, repo, db, project, args.migration.changePrimaryStorage());
}
#method_after
private Stream<ChangeNotesResult> scanNoteDb(Repository repo, ReviewDb db, Project.NameKey project) throws IOException {
    ScanResult sr = scanChangeIds(repo);
    PrimaryStorage defaultStorage = args.migration.changePrimaryStorage();
    return sr.all().stream().map(id -> scanOneNoteDbChange(db, project, sr, defaultStorage, id)).filter(Objects::nonNull);
}
#end_block

#method_before
static ScanResult scanChangeIds(Repository repo) throws IOException {
    ImmutableSet.Builder<Change.Id> fromPs = ImmutableSet.builder();
    ImmutableSet.Builder<Change.Id> fromMeta = ImmutableSet.builder();
    for (Ref r : repo.getRefDatabase().getRefs(RefNames.REFS_CHANGES).values()) {
        Change.Id id = Change.Id.fromRef(r.getName());
        if (id != null) {
            (r.getName().endsWith(RefNames.META_SUFFIX) ? fromMeta : fromPs).add(id);
        }
    }
    return new AutoValue_ChangeNotes_Factory_ScanResult(fromPs.build(), fromMeta.build());
}
#method_after
private static ScanResult scanChangeIds(Repository repo) throws IOException {
    ImmutableSet.Builder<Change.Id> fromPs = ImmutableSet.builder();
    ImmutableSet.Builder<Change.Id> fromMeta = ImmutableSet.builder();
    for (Ref r : repo.getRefDatabase().getRefs(RefNames.REFS_CHANGES).values()) {
        Change.Id id = Change.Id.fromRef(r.getName());
        if (id != null) {
            (r.getName().endsWith(RefNames.META_SUFFIX) ? fromMeta : fromPs).add(id);
        }
    }
    return new AutoValue_ChangeNotes_Factory_ScanResult(fromPs.build(), fromMeta.build());
}
#end_block

#method_before
@Override
public Void call() throws Exception {
    try (Repository repo = repoManager.openRepository(project);
        ReviewDb db = schemaFactory.open()) {
        // all ChangeNotes into memory.
        for (ChangeNotes notes : notesFactory.scan(repo, db, project)) {
            try {
                indexer.index(changeDataFactory.create(db, notes));
                done.update(1);
                verboseWriter.println("Reindexed change " + notes.getChangeId());
            } catch (RejectedExecutionException e) {
                // Server shutdown, don't spam the logs.
                failSilently();
            } catch (Exception e) {
                fail("Failed to index change " + notes.getChangeId(), true, e);
            }
        }
    }
    return null;
}
#method_after
@Override
public Void call() throws Exception {
    try (Repository repo = repoManager.openRepository(project);
        ReviewDb db = schemaFactory.open()) {
        // all ChangeNotes into memory.
        for (ChangeNotes notes : notesFactory.scan(repo, db, project)) {
            try {
                indexer.index(changeDataFactory.create(db, notes));
                done.update(1);
                verboseWriter.println("Reindexed change " + notes.getChangeId());
            } catch (RejectedExecutionException e) {
                // Server shutdown, don't spam the logs.
                failSilently();
            } catch (Exception e) {
                fail("Failed to index change " + notes.getChangeId(), true, e);
            }
        }
    } catch (RepositoryNotFoundException rnfe) {
        log.error(rnfe.getMessage());
    }
    return null;
}
#end_block

#method_before
protected void beforeTest(Description description) throws Exception {
    this.description = description;
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.initAndStart(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.initAndStart(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    admin = accountCreator.admin();
    user = accountCreator.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    db = reviewDbProvider.open();
    testRequiresSsh = classDesc.useSshAnnotation() || methodDesc.useSshAnnotation();
    if (testRequiresSsh && SshMode.useSsh() && (adminSshSession == null || userSshSession == null)) {
        // Create Ssh sessions
        initSsh(admin);
        Context ctx = newRequestContext(user);
        atrScope.set(ctx);
        userSshSession = ctx.getSession();
        userSshSession.open();
        ctx = newRequestContext(admin);
        atrScope.set(ctx);
        adminSshSession = ctx.getSession();
        adminSshSession.open();
    }
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#method_after
protected void beforeTest(Description description) throws Exception {
    this.description = description;
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.initAndStart(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.initAndStart(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    // As a workaround, we simply reindex all available groups here.
    for (AccountGroup group : groupCache.all()) {
        groupCache.evict(group);
    }
    admin = accountCreator.admin();
    user = accountCreator.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    db = reviewDbProvider.open();
    testRequiresSsh = classDesc.useSshAnnotation() || methodDesc.useSshAnnotation();
    if (testRequiresSsh && SshMode.useSsh() && (adminSshSession == null || userSshSession == null)) {
        // Create Ssh sessions
        initSsh(admin);
        Context ctx = newRequestContext(user);
        atrScope.set(ctx);
        userSshSession = ctx.getSession();
        userSshSession.open();
        ctx = newRequestContext(admin);
        atrScope.set(ctx);
        adminSshSession = ctx.getSession();
        adminSshSession.open();
    }
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#end_block

#method_before
@Test
public void lookUpByPreferredEmail() throws Exception {
    // create an inconsistent account that has a preferred email without external ID
    String prefEmail = "foo.preferred@example.com";
    TestAccount foo = accountCreator.create(name("foo"));
    accountsUpdate.create().update(db, foo.id, a -> a.setPreferredEmail(prefEmail));
    // verify that the account is still found when using the preferred email to lookup the account
    ImmutableSet<Account.Id> accountsByPrefEmail = emails.getAccountFor(prefEmail);
    assertThat(accountsByPrefEmail).hasSize(1);
    assertThat(Iterables.getOnlyElement(accountsByPrefEmail)).isEqualTo(foo.id);
}
#method_after
@Test
public void lookUpByPreferredEmail() throws Exception {
    // create an inconsistent account that has a preferred email without external ID
    String prefix = "foo.preferred";
    String prefEmail = prefix + "@example.com";
    TestAccount foo = accountCreator.create(name("foo"));
    accountsUpdate.create().update(db, foo.id, a -> a.setPreferredEmail(prefEmail));
    // verify that the account is still found when using the preferred email to lookup the account
    ImmutableSet<Account.Id> accountsByPrefEmail = emails.getAccountFor(prefEmail);
    assertThat(accountsByPrefEmail).hasSize(1);
    assertThat(Iterables.getOnlyElement(accountsByPrefEmail)).isEqualTo(foo.id);
    // look up by email prefix doesn't find the account
    accountsByPrefEmail = emails.getAccountFor(prefix);
    assertThat(accountsByPrefEmail).isEmpty();
    // look up by other case doesn't find the account
    accountsByPrefEmail = emails.getAccountFor(prefEmail.toUpperCase(Locale.US));
    assertThat(accountsByPrefEmail).isEmpty();
}
#end_block

#method_before
@Test
public void groups() throws Exception {
    assertGroups(admin.username, ImmutableList.of("Registered Users", "Administrators", "Anonymous Users"));
    // TODO: is the user expected to be in these groups?
    // assertGroups(user.username, ImmutableList.of("Registered Users", "Anonymous Users"));
    String group = createGroup("group");
    String user = createAccount("user1", group);
    assertGroups(user, ImmutableList.of(group));
}
#method_after
@Test
public void groups() throws Exception {
    assertGroups(admin.username, ImmutableList.of("Anonymous Users", "Registered Users", "Administrators"));
    // TODO: update when test user is fixed to be included in "Anonymous Users" and
    // "Registered Users" groups
    assertGroups(user.username, ImmutableList.of());
    String group = createGroup("group");
    String newUser = createAccount("user1", group);
    assertGroups(newUser, ImmutableList.of(group));
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws AuthException, ResourceNotFoundException, OrmException, PermissionBackendException {
    Account.Id reviewerId = reviewer.getId();
    if (!approvalsUtil.getReviewers(ctx.getDb(), ctx.getNotes()).all().contains(reviewerId)) {
        throw new ResourceNotFoundException();
    }
    currChange = ctx.getChange();
    currPs = psUtil.current(ctx.getDb(), ctx.getNotes());
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    // removing a reviewer will remove all her votes
    for (LabelType lt : labelTypes.getLabelTypes()) {
        newApprovals.put(lt.getName(), (short) 0);
    }
    StringBuilder msg = new StringBuilder();
    msg.append("Removed reviewer " + reviewer.getFullName());
    StringBuilder removedVotesMsg = new StringBuilder();
    removedVotesMsg.append(" with the following votes:\n\n");
    List<PatchSetApproval> del = new ArrayList<>();
    boolean votesRemoved = false;
    for (PatchSetApproval a : approvals(ctx, reviewerId)) {
        if (!ctx.getControl().canRemoveReviewer(a)) {
            ctx.permissions().check(ChangePermission.REMOVE_REVIEWER);
        }
        del.add(a);
        if (a.getPatchSetId().equals(currPs.getId()) && a.getValue() != 0) {
            oldApprovals.put(a.getLabel(), a.getValue());
            removedVotesMsg.append("* ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
            votesRemoved = true;
        }
    }
    if (votesRemoved) {
        msg.append(removedVotesMsg);
    } else {
        msg.append(".");
    }
    ctx.getDb().patchSetApprovals().delete(del);
    ChangeUpdate update = ctx.getUpdate(currPs.getId());
    update.removeReviewer(reviewerId);
    changeMessage = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_DELETE_REVIEWER);
    cmUtil.addChangeMessage(ctx.getDb(), update, changeMessage);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws AuthException, ResourceNotFoundException, OrmException, PermissionBackendException {
    Account.Id reviewerId = reviewer.getId();
    if (!approvalsUtil.getReviewers(ctx.getDb(), ctx.getNotes()).all().contains(reviewerId)) {
        throw new ResourceNotFoundException();
    }
    currChange = ctx.getChange();
    currPs = psUtil.current(ctx.getDb(), ctx.getNotes());
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    // removing a reviewer will remove all her votes
    for (LabelType lt : labelTypes.getLabelTypes()) {
        newApprovals.put(lt.getName(), (short) 0);
    }
    StringBuilder msg = new StringBuilder();
    msg.append("Removed reviewer " + reviewer.getFullName());
    StringBuilder removedVotesMsg = new StringBuilder();
    removedVotesMsg.append(" with the following votes:\n\n");
    List<PatchSetApproval> del = new ArrayList<>();
    boolean votesRemoved = false;
    for (PatchSetApproval a : approvals(ctx, reviewerId)) {
        removeReviewerControl.checkRemoveReviewer(ctx.getNotes(), ctx.getUser(), a);
        del.add(a);
        if (a.getPatchSetId().equals(currPs.getId()) && a.getValue() != 0) {
            oldApprovals.put(a.getLabel(), a.getValue());
            removedVotesMsg.append("* ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
            votesRemoved = true;
        }
    }
    if (votesRemoved) {
        msg.append(removedVotesMsg);
    } else {
        msg.append(".");
    }
    ctx.getDb().patchSetApprovals().delete(del);
    ChangeUpdate update = ctx.getUpdate(currPs.getId());
    update.removeReviewer(reviewerId);
    changeMessage = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_DELETE_REVIEWER);
    cmUtil.addChangeMessage(ctx.getDb(), update, changeMessage);
    return true;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, AuthException, ResourceNotFoundException, IOException, PermissionBackendException {
    ChangeControl ctl = ctx.getControl();
    change = ctl.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ps = psUtil.current(db.get(), ctl.getNotes());
    boolean found = false;
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctl, psId, account.getId(), ctx.getRevWalk(), ctx.getRepoView().getConfig())) {
        if (labelTypes.byLabel(a.getLabelId()) == null) {
            // Ignore undefined labels.
            continue;
        } else if (!a.getLabel().equals(label)) {
            // Populate map for non-matching labels, needed by VoteDeleted.
            newApprovals.put(a.getLabel(), a.getValue());
            continue;
        } else if (!ctl.canRemoveReviewer(a)) {
            try {
                ctx.permissions().check(ChangePermission.REMOVE_REVIEWER);
            } catch (AuthException e) {
                throw new AuthException("delete vote not permitted", e);
            }
        }
        // Set the approval to 0 if vote is being removed.
        newApprovals.put(a.getLabel(), (short) 0);
        found = true;
        // Set old value, as required by VoteDeleted.
        oldApprovals.put(a.getLabel(), a.getValue());
        break;
    }
    if (!found) {
        throw new ResourceNotFoundException();
    }
    ctx.getUpdate(psId).removeApprovalFor(account.getId(), label);
    ctx.getDb().patchSetApprovals().upsert(Collections.singleton(deletedApproval(ctx)));
    StringBuilder msg = new StringBuilder();
    msg.append("Removed ");
    LabelVote.appendTo(msg, label, checkNotNull(oldApprovals.get(label)));
    msg.append(" by ").append(userFactory.create(account.getId()).getNameEmail()).append("\n");
    changeMessage = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_DELETE_VOTE);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, AuthException, ResourceNotFoundException, IOException, PermissionBackendException {
    ChangeControl ctl = ctx.getControl();
    change = ctl.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ps = psUtil.current(db.get(), ctl.getNotes());
    boolean found = false;
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctl, psId, account.getId(), ctx.getRevWalk(), ctx.getRepoView().getConfig())) {
        if (labelTypes.byLabel(a.getLabelId()) == null) {
            // Ignore undefined labels.
            continue;
        } else if (!a.getLabel().equals(label)) {
            // Populate map for non-matching labels, needed by VoteDeleted.
            newApprovals.put(a.getLabel(), a.getValue());
            continue;
        } else {
            try {
                removeReviewerControl.checkRemoveReviewer(ctx.getNotes(), ctx.getUser(), a);
            } catch (AuthException e) {
                throw new AuthException("delete vote not permitted", e);
            }
        }
        // Set the approval to 0 if vote is being removed.
        newApprovals.put(a.getLabel(), (short) 0);
        found = true;
        // Set old value, as required by VoteDeleted.
        oldApprovals.put(a.getLabel(), a.getValue());
        break;
    }
    if (!found) {
        throw new ResourceNotFoundException();
    }
    ctx.getUpdate(psId).removeApprovalFor(account.getId(), label);
    ctx.getDb().patchSetApprovals().upsert(Collections.singleton(deletedApproval(ctx)));
    StringBuilder msg = new StringBuilder();
    msg.append("Removed ");
    LabelVote.appendTo(msg, label, checkNotNull(oldApprovals.get(label)));
    msg.append(" by ").append(userFactory.create(account.getId()).getNameEmail()).append("\n");
    changeMessage = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_DELETE_VOTE);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage);
    return true;
}
#end_block

#method_before
private Collection<AccountInfo> removableReviewers(ChangeControl ctl, ChangeInfo out) throws PermissionBackendException {
    // Although this is called removableReviewers, this method also determines
    // which CCs are removable.
    // 
    // For reviewers, we need to look at each approval, because the reviewer
    // should only be considered removable if *all* of their approvals can be
    // removed. First, add all reviewers with *any* removable approval to the
    // "removable" set. Along the way, if we encounter a non-removable approval,
    // add the reviewer to the "fixed" set. Before we return, remove all members
    // of "fixed" from "removable", because not all of their approvals can be
    // removed.
    Collection<LabelInfo> labels = out.labels.values();
    Set<Account.Id> fixed = Sets.newHashSetWithExpectedSize(labels.size());
    Set<Account.Id> removable = Sets.newHashSetWithExpectedSize(labels.size());
    for (LabelInfo label : labels) {
        if (label.all == null) {
            continue;
        }
        for (ApprovalInfo ai : label.all) {
            Account.Id id = new Account.Id(ai._accountId);
            if (canRemoveReviewer(ctl, id, MoreObjects.firstNonNull(ai.value, 0))) {
                removable.add(id);
            } else {
                fixed.add(id);
            }
        }
    }
    // CCs are simpler than reviewers. They are removable if the ChangeControl
    // would permit a non-negative approval by that account to be removed, in
    // which case add them to removable. We don't need to add unremovable CCs to
    // "fixed" because we only visit each CC once here.
    Collection<AccountInfo> ccs = out.reviewers.get(ReviewerState.CC);
    if (ccs != null) {
        for (AccountInfo ai : ccs) {
            if (ai._accountId != null) {
                Account.Id id = new Account.Id(ai._accountId);
                if (canRemoveReviewer(ctl, id, 0)) {
                    removable.add(id);
                }
            }
        }
    }
    // Subtract any reviewers with non-removable approvals from the "removable"
    // set. This also subtracts any CCs that for some reason also hold
    // unremovable approvals.
    removable.removeAll(fixed);
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    // Reviewers added by email are always removable
    for (Collection<AccountInfo> infos : out.reviewers.values()) {
        for (AccountInfo info : infos) {
            if (info._accountId == null) {
                result.add(info);
            }
        }
    }
    return result;
}
#method_after
private Collection<AccountInfo> removableReviewers(ChangeControl ctl, ChangeInfo out) throws PermissionBackendException, NoSuchChangeException {
    // Although this is called removableReviewers, this method also determines
    // which CCs are removable.
    // 
    // For reviewers, we need to look at each approval, because the reviewer
    // should only be considered removable if *all* of their approvals can be
    // removed. First, add all reviewers with *any* removable approval to the
    // "removable" set. Along the way, if we encounter a non-removable approval,
    // add the reviewer to the "fixed" set. Before we return, remove all members
    // of "fixed" from "removable", because not all of their approvals can be
    // removed.
    Collection<LabelInfo> labels = out.labels.values();
    Set<Account.Id> fixed = Sets.newHashSetWithExpectedSize(labels.size());
    Set<Account.Id> removable = Sets.newHashSetWithExpectedSize(labels.size());
    for (LabelInfo label : labels) {
        if (label.all == null) {
            continue;
        }
        for (ApprovalInfo ai : label.all) {
            Account.Id id = new Account.Id(ai._accountId);
            if (removeReviewerControl.testRemoveReviewer(ctl.getNotes(), ctl.getUser(), id, MoreObjects.firstNonNull(ai.value, 0))) {
                removable.add(id);
            } else {
                fixed.add(id);
            }
        }
    }
    // CCs are simpler than reviewers. They are removable if the ChangeControl
    // would permit a non-negative approval by that account to be removed, in
    // which case add them to removable. We don't need to add unremovable CCs to
    // "fixed" because we only visit each CC once here.
    Collection<AccountInfo> ccs = out.reviewers.get(ReviewerState.CC);
    if (ccs != null) {
        for (AccountInfo ai : ccs) {
            if (ai._accountId != null) {
                Account.Id id = new Account.Id(ai._accountId);
                if (removeReviewerControl.testRemoveReviewer(ctl.getNotes(), ctl.getUser(), id, 0)) {
                    removable.add(id);
                }
            }
        }
    }
    // Subtract any reviewers with non-removable approvals from the "removable"
    // set. This also subtracts any CCs that for some reason also hold
    // unremovable approvals.
    removable.removeAll(fixed);
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    // Reviewers added by email are always removable
    for (Collection<AccountInfo> infos : out.reviewers.values()) {
        for (AccountInfo info : infos) {
            if (info._accountId == null) {
                result.add(info);
            }
        }
    }
    return result;
}
#end_block

#method_before
public boolean isVisible(ReviewDb db) throws OrmException {
    return isVisible(db, null);
}
#method_after
boolean isVisible(ReviewDb db) throws OrmException {
    return isVisible(db, null);
}
#end_block

#method_before
public boolean isVisible(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getChange().isPrivate() && !isPrivateVisible(db, cd)) {
        return false;
    }
    if (getChange().getStatus() == Change.Status.DRAFT && !isDraftVisible(db, cd)) {
        return false;
    }
    return getRefControl().isVisible();
}
#method_after
private boolean isVisible(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getChange().isPrivate() && !isPrivateVisible(db, cd)) {
        return false;
    }
    if (getChange().getStatus() == Change.Status.DRAFT && !isDraftVisible(db, cd)) {
        return false;
    }
    return getRefControl().isVisible();
}
#end_block

#method_before
public boolean isPatchVisible(PatchSet ps, ReviewDb db) throws OrmException {
    if (ps != null && ps.isDraft() && !isDraftVisible(db, null)) {
        return false;
    }
    return isVisible(db);
}
#method_after
public boolean isPatchVisible(PatchSet ps, ReviewDb db) throws OrmException {
    // TODO(hiesel) These don't need to be migrated, just remove after support for drafts is removed
    if (ps != null && ps.isDraft() && !isDraftVisible(db, null)) {
        return false;
    }
    return isVisible(db);
}
#end_block

#method_before
public boolean isPatchVisible(PatchSet ps, ChangeData cd) throws OrmException {
    checkArgument(cd.getId().equals(ps.getId().getParentKey()), "%s not for change %s", ps, cd.getId());
    if (ps.isDraft() && !isDraftVisible(cd.db(), cd)) {
        return false;
    }
    return isVisible(cd.db());
}
#method_after
public boolean isPatchVisible(PatchSet ps, ChangeData cd) throws OrmException {
    // TODO(hiesel) These don't need to be migrated, just remove after support for drafts is removed
    checkArgument(cd.getId().equals(ps.getId().getParentKey()), "%s not for change %s", ps, cd.getId());
    if (ps.isDraft() && !isDraftVisible(cd.db(), cd)) {
        return false;
    }
    return isVisible(cd.db());
}
#end_block

#method_before
private boolean isOwner() {
    if (getUser().isIdentifiedUser()) {
        Account.Id id = getUser().asIdentifiedUser().getAccountId();
        return id.equals(getChange().getOwner());
    }
    return false;
}
#method_after
boolean isOwner() {
    if (getUser().isIdentifiedUser()) {
        Account.Id id = getUser().asIdentifiedUser().getAccountId();
        return id.equals(getChange().getOwner());
    }
    return false;
}
#end_block

#method_before
private boolean can(ChangePermission perm) throws PermissionBackendException {
    try {
        switch(perm) {
            case READ:
                return isVisible(db(), changeData());
            case ABANDON:
                return canAbandon(db());
            case DELETE:
                return canDelete(db(), getChange().getStatus());
            case ADD_PATCH_SET:
                return canAddPatchSet(db());
            case EDIT_ASSIGNEE:
                return canEditAssignee();
            case EDIT_DESCRIPTION:
                return canEditDescription();
            case EDIT_HASHTAGS:
                return canEditHashtags();
            case EDIT_TOPIC_NAME:
                return canEditTopicName();
            case REMOVE_REVIEWER:
                return canRemoveReviewer();
            case REBASE:
                return canRebase(db());
            case RESTORE:
                return canRestore(db());
            case SUBMIT:
                return getRefControl().canSubmit(isOwner());
            case SUBMIT_AS:
                return getRefControl().canPerform(perm.permissionName().get());
        }
    } catch (OrmException e) {
        throw new PermissionBackendException("unavailable", e);
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#method_after
private boolean can(ChangePermission perm) throws PermissionBackendException {
    try {
        switch(perm) {
            case READ:
                return isVisible(db(), changeData());
            case ABANDON:
                return canAbandon(db());
            case DELETE:
                return canDelete(db(), getChange().getStatus());
            case ADD_PATCH_SET:
                return canAddPatchSet(db());
            case EDIT_ASSIGNEE:
                return canEditAssignee();
            case EDIT_DESCRIPTION:
                return canEditDescription();
            case EDIT_HASHTAGS:
                return canEditHashtags();
            case EDIT_TOPIC_NAME:
                return canEditTopicName();
            case REBASE:
                return canRebase(db());
            case RESTORE:
                return canRestore(db());
            case SUBMIT:
                return getRefControl().canSubmit(isOwner());
            case REMOVE_REVIEWER:
            case SUBMIT_AS:
                return getRefControl().canPerform(perm.permissionName().get());
        }
    } catch (OrmException e) {
        throw new PermissionBackendException("unavailable", e);
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#end_block

#method_before
public Multimap<String, AccountState> byPreferredEmail(String... emails) throws OrmException {
    List<String> emailList = Arrays.asList(emails);
    List<List<AccountState>> r = query(emailList.stream().map(e -> AccountPredicates.preferredEmail(e)).collect(toList()));
    Multimap<String, AccountState> accountsByEmail = ArrayListMultimap.create();
    for (int i = 0; i < emailList.size(); i++) {
        String email = emailList.get(i);
        Set<AccountState> matchingAccounts = r.get(i).stream().filter(a -> a.getAccount().getPreferredEmail().equals(email)).collect(toSet());
        accountsByEmail.putAll(email, matchingAccounts);
    }
    return accountsByEmail;
}
#method_after
public List<AccountState> byPreferredEmail(String email) throws OrmException {
    return query(AccountPredicates.preferredEmail(email)).stream().filter(a -> a.getAccount().getPreferredEmail().equals(email)).collect(toList());
}
#end_block

#method_before
@Test
public void largeObjectTombstoneCanBeSerializedAndDeserialized() throws Exception {
    // Serialize
    byte[] serializedObject;
    try (ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream objectStream = new ObjectOutputStream(baos)) {
        objectStream.writeObject(new PatchListCacheImpl.LargeObjectTombstone());
        serializedObject = baos.toByteArray();
    }
    assertThat(serializedObject).isNotNull();
    // Deserialize
    PatchList recoveredTombstone;
    try (InputStream is = new ByteArrayInputStream(serializedObject);
        ObjectInputStream ois = new ObjectInputStream(is)) {
        recoveredTombstone = (PatchList) ois.readObject();
    }
    assertThat(recoveredTombstone).isInstanceOf(PatchListCacheImpl.LargeObjectTombstone.class);
}
#method_after
@Test
public void largeObjectTombstoneCanBeSerializedAndDeserialized() throws Exception {
    // Serialize
    byte[] serializedObject;
    try (ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream objectStream = new ObjectOutputStream(baos)) {
        objectStream.writeObject(new PatchListCacheImpl.LargeObjectTombstone());
        serializedObject = baos.toByteArray();
        assertThat(serializedObject).isNotNull();
    }
    // Deserialize
    try (InputStream is = new ByteArrayInputStream(serializedObject);
        ObjectInputStream ois = new ObjectInputStream(is)) {
        assertThat(ois.readObject()).isInstanceOf(PatchListCacheImpl.LargeObjectTombstone.class);
    }
}
#end_block

#method_before
@Test
public void byName() throws Exception {
    assertQuery("name:non-existing");
    GroupInfo group = createGroup(name("Group"));
    assertQuery("name:" + group.name, group);
    // only exact match
    GroupInfo groupWithHyphen = createGroup(name("group-with-hyphen"));
    createGroup(name("group-no-match-with-hyphen"));
    assertQuery("name:" + groupWithHyphen.name, groupWithHyphen);
}
#method_after
@Test
public void byName() throws Exception {
    assertQuery("name:non-existing");
    GroupInfo group = createGroup(name("Group"));
    assertQuery("name:" + group.name, group);
    assertQuery("name:" + group.name.toLowerCase(Locale.US));
    // only exact match
    GroupInfo groupWithHyphen = createGroup(name("group-with-hyphen"));
    createGroup(name("group-no-match-with-hyphen"));
    assertQuery("name:" + groupWithHyphen.name, groupWithHyphen);
}
#end_block

#method_before
public static Predicate<InternalGroup> uuid(AccountGroup.UUID uuid) {
    return new GroupPredicate(GroupField.UUID, GroupQueryBuilder.FIELD_UUID, uuid.get());
}
#method_after
public static Predicate<AccountGroup> uuid(AccountGroup.UUID uuid) {
    return new GroupPredicate(GroupField.UUID, GroupQueryBuilder.FIELD_UUID, uuid.get());
}
#end_block

#method_before
public static Predicate<InternalGroup> description(String description) {
    return new GroupPredicate(GroupField.DESCRIPTION, GroupQueryBuilder.FIELD_DESCRIPTION, description);
}
#method_after
public static Predicate<AccountGroup> description(String description) {
    return new GroupPredicate(GroupField.DESCRIPTION, GroupQueryBuilder.FIELD_DESCRIPTION, description);
}
#end_block

#method_before
public static Predicate<InternalGroup> inname(String name) {
    return new GroupPredicate(GroupField.NAME_PART, GroupQueryBuilder.FIELD_INNAME, name.toLowerCase(Locale.US));
}
#method_after
public static Predicate<AccountGroup> inname(String name) {
    return new GroupPredicate(GroupField.NAME_PART, GroupQueryBuilder.FIELD_INNAME, name.toLowerCase(Locale.US));
}
#end_block

#method_before
public static Predicate<InternalGroup> name(String name) {
    return new GroupPredicate(GroupField.NAME, GroupQueryBuilder.FIELD_NAME, name);
}
#method_after
public static Predicate<AccountGroup> name(String name) {
    return new GroupPredicate(GroupField.NAME, GroupQueryBuilder.FIELD_NAME, name);
}
#end_block

#method_before
public static Predicate<InternalGroup> owner(AccountGroup.UUID ownerUuid) {
    return new GroupPredicate(GroupField.OWNER_UUID, GroupQueryBuilder.FIELD_OWNER, ownerUuid.get());
}
#method_after
public static Predicate<AccountGroup> owner(AccountGroup.UUID ownerUuid) {
    return new GroupPredicate(GroupField.OWNER_UUID, GroupQueryBuilder.FIELD_OWNER, ownerUuid.get());
}
#end_block

#method_before
public static Predicate<InternalGroup> isVisibleToAll() {
    return new GroupPredicate(GroupField.IS_VISIBLE_TO_ALL, "1");
}
#method_after
public static Predicate<AccountGroup> isVisibleToAll() {
    return new GroupPredicate(GroupField.IS_VISIBLE_TO_ALL, "1");
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    readGroupList();
    groupsByName = mapGroupReferences();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    if (rc.getStringList(ACCESS, null, KEY_INHERIT_FROM).length > 1) {
        // The config must not contain more than one parent to inherit from
        // as there is no guarantee which of the parents would be used then.
        error(new ValidationError(PROJECT_CONFIG, "Cannot inherit from multiple projects"));
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, InheritableBoolean.INHERIT));
    p.setCreateNewChangeForAllNotInTarget(getEnum(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, InheritableBoolean.INHERIT));
    p.setEnableSignedPush(getEnum(rc, RECEIVE, null, KEY_ENABLE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setRequireSignedPush(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setRejectImplicitMerges(getEnum(rc, RECEIVE, null, KEY_REJECT_IMPLICIT_MERGES, InheritableBoolean.INHERIT));
    p.setPrivateByDefault(getEnum(rc, RECEIVE, null, KEY_PRIVATE_BY_DEFAULT, InheritableBoolean.INHERIT));
    p.setEnableReviewerByEmail(getEnum(rc, REVIEWER, null, KEY_ENABLE_REVIEWER_BY_EMAIL, InheritableBoolean.INHERIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, DEFAULT_SUBMIT_ACTION));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, InheritableBoolean.INHERIT));
    p.setMatchAuthorToCommitterDate(getEnum(rc, SUBMIT, null, KEY_MATCH_AUTHOR_DATE_WITH_COMMITTER_DATE, InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, DEFAULT_STATE_VALUE));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc);
    loadContributorAgreements(rc);
    loadAccessSections(rc);
    loadBranchOrderSection(rc);
    loadNotifySections(rc);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    loadSubscribeSections(rc);
    mimeTypes = new ConfiguredMimeTypes(projectName.get(), rc);
    loadPluginSections(rc);
    loadReceiveSection(rc);
    loadExtensionPanelSections(rc);
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    readGroupList();
    groupsByName = mapGroupReferences();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    if (rc.getStringList(ACCESS, null, KEY_INHERIT_FROM).length > 1) {
        // The config must not contain more than one parent to inherit from
        // as there is no guarantee which of the parents would be used then.
        error(new ValidationError(PROJECT_CONFIG, "Cannot inherit from multiple projects"));
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, InheritableBoolean.INHERIT));
    p.setCreateNewChangeForAllNotInTarget(getEnum(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, InheritableBoolean.INHERIT));
    p.setEnableSignedPush(getEnum(rc, RECEIVE, null, KEY_ENABLE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setRequireSignedPush(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setRejectImplicitMerges(getEnum(rc, RECEIVE, null, KEY_REJECT_IMPLICIT_MERGES, InheritableBoolean.INHERIT));
    p.setPrivateByDefault(getEnum(rc, CHANGE, null, KEY_PRIVATE_BY_DEFAULT, InheritableBoolean.INHERIT));
    p.setEnableReviewerByEmail(getEnum(rc, REVIEWER, null, KEY_ENABLE_REVIEWER_BY_EMAIL, InheritableBoolean.INHERIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, DEFAULT_SUBMIT_ACTION));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, InheritableBoolean.INHERIT));
    p.setMatchAuthorToCommitterDate(getEnum(rc, SUBMIT, null, KEY_MATCH_AUTHOR_DATE_WITH_COMMITTER_DATE, InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, DEFAULT_STATE_VALUE));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc);
    loadContributorAgreements(rc);
    loadAccessSections(rc);
    loadBranchOrderSection(rc);
    loadNotifySections(rc);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    loadSubscribeSections(rc);
    mimeTypes = new ConfiguredMimeTypes(projectName.get(), rc);
    loadPluginSections(rc);
    loadReceiveSection(rc);
    loadExtensionPanelSections(rc);
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.getUseContributorAgreements(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.getUseSignedOffBy(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.getRequireChangeID(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, p.getCreateNewChangeForAllNotInTarget(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, validMaxObjectSizeLimit(p.getMaxObjectSizeLimit()));
    set(rc, RECEIVE, null, KEY_ENABLE_SIGNED_PUSH, p.getEnableSignedPush(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_PUSH, p.getRequireSignedPush(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REJECT_IMPLICIT_MERGES, p.getRejectImplicitMerges(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_PRIVATE_BY_DEFAULT, p.getPrivateByDefault(), InheritableBoolean.INHERIT);
    set(rc, REVIEWER, null, KEY_ENABLE_REVIEWER_BY_EMAIL, p.getEnableReviewerByEmail(), InheritableBoolean.INHERIT);
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), DEFAULT_SUBMIT_ACTION);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.getUseContentMerge(), InheritableBoolean.INHERIT);
    set(rc, SUBMIT, null, KEY_MATCH_AUTHOR_DATE_WITH_COMMITTER_DATE, p.getMatchAuthorToCommitterDate(), InheritableBoolean.INHERIT);
    set(rc, PROJECT, null, KEY_STATE, p.getState(), DEFAULT_STATE_VALUE);
    set(rc, DASHBOARD, null, KEY_DEFAULT, p.getDefaultDashboard());
    set(rc, DASHBOARD, null, KEY_LOCAL_DEFAULT, p.getLocalDefaultDashboard());
    Set<AccountGroup.UUID> keepGroups = new HashSet<>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    savePluginSections(rc, keepGroups);
    groupList.retainUUIDs(keepGroups);
    saveLabelSections(rc);
    saveSubscribeSections(rc);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
    return true;
}
#method_after
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.getUseContributorAgreements(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.getUseSignedOffBy(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.getRequireChangeID(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, p.getCreateNewChangeForAllNotInTarget(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, validMaxObjectSizeLimit(p.getMaxObjectSizeLimit()));
    set(rc, RECEIVE, null, KEY_ENABLE_SIGNED_PUSH, p.getEnableSignedPush(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_PUSH, p.getRequireSignedPush(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REJECT_IMPLICIT_MERGES, p.getRejectImplicitMerges(), InheritableBoolean.INHERIT);
    set(rc, CHANGE, null, KEY_PRIVATE_BY_DEFAULT, p.getPrivateByDefault(), InheritableBoolean.INHERIT);
    set(rc, REVIEWER, null, KEY_ENABLE_REVIEWER_BY_EMAIL, p.getEnableReviewerByEmail(), InheritableBoolean.INHERIT);
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), DEFAULT_SUBMIT_ACTION);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.getUseContentMerge(), InheritableBoolean.INHERIT);
    set(rc, SUBMIT, null, KEY_MATCH_AUTHOR_DATE_WITH_COMMITTER_DATE, p.getMatchAuthorToCommitterDate(), InheritableBoolean.INHERIT);
    set(rc, PROJECT, null, KEY_STATE, p.getState(), DEFAULT_STATE_VALUE);
    set(rc, DASHBOARD, null, KEY_DEFAULT, p.getDefaultDashboard());
    set(rc, DASHBOARD, null, KEY_LOCAL_DEFAULT, p.getLocalDefaultDashboard());
    Set<AccountGroup.UUID> keepGroups = new HashSet<>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    savePluginSections(rc, keepGroups);
    groupList.retainUUIDs(keepGroups);
    saveLabelSections(rc);
    saveSubscribeSections(rc);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
    return true;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    Project p = (Project) obj;
    if (!name.equals(p.name)) {
        return false;
    }
    if (!path.equals(p.path)) {
        return false;
    }
    if (!remote.equals(p.remote)) {
        return false;
    }
    if (!remotebranch.equals(p.remotebranch)) {
        // check for master, empty means master
        if (!((remotebranch.equals("master") && p.remotebranch.equals("")) || (p.remotebranch.equals("master") && remotebranch.equals("")))) {
            return false;
        }
    }
    if (!revision.equals(p.revision)) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    Project p = (Project) obj;
    if (!name.equals(p.name)) {
        return false;
    }
    if (!path.equals(p.path)) {
        return false;
    }
    if (!remote.equals(p.remote)) {
        return false;
    }
    if (!remotebranch.equals(p.remotebranch)) {
        return false;
    }
    if (!revision.equals(p.revision)) {
        return false;
    }
    return true;
}
#end_block

#method_before
private void updateSubmodules(Repository repo, String targetRef, JiriProjects projects, GerritRemoteReader reader) throws Exception {
    DirCache index = DirCache.newInCore();
    DirCacheBuilder builder = index.builder();
    ObjectInserter inserter = repo.newObjectInserter();
    try (RevWalk rw = new RevWalk(repo)) {
        Config cfg = new Config();
        projects.sortByPath();
        String parent = null;
        for (Project proj : projects.getProjects()) {
            String path = proj.getPath();
            String nameUri = proj.getRemote();
            if (parent != null) {
                String p1 = StringUtil.stripAndaddCharsAtEnd(path, "/");
                String p2 = StringUtil.stripAndaddCharsAtEnd(parent, "/");
                if (p1.startsWith(p2)) {
                    warn("Skipping project %s(%s) as git doesn't support nested submodules", proj.getName(), path);
                    continue;
                }
            }
            ObjectId objectId;
            String ref = proj.getRef();
            if (ObjectId.isId(ref)) {
                objectId = ObjectId.fromString(ref);
            } else {
                if (ref.isEmpty()) {
                    ref = "master";
                }
                objectId = reader.sha1(nameUri, ref);
                if (objectId == null) {
                    // Run ls-remote
                    LsRemoteCommand ls = new LsRemoteCommand(repo);
                    ls.setRemote(nameUri);
                    Map<String, Ref> refs = ls.callAsMap();
                    if (refs.containsKey(REFS_HEADS + ref)) {
                        objectId = refs.get(REFS_HEADS + ref).getObjectId();
                    } else if (refs.containsKey(REFS_TAGS + ref)) {
                        objectId = refs.get(REFS_TAGS + ref).getObjectId();
                    } else {
                        warn("failed to get ref '%s' for '%s', skipping", ref, nameUri);
                        continue;
                    }
                }
            }
            // can be branch or tag
            cfg.setString("submodule", path, "branch", ref);
            if (proj.getHistorydepth() > 0) {
                // $NON-NLS-1$ //$NON-NLS-2$
                cfg.setBoolean("submodule", path, "shallow", true);
                if (proj.getHistorydepth() != 1) {
                    warn("Project %s(%s) has historydepth other than 1. Submodule only support shallow of depth 1.", proj.getName(), proj.getPath());
                }
            }
            URI submodUrl = URI.create(nameUri);
            // $NON-NLS-1$ //$NON-NLS-2$
            cfg.setString("submodule", path, "path", path);
            // $NON-NLS-1$ //$NON-NLS-2$
            cfg.setString("submodule", path, "url", submodUrl.toString());
            // create gitlink
            DirCacheEntry dcEntry = new DirCacheEntry(path);
            dcEntry.setObjectId(objectId);
            dcEntry.setFileMode(FileMode.GITLINK);
            builder.add(dcEntry);
            parent = path;
        }
        String content = cfg.toText();
        // create a new DirCacheEntry for .gitmodules file.
        final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);
        ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));
        dcEntry.setObjectId(objectId);
        dcEntry.setFileMode(FileMode.REGULAR_FILE);
        builder.add(dcEntry);
        builder.finish();
        ObjectId treeId = index.writeTree(inserter);
        // Create a Commit object, populate it and write it
        // $NON-NLS-1$
        ObjectId headId = repo.resolve(targetRef + "^{commit}");
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(treeId);
        if (headId != null)
            commit.setParentIds(headId);
        commit.setAuthor(serverIdent);
        commit.setCommitter(serverIdent);
        commit.setMessage(RepoText.get().repoCommitMessage);
        ObjectId commitId = inserter.insert(commit);
        inserter.flush();
        RefUpdate ru = repo.updateRef(targetRef);
        ru.setNewObjectId(commitId);
        ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());
        Result rc = ru.update(rw);
        switch(rc) {
            case NEW:
            case FORCED:
            case FAST_FORWARD:
                // Successful. Do nothing.
                break;
            case REJECTED:
            case LOCK_FAILURE:
                throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetRef), ru.getRef(), rc);
            default:
                throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetRef, commitId.name(), rc));
        }
        rw.parseCommit(commitId);
    }
}
#method_after
private void updateSubmodules(Repository repo, String targetRef, JiriProjects projects, GerritRemoteReader reader) throws Exception {
    DirCache index = DirCache.newInCore();
    DirCacheBuilder builder = index.builder();
    ObjectInserter inserter = repo.newObjectInserter();
    try (RevWalk rw = new RevWalk(repo)) {
        Config cfg = new Config();
        projects.sortByPath();
        String parent = null;
        for (JiriProjects.Project proj : projects.getProjects()) {
            String path = proj.getPath();
            String nameUri = proj.getRemote();
            if (parent != null) {
                String p1 = StringUtil.stripAndaddCharsAtEnd(path, "/");
                String p2 = StringUtil.stripAndaddCharsAtEnd(parent, "/");
                if (p1.startsWith(p2)) {
                    warn("Skipping project %s(%s) as git doesn't support nested submodules", proj.getName(), path);
                    continue;
                }
            }
            ObjectId objectId;
            String ref = proj.getRef();
            if (ObjectId.isId(ref)) {
                objectId = ObjectId.fromString(ref);
            } else {
                objectId = reader.sha1(nameUri, ref);
                if (objectId == null) {
                    warn("failed to get ref '%s' for '%s', skipping", ref, nameUri);
                    continue;
                }
            }
            // can be branch or tag
            cfg.setString("submodule", path, "branch", ref);
            if (proj.getHistorydepth() > 0) {
                cfg.setBoolean("submodule", path, "shallow", true);
                if (proj.getHistorydepth() != 1) {
                    warn("Project %s(%s) has historydepth other than 1. Submodule only support shallow of depth 1.", proj.getName(), proj.getPath());
                }
            }
            nameUri = URI.create(nameUri).toString();
            cfg.setString("submodule", path, "path", path);
            cfg.setString("submodule", path, "url", nameUri);
            // create gitlink
            DirCacheEntry dcEntry = new DirCacheEntry(path);
            dcEntry.setObjectId(objectId);
            dcEntry.setFileMode(FileMode.GITLINK);
            builder.add(dcEntry);
            parent = path;
        }
        String content = cfg.toText();
        // create a new DirCacheEntry for .gitmodules file.
        final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);
        ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));
        dcEntry.setObjectId(objectId);
        dcEntry.setFileMode(FileMode.REGULAR_FILE);
        builder.add(dcEntry);
        builder.finish();
        ObjectId treeId = index.writeTree(inserter);
        // Create a Commit object, populate it and write it
        ObjectId headId = repo.resolve(targetRef + "^{commit}");
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(treeId);
        if (headId != null)
            commit.setParentIds(headId);
        commit.setAuthor(serverIdent);
        commit.setCommitter(serverIdent);
        commit.setMessage(RepoText.get().repoCommitMessage);
        ObjectId commitId = inserter.insert(commit);
        inserter.flush();
        RefUpdate ru = repo.updateRef(targetRef);
        ru.setNewObjectId(commitId);
        ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());
        Result rc = ru.update(rw);
        switch(rc) {
            case NEW:
            case FORCED:
            case FAST_FORWARD:
                // Successful. Do nothing.
                break;
            case REJECTED:
            case LOCK_FAILURE:
                throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetRef), ru.getRef(), rc);
            default:
                throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetRef, commitId.name(), rc));
        }
    }
}
#end_block

#method_before
public static JiriProjects GetProjects(Repository repo, String ref, String manifest) throws Exception {
    Queue<String> q = new LinkedList<>();
    q.add(manifest);
    HashSet<String> processedFiles = new HashSet<>();
    HashMap<String, Project> projectMap = new HashMap<>();
    while (q.size() != 0) {
        String file = q.remove();
        if (processedFiles.contains(file)) {
            continue;
        }
        processedFiles.add(file);
        JiriManifest m = parseManifest(repo, ref, file);
        if (m.imports.getImports().length != 0) {
            throw new Exception(String.format("Manifest %s contains remote imports which are not supported", file));
        }
        for (Project project : m.projects.getProjects()) {
            if (projectMap.containsKey(project.Key())) {
                if (!projectMap.get(project.Key()).equals(project))
                    throw new Exception(String.format("Duplicate conflicting project %s in manifest %s\n%s\n%s", project.Key(), file, project.toString(), projectMap.get(project.Key()).toString()));
            } else {
                projectMap.put(project.Key(), project);
            }
        }
        URI parentURI = new URI(file);
        for (LocalImport l : m.imports.getLocalImports()) {
            q.add(parentURI.resolve(l.getFile()).getPath());
        }
    }
    return new JiriProjects(projectMap.values().toArray(new Project[0]));
}
#method_after
public static JiriProjects GetProjects(Repository repo, String ref, String manifest) throws Exception {
    Queue<String> q = new LinkedList<>();
    q.add(manifest);
    HashSet<String> processedFiles = new HashSet<>();
    HashMap<String, JiriProjects.Project> projectMap = new HashMap<>();
    while (q.size() != 0) {
        String file = q.remove();
        if (processedFiles.contains(file)) {
            continue;
        }
        processedFiles.add(file);
        JiriManifest m = parseManifest(repo, ref, file);
        if (m.imports.getImports().length != 0) {
            throw new Exception(String.format("Manifest %s contains remote imports which are not supported", file));
        }
        for (JiriProjects.Project project : m.projects.getProjects()) {
            project.fillDefault();
            if (projectMap.containsKey(project.Key())) {
                if (!projectMap.get(project.Key()).equals(project))
                    throw new Exception(String.format("Duplicate conflicting project %s in manifest %s\n%s\n%s", project.Key(), file, project.toString(), projectMap.get(project.Key()).toString()));
            } else {
                projectMap.put(project.Key(), project);
            }
        }
        URI parentURI = new URI(file);
        for (JiriManifest.LocalImport l : m.imports.getLocalImports()) {
            q.add(parentURI.resolve(l.getFile()).getPath());
        }
    }
    return new JiriProjects(projectMap.values().toArray(new JiriProjects.Project[0]));
}
#end_block

#method_before
@Override
public String toString() {
    return String.format("%s -> %s => %s", toolType, src(), dest());
}
#method_after
@Override
public String toString() {
    return String.format("%s (%s) => %s", src(), toolType, dest());
}
#end_block

#method_before
private void showDoc(HttpServletRequest req, HttpServletResponse res, GitilesView view, MarkdownConfig cfg, MarkdownToHtml.Builder fmt, MarkdownFile navFile, MarkdownFile srcFile) throws IOException {
    Map<String, Object> data = new HashMap<>();
    data.putAll(buildNavbar(cfg, fmt, navFile));
    Node doc = GitilesMarkdown.parse(cfg, srcFile.consumeContent());
    data.put("breadcrumbs", null);
    data.put("pageTitle", pageTitle(doc, srcFile));
    if (view.getType() != GitilesView.Type.ROOTED_DOC) {
        data.put("sourceUrl", GitilesView.show().copyFrom(view).toUrl());
        data.put("logUrl", GitilesView.log().copyFrom(view).toUrl());
        data.put("blameUrl", GitilesView.blame().copyFrom(view).toUrl());
    }
    if (cfg.analyticsId != null) {
        data.put("analyticsId", cfg.analyticsId);
    }
    try (OutputStream out = startRenderCompressedStreamingHtml(req, res, SOY_TEMPLATE, data)) {
        Writer w = newWriter(out, res);
        fmt.setFilePath(srcFile.path).build().renderToHtml(new StreamHtmlBuilder(w), doc);
        w.flush();
    } catch (RuntimeIOException e) {
        Throwables.throwIfInstanceOf(e.getCause(), IOException.class);
        throw e;
    }
}
#method_after
private void showDoc(HttpServletRequest req, HttpServletResponse res, GitilesView view, MarkdownConfig cfg, MarkdownToHtml.Builder fmt, MarkdownFile navFile, MarkdownFile srcFile) throws IOException {
    Map<String, Object> data = new HashMap<>();
    data.putAll(buildNavbar(cfg, fmt, navFile));
    Node doc = GitilesMarkdown.parse(cfg, srcFile.consumeContent());
    data.put("pageTitle", pageTitle(doc, srcFile));
    if (view.getType() != GitilesView.Type.ROOTED_DOC) {
        data.put("sourceUrl", GitilesView.show().copyFrom(view).toUrl());
        data.put("logUrl", GitilesView.log().copyFrom(view).toUrl());
        data.put("blameUrl", GitilesView.blame().copyFrom(view).toUrl());
    }
    if (cfg.analyticsId != null) {
        data.put("analyticsId", cfg.analyticsId);
    }
    try (OutputStream out = startRenderCompressedStreamingHtml(req, res, SOY_TEMPLATE, data)) {
        Writer w = newWriter(out, res);
        fmt.setFilePath(srcFile.path).build().renderToHtml(new StreamHtmlBuilder(w), doc);
        w.flush();
    } catch (RuntimeIOException e) {
        Throwables.throwIfInstanceOf(e.getCause(), IOException.class);
        throw e;
    }
}
#end_block

#method_before
private void showDoc(HttpServletRequest req, HttpServletResponse res, GitilesView view, MarkdownConfig cfg, MarkdownToHtml.Builder fmt, MarkdownFile navFile, MarkdownFile srcFile) throws IOException {
    Map<String, Object> data = new HashMap<>();
    data.putAll(buildNavbar(fmt, navFile));
    Node doc = GitilesMarkdown.parse(srcFile.consumeContent());
    data.put("breadcrumbs", null);
    data.put("pageTitle", pageTitle(doc, srcFile));
    if (view.getType() != GitilesView.Type.ROOTED_DOC) {
        data.put("sourceUrl", GitilesView.show().copyFrom(view).toUrl());
        data.put("logUrl", GitilesView.log().copyFrom(view).toUrl());
        data.put("blameUrl", GitilesView.blame().copyFrom(view).toUrl());
    }
    if (cfg.analyticsId != null) {
        data.put("analyticsId", cfg.analyticsId);
    }
    try (OutputStream out = startRenderCompressedStreamingHtml(req, res, SOY_TEMPLATE, data)) {
        Writer w = newWriter(out, res);
        fmt.setFilePath(srcFile.path).build().renderToHtml(new StreamHtmlBuilder(w), doc);
        w.flush();
    } catch (RuntimeIOException e) {
        Throwables.throwIfInstanceOf(e.getCause(), IOException.class);
        throw e;
    }
}
#method_after
private void showDoc(HttpServletRequest req, HttpServletResponse res, GitilesView view, MarkdownConfig cfg, MarkdownToHtml.Builder fmt, MarkdownFile navFile, MarkdownFile srcFile) throws IOException {
    Map<String, Object> data = new HashMap<>();
    data.putAll(buildNavbar(fmt, navFile));
    Node doc = GitilesMarkdown.parse(srcFile.consumeContent());
    data.put("pageTitle", pageTitle(doc, srcFile));
    if (view.getType() != GitilesView.Type.ROOTED_DOC) {
        data.put("sourceUrl", GitilesView.show().copyFrom(view).toUrl());
        data.put("logUrl", GitilesView.log().copyFrom(view).toUrl());
        data.put("blameUrl", GitilesView.blame().copyFrom(view).toUrl());
    }
    if (cfg.analyticsId != null) {
        data.put("analyticsId", cfg.analyticsId);
    }
    try (OutputStream out = startRenderCompressedStreamingHtml(req, res, SOY_TEMPLATE, data)) {
        Writer w = newWriter(out, res);
        fmt.setFilePath(srcFile.path).build().renderToHtml(new StreamHtmlBuilder(w), doc);
        w.flush();
    } catch (RuntimeIOException e) {
        Throwables.throwIfInstanceOf(e.getCause(), IOException.class);
        throw e;
    }
}
#end_block

#method_before
@Override
public /**
 * Return an empty list so that {@link PatchListWeigher} rely on {@code patches} being set in
 * {@link PatchList}
 */
List<PatchListEntry> getPatches() {
    return ImmutableList.of();
}
#method_after
@Override
public List<PatchListEntry> getPatches() {
    return ImmutableList.of();
}
#end_block

#method_before
private PatchList readPatchList(Repository repo, RevWalk rw, ObjectInserter ins) throws IOException, PatchListNotAvailableException {
    ObjectReader reader = rw.getObjectReader();
    checkArgument(reader.getCreatedFromInserter() == ins);
    RawTextComparator cmp = comparatorFor(key.getWhitespace());
    try (DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE)) {
        RevCommit b = rw.parseCommit(key.getNewId());
        RevObject a = aFor(key, repo, rw, ins, b);
        if (a == null) {
            // TODO(sop) Remove this case.
            // This is an octopus merge commit which should be compared against the
            // auto-merge. However since we don't support computing the auto-merge
            // for octopus merge commits, we fall back to diffing against the first
            // parent, even though this wasn't what was requested.
            // 
            ComparisonType comparisonType = ComparisonType.againstParent(1);
            PatchListEntry[] entries = new PatchListEntry[2];
            entries[0] = newCommitMessage(cmp, reader, null, b);
            entries[1] = newMergeList(cmp, reader, null, b, comparisonType);
            return new PatchList(a, b, true, comparisonType, entries);
        }
        ComparisonType comparisonType = getComparisonType(a, b);
        RevCommit aCommit = a instanceof RevCommit ? (RevCommit) a : null;
        RevTree aTree = rw.parseTree(a);
        RevTree bTree = b.getTree();
        df.setReader(reader, repo.getConfig());
        df.setDiffComparator(cmp);
        df.setDetectRenames(true);
        List<DiffEntry> diffEntries = new ArrayList<>(df.scan(aTree, bTree));
        List<PatchListEntry> entries = new ArrayList<>();
        entries.add(newCommitMessage(cmp, reader, comparisonType.isAgainstParentOrAutoMerge() ? null : aCommit, b));
        boolean isMerge = b.getParentCount() > 1;
        if (isMerge) {
            entries.add(newMergeList(cmp, reader, comparisonType.isAgainstParentOrAutoMerge() ? null : aCommit, b, comparisonType));
        }
        Multimap<String, ContextAwareEdit> editsDueToRebasePerFilePath = key.getAlgorithm() == PatchListKey.Algorithm.OPTIMIZED_DIFF ? getEditsDueToRebasePerFilePath(aCommit, b, diffEntries, df) : ImmutableMultimap.of();
        for (DiffEntry diffEntry : diffEntries) {
            Set<ContextAwareEdit> editsDueToRebase = getEditsDueToRebase(editsDueToRebasePerFilePath, diffEntry);
            Optional<PatchListEntry> patchListEntry = getPatchListEntry(reader, df, diffEntry, aTree, bTree, editsDueToRebase);
            patchListEntry.ifPresent(entries::add);
        }
        return new PatchList(a, b, isMerge, comparisonType, entries.toArray(new PatchListEntry[entries.size()]));
    }
}
#method_after
private PatchList readPatchList(Repository repo, RevWalk rw, ObjectInserter ins) throws IOException, PatchListNotAvailableException {
    ObjectReader reader = rw.getObjectReader();
    checkArgument(reader.getCreatedFromInserter() == ins);
    RawTextComparator cmp = comparatorFor(key.getWhitespace());
    try (DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE)) {
        RevCommit b = rw.parseCommit(key.getNewId());
        RevObject a = aFor(key, repo, rw, ins, b);
        if (a == null) {
            // TODO(sop) Remove this case.
            // This is an octopus merge commit which should be compared against the
            // auto-merge. However since we don't support computing the auto-merge
            // for octopus merge commits, we fall back to diffing against the first
            // parent, even though this wasn't what was requested.
            // 
            ComparisonType comparisonType = ComparisonType.againstParent(1);
            PatchListEntry[] entries = new PatchListEntry[2];
            entries[0] = newCommitMessage(cmp, reader, null, b);
            entries[1] = newMergeList(cmp, reader, null, b, comparisonType);
            return new PatchList(a, b, true, comparisonType, entries);
        }
        ComparisonType comparisonType = getComparisonType(a, b);
        RevCommit aCommit = a instanceof RevCommit ? (RevCommit) a : null;
        RevTree aTree = rw.parseTree(a);
        RevTree bTree = b.getTree();
        df.setReader(reader, repo.getConfig());
        df.setDiffComparator(cmp);
        df.setDetectRenames(true);
        List<DiffEntry> diffEntries = df.scan(aTree, bTree);
        Multimap<String, ContextAwareEdit> editsDueToRebasePerFilePath = ImmutableMultimap.of();
        if (key.getAlgorithm() == PatchListKey.Algorithm.OPTIMIZED_DIFF) {
            EditsDueToRebaseResult editsDueToRebaseResult = determineEditsDueToRebase(aCommit, b, diffEntries, df, rw);
            diffEntries = editsDueToRebaseResult.getRelevantOriginalDiffEntries();
            editsDueToRebasePerFilePath = editsDueToRebaseResult.getEditsDueToRebasePerFilePath();
        }
        List<PatchListEntry> entries = new ArrayList<>();
        entries.add(newCommitMessage(cmp, reader, comparisonType.isAgainstParentOrAutoMerge() ? null : aCommit, b));
        boolean isMerge = b.getParentCount() > 1;
        if (isMerge) {
            entries.add(newMergeList(cmp, reader, comparisonType.isAgainstParentOrAutoMerge() ? null : aCommit, b, comparisonType));
        }
        for (DiffEntry diffEntry : diffEntries) {
            Set<ContextAwareEdit> editsDueToRebase = getEditsDueToRebase(editsDueToRebasePerFilePath, diffEntry);
            Optional<PatchListEntry> patchListEntry = getPatchListEntry(reader, df, diffEntry, aTree, bTree, editsDueToRebase);
            patchListEntry.ifPresent(entries::add);
        }
        return new PatchList(a, b, isMerge, comparisonType, entries.toArray(new PatchListEntry[entries.size()]));
    }
}
#end_block

#method_before
private static Stream<String> getTouchedFilePaths(PatchListEntry patchListEntry) {
    String oldFilePath = patchListEntry.getOldName();
    String newFilePath = patchListEntry.getNewName();
    return oldFilePath == null ? Stream.of(newFilePath) : Stream.of(oldFilePath, newFilePath);
}
#method_after
private static Set<String> getTouchedFilePaths(PatchListEntry patchListEntry) {
    String oldFilePath = patchListEntry.getOldName();
    String newFilePath = patchListEntry.getNewName();
    return oldFilePath == null ? ImmutableSet.of(newFilePath) : ImmutableSet.of(oldFilePath, newFilePath);
}
#end_block

#method_before
private List<PatchListEntry> getRelevantPatchListEntries(List<DiffEntry> parentDiffEntries, RevCommit parentCommitA, RevCommit parentCommitB, ImmutableSet<String> touchedFilePaths, DiffFormatter diffFormatter) throws IOException {
    List<PatchListEntry> parentPatchListEntries = new ArrayList<>(parentDiffEntries.size());
    for (DiffEntry parentDiffEntry : parentDiffEntries) {
        if (!isTouched(touchedFilePaths, parentDiffEntry)) {
            continue;
        }
        FileHeader fileHeader = toFileHeader(parentCommitB, diffFormatter, parentDiffEntry);
        PatchListEntry patchListEntry = newEntry(parentCommitA.getTree(), fileHeader, ImmutableSet.of(), 0, 0);
        parentPatchListEntries.add(patchListEntry);
    }
    return parentPatchListEntries;
}
#method_after
private List<PatchListEntry> getRelevantPatchListEntries(List<DiffEntry> parentDiffEntries, RevCommit parentCommitA, RevCommit parentCommitB, Set<String> touchedFilePaths, DiffFormatter diffFormatter) throws IOException {
    List<PatchListEntry> parentPatchListEntries = new ArrayList<>(parentDiffEntries.size());
    for (DiffEntry parentDiffEntry : parentDiffEntries) {
        if (!isTouched(touchedFilePaths, parentDiffEntry)) {
            continue;
        }
        FileHeader fileHeader = toFileHeader(parentCommitB, diffFormatter, parentDiffEntry);
        // The code which uses this PatchListEntry doesn't care about the last three parameters. As
        // they are expensive to compute, we use arbitrary values for them.
        PatchListEntry patchListEntry = newEntry(parentCommitA.getTree(), fileHeader, ImmutableSet.of(), 0, 0);
        parentPatchListEntries.add(patchListEntry);
    }
    return parentPatchListEntries;
}
#end_block

#method_before
private List<QueryResult<T>> query(List<String> queryStrings, List<Predicate<T>> queries) throws OrmException, QueryParseException {
    checkState(!isDisabled(), "%s is disabled", getClass().getSimpleName());
    long startNanos = System.nanoTime();
    int cnt = queries.size();
    // Parse and rewrite all queries.
    List<Integer> limits = new ArrayList<>(cnt);
    List<Predicate<T>> predicates = new ArrayList<>(cnt);
    List<DataSource<T>> sources = new ArrayList<>(cnt);
    for (Predicate<T> q : queries) {
        int limit = getEffectiveLimit(q);
        limits.add(limit);
        if (limit == getBackendSupportedLimit()) {
            limit--;
        }
        int page = (start / limit) + 1;
        if (page > indexConfig.maxPages()) {
            throw new QueryParseException("Cannot go beyond page " + indexConfig.maxPages() + " of results");
        }
        // Always bump limit by 1, even if this results in exceeding the permitted
        // max for this user. The only way to see if there are more entities is to
        // ask for one more result from the query.
        QueryOptions opts = createOptions(indexConfig, start, limit + 1, getRequestedFields());
        Predicate<T> pred = rewriter.rewrite(q, opts);
        if (enforceVisibility) {
            pred = enforceVisibility(pred);
        }
        predicates.add(pred);
        @SuppressWarnings("unchecked")
        DataSource<T> s = (DataSource<T>) pred;
        sources.add(s);
    }
    // Run each query asynchronously, if supported.
    List<ResultSet<T>> matches = new ArrayList<>(cnt);
    for (DataSource<T> s : sources) {
        matches.add(s.read());
    }
    List<QueryResult<T>> out = new ArrayList<>(cnt);
    for (int i = 0; i < cnt; i++) {
        out.add(QueryResult.create(queryStrings != null ? queryStrings.get(i) : null, predicates.get(i), limits.get(i), matches.get(i).toList()));
    }
    // only measure successful queries
    metrics.executionTime.record(schemaDef.getName(), System.nanoTime() - startNanos, TimeUnit.NANOSECONDS);
    return out;
}
#method_after
private List<QueryResult<T>> query(@Nullable List<String> queryStrings, List<Predicate<T>> queries) throws OrmException, QueryParseException {
    long startNanos = System.nanoTime();
    checkState(!used.getAndSet(true), "%s has already been used", getClass().getSimpleName());
    int cnt = queries.size();
    if (queryStrings != null) {
        int qs = queryStrings.size();
        checkArgument(qs == cnt, "got %s query strings but %s predicates", qs, cnt);
    }
    if (cnt == 0) {
        return ImmutableList.of();
    }
    if (isDisabled()) {
        return disabledResults(queryStrings, queries);
    }
    // Parse and rewrite all queries.
    List<Integer> limits = new ArrayList<>(cnt);
    List<Predicate<T>> predicates = new ArrayList<>(cnt);
    List<DataSource<T>> sources = new ArrayList<>(cnt);
    for (Predicate<T> q : queries) {
        int limit = getEffectiveLimit(q);
        limits.add(limit);
        if (limit == getBackendSupportedLimit()) {
            limit--;
        }
        int page = (start / limit) + 1;
        if (page > indexConfig.maxPages()) {
            throw new QueryParseException("Cannot go beyond page " + indexConfig.maxPages() + " of results");
        }
        // Always bump limit by 1, even if this results in exceeding the permitted
        // max for this user. The only way to see if there are more entities is to
        // ask for one more result from the query.
        QueryOptions opts = createOptions(indexConfig, start, limit + 1, getRequestedFields());
        Predicate<T> pred = rewriter.rewrite(q, opts);
        if (enforceVisibility) {
            pred = enforceVisibility(pred);
        }
        predicates.add(pred);
        @SuppressWarnings("unchecked")
        DataSource<T> s = (DataSource<T>) pred;
        sources.add(s);
    }
    // Run each query asynchronously, if supported.
    List<ResultSet<T>> matches = new ArrayList<>(cnt);
    for (DataSource<T> s : sources) {
        matches.add(s.read());
    }
    List<QueryResult<T>> out = new ArrayList<>(cnt);
    for (int i = 0; i < cnt; i++) {
        out.add(QueryResult.create(queryStrings != null ? queryStrings.get(i) : null, predicates.get(i), limits.get(i), matches.get(i).toList()));
    }
    // Only measure successful queries that actually touched the index.
    metrics.executionTime.record(schemaDef.getName(), System.nanoTime() - startNanos, TimeUnit.NANOSECONDS);
    return out;
}
#end_block

#method_before
public boolean isDisabled() {
    return enforceVisibility && permittedLimit <= 0;
}
#method_after
public boolean isDisabled() {
    return enforceVisibility && getPermittedLimit() <= 0;
}
#end_block

#method_before
private int getEffectiveLimit(Predicate<T> p) {
    List<Integer> possibleLimits = new ArrayList<>(4);
    possibleLimits.add(getBackendSupportedLimit());
    checkState(permittedLimit > 0, "user limit should have been positive");
    possibleLimits.add(permittedLimit);
    if (userProvidedLimit > 0) {
        possibleLimits.add(userProvidedLimit);
    }
    if (limitField != null) {
        Integer limitFromPredicate = LimitPredicate.getLimit(limitField, p);
        if (limitFromPredicate != null) {
            possibleLimits.add(limitFromPredicate);
        }
    }
    return Ordering.natural().min(possibleLimits);
}
#method_after
private int getEffectiveLimit(Predicate<T> p) {
    List<Integer> possibleLimits = new ArrayList<>(4);
    possibleLimits.add(getBackendSupportedLimit());
    possibleLimits.add(getPermittedLimit());
    if (userProvidedLimit > 0) {
        possibleLimits.add(userProvidedLimit);
    }
    if (limitField != null) {
        Integer limitFromPredicate = LimitPredicate.getLimit(limitField, p);
        if (limitFromPredicate != null) {
            possibleLimits.add(limitFromPredicate);
        }
    }
    int result = Ordering.natural().min(possibleLimits);
    // Should have short-circuited from #query or thrown some other exception before getting here.
    checkState(result > 0, "effective limit should be positive");
    return result;
}
#end_block

#method_before
private List<Account.Id> suggestAccounts(SuggestReviewers suggestReviewers) throws OrmException {
    try (Timer0.Context ctx = metrics.queryAccountsLatency.start()) {
        try {
            QueryResult<AccountState> result = accountQueryProcessor.setUserProvidedLimit(suggestReviewers.getLimit() * CANDIDATE_LIST_MULTIPLIER).query(AccountPredicates.andActive(accountQueryBuilder.defaultQuery(suggestReviewers.getQuery())));
            return result.entities().stream().map(a -> a.getAccount().getId()).collect(toList());
        } catch (QueryParseException e) {
            return ImmutableList.of();
        }
    }
}
#method_after
private List<Account.Id> suggestAccounts(SuggestReviewers suggestReviewers) throws OrmException {
    try (Timer0.Context ctx = metrics.queryAccountsLatency.start()) {
        try {
            QueryResult<AccountState> result = queryProvider.get().setUserProvidedLimit(suggestReviewers.getLimit() * CANDIDATE_LIST_MULTIPLIER).query(AccountPredicates.andActive(accountQueryBuilder.defaultQuery(suggestReviewers.getQuery())));
            return result.entities().stream().map(a -> a.getAccount().getId()).collect(toList());
        } catch (QueryParseException e) {
            return ImmutableList.of();
        }
    }
}
#end_block

#method_before
private List<QueryResult<T>> query(List<String> queryStrings, List<Predicate<T>> queries) throws OrmException, QueryParseException {
    checkState(!isDisabled(), "%s is disabled", getClass().getSimpleName());
    checkState(!used.getAndSet(true), "%s has already been used", getClass().getSimpleName());
    long startNanos = System.nanoTime();
    int cnt = queries.size();
    // Parse and rewrite all queries.
    List<Integer> limits = new ArrayList<>(cnt);
    List<Predicate<T>> predicates = new ArrayList<>(cnt);
    List<DataSource<T>> sources = new ArrayList<>(cnt);
    for (Predicate<T> q : queries) {
        int limit = getEffectiveLimit(q);
        limits.add(limit);
        if (limit == getBackendSupportedLimit()) {
            limit--;
        }
        int page = (start / limit) + 1;
        if (page > indexConfig.maxPages()) {
            throw new QueryParseException("Cannot go beyond page " + indexConfig.maxPages() + " of results");
        }
        // Always bump limit by 1, even if this results in exceeding the permitted
        // max for this user. The only way to see if there are more entities is to
        // ask for one more result from the query.
        QueryOptions opts = createOptions(indexConfig, start, limit + 1, getRequestedFields());
        Predicate<T> pred = rewriter.rewrite(q, opts);
        if (enforceVisibility) {
            pred = enforceVisibility(pred);
        }
        predicates.add(pred);
        @SuppressWarnings("unchecked")
        DataSource<T> s = (DataSource<T>) pred;
        sources.add(s);
    }
    // Run each query asynchronously, if supported.
    List<ResultSet<T>> matches = new ArrayList<>(cnt);
    for (DataSource<T> s : sources) {
        matches.add(s.read());
    }
    List<QueryResult<T>> out = new ArrayList<>(cnt);
    for (int i = 0; i < cnt; i++) {
        out.add(QueryResult.create(queryStrings != null ? queryStrings.get(i) : null, predicates.get(i), limits.get(i), matches.get(i).toList()));
    }
    // only measure successful queries
    metrics.executionTime.record(schemaDef.getName(), System.nanoTime() - startNanos, TimeUnit.NANOSECONDS);
    return out;
}
#method_after
private List<QueryResult<T>> query(@Nullable List<String> queryStrings, List<Predicate<T>> queries) throws OrmException, QueryParseException {
    long startNanos = System.nanoTime();
    checkState(!used.getAndSet(true), "%s has already been used", getClass().getSimpleName());
    int cnt = queries.size();
    if (queryStrings != null) {
        int qs = queryStrings.size();
        checkArgument(qs == cnt, "got %s query strings but %s predicates", qs, cnt);
    }
    if (cnt == 0) {
        return ImmutableList.of();
    }
    if (isDisabled()) {
        return disabledResults(queryStrings, queries);
    }
    // Parse and rewrite all queries.
    List<Integer> limits = new ArrayList<>(cnt);
    List<Predicate<T>> predicates = new ArrayList<>(cnt);
    List<DataSource<T>> sources = new ArrayList<>(cnt);
    for (Predicate<T> q : queries) {
        int limit = getEffectiveLimit(q);
        limits.add(limit);
        if (limit == getBackendSupportedLimit()) {
            limit--;
        }
        int page = (start / limit) + 1;
        if (page > indexConfig.maxPages()) {
            throw new QueryParseException("Cannot go beyond page " + indexConfig.maxPages() + " of results");
        }
        // Always bump limit by 1, even if this results in exceeding the permitted
        // max for this user. The only way to see if there are more entities is to
        // ask for one more result from the query.
        QueryOptions opts = createOptions(indexConfig, start, limit + 1, getRequestedFields());
        Predicate<T> pred = rewriter.rewrite(q, opts);
        if (enforceVisibility) {
            pred = enforceVisibility(pred);
        }
        predicates.add(pred);
        @SuppressWarnings("unchecked")
        DataSource<T> s = (DataSource<T>) pred;
        sources.add(s);
    }
    // Run each query asynchronously, if supported.
    List<ResultSet<T>> matches = new ArrayList<>(cnt);
    for (DataSource<T> s : sources) {
        matches.add(s.read());
    }
    List<QueryResult<T>> out = new ArrayList<>(cnt);
    for (int i = 0; i < cnt; i++) {
        out.add(QueryResult.create(queryStrings != null ? queryStrings.get(i) : null, predicates.get(i), limits.get(i), matches.get(i).toList()));
    }
    // Only measure successful queries that actually touched the index.
    metrics.executionTime.record(schemaDef.getName(), System.nanoTime() - startNanos, TimeUnit.NANOSECONDS);
    return out;
}
#end_block

#method_before
public boolean isDisabled() {
    return enforceVisibility && permittedLimit <= 0;
}
#method_after
public boolean isDisabled() {
    return enforceVisibility && getPermittedLimit() <= 0;
}
#end_block

#method_before
private int getEffectiveLimit(Predicate<T> p) {
    List<Integer> possibleLimits = new ArrayList<>(4);
    possibleLimits.add(getBackendSupportedLimit());
    checkState(permittedLimit > 0, "user limit should have been positive");
    possibleLimits.add(permittedLimit);
    if (userProvidedLimit > 0) {
        possibleLimits.add(userProvidedLimit);
    }
    if (limitField != null) {
        Integer limitFromPredicate = LimitPredicate.getLimit(limitField, p);
        if (limitFromPredicate != null) {
            possibleLimits.add(limitFromPredicate);
        }
    }
    return Ordering.natural().min(possibleLimits);
}
#method_after
private int getEffectiveLimit(Predicate<T> p) {
    List<Integer> possibleLimits = new ArrayList<>(4);
    possibleLimits.add(getBackendSupportedLimit());
    possibleLimits.add(getPermittedLimit());
    if (userProvidedLimit > 0) {
        possibleLimits.add(userProvidedLimit);
    }
    if (limitField != null) {
        Integer limitFromPredicate = LimitPredicate.getLimit(limitField, p);
        if (limitFromPredicate != null) {
            possibleLimits.add(limitFromPredicate);
        }
    }
    int result = Ordering.natural().min(possibleLimits);
    // Should have short-circuited from #query or thrown some other exception before getting here.
    checkState(result > 0, "effective limit should be positive");
    return result;
}
#end_block

#method_before
public Multimap<String, AccountState> byPreferredEmail(String... emails) throws OrmException {
    List<String> emailList = Arrays.asList(emails);
    List<List<AccountState>> r = query(emailList.stream().map(e -> AccountPredicates.preferredEmail(e)).collect(toList()));
    Multimap<String, AccountState> accountsByEmail = ArrayListMultimap.create();
    for (int i = 0; i < emailList.size(); i++) {
        accountsByEmail.putAll(emailList.get(i), r.get(i));
    }
    return accountsByEmail;
}
#method_after
public List<AccountState> byPreferredEmail(String email) throws OrmException {
    return query(AccountPredicates.preferredEmail(email));
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    PersonIdent author = receiveEvent.commit.getAuthorIdent();
    if (receiveEvent.commit.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress())) {
        try {
            perm.check(RefPermission.FORGE_SERVER);
        } catch (AuthException denied) {
            throw new CommitValidationException(String.format("amending merges from others requires '%s' permission", RefPermission.FORGE_SERVER.name()));
        } catch (PermissionBackendException e) {
            log.error("cannot check FORGE_SERVER", e);
            throw new CommitValidationException("internal auth error");
        }
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    PersonIdent author = receiveEvent.commit.getAuthorIdent();
    if (receiveEvent.commit.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress())) {
        try {
            // Stop authors from amending the merge commits that Gerrit itself creates.
            perm.check(RefPermission.FORGE_SERVER);
        } catch (AuthException denied) {
            throw new CommitValidationException(String.format("pushing merge commit %s by %s requires '%s' permission", receiveEvent.commit.getId(), gerritIdent.getEmailAddress(), RefPermission.FORGE_SERVER.name()));
        } catch (PermissionBackendException e) {
            log.error("cannot check FORGE_SERVER", e);
            throw new CommitValidationException("internal auth error");
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
protected Response<ChangeInfo> applyImpl(BatchUpdate.Factory updateFactory, TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException, PermissionBackendException, ConfigInvalidException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("draft workflow is disabled");
        }
    }
    ProjectResource rsrc = projectsCollection.parse(input.project);
    checkValidCLA(rsrc.getControl());
    Project.NameKey project = rsrc.getNameKey();
    String refName = RefNames.fullName(input.branch);
    permissionBackend.user(user).project(project).ref(refName).check(RefPermission.CREATE_CHANGE);
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        ObjectId parentCommit;
        List<String> groups;
        if (input.baseChange != null) {
            List<ChangeControl> ctls = changeFinder.find(input.baseChange, rsrc.getControl().getUser());
            if (ctls.size() != 1) {
                throw new UnprocessableEntityException("Base change not found: " + input.baseChange);
            }
            ChangeControl ctl = Iterables.getOnlyElement(ctls);
            if (!ctl.isVisible(db.get())) {
                throw new UnprocessableEntityException("Base change not found: " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), ctl.getNotes());
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else {
            Ref destRef = git.getRefDatabase().exactRef(refName);
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", refName));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        AccountState account = accountCache.get(me.getAccountId());
        GeneralPreferencesInfo info = account.getAccount().getGeneralPreferencesInfo();
        ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
        ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, input.subject);
        String commitMessage = ChangeIdUtil.insertId(input.subject, id);
        if (Boolean.TRUE.equals(info.signedOffBy)) {
            commitMessage += String.format("%s%s", SIGNED_OFF_BY_TAG, account.getAccount().getNameEmail(anonymousCowardName));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            if (!(submitType.equals(SubmitType.MERGE_ALWAYS) || submitType.equals(SubmitType.MERGE_IF_NECESSARY))) {
                throw new BadRequestException("Submit type: " + submitType + " is not supported");
            }
            c = newMergeCommit(git, oi, rw, rsrc.getControl(), mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, refName);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        String topic = input.topic;
        if (topic != null) {
            topic = Strings.emptyToNull(topic.trim());
        }
        ins.setTopic(topic);
        ins.setDraft(input.status == ChangeStatus.DRAFT);
        ins.setPrivate(privateByDefault || (input.isPrivate != null && input.isPrivate));
        ins.setWorkInProgress(input.workInProgress != null && input.workInProgress);
        ins.setGroups(groups);
        ins.setNotify(input.notify);
        ins.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
        try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.noOptions();
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#method_after
@Override
protected Response<ChangeInfo> applyImpl(BatchUpdate.Factory updateFactory, TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException, PermissionBackendException, ConfigInvalidException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("draft workflow is disabled");
        }
    }
    ProjectResource rsrc = projectsCollection.parse(input.project);
    checkValidCLA(rsrc.getControl());
    Project.NameKey project = rsrc.getNameKey();
    String refName = RefNames.fullName(input.branch);
    permissionBackend.user(user).project(project).ref(refName).check(RefPermission.CREATE_CHANGE);
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        ObjectId parentCommit;
        List<String> groups;
        if (input.baseChange != null) {
            List<ChangeControl> ctls = changeFinder.find(input.baseChange, rsrc.getControl().getUser());
            if (ctls.size() != 1) {
                throw new UnprocessableEntityException("Base change not found: " + input.baseChange);
            }
            ChangeControl ctl = Iterables.getOnlyElement(ctls);
            if (!ctl.isVisible(db.get())) {
                throw new UnprocessableEntityException("Base change not found: " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), ctl.getNotes());
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else {
            Ref destRef = git.getRefDatabase().exactRef(refName);
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", refName));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        AccountState account = accountCache.get(me.getAccountId());
        GeneralPreferencesInfo info = account.getAccount().getGeneralPreferencesInfo();
        ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
        ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, input.subject);
        String commitMessage = ChangeIdUtil.insertId(input.subject, id);
        if (Boolean.TRUE.equals(info.signedOffBy)) {
            commitMessage += String.format("%s%s", SIGNED_OFF_BY_TAG, account.getAccount().getNameEmail(anonymousCowardName));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            if (!(submitType.equals(SubmitType.MERGE_ALWAYS) || submitType.equals(SubmitType.MERGE_IF_NECESSARY))) {
                throw new BadRequestException("Submit type: " + submitType + " is not supported");
            }
            c = newMergeCommit(git, oi, rw, rsrc.getControl(), mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, refName);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        String topic = input.topic;
        if (topic != null) {
            topic = Strings.emptyToNull(topic.trim());
        }
        ins.setTopic(topic);
        ins.setDraft(input.status == ChangeStatus.DRAFT);
        ins.setPrivate(input.isPrivate == null ? privateByDefault : input.isPrivate);
        ins.setWorkInProgress(input.workInProgress != null && input.workInProgress);
        ins.setGroups(groups);
        ins.setNotify(input.notify);
        ins.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
        try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.noOptions();
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
private void setChangeId(int id) {
    changeId = new Change.Id(id);
    ins = changeInserterFactory.create(changeId, commit, refName).setTopic(magicBranch.topic).setPrivate(receiveConfig.privateByDefault || magicBranch.isPrivate).setWorkInProgress(magicBranch.workInProgress).setValidate(false);
    if (magicBranch.draft) {
        ins.setDraft(magicBranch.draft);
    } else if (magicBranch.merged) {
        ins.setStatus(Change.Status.MERGED);
    }
    cmd = new ReceiveCommand(ObjectId.zeroId(), commit, ins.getPatchSetId().toRefName());
    if (rp.getPushCertificate() != null) {
        ins.setPushCertificate(rp.getPushCertificate().toTextWithSignature());
    }
}
#method_after
private void setChangeId(int id) {
    changeId = new Change.Id(id);
    ins = changeInserterFactory.create(changeId, commit, refName).setTopic(magicBranch.topic).setPrivate(magicBranch.isPrivate || (receiveConfig.privateByDefault && !magicBranch.removePrivate)).setWorkInProgress(magicBranch.workInProgress).setValidate(false);
    if (magicBranch.draft) {
        ins.setDraft(magicBranch.draft);
    } else if (magicBranch.merged) {
        ins.setStatus(Change.Status.MERGED);
    }
    cmd = new ReceiveCommand(ObjectId.zeroId(), commit, ins.getPatchSetId().toRefName());
    if (rp.getPushCertificate() != null) {
        ins.setPushCertificate(rp.getPushCertificate().toTextWithSignature());
    }
}
#end_block

#method_before
@Test
public void createChangeWithPrivateByDefaultEnabled() throws Exception {
    assume().that(isPrivateByDefault()).isTrue();
    ChangeInfo info = gApi.changes().create(new ChangeInput(project.get(), "master", "empty change")).get();
    assertThat(info.isPrivate).isEqualTo(true);
}
#method_after
@Test
@GerritConfig(name = "change.privateByDefault", value = "true")
public void createChangeWithPrivateByDefaultEnabled() throws Exception {
    ChangeInput input = new ChangeInput(project.get(), "master", "empty change");
    assertThat(gApi.changes().create(input).get().isPrivate).isEqualTo(true);
}
#end_block

#method_before
@Test
public void createChangeWithPrivateByDefaultDisabled() throws Exception {
    assume().that(isPrivateByDefault()).isFalse();
    ChangeInfo info = gApi.changes().create(new ChangeInput(project.get(), "master", "empty change")).get();
    assertThat(info.isPrivate).isNull();
}
#method_after
@Test
public void createChangeWithPrivateByDefaultDisabled() throws Exception {
    ChangeInfo info = gApi.changes().create(new ChangeInput(project.get(), "master", "empty change")).get();
    assertThat(info.isPrivate).isNull();
}
#end_block

#method_before
@Test
public void pushWithPrivateByDefaultEnabled() throws Exception {
    assume().that(isPrivateByDefault()).isTrue();
    assertThat(createChange().getChange().change().isPrivate()).isEqualTo(true);
}
#method_after
@Test
@GerritConfig(name = "change.privateByDefault", value = "true")
public void pushWithPrivateByDefaultEnabled() throws Exception {
    assertThat(createChange().getChange().change().isPrivate()).isEqualTo(true);
}
#end_block

#method_before
@Test
public void pushWithPrivateByDefaultDisabled() throws Exception {
    assume().that(isPrivateByDefault()).isFalse();
    assertThat(createChange().getChange().change().isPrivate()).isEqualTo(false);
}
#method_after
@Test
public void pushWithPrivateByDefaultDisabled() throws Exception {
    assertThat(createChange().getChange().change().isPrivate()).isEqualTo(false);
}
#end_block

#method_before
@Override
public void message(String msg) {
}
#method_after
@Override
public void message(String message) {
}
#end_block

#method_before
@Override
public boolean yesno(boolean def, String msg) {
    return def;
}
#method_after
@Override
public boolean yesno(boolean defaultValue, String message) {
    return defaultValue;
}
#end_block

#method_before
@Override
public String readString(String def, Set<String> allowedValues, String fmt) {
    return "";
}
#method_after
@Override
public String readString(String defaultValue, Set<String> allowedValues, String message) {
    return defaultValue;
}
#end_block

#method_before
void upgradeSchema() throws OrmException {
    final List<String> pruneList = new ArrayList<>();
    schemaUpdater.update(new UpdateUI() {

        @Override
        public void message(String msg) {
            System.err.println(msg);
            System.err.flush();
        }

        @Override
        public boolean yesno(boolean def, String msg) {
            return ui.yesno(def, msg);
        }

        @Override
        public void waitForUser() {
            ui.waitForUser();
        }

        @Override
        public String readString(String def, Set<String> allowedValues, String fmt) {
            return ui.readString(def, allowedValues, fmt);
        }

        @Override
        public boolean isBatch() {
            return ui.isBatch();
        }

        @Override
        public void pruneSchema(StatementExecutor e, List<String> prune) {
            for (String p : prune) {
                if (!pruneList.contains(p)) {
                    pruneList.add(p);
                }
            }
        }
    });
    if (!pruneList.isEmpty()) {
        StringBuilder msg = new StringBuilder();
        msg.append("Execute the following SQL to drop unused objects:\n");
        msg.append("\n");
        for (String sql : pruneList) {
            msg.append("  ");
            msg.append(sql);
            msg.append(";\n");
        }
        if (ui.isBatch()) {
            System.err.print(msg);
            System.err.flush();
        } else if (ui.yesno(true, "%s\nExecute now", msg)) {
            try (JdbcSchema db = (JdbcSchema) unwrapDb(schema.open());
                JdbcExecutor e = new JdbcExecutor(db)) {
                for (String sql : pruneList) {
                    e.execute(sql);
                }
            }
        }
    }
}
#method_after
void upgradeSchema() throws OrmException {
    final List<String> pruneList = new ArrayList<>();
    schemaUpdater.update(new UpdateUI() {

        @Override
        public void message(String message) {
            System.err.println(message);
            System.err.flush();
        }

        @Override
        public boolean yesno(boolean defaultValue, String message) {
            return ui.yesno(defaultValue, message);
        }

        @Override
        public void waitForUser() {
            ui.waitForUser();
        }

        @Override
        public String readString(String defaultValue, Set<String> allowedValues, String message) {
            return ui.readString(defaultValue, allowedValues, message);
        }

        @Override
        public boolean isBatch() {
            return ui.isBatch();
        }

        @Override
        public void pruneSchema(StatementExecutor e, List<String> prune) {
            for (String p : prune) {
                if (!pruneList.contains(p)) {
                    pruneList.add(p);
                }
            }
        }
    });
    if (!pruneList.isEmpty()) {
        StringBuilder msg = new StringBuilder();
        msg.append("Execute the following SQL to drop unused objects:\n");
        msg.append("\n");
        for (String sql : pruneList) {
            msg.append("  ");
            msg.append(sql);
            msg.append(";\n");
        }
        if (ui.isBatch()) {
            System.err.print(msg);
            System.err.flush();
        } else if (ui.yesno(true, "%s\nExecute now", msg)) {
            try (JdbcSchema db = (JdbcSchema) unwrapDb(schema.open());
                JdbcExecutor e = new JdbcExecutor(db)) {
                for (String sql : pruneList) {
                    e.execute(sql);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public boolean match(ChangeData cd) throws OrmException {
    if (cd.fastIsVisibleTo(user)) {
        return true;
    }
    Change change;
    try {
        change = cd.change();
        if (change == null) {
            return false;
        }
        ChangeNotes notes = notesFactory.createFromIndexedChange(change);
        ChangeControl cc = changeControl.controlFor(notes, user);
        boolean visible;
        try {
            visible = permissionBackend.user(user).indexedChange(cd, notes).database(db).test(ChangePermission.READ);
        } catch (PermissionBackendException e) {
            throw new OrmException("unable to check permissions", e);
        }
        if (visible) {
            cd.cacheVisibleTo(cc);
            return true;
        }
    } catch (NoSuchChangeException e) {
        // Ignored
        return false;
    }
    return false;
}
#method_after
@Override
public boolean match(ChangeData cd) throws OrmException {
    if (cd.fastIsVisibleTo(user)) {
        return true;
    }
    Change change = cd.change();
    if (change == null) {
        return false;
    }
    ChangeControl changeControl;
    ChangeNotes notes = notesFactory.createFromIndexedChange(change);
    try {
        changeControl = changeControlFactory.controlFor(notes, user);
    } catch (NoSuchChangeException e) {
        // Ignored
        return false;
    }
    boolean visible;
    try {
        visible = permissionBackend.user(user).indexedChange(cd, notes).database(db).test(ChangePermission.READ);
    } catch (PermissionBackendException e) {
        throw new OrmException("unable to check permissions", e);
    }
    if (visible) {
        cd.cacheVisibleTo(changeControl);
        return true;
    }
    return false;
}
#end_block

#method_before
private static String startTime(final Date when) {
    return format(when, TimeUtil.nowMs() - when.getTime());
}
#method_after
private static String startTime(Date when) {
    return format(when, TimeUtil.nowMs() - when.getTime());
}
#end_block

#method_before
// See GuiceRequestScopePropagator#wrapImpl
@SuppressWarnings("javadoc")
public final <T> Callable<T> wrap(final Callable<T> callable) {
    final RequestContext callerContext = checkNotNull(local.getContext());
    final Callable<T> wrapped = wrapImpl(context(callerContext, cleanup(callable)));
    return new Callable<T>() {

        @Override
        public T call() throws Exception {
            if (callerContext == local.getContext()) {
                return callable.call();
            }
            return wrapped.call();
        }

        @Override
        public String toString() {
            return callable.toString();
        }
    };
}
#method_after
// See GuiceRequestScopePropagator#wrapImpl
@SuppressWarnings("javadoc")
public final <T> Callable<T> wrap(Callable<T> callable) {
    final RequestContext callerContext = checkNotNull(local.getContext());
    final Callable<T> wrapped = wrapImpl(context(callerContext, cleanup(callable)));
    return new Callable<T>() {

        @Override
        public T call() throws Exception {
            if (callerContext == local.getContext()) {
                return callable.call();
            }
            return wrapped.call();
        }

        @Override
        public String toString() {
            return callable.toString();
        }
    };
}
#end_block

#method_before
public final Runnable wrap(final Runnable runnable) {
    final Callable<Object> wrapped = wrap(Executors.callable(runnable));
    if (runnable instanceof ProjectRunnable) {
        return new ProjectRunnable() {

            @Override
            public void run() {
                try {
                    wrapped.call();
                } catch (Exception e) {
                    Throwables.throwIfUnchecked(e);
                    // Not possible.
                    throw new RuntimeException(e);
                }
            }

            @Override
            public Project.NameKey getProjectNameKey() {
                return ((ProjectRunnable) runnable).getProjectNameKey();
            }

            @Override
            public String getRemoteName() {
                return ((ProjectRunnable) runnable).getRemoteName();
            }

            @Override
            public boolean hasCustomizedPrint() {
                return ((ProjectRunnable) runnable).hasCustomizedPrint();
            }

            @Override
            public String toString() {
                return runnable.toString();
            }
        };
    }
    return new Runnable() {

        @Override
        public void run() {
            try {
                wrapped.call();
            } catch (RuntimeException e) {
                throw e;
            } catch (Exception e) {
                // Not possible.
                throw new RuntimeException(e);
            }
        }

        @Override
        public String toString() {
            return runnable.toString();
        }
    };
}
#method_after
public final Runnable wrap(Runnable runnable) {
    final Callable<Object> wrapped = wrap(Executors.callable(runnable));
    if (runnable instanceof ProjectRunnable) {
        return new ProjectRunnable() {

            @Override
            public void run() {
                try {
                    wrapped.call();
                } catch (Exception e) {
                    Throwables.throwIfUnchecked(e);
                    // Not possible.
                    throw new RuntimeException(e);
                }
            }

            @Override
            public Project.NameKey getProjectNameKey() {
                return ((ProjectRunnable) runnable).getProjectNameKey();
            }

            @Override
            public String getRemoteName() {
                return ((ProjectRunnable) runnable).getRemoteName();
            }

            @Override
            public boolean hasCustomizedPrint() {
                return ((ProjectRunnable) runnable).hasCustomizedPrint();
            }

            @Override
            public String toString() {
                return runnable.toString();
            }
        };
    }
    return new Runnable() {

        @Override
        public void run() {
            try {
                wrapped.call();
            } catch (RuntimeException e) {
                throw e;
            } catch (Exception e) {
                // Not possible.
                throw new RuntimeException(e);
            }
        }

        @Override
        public String toString() {
            return runnable.toString();
        }
    };
}
#end_block

#method_before
@Override
public void setInputStream(final InputStream in) {
    this.in = in;
}
#method_after
@Override
public void setInputStream(InputStream in) {
    this.in = in;
}
#end_block

#method_before
@Override
public void setOutputStream(final OutputStream out) {
    this.out = out;
}
#method_after
@Override
public void setOutputStream(OutputStream out) {
    this.out = out;
}
#end_block

#method_before
@Override
public void setErrorStream(final OutputStream err) {
    this.err = err;
}
#method_after
@Override
public void setErrorStream(OutputStream err) {
    this.err = err;
}
#end_block

#method_before
@Override
public void setExitCallback(final ExitCallback callback) {
    this.exit = callback;
}
#method_after
@Override
public void setExitCallback(ExitCallback callback) {
    this.exit = callback;
}
#end_block

#method_before
void setName(final String prefix) {
    this.commandName = prefix;
}
#method_after
void setName(String prefix) {
    this.commandName = prefix;
}
#end_block

#method_before
public void setArguments(final String[] argv) {
    this.argv = argv;
}
#method_after
public void setArguments(String[] argv) {
    this.argv = argv;
}
#end_block

#method_before
protected void provideStateTo(final Command cmd) {
    cmd.setInputStream(in);
    cmd.setOutputStream(out);
    cmd.setErrorStream(err);
    cmd.setExitCallback(exit);
}
#method_after
protected void provideStateTo(Command cmd) {
    cmd.setInputStream(in);
    cmd.setOutputStream(out);
    cmd.setErrorStream(err);
    cmd.setExitCallback(exit);
}
#end_block

#method_before
protected void startThread(final CommandRunnable thunk) {
    final TaskThunk tt = new TaskThunk(thunk);
    if (isAdminHighPriorityCommand()) {
        // Admin commands should not block the main work threads (there
        // might be an interactive shell there), nor should they wait
        // for the main work threads.
        // 
        new Thread(tt, tt.toString()).start();
    } else {
        task.set(executor.submit(tt));
    }
}
#method_after
protected void startThread(CommandRunnable thunk) {
    final TaskThunk tt = new TaskThunk(thunk);
    if (isAdminHighPriorityCommand()) {
        // Admin commands should not block the main work threads (there
        // might be an interactive shell there), nor should they wait
        // for the main work threads.
        // 
        new Thread(tt, tt.toString()).start();
    } else {
        task.set(executor.submit(tt));
    }
}
#end_block

#method_before
protected void onExit(final int rc) {
    exit.onExit(rc);
    if (cleanup != null) {
        cleanup.run();
    }
}
#method_after
protected void onExit(int rc) {
    exit.onExit(rc);
    if (cleanup != null) {
        cleanup.run();
    }
}
#end_block

#method_before
protected static PrintWriter toPrintWriter(final OutputStream o) {
    return new PrintWriter(new BufferedWriter(new OutputStreamWriter(o, ENC)));
}
#method_after
protected static PrintWriter toPrintWriter(OutputStream o) {
    return new PrintWriter(new BufferedWriter(new OutputStreamWriter(o, ENC)));
}
#end_block

#method_before
private int handleError(final Throwable e) {
    if ((e.getClass() == IOException.class && "Pipe closed".equals(e.getMessage())) || // 
    (e.getClass() == SshException.class && "Already closed".equals(e.getMessage())) || // 
    e.getClass() == InterruptedIOException.class) {
        // 
        return 127;
    }
    if (!(e instanceof UnloggedFailure)) {
        final StringBuilder m = new StringBuilder();
        m.append("Internal server error");
        if (user.isIdentifiedUser()) {
            final IdentifiedUser u = user.asIdentifiedUser();
            m.append(" (user ");
            m.append(u.getAccount().getUserName());
            m.append(" account ");
            m.append(u.getAccountId());
            m.append(")");
        }
        m.append(" during ");
        m.append(context.getCommandLine());
        log.error(m.toString(), e);
    }
    if (e instanceof Failure) {
        final Failure f = (Failure) e;
        try {
            err.write((f.getMessage() + "\n").getBytes(ENC));
            err.flush();
        } catch (IOException e2) {
        // Ignored
        } catch (Throwable e2) {
            log.warn("Cannot send failure message to client", e2);
        }
        return f.exitCode;
    }
    try {
        err.write("fatal: internal server error\n".getBytes(ENC));
        err.flush();
    } catch (IOException e2) {
    // Ignored
    } catch (Throwable e2) {
        log.warn("Cannot send internal server error message to client", e2);
    }
    return 128;
}
#method_after
private int handleError(Throwable e) {
    if ((e.getClass() == IOException.class && "Pipe closed".equals(e.getMessage())) || // 
    (e.getClass() == SshException.class && "Already closed".equals(e.getMessage())) || // 
    e.getClass() == InterruptedIOException.class) {
        // 
        return 127;
    }
    if (!(e instanceof UnloggedFailure)) {
        final StringBuilder m = new StringBuilder();
        m.append("Internal server error");
        if (user.isIdentifiedUser()) {
            final IdentifiedUser u = user.asIdentifiedUser();
            m.append(" (user ");
            m.append(u.getAccount().getUserName());
            m.append(" account ");
            m.append(u.getAccountId());
            m.append(")");
        }
        m.append(" during ");
        m.append(context.getCommandLine());
        log.error(m.toString(), e);
    }
    if (e instanceof Failure) {
        final Failure f = (Failure) e;
        try {
            err.write((f.getMessage() + "\n").getBytes(ENC));
            err.flush();
        } catch (IOException e2) {
        // Ignored
        } catch (Throwable e2) {
            log.warn("Cannot send failure message to client", e2);
        }
        return f.exitCode;
    }
    try {
        err.write("fatal: internal server error\n".getBytes(ENC));
        err.flush();
    } catch (IOException e2) {
    // Ignored
    } catch (Throwable e2) {
        log.warn("Cannot send internal server error message to client", e2);
    }
    return 128;
}
#end_block

#method_before
public List<Task<?>> getTasks() {
    final List<Task<?>> r = new ArrayList<>();
    for (final Executor e : queues) {
        e.addAllTo(r);
    }
    return r;
}
#method_after
public List<Task<?>> getTasks() {
    final List<Task<?>> r = new ArrayList<>();
    for (Executor e : queues) {
        e.addAllTo(r);
    }
    return r;
}
#end_block

#method_before
public Task<?> getTask(final int id) {
    Task<?> result = null;
    for (final Executor e : queues) {
        final Task<?> t = e.getTask(id);
        if (t != null) {
            if (result != null) {
                // Don't return the task if we have a duplicate. Lie instead.
                return null;
            }
            result = t;
        }
    }
    return result;
}
#method_after
public Task<?> getTask(int id) {
    Task<?> result = null;
    for (Executor e : queues) {
        final Task<?> t = e.getTask(id);
        if (t != null) {
            if (result != null) {
                // Don't return the task if we have a duplicate. Lie instead.
                return null;
            }
            result = t;
        }
    }
    return result;
}
#end_block

#method_before
private void stop() {
    for (final Executor p : queues) {
        p.shutdown();
        boolean isTerminated;
        do {
            try {
                isTerminated = p.awaitTermination(10, TimeUnit.SECONDS);
            } catch (InterruptedException ie) {
                isTerminated = false;
            }
        } while (!isTerminated);
    }
    queues.clear();
}
#method_after
private void stop() {
    for (Executor p : queues) {
        p.shutdown();
        boolean isTerminated;
        do {
            try {
                isTerminated = p.awaitTermination(10, TimeUnit.SECONDS);
            } catch (InterruptedException ie) {
                isTerminated = false;
            }
        } while (!isTerminated);
    }
    queues.clear();
}
#end_block

#method_before
@Override
protected <V> RunnableScheduledFuture<V> decorateTask(final Runnable runnable, RunnableScheduledFuture<V> r) {
    r = super.decorateTask(runnable, r);
    for (; ; ) {
        final int id = idGenerator.next();
        Task<V> task;
        if (runnable instanceof ProjectRunnable) {
            task = new ProjectTask<>((ProjectRunnable) runnable, r, this, id);
        } else {
            task = new Task<>(runnable, r, this, id);
        }
        if (all.putIfAbsent(task.getTaskId(), task) == null) {
            return task;
        }
    }
}
#method_after
@Override
protected <V> RunnableScheduledFuture<V> decorateTask(Runnable runnable, RunnableScheduledFuture<V> r) {
    r = super.decorateTask(runnable, r);
    for (; ; ) {
        final int id = idGenerator.next();
        Task<V> task;
        if (runnable instanceof ProjectRunnable) {
            task = new ProjectTask<>((ProjectRunnable) runnable, r, this, id);
        } else {
            task = new Task<>(runnable, r, this, id);
        }
        if (all.putIfAbsent(task.getTaskId(), task) == null) {
            return task;
        }
    }
}
#end_block

#method_before
@Override
protected <V> RunnableScheduledFuture<V> decorateTask(final Callable<V> callable, final RunnableScheduledFuture<V> task) {
    throw new UnsupportedOperationException("Callable not implemented");
}
#method_after
@Override
protected <V> RunnableScheduledFuture<V> decorateTask(Callable<V> callable, RunnableScheduledFuture<V> task) {
    throw new UnsupportedOperationException("Callable not implemented");
}
#end_block

#method_before
void remove(final Task<?> task) {
    all.remove(task.getTaskId(), task);
}
#method_after
void remove(Task<?> task) {
    all.remove(task.getTaskId(), task);
}
#end_block

#method_before
Task<?> getTask(final int id) {
    return all.get(id);
}
#method_after
Task<?> getTask(int id) {
    return all.get(id);
}
#end_block

#method_before
void addAllTo(final List<Task<?>> list) {
    // iterator is thread safe
    list.addAll(all.values());
}
#method_after
void addAllTo(List<Task<?>> list) {
    // iterator is thread safe
    list.addAll(all.values());
}
#end_block

#method_before
@Override
public ScheduledThreadPoolExecutor get() {
    final ScheduledThreadPoolExecutor executor;
    executor = queues.createQueue(poolSize, "SSH-Stream-Worker");
    final ThreadFactory parent = executor.getThreadFactory();
    executor.setThreadFactory(new ThreadFactory() {

        @Override
        public Thread newThread(final Runnable task) {
            final Thread t = parent.newThread(task);
            t.setPriority(Thread.MIN_PRIORITY);
            return t;
        }
    });
    return executor;
}
#method_after
@Override
public ScheduledThreadPoolExecutor get() {
    final ScheduledThreadPoolExecutor executor;
    executor = queues.createQueue(poolSize, "SSH-Stream-Worker");
    final ThreadFactory parent = executor.getThreadFactory();
    executor.setThreadFactory(new ThreadFactory() {

        @Override
        public Thread newThread(Runnable task) {
            final Thread t = parent.newThread(task);
            t.setPriority(Thread.MIN_PRIORITY);
            return t;
        }
    });
    return executor;
}
#end_block

#method_before
@Override
public void start(final Environment env) throws IOException {
    try {
        parseCommandLine();
    } catch (UnloggedFailure e) {
        String msg = e.getMessage();
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        err.write(msg.getBytes(UTF_8));
        err.flush();
        onExit(1);
        return;
    }
    stdout = toPrintWriter(out);
    eventListenerRegistration = eventListeners.add(new UserScopedEventListener() {

        @Override
        public void onEvent(final Event event) {
            if (subscribedToEvents.isEmpty() || subscribedToEvents.contains(event.getType())) {
                offer(event);
            }
        }

        @Override
        public CurrentUser getUser() {
            return currentUser;
        }
    });
    gson = new GsonBuilder().registerTypeAdapter(Supplier.class, new SupplierSerializer()).registerTypeAdapter(Project.NameKey.class, new ProjectNameKeySerializer()).create();
}
#method_after
@Override
public void start(Environment env) throws IOException {
    try {
        parseCommandLine();
    } catch (UnloggedFailure e) {
        String msg = e.getMessage();
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        err.write(msg.getBytes(UTF_8));
        err.flush();
        onExit(1);
        return;
    }
    stdout = toPrintWriter(out);
    eventListenerRegistration = eventListeners.add(new UserScopedEventListener() {

        @Override
        public void onEvent(Event event) {
            if (subscribedToEvents.isEmpty() || subscribedToEvents.contains(event.getType())) {
                offer(event);
            }
        }

        @Override
        public CurrentUser getUser() {
            return currentUser;
        }
    });
    gson = new GsonBuilder().registerTypeAdapter(Supplier.class, new SupplierSerializer()).registerTypeAdapter(Project.NameKey.class, new ProjectNameKeySerializer()).create();
}
#end_block

#method_before
@Override
protected void onExit(final int rc) {
    eventListenerRegistration.remove();
    synchronized (taskLock) {
        done = true;
    }
    super.onExit(rc);
}
#method_after
@Override
protected void onExit(int rc) {
    eventListenerRegistration.remove();
    synchronized (taskLock) {
        done = true;
    }
    super.onExit(rc);
}
#end_block

#method_before
private void offer(final Event event) {
    synchronized (taskLock) {
        if (!queue.offer(event)) {
            dropped = true;
        }
        if (task == null && !done) {
            task = pool.submit(writer);
        }
    }
}
#method_after
private void offer(Event event) {
    synchronized (taskLock) {
        if (!queue.offer(event)) {
            dropped = true;
        }
        if (task == null && !done) {
            task = pool.submit(writer);
        }
    }
}
#end_block

#method_before
private void write(final Object message) {
    String msg = null;
    try {
        msg = gson.toJson(message) + "\n";
    } catch (Exception e) {
        log.warn("Could not deserialize the msg: ", e);
    }
    if (msg != null) {
        synchronized (stdout) {
            stdout.print(msg);
        }
    }
}
#method_after
private void write(Object message) {
    String msg = null;
    try {
        msg = gson.toJson(message) + "\n";
    } catch (Exception e) {
        log.warn("Could not deserialize the msg: ", e);
    }
    if (msg != null) {
        synchronized (stdout) {
            stdout.print(msg);
        }
    }
}
#end_block

#method_before
@Provides
@Singleton
@Named(TIMEOUT_NAME)
long getTimeoutMillis(@GerritServerConfig final Config cfg) {
    return ConfigUtil.getTimeUnit(cfg, "receive", null, "timeout", TimeUnit.MINUTES.toMillis(4), TimeUnit.MILLISECONDS);
}
#method_after
@Provides
@Singleton
@Named(TIMEOUT_NAME)
long getTimeoutMillis(@GerritServerConfig Config cfg) {
    return ConfigUtil.getTimeUnit(cfg, "receive", null, "timeout", TimeUnit.MINUTES.toMillis(4), TimeUnit.MILLISECONDS);
}
#end_block

#method_before
@Override
public void onPreReceive(final ReceivePack rp, final Collection<ReceiveCommand> commands) {
    try {
        progress.waitFor(executor.submit(scopePropagator.wrap(new Worker(commands))), timeoutMillis, TimeUnit.MILLISECONDS);
    } catch (ExecutionException e) {
        log.warn(String.format("Error in ReceiveCommits while processing changes for project %s", rc.getProject().getName()), e);
        rc.addError("internal error while processing changes");
        // point is very bad.
        for (final ReceiveCommand c : commands) {
            if (c.getResult() == Result.NOT_ATTEMPTED) {
                c.setResult(Result.REJECTED_OTHER_REASON, "internal error");
            }
        }
    } finally {
        rc.sendMessages();
    }
}
#method_after
@Override
public void onPreReceive(ReceivePack rp, Collection<ReceiveCommand> commands) {
    try {
        progress.waitFor(executor.submit(scopePropagator.wrap(new Worker(commands))), timeoutMillis, TimeUnit.MILLISECONDS);
    } catch (ExecutionException e) {
        log.warn(String.format("Error in ReceiveCommits while processing changes for project %s", rc.getProject().getName()), e);
        rc.addError("internal error while processing changes");
        // point is very bad.
        for (ReceiveCommand c : commands) {
            if (c.getResult() == Result.NOT_ATTEMPTED) {
                c.setResult(Result.REJECTED_OTHER_REASON, "internal error");
            }
        }
    } finally {
        rc.sendMessages();
    }
}
#end_block

#method_before
private void setThreadFactory(ScheduledThreadPoolExecutor executor) {
    final ThreadFactory parent = executor.getThreadFactory();
    executor.setThreadFactory(new ThreadFactory() {

        @Override
        public Thread newThread(final Runnable task) {
            final Thread t = parent.newThread(task);
            t.setPriority(Thread.MIN_PRIORITY);
            return t;
        }
    });
}
#method_after
private void setThreadFactory(ScheduledThreadPoolExecutor executor) {
    final ThreadFactory parent = executor.getThreadFactory();
    executor.setThreadFactory(new ThreadFactory() {

        @Override
        public Thread newThread(Runnable task) {
            final Thread t = parent.newThread(task);
            t.setPriority(Thread.MIN_PRIORITY);
            return t;
        }
    });
}
#end_block

#method_before
static String computeCanonicalPath(String canonicalURL) throws URISyntaxException {
    if (canonicalURL == null) {
        return "";
    }
    // If we serving from a sub-directory rather than root, determine the path
    // from the cannonical web URL.
    URI uri = new URI(canonicalURL);
    return uri.getPath().replaceAll("/$", "");
}
#method_after
static String computeCanonicalPath(String canonicalURL) throws URISyntaxException {
    if (Strings.isNullOrEmpty(canonicalURL)) {
        return "";
    }
    // If we serving from a sub-directory rather than root, determine the path
    // from the cannonical web URL.
    URI uri = new URI(canonicalURL);
    return uri.getPath().replaceAll("/$", "");
}
#end_block

#method_before
public String getPluginName(Path srcPath) {
    return MoreObjects.firstNonNull(getGerritPluginName(srcPath), nameOf(srcPath));
}
#method_after
public String getPluginName(Path srcPath) {
    return MoreObjects.firstNonNull(getGerritPluginName(srcPath), PluginUtil.nameOf(srcPath));
}
#end_block

#method_before
public String installPluginFromStream(String originalName, InputStream in) throws IOException, PluginInstallException {
    checkRemoteInstall();
    String fileName = originalName;
    Path tmp = asTemp(in, ".next_" + fileName + "_", ".tmp", pluginsDir);
    String name = MoreObjects.firstNonNull(getGerritPluginName(tmp), nameOf(fileName));
    if (!originalName.equals(name)) {
        log.warn(String.format("Plugin provides its own name: <%s>, use it instead of the input name: <%s>", name, originalName));
    }
    String fileExtension = getExtension(fileName);
    Path dst = pluginsDir.resolve(name + fileExtension);
    synchronized (this) {
        Plugin active = running.get(name);
        if (active != null) {
            fileName = active.getSrcFile().getFileName().toString();
            log.info(String.format("Replacing plugin %s", active.getName()));
            Path old = pluginsDir.resolve(".last_" + fileName);
            Files.deleteIfExists(old);
            Files.move(active.getSrcFile(), old);
        }
        Files.deleteIfExists(pluginsDir.resolve(fileName + ".disabled"));
        Files.move(tmp, dst);
        try {
            Plugin plugin = runPlugin(name, dst, active);
            if (active == null) {
                log.info(String.format("Installed plugin %s", plugin.getName()));
            }
        } catch (PluginInstallException e) {
            Files.deleteIfExists(dst);
            throw e;
        }
        cleanInBackground();
    }
    return name;
}
#method_after
public String installPluginFromStream(String originalName, InputStream in) throws IOException, PluginInstallException {
    checkRemoteInstall();
    String fileName = originalName;
    Path tmp = PluginUtil.asTemp(in, ".next_" + fileName + "_", ".tmp", pluginsDir);
    String name = MoreObjects.firstNonNull(getGerritPluginName(tmp), PluginUtil.nameOf(fileName));
    if (!originalName.equals(name)) {
        log.warn(String.format("Plugin provides its own name: <%s>, use it instead of the input name: <%s>", name, originalName));
    }
    String fileExtension = getExtension(fileName);
    Path dst = pluginsDir.resolve(name + fileExtension);
    synchronized (this) {
        Plugin active = running.get(name);
        if (active != null) {
            fileName = active.getSrcFile().getFileName().toString();
            log.info(String.format("Replacing plugin %s", active.getName()));
            Path old = pluginsDir.resolve(".last_" + fileName);
            Files.deleteIfExists(old);
            Files.move(active.getSrcFile(), old);
        }
        Files.deleteIfExists(pluginsDir.resolve(fileName + ".disabled"));
        Files.move(tmp, dst);
        try {
            Plugin plugin = runPlugin(name, dst, active);
            if (active == null) {
                log.info(String.format("Installed plugin %s", plugin.getName()));
            }
        } catch (PluginInstallException e) {
            Files.deleteIfExists(dst);
            throw e;
        }
        cleanInBackground();
    }
    return name;
}
#end_block

#method_before
@Override
public synchronized void start() {
    removeStalePluginFiles();
    log.info("Loading plugins from " + pluginsDir.toAbsolutePath());
    srvInfoImpl.state = ServerInformation.State.STARTUP;
    rescan();
    srvInfoImpl.state = ServerInformation.State.RUNNING;
    if (scanner != null) {
        scanner.start();
    }
}
#method_after
@Override
public synchronized void start() {
    removeStalePluginFiles();
    Path absolutePath = pluginsDir.toAbsolutePath();
    if (!Files.exists(absolutePath)) {
        log.info(absolutePath + " does not exist; creating");
        try {
            Files.createDirectories(absolutePath);
        } catch (IOException e) {
            log.error(String.format("Failed to create %s: %s", absolutePath, e.getMessage()));
        }
    }
    log.info("Loading plugins from " + absolutePath);
    srvInfoImpl.state = ServerInformation.State.STARTUP;
    rescan();
    srvInfoImpl.state = ServerInformation.State.RUNNING;
    if (scanner != null) {
        scanner.start();
    }
}
#end_block

#method_before
private static String getExtension(String name) {
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(ext) : "";
}
#method_after
private String getExtension(String name) {
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(ext) : "";
}
#end_block

#method_before
private String getPluginCanonicalWebUrl(String name) {
    String canonicalWebUrl = urlProvider.get();
    if (canonicalWebUrl == null) {
        canonicalWebUrl = "";
    }
    String url = String.format("%s/plugins/%s/", CharMatcher.is('/').trimTrailingFrom(canonicalWebUrl), name);
    return url;
}
#method_after
private String getPluginCanonicalWebUrl(String name) {
    String canonicalWebUrl = urlProvider.get();
    if (Strings.isNullOrEmpty(canonicalWebUrl)) {
        return "/plugins/" + name;
    }
    String url = String.format("%s/plugins/%s/", CharMatcher.is('/').trimTrailingFrom(canonicalWebUrl), name);
    return url;
}
#end_block

#method_before
// Only one active plugin per plugin name can exist for each plugin name.
private static Map<String, Path> filterDisabled(SetMultimap<String, Path> pluginPaths) {
    Map<String, Path> activePlugins = Maps.newHashMapWithExpectedSize(pluginPaths.keys().size());
    for (String name : pluginPaths.keys()) {
        for (Path pluginPath : pluginPaths.asMap().get(name)) {
            if (!pluginPath.getFileName().toString().endsWith(".disabled")) {
                assert !activePlugins.containsKey(name);
                activePlugins.put(name, pluginPath);
            }
        }
    }
    return activePlugins;
}
#method_after
// Only one active plugin per plugin name can exist for each plugin name.
private Map<String, Path> filterDisabled(SetMultimap<String, Path> pluginPaths) {
    Map<String, Path> activePlugins = Maps.newHashMapWithExpectedSize(pluginPaths.keys().size());
    for (String name : pluginPaths.keys()) {
        for (Path pluginPath : pluginPaths.asMap().get(name)) {
            if (!pluginPath.getFileName().toString().endsWith(".disabled")) {
                assert !activePlugins.containsKey(name);
                activePlugins.put(name, pluginPath);
            }
        }
    }
    return activePlugins;
}
#end_block

#method_before
private List<Path> scanPathsInPluginsDirectory(Path pluginsDir) {
    try {
        return listPlugins(pluginsDir);
    } catch (IOException e) {
        log.error("Cannot list " + pluginsDir.toAbsolutePath(), e);
        return ImmutableList.of();
    }
}
#method_after
private List<Path> scanPathsInPluginsDirectory(Path pluginsDir) {
    try {
        return PluginUtil.listPlugins(pluginsDir);
    } catch (IOException e) {
        log.error("Cannot list " + pluginsDir.toAbsolutePath(), e);
        return ImmutableList.of();
    }
}
#end_block

#method_before
private static Iterable<Path> filterDisabledPlugins(Collection<Path> paths) {
    return Iterables.filter(paths, p -> !p.getFileName().toString().endsWith(".disabled"));
}
#method_after
private Iterable<Path> filterDisabledPlugins(Collection<Path> paths) {
    return Iterables.filter(paths, p -> !p.getFileName().toString().endsWith(".disabled"));
}
#end_block

#method_before
private static boolean isUiPlugin(String name) {
    return isPlugin(name, "js") || isPlugin(name, "html");
}
#method_after
private boolean isUiPlugin(String name) {
    return isPlugin(name, "js") || isPlugin(name, "html");
}
#end_block

#method_before
private static boolean isPlugin(String fileName, String ext) {
    String fullExt = "." + ext;
    return fileName.endsWith(fullExt) || fileName.endsWith(fullExt + ".disabled");
}
#method_after
private boolean isPlugin(String fileName, String ext) {
    String fullExt = "." + ext;
    return fileName.endsWith(fullExt) || fileName.endsWith(fullExt + ".disabled");
}
#end_block

#method_before
private static String getHostName(String canonicalWebUrl) {
    try {
        return new URI(canonicalWebUrl).getHost();
    } catch (URISyntaxException e) {
        return null;
    }
}
#method_after
private static String getHostName(String canonicalWebUrl) {
    if (canonicalWebUrl == null) {
        log.error("No canonicalWebUrl defined in gerrit.config, OAuth may not work properly");
        return null;
    }
    try {
        return new URI(canonicalWebUrl).getHost();
    } catch (URISyntaxException e) {
        log.error("Invalid canonicalWebUrl '" + canonicalWebUrl + "'", e);
        return null;
    }
}
#end_block

#method_before
private String getShortenedCommentMessage(Comment comment) {
    final int THRESHOLD = 100;
    final String fullMessage = comment.message.trim();
    String msg = fullMessage;
    if (msg.length() > THRESHOLD) {
        msg = msg.substring(0, THRESHOLD);
    }
    int lf = msg.indexOf('\n');
    int period = msg.lastIndexOf('.');
    if (lf > 0) {
        // Truncate if a line feed appears within the threshold.
        msg = msg.substring(0, lf);
    } else if (period > 0) {
        // Otherwise truncate if there is a period within the threshold.
        msg = msg.substring(0, period + 1);
    }
    // Append an ellipsis if the message has been truncated.
    if (!msg.equals(fullMessage)) {
        msg += " []";
    }
    return msg;
}
#method_after
protected static String getShortenedCommentMessage(String message) {
    int threshold = 100;
    String fullMessage = message.trim();
    String msg = fullMessage;
    if (msg.length() > threshold) {
        msg = msg.substring(0, threshold);
    }
    int lf = msg.indexOf('\n');
    int period = msg.lastIndexOf('.');
    if (lf > 0) {
        // Truncate if a line feed appears within the threshold.
        msg = msg.substring(0, lf);
    } else if (period > 0) {
        // Otherwise truncate if there is a period within the threshold.
        msg = msg.substring(0, period + 1);
    }
    // Append an ellipsis if the message has been truncated.
    if (!msg.equals(fullMessage)) {
        msg += " []";
    }
    return msg;
}
#end_block

#method_before
private String getShortenedCommentMessage(Comment comment) {
    final int THRESHOLD = 100;
    final String fullMessage = comment.message.trim();
    String msg = fullMessage;
    if (msg.length() > THRESHOLD) {
        msg = msg.substring(0, THRESHOLD);
    }
    int lf = msg.indexOf('\n');
    int period = msg.lastIndexOf('.');
    if (lf > 0) {
        // Truncate if a line feed appears within the threshold.
        msg = msg.substring(0, lf);
    } else if (period > 0) {
        // Otherwise truncate if there is a period within the threshold.
        msg = msg.substring(0, period + 1);
    }
    // Append an ellipsis if the message has been truncated.
    if (!msg.equals(fullMessage)) {
        msg += " []";
    }
    return msg;
}
#method_after
protected static String getShortenedCommentMessage(Comment comment) {
    return getShortenedCommentMessage(comment.message);
}
#end_block

#method_before
@Test
public void createdOnIsPopulatedForGroupsCreatedAfterAudit() throws Exception {
    Timestamp testStartTime = TimeUtil.nowTs();
    AccountGroup.Id groupId = createGroup("Group for schema migration");
    setCreatedOnToVeryOldTimestamp(groupId);
    testRule.schema151.migrateData(testRule.db, new TestUpdateUI());
    AccountGroup group = testRule.db.accountGroups().get(groupId);
    assertThat(group.getCreatedOn()).isAtLeast(testStartTime);
}
#method_after
@Test
public void createdOnIsPopulatedForGroupsCreatedAfterAudit() throws Exception {
    Timestamp testStartTime = TimeUtil.nowTs();
    AccountGroup.Id groupId = createGroup("Group for schema migration");
    setCreatedOnToVeryOldTimestamp(groupId);
    schema151.migrateData(db, new TestUpdateUI());
    AccountGroup group = db.accountGroups().get(groupId);
    assertThat(group.getCreatedOn()).isAtLeast(testStartTime);
}
#end_block

#method_before
@Test
public void createdOnIsPopulatedForGroupsCreatedBeforeAudit() throws Exception {
    AccountGroup.Id groupId = createGroup("Ancient group for schema migration");
    setCreatedOnToVeryOldTimestamp(groupId);
    removeAuditEntriesFor(groupId);
    testRule.schema151.migrateData(testRule.db, new TestUpdateUI());
    AccountGroup group = testRule.db.accountGroups().get(groupId);
    assertThat(group.getCreatedOn()).isEqualTo(AccountGroup.auditCreationInstantTs());
}
#method_after
@Test
public void createdOnIsPopulatedForGroupsCreatedBeforeAudit() throws Exception {
    AccountGroup.Id groupId = createGroup("Ancient group for schema migration");
    setCreatedOnToVeryOldTimestamp(groupId);
    removeAuditEntriesFor(groupId);
    schema151.migrateData(db, new TestUpdateUI());
    AccountGroup group = db.accountGroups().get(groupId);
    assertThat(group.getCreatedOn()).isEqualTo(AccountGroup.auditCreationInstantTs());
}
#end_block

#method_before
private AccountGroup.Id createGroup(String name) throws Exception {
    GroupInput groupInput = new GroupInput();
    groupInput.name = name;
    GroupInfo groupInfo = testRule.createGroupFactory.create(name).apply(TopLevelResource.INSTANCE, groupInput);
    return new Id(groupInfo.groupId);
}
#method_after
private AccountGroup.Id createGroup(String name) throws Exception {
    GroupInput groupInput = new GroupInput();
    groupInput.name = name;
    GroupInfo groupInfo = createGroupFactory.create(name).apply(TopLevelResource.INSTANCE, groupInput);
    return new Id(groupInfo.groupId);
}
#end_block

#method_before
private void setCreatedOnToVeryOldTimestamp(Id groupId) throws OrmException {
    AccountGroup group = testRule.db.accountGroups().get(groupId);
    Instant instant = LocalDateTime.of(1800, Month.JANUARY, 1, 0, 0).toInstant(ZoneOffset.UTC);
    group.setCreatedOn(Timestamp.from(instant));
    testRule.db.accountGroups().update(ImmutableList.of(group));
}
#method_after
private void setCreatedOnToVeryOldTimestamp(Id groupId) throws OrmException {
    AccountGroup group = db.accountGroups().get(groupId);
    Instant instant = LocalDateTime.of(1800, Month.JANUARY, 1, 0, 0).toInstant(ZoneOffset.UTC);
    group.setCreatedOn(Timestamp.from(instant));
    db.accountGroups().update(ImmutableList.of(group));
}
#end_block

#method_before
private void removeAuditEntriesFor(AccountGroup.Id groupId) throws Exception {
    ResultSet<AccountGroupMemberAudit> groupMemberAudits = testRule.db.accountGroupMembersAudit().byGroup(groupId);
    testRule.db.accountGroupMembersAudit().delete(groupMemberAudits);
}
#method_after
private void removeAuditEntriesFor(AccountGroup.Id groupId) throws Exception {
    ResultSet<AccountGroupMemberAudit> groupMemberAudits = db.accountGroupMembersAudit().byGroup(groupId);
    db.accountGroupMembersAudit().delete(groupMemberAudits);
}
#end_block

#method_before
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse rsp) throws IOException, ServletException {
    rsp.setContentType("text/plain");
    rsp.setCharacterEncoding("UTF-8");
    try {
        Context.setForwardedEvent(true);
        if (!MediaType.parse(req.getContentType()).is(JSON_UTF_8)) {
            sendError(rsp, SC_UNSUPPORTED_MEDIA_TYPE, "Expecting " + JSON_UTF_8.toString() + " content type");
            return;
        }
        Event event = getEventFromRequest(req);
        dispatcher.postEvent(event);
        rsp.setStatus(SC_NO_CONTENT);
    } catch (OrmException e) {
        logger.debug("Error trying to find a change ", e);
        sendError(rsp, SC_NOT_FOUND, "Change not found\n");
    } catch (IOException e) {
        logger.error("Unable to re-trigger event", e);
        sendError(rsp, SC_BAD_REQUEST, e.getMessage());
    } catch (PermissionBackendException e) {
        logger.error("Unable to re-trigger event", e);
        sendError(rsp, SC_BAD_REQUEST, e.getMessage());
    } finally {
        Context.unsetForwardedEvent();
    }
}
#method_after
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse rsp) throws IOException, ServletException {
    rsp.setContentType("text/plain");
    rsp.setCharacterEncoding("UTF-8");
    try {
        Context.setForwardedEvent(true);
        if (!MediaType.parse(req.getContentType()).is(JSON_UTF_8)) {
            sendError(rsp, SC_UNSUPPORTED_MEDIA_TYPE, "Expecting " + JSON_UTF_8.toString() + " content type");
            return;
        }
        Event event = getEventFromRequest(req);
        dispatcher.postEvent(event);
        rsp.setStatus(SC_NO_CONTENT);
    } catch (OrmException e) {
        logger.debug("Error trying to find a change ", e);
        sendError(rsp, SC_NOT_FOUND, "Change not found\n");
    } catch (IOException | PermissionBackendException e) {
        logger.error("Unable to re-trigger event", e);
        sendError(rsp, SC_BAD_REQUEST, e.getMessage());
    } finally {
        Context.unsetForwardedEvent();
    }
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    ReceiveCommand magicBranchCmd = magicBranch != null ? magicBranch.cmd : null;
    if (magicBranchCmd != null && magicBranchCmd.getResult() != NOT_ATTEMPTED) {
        logWarn(String.format("Skipping change updates on %s because ref update failed: %s %s", project.getName(), magicBranchCmd.getResult(), Strings.nullToEmpty(magicBranchCmd.getMessage())));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, project.getNameKey(), user.materializedCopy(), TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        bu.setRefLogMessage("push");
        logDebug("Adding {} replace requests", newChanges.size());
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.addOps(bu, replaceProgress);
        }
        logDebug("Adding {} create requests", newChanges.size());
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        logDebug("Adding {} group update requests", newChanges.size());
        updateGroups.forEach(r -> r.addOps(bu));
        logDebug("Adding {} additional ref updates", actualCommands.size());
        actualCommands.forEach(c -> bu.addRepoOnlyOp(new UpdateOneRefOp(c)));
        logDebug("Executing batch");
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        if (magicBranchCmd != null) {
            magicBranchCmd.setResult(OK);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage == null) {
                if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
                    // Not necessarily the magic branch, so need to set OK on the original value.
                    replace.inputCommand.setResult(OK);
                }
            } else {
                logDebug("Rejecting due to message from ReplaceOp");
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranchCmd, "conflict");
    } catch (RestApiException | IOException err) {
        logError("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranchCmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranchCmd, "conflict");
        } catch (RestApiException | OrmException | UpdateException | IOException | ConfigInvalidException e) {
            logError("Error submitting changes to " + project.getName(), e);
            reject(magicBranchCmd, "error during submit");
        }
    }
}
#method_after
private void insertChangesAndPatchSets() {
    ReceiveCommand magicBranchCmd = magicBranch != null ? magicBranch.cmd : null;
    if (magicBranchCmd != null && magicBranchCmd.getResult() != NOT_ATTEMPTED) {
        logWarn(String.format("Skipping change updates on %s because ref update failed: %s %s", project.getName(), magicBranchCmd.getResult(), Strings.nullToEmpty(magicBranchCmd.getMessage())));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, project.getNameKey(), user.materializedCopy(), TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        bu.setRefLogMessage("push");
        logDebug("Adding {} replace requests", newChanges.size());
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.addOps(bu, replaceProgress);
        }
        logDebug("Adding {} create requests", newChanges.size());
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        logDebug("Adding {} group update requests", newChanges.size());
        updateGroups.forEach(r -> r.addOps(bu));
        logDebug("Adding {} additional ref updates", actualCommands.size());
        actualCommands.forEach(c -> bu.addRepoOnlyOp(new UpdateOneRefOp(c)));
        logDebug("Executing batch");
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        if (magicBranchCmd != null) {
            magicBranchCmd.setResult(OK);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage == null) {
                if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
                    // Not necessarily the magic branch, so need to set OK on the original value.
                    replace.inputCommand.setResult(OK);
                }
            } else {
                logDebug("Rejecting due to message from ReplaceOp");
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranchCmd, "conflict");
    } catch (RestApiException | IOException err) {
        logError("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranchCmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranchCmd, "conflict");
        } catch (RestApiException | OrmException | UpdateException | IOException | ConfigInvalidException | PermissionBackendException e) {
            logError("Error submitting changes to " + project.getName(), e);
            reject(magicBranchCmd, "error during submit");
        }
    }
}
#end_block

#method_before
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException, UpdateException, IOException, ConfigInvalidException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commit, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.notes.getChange());
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkNotNull(tipChange, "tip of push does not correspond to a change; found these changes: %s", bySha);
    logDebug("Processing submit with tip change {} ({})", tipChange.getId(), magicBranch.cmd.getNewId());
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput(), false);
    }
}
#method_after
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException, UpdateException, IOException, ConfigInvalidException, PermissionBackendException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commit, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.notes.getChange());
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkNotNull(tipChange, "tip of push does not correspond to a change; found these changes: %s", bySha);
    logDebug("Processing submit with tip change {} ({})", tipChange.getId(), magicBranch.cmd.getNewId());
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput(), false);
    }
}
#end_block

#method_before
private void newPatchSet() throws IOException {
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    psId = ChangeUtil.nextPatchSetIdFromAllRefsMap(allRefs, notes.getChange().currentPatchSetId());
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, psId);
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, psId.toRefName());
}
#method_after
private void newPatchSet() throws IOException, OrmException {
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    psId = ChangeUtil.nextPatchSetIdFromAllRefsMap(allRefs, notes.getChange().currentPatchSetId());
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, psId);
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, psId.toRefName());
}
#end_block

#method_before
@Override
public void advertiseRefs(BaseReceivePack rp) throws ServiceMayNotContinueException {
    Map<String, Ref> oldRefs = rp.getAdvertisedRefs();
    checkState(oldRefs != null, "expected refs to previously be advertised; %s assumes it is not the first %s in the chain", getClass().getSimpleName(), AdvertiseRefsHook.class.getSimpleName());
    Result r = advertiseRefs(oldRefs);
    rp.setAdvertisedRefs(r.allRefs(), r.additionalHaves());
}
#method_after
@Override
public void advertiseRefs(BaseReceivePack rp) throws ServiceMayNotContinueException {
    Result r = advertiseRefs(HookUtil.ensureAllRefsAdvertised(rp));
    rp.setAdvertisedRefs(r.allRefs(), r.additionalHaves());
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException, ServletException {
    doPost(req, rsp);
}
#method_after
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException, ServletException {
    doPost(req, rsp);
}
#end_block

#method_before
@Override
protected void doPost(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException, ServletException {
    CacheHeaders.setNotCacheable(rsp);
    final AuthResult res;
    if ("create_account".equals(req.getParameter("action"))) {
        res = create();
    } else if (req.getParameter("user_name") != null) {
        res = byUserName(req.getParameter("user_name"));
    } else if (req.getParameter("preferred_email") != null) {
        res = byPreferredEmail(req.getParameter("preferred_email"));
    } else if (req.getParameter("account_id") != null) {
        res = byAccountId(req.getParameter("account_id"));
    } else {
        byte[] raw;
        try {
            raw = prepareHtmlOutput();
        } catch (OrmException e) {
            throw new ServletException(e);
        }
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding(HtmlDomUtil.ENC.name());
        rsp.setContentLength(raw.length);
        try (OutputStream out = rsp.getOutputStream()) {
            out.write(raw);
        }
        return;
    }
    if (res != null) {
        webSession.get().login(res, false);
        final StringBuilder rdr = new StringBuilder();
        rdr.append(req.getContextPath());
        rdr.append("/");
        if (res.isNew()) {
            rdr.append('#' + PageLinks.REGISTER);
        } else {
            rdr.append(LoginUrlToken.getToken(req));
        }
        rsp.sendRedirect(rdr.toString());
    } else {
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding(HtmlDomUtil.ENC.name());
        try (Writer out = rsp.getWriter()) {
            out.write("<html>");
            out.write("<body>");
            out.write("<h1>Account Not Found</h1>");
            out.write("</body>");
            out.write("</html>");
        }
    }
}
#method_after
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse rsp) throws IOException, ServletException {
    CacheHeaders.setNotCacheable(rsp);
    final AuthResult res;
    if ("create_account".equals(req.getParameter("action"))) {
        res = create();
    } else if (req.getParameter("user_name") != null) {
        res = byUserName(req.getParameter("user_name"));
    } else if (req.getParameter("preferred_email") != null) {
        res = byPreferredEmail(req.getParameter("preferred_email"));
    } else if (req.getParameter("account_id") != null) {
        res = byAccountId(req.getParameter("account_id"));
    } else {
        byte[] raw;
        try {
            raw = prepareHtmlOutput();
        } catch (OrmException e) {
            throw new ServletException(e);
        }
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding(HtmlDomUtil.ENC.name());
        rsp.setContentLength(raw.length);
        try (OutputStream out = rsp.getOutputStream()) {
            out.write(raw);
        }
        return;
    }
    if (res != null) {
        webSession.get().login(res, false);
        final StringBuilder rdr = new StringBuilder();
        rdr.append(req.getContextPath());
        rdr.append("/");
        if (res.isNew()) {
            rdr.append('#' + PageLinks.REGISTER);
        } else {
            rdr.append(LoginUrlToken.getToken(req));
        }
        rsp.sendRedirect(rdr.toString());
    } else {
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding(HtmlDomUtil.ENC.name());
        try (Writer out = rsp.getWriter()) {
            out.write("<html>");
            out.write("<body>");
            out.write("<h1>Account Not Found</h1>");
            out.write("</body>");
            out.write("</html>");
        }
    }
}
#end_block

#method_before
private byte[] prepareHtmlOutput() throws IOException, OrmException {
    final String pageName = "BecomeAnyAccount.html";
    Document doc = headers.parse(getClass(), pageName);
    if (doc == null) {
        throw new FileNotFoundException("No " + pageName + " in webapp");
    }
    Element userlistElement = HtmlDomUtil.find(doc, "userlist");
    try (ReviewDb db = schema.open()) {
        ResultSet<Account> accounts = db.accounts().firstNById(100);
        for (Account a : accounts) {
            String displayName;
            if (a.getUserName() != null) {
                displayName = a.getUserName();
            } else if (a.getFullName() != null && !a.getFullName().isEmpty()) {
                displayName = a.getFullName();
            } else if (a.getPreferredEmail() != null) {
                displayName = a.getPreferredEmail();
            } else {
                displayName = a.getId().toString();
            }
            Element linkElement = doc.createElement("a");
            linkElement.setAttribute("href", "?account_id=" + a.getId().toString());
            linkElement.setTextContent(displayName);
            userlistElement.appendChild(linkElement);
            userlistElement.appendChild(doc.createElement("br"));
        }
    }
    return HtmlDomUtil.toUTF8(doc);
}
#method_after
private byte[] prepareHtmlOutput() throws IOException, OrmException {
    final String pageName = "BecomeAnyAccount.html";
    Document doc = headers.parse(getClass(), pageName);
    if (doc == null) {
        throw new FileNotFoundException("No " + pageName + " in webapp");
    }
    Element userlistElement = HtmlDomUtil.find(doc, "userlist");
    try (ReviewDb db = schema.open()) {
        for (Account.Id accountId : accounts.firstNIds(100)) {
            Account a = accountCache.get(accountId).getAccount();
            String displayName;
            if (a.getUserName() != null) {
                displayName = a.getUserName();
            } else if (a.getFullName() != null && !a.getFullName().isEmpty()) {
                displayName = a.getFullName();
            } else if (a.getPreferredEmail() != null) {
                displayName = a.getPreferredEmail();
            } else {
                displayName = accountId.toString();
            }
            Element linkElement = doc.createElement("a");
            linkElement.setAttribute("href", "?account_id=" + a.getId().toString());
            linkElement.setTextContent(displayName);
            userlistElement.appendChild(linkElement);
            userlistElement.appendChild(doc.createElement("br"));
        }
    }
    return HtmlDomUtil.toUTF8(doc);
}
#end_block

#method_before
private AuthResult auth(final Account account) {
    if (account != null) {
        return new AuthResult(account.getId(), null, false);
    }
    return null;
}
#method_after
private AuthResult auth(Account account) {
    if (account != null) {
        return new AuthResult(account.getId(), null, false);
    }
    return null;
}
#end_block

#method_before
private AuthResult byUserName(final String userName) {
    try {
        List<AccountState> accountStates = accountQuery.byExternalId(SCHEME_USERNAME, userName);
        if (accountStates.isEmpty()) {
            getServletContext().log("No accounts with username " + userName + " found");
            return null;
        }
        if (accountStates.size() > 1) {
            getServletContext().log("Multiple accounts with username " + userName + " found");
            return null;
        }
        return auth(accountStates.get(0).getAccount().getId());
    } catch (OrmException e) {
        getServletContext().log("cannot query account index", e);
        return null;
    }
}
#method_after
private AuthResult byUserName(String userName) {
    try {
        List<AccountState> accountStates = accountQuery.byExternalId(SCHEME_USERNAME, userName);
        if (accountStates.isEmpty()) {
            getServletContext().log("No accounts with username " + userName + " found");
            return null;
        }
        if (accountStates.size() > 1) {
            getServletContext().log("Multiple accounts with username " + userName + " found");
            return null;
        }
        return auth(accountStates.get(0).getAccount().getId());
    } catch (OrmException e) {
        getServletContext().log("cannot query account index", e);
        return null;
    }
}
#end_block

#method_before
private AuthResult byPreferredEmail(final String email) {
    Set<Account> matches = accountCache.getByPreferredEmail(email).stream().map(a -> a.getAccount()).collect(toSet());
    return matches.size() == 1 ? auth(Iterables.getOnlyElement(matches)) : null;
}
#method_after
private AuthResult byPreferredEmail(String email) {
    try (ReviewDb db = schema.open()) {
        Optional<Account> match = accountQuery.byPreferredEmail(email).stream().filter(a -> email.equalsIgnoreCase(a.getAccount().getPreferredEmail())).map(AccountState::getAccount).findFirst();
        return match.isPresent() ? auth(match.get()) : null;
    } catch (OrmException e) {
        getServletContext().log("cannot query database", e);
        return null;
    }
}
#end_block

#method_before
private AuthResult byAccountId(final String idStr) {
    final Account.Id id;
    try {
        id = Account.Id.parse(idStr);
    } catch (NumberFormatException nfe) {
        return null;
    }
    try (ReviewDb db = schema.open()) {
        return auth(db.accounts().get(id));
    } catch (OrmException e) {
        getServletContext().log("cannot query database", e);
        return null;
    }
}
#method_after
private AuthResult byAccountId(String idStr) {
    final Account.Id id;
    try {
        id = Account.Id.parse(idStr);
    } catch (NumberFormatException nfe) {
        return null;
    }
    try (ReviewDb db = schema.open()) {
        return auth(accounts.get(db, id));
    } catch (OrmException | IOException | ConfigInvalidException e) {
        getServletContext().log("cannot query database", e);
        return null;
    }
}
#end_block

#method_before
public boolean canRead(ProjectState state, Repository repo, RevCommit commit) {
    Project.NameKey project = state.getProject().getNameKey();
    // Look for changes associated with the commit.
    try {
        PermissionBackend.WithUser perm = permissionBackend.user(user).database(db);
        List<ChangeData> changes = queryProvider.get().byProjectCommit(project, commit);
        if (!perm.filterChangeData(ChangePermission.READ, changes).isEmpty()) {
            return true;
        }
    } catch (OrmException | PermissionBackendException e) {
        log.error("Cannot look up change for commit " + commit.name() + " in " + project, e);
    }
    return isReachableFrom(state, repo, commit, repo.getAllRefs());
}
#method_after
public boolean canRead(ProjectState state, Repository repo, RevCommit commit) {
    Project.NameKey project = state.getProject().getNameKey();
    // Look for changes associated with the commit.
    try {
        List<ChangeData> changes = queryProvider.get().enforceVisibility(true).byProjectCommit(project, commit);
        if (!changes.isEmpty()) {
            return true;
        }
    } catch (OrmException e) {
        log.error("Cannot look up change for commit " + commit.name() + " in " + project, e);
    }
    return isReachableFrom(state, repo, commit, repo.getAllRefs());
}
#end_block

#method_before
public boolean isReachableFrom(ProjectState state, Repository repo, RevCommit commit, Map<String, Ref> refs) {
    try (RevWalk rw = new RevWalk(repo)) {
        refs = refFilter.create(state, repo).filter(refs, true);
        return !refs.isEmpty() && IncludedInResolver.includedInOne(repo, rw, commit, refs.values());
    } catch (IOException e) {
        log.error(String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), state.getProject().getNameKey()), e);
        return false;
    }
}
#method_after
public boolean isReachableFrom(ProjectState state, Repository repo, RevCommit commit, Map<String, Ref> refs) {
    try (RevWalk rw = new RevWalk(repo)) {
        refs = refFilter.create(state, repo).filter(refs, true);
        return IncludedInResolver.includedInAny(repo, rw, commit, refs.values());
    } catch (IOException e) {
        log.error(String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), state.getProject().getNameKey()), e);
        return false;
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    repoManager = new InMemoryRepositoryManager();
    projectCache = new ProjectCache() {

        @Override
        public ProjectState getAllProjects() {
            return get(allProjectsName);
        }

        @Override
        public ProjectState getAllUsers() {
            return null;
        }

        @Override
        public ProjectState get(Project.NameKey projectName) {
            return all.get(projectName);
        }

        @Override
        public void evict(Project p) {
        }

        @Override
        public Iterable<Project.NameKey> all() {
            return Collections.emptySet();
        }

        @Override
        public Iterable<Project.NameKey> byName(String prefix) {
            return Collections.emptySet();
        }

        @Override
        public void onCreateProject(Project.NameKey newProjectName) {
        }

        @Override
        public Set<AccountGroup.UUID> guessRelevantGroupUUIDs() {
            return Collections.emptySet();
        }

        @Override
        public ProjectState checkedGet(Project.NameKey projectName) throws IOException {
            return all.get(projectName);
        }

        @Override
        public void evict(Project.NameKey p) {
        }
    };
    Injector injector = Guice.createInjector(new InMemoryModule());
    injector.injectMembers(this);
    try {
        Repository repo = repoManager.createRepository(allProjectsName);
        ProjectConfig allProjects = new ProjectConfig(new Project.NameKey(allProjectsName.get()));
        allProjects.load(repo);
        LabelType cr = Util.codeReview();
        allProjects.getLabelSections().put(cr.getName(), cr);
        add(allProjects);
    } catch (IOException | ConfigInvalidException e) {
        throw new RuntimeException(e);
    }
    db = schemaFactory.open();
    singleVersionListener.start();
    try {
        schemaCreator.create(db);
    } finally {
        singleVersionListener.stop();
    }
    Cache<SectionSortCache.EntryKey, SectionSortCache.EntryVal> c = CacheBuilder.newBuilder().build();
    sectionSorter = new PermissionCollection.Factory(new SectionSortCache(c));
    parent = new ProjectConfig(parentKey);
    parent.load(newRepository(parentKey));
    add(parent);
    local = new ProjectConfig(localKey);
    local.load(newRepository(localKey));
    add(local);
    local.getProject().setParentName(parentKey);
    requestContext.setContext(new RequestContext() {

        @Override
        public CurrentUser getUser() {
            return null;
        }

        @Override
        public Provider<ReviewDb> getReviewDbProvider() {
            return Providers.of(db);
        }
    });
    changeControlFactory = injector.getInstance(ChangeControl.Factory.class);
}
#method_after
@Before
public void setUp() throws Exception {
    repoManager = new InMemoryRepositoryManager();
    projectCache = new ProjectCache() {

        @Override
        public ProjectState getAllProjects() {
            return get(allProjectsName);
        }

        @Override
        public ProjectState getAllUsers() {
            return null;
        }

        @Override
        public ProjectState get(Project.NameKey projectName) {
            return all.get(projectName);
        }

        @Override
        public void evict(Project p) {
        }

        @Override
        public void remove(Project p) {
        }

        @Override
        public Iterable<Project.NameKey> all() {
            return Collections.emptySet();
        }

        @Override
        public Iterable<Project.NameKey> byName(String prefix) {
            return Collections.emptySet();
        }

        @Override
        public void onCreateProject(Project.NameKey newProjectName) {
        }

        @Override
        public Set<AccountGroup.UUID> guessRelevantGroupUUIDs() {
            return Collections.emptySet();
        }

        @Override
        public ProjectState checkedGet(Project.NameKey projectName) throws IOException {
            return all.get(projectName);
        }

        @Override
        public void evict(Project.NameKey p) {
        }
    };
    Injector injector = Guice.createInjector(new InMemoryModule());
    injector.injectMembers(this);
    try {
        Repository repo = repoManager.createRepository(allProjectsName);
        ProjectConfig allProjects = new ProjectConfig(new Project.NameKey(allProjectsName.get()));
        allProjects.load(repo);
        LabelType cr = Util.codeReview();
        allProjects.getLabelSections().put(cr.getName(), cr);
        add(allProjects);
    } catch (IOException | ConfigInvalidException e) {
        throw new RuntimeException(e);
    }
    db = schemaFactory.open();
    singleVersionListener.start();
    try {
        schemaCreator.create(db);
    } finally {
        singleVersionListener.stop();
    }
    Cache<SectionSortCache.EntryKey, SectionSortCache.EntryVal> c = CacheBuilder.newBuilder().build();
    sectionSorter = new PermissionCollection.Factory(new SectionSortCache(c));
    parent = new ProjectConfig(parentKey);
    parent.load(newRepository(parentKey));
    add(parent);
    local = new ProjectConfig(localKey);
    local.load(newRepository(localKey));
    add(local);
    local.getProject().setParentName(parentKey);
    requestContext.setContext(new RequestContext() {

        @Override
        public CurrentUser getUser() {
            return null;
        }

        @Override
        public Provider<ReviewDb> getReviewDbProvider() {
            return Providers.of(db);
        }
    });
    changeControlFactory = injector.getInstance(ChangeControl.Factory.class);
}
#end_block

#method_before
@Override
protected Response<ChangeInfo> applyImpl(BatchUpdate.Factory updateFactory, TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException, PermissionBackendException, ConfigInvalidException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("draft workflow is disabled");
        }
    }
    ProjectResource rsrc = projectsCollection.parse(input.project);
    checkValidCLA(rsrc.getControl());
    Project.NameKey project = rsrc.getNameKey();
    String refName = RefNames.fullName(input.branch);
    permissionBackend.user(user).project(project).ref(refName).check(RefPermission.CREATE_CHANGE);
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        ObjectId parentCommit;
        List<String> groups;
        if (input.baseChange != null) {
            List<ChangeControl> ctls = changeFinder.find(input.baseChange, rsrc.getControl().getUser());
            if (ctls.size() != 1) {
                throw new UnprocessableEntityException("Base change not found: " + input.baseChange);
            }
            ChangeControl ctl = Iterables.getOnlyElement(ctls);
            if (!ctl.isVisible(db.get())) {
                throw new UnprocessableEntityException("Base change not found: " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), ctl.getNotes());
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else {
            Ref destRef = git.getRefDatabase().exactRef(refName);
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", refName));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        AccountState account = accountCache.get(me.getAccountId());
        GeneralPreferencesInfo info = account.getAccount().getGeneralPreferencesInfo();
        ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
        ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, input.subject);
        String commitMessage = ChangeIdUtil.insertId(input.subject, id);
        if (Boolean.TRUE.equals(info.signedOffBy)) {
            commitMessage += String.format("%s%s", SIGNED_OFF_BY_TAG, account.getAccount().getNameEmail(anonymousCowardName));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            if (!(submitType.equals(SubmitType.MERGE_ALWAYS) || submitType.equals(SubmitType.MERGE_IF_NECESSARY))) {
                throw new BadRequestException("Submit type: " + submitType + " is not supported");
            }
            c = newMergeCommit(git, oi, rw, rsrc.getControl(), mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, refName);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        String topic = input.topic;
        if (topic != null) {
            topic = Strings.emptyToNull(topic.trim());
        }
        ins.setTopic(topic);
        ins.setDraft(input.status == ChangeStatus.DRAFT);
        ins.setPrivate(input.isPrivate != null && input.isPrivate);
        ins.setWorkInProgress(input.workInProgress != null && input.workInProgress);
        ins.setGroups(groups);
        ins.setNotify(input.notify);
        ins.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
        try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.noOptions();
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#method_after
@Override
protected Response<ChangeInfo> applyImpl(BatchUpdate.Factory updateFactory, TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException, PermissionBackendException, ConfigInvalidException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("draft workflow is disabled");
        }
    }
    ProjectResource rsrc = projectsCollection.parse(input.project);
    checkValidCLA(rsrc.getControl());
    Project.NameKey project = rsrc.getNameKey();
    String refName = RefNames.fullName(input.branch);
    permissionBackend.user(user).project(project).ref(refName).check(RefPermission.CREATE_CHANGE);
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        ObjectId parentCommit;
        List<String> groups;
        if (input.baseChange != null) {
            List<ChangeControl> ctls = changeFinder.find(input.baseChange, rsrc.getControl().getUser());
            if (ctls.size() != 1) {
                throw new UnprocessableEntityException("Base change not found: " + input.baseChange);
            }
            ChangeControl ctl = Iterables.getOnlyElement(ctls);
            if (!ctl.isVisible(db.get())) {
                throw new UnprocessableEntityException("Base change not found: " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), ctl.getNotes());
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else {
            Ref destRef = git.getRefDatabase().exactRef(refName);
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", refName));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        AccountState account = accountCache.get(me.getAccountId());
        GeneralPreferencesInfo info = account.getAccount().getGeneralPreferencesInfo();
        ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
        ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, input.subject);
        String commitMessage = ChangeIdUtil.insertId(input.subject, id);
        if (Boolean.TRUE.equals(info.signedOffBy)) {
            commitMessage += String.format("%s%s", SIGNED_OFF_BY_TAG, account.getAccount().getNameEmail(anonymousCowardName));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            if (!(submitType.equals(SubmitType.MERGE_ALWAYS) || submitType.equals(SubmitType.MERGE_IF_NECESSARY))) {
                throw new BadRequestException("Submit type: " + submitType + " is not supported");
            }
            c = newMergeCommit(git, oi, rw, rsrc.getControl(), mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, refName);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        String topic = input.topic;
        if (topic != null) {
            topic = Strings.emptyToNull(topic.trim());
        }
        ins.setTopic(topic);
        ins.setDraft(input.status == ChangeStatus.DRAFT);
        ins.setPrivate(input.isPrivate == null ? privateByDefault : input.isPrivate);
        ins.setWorkInProgress(input.workInProgress != null && input.workInProgress);
        ins.setGroups(groups);
        ins.setNotify(input.notify);
        ins.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
        try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.noOptions();
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
@Override
public Set<ExternalId> byAccount(Account.Id accountId) throws IOException {
    try {
        return extIdsByAccount.get(externalIdReader.readRevision()).byAccount().get(accountId);
    } catch (ExecutionException e) {
        throw new IOException("Cannot list external ids by account", e);
    }
}
#method_after
@Override
public Set<ExternalId> byAccount(Account.Id accountId) throws IOException {
    return get().byAccount().get(accountId);
}
#end_block

#method_before
@Override
public ImmutableSetMultimap<Account.Id, ExternalId> allByAccount() throws IOException {
    try {
        return extIdsByAccount.get(externalIdReader.readRevision()).byAccount();
    } catch (ExecutionException e) {
        throw new IOException("Cannot list external ids by account", e);
    }
}
#method_after
@Override
public ImmutableSetMultimap<Account.Id, ExternalId> allByAccount() throws IOException {
    return get().byAccount();
}
#end_block

#method_before
@Override
public ImmutableSetMultimap<String, ExternalId> byEmails(String... emails) throws IOException {
    try {
        AllExternalIds allExternalIds = extIdsByAccount.get(externalIdReader.readRevision());
        ImmutableSetMultimap.Builder<String, ExternalId> byEmails = ImmutableSetMultimap.builder();
        for (String email : emails) {
            byEmails.putAll(email, allExternalIds.byEmail().get(email));
        }
        return byEmails.build();
    } catch (ExecutionException e) {
        throw new IOException("Cannot list external ids by email", e);
    }
}
#method_after
@Override
public ImmutableSetMultimap<String, ExternalId> byEmails(String... emails) throws IOException {
    AllExternalIds allExternalIds = get();
    ImmutableSetMultimap.Builder<String, ExternalId> byEmails = ImmutableSetMultimap.builder();
    for (String email : emails) {
        byEmails.putAll(email, allExternalIds.byEmail().get(email));
    }
    return byEmails.build();
}
#end_block

#method_before
@Override
public ImmutableSetMultimap<String, ExternalId> allByEmail() throws IOException {
    try {
        return extIdsByAccount.get(externalIdReader.readRevision()).byEmail();
    } catch (ExecutionException e) {
        throw new IOException("Cannot list external ids by account", e);
    }
}
#method_after
@Override
public ImmutableSetMultimap<String, ExternalId> allByEmail() throws IOException {
    return get().byEmail();
}
#end_block

#method_before
private boolean insertMessage(ChangeContext ctx) throws OrmException {
    String msg = Strings.nullToEmpty(in.message).trim();
    StringBuilder buf = new StringBuilder();
    for (LabelVote d : labelDelta) {
        buf.append(" ").append(d.format());
    }
    if (comments.size() == 1) {
        buf.append("\n\n(1 comment)");
    } else if (comments.size() > 1) {
        buf.append(String.format("\n\n(%d comments)", comments.size()));
    }
    if (!msg.isEmpty()) {
        buf.append("\n\n").append(msg);
    }
    if (in.ready) {
        buf.append("\n\nThis change is ready for review.");
    }
    if (buf.length() == 0) {
        return false;
    }
    message = ChangeMessagesUtil.newMessage(psId, user, ctx.getWhen(), "Patch Set " + psId.get() + ":" + buf, in.tag);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), message);
    return true;
}
#method_after
private boolean insertMessage(ChangeContext ctx) throws OrmException {
    String msg = Strings.nullToEmpty(in.message).trim();
    StringBuilder buf = new StringBuilder();
    for (LabelVote d : labelDelta) {
        buf.append(" ").append(d.format());
    }
    if (comments.size() == 1) {
        buf.append("\n\n(1 comment)");
    } else if (comments.size() > 1) {
        buf.append(String.format("\n\n(%d comments)", comments.size()));
    }
    if (!msg.isEmpty()) {
        buf.append("\n\n").append(msg);
    } else if (in.ready) {
        buf.append("\n\n" + START_REVIEW_MESSAGE);
    }
    if (buf.length() == 0) {
        return false;
    }
    message = ChangeMessagesUtil.newMessage(psId, user, ctx.getWhen(), "Patch Set " + psId.get() + ":" + buf, in.tag);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), message);
    return true;
}
#end_block

#method_before
public List<BatchUpdate> batchUpdates(Collection<Project.NameKey> projects) throws NoSuchProjectException, IOException {
    List<BatchUpdate> updates = new ArrayList<>(projects.size());
    for (Project.NameKey project : projects) {
        updates.add(getRepo(project).getUpdate().setRefLogMessage("push"));
    }
    return updates;
}
#method_after
public List<BatchUpdate> batchUpdates(Collection<Project.NameKey> projects) throws NoSuchProjectException, IOException {
    List<BatchUpdate> updates = new ArrayList<>(projects.size());
    for (Project.NameKey project : projects) {
        updates.add(getRepo(project).getUpdate().setRefLogMessage("merged"));
    }
    return updates;
}
#end_block

#method_before
@Test
@GerritConfig(name = "plugins.allowRemoteAdmin", value = "true")
public void pluginManagement() throws Exception {
    // No plugins are loaded
    assertThat(list().get()).isEmpty();
    assertThat(list().all().get()).isEmpty();
    PluginApi api;
    // Install all the plugins
    InstallPluginInput input = new InstallPluginInput();
    input.raw = RawInputUtil.create(JS_PLUGIN_CONTENT);
    for (String plugin : PLUGINS) {
        api = gApi.plugins().install(plugin + ".js", input);
        assertThat(api).isNotNull();
        PluginInfo info = api.get();
        assertThat(info.id).isEqualTo(plugin);
        assertThat(info.disabled).isNull();
    }
    assertPlugins(list().get(), PLUGINS);
    // With pagination
    assertPlugins(list().start(1).limit(2).get(), PLUGINS.subList(1, 3));
    // With prefix
    assertPlugins(list().prefix("plugin-b").get(), ImmutableList.of("plugin-b"));
    // With substring
    assertPlugins(list().substring("lugin-").get(), PLUGINS);
    // With regex
    assertPlugins(list().regex(".*in-b").get(), ImmutableList.of("plugin-b"));
    assertPlugins(list().regex("plugin-.*").get(), PLUGINS);
    // Invalid match combinations
    assertBadRequest(list().regex(".*in-b").substring("a"));
    assertBadRequest(list().regex(".*in-b").prefix("a"));
    assertBadRequest(list().substring(".*in-b").prefix("a"));
    // Disable
    api = gApi.plugins().name("plugin-a");
    api.disable();
    api = gApi.plugins().name("plugin-a");
    assertThat(api.get().disabled).isTrue();
    assertPlugins(list().get(), PLUGINS.subList(1, PLUGINS.size()));
    assertPlugins(list().all().get(), PLUGINS);
    // Enable
    api.enable();
    api = gApi.plugins().name("plugin-a");
    assertThat(api.get().disabled).isNull();
    assertPlugins(list().get(), PLUGINS);
}
#method_after
@Test
@GerritConfig(name = "plugins.allowRemoteAdmin", value = "true")
public void pluginManagement() throws Exception {
    // No plugins are loaded
    assertThat(list().get()).isEmpty();
    assertThat(list().all().get()).isEmpty();
    PluginApi api;
    // Install all the plugins
    InstallPluginInput input = new InstallPluginInput();
    input.raw = RawInputUtil.create(JS_PLUGIN_CONTENT);
    for (String plugin : PLUGINS) {
        api = gApi.plugins().install(plugin + ".js", input);
        assertThat(api).isNotNull();
        PluginInfo info = api.get();
        assertThat(info.id).isEqualTo(plugin);
        assertThat(info.disabled).isNull();
    }
    assertPlugins(list().get(), PLUGINS);
    // With pagination
    assertPlugins(list().start(1).limit(2).get(), PLUGINS.subList(1, 3));
    // With prefix
    assertPlugins(list().prefix("plugin-b").get(), ImmutableList.of("plugin-b"));
    assertPlugins(list().prefix("PLUGIN-").get(), ImmutableList.of());
    // With substring
    assertPlugins(list().substring("lugin-").get(), PLUGINS);
    assertPlugins(list().substring("lugin-").start(1).limit(2).get(), PLUGINS.subList(1, 3));
    // With regex
    assertPlugins(list().regex(".*in-b").get(), ImmutableList.of("plugin-b"));
    assertPlugins(list().regex("plugin-.*").get(), PLUGINS);
    assertPlugins(list().regex("plugin-.*").start(1).limit(2).get(), PLUGINS.subList(1, 3));
    // Invalid match combinations
    assertBadRequest(list().regex(".*in-b").substring("a"));
    assertBadRequest(list().regex(".*in-b").prefix("a"));
    assertBadRequest(list().substring(".*in-b").prefix("a"));
    // Disable
    api = gApi.plugins().name("plugin-a");
    api.disable();
    api = gApi.plugins().name("plugin-a");
    assertThat(api.get().disabled).isTrue();
    assertPlugins(list().get(), PLUGINS.subList(1, PLUGINS.size()));
    assertPlugins(list().all().get(), PLUGINS);
    // Enable
    api.enable();
    api = gApi.plugins().name("plugin-a");
    assertThat(api.get().disabled).isNull();
    assertPlugins(list().get(), PLUGINS);
}
#end_block

#method_before
public SortedMap<String, PluginInfo> display(@Nullable PrintWriter stdout) throws BadRequestException {
    SortedMap<String, PluginInfo> output = new TreeMap<>();
    Stream<Plugin> s = Streams.stream(pluginLoader.getPlugins(all)).sorted(comparing(Plugin::getName));
    if (start > 0) {
        s = s.skip(start);
    }
    if (limit > 0) {
        s = s.limit(limit);
    }
    if (matchPrefix != null) {
        checkMatchOptions(matchSubstring == null && matchRegex == null);
        String prefix = matchPrefix.toLowerCase(Locale.US);
        s = s.filter(p -> p.getName().toLowerCase(Locale.US).startsWith(prefix));
    } else if (matchSubstring != null) {
        checkMatchOptions(matchPrefix == null && matchRegex == null);
        String substring = matchSubstring.toLowerCase(Locale.US);
        s = s.filter(p -> p.getName().toLowerCase(Locale.US).contains(substring));
    } else if (matchRegex != null) {
        checkMatchOptions(matchPrefix == null && matchSubstring == null);
        Pattern pattern = Pattern.compile(matchRegex);
        s = s.filter(p -> pattern.matcher(p.getName()).matches());
    }
    List<Plugin> plugins = s.collect(toList());
    if (!format.isJson()) {
        stdout.format("%-30s %-10s %-8s %s\n", "Name", "Version", "Status", "File");
        stdout.print("-------------------------------------------------------------------------------\n");
    }
    for (Plugin p : plugins) {
        PluginInfo info = toPluginInfo(p);
        if (format.isJson()) {
            output.put(p.getName(), info);
        } else {
            stdout.format("%-30s %-10s %-8s %s\n", p.getName(), Strings.nullToEmpty(info.version), p.isDisabled() ? "DISABLED" : "ENABLED", p.getSrcFile().getFileName());
        }
    }
    if (stdout == null) {
        return output;
    } else if (format.isJson()) {
        format.newGson().toJson(output, new TypeToken<Map<String, PluginInfo>>() {
        }.getType(), stdout);
        stdout.print('\n');
    }
    stdout.flush();
    return null;
}
#method_after
public SortedMap<String, PluginInfo> display(@Nullable PrintWriter stdout) throws BadRequestException {
    SortedMap<String, PluginInfo> output = new TreeMap<>();
    Stream<Plugin> s = Streams.stream(pluginLoader.getPlugins(all));
    if (matchPrefix != null) {
        checkMatchOptions(matchSubstring == null && matchRegex == null);
        s = s.filter(p -> p.getName().startsWith(matchPrefix));
    } else if (matchSubstring != null) {
        checkMatchOptions(matchPrefix == null && matchRegex == null);
        String substring = matchSubstring.toLowerCase(Locale.US);
        s = s.filter(p -> p.getName().toLowerCase(Locale.US).contains(substring));
    } else if (matchRegex != null) {
        checkMatchOptions(matchPrefix == null && matchSubstring == null);
        Pattern pattern = Pattern.compile(matchRegex);
        s = s.filter(p -> pattern.matcher(p.getName()).matches());
    }
    s = s.sorted(comparing(Plugin::getName));
    if (start > 0) {
        s = s.skip(start);
    }
    if (limit > 0) {
        s = s.limit(limit);
    }
    List<Plugin> plugins = s.collect(toList());
    if (!format.isJson()) {
        stdout.format("%-30s %-10s %-8s %s\n", "Name", "Version", "Status", "File");
        stdout.print("-------------------------------------------------------------------------------\n");
    }
    for (Plugin p : plugins) {
        PluginInfo info = toPluginInfo(p);
        if (format.isJson()) {
            output.put(p.getName(), info);
        } else {
            stdout.format("%-30s %-10s %-8s %s\n", p.getName(), Strings.nullToEmpty(info.version), p.isDisabled() ? "DISABLED" : "ENABLED", p.getSrcFile().getFileName());
        }
    }
    if (stdout == null) {
        return output;
    } else if (format.isJson()) {
        format.newGson().toJson(output, new TypeToken<Map<String, PluginInfo>>() {
        }.getType(), stdout);
        stdout.print('\n');
    }
    stdout.flush();
    return null;
}
#end_block

#method_before
private ChangeInfo checkOnly(ChangeData cd) {
    ChangeControl ctl;
    try {
        ctl = cd.changeControl().forUser(userProvider.get());
    } catch (OrmException e) {
        String msg = "Error loading change";
        log.warn(msg + " " + cd.getId(), e);
        ChangeInfo info = new ChangeInfo();
        info._number = cd.getId().get();
        ProblemInfo p = new ProblemInfo();
        p.message = msg;
        info.problems = Lists.newArrayList(p);
        return info;
    }
    ConsistencyChecker.Result result = checkerProvider.get().check(ctl, fix);
    ChangeInfo info;
    Change c = result.change();
    if (c != null) {
        info = new ChangeInfo();
        info.project = c.getProject().get();
        info.branch = c.getDest().getShortName();
        info.topic = c.getTopic();
        info.changeId = c.getKey().get();
        info.subject = c.getSubject();
        info.status = c.getStatus().asChangeStatus();
        info.owner = new AccountInfo(c.getOwner().get());
        info.created = c.getCreatedOn();
        info.updated = c.getLastUpdatedOn();
        info._number = c.getId().get();
        info.problems = result.problems();
        info.isPrivate = c.isPrivate() ? true : null;
        info.workInProgress = c.isWorkInProgress() ? true : null;
        info.hasReviewStarted = c.hasReviewStarted();
        info.revertOf = c.getRevertOf() != null ? c.getRevertOf().get() : null;
        finish(info);
    } else {
        info = new ChangeInfo();
        info._number = result.id().get();
        info.problems = result.problems();
    }
    return info;
}
#method_after
private ChangeInfo checkOnly(ChangeData cd) {
    ChangeControl ctl;
    try {
        ctl = cd.changeControl().forUser(userProvider.get());
    } catch (OrmException e) {
        String msg = "Error loading change";
        log.warn(msg + " " + cd.getId(), e);
        ChangeInfo info = new ChangeInfo();
        info._number = cd.getId().get();
        ProblemInfo p = new ProblemInfo();
        p.message = msg;
        info.problems = Lists.newArrayList(p);
        return info;
    }
    ConsistencyChecker.Result result = checkerProvider.get().check(ctl, fix);
    ChangeInfo info;
    Change c = result.change();
    if (c != null) {
        info = new ChangeInfo();
        info.project = c.getProject().get();
        info.branch = c.getDest().getShortName();
        info.topic = c.getTopic();
        info.changeId = c.getKey().get();
        info.subject = c.getSubject();
        info.status = c.getStatus().asChangeStatus();
        info.owner = new AccountInfo(c.getOwner().get());
        info.created = c.getCreatedOn();
        info.updated = c.getLastUpdatedOn();
        info._number = c.getId().get();
        info.problems = result.problems();
        info.isPrivate = c.isPrivate() ? true : null;
        info.workInProgress = c.isWorkInProgress() ? true : null;
        info.hasReviewStarted = c.hasReviewStarted();
        finish(info);
    } else {
        info = new ChangeInfo();
        info._number = result.id().get();
        info.problems = result.problems();
    }
    return info;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException, PermissionBackendException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    PermissionBackend.ForChange perm = permissionBackend.user(user).database(db).change(cd);
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate() ? true : null;
    out.workInProgress = in.isWorkInProgress() ? true : null;
    out.hasReviewStarted = in.hasReviewStarted();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        out.muted = stars.contains(StarredChangesUtil.MUTE_LABEL + "/" + cd.currentPatchSet().getPatchSetId()) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        if (out.muted != null) {
            out.reviewed = true;
        } else {
            out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
        }
    }
    out.labels = labelsFor(perm, ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    out.plugins = pluginDefinedAttributesFactory != null ? pluginDefinedAttributesFactory.create(cd) : null;
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (user.isIdentifiedUser() && (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId()))) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(perm, cd) : ImmutableMap.of();
        }
        out.reviewers = reviewerMap(cd.reviewers(), cd.reviewersByEmail(), false);
        out.pendingReviewers = reviewerMap(cd.pendingReviewers(), cd.pendingReviewersByEmail(), true);
        out.removableReviewers = removableReviewers(ctl, out);
        // TODO(hiesel) Replace with a call to ChangeData where the value was reconstructed from the
        // index.
        out.revertOf = cd.change().getRevertOf() != null ? cd.change().getRevertOf().get() : null;
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException, PermissionBackendException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    PermissionBackend.ForChange perm = permissionBackend.user(user).database(db).change(cd);
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate() ? true : null;
    out.workInProgress = in.isWorkInProgress() ? true : null;
    out.hasReviewStarted = in.hasReviewStarted();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        out.muted = stars.contains(StarredChangesUtil.MUTE_LABEL + "/" + cd.currentPatchSet().getPatchSetId()) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        if (out.muted != null) {
            out.reviewed = true;
        } else {
            out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
        }
    }
    out.labels = labelsFor(perm, ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    out.plugins = pluginDefinedAttributesFactory != null ? pluginDefinedAttributesFactory.create(cd) : null;
    out.revertOf = cd.change().getRevertOf() != null ? cd.change().getRevertOf().get() : null;
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (user.isIdentifiedUser() && (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId()))) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(perm, cd) : ImmutableMap.of();
        }
        out.reviewers = reviewerMap(cd.reviewers(), cd.reviewersByEmail(), false);
        out.pendingReviewers = reviewerMap(cd.pendingReviewers(), cd.pendingReviewersByEmail(), true);
        out.removableReviewers = removableReviewers(ctl, out);
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
@Test
public void reviewAndStartReview() throws Exception {
    PushOneCommit.Result r = createWorkInProgressChange();
    r.assertOkStatus();
    assertThat(r.getChange().change().isWorkInProgress()).isTrue();
    ReviewInput in = ReviewInput.noScore().setWorkInProgress(false);
    gApi.changes().id(r.getChangeId()).revision("current").review(in);
    ChangeInfo info = gApi.changes().id(r.getChangeId()).get();
    assertThat(info.workInProgress).isNull();
}
#method_after
@Test
public void reviewAndStartReview() throws Exception {
    PushOneCommit.Result r = createWorkInProgressChange();
    r.assertOkStatus();
    assertThat(r.getChange().change().isWorkInProgress()).isTrue();
    ReviewInput in = ReviewInput.noScore().setWorkInProgress(false);
    ReviewResult result = gApi.changes().id(r.getChangeId()).revision("current").review(in);
    assertThat(result.ready).isTrue();
    ChangeInfo info = gApi.changes().id(r.getChangeId()).get();
    assertThat(info.workInProgress).isNull();
}
#end_block

#method_before
@Test
public void reviewAndMoveToWorkInProgress() throws Exception {
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    assertThat(r.getChange().change().isWorkInProgress()).isFalse();
    ReviewInput in = ReviewInput.noScore().setWorkInProgress(true);
    gApi.changes().id(r.getChangeId()).revision("current").review(in);
    ChangeInfo info = gApi.changes().id(r.getChangeId()).get();
    assertThat(info.workInProgress).isTrue();
}
#method_after
@Test
public void reviewAndMoveToWorkInProgress() throws Exception {
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    assertThat(r.getChange().change().isWorkInProgress()).isFalse();
    ReviewInput in = ReviewInput.noScore().setWorkInProgress(true);
    ReviewResult result = gApi.changes().id(r.getChangeId()).revision("current").review(in);
    assertThat(result.ready).isNull();
    ChangeInfo info = gApi.changes().id(r.getChangeId()).get();
    assertThat(info.workInProgress).isTrue();
}
#end_block

#method_before
@Test
public void revert() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo revertChange = gApi.changes().id(r.getChangeId()).revert().get();
    // expected messages on source change:
    // 1. Uploaded patch set 1.
    // 2. Patch Set 1: Code-Review+2
    // 3. Change has been successfully merged by Administrator
    // 4. Patch Set 1: Reverted
    List<ChangeMessageInfo> sourceMessages = new ArrayList<>(gApi.changes().id(r.getChangeId()).get().messages);
    assertThat(sourceMessages).hasSize(4);
    String expectedMessage = String.format("Created a revert of this change as %s", revertChange.changeId);
    assertThat(sourceMessages.get(3).message).isEqualTo(expectedMessage);
    assertThat(revertChange.messages).hasSize(1);
    assertThat(revertChange.messages.iterator().next().message).isEqualTo("Uploaded patch set 1.");
    assertThat(revertChange.revertOf).isEqualTo(r.getChange().getId().get());
}
#method_after
@Test
public void revert() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo revertChange = gApi.changes().id(r.getChangeId()).revert().get();
    // expected messages on source change:
    // 1. Uploaded patch set 1.
    // 2. Patch Set 1: Code-Review+2
    // 3. Change has been successfully merged by Administrator
    // 4. Patch Set 1: Reverted
    List<ChangeMessageInfo> sourceMessages = new ArrayList<>(gApi.changes().id(r.getChangeId()).get().messages);
    assertThat(sourceMessages).hasSize(4);
    String expectedMessage = String.format("Created a revert of this change as %s", revertChange.changeId);
    assertThat(sourceMessages.get(3).message).isEqualTo(expectedMessage);
    assertThat(revertChange.messages).hasSize(1);
    assertThat(revertChange.messages.iterator().next().message).isEqualTo("Uploaded patch set 1.");
    assertThat(revertChange.revertOf).isEqualTo(gApi.changes().id(r.getChangeId()).get()._number);
}
#end_block

#method_before
private void testRebase(Rebase rebase) throws Exception {
    // Create two changes both with the same parent
    PushOneCommit.Result r = createChange();
    testRepo.reset("HEAD~1");
    PushOneCommit.Result r2 = createChange();
    // Approve and submit the first change
    RevisionApi revision = gApi.changes().id(r.getChangeId()).current();
    revision.review(ReviewInput.approve());
    revision.submit();
    // Add an approval whose score should be copied on trivial rebase
    gApi.changes().id(r2.getChangeId()).current().review(ReviewInput.recommend());
    String changeId = r2.getChangeId();
    // Rebase the second change
    rebase.call(changeId);
    // Second change should have 2 patch sets and an approval
    ChangeInfo c2 = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.DETAILED_LABELS));
    assertThat(c2.revisions.get(c2.currentRevision)._number).isEqualTo(2);
    // ...and the committer and description should be correct
    ChangeInfo info = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT));
    GitPerson committer = info.revisions.get(info.currentRevision).commit.committer;
    assertThat(committer.name).isEqualTo(admin.fullName);
    assertThat(committer.email).isEqualTo(admin.email);
    String description = info.revisions.get(info.currentRevision).description;
    assertThat(description).isEqualTo("Rebase");
    // ...and the approval was copied
    LabelInfo cr = c2.labels.get("Code-Review");
    assertThat(cr).isNotNull();
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).value).isEqualTo(1);
    if (notesMigration.changePrimaryStorage() == PrimaryStorage.REVIEW_DB) {
        // Ensure record was actually copied under ReviewDb
        List<PatchSetApproval> psas = db.patchSetApprovals().byPatchSet(new PatchSet.Id(new Change.Id(c2._number), 2)).toList();
        assertThat(psas).hasSize(1);
        assertThat(psas.get(0).getValue()).isEqualTo((short) 1);
    }
    // Rebasing the second change again should fail
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Change is already up to date");
    gApi.changes().id(changeId).current().rebase();
}
#method_after
private void testRebase(Rebase rebase) throws Exception {
    // Create two changes both with the same parent
    PushOneCommit.Result r = createChange();
    testRepo.reset("HEAD~1");
    PushOneCommit.Result r2 = createChange();
    // Approve and submit the first change
    RevisionApi revision = gApi.changes().id(r.getChangeId()).current();
    revision.review(ReviewInput.approve());
    revision.submit();
    // Add an approval whose score should be copied on trivial rebase
    gApi.changes().id(r2.getChangeId()).current().review(ReviewInput.recommend());
    String changeId = r2.getChangeId();
    // Rebase the second change
    rebase.call(changeId);
    // Second change should have 2 patch sets and an approval
    ChangeInfo c2 = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.DETAILED_LABELS));
    assertThat(c2.revisions.get(c2.currentRevision)._number).isEqualTo(2);
    // ...and the committer and description should be correct
    ChangeInfo info = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT));
    GitPerson committer = info.revisions.get(info.currentRevision).commit.committer;
    assertThat(committer.name).isEqualTo(admin.fullName);
    assertThat(committer.email).isEqualTo(admin.email);
    String description = info.revisions.get(info.currentRevision).description;
    assertThat(description).isEqualTo("Rebase");
    // ...and the approval was copied
    LabelInfo cr = c2.labels.get("Code-Review");
    assertThat(cr).isNotNull();
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).value).isEqualTo(1);
    if (notesMigration.changePrimaryStorage() == PrimaryStorage.REVIEW_DB) {
        // Ensure record was actually copied under ReviewDb
        List<PatchSetApproval> psas = unwrapDb(db).patchSetApprovals().byPatchSet(new PatchSet.Id(new Change.Id(c2._number), 2)).toList();
        assertThat(psas).hasSize(1);
        assertThat(psas.get(0).getValue()).isEqualTo((short) 1);
    }
    // Rebasing the second change again should fail
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Change is already up to date");
    gApi.changes().id(changeId).current().rebase();
}
#end_block

#method_before
@Test
public void addReviewerThatIsInactiveEmailFallback() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    ConfigInput conf = new ConfigInput();
    conf.enableReviewerByEmail = InheritableBoolean.TRUE;
    gApi.projects().name(project.get()).config(conf);
    PushOneCommit.Result result = createChange();
    String username = "user@domain.com";
    gApi.accounts().create(username).setActive(false);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = username;
    in.state = ReviewerState.CC;
    AddReviewerResult r = gApi.changes().id(result.getChangeId()).addReviewer(in);
    assertThat(r.input).isEqualTo(username);
    assertThat(r.error).isNull();
    // When adding by email, the reviewers field is also empty because we can't
    // render a ReviewerInfo object for a non-account.
    assertThat(r.reviewers).isNull();
}
#method_after
@Test
public void addReviewerThatIsInactiveEmailFallback() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    ConfigInput conf = new ConfigInput();
    conf.enableReviewerByEmail = InheritableBoolean.TRUE;
    gApi.projects().name(project.get()).config(conf);
    PushOneCommit.Result result = createChange();
    String username = "user@domain.com";
    gApi.accounts().create(username).setActive(false);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = username;
    in.state = ReviewerState.CC;
    AddReviewerResult r = gApi.changes().id(result.getChangeId()).addReviewer(in);
    assertThat(r.input).isEqualTo(username);
    assertThat(r.error).isNull();
    // When adding by email, the reviewers field is also empty because we can't
    // render a ReviewerInfo object for a non-account.
    assertThat(r.reviewers).isNull();
}
#end_block

#method_before
@Test
public void addReviewerWithNoteDbWhenDummyApprovalInReviewDbExists() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    assume().that(notesMigration.changePrimaryStorage()).isEqualTo(PrimaryStorage.REVIEW_DB);
    PushOneCommit.Result r = createChange();
    // insert dummy approval in ReviewDb
    PatchSetApproval psa = new PatchSetApproval(new PatchSetApproval.Key(r.getPatchSetId(), user.id, new LabelId("Code-Review")), (short) 0, TimeUtil.nowTs());
    db.patchSetApprovals().insert(Collections.singleton(psa));
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
}
#method_after
@Test
public void addReviewerWithNoteDbWhenDummyApprovalInReviewDbExists() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    assume().that(notesMigration.changePrimaryStorage()).isEqualTo(PrimaryStorage.REVIEW_DB);
    PushOneCommit.Result r = createChange();
    // insert dummy approval in ReviewDb
    PatchSetApproval psa = new PatchSetApproval(new PatchSetApproval.Key(r.getPatchSetId(), user.id, new LabelId("Code-Review")), (short) 0, TimeUtil.nowTs());
    db.patchSetApprovals().insert(Collections.singleton(psa));
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
}
#end_block

#method_before
@Test
public void check() throws Exception {
    // TODO(dborowitz): Re-enable when ConsistencyChecker supports NoteDb.
    assume().that(notesMigration.enabled()).isFalse();
    PushOneCommit.Result r = createChange();
    assertThat(gApi.changes().id(r.getChangeId()).get().problems).isNull();
    assertThat(gApi.changes().id(r.getChangeId()).get(EnumSet.of(ListChangesOption.CHECK)).problems).isEmpty();
}
#method_after
@Test
public void check() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(gApi.changes().id(r.getChangeId()).get().problems).isNull();
    assertThat(gApi.changes().id(r.getChangeId()).get(EnumSet.of(ListChangesOption.CHECK)).problems).isEmpty();
}
#end_block

#method_before
public List<ChangeNotes> create(ReviewDb db, Collection<Change.Id> changeIds) throws OrmException {
    List<ChangeNotes> notes = new ArrayList<>();
    if (args.migration.enabled()) {
        for (Change.Id changeId : changeIds) {
            try {
                notes.add(createChecked(changeId));
            } catch (NoSuchChangeException e) {
            // Ignore missing changes to match Access#get(Iterable) behavior.
            }
        }
        return notes;
    }
    for (Change c : ReviewDbUtil.unwrapDb(db).changes().get(changeIds)) {
        notes.add(createFromChangeOnlyWhenNoteDbDisabled(c));
    }
    return notes;
}
#method_after
public List<ChangeNotes> create(ReviewDb db, Collection<Change.Id> changeIds) throws OrmException {
    List<ChangeNotes> notes = new ArrayList<>();
    if (args.migration.readChanges()) {
        for (Change.Id changeId : changeIds) {
            try {
                notes.add(createChecked(changeId));
            } catch (NoSuchChangeException e) {
            // Ignore missing changes to match Access#get(Iterable) behavior.
            }
        }
        return notes;
    }
    for (Change c : ReviewDbUtil.unwrapDb(db).changes().get(changeIds)) {
        notes.add(createFromChangeOnlyWhenNoteDbDisabled(c));
    }
    return notes;
}
#end_block

#method_before
public List<ChangeNotes> create(ReviewDb db, Project.NameKey project, Collection<Change.Id> changeIds, Predicate<ChangeNotes> predicate) throws OrmException {
    List<ChangeNotes> notes = new ArrayList<>();
    if (args.migration.enabled()) {
        for (Change.Id cid : changeIds) {
            try {
                ChangeNotes cn = create(db, project, cid);
                if (cn.getChange() != null && predicate.test(cn)) {
                    notes.add(cn);
                }
            } catch (NoSuchChangeException e) {
                // a dangling patch set ref or something.
                continue;
            }
        }
        return notes;
    }
    for (Change c : ReviewDbUtil.unwrapDb(db).changes().get(changeIds)) {
        if (c != null && project.equals(c.getDest().getParentKey())) {
            ChangeNotes cn = createFromChangeOnlyWhenNoteDbDisabled(c);
            if (predicate.test(cn)) {
                notes.add(cn);
            }
        }
    }
    return notes;
}
#method_after
public List<ChangeNotes> create(ReviewDb db, Project.NameKey project, Collection<Change.Id> changeIds, Predicate<ChangeNotes> predicate) throws OrmException {
    List<ChangeNotes> notes = new ArrayList<>();
    if (args.migration.readChanges()) {
        for (Change.Id cid : changeIds) {
            try {
                ChangeNotes cn = create(db, project, cid);
                if (cn.getChange() != null && predicate.test(cn)) {
                    notes.add(cn);
                }
            } catch (NoSuchChangeException e) {
                // a dangling patch set ref or something.
                continue;
            }
        }
        return notes;
    }
    for (Change c : ReviewDbUtil.unwrapDb(db).changes().get(changeIds)) {
        if (c != null && project.equals(c.getDest().getParentKey())) {
            ChangeNotes cn = createFromChangeOnlyWhenNoteDbDisabled(c);
            if (predicate.test(cn)) {
                notes.add(cn);
            }
        }
    }
    return notes;
}
#end_block

#method_before
public void setRevertOf(int revertOf) {
    int ownId = getChange().getId().get();
    checkArgument(ownId != revertOf, "A change cannot revert itself.");
    this.revertOf = revertOf;
}
#method_after
public void setRevertOf(int revertOf) {
    int ownId = getChange().getId().get();
    checkArgument(ownId != revertOf, "A change cannot revert itself");
    this.revertOf = revertOf;
    rootOnly = true;
}
#end_block

#method_before
private ChangeNotesState buildState() {
    return ChangeNotesState.create(tip.copy(), id, new Change.Key(changeId), createdOn, lastUpdatedOn, ownerId, branch, buildCurrentPatchSetId(), subject, topic, originalSubject, submissionId, assignee != null ? assignee.orElse(null) : null, status, Sets.newLinkedHashSet(Lists.reverse(pastAssignees)), hashtags, patchSets, buildApprovals(), ReviewerSet.fromTable(Tables.transpose(reviewers)), ReviewerByEmailSet.fromTable(Tables.transpose(reviewersByEmail)), pendingReviewers, pendingReviewersByEmail, allPastReviewers, buildReviewerUpdates(), submitRecords, buildAllMessages(), buildMessagesByPatchSet(), comments, readOnlyUntil, isPrivate, workInProgress, hasReviewStarted, revertOf != null ? new Change.Id(revertOf) : null);
}
#method_after
private ChangeNotesState buildState() {
    return ChangeNotesState.create(tip.copy(), id, new Change.Key(changeId), createdOn, lastUpdatedOn, ownerId, branch, buildCurrentPatchSetId(), subject, topic, originalSubject, submissionId, assignee != null ? assignee.orElse(null) : null, status, Sets.newLinkedHashSet(Lists.reverse(pastAssignees)), hashtags, patchSets, buildApprovals(), ReviewerSet.fromTable(Tables.transpose(reviewers)), ReviewerByEmailSet.fromTable(Tables.transpose(reviewersByEmail)), pendingReviewers, pendingReviewersByEmail, allPastReviewers, buildReviewerUpdates(), submitRecords, buildAllMessages(), buildMessagesByPatchSet(), comments, readOnlyUntil, isPrivate, workInProgress, hasReviewStarted, revertOf);
}
#end_block

#method_before
private Integer parseRevertOf(ChangeNotesCommit commit) throws ConfigInvalidException {
    String footer = parseOneFooter(commit, FOOTER_REVERT_OF);
    if (footer == null) {
        return null;
    }
    return Ints.tryParse(footer);
}
#method_after
private Change.Id parseRevertOf(ChangeNotesCommit commit) throws ConfigInvalidException {
    String footer = parseOneFooter(commit, FOOTER_REVERT_OF);
    if (footer == null) {
        return null;
    }
    Integer revertOf = Ints.tryParse(footer);
    if (revertOf == null) {
        throw invalidFooter(FOOTER_REVERT_OF, footer);
    }
    return new Change.Id(revertOf);
}
#end_block

#method_before
private void copyNonConstructorColumnsTo(Change change) {
    ChangeColumns c = checkNotNull(columns(), "columns are required");
    if (c.status() != null) {
        change.setStatus(c.status());
    }
    change.setTopic(Strings.emptyToNull(c.topic()));
    change.setLastUpdatedOn(c.lastUpdatedOn());
    change.setSubmissionId(c.submissionId());
    change.setAssignee(c.assignee());
    change.setPrivate(c.isPrivate() == null ? false : c.isPrivate());
    change.setWorkInProgress(c.isWorkInProgress() == null ? false : c.isWorkInProgress());
    change.setReviewStarted(c.hasReviewStarted() == null ? false : c.hasReviewStarted());
    if (!patchSets().isEmpty()) {
        change.setCurrentPatchSet(c.currentPatchSetId(), c.subject(), c.originalSubject());
    } else {
        // TODO(dborowitz): This should be an error, but for now it's required for
        // some tests to pass.
        change.clearCurrentPatchSet();
    }
}
#method_after
private void copyNonConstructorColumnsTo(Change change) {
    ChangeColumns c = checkNotNull(columns(), "columns are required");
    if (c.status() != null) {
        change.setStatus(c.status());
    }
    change.setTopic(Strings.emptyToNull(c.topic()));
    change.setLastUpdatedOn(c.lastUpdatedOn());
    change.setSubmissionId(c.submissionId());
    change.setAssignee(c.assignee());
    change.setPrivate(c.isPrivate() == null ? false : c.isPrivate());
    change.setWorkInProgress(c.isWorkInProgress() == null ? false : c.isWorkInProgress());
    change.setReviewStarted(c.hasReviewStarted() == null ? false : c.hasReviewStarted());
    change.setRevertOf(c.revertOf());
    if (!patchSets().isEmpty()) {
        change.setCurrentPatchSet(c.currentPatchSetId(), c.subject(), c.originalSubject());
    } else {
        // TODO(dborowitz): This should be an error, but for now it's required for
        // some tests to pass.
        change.clearCurrentPatchSet();
    }
}
#end_block

#method_before
public void setRevertOf(Change.Id revertOf) {
    this.revertOf = revertOf;
}
#method_after
public void setRevertOf(Id revertOf) {
    this.revertOf = revertOf;
}
#end_block

#method_before
@Test
public void setRevertOfPersistsValue() throws Exception {
    Change c = newChange();
    Change changeToRevert = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setRevertOf(changeToRevert.getChangeId());
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getRevertOf()).isEqualTo(changeToRevert.getId());
}
#method_after
@Test
public void setRevertOfPersistsValue() throws Exception {
    Change changeToRevert = newChange();
    Change c = TestChanges.newChange(project, changeOwner.getAccountId());
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeId(c.getKey().get());
    update.setRevertOf(changeToRevert.getId().get());
    update.commit();
    assertThat(newNotes(c).getRevertOf()).isEqualTo(changeToRevert.getId());
}
#end_block

#method_before
@Test
public void setRevertOfToCurrentChangeFails() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    exception.expect(IllegalArgumentException.class);
    exception.expectMessage("A change cannot revert itself.");
    update.setRevertOf(c.getId().get());
}
#method_after
@Test
public void setRevertOfToCurrentChangeFails() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    exception.expect(IllegalArgumentException.class);
    exception.expectMessage("A change cannot revert itself");
    update.setRevertOf(c.getId().get());
}
#end_block

#method_before
protected PushOneCommit.Result forceDraftChange() throws Exception {
    Result pushTo = pushTo("refs/for/master");
    markChangeAsDraft(pushTo.getChange().change().getId());
    setDraftStatusOfPatchSetsOfChange(pushTo.getChange().change().getId(), true);
    return pushTo;
}
#method_after
protected PushOneCommit.Result forceDraftChange() throws Exception {
    PushOneCommit.Result pushTo = pushTo("refs/for/master");
    markChangeAsDraft(pushTo.getChange().change().getId());
    setDraftStatusOfPatchSetsOfChange(pushTo.getChange().change().getId(), true);
    return pushTo;
}
#end_block

#method_before
@Test
public void reviewAndStartReview() throws Exception {
    PushOneCommit.Result r = createWorkInProgressChange();
    r.assertOkStatus();
    assertThat(r.getChange().change().isWorkInProgress()).isTrue();
    ReviewInput in = ReviewInput.noScore().setWorkInProgress(false);
    ReviewResult result = gApi.changes().id(r.getChangeId()).revision("current").review(in);
    assertThat(result.reviewStarted).isTrue();
    ChangeInfo info = gApi.changes().id(r.getChangeId()).get();
    assertThat(info.workInProgress).isNull();
}
#method_after
@Test
public void reviewAndStartReview() throws Exception {
    PushOneCommit.Result r = createWorkInProgressChange();
    r.assertOkStatus();
    assertThat(r.getChange().change().isWorkInProgress()).isTrue();
    ReviewInput in = ReviewInput.noScore().setWorkInProgress(false);
    ReviewResult result = gApi.changes().id(r.getChangeId()).revision("current").review(in);
    assertThat(result.ready).isTrue();
    ChangeInfo info = gApi.changes().id(r.getChangeId()).get();
    assertThat(info.workInProgress).isNull();
}
#end_block

#method_before
@Test
public void reviewAndMoveToWorkInProgress() throws Exception {
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    assertThat(r.getChange().change().isWorkInProgress()).isFalse();
    ReviewInput in = ReviewInput.noScore().setWorkInProgress(true);
    ReviewResult result = gApi.changes().id(r.getChangeId()).revision("current").review(in);
    assertThat(result.reviewStarted).isNull();
    ChangeInfo info = gApi.changes().id(r.getChangeId()).get();
    assertThat(info.workInProgress).isTrue();
}
#method_after
@Test
public void reviewAndMoveToWorkInProgress() throws Exception {
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    assertThat(r.getChange().change().isWorkInProgress()).isFalse();
    ReviewInput in = ReviewInput.noScore().setWorkInProgress(true);
    ReviewResult result = gApi.changes().id(r.getChangeId()).revision("current").review(in);
    assertThat(result.ready).isNull();
    ChangeInfo info = gApi.changes().id(r.getChangeId()).get();
    assertThat(info.workInProgress).isTrue();
}
#end_block

#method_before
public Response<ReviewResult> apply(BatchUpdate.Factory updateFactory, RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException, PermissionBackendException, ConfigInvalidException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    } else if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        cleanUpComments(input.comments);
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    NotifyHandling reviewerNotify = input.notify;
    if (input.notify == null) {
        input.notify = defaultNotify(revision.getChange(), input);
    }
    ListMultimap<RecipientType, Account.Id> accountsToNotify = notifyUtil.resolveAccounts(input.notifyDetails);
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            // Prevent notifications because setting reviewers is batched.
            reviewerInput.notify = NotifyHandling.NONE;
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput, true);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        output.error = ERROR_ADDING_REVIEWER;
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = updateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        Account.Id id = revision.getUser().getAccountId();
        boolean ccOrReviewer = false;
        if (input.labels != null && !input.labels.isEmpty()) {
            ccOrReviewer = input.labels.values().stream().filter(v -> v != 0).findFirst().isPresent();
        }
        if (!ccOrReviewer) {
            // Check if user was already CCed or reviewing prior to this review.
            ReviewerSet currentReviewers = approvalsUtil.getReviewers(db.get(), revision.getChangeResource().getNotes());
            ccOrReviewer = currentReviewers.all().contains(id);
        }
        // themselves as a reviewer or to the CC list.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
            if (!ccOrReviewer && reviewerResult.result.reviewers != null) {
                for (ReviewerInfo reviewerInfo : reviewerResult.result.reviewers) {
                    if (Objects.equals(id.get(), reviewerInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
            if (!ccOrReviewer && reviewerResult.result.ccs != null) {
                for (AccountInfo accountInfo : reviewerResult.result.ccs) {
                    if (Objects.equals(id.get(), accountInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
        }
        if (!ccOrReviewer) {
            // User posting this review isn't currently in the reviewer or CC list,
            // isn't being explicitly added, and isn't voting on any label.
            // Automatically CC them on this change so they receive replies.
            PostReviewers.Addition selfAddition = postReviewers.ccCurrentUser(revision.getUser(), revision);
            bu.addOp(revision.getChange().getId(), selfAddition.op);
        }
        // Add WorkInProgressOp if requested.
        if (input.ready || input.workInProgress) {
            if (input.ready && input.workInProgress) {
                output.error = ERROR_WIP_READY_MUTUALLY_EXCLUSIVE;
                return Response.withStatusCode(SC_BAD_REQUEST, output);
            }
            if (!revision.getChange().getOwner().equals(revision.getUser().getAccountId())) {
                output.error = ERROR_ONLY_OWNER_CAN_MODIFY_WORK_IN_PROGRESS;
                return Response.withStatusCode(SC_BAD_REQUEST, output);
            }
            if (input.ready) {
                output.reviewStarted = true;
            }
            // Suppress notifications in WorkInProgressOp, we'll take care of
            // them in this endpoint.
            WorkInProgressOp.Input wipIn = new WorkInProgressOp.Input();
            wipIn.notify = NotifyHandling.NONE;
            bu.addOp(revision.getChange().getId(), workInProgressOpFactory.create(input.workInProgress, wipIn));
        }
        // Add the review op.
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input, accountsToNotify));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
        emailReviewers(revision.getChange(), reviewerResults, reviewerNotify, accountsToNotify);
    }
    return Response.ok(output);
}
#method_after
public Response<ReviewResult> apply(BatchUpdate.Factory updateFactory, RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException, PermissionBackendException, ConfigInvalidException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    } else if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        cleanUpComments(input.comments);
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    NotifyHandling reviewerNotify = input.notify;
    if (input.notify == null) {
        input.notify = defaultNotify(revision.getChange(), input);
    }
    ListMultimap<RecipientType, Account.Id> accountsToNotify = notifyUtil.resolveAccounts(input.notifyDetails);
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            // Prevent notifications because setting reviewers is batched.
            reviewerInput.notify = NotifyHandling.NONE;
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput, true);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        output.error = ERROR_ADDING_REVIEWER;
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = updateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        Account.Id id = revision.getUser().getAccountId();
        boolean ccOrReviewer = false;
        if (input.labels != null && !input.labels.isEmpty()) {
            ccOrReviewer = input.labels.values().stream().filter(v -> v != 0).findFirst().isPresent();
        }
        if (!ccOrReviewer) {
            // Check if user was already CCed or reviewing prior to this review.
            ReviewerSet currentReviewers = approvalsUtil.getReviewers(db.get(), revision.getChangeResource().getNotes());
            ccOrReviewer = currentReviewers.all().contains(id);
        }
        // themselves as a reviewer or to the CC list.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
            if (!ccOrReviewer && reviewerResult.result.reviewers != null) {
                for (ReviewerInfo reviewerInfo : reviewerResult.result.reviewers) {
                    if (Objects.equals(id.get(), reviewerInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
            if (!ccOrReviewer && reviewerResult.result.ccs != null) {
                for (AccountInfo accountInfo : reviewerResult.result.ccs) {
                    if (Objects.equals(id.get(), accountInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
        }
        if (!ccOrReviewer) {
            // User posting this review isn't currently in the reviewer or CC list,
            // isn't being explicitly added, and isn't voting on any label.
            // Automatically CC them on this change so they receive replies.
            PostReviewers.Addition selfAddition = postReviewers.ccCurrentUser(revision.getUser(), revision);
            bu.addOp(revision.getChange().getId(), selfAddition.op);
        }
        // Add WorkInProgressOp if requested.
        if (input.ready || input.workInProgress) {
            if (input.ready && input.workInProgress) {
                output.error = ERROR_WIP_READY_MUTUALLY_EXCLUSIVE;
                return Response.withStatusCode(SC_BAD_REQUEST, output);
            }
            if (!revision.getChange().getOwner().equals(revision.getUser().getAccountId())) {
                output.error = ERROR_ONLY_OWNER_CAN_MODIFY_WORK_IN_PROGRESS;
                return Response.withStatusCode(SC_BAD_REQUEST, output);
            }
            if (input.ready) {
                output.ready = true;
            }
            // Suppress notifications in WorkInProgressOp, we'll take care of
            // them in this endpoint.
            WorkInProgressOp.Input wipIn = new WorkInProgressOp.Input();
            wipIn.notify = NotifyHandling.NONE;
            bu.addOp(revision.getChange().getId(), workInProgressOpFactory.create(input.workInProgress, wipIn));
        }
        // Add the review op.
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input, accountsToNotify));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
        emailReviewers(revision.getChange(), reviewerResults, reviewerNotify, accountsToNotify);
    }
    return Response.ok(output);
}
#end_block

#method_before
public ReviewerInfo format(ReviewerInfo out, PermissionBackend.ForChange perm, ChangeData cd, Iterable<PatchSetApproval> approvals) throws OrmException, PermissionBackendException {
    LabelTypes labelTypes = cd.getLabelTypes();
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    out.approvals = new TreeMap<>(labelTypes.nameComparator());
    for (PatchSetApproval ca : approvals) {
        for (PermissionRange pr : cd.changeControl().getLabelRanges()) {
            if (!pr.isEmpty()) {
                LabelType at = labelTypes.byLabel(ca.getLabelId());
                if (at != null) {
                    out.approvals.put(at.getName(), formatValue(ca.getValue()));
                }
            }
        }
    }
    // Add dummy approvals for all permitted labels for the user even if they
    // do not exist in the DB.
    PatchSet ps = cd.currentPatchSet();
    if (ps != null) {
        for (SubmitRecord rec : new SubmitRuleEvaluator(accountByEmailCache, accountCache, cd).setFastEvalLabels(true).setAllowDraft(true).evaluate()) {
            if (rec.labels == null) {
                continue;
            }
            for (SubmitRecord.Label label : rec.labels) {
                String name = label.label;
                LabelType type = labelTypes.byLabel(name);
                if (!out.approvals.containsKey(name) && type != null && perm.test(new LabelPermission(type))) {
                    out.approvals.put(name, formatValue((short) 0));
                }
            }
        }
    }
    if (out.approvals.isEmpty()) {
        out.approvals = null;
    }
    return out;
}
#method_after
public ReviewerInfo format(ReviewerInfo out, PermissionBackend.ForChange perm, ChangeData cd, Iterable<PatchSetApproval> approvals) throws OrmException, PermissionBackendException {
    LabelTypes labelTypes = cd.getLabelTypes();
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    out.approvals = new TreeMap<>(labelTypes.nameComparator());
    for (PatchSetApproval ca : approvals) {
        for (PermissionRange pr : cd.changeControl().getLabelRanges()) {
            if (!pr.isEmpty()) {
                LabelType at = labelTypes.byLabel(ca.getLabelId());
                if (at != null) {
                    out.approvals.put(at.getName(), formatValue(ca.getValue()));
                }
            }
        }
    }
    // Add dummy approvals for all permitted labels for the user even if they
    // do not exist in the DB.
    PatchSet ps = cd.currentPatchSet();
    if (ps != null) {
        for (SubmitRecord rec : new SubmitRuleEvaluator(accountCache, accounts, cd).setFastEvalLabels(true).setAllowDraft(true).evaluate()) {
            if (rec.labels == null) {
                continue;
            }
            for (SubmitRecord.Label label : rec.labels) {
                String name = label.label;
                LabelType type = labelTypes.byLabel(name);
                if (!out.approvals.containsKey(name) && type != null && perm.test(new LabelPermission(type))) {
                    out.approvals.put(name, formatValue((short) 0));
                }
            }
        }
    }
    if (out.approvals.isEmpty()) {
        out.approvals = null;
    }
    return out;
}
#end_block

#method_before
private PrologEnvironment getPrologEnvironment(CurrentUser user) throws RuleEvalException {
    ProjectState projectState = control.getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        if (opts.rule() == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", new StringReader(opts.rule()));
        }
    } catch (CompileException err) {
        String msg;
        if (opts.rule() == null && control.getProjectControl().isOwner()) {
            msg = String.format("Cannot load rules.pl for %s: %s", getProjectName(), err.getMessage());
        } else if (opts.rule() != null) {
            msg = err.getMessage();
        } else {
            msg = String.format("Cannot load rules.pl for %s", getProjectName());
        }
        throw new RuleEvalException(msg, err);
    }
    env.set(StoredValues.ACCOUNT_BY_EMAIL_CACHE, accountByEmailCache);
    env.set(StoredValues.ACCOUNT_CACHE, accountCache);
    env.set(StoredValues.REVIEW_DB, cd.db());
    env.set(StoredValues.CHANGE_DATA, cd);
    env.set(StoredValues.CHANGE_CONTROL, control);
    if (user != null) {
        env.set(StoredValues.CURRENT_USER, user);
    }
    return env;
}
#method_after
private PrologEnvironment getPrologEnvironment(CurrentUser user) throws RuleEvalException {
    ProjectState projectState = control.getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        if (opts.rule() == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", new StringReader(opts.rule()));
        }
    } catch (CompileException err) {
        String msg;
        if (opts.rule() == null && control.getProjectControl().isOwner()) {
            msg = String.format("Cannot load rules.pl for %s: %s", getProjectName(), err.getMessage());
        } else if (opts.rule() != null) {
            msg = err.getMessage();
        } else {
            msg = String.format("Cannot load rules.pl for %s", getProjectName());
        }
        throw new RuleEvalException(msg, err);
    }
    env.set(StoredValues.ACCOUNTS, accounts);
    env.set(StoredValues.ACCOUNT_CACHE, accountCache);
    env.set(StoredValues.REVIEW_DB, cd.db());
    env.set(StoredValues.CHANGE_DATA, cd);
    env.set(StoredValues.CHANGE_CONTROL, control);
    if (user != null) {
        env.set(StoredValues.CURRENT_USER, user);
    }
    return env;
}
#end_block

#method_before
public List<SubmitRecord> submitRecords(SubmitRuleOptions options) throws OrmException {
    List<SubmitRecord> records = submitRecords.get(options);
    if (records == null) {
        if (!lazyLoad) {
            return Collections.emptyList();
        }
        records = new SubmitRuleEvaluator(accountByEmailCache, accountCache, this).setOptions(options).evaluate();
        submitRecords.put(options, records);
    }
    return records;
}
#method_after
public List<SubmitRecord> submitRecords(SubmitRuleOptions options) throws OrmException {
    List<SubmitRecord> records = submitRecords.get(options);
    if (records == null) {
        if (!lazyLoad) {
            return Collections.emptyList();
        }
        records = new SubmitRuleEvaluator(accountCache, accounts, this).setOptions(options).evaluate();
        submitRecords.put(options, records);
    }
    return records;
}
#end_block

#method_before
public SubmitTypeRecord submitTypeRecord() throws OrmException {
    if (submitTypeRecord == null) {
        submitTypeRecord = new SubmitRuleEvaluator(accountByEmailCache, accountCache, this).getSubmitType();
    }
    return submitTypeRecord;
}
#method_after
public SubmitTypeRecord submitTypeRecord() throws OrmException {
    if (submitTypeRecord == null) {
        submitTypeRecord = new SubmitRuleEvaluator(accountCache, accounts, this).getSubmitType();
    }
    return submitTypeRecord;
}
#end_block

#method_before
private ChangeAttribute buildChangeAttribute(ChangeData d, Map<Project.NameKey, Repository> repos, Map<Project.NameKey, RevWalk> revWalks) throws OrmException, IOException {
    ChangeControl cc = d.changeControl().forUser(user);
    LabelTypes labelTypes = cc.getLabelTypes();
    ChangeAttribute c = eventFactory.asChangeAttribute(db, d.change());
    eventFactory.extend(c, d.change());
    if (!trackingFooters.isEmpty()) {
        eventFactory.addTrackingIds(c, trackingFooters.extract(d.commitFooters()));
    }
    if (includeAllReviewers) {
        eventFactory.addAllReviewers(db, c, d.notes());
    }
    if (includeSubmitRecords) {
        eventFactory.addSubmitRecords(c, new SubmitRuleEvaluator(accountByEmailCache, accountCache, d).setAllowClosed(true).setAllowDraft(true).evaluate());
    }
    if (includeCommitMessage) {
        eventFactory.addCommitMessage(c, d.commitMessage());
    }
    RevWalk rw = null;
    if (includePatchSets || includeCurrentPatchSet || includeDependencies) {
        Project.NameKey p = d.change().getProject();
        rw = revWalks.get(p);
        // Cache and reuse repos and revwalks.
        if (rw == null) {
            Repository repo = repoManager.openRepository(p);
            checkState(repos.put(p, repo) == null);
            rw = new RevWalk(repo);
            revWalks.put(p, rw);
        }
    }
    if (includePatchSets) {
        eventFactory.addPatchSets(db, rw, c, d.visiblePatchSets(), includeApprovals ? d.approvals().asMap() : null, includeFiles, d.change(), labelTypes);
    }
    if (includeCurrentPatchSet) {
        PatchSet current = d.currentPatchSet();
        if (current != null && cc.isPatchVisible(current, d.db())) {
            c.currentPatchSet = eventFactory.asPatchSetAttribute(db, rw, d.change(), current);
            eventFactory.addApprovals(c.currentPatchSet, d.currentApprovals(), labelTypes);
            if (includeFiles) {
                eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(), d.currentPatchSet());
            }
            if (includeComments) {
                eventFactory.addPatchSetComments(c.currentPatchSet, d.publishedComments());
            }
        }
    }
    if (includeComments) {
        eventFactory.addComments(c, d.messages());
        if (includePatchSets) {
            eventFactory.addPatchSets(db, rw, c, d.visiblePatchSets(), includeApprovals ? d.approvals().asMap() : null, includeFiles, d.change(), labelTypes);
            for (PatchSetAttribute attribute : c.patchSets) {
                eventFactory.addPatchSetComments(attribute, d.publishedComments());
            }
        }
    }
    if (includeDependencies) {
        eventFactory.addDependencies(rw, c, d.change(), d.currentPatchSet());
    }
    c.plugins = queryProcessor.create(d);
    return c;
}
#method_after
private ChangeAttribute buildChangeAttribute(ChangeData d, Map<Project.NameKey, Repository> repos, Map<Project.NameKey, RevWalk> revWalks) throws OrmException, IOException {
    ChangeControl cc = d.changeControl().forUser(user);
    LabelTypes labelTypes = cc.getLabelTypes();
    ChangeAttribute c = eventFactory.asChangeAttribute(db, d.change());
    eventFactory.extend(c, d.change());
    if (!trackingFooters.isEmpty()) {
        eventFactory.addTrackingIds(c, trackingFooters.extract(d.commitFooters()));
    }
    if (includeAllReviewers) {
        eventFactory.addAllReviewers(db, c, d.notes());
    }
    if (includeSubmitRecords) {
        eventFactory.addSubmitRecords(c, new SubmitRuleEvaluator(accountCache, accounts, d).setAllowClosed(true).setAllowDraft(true).evaluate());
    }
    if (includeCommitMessage) {
        eventFactory.addCommitMessage(c, d.commitMessage());
    }
    RevWalk rw = null;
    if (includePatchSets || includeCurrentPatchSet || includeDependencies) {
        Project.NameKey p = d.change().getProject();
        rw = revWalks.get(p);
        // Cache and reuse repos and revwalks.
        if (rw == null) {
            Repository repo = repoManager.openRepository(p);
            checkState(repos.put(p, repo) == null);
            rw = new RevWalk(repo);
            revWalks.put(p, rw);
        }
    }
    if (includePatchSets) {
        eventFactory.addPatchSets(db, rw, c, d.visiblePatchSets(), includeApprovals ? d.approvals().asMap() : null, includeFiles, d.change(), labelTypes);
    }
    if (includeCurrentPatchSet) {
        PatchSet current = d.currentPatchSet();
        if (current != null && cc.isPatchVisible(current, d.db())) {
            c.currentPatchSet = eventFactory.asPatchSetAttribute(db, rw, d.change(), current);
            eventFactory.addApprovals(c.currentPatchSet, d.currentApprovals(), labelTypes);
            if (includeFiles) {
                eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(), d.currentPatchSet());
            }
            if (includeComments) {
                eventFactory.addPatchSetComments(c.currentPatchSet, d.publishedComments());
            }
        }
    }
    if (includeComments) {
        eventFactory.addComments(c, d.messages());
        if (includePatchSets) {
            eventFactory.addPatchSets(db, rw, c, d.visiblePatchSets(), includeApprovals ? d.approvals().asMap() : null, includeFiles, d.change(), labelTypes);
            for (PatchSetAttribute attribute : c.patchSets) {
                eventFactory.addPatchSetComments(attribute, d.publishedComments());
            }
        }
    }
    if (includeDependencies) {
        eventFactory.addDependencies(rw, c, d.change(), d.currentPatchSet());
    }
    c.plugins = queryProcessor.create(d);
    return c;
}
#end_block

#method_before
private SubmitType getSubmitType(ChangeData cd, PatchSet patchSet) throws OrmException {
    SubmitTypeRecord rec = new SubmitRuleEvaluator(accountByEmailCache, accountCache, cd).setPatchSet(patchSet).getSubmitType();
    if (rec.status != SubmitTypeRecord.Status.OK) {
        throw new OrmException("Submit type rule failed: " + rec);
    }
    return rec.type;
}
#method_after
private SubmitType getSubmitType(ChangeData cd, PatchSet patchSet) throws OrmException {
    SubmitTypeRecord rec = new SubmitRuleEvaluator(accountCache, accounts, cd).setPatchSet(patchSet).getSubmitType();
    if (rec.status != SubmitTypeRecord.Status.OK) {
        throw new OrmException("Submit type rule failed: " + rec);
    }
    return rec.type;
}
#end_block

#method_before
@Override
public List<Record> apply(RevisionResource rsrc, TestSubmitRuleInput input) throws AuthException, OrmException {
    if (input == null) {
        input = new TestSubmitRuleInput();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(accountByEmailCache, accountCache, changeDataFactory.create(db.get(), rsrc.getControl()));
    List<SubmitRecord> records = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).evaluate();
    List<Record> out = Lists.newArrayListWithCapacity(records.size());
    AccountLoader accounts = accountInfoFactory.create(true);
    for (SubmitRecord r : records) {
        out.add(new Record(r, accounts));
    }
    if (!out.isEmpty()) {
        out.get(0).prologReductionCount = evaluator.getReductionsConsumed();
    }
    accounts.fill();
    return out;
}
#method_after
@Override
public List<Record> apply(RevisionResource rsrc, TestSubmitRuleInput input) throws AuthException, OrmException {
    if (input == null) {
        input = new TestSubmitRuleInput();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(accountCache, accounts, changeDataFactory.create(db.get(), rsrc.getControl()));
    List<SubmitRecord> records = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).evaluate();
    List<Record> out = Lists.newArrayListWithCapacity(records.size());
    AccountLoader accounts = accountInfoFactory.create(true);
    for (SubmitRecord r : records) {
        out.add(new Record(r, accounts));
    }
    if (!out.isEmpty()) {
        out.get(0).prologReductionCount = evaluator.getReductionsConsumed();
    }
    accounts.fill();
    return out;
}
#end_block

#method_before
private SubmitType submitType(ChangeData cd, PatchSet ps, boolean visible) throws OrmException {
    // would be submitted together with the visible ones.
    if (!visible) {
        return cd.changeControl().getProject().getSubmitType();
    }
    SubmitTypeRecord str = ps == cd.currentPatchSet() ? cd.submitTypeRecord() : new SubmitRuleEvaluator(accountByEmailCache, accountCache, cd).setPatchSet(ps).getSubmitType();
    if (!str.isOk()) {
        logErrorAndThrow("Failed to get submit type for " + cd.getId() + ": " + str.errorMessage);
    }
    return str.type;
}
#method_after
private SubmitType submitType(ChangeData cd, PatchSet ps, boolean visible) throws OrmException {
    // would be submitted together with the visible ones.
    if (!visible) {
        return cd.changeControl().getProject().getSubmitType();
    }
    SubmitTypeRecord str = ps == cd.currentPatchSet() ? cd.submitTypeRecord() : new SubmitRuleEvaluator(accountCache, accounts, cd).setPatchSet(ps).getSubmitType();
    if (!str.isOk()) {
        logErrorAndThrow("Failed to get submit type for " + cd.getId() + ": " + str.errorMessage);
    }
    return str.type;
}
#end_block

#method_before
@Override
public SubmitType apply(RevisionResource rsrc, TestSubmitRuleInput input) throws AuthException, BadRequestException, OrmException {
    if (input == null) {
        input = new TestSubmitRuleInput();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(accountByEmailCache, accountCache, changeDataFactory.create(db.get(), rsrc.getControl()));
    SubmitTypeRecord rec = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).getSubmitType();
    if (rec.status != SubmitTypeRecord.Status.OK) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRuleName(), rec));
    }
    return rec.type;
}
#method_after
@Override
public SubmitType apply(RevisionResource rsrc, TestSubmitRuleInput input) throws AuthException, BadRequestException, OrmException {
    if (input == null) {
        input = new TestSubmitRuleInput();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(accountCache, accounts, changeDataFactory.create(db.get(), rsrc.getControl()));
    SubmitTypeRecord rec = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).getSubmitType();
    if (rec.status != SubmitTypeRecord.Status.OK) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRuleName(), rec));
    }
    return rec.type;
}
#end_block

#method_before
private Supplier<AccountAttribute> accountAttributeSupplier(final AccountInfo account) {
    return Suppliers.memoize(new Supplier<AccountAttribute>() {

        @Override
        public AccountAttribute get() {
            return eventFactory.asAccountAttribute(new Account.Id(account._accountId));
        }
    });
}
#method_after
private Supplier<AccountAttribute> accountAttributeSupplier(final AccountInfo account) {
    return Suppliers.memoize(new Supplier<AccountAttribute>() {

        @Override
        public AccountAttribute get() {
            return account != null ? eventFactory.asAccountAttribute(new Account.Id(account._accountId)) : null;
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCache.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), AssigneeChangedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    factory(SubmoduleOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCache.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), AssigneeChangedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    DynamicSet.setOf(binder(), AssigneeValidationListener.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    factory(SubmoduleOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws OrmException, RestApiException {
    change = ctx.getChange();
    if (!notesMigration.readChanges()) {
        throw new BadRequestException("Cannot add Assignee; NoteDb is disabled");
    }
    if (!ctx.getControl().canEditAssignee()) {
        throw new AuthException("Changing Assignee not permitted");
    }
    ChangeUpdate update = ctx.getUpdate(ctx.getChange().currentPatchSetId());
    ChangeNotes notes = update.getNotes();
    Account.Id oldAssigneeId = notes.getAssignee();
    if (input.assignee == null) {
        if (oldAssigneeId != null) {
            throw new AuthException("Cannot remove Assignee");
        }
        return false;
    }
    oldAssignee = null;
    if (oldAssigneeId != null) {
        oldAssignee = accountInfosFactory.create().get(oldAssigneeId);
    }
    IdentifiedUser newAssigneeUser = accounts.parse(input.assignee);
    if (oldAssigneeId != null && oldAssigneeId.equals(newAssigneeUser.getAccountId())) {
        newAssignee = oldAssignee;
        return false;
    }
    if (!newAssigneeUser.getAccount().isActive()) {
        throw new UnprocessableEntityException(String.format("Account of %s is not active", newAssigneeUser.getUserName()));
    }
    if (!ctx.getControl().forUser(newAssigneeUser).isRefVisible()) {
        throw new AuthException(String.format("Change %s is not visible to %s.", change.getChangeId(), newAssigneeUser.getUserName()));
    }
    update.setAssignee(newAssigneeUser.getAccountId());
    this.newAssignee = newAssigneeUser.getAccount();
    addMessage(ctx, update, oldAssignee);
    return true;
}
#method_after
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws OrmException, RestApiException {
    if (!ctx.getControl().canEditAssignee()) {
        throw new AuthException("Changing Assignee not permitted");
    }
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    Optional<Account.Id> oldAssigneeId = Optional.fromNullable(change.getAssignee());
    if (input.assignee == null) {
        if (oldAssigneeId.isPresent()) {
            throw new BadRequestException("Cannot set Assignee to empty");
        }
        return false;
    }
    oldAssignee = null;
    if (oldAssigneeId.isPresent()) {
        oldAssignee = accountInfosFactory.create().get(oldAssigneeId.get());
    }
    IdentifiedUser newAssigneeUser = accounts.parse(input.assignee);
    if (oldAssigneeId.isPresent() && oldAssigneeId.get().equals(newAssigneeUser.getAccountId())) {
        newAssignee = oldAssignee;
        return false;
    }
    if (!newAssigneeUser.getAccount().isActive()) {
        throw new UnprocessableEntityException(String.format("Account of %s is not active", newAssigneeUser.getUserName()));
    }
    if (!ctx.getControl().forUser(newAssigneeUser).isRefVisible()) {
        throw new AuthException(String.format("Change %s is not visible to %s.", change.getChangeId(), newAssigneeUser.getUserName()));
    }
    try {
        for (AssigneeValidationListener validator : validationListeners) {
            validator.validateAssignee(change, newAssigneeUser.getAccount());
        }
    } catch (ValidationException e) {
        throw new BadRequestException(e.getMessage());
    }
    // notedb
    update.setAssignee(newAssigneeUser.getAccountId());
    // reviewdb
    change.setAssignee(newAssigneeUser.getAccountId());
    this.newAssignee = newAssigneeUser.getAccount();
    addMessage(ctx, update, oldAssignee);
    return true;
}
#end_block

#method_before
private void addMessage(BatchUpdate.ChangeContext ctx, ChangeUpdate update, Account previousAssignee) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Assignee ");
    if (previousAssignee == null) {
        msg.append("added: ");
        msg.append(newAssignee.getName(anonymousCowardName));
    } else {
        msg.append("changed from: ");
        msg.append(previousAssignee.getName(anonymousCowardName));
        msg.append(" to:");
        msg.append(newAssignee.getName(anonymousCowardName));
    }
    ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getAccountId(), ctx.getWhen(), change.currentPatchSetId());
    cmsg.setMessage(msg.toString());
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
}
#method_after
private void addMessage(BatchUpdate.ChangeContext ctx, ChangeUpdate update, Account previousAssignee) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Assignee ");
    if (previousAssignee == null) {
        msg.append("added: ");
        msg.append(newAssignee.getName(anonymousCowardName));
    } else {
        msg.append("changed from: ");
        msg.append(previousAssignee.getName(anonymousCowardName));
        msg.append(" to: ");
        msg.append(newAssignee.getName(anonymousCowardName));
    }
    ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getAccountId(), ctx.getWhen(), change.currentPatchSetId());
    cmsg.setMessage(msg.toString());
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    if (change != null) {
        assigneeChanged.fire(change, ctx.getAccount(), oldAssignee, ctx.getWhen());
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException {
    assigneeChanged.fire(change, ctx.getAccount(), oldAssignee, ctx.getWhen());
}
#end_block

#method_before
public MutableNotesMigration setFrom(NotesMigrationState state) {
    snapshot.set(state.snapshot());
    return this;
}
#method_after
public MutableNotesMigration setFrom(NotesMigration other) {
    snapshot.set(other.snapshot.get());
    return this;
}
#end_block

#method_before
public static GerritServer initAndStart(Description desc, Config baseConfig) throws Exception {
    if (!desc.memory()) {
        assume().withMessage("FUSED mode not yet supported for on-disk sites").that(NoteDbMode.get()).isNotEqualTo(NoteDbMode.FUSED);
    }
    Path site = Paths.get(baseConfig.getString("gerrit", null, "tempSiteDir"));
    if (!desc.memory()) {
        init(desc, baseConfig, site);
    }
    return start(desc, baseConfig, site, null);
}
#method_after
public static GerritServer initAndStart(Description desc, Config baseConfig) throws Exception {
    Path site = Paths.get(baseConfig.getString("gerrit", null, "tempSiteDir"));
    if (!desc.memory()) {
        init(desc, baseConfig, site);
    }
    return start(desc, baseConfig, site, null);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    TestAccount user = accounts.create("user", "user@example.com", "User");
    userSession = new RestSession(server, user);
}
#method_after
@Before
public void setUp() throws Exception {
    TestAccount user = accounts.create("user", "user@example.com", "User");
    TestAccount admin = accounts.admin();
    userSession = new RestSession(server, user);
    adminSession = new RestSession(server, admin);
}
#end_block

#method_before
public ProjectInfo format(Project p) {
    ProjectInfo info = new ProjectInfo();
    info.name = p.getName();
    Project.NameKey parentName = p.getParent(allProjects);
    info.parent = parentName != null ? parentName.get() : null;
    info.description = Strings.emptyToNull(p.getDescription());
    info.state = p.getState();
    info.id = Url.encode(info.name);
    List<WebLinkInfo> links = webLinks.getProjectLinks(p.getName());
    info.webLinks = links.isEmpty() ? null : links;
    return info;
}
#method_after
public ProjectInfo format(ProjectControl ctl) {
    ProjectInfo info = format(ctl.getProject());
    info.labels = new HashMap<>();
    for (LabelType t : ctl.getLabelTypes().getLabelTypes()) {
        LabelTypeInfo labelInfo = new LabelTypeInfo();
        labelInfo.values = t.getValues().stream().collect(Collectors.toMap(LabelValue::formatValue, LabelValue::getText));
        labelInfo.defaultValue = t.getDefaultValue();
        info.labels.put(t.getName(), labelInfo);
    }
    return info;
}
#end_block

#method_before
@Test
public void getProject() throws Exception {
    String name = project.get();
    ProjectInfo p = gApi.projects().name(name).get();
    assertThat(p.name).isEqualTo(name);
    assertThat(p.labels.get("Code-Review").values.get("0")).isEqualTo("No score");
}
#method_after
@Test
public void getProject() throws Exception {
    String name = project.get();
    ProjectInfo p = gApi.projects().name(name).get();
    assertThat(p.name).isEqualTo(name);
    assertThat(p.labels).hasSize(1);
    LabelTypeInfo l = p.labels.get("Code-Review");
    ImmutableMap<String, String> want = ImmutableMap.of(" 0", "No score", "-1", "I would prefer this is not merged as is", "-2", "This shall not be merged", "+1", "Looks good to me, but someone else must approve", "+2", "Looks good to me, approved");
    assertThat(l.values).isEqualTo(want);
    assertThat(l.defaultValue).isEqualTo(0);
}
#end_block

#method_before
private Path resolvePath(HttpServletRequest req) {
    return sitePaths.resolve(req.getServletPath() + req.getPathInfo());
}
#method_after
private Path resolvePath(HttpServletRequest req) {
    return sitePaths.resolve(CharMatcher.is('/').trimLeadingFrom(req.getServletPath() + req.getPathInfo()));
}
#end_block

#method_before
private void render(Writer out, final Map<String, EmailHeader> callerHeaders, String textBody, @Nullable String htmlBody) throws IOException, EmailException {
    final Map<String, EmailHeader> hdrs = new LinkedHashMap<>(callerHeaders);
    setMissingHeader(hdrs, "MIME-Version", "1.0");
    setMissingHeader(hdrs, "Content-Transfer-Encoding", "8bit");
    setMissingHeader(hdrs, "Content-Disposition", "inline");
    setMissingHeader(hdrs, "User-Agent", "Gerrit/" + Version.getVersion());
    if (importance != null) {
        setMissingHeader(hdrs, "Importance", importance);
    }
    if (expiryDays > 0) {
        Date expiry = new Date(TimeUtil.nowMs() + expiryDays * 24 * 60 * 60 * 1000L);
        setMissingHeader(hdrs, "Expiry-Date", new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss Z").format(expiry));
    }
    String encodedBody;
    if (htmlBody == null) {
        setMissingHeader(hdrs, "Content-Type", "text/plain; charset=UTF-8");
        encodedBody = textBody;
    } else {
        String boundary = generateMultipartBoundary(textBody, htmlBody);
        setMissingHeader(hdrs, "Content-Type", "multipart/alternative; boundary=\"" + boundary + "\"; charset=UTF-8");
        encodedBody = buildMultipartBody(boundary, textBody, htmlBody);
    }
    try (Writer w = new BufferedWriter(out)) {
        for (Map.Entry<String, EmailHeader> h : hdrs.entrySet()) {
            if (!h.getValue().isEmpty()) {
                w.write(h.getKey());
                w.write(": ");
                h.getValue().write(w);
                w.write("\r\n");
            }
        }
        w.write("\r\n");
        w.write(encodedBody);
        w.flush();
    }
}
#method_after
private void render(Writer out, Map<String, EmailHeader> callerHeaders, String textBody, @Nullable String htmlBody) throws IOException, EmailException {
    final Map<String, EmailHeader> hdrs = new LinkedHashMap<>(callerHeaders);
    setMissingHeader(hdrs, "MIME-Version", "1.0");
    setMissingHeader(hdrs, "Content-Transfer-Encoding", "8bit");
    setMissingHeader(hdrs, "Content-Disposition", "inline");
    setMissingHeader(hdrs, "User-Agent", "Gerrit/" + Version.getVersion());
    if (importance != null) {
        setMissingHeader(hdrs, "Importance", importance);
    }
    if (expiryDays > 0) {
        Date expiry = new Date(TimeUtil.nowMs() + expiryDays * 24 * 60 * 60 * 1000L);
        setMissingHeader(hdrs, "Expiry-Date", new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss Z").format(expiry));
    }
    String encodedBody;
    if (htmlBody == null) {
        setMissingHeader(hdrs, "Content-Type", "text/plain; charset=UTF-8");
        encodedBody = textBody;
    } else {
        String boundary = generateMultipartBoundary(textBody, htmlBody);
        setMissingHeader(hdrs, "Content-Type", "multipart/alternative; boundary=\"" + boundary + "\"; charset=UTF-8");
        encodedBody = buildMultipartBody(boundary, textBody, htmlBody);
    }
    try (Writer w = new BufferedWriter(out)) {
        for (Map.Entry<String, EmailHeader> h : hdrs.entrySet()) {
            if (!h.getValue().isEmpty()) {
                w.write(h.getKey());
                w.write(": ");
                h.getValue().write(w);
                w.write("\r\n");
            }
        }
        w.write("\r\n");
        w.write(encodedBody);
        w.flush();
    }
}
#end_block

#method_before
protected String buildMultipartBody(String boundary, String textPart, String htmlPart) throws IOException {
    return // Output the text part:
    "--" + boundary + "\r\n" + "Content-Type: text/plain; charset=UTF-8\r\n" + "Content-Transfer-Encoding: quoted-printable\r\n" + "\r\n" + quotedPrintableEncode(textPart) + "\r\n" + // Output the HTML part:
    "--" + boundary + "\r\n" + "Content-Type: text/html; charset=UTF-8\r\n" + "Content-Transfer-Encoding: quoted-printable\r\n" + "\r\n" + quotedPrintableEncode(htmlPart) + "\r\n" + // Output the closing boundary.
    "--" + boundary + "--\r\n";
}
#method_after
protected String buildMultipartBody(String boundary, String textPart, String htmlPart) throws IOException {
    String encodedTextPart = quotedPrintableEncode(textPart);
    String encodedHtmlPart = quotedPrintableEncode(htmlPart);
    // Only declare quoted-printable encoding if there are characters that need to be encoded.
    String textTransferEncoding = textPart.equals(encodedTextPart) ? "7bit" : "quoted-printable";
    String htmlTransferEncoding = htmlPart.equals(encodedHtmlPart) ? "7bit" : "quoted-printable";
    return // Output the text part:
    "--" + boundary + "\r\n" + "Content-Type: text/plain; charset=UTF-8\r\n" + "Content-Transfer-Encoding: " + textTransferEncoding + "\r\n" + "\r\n" + encodedTextPart + "\r\n" + // Output the HTML part:
    "--" + boundary + "\r\n" + "Content-Type: text/html; charset=UTF-8\r\n" + "Content-Transfer-Encoding: " + htmlTransferEncoding + "\r\n" + "\r\n" + encodedHtmlPart + "\r\n" + // Output the closing boundary.
    "--" + boundary + "--\r\n";
}
#end_block

#method_before
protected String quotedPrintableEncode(String input) throws IOException {
    ByteArrayOutputStream s = new ByteArrayOutputStream();
    QuotedPrintableOutputStream qp = new QuotedPrintableOutputStream(s, false);
    qp.write(input.getBytes(UTF_8));
    qp.close();
    return s.toString();
}
#method_after
protected String quotedPrintableEncode(String input) throws IOException {
    ByteArrayOutputStream s = new ByteArrayOutputStream();
    try (QuotedPrintableOutputStream qp = new QuotedPrintableOutputStream(s, false)) {
        qp.write(input.getBytes(UTF_8));
    }
    return s.toString();
}
#end_block

#method_before
private static void setMissingHeader(final Map<String, EmailHeader> hdrs, String name, String value) {
    if (!hdrs.containsKey(name) || hdrs.get(name).isEmpty()) {
        hdrs.put(name, new EmailHeader.String(value));
    }
}
#method_after
private static void setMissingHeader(Map<String, EmailHeader> hdrs, String name, String value) {
    if (!hdrs.containsKey(name) || hdrs.get(name).isEmpty()) {
        hdrs.put(name, new EmailHeader.String(value));
    }
}
#end_block

#method_before
@Override
public OAuthUserInfo getUserInfo(OAuthToken token) throws IOException {
    OAuthRequest request = new OAuthRequest(Verb.GET, PROTECTED_RESOURCE_URL);
    Token t = new Token(token.getToken(), token.getSecret(), token.getRaw());
    service.signRequest(t, request);
    Response response = request.send();
    if (response.getCode() != HttpServletResponse.SC_OK) {
        throw new IOException(String.format("Status %s (%s) for request %s", response.getCode(), response.getBody(), request.getUrl()));
    }
    JsonElement userJson = OutputFormat.JSON.newGson().fromJson(response.getBody(), JsonElement.class);
    if (log.isDebugEnabled()) {
        log.debug("User info response: {}", response.getBody());
    }
    if (userJson.isJsonObject()) {
        JsonObject jsonObject = userJson.getAsJsonObject();
        JsonElement id = jsonObject.get("id");
        if (id == null || id.isJsonNull()) {
            throw new IOException(String.format("Response doesn't contain id field"));
        }
        JsonElement email = jsonObject.get("email");
        JsonElement name = jsonObject.get("name");
        String login = null;
        if (domains.length > 0) {
            boolean domainMatched = false;
            JsonObject jwtToken = retrieveJWTToken(token);
            String hdClaim = retrieveHostedDomain(jwtToken);
            for (String domain : domains) {
                if (domain.equalsIgnoreCase(hdClaim)) {
                    domainMatched = true;
                    break;
                }
            }
            if (!domainMatched) {
                // TODO(davido): improve error reporting in OAuth extension point
                log.error("Error: hosted domain validation failed: {}", Strings.nullToEmpty(hdClaim));
                return null;
            }
        }
        if (useEmailAsUsername && !email.isJsonNull()) {
            login = email.getAsString().split("@")[0];
        }
        return new OAuthUserInfo(GOOGLE_PROVIDER_PREFIX + id.getAsString(), /*externalId*/
        login, /*username*/
        email == null || email.isJsonNull() ? null : email.getAsString(), /*email*/
        name == null || name.isJsonNull() ? null : name.getAsString(), /*displayName*/
        fixLegacyUserId ? id.getAsString() : null);
    }
    throw new IOException(String.format("Invalid JSON '%s': not a JSON Object", userJson));
}
#method_after
@Override
public OAuthUserInfo getUserInfo(OAuthToken token) throws IOException {
    OAuthRequest request = new OAuthRequest(Verb.GET, PROTECTED_RESOURCE_URL);
    Token t = new Token(token.getToken(), token.getSecret(), token.getRaw());
    service.signRequest(t, request);
    Response response = request.send();
    if (response.getCode() != HttpServletResponse.SC_OK) {
        throw new IOException(String.format("Status %s (%s) for request %s", response.getCode(), response.getBody(), request.getUrl()));
    }
    JsonElement userJson = OutputFormat.JSON.newGson().fromJson(response.getBody(), JsonElement.class);
    if (log.isDebugEnabled()) {
        log.debug("User info response: {}", response.getBody());
    }
    if (userJson.isJsonObject()) {
        JsonObject jsonObject = userJson.getAsJsonObject();
        JsonElement id = jsonObject.get("id");
        if (id == null || id.isJsonNull()) {
            throw new IOException(String.format("Response doesn't contain id field"));
        }
        JsonElement email = jsonObject.get("email");
        JsonElement name = jsonObject.get("name");
        String login = null;
        if (domains.size() > 0) {
            boolean domainMatched = false;
            JsonObject jwtToken = retrieveJWTToken(token);
            String hdClaim = retrieveHostedDomain(jwtToken);
            for (String domain : domains) {
                if (domain.equalsIgnoreCase(hdClaim)) {
                    domainMatched = true;
                    break;
                }
            }
            if (!domainMatched) {
                // TODO(davido): improve error reporting in OAuth extension point
                log.error("Error: hosted domain validation failed: {}", Strings.nullToEmpty(hdClaim));
                return null;
            }
        }
        if (useEmailAsUsername && !email.isJsonNull()) {
            login = email.getAsString().split("@")[0];
        }
        return new OAuthUserInfo(GOOGLE_PROVIDER_PREFIX + id.getAsString(), /*externalId*/
        login, /*username*/
        email == null || email.isJsonNull() ? null : email.getAsString(), /*email*/
        name == null || name.isJsonNull() ? null : name.getAsString(), /*displayName*/
        fixLegacyUserId ? id.getAsString() : null);
    }
    throw new IOException(String.format("Invalid JSON '%s': not a JSON Object", userJson));
}
#end_block

#method_before
@Override
public String getAuthorizationUrl() {
    String url = service.getAuthorizationUrl(null);
    try {
        if (domains.length == 1) {
            url += "&hd=" + URLEncoder.encode(domains[0], StandardCharsets.UTF_8.name());
        } else if (domains.length > 1) {
            url += "&hd=*";
        }
    } catch (UnsupportedEncodingException e) {
        throw new IllegalArgumentException(e);
    }
    if (log.isDebugEnabled()) {
        log.debug("OAuth2: authorization URL={}", url);
    }
    return url;
}
#method_after
@Override
public String getAuthorizationUrl() {
    String url = service.getAuthorizationUrl(null);
    try {
        if (domains.size() == 1) {
            url += "&hd=" + URLEncoder.encode(domains.get(0), StandardCharsets.UTF_8.name());
        } else if (domains.size() > 1) {
            url += "&hd=*";
        }
    } catch (UnsupportedEncodingException e) {
        throw new IllegalArgumentException(e);
    }
    if (log.isDebugEnabled()) {
        log.debug("OAuth2: authorization URL={}", url);
    }
    return url;
}
#end_block

#method_before
public Optional<Comment> getPublished(ReviewDb db, ChangeNotes notes, Comment.Key key) throws OrmException {
    if (!migration.readChanges()) {
        return Optional.ofNullable(db.patchComments().get(PatchLineComment.Key.from(notes.getChangeId(), key))).map(plc -> plc.asComment(serverId));
    }
    return publishedByChange(db, notes).stream().filter(c -> key.equals(c.key)).findFirst();
}
#method_after
public Optional<Comment> getPublished(ReviewDb db, ChangeNotes notes, Comment.Key key) throws OrmException {
    if (!migration.readChanges()) {
        return getReviewDb(db, notes, key);
    }
    return publishedByChange(db, notes).stream().filter(c -> key.equals(c.key)).findFirst();
}
#end_block

#method_before
public Optional<Comment> getDraft(ReviewDb db, ChangeNotes notes, IdentifiedUser user, Comment.Key key) throws OrmException {
    if (!migration.readChanges()) {
        return Optional.ofNullable(db.patchComments().get(PatchLineComment.Key.from(notes.getChangeId(), key))).map(plc -> plc.asComment(serverId));
    }
    return draftByChangeAuthor(db, notes, user.getAccountId()).stream().filter(c -> key.equals(c.key)).findFirst();
}
#method_after
public Optional<Comment> getDraft(ReviewDb db, ChangeNotes notes, IdentifiedUser user, Comment.Key key) throws OrmException {
    if (!migration.readChanges()) {
        Optional<Comment> c = getReviewDb(db, notes, key);
        if (c.isPresent() && !c.get().author.getId().equals(user.getAccountId())) {
            throw new OrmException(String.format("Expected draft %s to belong to account %s, but it belongs to %s", key, user.getAccountId(), c.get().author.getId()));
        }
        return c;
    }
    return draftByChangeAuthor(db, notes, user.getAccountId()).stream().filter(c -> key.equals(c.key)).findFirst();
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceNotFoundException, OrmException {
    Optional<Comment> maybeComment = commentsUtil.getDraft(ctx.getDb(), ctx.getNotes(), ctx.getIdentifiedUser(), key);
    if (!maybeComment.isPresent()) {
        // because the input might be missing required fields. Just give up.
        throw new ResourceNotFoundException("comment not found: " + key);
    }
    Comment origComment = maybeComment.get();
    comment = new Comment(origComment);
    PatchSet.Id psId = new PatchSet.Id(ctx.getChange().getId(), origComment.key.patchSetId);
    ChangeUpdate update = ctx.getUpdate(psId);
    PatchSet ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    if (ps == null) {
        throw new ResourceNotFoundException("patch set not found: " + psId);
    }
    if (in.path != null && !in.path.equals(origComment.key.filename)) {
        // Updating the path alters the primary key, which isn't possible.
        // Delete then recreate the comment instead of an update.
        commentsUtil.deleteComments(ctx.getDb(), update, Collections.singleton(origComment));
        comment.key.filename = in.path;
    }
    setCommentRevId(comment, patchListCache, ctx.getChange(), ps);
    commentsUtil.putComments(ctx.getDb(), update, Status.DRAFT, Collections.singleton(update(comment, in, ctx.getWhen())));
    ctx.dontBumpLastUpdatedOn();
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceNotFoundException, OrmException {
    Optional<Comment> maybeComment = commentsUtil.getDraft(ctx.getDb(), ctx.getNotes(), ctx.getIdentifiedUser(), key);
    if (!maybeComment.isPresent()) {
        // because the input might be missing required fields. Just give up.
        throw new ResourceNotFoundException("comment not found: " + key);
    }
    Comment origComment = maybeComment.get();
    comment = new Comment(origComment);
    // Copy constructor preserved old real author; replace with current real
    // user.
    ctx.getUser().updateRealAccountId(comment::setRealAuthor);
    PatchSet.Id psId = new PatchSet.Id(ctx.getChange().getId(), origComment.key.patchSetId);
    ChangeUpdate update = ctx.getUpdate(psId);
    PatchSet ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    if (ps == null) {
        throw new ResourceNotFoundException("patch set not found: " + psId);
    }
    if (in.path != null && !in.path.equals(origComment.key.filename)) {
        // Updating the path alters the primary key, which isn't possible.
        // Delete then recreate the comment instead of an update.
        commentsUtil.deleteComments(ctx.getDb(), update, Collections.singleton(origComment));
        comment.key.filename = in.path;
    }
    setCommentRevId(comment, patchListCache, ctx.getChange(), ps);
    commentsUtil.putComments(ctx.getDb(), update, Status.DRAFT, Collections.singleton(update(comment, in, ctx.getWhen())));
    ctx.dontBumpLastUpdatedOn();
    return true;
}
#end_block

#method_before
public Change.Id cherryPick(BatchUpdate.Factory batchUpdateFactory, Change change, PatchSet patch, CherryPickInput input, RefControl refControl) throws OrmException, IOException, InvalidChangeOperationException, IntegrationException, UpdateException, RestApiException {
    return cherryPick(batchUpdateFactory, change, patch.getId(), change.getDest(), change.getTopic(), change.getProject(), ObjectId.fromString(patch.getRevision().get()), input, refControl);
}
#method_after
public Change.Id cherryPick(BatchUpdate.Factory batchUpdateFactory, Change change, PatchSet patch, CherryPickInput input, RefControl refControl) throws OrmException, IOException, InvalidChangeOperationException, IntegrationException, UpdateException, RestApiException, ConfigInvalidException {
    return cherryPick(batchUpdateFactory, change, patch.getId(), change.getProject(), ObjectId.fromString(patch.getRevision().get()), input, refControl);
}
#end_block

#method_before
public Change.Id cherryPick(BatchUpdate.Factory batchUpdateFactory, Change sourceChange, @Nullable PatchSet.Id sourcePatchId, @Nullable Branch.NameKey sourceBranch, @Nullable String sourceChangeTopic, Project.NameKey project, ObjectId sourceCommit, CherryPickInput input, RefControl destRefControl) throws OrmException, IOException, InvalidChangeOperationException, IntegrationException, UpdateException, RestApiException {
    IdentifiedUser identifiedUser = user.get();
    try (Repository git = gitManager.openRepository(project);
        // before patch sets are updated.
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        CodeReviewRevWalk revWalk = CodeReviewCommit.newRevWalk(reader)) {
        String destRefName = destRefControl.getRefName();
        Ref destRef = git.getRefDatabase().exactRef(destRefName);
        if (destRef == null) {
            throw new InvalidChangeOperationException(String.format("Branch %s does not exist.", destRefName));
        }
        RevCommit baseCommit = getBaseCommit(destRef, project.get(), revWalk, input.base);
        CodeReviewCommit commitToCherryPick = revWalk.parseCommit(sourceCommit);
        if (input.parent <= 0 || input.parent > commitToCherryPick.getParentCount()) {
            throw new InvalidChangeOperationException(String.format("Cherry Pick: Parent %s does not exist. Please specify a parent in" + " range [1, %s].", input.parent, commitToCherryPick.getParentCount()));
        }
        Timestamp now = TimeUtil.nowTs();
        PersonIdent committerIdent = identifiedUser.newCommitterIdent(now, serverTimeZone);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(commitToCherryPick.getTree(), baseCommit, commitToCherryPick.getAuthorIdent(), committerIdent, input.message);
        String commitMessage = ChangeIdUtil.insertId(input.message, computedChangeId).trim() + '\n';
        CodeReviewCommit cherryPickCommit;
        try {
            ProjectState projectState = destRefControl.getProjectControl().getProjectState();
            cherryPickCommit = mergeUtilFactory.create(projectState).createCherryPickFromCommit(oi, git.getConfig(), baseCommit, commitToCherryPick, committerIdent, commitMessage, revWalk, input.parent - 1, false);
            Change.Key changeKey;
            final List<String> idList = cherryPickCommit.getFooterLines(FooterConstants.CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                changeKey = new Change.Key(idStr);
            } else {
                changeKey = new Change.Key("I" + computedChangeId.name());
            }
            Branch.NameKey newDest = new Branch.NameKey(project, destRef.getName());
            List<ChangeData> destChanges = queryProvider.get().setLimit(2).byBranchKey(newDest, changeKey);
            if (destChanges.size() > 1) {
                throw new InvalidChangeOperationException("Several changes with key " + changeKey + " reside on the same branch. " + "Cannot create a new patch set.");
            }
            try (BatchUpdate bu = batchUpdateFactory.create(dbProvider.get(), project, identifiedUser, now)) {
                bu.setRepository(git, revWalk, oi);
                Change.Id result;
                if (destChanges.size() == 1) {
                    // The change key exists on the destination branch. The cherry pick
                    // will be added as a new patch set.
                    ChangeControl destCtl = destRefControl.getProjectControl().controlFor(destChanges.get(0).notes());
                    result = insertPatchSet(bu, git, destCtl, cherryPickCommit, input);
                } else {
                    // Change key not found on destination branch. We can create a new
                    // change.
                    String newTopic = null;
                    if (!Strings.isNullOrEmpty(sourceChangeTopic)) {
                        newTopic = sourceChangeTopic + "-" + newDest.getShortName();
                    }
                    result = createNewChange(bu, cherryPickCommit, destRefControl, newTopic, sourceChange, sourceCommit, input);
                    if (sourceChange != null && sourcePatchId != null) {
                        bu.addOp(sourceChange.getId(), new AddMessageToSourceChangeOp(changeMessagesUtil, sourcePatchId, RefNames.shortName(destRefName), cherryPickCommit));
                    }
                }
                bu.execute();
                return result;
            }
        } catch (MergeIdenticalTreeException | MergeConflictException e) {
            throw new IntegrationException("Cherry pick failed: " + e.getMessage());
        }
    }
}
#method_after
public Change.Id cherryPick(BatchUpdate.Factory batchUpdateFactory, @Nullable Change sourceChange, @Nullable PatchSet.Id sourcePatchId, Project.NameKey project, ObjectId sourceCommit, CherryPickInput input, RefControl destRefControl) throws OrmException, IOException, InvalidChangeOperationException, IntegrationException, UpdateException, RestApiException, ConfigInvalidException {
    IdentifiedUser identifiedUser = user.get();
    try (Repository git = gitManager.openRepository(project);
        // before patch sets are updated.
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        CodeReviewRevWalk revWalk = CodeReviewCommit.newRevWalk(reader)) {
        String destRefName = destRefControl.getRefName();
        Ref destRef = git.getRefDatabase().exactRef(destRefName);
        if (destRef == null) {
            throw new InvalidChangeOperationException(String.format("Branch %s does not exist.", destRefName));
        }
        RevCommit baseCommit = getBaseCommit(destRef, project.get(), revWalk, input.base);
        CodeReviewCommit commitToCherryPick = revWalk.parseCommit(sourceCommit);
        if (input.parent <= 0 || input.parent > commitToCherryPick.getParentCount()) {
            throw new InvalidChangeOperationException(String.format("Cherry Pick: Parent %s does not exist. Please specify a parent in" + " range [1, %s].", input.parent, commitToCherryPick.getParentCount()));
        }
        Timestamp now = TimeUtil.nowTs();
        PersonIdent committerIdent = identifiedUser.newCommitterIdent(now, serverTimeZone);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(commitToCherryPick.getTree(), baseCommit, commitToCherryPick.getAuthorIdent(), committerIdent, input.message);
        String commitMessage = ChangeIdUtil.insertId(input.message, computedChangeId).trim() + '\n';
        CodeReviewCommit cherryPickCommit;
        try {
            ProjectState projectState = destRefControl.getProjectControl().getProjectState();
            cherryPickCommit = mergeUtilFactory.create(projectState).createCherryPickFromCommit(oi, git.getConfig(), baseCommit, commitToCherryPick, committerIdent, commitMessage, revWalk, input.parent - 1, false);
            Change.Key changeKey;
            final List<String> idList = cherryPickCommit.getFooterLines(FooterConstants.CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                changeKey = new Change.Key(idStr);
            } else {
                changeKey = new Change.Key("I" + computedChangeId.name());
            }
            Branch.NameKey newDest = new Branch.NameKey(project, destRef.getName());
            List<ChangeData> destChanges = queryProvider.get().setLimit(2).byBranchKey(newDest, changeKey);
            if (destChanges.size() > 1) {
                throw new InvalidChangeOperationException("Several changes with key " + changeKey + " reside on the same branch. " + "Cannot create a new patch set.");
            }
            try (BatchUpdate bu = batchUpdateFactory.create(dbProvider.get(), project, identifiedUser, now)) {
                bu.setRepository(git, revWalk, oi);
                Change.Id result;
                if (destChanges.size() == 1) {
                    // The change key exists on the destination branch. The cherry pick
                    // will be added as a new patch set.
                    ChangeControl destCtl = destRefControl.getProjectControl().controlFor(destChanges.get(0).notes());
                    result = insertPatchSet(bu, git, destCtl, cherryPickCommit, input);
                } else {
                    // Change key not found on destination branch. We can create a new
                    // change.
                    String newTopic = null;
                    if (sourceChange != null && !Strings.isNullOrEmpty(sourceChange.getTopic())) {
                        newTopic = sourceChange.getTopic() + "-" + newDest.getShortName();
                    }
                    result = createNewChange(bu, cherryPickCommit, destRefName, newTopic, sourceChange, sourceCommit, input);
                    if (sourceChange != null && sourcePatchId != null) {
                        bu.addOp(sourceChange.getId(), new AddMessageToSourceChangeOp(changeMessagesUtil, sourcePatchId, RefNames.shortName(destRefName), cherryPickCommit));
                    }
                }
                bu.execute();
                return result;
            }
        } catch (MergeIdenticalTreeException | MergeConflictException e) {
            throw new IntegrationException("Cherry pick failed: " + e.getMessage());
        }
    }
}
#end_block

#method_before
private Change.Id insertPatchSet(BatchUpdate bu, Repository git, ChangeControl destCtl, CodeReviewCommit cherryPickCommit, CherryPickInput input) throws IOException, OrmException, BadRequestException {
    Change destChange = destCtl.getChange();
    PatchSet.Id psId = ChangeUtil.nextPatchSetId(git, destChange.currentPatchSetId());
    PatchSet current = psUtil.current(dbProvider.get(), destCtl.getNotes());
    PatchSetInserter inserter = patchSetInserterFactory.create(destCtl, psId, cherryPickCommit);
    inserter.setMessage("Uploaded patch set " + inserter.getPatchSetId().get() + ".").setDraft(current.isDraft()).setNotify(input.notify).setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
    bu.addOp(destChange.getId(), inserter);
    return destChange.getId();
}
#method_after
private Change.Id insertPatchSet(BatchUpdate bu, Repository git, ChangeControl destCtl, CodeReviewCommit cherryPickCommit, CherryPickInput input) throws IOException, OrmException, BadRequestException, ConfigInvalidException {
    Change destChange = destCtl.getChange();
    PatchSet.Id psId = ChangeUtil.nextPatchSetId(git, destChange.currentPatchSetId());
    PatchSet current = psUtil.current(dbProvider.get(), destCtl.getNotes());
    PatchSetInserter inserter = patchSetInserterFactory.create(destCtl, psId, cherryPickCommit);
    inserter.setMessage("Uploaded patch set " + inserter.getPatchSetId().get() + ".").setDraft(current.isDraft()).setNotify(input.notify).setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
    bu.addOp(destChange.getId(), inserter);
    return destChange.getId();
}
#end_block

#method_before
private Change.Id createNewChange(BatchUpdate bu, CodeReviewCommit cherryPickCommit, RefControl destRefControl, String topic, Change sourceChange, ObjectId sourceCommit, CherryPickInput input) throws OrmException, IOException, BadRequestException {
    Change.Id changeId = new Change.Id(seq.nextChangeId());
    ChangeInserter ins = changeInserterFactory.create(changeId, cherryPickCommit, destRefControl.getRefName());
    Branch.NameKey sourceBranch = null;
    if (sourceChange != null) {
        sourceBranch = sourceChange.getDest();
    }
    ins.setMessage(messageForDestinationChange(ins.getPatchSetId(), sourceBranch, sourceCommit)).setTopic(topic).setNotify(input.notify).setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
    if (input.keepReviewers && sourceChange != null) {
        ReviewerSet reviewerSet = approvalsUtil.getReviewers(dbProvider.get(), destRefControl.getProjectControl().controlFor(dbProvider.get(), sourceChange).getNotes());
        Set<Account.Id> reviewers = new HashSet<>(reviewerSet.byState(ReviewerStateInternal.REVIEWER));
        reviewers.add(sourceChange.getOwner());
        Set<Account.Id> ccs = new HashSet<>(reviewerSet.byState(ReviewerStateInternal.CC));
        ins.setReviewers(reviewers).setExtraCC(ccs);
    }
    bu.insertChange(ins);
    return changeId;
}
#method_after
private Change.Id createNewChange(BatchUpdate bu, CodeReviewCommit cherryPickCommit, String refName, String topic, @Nullable Change sourceChange, ObjectId sourceCommit, CherryPickInput input) throws OrmException, IOException, BadRequestException, ConfigInvalidException {
    Change.Id changeId = new Change.Id(seq.nextChangeId());
    ChangeInserter ins = changeInserterFactory.create(changeId, cherryPickCommit, refName);
    Branch.NameKey sourceBranch = sourceChange == null ? null : sourceChange.getDest();
    ins.setMessage(messageForDestinationChange(ins.getPatchSetId(), sourceBranch, sourceCommit)).setTopic(topic).setNotify(input.notify).setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
    if (input.keepReviewers && sourceChange != null) {
        ReviewerSet reviewerSet = approvalsUtil.getReviewers(dbProvider.get(), changeNotesFactory.createChecked(dbProvider.get(), sourceChange));
        Set<Account.Id> reviewers = new HashSet<>(reviewerSet.byState(ReviewerStateInternal.REVIEWER));
        reviewers.add(sourceChange.getOwner());
        reviewers.remove(user.get().getAccountId());
        Set<Account.Id> ccs = new HashSet<>(reviewerSet.byState(ReviewerStateInternal.CC));
        ccs.remove(user.get().getAccountId());
        ins.setReviewers(reviewers).setExtraCC(ccs);
    }
    bu.insertChange(ins);
    return changeId;
}
#end_block

#method_before
@Test
public void cherryPickNotify() throws Exception {
    createBranch(new NameKey(project, "branch-1"));
    createBranch(new NameKey(project, "branch-2"));
    createBranch(new NameKey(project, "branch-3"));
    // Creates a change for 'admin'.
    PushOneCommit.Result result = createChange();
    String changeId = project.get() + "~master~" + result.getChangeId();
    // 'user' cherry-picks the change to a new branch, the source change's author/committer('admin')
    // will be added as a reviewer of the newly created change.
    setApiUser(user);
    CherryPickInput input = new CherryPickInput();
    input.message = "it goes to a new branch";
    // Enable the notification. 'admin' as a reviewer should be notified.
    input.destination = "branch-1";
    input.notify = NotifyHandling.ALL;
    sender.clear();
    gApi.changes().id(changeId).current().cherryPick(input);
    assertNotifyCc(admin);
    // Disable the notification. 'admin' as a reviewer should not be notified any more.
    input.destination = "branch-2";
    input.notify = NotifyHandling.NONE;
    sender.clear();
    gApi.changes().id(changeId).current().cherryPick(input);
    assertThat(sender.getMessages()).hasSize(0);
    // Disable the notification. The user provided in the 'notifyDetails' should still be notified.
    TestAccount userToNotify = accountCreator.user2();
    input.destination = "branch-3";
    input.notify = NotifyHandling.NONE;
    input.notifyDetails = ImmutableMap.of(RecipientType.TO, new NotifyInfo(ImmutableList.of(userToNotify.email)));
    sender.clear();
    gApi.changes().id(changeId).current().cherryPick(input);
    assertNotifyTo(userToNotify);
}
#method_after
@Test
public void cherryPickNotify() throws Exception {
    createBranch(new Branch.NameKey(project, "branch-1"));
    createBranch(new Branch.NameKey(project, "branch-2"));
    createBranch(new Branch.NameKey(project, "branch-3"));
    // Creates a change for 'admin'.
    PushOneCommit.Result result = createChange();
    String changeId = project.get() + "~master~" + result.getChangeId();
    // 'user' cherry-picks the change to a new branch, the source change's author/committer('admin')
    // will be added as a reviewer of the newly created change.
    setApiUser(user);
    CherryPickInput input = new CherryPickInput();
    input.message = "it goes to a new branch";
    // Enable the notification. 'admin' as a reviewer should be notified.
    input.destination = "branch-1";
    input.notify = NotifyHandling.ALL;
    sender.clear();
    gApi.changes().id(changeId).current().cherryPick(input);
    assertNotifyCc(admin);
    // Disable the notification. 'admin' as a reviewer should not be notified any more.
    input.destination = "branch-2";
    input.notify = NotifyHandling.NONE;
    sender.clear();
    gApi.changes().id(changeId).current().cherryPick(input);
    assertThat(sender.getMessages()).hasSize(0);
    // Disable the notification. The user provided in the 'notifyDetails' should still be notified.
    TestAccount userToNotify = accountCreator.user2();
    input.destination = "branch-3";
    input.notify = NotifyHandling.NONE;
    input.notifyDetails = ImmutableMap.of(RecipientType.TO, new NotifyInfo(ImmutableList.of(userToNotify.email)));
    sender.clear();
    gApi.changes().id(changeId).current().cherryPick(input);
    assertNotifyTo(userToNotify);
}
#end_block

#method_before
@Test
public void cherryPickKeepReviewers() throws Exception {
    createBranch(new NameKey(project, "stable"));
    // admin creates the change.
    PushOneCommit.Result r = createChange();
    // Which is approved by admin2, who also adds user as a CC.
    setApiUser(accountCreator.admin2());
    ReviewInput in = ReviewInput.approve();
    in.reviewer(accountCreator.admin2().email);
    in.reviewer(user.email, ReviewerState.CC, true);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(in);
    // Finally, cherrypicked by user2.
    setApiUser(accountCreator.user2());
    CherryPickInput cin = new CherryPickInput();
    cin.message = "this need to go to stable";
    cin.destination = "stable";
    cin.keepReviewers = true;
    Map<ReviewerState, Collection<AccountInfo>> result = gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).cherryPick(cin).get().reviewers;
    // Therefore, admin and admin2 should both be reviewers (as the old
    // owner and old reviewer), and user should still be on CC.
    assertThat(result).containsKey(ReviewerState.REVIEWER);
    List<Integer> reviewers = result.get(ReviewerState.REVIEWER).stream().map(a -> a._accountId).collect(toList());
    if (notesMigration.readChanges()) {
        assertThat(result).containsKey(ReviewerState.CC);
        List<Integer> ccs = result.get(ReviewerState.CC).stream().map(a -> a._accountId).collect(toList());
        assertThat(ccs).containsExactly(user.id.get());
        assertThat(reviewers).containsExactly(admin.id.get(), accountCreator.admin2().id.get());
    } else {
        assertThat(reviewers).containsExactly(user.id.get(), admin.id.get(), accountCreator.admin2().id.get());
    }
}
#method_after
@Test
public void cherryPickKeepReviewers() throws Exception {
    createBranch(new Branch.NameKey(project, "stable"));
    // Change is created by 'admin'.
    PushOneCommit.Result r = createChange();
    // Change is approved by 'admin2'. Change is CC'd to 'user'.
    setApiUser(accountCreator.admin2());
    ReviewInput in = ReviewInput.approve();
    in.reviewer(user.email, ReviewerState.CC, true);
    gApi.changes().id(r.getChangeId()).current().review(in);
    // Change is cherrypicked by 'user2'.
    setApiUser(accountCreator.user2());
    CherryPickInput cin = new CherryPickInput();
    cin.message = "this need to go to stable";
    cin.destination = "stable";
    cin.keepReviewers = true;
    Map<ReviewerState, Collection<AccountInfo>> result = gApi.changes().id(r.getChangeId()).current().cherryPick(cin).get().reviewers;
    // 'admin' should be a reviewer as the old owner.
    // 'admin2' should be a reviewer as the old reviewer.
    // 'user' should be on CC.
    assertThat(result).containsKey(ReviewerState.REVIEWER);
    List<Integer> reviewers = result.get(ReviewerState.REVIEWER).stream().map(a -> a._accountId).collect(toList());
    if (notesMigration.readChanges()) {
        assertThat(result).containsKey(ReviewerState.CC);
        List<Integer> ccs = result.get(ReviewerState.CC).stream().map(a -> a._accountId).collect(toList());
        assertThat(ccs).containsExactly(user.id.get());
        assertThat(reviewers).containsExactly(admin.id.get(), accountCreator.admin2().id.get());
    } else {
        assertThat(reviewers).containsExactly(user.id.get(), admin.id.get(), accountCreator.admin2().id.get());
    }
}
#end_block

#method_before
@Test
public void cherryPickToMergedChangeRevision() throws Exception {
    createBranch(new NameKey(project, "foo"));
    PushOneCommit.Result dstChange = createChange(testRepo, "foo", SUBJECT, "b.txt", "b", "t");
    dstChange.assertOkStatus();
    merge(dstChange);
    PushOneCommit.Result result = createChange(testRepo, "foo", SUBJECT, "b.txt", "c", "t");
    result.assertOkStatus();
    merge(result);
    PushOneCommit.Result srcChange = createChange();
    CherryPickInput input = new CherryPickInput();
    input.destination = "foo";
    input.base = dstChange.getCommit().name();
    input.message = srcChange.getCommit().getFullMessage();
    ChangeInfo changeInfo = gApi.changes().id(srcChange.getChangeId()).current().cherryPick(input).get();
    assertCherryPickResult(changeInfo, input, srcChange.getChangeId());
}
#method_after
@Test
public void cherryPickToMergedChangeRevision() throws Exception {
    createBranch(new Branch.NameKey(project, "foo"));
    PushOneCommit.Result dstChange = createChange(testRepo, "foo", SUBJECT, "b.txt", "b", "t");
    dstChange.assertOkStatus();
    merge(dstChange);
    PushOneCommit.Result result = createChange(testRepo, "foo", SUBJECT, "b.txt", "c", "t");
    result.assertOkStatus();
    merge(result);
    PushOneCommit.Result srcChange = createChange();
    CherryPickInput input = new CherryPickInput();
    input.destination = "foo";
    input.base = dstChange.getCommit().name();
    input.message = srcChange.getCommit().getFullMessage();
    ChangeInfo changeInfo = gApi.changes().id(srcChange.getChangeId()).current().cherryPick(input).get();
    assertCherryPickResult(changeInfo, input, srcChange.getChangeId());
}
#end_block

#method_before
@Test
public void cherryPickToOpenChangeRevision() throws Exception {
    createBranch(new NameKey(project, "foo"));
    PushOneCommit.Result dstChange = createChange(testRepo, "foo", SUBJECT, "b.txt", "b", "t");
    dstChange.assertOkStatus();
    PushOneCommit.Result srcChange = createChange();
    CherryPickInput input = new CherryPickInput();
    input.destination = "foo";
    input.base = dstChange.getCommit().name();
    input.message = srcChange.getCommit().getFullMessage();
    ChangeInfo changeInfo = gApi.changes().id(srcChange.getChangeId()).current().cherryPick(input).get();
    assertCherryPickResult(changeInfo, input, srcChange.getChangeId());
}
#method_after
@Test
public void cherryPickToOpenChangeRevision() throws Exception {
    createBranch(new Branch.NameKey(project, "foo"));
    PushOneCommit.Result dstChange = createChange(testRepo, "foo", SUBJECT, "b.txt", "b", "t");
    dstChange.assertOkStatus();
    PushOneCommit.Result srcChange = createChange();
    CherryPickInput input = new CherryPickInput();
    input.destination = "foo";
    input.base = dstChange.getCommit().name();
    input.message = srcChange.getCommit().getFullMessage();
    ChangeInfo changeInfo = gApi.changes().id(srcChange.getChangeId()).current().cherryPick(input).get();
    assertCherryPickResult(changeInfo, input, srcChange.getChangeId());
}
#end_block

#method_before
@Test
public void cherryPickToNonVisibleChangeFails() throws Exception {
    createBranch(new NameKey(project, "foo"));
    PushOneCommit.Result dstChange = createChange(testRepo, "foo", SUBJECT, "b.txt", "b", "t");
    dstChange.assertOkStatus();
    gApi.changes().id(dstChange.getChangeId()).setPrivate(true, null);
    PushOneCommit.Result srcChange = createChange();
    CherryPickInput input = new CherryPickInput();
    input.destination = "foo";
    input.base = dstChange.getCommit().name();
    input.message = srcChange.getCommit().getFullMessage();
    setApiUser(user);
    exception.expect(UnprocessableEntityException.class);
    exception.expectMessage(String.format("Commit %s does not exist on branch refs/heads/foo", input.base));
    gApi.changes().id(srcChange.getChangeId()).current().cherryPick(input).get();
}
#method_after
@Test
public void cherryPickToNonVisibleChangeFails() throws Exception {
    createBranch(new Branch.NameKey(project, "foo"));
    PushOneCommit.Result dstChange = createChange(testRepo, "foo", SUBJECT, "b.txt", "b", "t");
    dstChange.assertOkStatus();
    gApi.changes().id(dstChange.getChangeId()).setPrivate(true, null);
    PushOneCommit.Result srcChange = createChange();
    CherryPickInput input = new CherryPickInput();
    input.destination = "foo";
    input.base = dstChange.getCommit().name();
    input.message = srcChange.getCommit().getFullMessage();
    setApiUser(user);
    exception.expect(UnprocessableEntityException.class);
    exception.expectMessage(String.format("Commit %s does not exist on branch refs/heads/foo", input.base));
    gApi.changes().id(srcChange.getChangeId()).current().cherryPick(input).get();
}
#end_block

#method_before
@Test
public void pushWorkInProgressChangeWhenNotOwner() throws Exception {
    TestRepository<?> userRepo = cloneProject(project, user);
    PushOneCommit.Result r = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master%wip");
    r.assertOkStatus();
    assertThat(r.getChange().change().getOwner()).isEqualTo(user.id);
    assertThat(r.getChange().change().isWorkInProgress()).isTrue();
    GitUtil.fetch(testRepo, r.getPatchSet().getRefName() + ":ps");
    testRepo.reset("ps");
    r = amendChange(r.getChangeId(), "refs/for/master%wip", admin, testRepo);
    r.assertErrorStatus(ReplaceOp.ONLY_OWNER_CAN_MODIFY_WIP);
    r = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master%ready");
    r.assertOkStatus();
    assertThat(r.getChange().change().isWorkInProgress()).isFalse();
    GitUtil.fetch(testRepo, r.getPatchSet().getRefName() + ":ps");
    testRepo.reset("ps");
    r = amendChange(r.getChangeId(), "refs/for/master%ready", admin, testRepo);
    r.assertErrorStatus(ReplaceOp.ONLY_OWNER_CAN_MODIFY_WIP);
}
#method_after
@Test
public void pushWorkInProgressChangeWhenNotOwner() throws Exception {
    TestRepository<?> userRepo = cloneProject(project, user);
    PushOneCommit.Result r = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master%wip");
    r.assertOkStatus();
    assertThat(r.getChange().change().getOwner()).isEqualTo(user.id);
    assertThat(r.getChange().change().isWorkInProgress()).isTrue();
    // Other user trying to move from WIP to ready should fail.
    GitUtil.fetch(testRepo, r.getPatchSet().getRefName() + ":ps");
    testRepo.reset("ps");
    r = amendChange(r.getChangeId(), "refs/for/master%ready", admin, testRepo);
    r.assertErrorStatus(ReceiveCommits.ONLY_OWNER_CAN_MODIFY_WIP);
    // Other user trying to move from WIP to WIP should succeed.
    r = amendChange(r.getChangeId(), "refs/for/master%wip", admin, testRepo);
    r.assertOkStatus();
    assertThat(r.getChange().change().isWorkInProgress()).isTrue();
    // Push as change owner to move change from WIP to ready.
    r = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master%ready");
    r.assertOkStatus();
    assertThat(r.getChange().change().isWorkInProgress()).isFalse();
    // Other user trying to move from ready to WIP should fail.
    GitUtil.fetch(testRepo, r.getPatchSet().getRefName() + ":ps");
    testRepo.reset("ps");
    r = amendChange(r.getChangeId(), "refs/for/master%wip", admin, testRepo);
    r.assertErrorStatus(ReceiveCommits.ONLY_OWNER_CAN_MODIFY_WIP);
    // Other user trying to move from ready to ready should succeed.
    r = amendChange(r.getChangeId(), "refs/for/master%ready", admin, testRepo);
    r.assertOkStatus();
}
#end_block

#method_before
@Override
public List<TagInfo> apply(ProjectResource resource) throws IOException, ResourceNotFoundException, BadRequestException {
    List<TagInfo> tags = new ArrayList<>();
    PermissionBackend.ForProject perm = permissionBackend.user(user).project(resource.getNameKey());
    try (Repository repo = getRepository(resource.getNameKey());
        RevWalk rw = new RevWalk(repo)) {
        ProjectControl pctl = resource.getControl();
        Map<String, Ref> all = visibleTags(pctl, repo, repo.getRefDatabase().getRefs(Constants.R_TAGS));
        for (Ref ref : all.values()) {
            tags.add(createTagInfo(perm.ref(ref.getName()), ref, rw, pctl, links));
        }
    }
    Collections.sort(tags, new Comparator<TagInfo>() {

        @Override
        public int compare(TagInfo a, TagInfo b) {
            return a.ref.compareTo(b.ref);
        }
    });
    return new RefFilter<TagInfo>(Constants.R_TAGS).start(start).limit(limit).subString(matchSubstring).regex(matchRegex).filter(tags);
}
#method_after
@Override
public List<TagInfo> apply(ProjectResource resource) throws IOException, ResourceNotFoundException, BadRequestException {
    List<TagInfo> tags = new ArrayList<>();
    PermissionBackend.ForProject perm = permissionBackend.user(user).project(resource.getNameKey());
    try (Repository repo = getRepository(resource.getNameKey());
        RevWalk rw = new RevWalk(repo)) {
        ProjectControl pctl = resource.getControl();
        Map<String, Ref> all = visibleTags(pctl, repo, repo.getRefDatabase().getRefs(Constants.R_TAGS));
        for (Ref ref : all.values()) {
            tags.add(createTagInfo(perm.ref(ref.getName()), ref, rw, pctl.getProject().getNameKey(), links));
        }
    }
    Collections.sort(tags, new Comparator<TagInfo>() {

        @Override
        public int compare(TagInfo a, TagInfo b) {
            return a.ref.compareTo(b.ref);
        }
    });
    return new RefFilter<TagInfo>(Constants.R_TAGS).start(start).limit(limit).subString(matchSubstring).regex(matchRegex).filter(tags);
}
#end_block

#method_before
public TagInfo get(ProjectResource resource, IdString id) throws ResourceNotFoundException, IOException {
    try (Repository repo = getRepository(resource.getNameKey());
        RevWalk rw = new RevWalk(repo)) {
        String tagName = id.get();
        if (!tagName.startsWith(Constants.R_TAGS)) {
            tagName = Constants.R_TAGS + tagName;
        }
        Ref ref = repo.getRefDatabase().exactRef(tagName);
        ProjectControl pctl = resource.getControl();
        if (ref != null && !visibleTags(pctl, repo, ImmutableMap.of(ref.getName(), ref)).isEmpty()) {
            return createTagInfo(permissionBackend.user(pctl.getUser()).project(resource.getNameKey()).ref(ref.getName()), ref, rw, pctl, links);
        }
    }
    throw new ResourceNotFoundException(id);
}
#method_after
public TagInfo get(ProjectResource resource, IdString id) throws ResourceNotFoundException, IOException {
    try (Repository repo = getRepository(resource.getNameKey());
        RevWalk rw = new RevWalk(repo)) {
        String tagName = id.get();
        if (!tagName.startsWith(Constants.R_TAGS)) {
            tagName = Constants.R_TAGS + tagName;
        }
        Ref ref = repo.getRefDatabase().exactRef(tagName);
        ProjectControl pctl = resource.getControl();
        if (ref != null && !visibleTags(pctl, repo, ImmutableMap.of(ref.getName(), ref)).isEmpty()) {
            return createTagInfo(permissionBackend.user(pctl.getUser()).project(resource.getNameKey()).ref(ref.getName()), ref, rw, pctl.getProject().getNameKey(), links);
        }
    }
    throw new ResourceNotFoundException(id);
}
#end_block

#method_before
public static TagInfo createTagInfo(PermissionBackend.ForRef perm, Ref ref, RevWalk rw, ProjectControl pctl, WebLinks links) throws MissingObjectException, IOException {
    RevObject object = rw.parseAny(ref.getObjectId());
    boolean canDelete = perm.testOrFalse(RefPermission.DELETE);
    List<WebLinkInfo> webLinks = links.getTagLinks(pctl.getProject().getName(), ref.getName());
    if (object instanceof RevTag) {
        // Annotated or signed tag
        RevTag tag = (RevTag) object;
        PersonIdent tagger = tag.getTaggerIdent();
        return new TagInfo(ref.getName(), tag.getName(), tag.getObject().getName(), tag.getFullMessage().trim(), tagger != null ? CommonConverters.toGitPerson(tag.getTaggerIdent()) : null, canDelete, webLinks.isEmpty() ? null : webLinks);
    }
    // Lightweight tag
    return new TagInfo(ref.getName(), ref.getObjectId().getName(), canDelete, webLinks.isEmpty() ? null : webLinks);
}
#method_after
public static TagInfo createTagInfo(PermissionBackend.ForRef perm, Ref ref, RevWalk rw, Project.NameKey projectName, WebLinks links) throws MissingObjectException, IOException {
    RevObject object = rw.parseAny(ref.getObjectId());
    boolean canDelete = perm.testOrFalse(RefPermission.DELETE);
    List<WebLinkInfo> webLinks = links.getTagLinks(projectName.get(), ref.getName());
    if (object instanceof RevTag) {
        // Annotated or signed tag
        RevTag tag = (RevTag) object;
        PersonIdent tagger = tag.getTaggerIdent();
        return new TagInfo(ref.getName(), tag.getName(), tag.getObject().getName(), tag.getFullMessage().trim(), tagger != null ? CommonConverters.toGitPerson(tag.getTaggerIdent()) : null, canDelete, webLinks.isEmpty() ? null : webLinks);
    }
    // Lightweight tag
    return new TagInfo(ref.getName(), ref.getObjectId().getName(), canDelete, webLinks.isEmpty() ? null : webLinks);
}
#end_block

#method_before
@Override
public TagInfo apply(ProjectResource resource, TagInput input) throws RestApiException, IOException, PermissionBackendException {
    if (input == null) {
        input = new TagInput();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    ref = RefUtil.normalizeTagRef(ref);
    RefControl refControl = resource.getControl().controlForRef(ref);
    PermissionBackend.ForRef perm = permissionBackend.user(identifiedUser).project(resource.getNameKey()).ref(ref);
    try (Repository repo = repoManager.openRepository(resource.getNameKey())) {
        ObjectId revid = RefUtil.parseBaseRevision(repo, resource.getNameKey(), input.revision);
        RevWalk rw = RefUtil.verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        rw.reset();
        boolean isAnnotated = Strings.emptyToNull(input.message) != null;
        boolean isSigned = isAnnotated && input.message.contains("-----BEGIN PGP SIGNATURE-----\n");
        if (isSigned) {
            throw new MethodNotAllowedException("Cannot create signed tag \"" + ref + "\"");
        } else if (isAnnotated && !refControl.canPerform(Permission.CREATE_TAG)) {
            throw new AuthException("Cannot create annotated tag \"" + ref + "\"");
        } else {
            perm.check(RefPermission.CREATE);
        }
        if (repo.getRefDatabase().exactRef(ref) != null) {
            throw new ResourceConflictException("tag \"" + ref + "\" already exists");
        }
        try (Git git = new Git(repo)) {
            TagCommand tag = git.tag().setObjectId(object).setName(ref.substring(R_TAGS.length())).setAnnotated(isAnnotated).setSigned(isSigned);
            if (isAnnotated) {
                tag.setMessage(input.message).setTagger(identifiedUser.get().newCommitterIdent(TimeUtil.nowTs(), TimeZone.getDefault()));
            }
            Ref result = tag.call();
            tagCache.updateFastForward(resource.getNameKey(), ref, ObjectId.zeroId(), result.getObjectId());
            referenceUpdated.fire(resource.getNameKey(), ref, ObjectId.zeroId(), result.getObjectId(), identifiedUser.get().getAccount());
            try (RevWalk w = new RevWalk(repo)) {
                return ListTags.createTagInfo(perm, result, w, resource.getControl(), links);
            }
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("Invalid base revision");
    } catch (GitAPIException e) {
        log.error("Cannot create tag \"" + ref + "\"", e);
        throw new IOException(e);
    }
}
#method_after
@Override
public TagInfo apply(ProjectResource resource, TagInput input) throws RestApiException, IOException, PermissionBackendException {
    if (input == null) {
        input = new TagInput();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    ref = RefUtil.normalizeTagRef(ref);
    RefControl refControl = resource.getControl().controlForRef(ref);
    PermissionBackend.ForRef perm = permissionBackend.user(identifiedUser).project(resource.getNameKey()).ref(ref);
    try (Repository repo = repoManager.openRepository(resource.getNameKey())) {
        ObjectId revid = RefUtil.parseBaseRevision(repo, resource.getNameKey(), input.revision);
        RevWalk rw = RefUtil.verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        rw.reset();
        boolean isAnnotated = Strings.emptyToNull(input.message) != null;
        boolean isSigned = isAnnotated && input.message.contains("-----BEGIN PGP SIGNATURE-----\n");
        if (isSigned) {
            throw new MethodNotAllowedException("Cannot create signed tag \"" + ref + "\"");
        } else if (isAnnotated && !refControl.canPerform(Permission.CREATE_TAG)) {
            throw new AuthException("Cannot create annotated tag \"" + ref + "\"");
        } else {
            perm.check(RefPermission.CREATE);
        }
        if (repo.getRefDatabase().exactRef(ref) != null) {
            throw new ResourceConflictException("tag \"" + ref + "\" already exists");
        }
        try (Git git = new Git(repo)) {
            TagCommand tag = git.tag().setObjectId(object).setName(ref.substring(R_TAGS.length())).setAnnotated(isAnnotated).setSigned(isSigned);
            if (isAnnotated) {
                tag.setMessage(input.message).setTagger(identifiedUser.get().newCommitterIdent(TimeUtil.nowTs(), TimeZone.getDefault()));
            }
            Ref result = tag.call();
            tagCache.updateFastForward(resource.getNameKey(), ref, ObjectId.zeroId(), result.getObjectId());
            referenceUpdated.fire(resource.getNameKey(), ref, ObjectId.zeroId(), result.getObjectId(), identifiedUser.get().getAccount());
            try (RevWalk w = new RevWalk(repo)) {
                return ListTags.createTagInfo(perm, result, w, resource.getNameKey(), links);
            }
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("Invalid base revision");
    } catch (GitAPIException e) {
        log.error("Cannot create tag \"" + ref + "\"", e);
        throw new IOException(e);
    }
}
#end_block

#method_before
@Override
public TagInfo apply(ProjectResource resource, TagInput input) throws RestApiException, IOException {
    if (input == null) {
        input = new TagInput();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    ref = RefUtil.normalizeTagRef(ref);
    RefControl refControl = resource.getControl().controlForRef(ref);
    try (Repository repo = repoManager.openRepository(resource.getNameKey())) {
        ObjectId revid = RefUtil.parseBaseRevision(repo, resource.getNameKey(), input.revision);
        RevWalk rw = RefUtil.verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        rw.reset();
        boolean isAnnotated = Strings.emptyToNull(input.message) != null;
        boolean isSigned = isAnnotated && input.message.contains("-----BEGIN PGP SIGNATURE-----\n");
        if (isSigned) {
            throw new MethodNotAllowedException("Cannot create signed tag \"" + ref + "\"");
        } else if (isAnnotated && !refControl.canPerform(Permission.CREATE_TAG)) {
            throw new AuthException("Cannot create annotated tag \"" + ref + "\"");
        } else if (!refControl.canPerform(Permission.CREATE)) {
            throw new AuthException("Cannot create tag \"" + ref + "\"");
        }
        if (repo.getRefDatabase().exactRef(ref) != null) {
            throw new ResourceConflictException("tag \"" + ref + "\" already exists");
        }
        try (Git git = new Git(repo)) {
            TagCommand tag = git.tag().setObjectId(object).setName(ref.substring(R_TAGS.length())).setAnnotated(isAnnotated).setSigned(isSigned);
            if (isAnnotated) {
                tag.setMessage(input.message).setTagger(identifiedUser.get().newCommitterIdent(TimeUtil.nowTs(), TimeZone.getDefault()));
            }
            Ref result = tag.call();
            tagCache.updateFastForward(resource.getNameKey(), ref, ObjectId.zeroId(), result.getObjectId());
            referenceUpdated.fire(resource.getNameKey(), ref, ObjectId.zeroId(), result.getObjectId(), identifiedUser.get().getAccount());
            ProjectControl pctl = resource.getControl();
            try (RevWalk w = new RevWalk(repo)) {
                return ListTags.createTagInfo(result, w, refControl, pctl, links);
            }
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("Invalid base revision");
    } catch (GitAPIException e) {
        log.error("Cannot create tag \"" + ref + "\"", e);
        throw new IOException(e);
    }
}
#method_after
@Override
public TagInfo apply(ProjectResource resource, TagInput input) throws RestApiException, IOException {
    if (input == null) {
        input = new TagInput();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    ref = RefUtil.normalizeTagRef(ref);
    RefControl refControl = resource.getControl().controlForRef(ref);
    try (Repository repo = repoManager.openRepository(resource.getNameKey())) {
        ObjectId revid = RefUtil.parseBaseRevision(repo, resource.getNameKey(), input.revision);
        RevWalk rw = RefUtil.verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        rw.reset();
        boolean isAnnotated = Strings.emptyToNull(input.message) != null;
        boolean isSigned = isAnnotated && input.message.contains("-----BEGIN PGP SIGNATURE-----\n");
        if (isSigned) {
            throw new MethodNotAllowedException("Cannot create signed tag \"" + ref + "\"");
        } else if (isAnnotated && !refControl.canPerform(Permission.CREATE_TAG)) {
            throw new AuthException("Cannot create annotated tag \"" + ref + "\"");
        } else if (!refControl.canPerform(Permission.CREATE)) {
            throw new AuthException("Cannot create tag \"" + ref + "\"");
        }
        if (repo.getRefDatabase().exactRef(ref) != null) {
            throw new ResourceConflictException("tag \"" + ref + "\" already exists");
        }
        try (Git git = new Git(repo)) {
            TagCommand tag = git.tag().setObjectId(object).setName(ref.substring(R_TAGS.length())).setAnnotated(isAnnotated).setSigned(isSigned);
            if (isAnnotated) {
                tag.setMessage(input.message).setTagger(identifiedUser.get().newCommitterIdent(TimeUtil.nowTs(), TimeZone.getDefault()));
            }
            Ref result = tag.call();
            tagCache.updateFastForward(resource.getNameKey(), ref, ObjectId.zeroId(), result.getObjectId());
            referenceUpdated.fire(resource.getNameKey(), ref, ObjectId.zeroId(), result.getObjectId(), identifiedUser.get().getAccount());
            try (RevWalk w = new RevWalk(repo)) {
                ProjectControl pctl = resource.getControl();
                return ListTags.createTagInfo(result, w, refControl, pctl, links);
            }
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("Invalid base revision");
    } catch (GitAPIException e) {
        log.error("Cannot create tag \"" + ref + "\"", e);
        throw new IOException(e);
    }
}
#end_block

#method_before
private void grantApprove(Project.NameKey project, AccountGroup.UUID groupUUID, boolean exclusive) throws Exception {
    grantLabel(Permission.LABEL + "Code-Review", -2, 2, project, "refs/heads/*", false, groupUUID, exclusive);
}
#method_after
private void grantApprove(Project.NameKey project, AccountGroup.UUID groupUUID, boolean exclusive) throws Exception {
    grantLabel("Code-Review", -2, 2, project, "refs/heads/*", false, groupUUID, exclusive);
}
#end_block

#method_before
private void blockApproveForChangeOwner(Project.NameKey project) throws Exception {
    blockLabel(Permission.LABEL + "Code-Review", -2, 2, SystemGroupBackend.CHANGE_OWNER, "refs/heads/*", project);
}
#method_after
private void blockApproveForChangeOwner(Project.NameKey project) throws Exception {
    blockLabel("Code-Review", -2, 2, SystemGroupBackend.CHANGE_OWNER, "refs/heads/*", project);
}
#end_block

#method_before
protected void blockLabel(String permission, int min, int max, AccountGroup.UUID id, String ref, Project.NameKey project) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.block(cfg, permission, min, max, id, ref);
    saveProjectConfig(project, cfg);
}
#method_after
protected void blockLabel(String label, int min, int max, AccountGroup.UUID id, String ref, Project.NameKey project) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.block(cfg, Permission.LABEL + label, min, max, id, ref);
    saveProjectConfig(project, cfg);
}
#end_block

#method_before
protected void grantLabel(String permission, int min, int max, Project.NameKey project, String ref, boolean force, AccountGroup.UUID groupUUID, boolean exclusive) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(project)) {
        md.setMessage(String.format("Grant %s on %s", permission, ref));
        ProjectConfig config = ProjectConfig.read(md);
        AccessSection s = config.getAccessSection(ref, true);
        Permission p = s.getPermission(permission, true);
        p.setExclusiveGroup(exclusive);
        PermissionRule rule = Util.newRule(config, groupUUID);
        rule.setForce(force);
        rule.setMin(min);
        rule.setMax(max);
        p.add(rule);
        config.commit(md);
        projectCache.evict(config.getProject());
    }
}
#method_after
protected void grantLabel(String label, int min, int max, Project.NameKey project, String ref, boolean force, AccountGroup.UUID groupUUID, boolean exclusive) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    String permission = Permission.LABEL + label;
    try (MetaDataUpdate md = metaDataUpdateFactory.create(project)) {
        md.setMessage(String.format("Grant %s on %s", permission, ref));
        ProjectConfig config = ProjectConfig.read(md);
        AccessSection s = config.getAccessSection(ref, true);
        Permission p = s.getPermission(permission, true);
        p.setExclusiveGroup(exclusive);
        PermissionRule rule = Util.newRule(config, groupUUID);
        rule.setForce(force);
        rule.setMin(min);
        rule.setMax(max);
        p.add(rule);
        config.commit(md);
        projectCache.evict(config.getProject());
    }
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure {
    if (localDiskRepositoryManager == null) {
        throw new UnloggedFailure(1, "Command only works with disk based repository managers");
    }
    Project.NameKey nameKey = new Project.NameKey(projectName);
    if (projectCache.get(nameKey) != null) {
        stdout.print(localDiskRepositoryManager.getBasePath(nameKey) + "/" + nameKey.get() + ".git" + "\n");
    } else {
        throw new UnloggedFailure(1, "Repository not found");
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    if (localDiskRepositoryManager == null) {
        throw new UnloggedFailure(1, "Command only works with disk based repository managers");
    }
    Project.NameKey nameKey = new Project.NameKey(projectName);
    if (projectCache.get(nameKey) != null) {
        stdout.println(localDiskRepositoryManager.getBasePath(nameKey).resolve(nameKey.get().concat(Constants.DOT_GIT_EXT)));
    } else {
        throw new UnloggedFailure(1, "Repository not found");
    }
}
#end_block

#method_before
private void parseCreate(ReceiveCommand cmd) throws PermissionBackendException {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    boolean ok;
    try {
        permissions.ref(cmd.getRefName()).check(RefPermission.CREATE);
        ok = true;
    } catch (AuthException err) {
        ok = false;
    }
    if (!ok) {
        reject(cmd, "prohibited by Gerrit: 'create' permission missing on " + cmd.getRefName());
        return;
    }
    String rejectReason = ctl.canCreate(rp.getRepository(), obj);
    if (rejectReason != null) {
        reject(cmd, "prohibited by Gerrit: " + rejectReason);
        return;
    }
    if (!validRefOperation(cmd)) {
        return;
    }
    validateNewCommits(ctl, cmd);
    actualCommands.add(cmd);
}
#method_after
private void parseCreate(ReceiveCommand cmd) throws PermissionBackendException {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    String rejectReason = ctl.canCreate(rp.getRepository(), obj);
    if (rejectReason != null) {
        reject(cmd, "prohibited by Gerrit: " + rejectReason);
        return;
    }
    if (!validRefOperation(cmd)) {
        // validRefOperation sets messages, so no need to provide more feedback.
        return;
    }
    validateNewCommits(ctl, cmd);
    actualCommands.add(cmd);
}
#end_block

#method_before
public String canCreate(Repository repo, RevObject object) {
    if (!isProjectStatePermittingWrite()) {
        return "project state does not permit write";
    }
    if (object instanceof RevCommit) {
        if (!canPerform(Permission.CREATE)) {
            return "no create permission";
        }
        return canCreateCommit(repo, (RevCommit) object);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try (RevWalk rw = new RevWalk(repo)) {
            rw.parseBody(tag);
        } catch (IOException e) {
            return "I/O exception for revwalk";
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getUser().isIdentifiedUser()) {
                final String addr = tagger.getEmailAddress();
                valid = getUser().asIdentifiedUser().hasEmailAddress(addr);
            } else {
                valid = false;
            }
            if (!valid && !canForgeCommitter()) {
                return "no 'Forge Committer' permission";
            }
        }
        RevObject tagObject = tag.getObject();
        if (tagObject instanceof RevCommit) {
            String rejectReason = canCreateCommit(repo, (RevCommit) tagObject);
            if (rejectReason != null) {
                return rejectReason;
            }
        } else {
            String rejectReason = canCreate(repo, tagObject);
            if (rejectReason != null) {
                return rejectReason;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return canPerform(Permission.CREATE_SIGNED_TAG) ? null : "'create signed tag' permission missing";
        }
        return canPerform(Permission.CREATE_TAG) ? null : "'create tag' permission missing";
    }
    return null;
}
#method_after
@Nullable
public String canCreate(Repository repo, RevObject object) {
    if (!isProjectStatePermittingWrite()) {
        return "project state does not permit write";
    }
    if (object instanceof RevCommit) {
        if (!canPerform(Permission.CREATE)) {
            return "lacks permission: " + Permission.CREATE;
        }
        return canCreateCommit(repo, (RevCommit) object);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try (RevWalk rw = new RevWalk(repo)) {
            rw.parseBody(tag);
        } catch (IOException e) {
            String msg = String.format("RevWalk(%s) for pushing tag %s:", projectControl.getProject().getNameKey(), tag.name());
            log.error(msg, e);
            return "I/O exception for revwalk";
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getUser().isIdentifiedUser()) {
                final String addr = tagger.getEmailAddress();
                valid = getUser().asIdentifiedUser().hasEmailAddress(addr);
            } else {
                valid = false;
            }
            if (!valid && !canForgeCommitter()) {
                return "lacks permission: " + Permission.FORGE_COMMITTER;
            }
        }
        RevObject tagObject = tag.getObject();
        if (tagObject instanceof RevCommit) {
            String rejectReason = canCreateCommit(repo, (RevCommit) tagObject);
            if (rejectReason != null) {
                return rejectReason;
            }
        } else {
            String rejectReason = canCreate(repo, tagObject);
            if (rejectReason != null) {
                return rejectReason;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return canPerform(Permission.CREATE_SIGNED_TAG) ? null : "lacks permission: " + Permission.CREATE_SIGNED_TAG;
        }
        return canPerform(Permission.CREATE_TAG) ? null : "lacks permission " + Permission.CREATE_TAG;
    }
    return null;
}
#end_block

#method_before
@Nullable
private String canCreateCommit(Repository repo, RevCommit commit) {
    if (canUpdate()) {
        // of whether they are pushing any new objects along with the create.
        return null;
    } else if (isMergedIntoBranchOrTag(repo, commit)) {
        // even if they don't have push permission.
        return null;
    }
    return "creating new commit object requires 'push' permission";
}
#method_after
@Nullable
private String canCreateCommit(Repository repo, RevCommit commit) {
    if (canUpdate()) {
        // of whether they are pushing any new objects along with the create.
        return null;
    } else if (isMergedIntoBranchOrTag(repo, commit)) {
        // even if they don't have push permission.
        return null;
    }
    return "lacks permission " + Permission.PUSH + " for creating new commit object";
}
#end_block

#method_before
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    try {
        parseCommands(commands);
    } catch (PermissionBackendException err) {
        for (ReceiveCommand cmd : batch.getCommands()) {
            if (cmd.getResult() == NOT_ATTEMPTED) {
                cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
        logError(String.format("Failed to process refs in %s", project.getName()), err);
    }
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    logDebug("Executing batch with {} commands", batch.getCommands().size());
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                logDebug("Allowing non-fast-forward for edit ref");
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            logError(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        logDebug("Handling error conditions: {}", errors.keySet());
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                logDebug("Updating tag cache on fast-forward of {}", c.getRefName());
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                logDebug("Reloading project in cache");
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                try {
                    repo.setGitwebDescription(ps.getProject().getDescription());
                } catch (IOException e) {
                    log.warn("cannot update description of " + project.getName(), e);
                }
            }
            if (!MagicBranch.isMagicBranch(refName)) {
                logDebug("Firing ref update for {}", c.getRefName());
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
            } else {
                logDebug("Assuming ref update event for {} has fired", c.getRefName());
            }
        }
    }
    // Update superproject gitlinks if required.
    if (!branches.isEmpty()) {
        try (MergeOpRepoManager orm = ormProvider.get()) {
            orm.setContext(db, TimeUtil.nowTs(), user, receiveId);
            SubmoduleOp op = subOpFactory.create(branches, orm);
            op.updateSuperProjects();
        } catch (SubmoduleException e) {
            logError("Can't update the superprojects", e);
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    try {
        parseCommands(commands);
    } catch (PermissionBackendException err) {
        for (ReceiveCommand cmd : actualCommands) {
            if (cmd.getResult() == NOT_ATTEMPTED) {
                cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
        logError(String.format("Failed to process refs in %s", project.getName()), err);
    }
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        logDebug("Handling error conditions: {}", errors.keySet());
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : actualCommands) {
        // involve kicking off an additional BatchUpdate.
        if (c.getResult() != OK) {
            continue;
        }
        if (isHead(c) || isConfig(c)) {
            switch(c.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    autoCloseChanges(c);
                    branches.add(new Branch.NameKey(project.getNameKey(), c.getRefName()));
                    break;
                case DELETE:
                    break;
            }
        }
    }
    // Update superproject gitlinks if required.
    if (!branches.isEmpty()) {
        try (MergeOpRepoManager orm = ormProvider.get()) {
            orm.setContext(db, TimeUtil.nowTs(), user, receiveId);
            SubmoduleOp op = subOpFactory.create(branches, orm);
            op.updateSuperProjects(batchUpdateFactory);
        } catch (SubmoduleException e) {
            logError("Can't update the superprojects", e);
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            String refName = replace.inputCommand.getRefName();
            checkState(NEW_PATCHSET.matcher(refName).matches(), "expected a new patch set command as input when creating %s; got %s", replace.cmd.getRefName(), refName);
            try {
                logDebug("One-off insertion of patch set for {}", refName);
                replace.insertPatchSetWithoutBatchUpdate();
                replace.inputCommand.setResult(OK);
            } catch (IOException | UpdateException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                logError(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            logError(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    // No need to continue.
    if (magicBranch == null) {
        logDebug("No magic branch, nothing more to do");
        return;
    } else if (magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        logWarn(String.format("Skipping change updates on %s because ref update failed: %s %s", project.getName(), magicBranch.cmd.getResult(), Strings.nullToEmpty(magicBranch.cmd.getMessage())));
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            logError(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    logDebug("Counted {} ok to insert, out of {} to replace and {} new", okToInsert, replaceCount, newChanges.size());
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + lastCreateChangeErrors.stream().collect(joining(" ")));
        logError(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, magicBranch.dest.getParentKey(), user.materializedCopy(), TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                replace.addOps(bu, replaceProgress);
            }
        }
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.addOps(bu);
        }
        logDebug("Executing batch");
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        magicBranch.cmd.setResult(OK);
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage != null) {
                logDebug("Rejecting due to message from ReplaceOp");
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException | IOException err) {
        logError("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranch.cmd, "conflict");
        } catch (RestApiException | OrmException e) {
            logError("Error submitting changes to " + project.getName(), e);
            reject(magicBranch.cmd, "error during submit");
        }
    }
}
#method_after
private void insertChangesAndPatchSets() {
    ReceiveCommand magicBranchCmd = magicBranch != null ? magicBranch.cmd : null;
    if (magicBranchCmd != null && magicBranchCmd.getResult() != NOT_ATTEMPTED) {
        logWarn(String.format("Skipping change updates on %s because ref update failed: %s %s", project.getName(), magicBranchCmd.getResult(), Strings.nullToEmpty(magicBranchCmd.getMessage())));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, project.getNameKey(), user.materializedCopy(), TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        bu.setRefLogMessage("push");
        logDebug("Adding {} replace requests", newChanges.size());
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.addOps(bu, replaceProgress);
        }
        logDebug("Adding {} create requests", newChanges.size());
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        logDebug("Adding {} group update requests", newChanges.size());
        updateGroups.forEach(r -> r.addOps(bu));
        logDebug("Adding {} additional ref updates", actualCommands.size());
        actualCommands.forEach(c -> bu.addRepoOnlyOp(new UpdateOneRefOp(c)));
        logDebug("Executing batch");
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        if (magicBranchCmd != null) {
            magicBranchCmd.setResult(OK);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage == null) {
                if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
                    // Not necessarily the magic branch, so need to set OK on the original value.
                    replace.inputCommand.setResult(OK);
                }
            } else {
                logDebug("Rejecting due to message from ReplaceOp");
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranchCmd, "conflict");
    } catch (RestApiException | IOException err) {
        logError("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranchCmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranchCmd, "conflict");
        } catch (RestApiException | OrmException e) {
            logError("Error submitting changes to " + project.getName(), e);
            reject(magicBranchCmd, "error during submit");
        }
    }
}
#end_block

#method_before
private void parseCreate(ReceiveCommand cmd) throws PermissionBackendException {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    boolean ok;
    try {
        permissions.ref(cmd.getRefName()).check(RefPermission.CREATE);
        ok = true;
    } catch (AuthException err) {
        ok = false;
    }
    if (ok && ctl.canCreate(db, rp.getRepository(), obj)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd, "prohibited by Gerrit: create access denied for " + cmd.getRefName());
    }
}
#method_after
private void parseCreate(ReceiveCommand cmd) throws PermissionBackendException {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    boolean ok;
    try {
        permissions.ref(cmd.getRefName()).check(RefPermission.CREATE);
        ok = true;
    } catch (AuthException err) {
        ok = false;
    }
    if (ok && ctl.canCreate(db, rp.getRepository(), obj)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        actualCommands.add(cmd);
    } else {
        reject(cmd, "prohibited by Gerrit: create access denied for " + cmd.getRefName());
    }
}
#end_block

#method_before
private void parseUpdate(ReceiveCommand cmd) throws PermissionBackendException {
    logDebug("Updating {}", cmd);
    boolean ok;
    try {
        permissions.ref(cmd.getRefName()).check(RefPermission.UPDATE);
        ok = true;
    } catch (AuthException err) {
        ok = false;
    }
    if (ok) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(projectControl.controlForRef(cmd.getRefName()), cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(cmd.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, cmd.getRefName());
        }
        reject(cmd, "prohibited by Gerrit: ref update access denied");
    }
}
#method_after
private void parseUpdate(ReceiveCommand cmd) throws PermissionBackendException {
    logDebug("Updating {}", cmd);
    boolean ok;
    try {
        permissions.ref(cmd.getRefName()).check(RefPermission.UPDATE);
        ok = true;
    } catch (AuthException err) {
        ok = false;
    }
    if (ok) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(projectControl.controlForRef(cmd.getRefName()), cmd);
        actualCommands.add(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(cmd.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, cmd.getRefName());
        }
        reject(cmd, "prohibited by Gerrit: ref update access denied");
    }
}
#end_block

#method_before
private void parseDelete(ReceiveCommand cmd) throws PermissionBackendException {
    logDebug("Deleting {}", cmd);
    if (cmd.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, cmd.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (canDelete(cmd)) {
        if (validRefOperation(cmd)) {
            batch.addCommand(cmd);
        }
    } else if (RefNames.REFS_CONFIG.equals(cmd.getRefName())) {
        reject(cmd, "cannot delete project configuration");
    } else {
        errors.put(Error.DELETE, cmd.getRefName());
        reject(cmd, "cannot delete references");
    }
}
#method_after
private void parseDelete(ReceiveCommand cmd) throws PermissionBackendException {
    logDebug("Deleting {}", cmd);
    if (cmd.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, cmd.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (canDelete(cmd)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        actualCommands.add(cmd);
    } else if (RefNames.REFS_CONFIG.equals(cmd.getRefName())) {
        reject(cmd, "cannot delete project configuration");
    } else {
        errors.put(Error.DELETE, cmd.getRefName());
        reject(cmd, "cannot delete references");
    }
}
#end_block

#method_before
private void parseRewind(ReceiveCommand cmd) throws PermissionBackendException {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Rewinding {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    boolean ok;
    try {
        permissions.ref(cmd.getRefName()).check(RefPermission.FORCE_UPDATE);
        ok = true;
    } catch (AuthException err) {
        ok = false;
    }
    if (ok) {
        if (!validRefOperation(cmd)) {
            return;
        }
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(ReceiveCommand cmd) throws PermissionBackendException {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Rewinding {}", cmd);
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    boolean ok;
    try {
        permissions.ref(cmd.getRefName()).check(RefPermission.FORCE_UPDATE);
        ok = true;
    } catch (AuthException err) {
        ok = false;
    }
    if (ok) {
        if (!validRefOperation(cmd)) {
            return;
        }
        actualCommands.add(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (projectControl.getProject().getState() != com.google.gerrit.extensions.client.ProjectState.ACTIVE) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef(MagicBranch.NEW_DRAFT_CHANGE + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isPrivate && magicBranch.removePrivate) {
        reject(cmd, "the options 'private' and 'remove-private' are mutually exclusive");
        return;
    }
    if (magicBranch.workInProgress && magicBranch.ready) {
        reject(cmd, "the options 'wip' and 'ready' are mutually exclusive");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit(true)) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    String destBranch = magicBranch.dest.get();
    try {
        if (magicBranch.merged) {
            if (magicBranch.draft) {
                reject(cmd, "cannot be draft & merged");
                return;
            }
            if (magicBranch.base != null) {
                reject(cmd, "cannot use merged with base");
                return;
            }
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            if (!walk.isMergedInto(tip, branchTip)) {
                reject(cmd, "not merged into branch");
                return;
            }
        }
        // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
        if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
            logDebug("Forcing newChangeForAllNotInTarget = false");
            newChangeForAllNotInTarget = false;
        }
        if (magicBranch.base != null) {
            logDebug("Handling %base: {}", magicBranch.base);
            magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
            for (ObjectId id : magicBranch.base) {
                try {
                    magicBranch.baseCommit.add(walk.parseCommit(id));
                } catch (IncorrectObjectTypeException notCommit) {
                    reject(cmd, "base must be a commit");
                    return;
                } catch (MissingObjectException e) {
                    reject(cmd, "base not found");
                    return;
                } catch (IOException e) {
                    logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                    reject(cmd, "internal server error");
                    return;
                }
            }
        } else if (newChangeForAllNotInTarget) {
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            magicBranch.baseCommit = Collections.singletonList(branchTip);
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        }
    } catch (IOException ex) {
        logWarn(String.format("Error walking to %s in project %s", destBranch, project.getName()), ex);
        reject(cmd, "internal server error");
        return;
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(user, cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (projectControl.getProject().getState() != com.google.gerrit.extensions.client.ProjectState.ACTIVE) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef(MagicBranch.NEW_DRAFT_CHANGE + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isPrivate && magicBranch.removePrivate) {
        reject(cmd, "the options 'private' and 'remove-private' are mutually exclusive");
        return;
    }
    if (magicBranch.workInProgress && magicBranch.ready) {
        reject(cmd, "the options 'wip' and 'ready' are mutually exclusive");
        return;
    }
    if (magicBranch.publishComments && magicBranch.noPublishComments) {
        reject(cmd, "the options 'publish-comments' and 'no-publish-comments' are mutually exclusive");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit(true)) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    String destBranch = magicBranch.dest.get();
    try {
        if (magicBranch.merged) {
            if (magicBranch.draft) {
                reject(cmd, "cannot be draft & merged");
                return;
            }
            if (magicBranch.base != null) {
                reject(cmd, "cannot use merged with base");
                return;
            }
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            if (!walk.isMergedInto(tip, branchTip)) {
                reject(cmd, "not merged into branch");
                return;
            }
        }
        // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
        if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
            logDebug("Forcing newChangeForAllNotInTarget = false");
            newChangeForAllNotInTarget = false;
        }
        if (magicBranch.base != null) {
            logDebug("Handling %base: {}", magicBranch.base);
            magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
            for (ObjectId id : magicBranch.base) {
                try {
                    magicBranch.baseCommit.add(walk.parseCommit(id));
                } catch (IncorrectObjectTypeException notCommit) {
                    reject(cmd, "base must be a commit");
                    return;
                } catch (MissingObjectException e) {
                    reject(cmd, "base not found");
                    return;
                } catch (IOException e) {
                    logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                    reject(cmd, "internal server error");
                    return;
                }
            }
        } else if (newChangeForAllNotInTarget) {
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            magicBranch.baseCommit = Collections.singletonList(branchTip);
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        }
    } catch (IOException ex) {
        logWarn(String.format("Error walking to %s in project %s", destBranch, project.getName()), ex);
        reject(cmd, "internal server error");
        return;
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    ListMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return;
        }
        LinkedHashMap<RevCommit, ChangeLookup> pending = new LinkedHashMap<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            rp.getRevWalk().parseBody(c);
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            boolean commitAlreadyTracked = !existingRefs.isEmpty();
            if (commitAlreadyTracked) {
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            String idStr = !idList.isEmpty() ? idList.get(idList.size() - 1).trim() : null;
            if (idStr != null) {
                pending.put(c, new ChangeLookup(c, new Change.Key(idStr)));
            } else {
                pending.put(c, new ChangeLookup(c));
            }
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
            if (commitAlreadyTracked) {
                boolean changeExistsOnDestBranch = false;
                for (ChangeData cd : pending.get(c).destChanges) {
                    if (cd.change().getDest().equals(magicBranch.dest)) {
                        changeExistsOnDestBranch = true;
                        break;
                    }
                }
                if (changeExistsOnDestBranch) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.values().iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (p.changeKey == null) {
                continue;
            }
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in branch {} with Change-Id {}: {}", magicBranch.dest, p.changeKey, changes.stream().map(cd -> cd.getId().toString()).collect(joining()));
                // WTF, multiple changes in this branch have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique per branch.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                // double check against the existing refs
                if (foundInExistingRef(existing.get(p.commit))) {
                    if (pending.size() == 1) {
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                        newChanges = Collections.emptyList();
                        return;
                    }
                    itr.remove();
                    continue;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    ListMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return;
        }
        LinkedHashMap<RevCommit, ChangeLookup> pending = new LinkedHashMap<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            rp.getRevWalk().parseBody(c);
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            boolean commitAlreadyTracked = !existingRefs.isEmpty();
            if (commitAlreadyTracked) {
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            String idStr = !idList.isEmpty() ? idList.get(idList.size() - 1).trim() : null;
            if (idStr != null) {
                pending.put(c, new ChangeLookup(c, new Change.Key(idStr)));
            } else {
                pending.put(c, new ChangeLookup(c));
            }
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
            if (commitAlreadyTracked) {
                boolean changeExistsOnDestBranch = false;
                for (ChangeData cd : pending.get(c).destChanges) {
                    if (cd.change().getDest().equals(magicBranch.dest)) {
                        changeExistsOnDestBranch = true;
                        break;
                    }
                }
                if (changeExistsOnDestBranch) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.values().iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (p.changeKey == null) {
                continue;
            }
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in branch {} with Change-Id {}: {}", magicBranch.dest, p.changeKey, changes.stream().map(cd -> cd.getId().toString()).collect(joining()));
                // WTF, multiple changes in this branch have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique per branch.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                // double check against the existing refs
                if (foundInExistingRef(existing.get(p.commit))) {
                    if (pending.size() == 1) {
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                        newChanges = Collections.emptyList();
                        return;
                    }
                    itr.remove();
                    continue;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void addOps(BatchUpdate bu) throws RestApiException {
    checkState(changeId != null, "must call setChangeId before addOps");
    try {
        RevWalk rw = rp.getRevWalk();
        rw.parseBody(commit);
        final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
        Account.Id me = user.getAccountId();
        List<FooterLine> footerLines = commit.getFooterLines();
        MailRecipients recipients = new MailRecipients();
        Map<String, Short> approvals = new HashMap<>();
        checkNotNull(magicBranch);
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        recipients.add(getRecipientsFromFooters(db, accountResolver, magicBranch.draft, footerLines));
        recipients.remove(me);
        StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
        msg.append('.');
        if (!Strings.isNullOrEmpty(magicBranch.message)) {
            msg.append("\n").append(magicBranch.message);
        }
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setAccountsToNotify(magicBranch.getAccountsToNotify()).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(false).setPatchSetDescription(magicBranch.message));
        if (!magicBranch.hashtags.isEmpty()) {
            // Any change owner is allowed to add hashtags when creating a change.
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setFireEvent(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdateOp() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.addOp(changeId, new BatchUpdateOp() {

            @Override
            public boolean updateChange(ChangeContext ctx) {
                change = ctx.getChange();
                return false;
            }
        });
        bu.addOp(changeId, new ChangeProgressOp(newProgress));
    } catch (Exception e) {
        throw INSERT_EXCEPTION.apply(e);
    }
}
#method_after
private void addOps(BatchUpdate bu) throws RestApiException {
    checkState(changeId != null, "must call setChangeId before addOps");
    try {
        RevWalk rw = rp.getRevWalk();
        rw.parseBody(commit);
        final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
        Account.Id me = user.getAccountId();
        List<FooterLine> footerLines = commit.getFooterLines();
        MailRecipients recipients = new MailRecipients();
        Map<String, Short> approvals = new HashMap<>();
        checkNotNull(magicBranch);
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        recipients.add(getRecipientsFromFooters(db, accountResolver, magicBranch.draft, footerLines));
        recipients.remove(me);
        StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
        msg.append('.');
        if (!Strings.isNullOrEmpty(magicBranch.message)) {
            msg.append("\n").append(magicBranch.message);
        }
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setAccountsToNotify(magicBranch.getAccountsToNotify()).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setPatchSetDescription(magicBranch.message));
        if (!magicBranch.hashtags.isEmpty()) {
            // Any change owner is allowed to add hashtags when creating a change.
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setFireEvent(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdateOp() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.addOp(changeId, new BatchUpdateOp() {

            @Override
            public boolean updateChange(ChangeContext ctx) {
                change = ctx.getChange();
                return false;
            }
        });
        bu.addOp(changeId, new ChangeProgressOp(newProgress));
    } catch (Exception e) {
        throw INSERT_EXCEPTION.apply(e);
    }
}
#end_block

#method_before
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commit, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.notes.getChange());
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkNotNull(tipChange, "tip of push does not correspond to a change; found these changes: %s", bySha);
    logDebug("Processing submit with tip change {} ({})", tipChange.getId(), magicBranch.cmd.getNewId());
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput(), false);
    }
}
#method_after
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commit, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.notes.getChange());
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkNotNull(tipChange, "tip of push does not correspond to a change; found these changes: %s", bySha);
    logDebug("Processing submit with tip change {} ({})", tipChange.getId(), magicBranch.cmd.getNewId());
    try (MergeOp op = mergeOpFactory.create(batchUpdateFactory)) {
        op.merge(db, tipChange, user, false, new SubmitInput(), false);
    }
}
#end_block

#method_before
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                }
            }
        }
    } catch (OrmException err) {
        logError(String.format("Cannot read database before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException | PermissionBackendException err) {
        logError(String.format("Cannot read repository before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    logDebug("Read {} changes to replace", replaceByChange.size());
    for (ReplaceRequest req : replaceByChange.values()) {
        if (req.inputCommand.getResult() == NOT_ATTEMPTED && req.cmd != null) {
            if (req.prev != null) {
                batch.addCommand(req.prev);
            }
            batch.addCommand(req.cmd);
        }
    }
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#method_after
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                }
            }
        }
    } catch (OrmException err) {
        logError(String.format("Cannot read database before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException | PermissionBackendException err) {
        logError(String.format("Cannot read repository before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    logDebug("Read {} changes to replace", replaceByChange.size());
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#end_block

#method_before
void addOps(BatchUpdate bu, @Nullable Task progress) throws IOException {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        // TODO(dborowitz): When does this happen? Only when an edit ref is
        // involved?
        cmd.execute(rp);
    }
    if (magicBranch != null && magicBranch.edit) {
        bu.addOp(notes.getChangeId(), new BatchUpdateOp() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws Exception {
                // return pseudo dirty state to trigger reindexing
                return true;
            }
        });
        return;
    }
    RevWalk rw = rp.getRevWalk();
    // TODO(dborowitz): Move to ReplaceOp#updateRepo.
    RevCommit newCommit = rw.parseCommit(newCommitId);
    rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    replaceOp = replaceOpFactory.create(projectControl, notes.getChange().getDest(), checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate()).setRequestScopePropagator(requestScopePropagator).setUpdateRef(false);
    bu.addOp(notes.getChangeId(), replaceOp);
    if (progress != null) {
        bu.addOp(notes.getChangeId(), new ChangeProgressOp(progress));
    }
}
#method_after
void addOps(BatchUpdate bu, @Nullable Task progress) throws IOException {
    if (magicBranch != null && magicBranch.edit) {
        bu.addOp(notes.getChangeId(), new ReindexOnlyOp());
        if (prev != null) {
            bu.addRepoOnlyOp(new UpdateOneRefOp(prev));
        }
        bu.addRepoOnlyOp(new UpdateOneRefOp(cmd));
        return;
    }
    RevWalk rw = rp.getRevWalk();
    // TODO(dborowitz): Move to ReplaceOp#updateRepo.
    RevCommit newCommit = rw.parseCommit(newCommitId);
    rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    replaceOp = replaceOpFactory.create(projectControl, notes.getChange().getDest(), checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate()).setRequestScopePropagator(requestScopePropagator);
    bu.addOp(notes.getChangeId(), replaceOp);
    if (progress != null) {
        bu.addOp(notes.getChangeId(), new ChangeProgressOp(progress));
    }
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) throws PermissionBackendException {
    if (!RefNames.REFS_CONFIG.equals(cmd.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches()) && pushOptions.containsKey(BYPASS_REVIEW)) {
        try {
            permissions.ref(cmd.getRefName()).check(RefPermission.BYPASS_REVIEW);
            if (!Iterables.isEmpty(rejectCommits)) {
                throw new AuthException("reject-commits prevents " + BYPASS_REVIEW);
            }
            logDebug("Short-circuiting new commit validation");
        } catch (AuthException denied) {
            reject(cmd, denied.getMessage());
        }
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        ListMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        int i = 0;
        for (RevCommit c; (c = walk.next()) != null; ) {
            i++;
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    logWarn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
        logDebug("Validated {} new commits", i);
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) throws PermissionBackendException {
    if (!RefNames.REFS_CONFIG.equals(cmd.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches()) && pushOptions.containsKey(BYPASS_REVIEW)) {
        try {
            permissions.ref(cmd.getRefName()).check(RefPermission.BYPASS_REVIEW);
            if (!Iterables.isEmpty(rejectCommits)) {
                throw new AuthException("reject-commits prevents " + BYPASS_REVIEW);
            }
            logDebug("Short-circuiting new commit validation");
        } catch (AuthException denied) {
            reject(cmd, denied.getMessage());
        }
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        ListMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        int i = 0;
        for (RevCommit c; (c = walk.next()) != null; ) {
            i++;
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = accounts.get(db, user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        accountsUpdate.create().update(db, a);
                        user.getAccount().setFullName(a.getFullName());
                    }
                } catch (OrmException e) {
                    logWarn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
        logDebug("Validated {} new commits", i);
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private void reject(ReceiveCommand cmd, String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#method_after
private void reject(@Nullable ReceiveCommand cmd, String why) {
    if (cmd != null) {
        cmd.setResult(REJECTED_OTHER_REASON, why);
        commandProgress.update(1);
    }
}
#end_block

#method_before
@Before
public void setup() throws Exception {
    // clone with user to avoid inherited tag permissions of admin user
    testRepo = cloneProject(project, user);
    initialHead = getRemoteHead();
}
#method_after
@Before
public void setup() throws Exception {
    // clone with user to avoid inherited tag permissions of admin user
    testRepo = cloneProject(project, user);
    initialHead = getRemoteHead();
    tagType = getTagType();
}
#end_block

#method_before
@Test
public void createTagForExistingCommit() throws Exception {
    TagType tagType = getTagType();
    pushTagForExistingCommit(tagType, Status.REJECTED_OTHER_REASON);
    allowTagCreation(tagType);
    pushTagForExistingCommit(tagType, Status.OK);
    allowPushOnRefsTags();
    pushTagForExistingCommit(tagType, Status.OK);
    removePushFromRefsTags();
}
#method_after
@Test
public void createTagForExistingCommit() throws Exception {
    pushTagForExistingCommit(Status.REJECTED_OTHER_REASON);
    allowTagCreation();
    pushTagForExistingCommit(Status.OK);
    allowPushOnRefsTags();
    pushTagForExistingCommit(Status.OK);
    removePushFromRefsTags();
}
#end_block

#method_before
@Test
public void createTagForNewCommit() throws Exception {
    TagType tagType = getTagType();
    pushTagForNewCommit(tagType, Status.REJECTED_OTHER_REASON);
    allowTagCreation(tagType);
    pushTagForNewCommit(tagType, Status.REJECTED_OTHER_REASON);
    allowPushOnRefsTags();
    pushTagForNewCommit(tagType, Status.OK);
    removePushFromRefsTags();
}
#method_after
@Test
public void createTagForNewCommit() throws Exception {
    pushTagForNewCommit(Status.REJECTED_OTHER_REASON);
    allowTagCreation();
    pushTagForNewCommit(Status.REJECTED_OTHER_REASON);
    allowPushOnRefsTags();
    pushTagForNewCommit(Status.OK);
    removePushFromRefsTags();
}
#end_block

#method_before
@Test
public void fastForward() throws Exception {
    TagType tagType = getTagType();
    allowTagCreation(tagType);
    String tagName = pushTagForExistingCommit(tagType, Status.OK);
    fastForwardTagToExistingCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
    fastForwardTagToNewCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
    allowTagDeletion();
    fastForwardTagToExistingCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
    fastForwardTagToNewCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
    allowPushOnRefsTags();
    Status expectedStatus = tagType == ANNOTATED ? Status.REJECTED_OTHER_REASON : Status.OK;
    fastForwardTagToExistingCommit(tagType, tagName, expectedStatus);
    fastForwardTagToNewCommit(tagType, tagName, expectedStatus);
    allowForcePushOnRefsTags();
    fastForwardTagToExistingCommit(tagType, tagName, Status.OK);
    fastForwardTagToNewCommit(tagType, tagName, Status.OK);
    removePushFromRefsTags();
}
#method_after
@Test
public void fastForward() throws Exception {
    allowTagCreation();
    String tagName = pushTagForExistingCommit(Status.OK);
    fastForwardTagToExistingCommit(tagName, Status.REJECTED_OTHER_REASON);
    fastForwardTagToNewCommit(tagName, Status.REJECTED_OTHER_REASON);
    allowTagDeletion();
    fastForwardTagToExistingCommit(tagName, Status.REJECTED_OTHER_REASON);
    fastForwardTagToNewCommit(tagName, Status.REJECTED_OTHER_REASON);
    allowPushOnRefsTags();
    Status expectedStatus = tagType == ANNOTATED ? Status.REJECTED_OTHER_REASON : Status.OK;
    fastForwardTagToExistingCommit(tagName, expectedStatus);
    fastForwardTagToNewCommit(tagName, expectedStatus);
    allowForcePushOnRefsTags();
    fastForwardTagToExistingCommit(tagName, Status.OK);
    fastForwardTagToNewCommit(tagName, Status.OK);
    removePushFromRefsTags();
}
#end_block

#method_before
@Test
public void forceUpdate() throws Exception {
    TagType tagType = getTagType();
    allowTagCreation(tagType);
    String tagName = pushTagForExistingCommit(tagType, Status.OK);
    forceUpdateTagToExistingCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
    forceUpdateTagToNewCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
    allowPushOnRefsTags();
    forceUpdateTagToExistingCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
    forceUpdateTagToNewCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
    allowTagDeletion();
    forceUpdateTagToExistingCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
    forceUpdateTagToNewCommit(tagType, tagName, Status.REJECTED_OTHER_REASON);
    allowForcePushOnRefsTags();
    forceUpdateTagToExistingCommit(tagType, tagName, Status.OK);
    forceUpdateTagToNewCommit(tagType, tagName, Status.OK);
    removePushFromRefsTags();
}
#method_after
@Test
public void forceUpdate() throws Exception {
    allowTagCreation();
    String tagName = pushTagForExistingCommit(Status.OK);
    forceUpdateTagToExistingCommit(tagName, Status.REJECTED_OTHER_REASON);
    forceUpdateTagToNewCommit(tagName, Status.REJECTED_OTHER_REASON);
    allowPushOnRefsTags();
    forceUpdateTagToExistingCommit(tagName, Status.REJECTED_OTHER_REASON);
    forceUpdateTagToNewCommit(tagName, Status.REJECTED_OTHER_REASON);
    allowTagDeletion();
    forceUpdateTagToExistingCommit(tagName, Status.REJECTED_OTHER_REASON);
    forceUpdateTagToNewCommit(tagName, Status.REJECTED_OTHER_REASON);
    allowForcePushOnRefsTags();
    forceUpdateTagToExistingCommit(tagName, Status.OK);
    forceUpdateTagToNewCommit(tagName, Status.OK);
    removePushFromRefsTags();
}
#end_block

#method_before
@Test
public void delete() throws Exception {
    TagType tagType = getTagType();
    allowTagCreation(tagType);
    String tagName = pushTagForExistingCommit(tagType, Status.OK);
    pushTagDeletion(tagType, tagName, Status.REJECTED_OTHER_REASON);
    allowPushOnRefsTags();
    pushTagDeletion(tagType, tagName, Status.REJECTED_OTHER_REASON);
    allowForcePushOnRefsTags();
    tagName = pushTagForExistingCommit(tagType, Status.OK);
    pushTagDeletion(tagType, tagName, Status.OK);
    removePushFromRefsTags();
    allowTagDeletion();
    tagName = pushTagForExistingCommit(tagType, Status.OK);
    pushTagDeletion(tagType, tagName, Status.OK);
}
#method_after
@Test
public void delete() throws Exception {
    allowTagCreation();
    String tagName = pushTagForExistingCommit(Status.OK);
    pushTagDeletion(tagName, Status.REJECTED_OTHER_REASON);
    allowPushOnRefsTags();
    pushTagDeletion(tagName, Status.REJECTED_OTHER_REASON);
    allowForcePushOnRefsTags();
    tagName = pushTagForExistingCommit(Status.OK);
    pushTagDeletion(tagName, Status.OK);
    removePushFromRefsTags();
    allowTagDeletion();
    tagName = pushTagForExistingCommit(Status.OK);
    pushTagDeletion(tagName, Status.OK);
}
#end_block

#method_before
private String pushTagForExistingCommit(TagType tagType, Status expectedStatus) throws Exception {
    return pushTag(tagType, null, false, false, expectedStatus);
}
#method_after
private String pushTagForExistingCommit(Status expectedStatus) throws Exception {
    return pushTag(null, false, false, expectedStatus);
}
#end_block

#method_before
private String pushTagForNewCommit(TagType tagType, Status expectedStatus) throws Exception {
    return pushTag(tagType, null, true, false, expectedStatus);
}
#method_after
private String pushTagForNewCommit(Status expectedStatus) throws Exception {
    return pushTag(null, true, false, expectedStatus);
}
#end_block

#method_before
private void fastForwardTagToExistingCommit(TagType tagType, String tagName, Status expectedStatus) throws Exception {
    pushTag(tagType, tagName, false, false, expectedStatus);
}
#method_after
private void fastForwardTagToExistingCommit(String tagName, Status expectedStatus) throws Exception {
    pushTag(tagName, false, false, expectedStatus);
}
#end_block

#method_before
private void fastForwardTagToNewCommit(TagType tagType, String tagName, Status expectedStatus) throws Exception {
    pushTag(tagType, tagName, true, false, expectedStatus);
}
#method_after
private void fastForwardTagToNewCommit(String tagName, Status expectedStatus) throws Exception {
    pushTag(tagName, true, false, expectedStatus);
}
#end_block

#method_before
private void forceUpdateTagToExistingCommit(TagType tagType, String tagName, Status expectedStatus) throws Exception {
    pushTag(tagType, tagName, false, true, expectedStatus);
}
#method_after
private void forceUpdateTagToExistingCommit(String tagName, Status expectedStatus) throws Exception {
    pushTag(tagName, false, true, expectedStatus);
}
#end_block

#method_before
private void forceUpdateTagToNewCommit(TagType tagType, String tagName, Status expectedStatus) throws Exception {
    pushTag(tagType, tagName, true, true, expectedStatus);
}
#method_after
private void forceUpdateTagToNewCommit(String tagName, Status expectedStatus) throws Exception {
    pushTag(tagName, true, true, expectedStatus);
}
#end_block

#method_before
private String pushTag(TagType tagType, String tagName, boolean newCommit, boolean force, Status expectedStatus) throws Exception {
    if (force) {
        testRepo.reset(initialHead);
    }
    commit(user.getIdent(), "subject");
    boolean createTag = tagName == null;
    tagName = MoreObjects.firstNonNull(tagName, "v1_" + System.nanoTime());
    switch(tagType) {
        case LIGHTWEIGHT:
            break;
        case ANNOTATED:
            if (createTag) {
                createAnnotatedTag(testRepo, tagName, user.getIdent());
            } else {
                updateAnnotatedTag(testRepo, tagName, user.getIdent());
            }
            break;
        default:
            throw new IllegalStateException("unexpected tag type: " + tagType);
    }
    if (!newCommit) {
        grant(project, "refs/for/refs/heads/master", Permission.SUBMIT, false, REGISTERED_USERS);
        pushHead(testRepo, "refs/for/master%submit");
    }
    String tagRef = tagRef(tagName);
    PushResult r = tagType == LIGHTWEIGHT ? pushHead(testRepo, tagRef, false, force) : GitUtil.pushTag(testRepo, tagName, !createTag);
    RemoteRefUpdate refUpdate = r.getRemoteUpdate(tagRef);
    assertThat(refUpdate.getStatus()).named(tagType.name()).isEqualTo(expectedStatus);
    return tagName;
}
#method_after
private String pushTag(String tagName, boolean newCommit, boolean force, Status expectedStatus) throws Exception {
    if (force) {
        testRepo.reset(initialHead);
    }
    commit(user.getIdent(), "subject");
    boolean createTag = tagName == null;
    tagName = MoreObjects.firstNonNull(tagName, "v1_" + System.nanoTime());
    switch(tagType) {
        case LIGHTWEIGHT:
            break;
        case ANNOTATED:
            if (createTag) {
                createAnnotatedTag(testRepo, tagName, user.getIdent());
            } else {
                updateAnnotatedTag(testRepo, tagName, user.getIdent());
            }
            break;
        default:
            throw new IllegalStateException("unexpected tag type: " + tagType);
    }
    if (!newCommit) {
        grant(project, "refs/for/refs/heads/master", Permission.SUBMIT, false, REGISTERED_USERS);
        pushHead(testRepo, "refs/for/master%submit");
    }
    String tagRef = tagRef(tagName);
    PushResult r = tagType == LIGHTWEIGHT ? pushHead(testRepo, tagRef, false, force) : GitUtil.pushTag(testRepo, tagName, !createTag);
    RemoteRefUpdate refUpdate = r.getRemoteUpdate(tagRef);
    assertThat(refUpdate.getStatus()).named(tagType.name()).isEqualTo(expectedStatus);
    return tagName;
}
#end_block

#method_before
private void pushTagDeletion(TagType tagType, String tagName, Status expectedStatus) throws Exception {
    String tagRef = tagRef(tagName);
    PushResult r = deleteRef(testRepo, tagRef);
    RemoteRefUpdate refUpdate = r.getRemoteUpdate(tagRef);
    assertThat(refUpdate.getStatus()).named(tagType.name()).isEqualTo(expectedStatus);
}
#method_after
private void pushTagDeletion(String tagName, Status expectedStatus) throws Exception {
    String tagRef = tagRef(tagName);
    PushResult r = deleteRef(testRepo, tagRef);
    RemoteRefUpdate refUpdate = r.getRemoteUpdate(tagRef);
    assertThat(refUpdate.getStatus()).named(tagType.name()).isEqualTo(expectedStatus);
}
#end_block

#method_before
private void allowTagCreation(TagType tagType) throws Exception {
    grant(project, "refs/tags/*", tagType.createPermission, false, REGISTERED_USERS);
}
#method_after
private void allowTagCreation() throws Exception {
    grant(project, "refs/tags/*", tagType.createPermission, false, REGISTERED_USERS);
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    final HttpServletRequest req = (HttpServletRequest) request;
    final HttpServletResponse rsp = (HttpServletResponse) response;
    final Continuation cont = ContinuationSupport.getContinuation(req);
    ScheduledThreadPoolExecutor executor = getExecutor();
    if (cont.isInitial()) {
        TaskThunk task = new TaskThunk(executor, cont, req);
        if (maxWait > 0) {
            cont.setTimeout(maxWait);
        }
        cont.suspend(rsp);
        cont.addContinuationListener(task);
        cont.setAttribute(TASK, task);
        executor.submit(task);
    } else if (cont.isExpired()) {
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    } else if (cont.isResumed() && cont.getAttribute(CANCEL) == Boolean.TRUE) {
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    } else if (cont.isResumed()) {
        TaskThunk task = (TaskThunk) cont.getAttribute(TASK);
        try {
            task.begin(Thread.currentThread());
            chain.doFilter(req, rsp);
        } finally {
            task.end();
            Thread.interrupted();
        }
    } else {
        context.log("Unexpected QoS continuation state, aborting request");
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    }
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    final HttpServletRequest req = (HttpServletRequest) request;
    final HttpServletResponse rsp = (HttpServletResponse) response;
    final Continuation cont = ContinuationSupport.getContinuation(req);
    if (cont.isInitial()) {
        TaskThunk task = new TaskThunk(cont, req);
        if (maxWait > 0) {
            cont.setTimeout(maxWait);
        }
        cont.suspend(rsp);
        cont.setAttribute(TASK, task);
        Future f = getExecutor().submit(task);
        cont.addContinuationListener(new Listener(f));
    } else if (cont.isExpired()) {
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    } else if (cont.isResumed() && cont.getAttribute(CANCEL) == Boolean.TRUE) {
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    } else if (cont.isResumed()) {
        TaskThunk task = (TaskThunk) cont.getAttribute(TASK);
        try {
            task.begin(Thread.currentThread());
            chain.doFilter(req, rsp);
        } finally {
            task.end();
            Thread.interrupted();
        }
    } else {
        context.log("Unexpected QoS continuation state, aborting request");
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    }
}
#end_block

#method_before
private ScheduledThreadPoolExecutor getExecutor() {
    return queue.getQueue(user.get().getCapabilities().getQueueType());
}
#method_after
private ScheduledThreadPoolExecutor getExecutor() {
    QueueProvider.QueueType qt = capabilityFactory.create(user.get()).getQueueType();
    return queue.getQueue(qt);
}
#end_block

#method_before
@Test
public void preconditionsFail() throws Exception {
    List<Change.Id> cs = ImmutableList.of(new Change.Id(1));
    List<Project.NameKey> ps = ImmutableList.of(new Project.NameKey("p"));
    assertMigrationException("Cannot rebuild without noteDb.changes.write=true", b -> b, NoteDbMigrator::rebuild);
    assertMigrationException("Cannot set both changes and projects", b -> b.setChanges(cs).setProjects(ps), m -> {
    });
    assertMigrationException("Cannot set changes or projects during auto-migration", b -> b.setChanges(cs), NoteDbMigrator::migrate);
    assertMigrationException("Cannot set changes or projects during auto-migration", b -> b.setProjects(ps), NoteDbMigrator::migrate);
    assertMigrationException("Sequence gap must be non-negative", b -> b.setSequenceGap(-1), m -> {
    });
    setNotesMigrationState(READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY);
    assertMigrationException("Migration has already progressed past the endpoint of the \"trial mode\" state", b -> b.setTrialMode(true), NoteDbMigrator::migrate);
    setNotesMigrationState(READ_WRITE_WITH_SEQUENCE_NOTE_DB_PRIMARY);
    assertMigrationException("Cannot force rebuild changes; NoteDb is already the primary storage for some changes", b -> b.setForceRebuild(true), NoteDbMigrator::migrate);
}
#method_after
@Test
public void preconditionsFail() throws Exception {
    List<Change.Id> cs = ImmutableList.of(new Change.Id(1));
    List<Project.NameKey> ps = ImmutableList.of(new Project.NameKey("p"));
    assertMigrationException("Cannot rebuild without noteDb.changes.write=true", b -> b, NoteDbMigrator::rebuild);
    assertMigrationException("Cannot set both changes and projects", b -> b.setChanges(cs).setProjects(ps), m -> {
    });
    assertMigrationException("Cannot set changes or projects during auto-migration", b -> b.setChanges(cs), NoteDbMigrator::migrate);
    assertMigrationException("Cannot set changes or projects during auto-migration", b -> b.setProjects(ps), NoteDbMigrator::migrate);
    setNotesMigrationState(READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY);
    assertMigrationException("Migration has already progressed past the endpoint of the \"trial mode\" state", b -> b.setTrialMode(true), NoteDbMigrator::migrate);
    setNotesMigrationState(READ_WRITE_WITH_SEQUENCE_NOTE_DB_PRIMARY);
    assertMigrationException("Cannot force rebuild changes; NoteDb is already the primary storage for some changes", b -> b.setForceRebuild(true), NoteDbMigrator::migrate);
}
#end_block

#method_before
@Test
public void enableSequencesNoGap() throws Exception {
    testEnableSequences(0, 3, "13");
}
#method_after
@Test
public void enableSequencesNoGap() throws Exception {
    testEnableSequences(0, 2, "12");
}
#end_block

#method_before
@Test
public void enableSequencesWithGap() throws Exception {
    testEnableSequences(null, 503, "513");
}
#method_after
@Test
public void enableSequencesWithGap() throws Exception {
    testEnableSequences(-1, 502, "512");
}
#end_block

#method_before
private void testEnableSequences(Integer builderOption, int expectedFirstId, String expectedRefValue) throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getChange().getId();
    assertThat(id.get()).isEqualTo(1);
    migrate(b -> b.setSequenceGap(builderOption).setStopAtStateForTesting(READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY));
    // Implementation always discards 1 ID in addition to the gap.
    assertThat(sequences.nextChangeId()).isEqualTo(expectedFirstId);
    assertThat(sequences.nextChangeId()).isEqualTo(expectedFirstId + 1);
    try (Repository repo = repoManager.openRepository(allProjects);
        ObjectReader reader = repo.newObjectReader()) {
        Ref ref = repo.exactRef("refs/sequences/changes");
        assertThat(ref).isNotNull();
        ObjectLoader loader = reader.open(ref.getObjectId());
        assertThat(loader.getType()).isEqualTo(Constants.OBJ_BLOB);
        // Acquired a block of 10 to serve the first nextChangeId call after migration.
        assertThat(new String(loader.getCachedBytes(), UTF_8)).isEqualTo(expectedRefValue);
    }
    try (ReviewDb db = schemaFactory.open()) {
        // Underlying, unused ReviewDb is still on its own sequence.
        @SuppressWarnings("deprecation")
        int nextFromReviewDb = db.nextChangeId();
        assertThat(nextFromReviewDb).isEqualTo(3);
    }
}
#method_after
private void testEnableSequences(int builderOption, int expectedFirstId, String expectedRefValue) throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getChange().getId();
    assertThat(id.get()).isEqualTo(1);
    migrate(b -> b.setSequenceGap(builderOption).setStopAtStateForTesting(READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY));
    assertThat(sequences.nextChangeId()).isEqualTo(expectedFirstId);
    assertThat(sequences.nextChangeId()).isEqualTo(expectedFirstId + 1);
    try (Repository repo = repoManager.openRepository(allProjects);
        ObjectReader reader = repo.newObjectReader()) {
        Ref ref = repo.exactRef("refs/sequences/changes");
        assertThat(ref).isNotNull();
        ObjectLoader loader = reader.open(ref.getObjectId());
        assertThat(loader.getType()).isEqualTo(Constants.OBJ_BLOB);
        // Acquired a block of 10 to serve the first nextChangeId call after migration.
        assertThat(new String(loader.getCachedBytes(), UTF_8)).isEqualTo(expectedRefValue);
    }
    try (ReviewDb db = schemaFactory.open()) {
        // Underlying, unused ReviewDb is still on its own sequence.
        @SuppressWarnings("deprecation")
        int nextFromReviewDb = db.nextChangeId();
        assertThat(nextFromReviewDb).isEqualTo(3);
    }
}
#end_block

#method_before
public Builder setSequenceGap(Integer sequenceGap) {
    this.sequenceGap = sequenceGap;
    return this;
}
#method_after
public Builder setSequenceGap(int sequenceGap) {
    this.sequenceGap = sequenceGap;
    return this;
}
#end_block

#method_before
public NoteDbMigrator build() throws MigrationException {
    return new NoteDbMigrator(sitePaths, schemaFactory, repoManager, allProjects, rebuilder, globalNotesMigration, threads > 1 ? MoreExecutors.listeningDecorator(workQueue.createQueue(threads, "RebuildChange")) : MoreExecutors.newDirectExecutorService(), projects, changes, progressOut, stopAtState, trial, forceRebuild, sequenceGap != null ? sequenceGap : Sequences.getChangeSequenceGap(cfg));
}
#method_after
public NoteDbMigrator build() throws MigrationException {
    return new NoteDbMigrator(sitePaths, schemaFactory, repoManager, allProjects, rebuilder, globalNotesMigration, threads > 1 ? MoreExecutors.listeningDecorator(workQueue.createQueue(threads, "RebuildChange")) : MoreExecutors.newDirectExecutorService(), projects, changes, progressOut, stopAtState, trial, forceRebuild, sequenceGap >= 0 ? sequenceGap : Sequences.getChangeSequenceGap(cfg));
}
#end_block

#method_before
private NotesMigrationState enableSequences(NotesMigrationState prev) throws OrmException, IOException {
    try (ReviewDb db = schemaFactory.open()) {
        @SuppressWarnings("deprecation")
        RepoSequence seq = new RepoSequence(repoManager, allProjects, Sequences.CHANGES, () -> db.nextChangeId() + sequenceGap, 1);
        // Throw away one ID to ensure the ref is populated.
        seq.next();
    }
    return saveState(prev, READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY);
}
#method_after
private NotesMigrationState enableSequences(NotesMigrationState prev) throws OrmException, IOException {
    try (ReviewDb db = schemaFactory.open()) {
        @SuppressWarnings("deprecation")
        RepoSequence seq = new RepoSequence(repoManager, allProjects, Sequences.CHANGES, // would be a problem, but we just discard it, so this is safe.
        () -> db.nextChangeId() + sequenceGap - 1, 1);
        seq.next();
    }
    return saveState(prev, READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY);
}
#end_block

#method_before
public CodeReviewCommit writeMergeCommit(PersonIdent author, PersonIdent committer, CodeReviewRevWalk rw, ObjectInserter inserter, Branch.NameKey destBranch, CodeReviewCommit mergeTip, ObjectId treeId, CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<>();
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    CodeReviewCommit crc;
    while ((crc = rw.next()) != null) {
        if (crc.getPatchsetId() != null) {
            merged.add(crc);
        }
    }
    StringBuilder msgbuf = new StringBuilder().append(summarize(rw, merged));
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(treeId);
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(author);
    mergeCommit.setCommitter(committer);
    mergeCommit.setMessage(msgbuf.toString());
    matchAuthorToCommitterDate(project, mergeCommit);
    CodeReviewCommit mergeResult = rw.parseCommit(inserter.insert(mergeCommit));
    mergeResult.setControl(n.getControl());
    return mergeResult;
}
#method_after
public CodeReviewCommit writeMergeCommit(PersonIdent author, PersonIdent committer, CodeReviewRevWalk rw, ObjectInserter inserter, Branch.NameKey destBranch, CodeReviewCommit mergeTip, ObjectId treeId, CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<>();
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    CodeReviewCommit crc;
    while ((crc = rw.next()) != null) {
        if (crc.getPatchsetId() != null) {
            merged.add(crc);
        }
    }
    StringBuilder msgbuf = new StringBuilder().append(summarize(rw, merged));
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(treeId);
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(author);
    mergeCommit.setCommitter(committer);
    mergeCommit.setMessage(msgbuf.toString());
    CodeReviewCommit mergeResult = rw.parseCommit(inserter.insert(mergeCommit));
    mergeResult.setControl(n.getControl());
    return mergeResult;
}
#end_block

#method_before
private NotifyHandling defaultNotify(Change c, ReviewInput in) {
    if (in.tag != null && in.tag.startsWith("autogenerated:")) {
        // Autogenerated comments default to lower notify levels.
        return c.isWorkInProgress() ? NotifyHandling.OWNER : NotifyHandling.OWNER_REVIEWERS;
    }
    if (c.isWorkInProgress() && !c.hasReviewStarted()) {
        // the author is.
        return NotifyHandling.OWNER;
    }
    return NotifyHandling.ALL;
}
#method_after
private NotifyHandling defaultNotify(Change c, ReviewInput in) {
    if (ChangeMessagesUtil.isAutogenerated(in.tag)) {
        // Autogenerated comments default to lower notify levels.
        return c.isWorkInProgress() ? NotifyHandling.OWNER : NotifyHandling.OWNER_REVIEWERS;
    }
    if (c.isWorkInProgress() && !c.hasReviewStarted()) {
        // the author is.
        return NotifyHandling.OWNER;
    }
    return NotifyHandling.ALL;
}
#end_block

#method_before
public PersonIdent newRefLogIdent(final Date when, final TimeZone tz) {
    final Account ua = getAccount();
    String name = ua.getFullName();
    if (name == null || name.isEmpty()) {
        name = ua.getPreferredEmail();
    }
    if (name == null || name.isEmpty()) {
        name = anonymousCowardName;
    }
    String user = getUserName();
    if (user == null) {
        user = "";
    }
    user = user + "|account-" + ua.getId().toString();
    return new PersonIdent(name, user + "@" + guessHost(), when, tz);
}
#method_after
public PersonIdent newRefLogIdent(Date when, TimeZone tz) {
    final Account ua = getAccount();
    String name = ua.getFullName();
    if (name == null || name.isEmpty()) {
        name = ua.getPreferredEmail();
    }
    if (name == null || name.isEmpty()) {
        name = anonymousCowardName;
    }
    String user = getUserName();
    if (user == null) {
        user = "";
    }
    user = user + "|account-" + ua.getId().toString();
    return new PersonIdent(name, user + "@" + guessHost(), when, tz);
}
#end_block

#method_before
public PersonIdent newCommitterIdent(final Date when, final TimeZone tz) {
    final Account ua = getAccount();
    String name = ua.getFullName();
    String email = ua.getPreferredEmail();
    if (email == null || email.isEmpty()) {
        // No preferred email is configured. Use a generic identity so we
        // don't leak an address the user may have given us, but doesn't
        // necessarily want to publish through Git records.
        // 
        String user = getUserName();
        if (user == null || user.isEmpty()) {
            user = "account-" + ua.getId().toString();
        }
        String host;
        if (canonicalUrl.get() != null) {
            try {
                host = new URL(canonicalUrl.get()).getHost();
            } catch (MalformedURLException e) {
                host = SystemReader.getInstance().getHostname();
            }
        } else {
            host = SystemReader.getInstance().getHostname();
        }
        email = user + "@" + host;
    }
    if (name == null || name.isEmpty()) {
        final int at = email.indexOf('@');
        if (0 < at) {
            name = email.substring(0, at);
        } else {
            name = anonymousCowardName;
        }
    }
    return new PersonIdent(name, email, when, tz);
}
#method_after
public PersonIdent newCommitterIdent(Date when, TimeZone tz) {
    final Account ua = getAccount();
    String name = ua.getFullName();
    String email = ua.getPreferredEmail();
    if (email == null || email.isEmpty()) {
        // No preferred email is configured. Use a generic identity so we
        // don't leak an address the user may have given us, but doesn't
        // necessarily want to publish through Git records.
        // 
        String user = getUserName();
        if (user == null || user.isEmpty()) {
            user = "account-" + ua.getId().toString();
        }
        String host;
        if (canonicalUrl.get() != null) {
            try {
                host = new URL(canonicalUrl.get()).getHost();
            } catch (MalformedURLException e) {
                host = SystemReader.getInstance().getHostname();
            }
        } else {
            host = SystemReader.getInstance().getHostname();
        }
        email = user + "@" + host;
    }
    if (name == null || name.isEmpty()) {
        final int at = email.indexOf('@');
        if (0 < at) {
            name = email.substring(0, at);
        } else {
            name = anonymousCowardName;
        }
    }
    return new PersonIdent(name, email, when, tz);
}
#end_block

#method_before
private String getHost(final InetAddress in) {
    if (Boolean.FALSE.equals(disableReverseDnsLookup)) {
        return in.getCanonicalHostName();
    }
    return in.getHostAddress();
}
#method_after
private String getHost(InetAddress in) {
    if (Boolean.FALSE.equals(disableReverseDnsLookup)) {
        return in.getCanonicalHostName();
    }
    return in.getHostAddress();
}
#end_block

#method_before
public boolean doCanForDefaultPermissionBackend(GlobalOrPluginPermission perm) throws PermissionBackendException {
    if (perm instanceof GlobalPermission) {
        return can((GlobalPermission) perm);
    } else if (perm instanceof PluginPermission) {
        return canPerform(perm.permissionName()) || isAdmin();
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#method_after
public boolean doCanForDefaultPermissionBackend(GlobalOrPluginPermission perm) throws PermissionBackendException {
    if (perm instanceof GlobalPermission) {
        return can((GlobalPermission) perm);
    } else if (perm instanceof PluginPermission) {
        PluginPermission pluginPermission = (PluginPermission) perm;
        return canPerform(pluginPermission.permissionName()) || (pluginPermission.fallBackToAdmin() && isAdmin());
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    setTimeForTesting();
    serverIdent = new PersonIdent("Gerrit Server", "noreply@gerrit.com", TimeUtil.nowTs(), TZ);
    project = new Project.NameKey("test-project");
    repoManager = new InMemoryRepositoryManager();
    repo = repoManager.createRepository(project);
    tr = new TestRepository<>(repo);
    rw = tr.getRevWalk();
    accountCache = new FakeAccountCache();
    Account co = new Account(new Account.Id(1), TimeUtil.nowTs());
    co.setFullName("Change Owner");
    co.setPreferredEmail("change@owner.com");
    accountCache.put(co);
    Account ou = new Account(new Account.Id(2), TimeUtil.nowTs());
    ou.setFullName("Other Account");
    ou.setPreferredEmail("other@account.com");
    accountCache.put(ou);
    injector = Guice.createInjector(new FactoryModule() {

        @Override
        public void configure() {
            install(new GitModule());
            install(NoteDbModule.forTest(testConfig));
            bind(AllUsersName.class).toProvider(AllUsersNameProvider.class);
            bind(String.class).annotatedWith(GerritServerId.class).toInstance("gerrit");
            bind(NotesMigration.class).toInstance(MIGRATION);
            bind(GitRepositoryManager.class).toInstance(repoManager);
            bind(ProjectCache.class).toProvider(Providers.<ProjectCache>of(null));
            bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(testConfig);
            bind(String.class).annotatedWith(AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toInstance("http://localhost:8080/");
            bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toInstance(Boolean.FALSE);
            bind(Realm.class).to(FakeRealm.class);
            bind(GroupBackend.class).to(SystemGroupBackend.class).in(SINGLETON);
            bind(AccountCache.class).toInstance(accountCache);
            bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toInstance(serverIdent);
            bind(GitReferenceUpdated.class).toInstance(GitReferenceUpdated.DISABLED);
            bind(MetricMaker.class).to(DisabledMetricMaker.class);
            bind(ReviewDb.class).toProvider(Providers.<ReviewDb>of(null));
        }
    });
    injector.injectMembers(this);
    repoManager.createRepository(allUsers);
    changeOwner = userFactory.create(co.getId());
    otherUser = userFactory.create(ou.getId());
    otherUserId = otherUser.getAccountId();
    internalUser = new InternalUser();
}
#method_after
@Before
public void setUp() throws Exception {
    setTimeForTesting();
    serverIdent = new PersonIdent("Gerrit Server", "noreply@gerrit.com", TimeUtil.nowTs(), TZ);
    project = new Project.NameKey("test-project");
    repoManager = new InMemoryRepositoryManager();
    repo = repoManager.createRepository(project);
    tr = new TestRepository<>(repo);
    rw = tr.getRevWalk();
    accountCache = new FakeAccountCache();
    Account co = new Account(new Account.Id(1), TimeUtil.nowTs());
    co.setFullName("Change Owner");
    co.setPreferredEmail("change@owner.com");
    accountCache.put(co);
    Account ou = new Account(new Account.Id(2), TimeUtil.nowTs());
    ou.setFullName("Other Account");
    ou.setPreferredEmail("other@account.com");
    accountCache.put(ou);
    injector = Guice.createInjector(new FactoryModule() {

        @Override
        public void configure() {
            install(new GitModule());
            install(NoteDbModule.forTest(testConfig));
            bind(AllUsersName.class).toProvider(AllUsersNameProvider.class);
            bind(String.class).annotatedWith(GerritServerId.class).toInstance("gerrit");
            bind(NotesMigration.class).toInstance(MIGRATION);
            bind(GitRepositoryManager.class).toInstance(repoManager);
            bind(ProjectCache.class).toProvider(Providers.<ProjectCache>of(null));
            bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(testConfig);
            bind(String.class).annotatedWith(AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toInstance("http://localhost:8080/");
            bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toInstance(Boolean.FALSE);
            bind(Realm.class).to(FakeRealm.class);
            bind(GroupBackend.class).to(SystemGroupBackend.class).in(SINGLETON);
            bind(AccountCache.class).toInstance(accountCache);
            bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toInstance(serverIdent);
            bind(GitReferenceUpdated.class).toInstance(GitReferenceUpdated.DISABLED);
            bind(MetricMaker.class).to(DisabledMetricMaker.class);
            bind(ReviewDb.class).toProvider(Providers.<ReviewDb>of(null));
            // Tests don't support ReviewDb at all, but bindings are required via NoteDbModule.
            bind(new TypeLiteral<SchemaFactory<ReviewDb>>() {
            }).toInstance(() -> {
                throw new UnsupportedOperationException();
            });
            bind(ChangeBundleReader.class).toInstance((db, id) -> {
                throw new UnsupportedOperationException();
            });
        }
    });
    injector.injectMembers(this);
    repoManager.createRepository(allUsers);
    changeOwner = userFactory.create(co.getId());
    otherUser = userFactory.create(ou.getId());
    otherUserId = otherUser.getAccountId();
    internalUser = new InternalUser();
}
#end_block

#method_before
protected Change newChange() throws Exception {
    Change c = TestChanges.newChange(project, changeOwner.getAccountId());
    ChangeUpdate u = newUpdate(c, changeOwner);
    u.setChangeId(c.getKey().get());
    u.setBranch(c.getDest().get());
    u.commit();
    return c;
}
#method_after
protected Change newChange(boolean workInProgress) throws Exception {
    Change c = TestChanges.newChange(project, changeOwner.getAccountId());
    ChangeUpdate u = newUpdate(c, changeOwner);
    u.setChangeId(c.getKey().get());
    u.setBranch(c.getDest().get());
    u.setWorkInProgress(workInProgress);
    u.commit();
    return c;
}
#end_block

#method_before
protected Change newChange() throws Exception {
    Change c = TestChanges.newChange(project, changeOwner.getAccountId());
    ChangeUpdate u = newUpdate(c, changeOwner);
    u.setChangeId(c.getKey().get());
    u.setBranch(c.getDest().get());
    u.commit();
    return c;
}
#method_after
protected Change newChange() throws Exception {
    return newChange(false);
}
#end_block

#method_before
public void setPatchSet(final PatchSet ps) {
    patchSet = ps;
}
#method_after
public void setPatchSet(PatchSet ps) {
    patchSet = ps;
}
#end_block

#method_before
public void setPatchSet(final PatchSet ps, final PatchSetInfo psi) {
    patchSet = ps;
    patchSetInfo = psi;
}
#method_after
public void setPatchSet(PatchSet ps, PatchSetInfo psi) {
    patchSet = ps;
    patchSetInfo = psi;
}
#end_block

#method_before
@Deprecated
public void setChangeMessage(final ChangeMessage cm) {
    setChangeMessage(cm.getMessage(), cm.getWrittenOn());
}
#method_after
@Deprecated
public void setChangeMessage(ChangeMessage cm) {
    setChangeMessage(cm.getMessage(), cm.getWrittenOn());
}
#end_block

#method_before
@Override
protected void init() throws EmailException {
    if (args.projectCache != null) {
        projectState = args.projectCache.get(change.getProject());
    } else {
        projectState = null;
    }
    if (patchSet == null) {
        try {
            patchSet = changeData.currentPatchSet();
        } catch (OrmException err) {
            patchSet = null;
        }
    }
    if (patchSet != null) {
        setHeader("X-Gerrit-PatchSet", patchSet.getPatchSetId() + "");
        if (patchSetInfo == null) {
            try {
                patchSetInfo = args.patchSetInfoFactory.get(args.db.get(), changeData.notes(), patchSet.getId());
            } catch (PatchSetInfoNotAvailableException | OrmException err) {
                patchSetInfo = null;
            }
        }
    }
    authors = getAuthors();
    try {
        stars = args.starredChangesUtil.byChangeFromIndex(change.getId());
    } catch (OrmException e) {
        throw new EmailException("Failed to load stars for change " + change.getChangeId(), e);
    }
    super.init();
    if (timestamp != null) {
        setHeader("Date", new Date(timestamp.getTime()));
    }
    setChangeSubjectHeader();
    setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
    setHeader("X-Gerrit-Change-Number", "" + change.getChangeId());
    setChangeUrlHeader();
    setCommitIdHeader();
    if (notify.ordinal() >= NotifyHandling.OWNER_REVIEWERS.ordinal()) {
        try {
            addByEmail(RecipientType.CC, changeData.reviewersByEmail().byState(ReviewerStateInternal.CC));
            addByEmail(RecipientType.TO, changeData.reviewersByEmail().byState(ReviewerStateInternal.REVIEWER));
        } catch (OrmException e) {
            throw new EmailException("Failed to add unregistered CCs " + change.getChangeId(), e);
        }
    }
}
#method_after
@Override
protected void init() throws EmailException {
    if (args.projectCache != null) {
        projectState = args.projectCache.get(change.getProject());
    } else {
        projectState = null;
    }
    if (patchSet == null) {
        try {
            patchSet = changeData.currentPatchSet();
        } catch (OrmException err) {
            patchSet = null;
        }
    }
    if (patchSet != null) {
        setHeader("X-Gerrit-PatchSet", patchSet.getPatchSetId() + "");
        if (patchSetInfo == null) {
            try {
                patchSetInfo = args.patchSetInfoFactory.get(args.db.get(), changeData.notes(), patchSet.getId());
            } catch (PatchSetInfoNotAvailableException | OrmException err) {
                patchSetInfo = null;
            }
        }
    }
    authors = getAuthors();
    try {
        stars = args.starredChangesUtil.byChangeFromIndex(change.getId());
    } catch (OrmException e) {
        throw new EmailException("Failed to load stars for change " + change.getChangeId(), e);
    }
    super.init();
    if (timestamp != null) {
        setHeader("Date", new Date(timestamp.getTime()));
    }
    setChangeSubjectHeader();
    setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
    setHeader("X-Gerrit-Change-Number", "" + change.getChangeId());
    setChangeUrlHeader();
    setCommitIdHeader();
    if (notify.ordinal() >= NotifyHandling.OWNER_REVIEWERS.ordinal()) {
        try {
            addByEmail(RecipientType.CC, changeData.reviewersByEmail().byState(ReviewerStateInternal.CC));
            addByEmail(RecipientType.CC, changeData.reviewersByEmail().byState(ReviewerStateInternal.REVIEWER));
        } catch (OrmException e) {
            throw new EmailException("Failed to add unregistered CCs " + change.getChangeId(), e);
        }
    }
}
#end_block

#method_before
protected void rcptToAuthors(final RecipientType rt) {
    for (final Account.Id id : authors) {
        add(rt, id);
    }
}
#method_after
protected void rcptToAuthors(RecipientType rt) {
    for (Account.Id id : authors) {
        add(rt, id);
    }
}
#end_block

#method_before
@Override
protected void add(final RecipientType rt, final Account.Id to) {
    if (!emailOnlyAuthors || authors.contains(to)) {
        super.add(rt, to);
    }
}
#method_after
@Override
protected void add(RecipientType rt, Account.Id to) {
    if (!emailOnlyAuthors || authors.contains(to)) {
        super.add(rt, to);
    }
}
#end_block

#method_before
@Override
protected boolean isVisibleTo(final Account.Id to) throws OrmException {
    return projectState == null || projectState.controlFor(args.identifiedUserFactory.create(to)).controlFor(args.db.get(), change).isVisible(args.db.get());
}
#method_after
@Override
protected boolean isVisibleTo(Account.Id to) throws OrmException {
    return projectState == null || projectState.controlFor(args.identifiedUserFactory.create(to)).controlFor(args.db.get(), change).isVisible(args.db.get());
}
#end_block

#method_before
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("changeId", change.getKey().get());
    soyContext.put("coverLetter", getCoverLetter());
    soyContext.put("fromName", getNameFor(fromId));
    soyContext.put("fromEmail", getNameEmailFor(fromId));
    soyContext.put("diffLines", getDiffTemplateData());
    soyContextEmailData.put("unifiedDiff", getUnifiedDiff());
    soyContextEmailData.put("changeDetail", getChangeDetail());
    soyContextEmailData.put("changeUrl", getChangeUrl());
    soyContextEmailData.put("includeDiff", getIncludeDiff());
    Map<String, String> changeData = new HashMap<>();
    changeData.put("subject", change.getSubject());
    changeData.put("originalSubject", change.getOriginalSubject());
    changeData.put("ownerName", getNameFor(change.getOwner()));
    changeData.put("ownerEmail", getNameEmailFor(change.getOwner()));
    changeData.put("changeNumber", Integer.toString(change.getChangeId()));
    soyContext.put("change", changeData);
    String subject = change.getSubject();
    changeData.put("subject", subject);
    // it exceeds that.
    if (subject.length() < 64) {
        changeData.put("shortSubject", subject);
    } else {
        changeData.put("shortSubject", subject.substring(0, 60) + "...");
    }
    Map<String, Object> patchSetData = new HashMap<>();
    patchSetData.put("patchSetId", patchSet.getPatchSetId());
    patchSetData.put("refName", patchSet.getRefName());
    soyContext.put("patchSet", patchSetData);
    // TODO(wyatta): patchSetInfo
    footers.add("Gerrit-MessageType: " + messageClass);
    footers.add("Gerrit-Change-Id: " + change.getKey().get());
    footers.add("Gerrit-Change-Number: " + Integer.toString(change.getChangeId()));
    footers.add("Gerrit-PatchSet: " + patchSet.getPatchSetId());
    footers.add("Gerrit-Owner: " + getNameEmailFor(change.getOwner()));
    for (String reviewer : getEmailsByState(ReviewerStateInternal.REVIEWER)) {
        footers.add("Gerrit-Reviewer: " + reviewer);
    }
    for (String reviewer : getEmailsByState(ReviewerStateInternal.CC)) {
        footers.add("Gerrit-CC: " + reviewer);
    }
}
#method_after
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("changeId", change.getKey().get());
    soyContext.put("coverLetter", getCoverLetter());
    soyContext.put("fromName", getNameFor(fromId));
    soyContext.put("fromEmail", getNameEmailFor(fromId));
    soyContext.put("diffLines", getDiffTemplateData());
    soyContextEmailData.put("unifiedDiff", getUnifiedDiff());
    soyContextEmailData.put("changeDetail", getChangeDetail());
    soyContextEmailData.put("changeUrl", getChangeUrl());
    soyContextEmailData.put("includeDiff", getIncludeDiff());
    Map<String, String> changeData = new HashMap<>();
    changeData.put("subject", change.getSubject());
    changeData.put("originalSubject", change.getOriginalSubject());
    changeData.put("ownerName", getNameFor(change.getOwner()));
    changeData.put("ownerEmail", getNameEmailFor(change.getOwner()));
    changeData.put("changeNumber", Integer.toString(change.getChangeId()));
    soyContext.put("change", changeData);
    String subject = change.getSubject();
    changeData.put("subject", subject);
    // it exceeds that.
    if (subject.length() < 73) {
        changeData.put("shortSubject", subject);
    } else {
        changeData.put("shortSubject", subject.substring(0, 69) + "...");
    }
    Map<String, Object> patchSetData = new HashMap<>();
    patchSetData.put("patchSetId", patchSet.getPatchSetId());
    patchSetData.put("refName", patchSet.getRefName());
    soyContext.put("patchSet", patchSetData);
    // TODO(wyatta): patchSetInfo
    footers.add("Gerrit-MessageType: " + messageClass);
    footers.add("Gerrit-Change-Id: " + change.getKey().get());
    footers.add("Gerrit-Change-Number: " + Integer.toString(change.getChangeId()));
    footers.add("Gerrit-PatchSet: " + patchSet.getPatchSetId());
    footers.add("Gerrit-Owner: " + getNameEmailFor(change.getOwner()));
    for (String reviewer : getEmailsByState(ReviewerStateInternal.REVIEWER)) {
        footers.add("Gerrit-Reviewer: " + reviewer);
    }
    for (String reviewer : getEmailsByState(ReviewerStateInternal.CC)) {
        footers.add("Gerrit-CC: " + reviewer);
    }
}
#end_block

#method_before
public boolean canSee(final Account.Id otherUser) {
    return canSee(new OtherUser() {

        @Override
        Account.Id getId() {
            return otherUser;
        }

        @Override
        IdentifiedUser createUser() {
            return userFactory.create(otherUser);
        }
    });
}
#method_after
public boolean canSee(Account.Id otherUser) {
    return canSee(new OtherUser() {

        @Override
        Account.Id getId() {
            return otherUser;
        }

        @Override
        IdentifiedUser createUser() {
            return userFactory.create(otherUser);
        }
    });
}
#end_block

#method_before
public boolean canSee(final AccountState otherUser) {
    return canSee(new OtherUser() {

        @Override
        Account.Id getId() {
            return otherUser.getAccount().getId();
        }

        @Override
        IdentifiedUser createUser() {
            return userFactory.create(otherUser);
        }
    });
}
#method_after
public boolean canSee(AccountState otherUser) {
    return canSee(new OtherUser() {

        @Override
        Account.Id getId() {
            return otherUser.getAccount().getId();
        }

        @Override
        IdentifiedUser createUser() {
            return userFactory.create(otherUser);
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(BatchUpdate.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new ExternalIdModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.AssistedFactory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(SetAssigneeSender.Factory.class);
    factory(VisibleRefFilter.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    bind(UiActions.class);
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), AssigneeChangedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), AccountIndexedListener.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterRefUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), ChangeMessageModifier.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), OnSubmitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ReviewerSuggestion.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), ParentWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    DynamicSet.setOf(binder(), AssigneeValidationListener.class);
    DynamicSet.setOf(binder(), ActionVisitor.class);
    DynamicMap.mapOf(binder(), MailFilter.class);
    bind(MailFilter.class).annotatedWith(Exports.named("ListMailFilter")).to(ListMailFilter.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeHasOperandFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryProcessor.ChangeAttributeFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(AbandonOp.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(OnSubmitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    factory(SubmoduleOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(BatchUpdate.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new ExternalIdModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.AssistedFactory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(SetAssigneeSender.Factory.class);
    factory(VisibleRefFilter.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    bind(UiActions.class);
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), AssigneeChangedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), AccountIndexedListener.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), GroupIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterRefUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), ChangeMessageModifier.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), OnSubmitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ReviewerSuggestion.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), ParentWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    DynamicSet.setOf(binder(), AssigneeValidationListener.class);
    DynamicSet.setOf(binder(), ActionVisitor.class);
    DynamicMap.mapOf(binder(), MailFilter.class);
    bind(MailFilter.class).annotatedWith(Exports.named("ListMailFilter")).to(ListMailFilter.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeHasOperandFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryProcessor.ChangeAttributeFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(AbandonOp.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(OnSubmitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    factory(MergeOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
public WorkQueue.Executor get() {
    return queues.getQueue(capabilityFactory.create(user).getQueueType());
}
#method_after
@Override
public ScheduledThreadPoolExecutor get() {
    return queues.getQueue(capabilityFactory.create(user).getQueueType());
}
#end_block

#method_before
public ProjectControl controlFor(final Project.NameKey nameKey) throws NoSuchProjectException {
    return userCache.get().get(nameKey);
}
#method_after
public ProjectControl controlFor(Project.NameKey nameKey) throws NoSuchProjectException {
    return userCache.get().get(nameKey);
}
#end_block

#method_before
private static Set<GroupReference> getGroups(final List<SectionMatcher> sectionMatcherList) {
    final Set<GroupReference> all = new HashSet<>();
    for (final SectionMatcher matcher : sectionMatcherList) {
        final AccessSection section = matcher.section;
        for (final Permission permission : section.getPermissions()) {
            for (final PermissionRule rule : permission.getRules()) {
                all.add(rule.getGroup());
            }
        }
    }
    return all;
}
#method_after
private static Set<GroupReference> getGroups(List<SectionMatcher> sectionMatcherList) {
    final Set<GroupReference> all = new HashSet<>();
    for (SectionMatcher matcher : sectionMatcherList) {
        final AccessSection section = matcher.section;
        for (Permission permission : section.getPermissions()) {
            for (PermissionRule rule : permission.getRules()) {
                all.add(rule.getGroup());
            }
        }
    }
    return all;
}
#end_block

#method_before
private boolean canPerformOnAllRefs(String permission, Set<String> ignore) {
    boolean canPerform = false;
    Set<String> patterns = allRefPatterns(permission);
    if (patterns.contains(AccessSection.ALL)) {
        // 
        for (final String pattern : patterns) {
            if (controlForRef(pattern).canPerform(permission)) {
                canPerform = true;
            } else if (ignore.contains(pattern)) {
                continue;
            } else {
                return false;
            }
        }
    }
    return canPerform;
}
#method_after
private boolean canPerformOnAllRefs(String permission, Set<String> ignore) {
    boolean canPerform = false;
    Set<String> patterns = allRefPatterns(permission);
    if (patterns.contains(AccessSection.ALL)) {
        // 
        for (String pattern : patterns) {
            if (controlForRef(pattern).canPerform(permission)) {
                canPerform = true;
            } else if (ignore.contains(pattern)) {
                continue;
            } else {
                return false;
            }
        }
    }
    return canPerform;
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    final HttpServletRequest req = (HttpServletRequest) request;
    final HttpServletResponse rsp = (HttpServletResponse) response;
    final Continuation cont = ContinuationSupport.getContinuation(req);
    WorkQueue.Executor executor = getExecutor();
    if (cont.isInitial()) {
        TaskThunk task = new TaskThunk(executor, cont, req);
        if (maxWait > 0) {
            cont.setTimeout(maxWait);
        }
        cont.suspend(rsp);
        cont.addContinuationListener(task);
        cont.setAttribute(TASK, task);
        executor.submit(task);
    } else if (cont.isExpired()) {
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    } else if (cont.isResumed() && cont.getAttribute(CANCEL) == Boolean.TRUE) {
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    } else if (cont.isResumed()) {
        TaskThunk task = (TaskThunk) cont.getAttribute(TASK);
        try {
            task.begin(Thread.currentThread());
            chain.doFilter(req, rsp);
        } finally {
            task.end();
            Thread.interrupted();
        }
    } else {
        context.log("Unexpected QoS continuation state, aborting request");
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    }
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    final HttpServletRequest req = (HttpServletRequest) request;
    final HttpServletResponse rsp = (HttpServletResponse) response;
    final Continuation cont = ContinuationSupport.getContinuation(req);
    ScheduledThreadPoolExecutor executor = getExecutor();
    if (cont.isInitial()) {
        TaskThunk task = new TaskThunk(executor, cont, req);
        if (maxWait > 0) {
            cont.setTimeout(maxWait);
        }
        cont.suspend(rsp);
        cont.addContinuationListener(task);
        cont.setAttribute(TASK, task);
        executor.submit(task);
    } else if (cont.isExpired()) {
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    } else if (cont.isResumed() && cont.getAttribute(CANCEL) == Boolean.TRUE) {
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    } else if (cont.isResumed()) {
        TaskThunk task = (TaskThunk) cont.getAttribute(TASK);
        try {
            task.begin(Thread.currentThread());
            chain.doFilter(req, rsp);
        } finally {
            task.end();
            Thread.interrupted();
        }
    } else {
        context.log("Unexpected QoS continuation state, aborting request");
        rsp.sendError(SC_SERVICE_UNAVAILABLE);
    }
}
#end_block

#method_before
private WorkQueue.Executor getExecutor() {
    QueueType qt = capabilityFactory.create(user.get()).getQueueType();
    return queue.getQueue(qt);
}
#method_after
private ScheduledThreadPoolExecutor getExecutor() {
    QueueProvider.QueueType qt = capabilityFactory.create(user.get()).getQueueType();
    return queue.getQueue(qt);
}
#end_block

#method_before
public GroupControl controlFor(final AccountGroup.Id groupId) throws NoSuchGroupException {
    final AccountGroup group = groupCache.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return controlFor(GroupDescriptions.forAccountGroup(group));
}
#method_after
public GroupControl controlFor(AccountGroup.Id groupId) throws NoSuchGroupException {
    final AccountGroup group = groupCache.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return controlFor(GroupDescriptions.forAccountGroup(group));
}
#end_block

#method_before
public GroupControl controlFor(final AccountGroup.UUID groupId) throws NoSuchGroupException {
    final GroupDescription.Basic group = groupBackend.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return controlFor(group);
}
#method_after
public GroupControl controlFor(AccountGroup.UUID groupId) throws NoSuchGroupException {
    final GroupDescription.Basic group = groupBackend.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return controlFor(group);
}
#end_block

#method_before
public GroupControl validateFor(final AccountGroup.Id groupId) throws NoSuchGroupException {
    final GroupControl c = controlFor(groupId);
    if (!c.isVisible()) {
        throw new NoSuchGroupException(groupId);
    }
    return c;
}
#method_after
public GroupControl validateFor(AccountGroup.Id groupId) throws NoSuchGroupException {
    final GroupControl c = controlFor(groupId);
    if (!c.isVisible()) {
        throw new NoSuchGroupException(groupId);
    }
    return c;
}
#end_block

#method_before
public GroupControl validateFor(final AccountGroup.UUID groupUUID) throws NoSuchGroupException {
    final GroupControl c = controlFor(groupUUID);
    if (!c.isVisible()) {
        throw new NoSuchGroupException(groupUUID);
    }
    return c;
}
#method_after
public GroupControl validateFor(AccountGroup.UUID groupUUID) throws NoSuchGroupException {
    final GroupControl c = controlFor(groupUUID);
    if (!c.isVisible()) {
        throw new NoSuchGroupException(groupUUID);
    }
    return c;
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP, args.fillArgs)), ReviewerPredicate.reviewer(args, self()));
    }
    if ("cc".equalsIgnoreCase(value)) {
        return ReviewerPredicate.cc(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.MERGEABLE, args.fillArgs);
    }
    if ("private".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.PRIVATE, args.fillArgs);
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    if ("submittable".equalsIgnoreCase(value)) {
        return new SubmittablePredicate(SubmitRecord.Status.OK);
    }
    if ("ignored".equalsIgnoreCase(value)) {
        return star("ignore");
    }
    if ("wip".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.WIP, args.fillArgs);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.WIP)) {
            return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP, args.fillArgs)), ReviewerPredicate.reviewer(args, self()));
        }
        return ReviewerPredicate.reviewer(args, self());
    }
    if ("cc".equalsIgnoreCase(value)) {
        return ReviewerPredicate.cc(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.MERGEABLE, args.fillArgs);
    }
    if ("private".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.PRIVATE)) {
            return new BooleanPredicate(ChangeField.PRIVATE, args.fillArgs);
        }
        throw new QueryParseException("'is:private' operator is not supported by change index version");
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    if ("submittable".equalsIgnoreCase(value)) {
        return new SubmittablePredicate(SubmitRecord.Status.OK);
    }
    if ("ignored".equalsIgnoreCase(value)) {
        return star("ignore");
    }
    if ("started".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.STARTED)) {
            return new BooleanPredicate(ChangeField.STARTED, args.fillArgs);
        }
        throw new QueryParseException("'is:started' operator is not supported by change index version");
    }
    if ("wip".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.WIP)) {
            return new BooleanPredicate(ChangeField.WIP, args.fillArgs);
        }
        throw new QueryParseException("'is:wip' operator is not supported by change index version");
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(args.db.get(), who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#method_after
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if (isSelf(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(args.db.get(), who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> reviewer(String who) throws QueryParseException, OrmException {
    return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP, args.fillArgs)), reviewerByState(who, ReviewerStateInternal.REVIEWER));
}
#method_after
@Operator
public Predicate<ChangeData> reviewer(String who) throws QueryParseException, OrmException {
    return reviewer(who, false);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> reviewer(String who) throws QueryParseException, OrmException {
    return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP, args.fillArgs)), reviewerByState(who, ReviewerStateInternal.REVIEWER));
}
#method_after
private Predicate<ChangeData> reviewer(String who, boolean forDefaultField) throws QueryParseException, OrmException {
    Predicate<ChangeData> byState = reviewerByState(who, ReviewerStateInternal.REVIEWER, forDefaultField);
    if (Objects.equals(byState, Predicate.<ChangeData>any())) {
        return Predicate.any();
    }
    if (args.getSchema().hasField(ChangeField.WIP)) {
        return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP, args.fillArgs)), byState);
    }
    return byState;
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> cc(String who) throws QueryParseException, OrmException {
    return reviewerByState(who, ReviewerStateInternal.CC);
}
#method_after
@Operator
public Predicate<ChangeData> cc(String who) throws QueryParseException, OrmException {
    return reviewerByState(who, ReviewerStateInternal.CC, false);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> author(String who) {
    return new AuthorPredicate(who);
}
#method_after
@Operator
public Predicate<ChangeData> author(String who) throws QueryParseException {
    if (args.getSchema().hasField(ChangeField.EXACT_AUTHOR)) {
        return getAuthorOrCommitterPredicate(who.trim(), ExactAuthorPredicate::new, AuthorPredicate::new);
    }
    return getAuthorOrCommitterFullTextPredicate(who.trim(), AuthorPredicate::new);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> committer(String who) {
    return new CommitterPredicate(who);
}
#method_after
@Operator
public Predicate<ChangeData> committer(String who) throws QueryParseException {
    if (args.getSchema().hasField(ChangeField.EXACT_COMMITTER)) {
        return getAuthorOrCommitterPredicate(who.trim(), ExactCommitterPredicate::new, CommitterPredicate::new);
    }
    return getAuthorOrCommitterFullTextPredicate(who.trim(), CommitterPredicate::new);
}
#end_block

#method_before
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(2);
        try {
            predicates.add(change(query));
        } catch (QueryParseException e) {
        // Skip.
        }
        // For PAT_LEGACY_ID, it may also be the prefix of some commits.
        if (query.length() >= 6 && PAT_LEGACY_ID.matcher(query).matches()) {
            predicates.add(commit(query));
        }
        return Predicate.or(predicates);
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(commit(query));
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#method_after
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(2);
        try {
            predicates.add(change(query));
        } catch (QueryParseException e) {
        // Skip.
        }
        // For PAT_LEGACY_ID, it may also be the prefix of some commits.
        if (query.length() >= 6 && PAT_LEGACY_ID.matcher(query).matches()) {
            predicates.add(commit(query));
        }
        return Predicate.or(predicates);
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        Predicate<ChangeData> p = ownerDefaultField(query);
        if (!Objects.equals(p, Predicate.<ChangeData>any())) {
            predicates.add(p);
        }
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        Predicate<ChangeData> p = reviewerDefaultField(query);
        if (!Objects.equals(p, Predicate.<ChangeData>any())) {
            predicates.add(p);
        }
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(commit(query));
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#end_block

#method_before
private Set<Account.Id> parseAccount(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return Collections.singleton(self());
    }
    Set<Account.Id> matches = args.accountResolver.findAll(args.db.get(), who);
    if (matches.isEmpty()) {
        throw error("User " + who + " not found");
    }
    return matches;
}
#method_after
private Set<Account.Id> parseAccount(String who) throws QueryParseException, OrmException {
    if (isSelf(who)) {
        return Collections.singleton(self());
    }
    Set<Account.Id> matches = args.accountResolver.findAll(args.db.get(), who);
    if (matches.isEmpty()) {
        throw error("User " + who + " not found");
    }
    return matches;
}
#end_block

#method_before
public Predicate<ChangeData> reviewerByState(String who, ReviewerStateInternal state) throws QueryParseException, OrmException {
    Predicate<ChangeData> reviewerByEmailPredicate = null;
    if (args.index.getSchema().hasField(ChangeField.REVIEWER_BY_EMAIL)) {
        Address address = Address.tryParse(who);
        if (address != null) {
            reviewerByEmailPredicate = ReviewerByEmailPredicate.forState(args, address, state);
        }
    }
    Predicate<ChangeData> reviewerPredicate = null;
    try {
        reviewerPredicate = Predicate.or(parseAccount(who).stream().map(id -> ReviewerPredicate.forState(args, id, state)).collect(toList()));
    } catch (QueryParseException e) {
        // Propagate this exception only if we can't use 'who' to query by email
        if (reviewerByEmailPredicate == null) {
            throw e;
        }
    }
    if (reviewerPredicate != null && reviewerByEmailPredicate != null) {
        return Predicate.or(reviewerPredicate, reviewerByEmailPredicate);
    } else if (reviewerPredicate != null) {
        return reviewerPredicate;
    }
    return reviewerByEmailPredicate;
}
#method_after
public Predicate<ChangeData> reviewerByState(String who, ReviewerStateInternal state, boolean forDefaultField) throws QueryParseException, OrmException {
    Predicate<ChangeData> reviewerByEmailPredicate = null;
    if (args.index.getSchema().hasField(ChangeField.REVIEWER_BY_EMAIL)) {
        Address address = Address.tryParse(who);
        if (address != null) {
            reviewerByEmailPredicate = ReviewerByEmailPredicate.forState(args, address, state);
        }
    }
    Predicate<ChangeData> reviewerPredicate = null;
    try {
        Set<Account.Id> accounts = parseAccount(who);
        if (!forDefaultField || accounts.size() <= MAX_ACCOUNTS_PER_DEFAULT_FIELD) {
            reviewerPredicate = Predicate.or(accounts.stream().map(id -> ReviewerPredicate.forState(args, id, state)).collect(toList()));
        }
    } catch (QueryParseException e) {
        // Propagate this exception only if we can't use 'who' to query by email
        if (reviewerByEmailPredicate == null) {
            throw e;
        }
    }
    if (reviewerPredicate != null && reviewerByEmailPredicate != null) {
        return Predicate.or(reviewerPredicate, reviewerByEmailPredicate);
    } else if (reviewerPredicate != null) {
        return reviewerPredicate;
    } else if (reviewerByEmailPredicate != null) {
        return reviewerByEmailPredicate;
    } else {
        return Predicate.any();
    }
}
#end_block

#method_before
public ChangeControl forUser(final CurrentUser who) {
    if (getUser().equals(who)) {
        return this;
    }
    return new ChangeControl(changeDataFactory, approvalsUtil, getRefControl().forUser(who), notes, patchSetUtil);
}
#method_after
public ChangeControl forUser(CurrentUser who) {
    if (getUser().equals(who)) {
        return this;
    }
    return new ChangeControl(changeDataFactory, approvalsUtil, getRefControl().forUser(who), notes, patchSetUtil);
}
#end_block

#method_before
public boolean canPublish(final ReviewDb db) throws OrmException {
    return (isOwner() || getRefControl().canPublishDrafts()) && isVisible(db);
}
#method_after
public boolean canPublish(ReviewDb db) throws OrmException {
    return (isOwner() || getRefControl().canPublishDrafts()) && isVisible(db);
}
#end_block

#method_before
private boolean canRebase(ReviewDb db) throws OrmException {
    return (isOwner() || getRefControl().canSubmit(isOwner()) || getRefControl().canRebase()) && !isPatchSetLocked(db);
}
#method_after
private boolean canRebase(ReviewDb db) throws OrmException {
    return (isOwner() || getRefControl().canSubmit(isOwner()) || getRefControl().canRebase()) && refControl.asForRef().testOrFalse(RefPermission.CREATE_CHANGE) && !isPatchSetLocked(db);
}
#end_block

#method_before
@Override
protected Response<?> applyImpl(BatchUpdate.Factory updateFactory, ChangeResource rsrc, Input input) throws RestApiException, UpdateException {
    Change change = rsrc.getChange();
    if (!rsrc.isUserOwner()) {
        throw new AuthException("not allowed to set work in progress");
    }
    if (change.getStatus() != Status.NEW) {
        throw new ResourceConflictException("change is " + ChangeUtil.status(change));
    }
    if (change.isWorkInProgress()) {
        throw new ResourceConflictException("change is already work in progress");
    }
    try (BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        bu.addOp(rsrc.getChange().getId(), new WorkInProgressOp(cmUtil, null, null, true, input));
        bu.execute();
        return Response.ok("");
    }
}
#method_after
@Override
protected Response<?> applyImpl(BatchUpdate.Factory updateFactory, ChangeResource rsrc, Input input) throws RestApiException, UpdateException {
    Change change = rsrc.getChange();
    if (!rsrc.isUserOwner()) {
        throw new AuthException("not allowed to set work in progress");
    }
    if (change.getStatus() != Status.NEW) {
        throw new ResourceConflictException("change is " + ChangeUtil.status(change));
    }
    if (change.isWorkInProgress()) {
        throw new ResourceConflictException("change is already work in progress");
    }
    try (BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        bu.addOp(rsrc.getChange().getId(), opFactory.create(true, input));
        bu.execute();
        return Response.ok("");
    }
}
#end_block

#method_before
@Override
protected Response<?> applyImpl(BatchUpdate.Factory updateFactory, ChangeResource rsrc, Input input) throws RestApiException, UpdateException {
    Change change = rsrc.getChange();
    if (!rsrc.isUserOwner()) {
        throw new AuthException("not allowed to set ready for review");
    }
    if (change.getStatus() != Status.NEW) {
        throw new ResourceConflictException("change is " + ChangeUtil.status(change));
    }
    if (!change.isWorkInProgress()) {
        throw new ResourceConflictException("change is not work in progress");
    }
    try (BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        bu.addOp(rsrc.getChange().getId(), new WorkInProgressOp(cmUtil, email, psUtil, false, input));
        bu.execute();
        return Response.ok("");
    }
}
#method_after
@Override
protected Response<?> applyImpl(BatchUpdate.Factory updateFactory, ChangeResource rsrc, Input input) throws RestApiException, UpdateException {
    Change change = rsrc.getChange();
    if (!rsrc.isUserOwner()) {
        throw new AuthException("not allowed to set ready for review");
    }
    if (change.getStatus() != Status.NEW) {
        throw new ResourceConflictException("change is " + ChangeUtil.status(change));
    }
    if (!change.isWorkInProgress()) {
        throw new ResourceConflictException("change is not work in progress");
    }
    try (BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        bu.addOp(rsrc.getChange().getId(), opFactory.create(false, input));
        bu.execute();
        return Response.ok("");
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException {
    change = ctx.getChange();
    notes = ctx.getNotes();
    if (psUtil != null) {
        ps = psUtil.get(ctx.getDb(), ctx.getNotes(), change.currentPatchSetId());
    }
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    change.setWorkInProgress(workInProgress);
    if (!change.hasReviewStarted() && !workInProgress) {
        change.setReviewStarted(true);
    }
    change.setLastUpdatedOn(ctx.getWhen());
    update.setWorkInProgress(workInProgress);
    addMessage(ctx, update);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException {
    change = ctx.getChange();
    notes = ctx.getNotes();
    ps = psUtil.get(ctx.getDb(), ctx.getNotes(), change.currentPatchSetId());
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    change.setWorkInProgress(workInProgress);
    if (!change.hasReviewStarted() && !workInProgress) {
        change.setReviewStarted(true);
    }
    change.setLastUpdatedOn(ctx.getWhen());
    update.setWorkInProgress(workInProgress);
    addMessage(ctx, update);
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) {
    if (email == null || ps == null) {
        return;
    }
    email.create(NotifyHandling.ALL, ImmutableListMultimap.of(), notes, ps, ctx.getIdentifiedUser(), cmsg, ImmutableList.of(), cmsg.getMessage(), ImmutableList.of()).sendAsync();
}
#method_after
@Override
public void postUpdate(Context ctx) {
    if (workInProgress) {
        return;
    }
    email.create(NotifyHandling.ALL, ImmutableListMultimap.of(), notes, ps, ctx.getIdentifiedUser(), cmsg, ImmutableList.of(), cmsg.getMessage(), ImmutableList.of()).sendAsync();
}
#end_block

#method_before
@Override
public Response<String> apply(AccountResource rsrc, Input input) throws AuthException, RepositoryNotFoundException, IOException, UnprocessableEntityException {
    if (self.get() != rsrc.getUser()) {
        permissionBackend.user(self).check(ADMINISTRATE_SERVER);
    }
    if (input == null) {
        input = new Input();
    }
    String username = self.get().getUserName();
    ProjectLevelConfig storage = projectCache.getAllProjects().getConfig(pluginName + ".config");
    Config db = storage.get();
    boolean modified = false;
    String defaultProject = db.getString(PREFERENCE, username, KEY_DEFAULT_PROJECT);
    if (Strings.emptyToNull(input.defaultProject) != null) {
        if (projectCache.get(new Project.NameKey(input.defaultProject)) == null) {
            throw new UnprocessableEntityException("project '" + input.defaultProject + "' does not exist");
        }
        if (!input.defaultProject.equals(defaultProject)) {
            db.setString(PREFERENCE, username, KEY_DEFAULT_PROJECT, input.defaultProject);
            modified = true;
        }
    } else {
        if (defaultProject != null) {
            db.unset(PREFERENCE, username, KEY_DEFAULT_PROJECT);
            modified = true;
        }
    }
    if (input.linkDecoration != null) {
        LinkDecoration linkDecoration = db.getEnum(PREFERENCE, username, KEY_LINK_DECORATION, LinkDecoration.NONE);
        if (!input.linkDecoration.equals(linkDecoration)) {
            db.setEnum(PREFERENCE, username, KEY_LINK_DECORATION, input.linkDecoration);
            modified = true;
        }
    } else {
        if (db.getNames(PREFERENCE, username).contains(KEY_LINK_DECORATION)) {
            db.unset(PREFERENCE, username, KEY_LINK_DECORATION);
            modified = true;
        }
    }
    boolean stage = db.getBoolean(PREFERENCE, username, KEY_STAGE, false);
    if (input.stage != null) {
        if (input.stage != stage) {
            db.setBoolean(PREFERENCE, username, KEY_STAGE, input.stage);
            modified = true;
        }
    } else {
        if (!stage) {
            db.unset(PREFERENCE, username, KEY_STAGE);
            modified = true;
        }
    }
    if (modified) {
        MetaDataUpdate md = metaDataUpdateFactory.create(projectCache.getAllProjects().getProject().getNameKey());
        md.setMessage("Update " + pluginName + " Preferences for '" + username + "'\n");
        storage.commit(md);
    }
    return Response.<String>ok("OK");
}
#method_after
@Override
public Response<String> apply(AccountResource rsrc, Input input) throws AuthException, RepositoryNotFoundException, IOException, UnprocessableEntityException, PermissionBackendException {
    if (self.get() != rsrc.getUser()) {
        permissionBackend.user(self).check(ADMINISTRATE_SERVER);
    }
    if (input == null) {
        input = new Input();
    }
    String username = self.get().getUserName();
    ProjectLevelConfig storage = projectCache.getAllProjects().getConfig(pluginName + ".config");
    Config db = storage.get();
    boolean modified = false;
    String defaultProject = db.getString(PREFERENCE, username, KEY_DEFAULT_PROJECT);
    if (Strings.emptyToNull(input.defaultProject) != null) {
        if (projectCache.get(new Project.NameKey(input.defaultProject)) == null) {
            throw new UnprocessableEntityException("project '" + input.defaultProject + "' does not exist");
        }
        if (!input.defaultProject.equals(defaultProject)) {
            db.setString(PREFERENCE, username, KEY_DEFAULT_PROJECT, input.defaultProject);
            modified = true;
        }
    } else {
        if (defaultProject != null) {
            db.unset(PREFERENCE, username, KEY_DEFAULT_PROJECT);
            modified = true;
        }
    }
    if (input.linkDecoration != null) {
        LinkDecoration linkDecoration = db.getEnum(PREFERENCE, username, KEY_LINK_DECORATION, LinkDecoration.NONE);
        if (!input.linkDecoration.equals(linkDecoration)) {
            db.setEnum(PREFERENCE, username, KEY_LINK_DECORATION, input.linkDecoration);
            modified = true;
        }
    } else {
        if (db.getNames(PREFERENCE, username).contains(KEY_LINK_DECORATION)) {
            db.unset(PREFERENCE, username, KEY_LINK_DECORATION);
            modified = true;
        }
    }
    boolean stage = db.getBoolean(PREFERENCE, username, KEY_STAGE, false);
    if (input.stage != null) {
        if (input.stage != stage) {
            db.setBoolean(PREFERENCE, username, KEY_STAGE, input.stage);
            modified = true;
        }
    } else {
        if (!stage) {
            db.unset(PREFERENCE, username, KEY_STAGE);
            modified = true;
        }
    }
    if (modified) {
        MetaDataUpdate md = metaDataUpdateFactory.create(projectCache.getAllProjects().getProject().getNameKey());
        md.setMessage("Update " + pluginName + " Preferences for '" + username + "'\n");
        storage.commit(md);
    }
    return Response.<String>ok("OK");
}
#end_block

#method_before
@Override
public void service(HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!"GET".equals(req.getMethod()) && !"HEAD".equals(req.getMethod())) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
        return;
    }
    ResourceKey key = ResourceKey.fromPath(getEncodedPath(req));
    ProjectState state = projectCache.get(key.project);
    if (state == null || key.file == null) {
        notFound(res);
        return;
    }
    MimeType mimeType = fileTypeRegistry.getMimeType(key.file, null);
    if (!("image".equals(mimeType.getMediaType()) && fileTypeRegistry.isSafeInline(mimeType))) {
        notFound(res);
        return;
    }
    try {
        ProjectControl projectControl = projectControlFactory.validateFor(key.project);
        String rev = key.revision;
        if (rev == null || Constants.HEAD.equals(rev)) {
            rev = getHead.get().apply(new ProjectResource(projectControl));
        } else {
            if (!ObjectId.isId(rev)) {
                if (!rev.startsWith(Constants.R_REFS)) {
                    rev = Constants.R_HEADS + rev;
                }
                if (!projectControl.controlForRef(rev).isVisible()) {
                    notFound(res);
                    return;
                }
            }
        }
        try (Repository repo = repoManager.openRepository(key.project)) {
            ObjectId revId = repo.resolve(rev != null ? rev : Constants.HEAD);
            if (revId == null) {
                notFound(res);
                return;
            }
            if (ObjectId.isId(rev)) {
                try (RevWalk rw = new RevWalk(repo)) {
                    RevCommit commit = rw.parseCommit(repo.resolve(rev));
                    if (!projectControl.canReadCommit(db.get(), repo, commit)) {
                        notFound(res);
                        return;
                    }
                }
            }
            String eTag = null;
            String receivedETag = req.getHeader(HttpHeaders.IF_NONE_MATCH);
            if (receivedETag != null) {
                eTag = computeETag(key.project, revId, key.file);
                if (eTag.equals(receivedETag)) {
                    res.sendError(SC_NOT_MODIFIED);
                    return;
                }
            }
            if (!"image".equals(mimeType.getMediaType())) {
                notFound(res);
                return;
            }
            try (RevWalk rw = new RevWalk(repo)) {
                RevCommit commit = rw.parseCommit(revId);
                RevTree tree = commit.getTree();
                try (TreeWalk tw = new TreeWalk(repo)) {
                    tw.addTree(tree);
                    tw.setRecursive(true);
                    tw.setFilter(PathFilter.create(key.file));
                    if (!tw.next()) {
                        notFound(res);
                        return;
                    }
                    ObjectId objectId = tw.getObjectId(0);
                    ObjectLoader loader = repo.open(objectId);
                    byte[] content = loader.getBytes(Integer.MAX_VALUE);
                    mimeType = fileTypeRegistry.getMimeType(key.file, content);
                    if (!"image".equals(mimeType.getMediaType()) || !fileTypeRegistry.isSafeInline(mimeType)) {
                        notFound(res);
                        return;
                    }
                    res.setHeader(HttpHeaders.ETAG, eTag != null ? eTag : computeETag(key.project, revId, key.file));
                    CacheHeaders.setCacheablePrivate(res, 7, TimeUnit.DAYS, false);
                    send(req, res, content, mimeType.toString(), commit.getCommitTime());
                    return;
                }
            } catch (IOException e) {
                notFound(res);
                return;
            }
        }
    } catch (RepositoryNotFoundException | NoSuchProjectException | ResourceNotFoundException | AuthException | RevisionSyntaxException e) {
        notFound(res);
        return;
    }
}
#method_after
@Override
public void service(HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!"GET".equals(req.getMethod()) && !"HEAD".equals(req.getMethod())) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
        return;
    }
    ResourceKey key = ResourceKey.fromPath(getEncodedPath(req));
    ProjectState state = projectCache.get(key.project);
    if (state == null || key.file == null) {
        notFound(res);
        return;
    }
    MimeType mimeType = fileTypeRegistry.getMimeType(key.file, (byte[]) null);
    if (!("image".equals(mimeType.getMediaType()) && fileTypeRegistry.isSafeInline(mimeType))) {
        notFound(res);
        return;
    }
    try {
        ProjectControl projectControl = projectControlFactory.controlFor(key.project);
        String rev = key.revision;
        if (rev == null || Constants.HEAD.equals(rev)) {
            rev = getHead.get().apply(new ProjectResource(projectControl));
        } else {
            if (!ObjectId.isId(rev)) {
                if (!rev.startsWith(Constants.R_REFS)) {
                    rev = Constants.R_HEADS + rev;
                }
                if (!projectControl.controlForRef(rev).isVisible()) {
                    notFound(res);
                    return;
                }
            }
        }
        try (Repository repo = repoManager.openRepository(key.project)) {
            ObjectId revId = repo.resolve(rev != null ? rev : Constants.HEAD);
            if (revId == null) {
                notFound(res);
                return;
            }
            if (ObjectId.isId(rev)) {
                try (RevWalk rw = new RevWalk(repo)) {
                    RevCommit commit = rw.parseCommit(repo.resolve(rev));
                    if (!projectControl.canReadCommit(db.get(), repo, commit)) {
                        notFound(res);
                        return;
                    }
                }
            }
            String eTag = null;
            String receivedETag = req.getHeader(HttpHeaders.IF_NONE_MATCH);
            if (receivedETag != null) {
                eTag = computeETag(key.project, revId, key.file);
                if (eTag.equals(receivedETag)) {
                    res.sendError(SC_NOT_MODIFIED);
                    return;
                }
            }
            if (!"image".equals(mimeType.getMediaType())) {
                notFound(res);
                return;
            }
            try (RevWalk rw = new RevWalk(repo)) {
                RevCommit commit = rw.parseCommit(revId);
                RevTree tree = commit.getTree();
                try (TreeWalk tw = new TreeWalk(repo)) {
                    tw.addTree(tree);
                    tw.setRecursive(true);
                    tw.setFilter(PathFilter.create(key.file));
                    if (!tw.next()) {
                        notFound(res);
                        return;
                    }
                    ObjectId objectId = tw.getObjectId(0);
                    ObjectLoader loader = repo.open(objectId);
                    byte[] content = loader.getBytes(Integer.MAX_VALUE);
                    mimeType = fileTypeRegistry.getMimeType(key.file, content);
                    if (!"image".equals(mimeType.getMediaType()) || !fileTypeRegistry.isSafeInline(mimeType)) {
                        notFound(res);
                        return;
                    }
                    res.setHeader(HttpHeaders.ETAG, eTag != null ? eTag : computeETag(key.project, revId, key.file));
                    CacheHeaders.setCacheablePrivate(res, 7, TimeUnit.DAYS, false);
                    send(req, res, content, mimeType.toString(), commit.getCommitTime());
                    return;
                }
            } catch (IOException e) {
                notFound(res);
                return;
            }
        }
    } catch (RepositoryNotFoundException | NoSuchProjectException | ResourceNotFoundException | AuthException | RevisionSyntaxException e) {
        notFound(res);
        return;
    }
}
#end_block

#method_before
@Override
public ConfigInfo apply(AccountResource rsrc) throws AuthException {
    if (self.get() != rsrc.getUser()) {
        permissionBackend.user(self).check(ADMINISTRATE_SERVER);
    }
    String username = self.get().getUserName();
    ConfigInfo globalCfg = getConfig.get().apply(new ConfigResource());
    Config db = projectCache.getAllProjects().getConfig(pluginName + ".config").get();
    ConfigInfo info = new ConfigInfo();
    info.defaultProject = MoreObjects.firstNonNull(db.getString(PREFERENCE, username, KEY_DEFAULT_PROJECT), globalCfg.defaultProject);
    info.linkDecoration = db.getEnum(PREFERENCE, username, KEY_LINK_DECORATION, MoreObjects.firstNonNull(globalCfg.linkDecoration, LinkDecoration.NONE));
    if (LinkDecoration.NONE.equals(info.linkDecoration)) {
        info.linkDecoration = null;
    }
    info.stage = db.getBoolean(PREFERENCE, username, KEY_STAGE, (globalCfg.stage != null ? globalCfg.stage : false));
    if (!info.stage) {
        info.stage = null;
    }
    info.pattern = globalCfg.pattern;
    return info;
}
#method_after
@Override
public ConfigInfo apply(AccountResource rsrc) throws AuthException, PermissionBackendException {
    if (self.get() != rsrc.getUser()) {
        permissionBackend.user(self).check(ADMINISTRATE_SERVER);
    }
    String username = self.get().getUserName();
    ConfigInfo globalCfg = getConfig.get().apply(new ConfigResource());
    Config db = projectCache.getAllProjects().getConfig(pluginName + ".config").get();
    ConfigInfo info = new ConfigInfo();
    info.defaultProject = MoreObjects.firstNonNull(db.getString(PREFERENCE, username, KEY_DEFAULT_PROJECT), globalCfg.defaultProject);
    info.linkDecoration = db.getEnum(PREFERENCE, username, KEY_LINK_DECORATION, MoreObjects.firstNonNull(globalCfg.linkDecoration, LinkDecoration.NONE));
    if (LinkDecoration.NONE.equals(info.linkDecoration)) {
        info.linkDecoration = null;
    }
    info.stage = db.getBoolean(PREFERENCE, username, KEY_STAGE, (globalCfg.stage != null ? globalCfg.stage : false));
    if (!info.stage) {
        info.stage = null;
    }
    info.pattern = globalCfg.pattern;
    return info;
}
#end_block

#method_before
public synchronized Executor getDefaultQueue() {
    if (defaultQueue == null) {
        defaultQueue = createQueue(defaultQueueSize, "WorkQueue");
    }
    return defaultQueue;
}
#method_after
public synchronized ScheduledThreadPoolExecutor getDefaultQueue() {
    if (defaultQueue == null) {
        defaultQueue = createQueue(defaultQueueSize, "WorkQueue");
    }
    return defaultQueue;
}
#end_block

#method_before
public Executor createQueue(int poolsize, String prefix) {
    return createQueue(poolsize, prefix, Thread.NORM_PRIORITY);
}
#method_after
public ScheduledThreadPoolExecutor createQueue(int poolsize, String prefix) {
    return createQueue(poolsize, prefix, Thread.NORM_PRIORITY);
}
#end_block

#method_before
public Executor createQueue(int poolsize, String prefix, int threadPriority) {
    final Executor r = new Executor(poolsize, prefix);
    if (threadPriority != Thread.NORM_PRIORITY) {
        final ThreadFactory parent = r.getThreadFactory();
        r.setThreadFactory(task -> {
            final Thread t = parent.newThread(task);
            t.setPriority(threadPriority);
            return t;
        });
    }
    r.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);
    r.setExecuteExistingDelayedTasksAfterShutdownPolicy(true);
    queues.add(r);
    return r;
}
#method_after
public ScheduledThreadPoolExecutor createQueue(int poolsize, String prefix, int threadPriority) {
    Executor executor = new Executor(poolsize, prefix);
    executor.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);
    executor.setExecuteExistingDelayedTasksAfterShutdownPolicy(true);
    queues.add(executor);
    if (threadPriority != Thread.NORM_PRIORITY) {
        ThreadFactory parent = executor.getThreadFactory();
        executor.setThreadFactory(task -> {
            Thread t = parent.newThread(task);
            t.setPriority(threadPriority);
            return t;
        });
    }
    return executor;
}
#end_block

#method_before
public List<Task<?>> getTasks() {
    final List<Task<?>> r = new ArrayList<>();
    for (final Executor e : queues) {
        e.addAllTo(r);
    }
    return r;
}
#method_after
public List<Task<?>> getTasks() {
    final List<Task<?>> r = new ArrayList<>();
    for (Executor e : queues) {
        e.addAllTo(r);
    }
    return r;
}
#end_block

#method_before
public Task<?> getTask(final int id) {
    Task<?> result = null;
    for (final Executor e : queues) {
        final Task<?> t = e.getTask(id);
        if (t != null) {
            if (result != null) {
                // Don't return the task if we have a duplicate. Lie instead.
                return null;
            }
            result = t;
        }
    }
    return result;
}
#method_after
public Task<?> getTask(int id) {
    Task<?> result = null;
    for (Executor e : queues) {
        final Task<?> t = e.getTask(id);
        if (t != null) {
            if (result != null) {
                // Don't return the task if we have a duplicate. Lie instead.
                return null;
            }
            result = t;
        }
    }
    return result;
}
#end_block

#method_before
public Executor getExecutor(String queueName) {
    for (Executor e : queues) {
        if (e.queueName.equals(queueName)) {
            return e;
        }
    }
    return null;
}
#method_after
public ScheduledThreadPoolExecutor getExecutor(String queueName) {
    for (Executor e : queues) {
        if (e.queueName.equals(queueName)) {
            return e;
        }
    }
    return null;
}
#end_block

#method_before
private void stop() {
    for (final Executor p : queues) {
        p.shutdown();
        boolean isTerminated;
        do {
            try {
                isTerminated = p.awaitTermination(10, TimeUnit.SECONDS);
            } catch (InterruptedException ie) {
                isTerminated = false;
            }
        } while (!isTerminated);
    }
    queues.clear();
}
#method_after
private void stop() {
    for (Executor p : queues) {
        p.shutdown();
        boolean isTerminated;
        do {
            try {
                isTerminated = p.awaitTermination(10, TimeUnit.SECONDS);
            } catch (InterruptedException ie) {
                isTerminated = false;
            }
        } while (!isTerminated);
    }
    queues.clear();
}
#end_block

#method_before
@Override
protected <V> RunnableScheduledFuture<V> decorateTask(final Runnable runnable, RunnableScheduledFuture<V> r) {
    r = super.decorateTask(runnable, r);
    for (; ; ) {
        final int id = idGenerator.next();
        Task<V> task;
        if (runnable instanceof ProjectRunnable) {
            task = new ProjectTask<>((ProjectRunnable) runnable, r, this, id);
        } else {
            task = new Task<>(runnable, r, this, id);
        }
        if (all.putIfAbsent(task.getTaskId(), task) == null) {
            return task;
        }
    }
}
#method_after
@Override
protected <V> RunnableScheduledFuture<V> decorateTask(Runnable runnable, RunnableScheduledFuture<V> r) {
    r = super.decorateTask(runnable, r);
    for (; ; ) {
        final int id = idGenerator.next();
        Task<V> task;
        if (runnable instanceof ProjectRunnable) {
            task = new ProjectTask<>((ProjectRunnable) runnable, r, this, id);
        } else {
            task = new Task<>(runnable, r, this, id);
        }
        if (all.putIfAbsent(task.getTaskId(), task) == null) {
            return task;
        }
    }
}
#end_block

#method_before
@Override
protected <V> RunnableScheduledFuture<V> decorateTask(final Callable<V> callable, final RunnableScheduledFuture<V> task) {
    throw new UnsupportedOperationException("Callable not implemented");
}
#method_after
@Override
protected <V> RunnableScheduledFuture<V> decorateTask(Callable<V> callable, RunnableScheduledFuture<V> task) {
    throw new UnsupportedOperationException("Callable not implemented");
}
#end_block

#method_before
void remove(final Task<?> task) {
    all.remove(task.getTaskId(), task);
}
#method_after
void remove(Task<?> task) {
    all.remove(task.getTaskId(), task);
}
#end_block

#method_before
Task<?> getTask(final int id) {
    return all.get(id);
}
#method_after
Task<?> getTask(int id) {
    return all.get(id);
}
#end_block

#method_before
void addAllTo(final List<Task<?>> list) {
    // iterator is thread safe
    list.addAll(all.values());
}
#method_after
void addAllTo(List<Task<?>> list) {
    // iterator is thread safe
    list.addAll(all.values());
}
#end_block

#method_before
@Override
public WorkQueue.Executor getQueue(QueueType type) {
    switch(type) {
        case INTERACTIVE:
            return interactiveExecutor;
        case BATCH:
        default:
            return batchExecutor;
    }
}
#method_after
@Override
public ScheduledThreadPoolExecutor getQueue(QueueType type) {
    switch(type) {
        case INTERACTIVE:
            return interactiveExecutor;
        case BATCH:
        default:
            return batchExecutor;
    }
}
#end_block

#method_before
@Override
public WorkQueue.Executor get() {
    return queues.createQueue(poolSize, "SSH-Stream-Worker", Thread.MIN_PRIORITY);
}
#method_after
@Override
public ScheduledThreadPoolExecutor get() {
    return queues.createQueue(poolSize, "SSH-Stream-Worker", Thread.MIN_PRIORITY);
}
#end_block

#method_before
public static boolean isGroupReference(String configValue) {
    return configValue.startsWith(PREFIX);
}
#method_after
public static boolean isGroupReference(String configValue) {
    return configValue != null && configValue.startsWith(PREFIX);
}
#end_block

#method_before
private Collection<String> reviewed(RevisionResource resource) throws AuthException, OrmException {
    CurrentUser user = self.get();
    if (!(user.isIdentifiedUser())) {
        throw new AuthException("Authentication required");
    }
    Account.Id userId = user.getAccountId();
    PatchSet patchSetId = resource.getPatchSet();
    Optional<PatchSetWithReviewedFiles> o = accountPatchReviewStore.get().findReviewed(patchSetId.getId(), userId);
    if (o.isPresent()) {
        PatchSetWithReviewedFiles res = o.get();
        if (res.patchSetId.equals(patchSetId.getId())) {
            return res.files;
        }
        PatchSetWithReviewedFiles reviewed = o.get();
        try {
            return copy(Sets.newHashSet(reviewed.files), reviewed.patchSetId, resource, userId);
        } catch (IOException | PatchListNotAvailableException e) {
            log.warn("Cannot copy patch review flags", e);
        }
    }
    return Collections.emptyList();
}
#method_after
private Collection<String> reviewed(RevisionResource resource) throws AuthException, OrmException {
    CurrentUser user = self.get();
    if (!(user.isIdentifiedUser())) {
        throw new AuthException("Authentication required");
    }
    Account.Id userId = user.getAccountId();
    PatchSet patchSetId = resource.getPatchSet();
    Optional<PatchSetWithReviewedFiles> o = accountPatchReviewStore.get().findReviewed(patchSetId.getId(), userId);
    if (o.isPresent()) {
        PatchSetWithReviewedFiles res = o.get();
        if (res.patchSetId().equals(patchSetId.getId())) {
            return res.files();
        }
        try {
            return copy(res.files(), res.patchSetId(), resource, userId);
        } catch (IOException | PatchListNotAvailableException e) {
            log.warn("Cannot copy patch review flags", e);
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
private static void doCreateTable(Statement stmt) throws SQLException {
    stmt.executeUpdate("CREATE TABLE IF NOT EXISTS ACCOUNT_PATCH_REVIEWS (" + "ACCOUNT_ID INTEGER DEFAULT 0 NOT NULL, " + "CHANGE_ID INTEGER DEFAULT 0 NOT NULL, " + "PATCH_SET_ID INTEGER DEFAULT 0 NOT NULL, " + "FILE_NAME VARCHAR(255) DEFAULT '' NOT NULL, " + "CONSTRAINT PRIMARY_KEY_ACCOUNT_PATCH_REVIEWS " + "PRIMARY KEY (ACCOUNT_ID, CHANGE_ID, PATCH_SET_ID, FILE_NAME)" + ")");
}
#method_after
private static void doCreateTable(Statement stmt) throws SQLException {
    stmt.executeUpdate("CREATE TABLE IF NOT EXISTS account_patch_reviews (" + "account_id INTEGER DEFAULT 0 NOT NULL, " + "change_id INTEGER DEFAULT 0 NOT NULL, " + "patch_set_id INTEGER DEFAULT 0 NOT NULL, " + "file_name VARCHAR(255) DEFAULT '' NOT NULL, " + "CONSTRAINT primary_key_account_patch_reviews " + "PRIMARY KEY (account_id, change_id, patch_set_id, file_name)" + ")");
}
#end_block

#method_before
public static void dropTableIfExists(String url) throws OrmException {
    try (Connection con = DriverManager.getConnection(url);
        Statement stmt = con.createStatement()) {
        stmt.executeUpdate("DROP TABLE IF EXISTS ACCOUNT_PATCH_REVIEWS");
    } catch (SQLException e) {
        throw convertError("create", e);
    }
}
#method_after
public static void dropTableIfExists(String url) throws OrmException {
    try (Connection con = DriverManager.getConnection(url);
        Statement stmt = con.createStatement()) {
        stmt.executeUpdate("DROP TABLE IF EXISTS account_patch_reviews");
    } catch (SQLException e) {
        throw convertError("create", e);
    }
}
#end_block

#method_before
@Override
public boolean markReviewed(PatchSet.Id psId, Account.Id accountId, String path) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("INSERT INTO ACCOUNT_PATCH_REVIEWS " + "(ACCOUNT_ID, CHANGE_ID, PATCH_SET_ID, FILE_NAME) VALUES " + "(?, ?, ?, ?)")) {
        stmt.setInt(1, accountId.get());
        stmt.setInt(2, psId.getParentKey().get());
        stmt.setInt(3, psId.get());
        stmt.setString(4, path);
        stmt.executeUpdate();
        return true;
    } catch (SQLException e) {
        OrmException ormException = convertError("insert", e);
        if (ormException instanceof OrmDuplicateKeyException) {
            return false;
        }
        throw ormException;
    }
}
#method_after
@Override
public boolean markReviewed(PatchSet.Id psId, Account.Id accountId, String path) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("INSERT INTO account_patch_reviews " + "(account_id, change_id, patch_set_id, file_name) VALUES " + "(?, ?, ?, ?)")) {
        stmt.setInt(1, accountId.get());
        stmt.setInt(2, psId.getParentKey().get());
        stmt.setInt(3, psId.get());
        stmt.setString(4, path);
        stmt.executeUpdate();
        return true;
    } catch (SQLException e) {
        OrmException ormException = convertError("insert", e);
        if (ormException instanceof OrmDuplicateKeyException) {
            return false;
        }
        throw ormException;
    }
}
#end_block

#method_before
@Override
public void markReviewed(PatchSet.Id psId, Account.Id accountId, Collection<String> paths) throws OrmException {
    if (paths == null || paths.isEmpty()) {
        return;
    }
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("INSERT INTO ACCOUNT_PATCH_REVIEWS " + "(ACCOUNT_ID, CHANGE_ID, PATCH_SET_ID, FILE_NAME) VALUES " + "(?, ?, ?, ?)")) {
        for (String path : paths) {
            stmt.setInt(1, accountId.get());
            stmt.setInt(2, psId.getParentKey().get());
            stmt.setInt(3, psId.get());
            stmt.setString(4, path);
            stmt.addBatch();
        }
        stmt.executeBatch();
    } catch (SQLException e) {
        OrmException ormException = convertError("insert", e);
        if (ormException instanceof OrmDuplicateKeyException) {
            return;
        }
        throw ormException;
    }
}
#method_after
@Override
public void markReviewed(PatchSet.Id psId, Account.Id accountId, Collection<String> paths) throws OrmException {
    if (paths == null || paths.isEmpty()) {
        return;
    }
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("INSERT INTO account_patch_reviews " + "(account_id, change_id, patch_set_id, file_name) VALUES " + "(?, ?, ?, ?)")) {
        for (String path : paths) {
            stmt.setInt(1, accountId.get());
            stmt.setInt(2, psId.getParentKey().get());
            stmt.setInt(3, psId.get());
            stmt.setString(4, path);
            stmt.addBatch();
        }
        stmt.executeBatch();
    } catch (SQLException e) {
        OrmException ormException = convertError("insert", e);
        if (ormException instanceof OrmDuplicateKeyException) {
            return;
        }
        throw ormException;
    }
}
#end_block

#method_before
@Override
public void clearReviewed(PatchSet.Id psId, Account.Id accountId, String path) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("DELETE FROM ACCOUNT_PATCH_REVIEWS " + "WHERE ACCOUNT_ID = ? AND CHANGE_ID + ? AND " + "PATCH_SET_ID = ? AND FILE_NAME = ?")) {
        stmt.setInt(1, accountId.get());
        stmt.setInt(2, psId.getParentKey().get());
        stmt.setInt(3, psId.get());
        stmt.setString(4, path);
        stmt.executeUpdate();
    } catch (SQLException e) {
        throw convertError("delete", e);
    }
}
#method_after
@Override
public void clearReviewed(PatchSet.Id psId, Account.Id accountId, String path) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("DELETE FROM account_patch_reviews " + "WHERE account_id = ? AND change_id = ? AND " + "patch_set_id = ? AND file_name = ?")) {
        stmt.setInt(1, accountId.get());
        stmt.setInt(2, psId.getParentKey().get());
        stmt.setInt(3, psId.get());
        stmt.setString(4, path);
        stmt.executeUpdate();
    } catch (SQLException e) {
        throw convertError("delete", e);
    }
}
#end_block

#method_before
@Override
public void clearReviewed(PatchSet.Id psId) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("DELETE FROM ACCOUNT_PATCH_REVIEWS " + "WHERE CHANGE_ID + ? AND PATCH_SET_ID = ?")) {
        stmt.setInt(1, psId.getParentKey().get());
        stmt.setInt(2, psId.get());
        stmt.executeUpdate();
    } catch (SQLException e) {
        throw convertError("delete", e);
    }
}
#method_after
@Override
public void clearReviewed(PatchSet.Id psId) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("DELETE FROM account_patch_reviews " + "WHERE change_id = ? AND patch_set_id = ?")) {
        stmt.setInt(1, psId.getParentKey().get());
        stmt.setInt(2, psId.get());
        stmt.executeUpdate();
    } catch (SQLException e) {
        throw convertError("delete", e);
    }
}
#end_block

#method_before
@Override
public Optional<PatchSetWithReviewedFiles> findReviewed(PatchSet.Id psId, Account.Id accountId) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("SELECT PATCH_SET_ID, FILE_NAME FROM ACCOUNT_PATCH_REVIEWS APR1 " + "WHERE ACCOUNT_ID = ? AND CHANGE_ID = ? AND PATCH_SET_ID = " + "(SELECT MAX(PATCH_SET_ID) FROM ACCOUNT_PATCH_REVIEWS APR2 WHERE " + "APR1.ACCOUNT_ID = APR2.ACCOUNT_ID " + "AND APR1.CHANGE_ID = APR2.CHANGE_ID " + "AND PATCH_SET_ID <= ?)")) {
        stmt.setInt(1, accountId.get());
        stmt.setInt(2, psId.getParentKey().get());
        stmt.setInt(3, psId.get());
        try (ResultSet rs = stmt.executeQuery()) {
            if (rs.next()) {
                PatchSetWithReviewedFiles r = new PatchSetWithReviewedFiles();
                r.files = new ArrayList<>();
                r.patchSetId = new PatchSet.Id(psId.getParentKey(), rs.getInt("PATCH_SET_ID"));
                do {
                    r.files.add(rs.getString("FILE_NAME"));
                } while (rs.next());
                return Optional.of(r);
            }
            return Optional.absent();
        }
    } catch (SQLException e) {
        throw convertError("select", e);
    }
}
#method_after
@Override
public Optional<PatchSetWithReviewedFiles> findReviewed(PatchSet.Id psId, Account.Id accountId) throws OrmException {
    try (Connection con = ds.getConnection();
        PreparedStatement stmt = con.prepareStatement("SELECT patch_set_id, file_name FROM account_patch_reviews APR1 " + "WHERE account_id = ? AND change_id = ? AND patch_set_id = " + "(SELECT MAX(patch_set_id) FROM account_patch_reviews APR2 WHERE " + "APR1.account_id = APR2.account_id " + "AND APR1.change_id = APR2.change_id " + "AND patch_set_id <= ?)")) {
        stmt.setInt(1, accountId.get());
        stmt.setInt(2, psId.getParentKey().get());
        stmt.setInt(3, psId.get());
        try (ResultSet rs = stmt.executeQuery()) {
            if (rs.next()) {
                PatchSet.Id id = new PatchSet.Id(psId.getParentKey(), rs.getInt("PATCH_SET_ID"));
                ImmutableSet.Builder<String> builder = ImmutableSet.builder();
                do {
                    builder.add(rs.getString("FILE_NAME"));
                } while (rs.next());
                return Optional.of(AccountPatchReviewStore.PatchSetWithReviewedFiles.create(id, builder.build()));
            }
            return Optional.absent();
        }
    } catch (SQLException e) {
        throw convertError("select", e);
    }
}
#end_block

#method_before
public static OrmException convertError(String op, SQLException err) {
    switch(getSQLStateInt(err)) {
        // UNIQUE CONSTRAINT VIOLATION
        case 23001:
        case // DUPLICATE_KEY_1
        23505:
            return new OrmDuplicateKeyException("ACCOUNT_PATCH_REVIEWS", err);
        default:
            if (err.getCause() == null && err.getNextException() != null) {
                err.initCause(err.getNextException());
            }
            return new OrmException(op + " failure on ACCOUNT_PATCH_REVIEWS", err);
    }
}
#method_after
public static OrmException convertError(String op, SQLException err) {
    switch(getSQLStateInt(err)) {
        // UNIQUE CONSTRAINT VIOLATION
        case 23001:
        case // DUPLICATE_KEY_1
        23505:
            return new OrmDuplicateKeyException("account_patch_reviews", err);
        default:
            if (err.getCause() == null && err.getNextException() != null) {
                err.initCause(err.getNextException());
            }
            return new OrmException(op + " failure on account_patch_reviews", err);
    }
}
#end_block

#method_before
private void doCorsPreflight(HttpServletRequest req, HttpServletResponse res) throws BadRequestException {
    CacheHeaders.setNotCacheable(res);
    res.setHeader(VARY, Joiner.on(", ").join(ImmutableList.of(ORIGIN, ACCESS_CONTROL_REQUEST_METHOD)));
    String origin = req.getHeader(ORIGIN);
    if (Strings.isNullOrEmpty(origin) || !isOriginAllowed(origin)) {
        throw new BadRequestException("CORS not allowed");
    }
    String headers = req.getHeader(ACCESS_CONTROL_REQUEST_HEADERS);
    if (headers != null) {
        res.addHeader(VARY, ACCESS_CONTROL_REQUEST_HEADERS);
        for (String reqHdr : Splitter.on(',').trimResults().split(headers)) {
            if (!isAllowedCorsRequestHeader(reqHdr)) {
                throw new BadRequestException(reqHdr + " not allowed in CORS");
            }
        }
    }
    res.setStatus(SC_OK);
    setCorsHeaders(res, origin);
    res.setContentType("text/plain");
    res.setContentLength(0);
}
#method_after
private void doCorsPreflight(HttpServletRequest req, HttpServletResponse res) throws BadRequestException {
    CacheHeaders.setNotCacheable(res);
    setHeaderList(res, VARY, ImmutableList.of(ORIGIN, ACCESS_CONTROL_REQUEST_METHOD, ACCESS_CONTROL_REQUEST_HEADERS));
    String origin = req.getHeader(ORIGIN);
    if (Strings.isNullOrEmpty(origin) || !isOriginAllowed(origin)) {
        throw new BadRequestException("CORS not allowed");
    }
    String method = req.getHeader(ACCESS_CONTROL_REQUEST_METHOD);
    if (!ALLOWED_CORS_METHODS.contains(method)) {
        throw new BadRequestException(method + " not allowed in CORS");
    }
    String headers = req.getHeader(ACCESS_CONTROL_REQUEST_HEADERS);
    if (headers != null) {
        res.addHeader(VARY, ACCESS_CONTROL_REQUEST_HEADERS);
        for (String reqHdr : Splitter.on(',').trimResults().split(headers)) {
            if (!ALLOWED_CORS_REQUEST_HEADERS.contains(reqHdr.toLowerCase(Locale.US))) {
                throw new BadRequestException(reqHdr + " not allowed in CORS");
            }
        }
    }
    res.setStatus(SC_OK);
    setCorsHeaders(res, origin);
    res.setContentType("text/plain");
    res.setContentLength(0);
}
#end_block

#method_before
private static void setCorsHeaders(HttpServletResponse res, String origin) {
    res.setHeader(ACCESS_CONTROL_ALLOW_ORIGIN, origin);
    res.setHeader(ACCESS_CONTROL_ALLOW_CREDENTIALS, "true");
    res.setHeader(ACCESS_CONTROL_MAX_AGE, "600");
    res.setHeader(ACCESS_CONTROL_ALLOW_METHODS, "GET, OPTIONS, PUT, DELETE, POST");
    res.setHeader(ACCESS_CONTROL_ALLOW_HEADERS, Joiner.on(", ").join(ALLOWED_CORS_REQUEST_HEADERS));
}
#method_after
private static void setCorsHeaders(HttpServletResponse res, String origin) {
    res.setHeader(ACCESS_CONTROL_ALLOW_ORIGIN, origin);
    res.setHeader(ACCESS_CONTROL_ALLOW_CREDENTIALS, "true");
    res.setHeader(ACCESS_CONTROL_MAX_AGE, "600");
    setHeaderList(res, ACCESS_CONTROL_ALLOW_METHODS, Iterables.concat(ALLOWED_CORS_METHODS, ImmutableList.of("OPTIONS")));
    setHeaderList(res, ACCESS_CONTROL_ALLOW_HEADERS, ALLOWED_CORS_REQUEST_HEADERS);
}
#end_block

#method_before
@Override
public List<ValidationMessage> onRefOperation(RefReceivedEvent refEvent) throws ValidationException {
    if (refEvent.project.getNameKey().equals(allUsersName) && (refEvent.command.getRefName().startsWith(RefNames.REFS_USERS) && !refEvent.command.getRefName().equals(RefNames.REFS_USERS_DEFAULT))) {
        if (refEvent.command.getType().equals(ReceiveCommand.Type.CREATE)) {
            if (!perm.testOrFalse(GlobalPermission.ACCESS_DATABASE)) {
                throw new ValidationException("Not allowed to create user branch.");
            }
            if (Account.Id.fromRef(refEvent.command.getRefName()) == null) {
                throw new ValidationException(String.format("Not allowed to create non-user branch under %s.", RefNames.REFS_USERS));
            }
        } else if (refEvent.command.getType().equals(ReceiveCommand.Type.DELETE)) {
            if (!perm.testOrFalse(GlobalPermission.ACCESS_DATABASE)) {
                throw new ValidationException("Not allowed to delete user branch.");
            }
        }
    }
    return ImmutableList.of();
}
#method_after
@Override
public List<ValidationMessage> onRefOperation(RefReceivedEvent refEvent) throws ValidationException {
    if (refEvent.project.getNameKey().equals(allUsersName) && (refEvent.command.getRefName().startsWith(RefNames.REFS_USERS) && !refEvent.command.getRefName().equals(RefNames.REFS_USERS_DEFAULT))) {
        if (refEvent.command.getType().equals(ReceiveCommand.Type.CREATE)) {
            try {
                perm.check(GlobalPermission.ACCESS_DATABASE);
            } catch (AuthException | PermissionBackendException e) {
                throw new ValidationException("Not allowed to create user branch.");
            }
            if (Account.Id.fromRef(refEvent.command.getRefName()) == null) {
                throw new ValidationException(String.format("Not allowed to create non-user branch under %s.", RefNames.REFS_USERS));
            }
        } else if (refEvent.command.getType().equals(ReceiveCommand.Type.DELETE)) {
            try {
                perm.check(GlobalPermission.ACCESS_DATABASE);
            } catch (AuthException | PermissionBackendException e) {
                throw new ValidationException("Not allowed to delete user branch.");
            }
        }
    }
    return ImmutableList.of();
}
#end_block

#method_before
@Test
public void getExternalIdsOfOtherUserNotAllowed() throws Exception {
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("not allowed to get external IDs");
    gApi.accounts().id(admin.id.get()).getExternalIds();
}
#method_after
@Test
public void getExternalIdsOfOtherUserNotAllowed() throws Exception {
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("access database not permitted");
    gApi.accounts().id(admin.id.get()).getExternalIds();
}
#end_block

#method_before
@Test
public void deleteExternalIdsOfOtherUserNotAllowed() throws Exception {
    List<AccountExternalIdInfo> extIds = gApi.accounts().self().getExternalIds();
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("not allowed to delete external IDs");
    gApi.accounts().id(admin.id.get()).deleteExternalIds(extIds.stream().map(e -> e.identity).collect(toList()));
}
#method_after
@Test
public void deleteExternalIdsOfOtherUserNotAllowed() throws Exception {
    List<AccountExternalIdInfo> extIds = gApi.accounts().self().getExternalIds();
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("access database not permitted");
    gApi.accounts().id(admin.id.get()).deleteExternalIds(extIds.stream().map(e -> e.identity).collect(toList()));
}
#end_block

#method_before
public Map<String, Ref> filter(Map<String, Ref> refs, boolean filterTagsSeparately) {
    if (projectState.isAllUsers()) {
        refs = addUsersSelfSymref(refs);
    }
    projectCtl = projectState.controlFor(user.get());
    if (projectCtl.allRefsAreVisible(ImmutableSet.of(REFS_CONFIG))) {
        return fastHideRefsMetaConfig(refs);
    }
    Account.Id userId;
    boolean viewMetadata;
    if (user.get().isIdentifiedUser()) {
        try {
            permissionBackend.user(user).check(GlobalPermission.ACCESS_DATABASE);
            viewMetadata = true;
        } catch (AuthException | PermissionBackendException no) {
            viewMetadata = false;
        }
        IdentifiedUser u = user.get().asIdentifiedUser();
        userId = u.getAccountId();
        userEditPrefix = RefNames.refsEditPrefix(userId);
    } else {
        userId = null;
        viewMetadata = false;
    }
    Map<String, Ref> result = new HashMap<>();
    List<Ref> deferredTags = new ArrayList<>();
    for (Ref ref : refs.values()) {
        String name = ref.getName();
        Change.Id changeId;
        Account.Id accountId;
        if (name.startsWith(REFS_CACHE_AUTOMERGE) || (!showMetadata && isMetadata(name))) {
            continue;
        } else if (RefNames.isRefsEdit(name)) {
            // Edits are visible only to the owning user, if change is visible.
            if (viewMetadata || visibleEdit(name)) {
                result.put(name, ref);
            }
        } else if ((changeId = Change.Id.fromRef(name)) != null) {
            // Change ref is visible only if the change is visible.
            if (viewMetadata || visible(changeId)) {
                result.put(name, ref);
            }
        } else if ((accountId = Account.Id.fromRef(name)) != null) {
            // Account ref is visible only to corresponding account.
            if (viewMetadata || (accountId.equals(userId) && projectCtl.controlForRef(name).isVisible())) {
                result.put(name, ref);
            }
        } else if (isTag(ref)) {
            // If its a tag, consider it later.
            if (ref.getObjectId() != null) {
                deferredTags.add(ref);
            }
        } else if (name.startsWith(RefNames.REFS_SEQUENCES)) {
            // Sequences are internal database implementation details.
            if (viewMetadata) {
                result.put(name, ref);
            }
        } else if (projectState.isAllUsers() && name.equals(RefNames.REFS_EXTERNAL_IDS)) {
            // The notes branch with the external IDs of all users must not be exposed to normal users.
            if (viewMetadata) {
                result.put(name, ref);
            }
        } else if (projectCtl.controlForRef(ref.getLeaf().getName()).isVisible()) {
            // Use the leaf to lookup the control data. If the reference is
            // symbolic we want the control around the final target. If its
            // not symbolic then getLeaf() is a no-op returning ref itself.
            result.put(name, ref);
        }
    }
    // 
    if (!deferredTags.isEmpty() && (!result.isEmpty() || filterTagsSeparately)) {
        TagMatcher tags = tagCache.get(projectState.getProject().getNameKey()).matcher(tagCache, git, filterTagsSeparately ? filter(git.getAllRefs()).values() : result.values());
        for (Ref tag : deferredTags) {
            if (tags.isReachable(tag)) {
                result.put(tag.getName(), tag);
            }
        }
    }
    return result;
}
#method_after
public Map<String, Ref> filter(Map<String, Ref> refs, boolean filterTagsSeparately) {
    if (projectState.isAllUsers()) {
        refs = addUsersSelfSymref(refs);
    }
    projectCtl = projectState.controlFor(user.get());
    if (projectCtl.allRefsAreVisible(ImmutableSet.of(REFS_CONFIG))) {
        return fastHideRefsMetaConfig(refs);
    }
    Account.Id userId;
    boolean viewMetadata;
    if (user.get().isIdentifiedUser()) {
        viewMetadata = permissionBackend.user(user).testOrFalse(GlobalPermission.ACCESS_DATABASE);
        IdentifiedUser u = user.get().asIdentifiedUser();
        userId = u.getAccountId();
        userEditPrefix = RefNames.refsEditPrefix(userId);
    } else {
        userId = null;
        viewMetadata = false;
    }
    Map<String, Ref> result = new HashMap<>();
    List<Ref> deferredTags = new ArrayList<>();
    for (Ref ref : refs.values()) {
        String name = ref.getName();
        Change.Id changeId;
        Account.Id accountId;
        if (name.startsWith(REFS_CACHE_AUTOMERGE) || (!showMetadata && isMetadata(name))) {
            continue;
        } else if (RefNames.isRefsEdit(name)) {
            // Edits are visible only to the owning user, if change is visible.
            if (viewMetadata || visibleEdit(name)) {
                result.put(name, ref);
            }
        } else if ((changeId = Change.Id.fromRef(name)) != null) {
            // Change ref is visible only if the change is visible.
            if (viewMetadata || visible(changeId)) {
                result.put(name, ref);
            }
        } else if ((accountId = Account.Id.fromRef(name)) != null) {
            // Account ref is visible only to corresponding account.
            if (viewMetadata || (accountId.equals(userId) && projectCtl.controlForRef(name).isVisible())) {
                result.put(name, ref);
            }
        } else if (isTag(ref)) {
            // If its a tag, consider it later.
            if (ref.getObjectId() != null) {
                deferredTags.add(ref);
            }
        } else if (name.startsWith(RefNames.REFS_SEQUENCES)) {
            // Sequences are internal database implementation details.
            if (viewMetadata) {
                result.put(name, ref);
            }
        } else if (projectState.isAllUsers() && name.equals(RefNames.REFS_EXTERNAL_IDS)) {
            // The notes branch with the external IDs of all users must not be exposed to normal users.
            if (viewMetadata) {
                result.put(name, ref);
            }
        } else if (projectCtl.controlForRef(ref.getLeaf().getName()).isVisible()) {
            // Use the leaf to lookup the control data. If the reference is
            // symbolic we want the control around the final target. If its
            // not symbolic then getLeaf() is a no-op returning ref itself.
            result.put(name, ref);
        }
    }
    // 
    if (!deferredTags.isEmpty() && (!result.isEmpty() || filterTagsSeparately)) {
        TagMatcher tags = tagCache.get(projectState.getProject().getNameKey()).matcher(tagCache, git, filterTagsSeparately ? filter(git.getAllRefs()).values() : result.values());
        for (Ref tag : deferredTags) {
            if (tags.isReachable(tag)) {
                result.put(tag.getName(), tag);
            }
        }
    }
    return result;
}
#end_block

#method_before
@Override
public Response<?> apply(AccountResource resource, List<String> extIds) throws RestApiException, IOException, OrmException, ConfigInvalidException {
    if (self.get() != resource.getUser() && !permissionBackend.user(self).testOrFalse(GlobalPermission.ACCESS_DATABASE)) {
        throw new AuthException("not allowed to delete external IDs");
    }
    if (extIds == null || extIds.size() == 0) {
        throw new BadRequestException("external IDs are required");
    }
    Map<ExternalId.Key, ExternalId> externalIdMap = externalIds.byAccount(resource.getUser().getAccountId()).stream().collect(toMap(i -> i.key(), i -> i));
    List<ExternalId> toDelete = new ArrayList<>();
    ExternalId.Key last = resource.getUser().getLastLoginExternalIdKey();
    for (String externalIdStr : extIds) {
        ExternalId id = externalIdMap.get(ExternalId.Key.parse(externalIdStr));
        if (id == null) {
            throw new UnprocessableEntityException(String.format("External id %s does not exist", externalIdStr));
        }
        if ((!id.isScheme(SCHEME_USERNAME)) && ((last == null) || (!last.get().equals(id.key().get())))) {
            toDelete.add(id);
        } else {
            throw new ResourceConflictException(String.format("External id %s cannot be deleted", externalIdStr));
        }
    }
    try {
        for (ExternalId extId : toDelete) {
            AuthRequest authRequest = new AuthRequest(extId.key());
            authRequest.setEmailAddress(extId.email());
            accountManager.unlink(extId.accountId(), authRequest);
        }
    } catch (AccountException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(AccountResource resource, List<String> extIds) throws RestApiException, IOException, OrmException, ConfigInvalidException, PermissionBackendException {
    if (self.get() != resource.getUser()) {
        permissionBackend.user(self).check(GlobalPermission.ACCESS_DATABASE);
    }
    if (extIds == null || extIds.size() == 0) {
        throw new BadRequestException("external IDs are required");
    }
    Map<ExternalId.Key, ExternalId> externalIdMap = externalIds.byAccount(resource.getUser().getAccountId()).stream().collect(toMap(i -> i.key(), i -> i));
    List<ExternalId> toDelete = new ArrayList<>();
    ExternalId.Key last = resource.getUser().getLastLoginExternalIdKey();
    for (String externalIdStr : extIds) {
        ExternalId id = externalIdMap.get(ExternalId.Key.parse(externalIdStr));
        if (id == null) {
            throw new UnprocessableEntityException(String.format("External id %s does not exist", externalIdStr));
        }
        if ((!id.isScheme(SCHEME_USERNAME)) && ((last == null) || (!last.get().equals(id.key().get())))) {
            toDelete.add(id);
        } else {
            throw new ResourceConflictException(String.format("External id %s cannot be deleted", externalIdStr));
        }
    }
    try {
        for (ExternalId extId : toDelete) {
            AuthRequest authRequest = new AuthRequest(extId.key());
            authRequest.setEmailAddress(extId.email());
            accountManager.unlink(extId.accountId(), authRequest);
        }
    } catch (AccountException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public List<AccountExternalIdInfo> apply(AccountResource resource) throws RestApiException, IOException, OrmException {
    if (self.get() != resource.getUser() && !permissionBackend.user(self).testOrFalse(GlobalPermission.ACCESS_DATABASE)) {
        throw new AuthException("not allowed to get external IDs");
    }
    Collection<ExternalId> ids = externalIds.byAccount(resource.getUser().getAccountId());
    if (ids.isEmpty()) {
        return ImmutableList.of();
    }
    List<AccountExternalIdInfo> result = Lists.newArrayListWithCapacity(ids.size());
    for (ExternalId id : ids) {
        AccountExternalIdInfo info = new AccountExternalIdInfo();
        info.identity = id.key().get();
        info.emailAddress = id.email();
        info.trusted = toBoolean(authConfig.isIdentityTrustable(Collections.singleton(id)));
        // actually used to establish this web session.
        if (!id.isScheme(SCHEME_USERNAME)) {
            ExternalId.Key last = resource.getUser().getLastLoginExternalIdKey();
            info.canDelete = toBoolean(last == null || !last.get().equals(info.identity));
        }
        result.add(info);
    }
    return result;
}
#method_after
@Override
public List<AccountExternalIdInfo> apply(AccountResource resource) throws RestApiException, IOException, OrmException, PermissionBackendException {
    if (self.get() != resource.getUser()) {
        permissionBackend.user(self).check(GlobalPermission.ACCESS_DATABASE);
    }
    Collection<ExternalId> ids = externalIds.byAccount(resource.getUser().getAccountId());
    if (ids.isEmpty()) {
        return ImmutableList.of();
    }
    List<AccountExternalIdInfo> result = Lists.newArrayListWithCapacity(ids.size());
    for (ExternalId id : ids) {
        AccountExternalIdInfo info = new AccountExternalIdInfo();
        info.identity = id.key().get();
        info.emailAddress = id.email();
        info.trusted = toBoolean(authConfig.isIdentityTrustable(Collections.singleton(id)));
        // actually used to establish this web session.
        if (!id.isScheme(SCHEME_USERNAME)) {
            ExternalId.Key last = resource.getUser().getLastLoginExternalIdKey();
            info.canDelete = toBoolean(last == null || !last.get().equals(info.identity));
        }
        result.add(info);
    }
    return result;
}
#end_block

#method_before
@Override
public Response<?> apply(TagResource rsrc, Input input) throws AuthException, ResourceConflictException, OrmException, IOException {
    /* if (!rsrc.getControl().controlForRef(rsrc.getTagKey()).canDelete()) {
      throw new AuthException("Cannot delete tag");
    } */
    try (Repository r = repoManager.openRepository(rsrc.getNameKey())) {
        RefUpdate.Result result;
        RefUpdate u = r.updateRef(rsrc.getRef());
        u.setForceUpdate(true);
        refDeletionValidator.validateRefOperation(rsrc.getName(), identifiedUser.get(), u);
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        for (; ; ) {
            try {
                result = u.delete();
            } catch (LockFailedException e) {
                result = RefUpdate.Result.LOCK_FAILURE;
            } catch (IOException e) {
                log.error("Cannot delete " + rsrc.getTagKey(), e);
                throw e;
            }
            if (result == RefUpdate.Result.LOCK_FAILURE && --remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException ie) {
                // ignore
                }
            } else {
                break;
            }
        }
        switch(result) {
            case NEW:
            case NO_CHANGE:
            case FAST_FORWARD:
            case FORCED:
                referenceUpdated.fire(rsrc.getNameKey(), u, ReceiveCommand.Type.DELETE, identifiedUser.get().getAccount());
                break;
            case REJECTED_CURRENT_BRANCH:
                log.error("Cannot delete " + rsrc.getTagKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete current tag");
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case REJECTED:
            case RENAMED:
            default:
                log.error("Cannot delete " + rsrc.getTagKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete tag: " + result.name());
        }
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(TagResource resource, Input input) throws OrmException, RestApiException, IOException {
    String tag = RefUtil.normalizeTagRef(resource.getTagInfo().ref);
    RefControl refControl = resource.getControl().controlForRef(tag);
    if (!refControl.canDelete()) {
        throw new AuthException("Cannot delete tag");
    }
    deleteRefFactory.create(resource).ref(tag).delete();
    return Response.none();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), COMMIT_KIND);
    DynamicMap.mapOf(binder(), TAG_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "access").to(GetAccess.class);
    post(PROJECT_KIND, "access").to(SetAccess.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    put(PROJECT_KIND, "ban").to(BanCommit.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    put(BRANCH_KIND).to(PutBranch.class);
    get(BRANCH_KIND).to(GetBranch.class);
    delete(BRANCH_KIND).to(DeleteBranch.class);
    post(PROJECT_KIND, "branches:delete").to(DeleteBranches.class);
    factory(CreateBranch.Factory.class);
    get(BRANCH_KIND, "mergeable").to(CheckMergeability.class);
    factory(RefValidationHelper.Factory.class);
    get(BRANCH_KIND, "reflog").to(GetReflog.class);
    child(BRANCH_KIND, "files").to(FilesCollection.class);
    get(FILE_KIND, "content").to(GetContent.class);
    child(PROJECT_KIND, "commits").to(CommitsCollection.class);
    get(COMMIT_KIND).to(GetCommit.class);
    child(COMMIT_KIND, "files").to(FilesInCommitCollection.class);
    child(PROJECT_KIND, "tags").to(TagsCollection.class);
    get(TAG_KIND).to(GetTag.class);
    put(TAG_KIND).to(PutTag.class);
    delete(TAG_KIND).to(DeleteTag.class);
    post(PROJECT_KIND, "tags:delete").to(DeleteTags.class);
    factory(CreateTag.Factory.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    factory(CreateProject.Factory.class);
    get(PROJECT_KIND, "config").to(GetConfig.class);
    put(PROJECT_KIND, "config").to(PutConfig.class);
}
#method_after
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), COMMIT_KIND);
    DynamicMap.mapOf(binder(), TAG_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "access").to(GetAccess.class);
    post(PROJECT_KIND, "access").to(SetAccess.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    put(PROJECT_KIND, "ban").to(BanCommit.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    put(BRANCH_KIND).to(PutBranch.class);
    get(BRANCH_KIND).to(GetBranch.class);
    delete(BRANCH_KIND).to(DeleteBranch.class);
    post(PROJECT_KIND, "branches:delete").to(DeleteBranches.class);
    factory(CreateBranch.Factory.class);
    get(BRANCH_KIND, "mergeable").to(CheckMergeability.class);
    factory(RefValidationHelper.Factory.class);
    get(BRANCH_KIND, "reflog").to(GetReflog.class);
    child(BRANCH_KIND, "files").to(FilesCollection.class);
    get(FILE_KIND, "content").to(GetContent.class);
    child(PROJECT_KIND, "commits").to(CommitsCollection.class);
    get(COMMIT_KIND).to(GetCommit.class);
    child(COMMIT_KIND, "files").to(FilesInCommitCollection.class);
    child(PROJECT_KIND, "tags").to(TagsCollection.class);
    get(TAG_KIND).to(GetTag.class);
    put(TAG_KIND).to(PutTag.class);
    delete(TAG_KIND).to(DeleteTag.class);
    factory(CreateTag.Factory.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    factory(CreateProject.Factory.class);
    get(PROJECT_KIND, "config").to(GetConfig.class);
    put(PROJECT_KIND, "config").to(PutConfig.class);
    factory(DeleteRef.Factory.class);
}
#end_block

#method_before
@Test
public void deleteVoteNotifyAccount() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    DeleteVoteInput in = new DeleteVoteInput();
    in.label = "Code-Review";
    in.notify = NotifyHandling.NONE;
    // notify unrelated account as TO
    TestAccount user2 = accounts.user2();
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.TO, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyTo(user2);
    // notify unrelated account as CC
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.CC, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyCc(user2);
    // notify unrelated account as BCC
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.BCC, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyBcc(user2);
}
#method_after
@Test
public void deleteVoteNotifyAccount() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    DeleteVoteInput in = new DeleteVoteInput();
    in.label = "Code-Review";
    in.notify = NotifyHandling.NONE;
    // notify unrelated account as TO
    TestAccount user2 = accountCreator.user2();
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.TO, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyTo(user2);
    // notify unrelated account as CC
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.CC, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyCc(user2);
    // notify unrelated account as BCC
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.BCC, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyBcc(user2);
}
#end_block

#method_before
public static Id parse(final String str) {
    final Id r = new Id();
    r.fromString(str);
    return r;
}
#method_after
public static Id parse(String str) {
    final Id r = new Id();
    r.fromString(str);
    return r;
}
#end_block

#method_before
public static Key parse(final String str) {
    final Key r = new Key();
    r.fromString(str);
    return r;
}
#method_after
public static Key parse(String str) {
    final Key r = new Key();
    r.fromString(str);
    return r;
}
#end_block

#method_before
public void setKey(final Change.Key k) {
    changeKey = k;
}
#method_after
public void setKey(Change.Key k) {
    changeKey = k;
}
#end_block

#method_before
public void setCurrentPatchSet(final PatchSetInfo ps) {
    if (originalSubject == null && subject != null) {
        // Change was created before schema upgrade. Use the last subject
        // associated with this change, as the most recent discussion will
        // be under that thread in an email client such as GMail.
        originalSubject = subject;
    }
    currentPatchSetId = ps.getKey().get();
    subject = ps.getSubject();
    if (originalSubject == null) {
        // Newly created changes remember the first commit's subject.
        originalSubject = subject;
    }
}
#method_after
public void setCurrentPatchSet(PatchSetInfo ps) {
    if (originalSubject == null && subject != null) {
        // Change was created before schema upgrade. Use the last subject
        // associated with this change, as the most recent discussion will
        // be under that thread in an email client such as GMail.
        originalSubject = subject;
    }
    currentPatchSetId = ps.getKey().get();
    subject = ps.getSubject();
    if (originalSubject == null) {
        // Newly created changes remember the first commit's subject.
        originalSubject = subject;
    }
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException, PermissionBackendException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    PermissionBackend.ForChange perm = permissionBackend.user(user).database(db).change(cd);
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate() ? true : null;
    out.workInProgress = in.isWorkInProgress() ? true : null;
    out.hasReviewStarted = in.hasReviewStarted();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        out.muted = stars.contains(StarredChangesUtil.MUTE_LABEL + "/" + cd.currentPatchSet().getPatchSetId()) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        if (out.muted != null) {
            out.reviewed = true;
        } else {
            out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
        }
    }
    out.labels = labelsFor(perm, ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    out.plugins = pluginDefinedAttributesFactory != null ? pluginDefinedAttributesFactory.create(cd) : null;
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (user.isIdentifiedUser() && (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId()))) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(perm, cd) : ImmutableMap.of();
        }
        out.reviewers = new HashMap<>();
        for (ReviewerStateInternal state : ReviewerStateInternal.values()) {
            if (state == ReviewerStateInternal.REMOVED) {
                continue;
            }
            Collection<AccountInfo> reviewers = toAccountInfo(cd.reviewers().byState(state));
            reviewers.addAll(toAccountInfoByEmail(cd.reviewersByEmail().byState(state)));
            if (!reviewers.isEmpty()) {
                out.reviewers.put(state.asReviewerState(), reviewers);
            }
        }
        out.removableReviewers = removableReviewers(ctl, out);
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException, PermissionBackendException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    PermissionBackend.ForChange perm = permissionBackend.user(user).database(db).change(cd);
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate() ? true : null;
    out.workInProgress = in.isWorkInProgress() ? true : null;
    out.hasReviewStarted = in.hasReviewStarted();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        out.muted = stars.contains(StarredChangesUtil.MUTE_LABEL + "/" + cd.currentPatchSet().getPatchSetId()) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        if (out.muted != null) {
            out.reviewed = true;
        } else {
            out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
        }
    }
    out.labels = labelsFor(perm, ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    out.plugins = pluginDefinedAttributesFactory != null ? pluginDefinedAttributesFactory.create(cd) : null;
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (user.isIdentifiedUser() && (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId()))) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(perm, cd) : ImmutableMap.of();
        }
        out.reviewers = reviewerMap(cd.reviewers(), cd.reviewersByEmail(), false);
        out.pendingReviewers = reviewerMap(cd.pendingReviewers(), cd.pendingReviewersByEmail(), true);
        out.removableReviewers = removableReviewers(ctl, out);
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), ctx.getRevWalk().parseCommit(commitId), psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setChangeId(change.getKey().get());
    update.setSubjectForCommit("Create change");
    update.setBranch(change.getDest().get());
    update.setTopic(change.getTopic());
    update.setPsDescription(patchSetDescription);
    update.setPrivate(isPrivate);
    update.setWorkInProgress(workInProgress);
    boolean draft = status == Change.Status.DRAFT;
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        newGroups = GroupCollector.getDefaultGroups(commitId);
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commitId, draft, newGroups, pushCert, patchSetDescription);
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, filterOnChangeVisibility(db, ctx.getNotes(), reviewers), Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovalsForNewPatchSet(db, update, labelTypes, patchSet, ctx.getControl(), approvals);
    // reviewer which is needed in several other code paths.
    if (!approvals.isEmpty()) {
        update.putReviewer(ctx.getAccountId(), REVIEWER);
    }
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(patchSet.getId(), ctx.getUser(), patchSet.getCreatedOn(), message, ChangeMessagesUtil.uploadedPatchSetTag(workInProgress));
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), ctx.getRevWalk().parseCommit(commitId), psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setChangeId(change.getKey().get());
    update.setSubjectForCommit("Create change");
    update.setBranch(change.getDest().get());
    update.setTopic(change.getTopic());
    update.setPsDescription(patchSetDescription);
    update.setPrivate(isPrivate);
    update.setWorkInProgress(workInProgress);
    boolean draft = status == Change.Status.DRAFT;
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        newGroups = GroupCollector.getDefaultGroups(commitId);
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commitId, draft, newGroups, pushCert, patchSetDescription);
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    Set<Account.Id> reviewersToAdd = new HashSet<>(reviewers);
    if (migration.readChanges()) {
        approvalsUtil.addCcs(ctx.getNotes(), update, filterOnChangeVisibility(db, ctx.getNotes(), extraCC));
    } else {
        reviewersToAdd.addAll(extraCC);
    }
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, filterOnChangeVisibility(db, ctx.getNotes(), reviewersToAdd), Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovalsForNewPatchSet(db, update, labelTypes, patchSet, ctx.getControl(), approvals);
    // reviewer which is needed in several other code paths.
    if (!approvals.isEmpty()) {
        update.putReviewer(ctx.getAccountId(), REVIEWER);
    }
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(patchSet.getId(), ctx.getUser(), patchSet.getCreatedOn(), message, ChangeMessagesUtil.uploadedPatchSetTag(workInProgress));
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
private Set<Account.Id> filterOnChangeVisibility(final ReviewDb db, final ChangeNotes notes, Set<Account.Id> accounts) {
    return accounts.stream().filter(accountId -> {
        try {
            IdentifiedUser user = userFactory.create(accountId);
            return changeControlFactory.controlFor(notes, user).isVisible(db);
        } catch (OrmException e) {
            log.warn(String.format("Failed to check if account %d can see change %d", accountId.get(), notes.getChangeId().get()), e);
            return false;
        }
    }).collect(toSet());
}
#method_after
private Set<Account.Id> filterOnChangeVisibility(final ReviewDb db, ChangeNotes notes, Set<Account.Id> accounts) {
    return accounts.stream().filter(accountId -> {
        try {
            IdentifiedUser user = userFactory.create(accountId);
            return changeControlFactory.controlFor(notes, user).isVisible(db);
        } catch (OrmException e) {
            log.warn(String.format("Failed to check if account %d can see change %d", accountId.get(), notes.getChangeId().get()), e);
            return false;
        }
    }).collect(toSet());
}
#end_block

#method_before
private void validate(RepoContext ctx) throws IOException, ResourceConflictException {
    if (!validate) {
        return;
    }
    try {
        RefControl refControl = projectControlFactory.controlFor(ctx.getProject(), ctx.getUser()).controlForRef(refName);
        try (CommitReceivedEvent event = new CommitReceivedEvent(cmd, refControl.getProjectControl().getProject(), change.getDest().get(), ctx.getRevWalk().getObjectReader(), commitId, ctx.getIdentifiedUser())) {
            commitValidatorsFactory.forGerritCommits(refControl, new NoSshInfo(), ctx.getRevWalk()).validate(event);
        }
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    } catch (NoSuchProjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
private void validate(RepoContext ctx) throws IOException, ResourceConflictException {
    if (!validate) {
        return;
    }
    PermissionBackend.ForRef perm = permissionBackend.user(ctx.getUser()).project(ctx.getProject()).ref(refName);
    try {
        RefControl refControl = projectControlFactory.controlFor(ctx.getProject(), ctx.getUser()).controlForRef(refName);
        try (CommitReceivedEvent event = new CommitReceivedEvent(cmd, refControl.getProjectControl().getProject(), change.getDest().get(), ctx.getRevWalk().getObjectReader(), commitId, ctx.getIdentifiedUser())) {
            commitValidatorsFactory.forGerritCommits(perm, refControl, new NoSshInfo(), ctx.getRevWalk()).validate(event);
        }
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    } catch (NoSuchProjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws Exception {
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        // TODO(dborowitz): Merge email templates so we only have to send one.
        Runnable e = new ReplaceEmailTask(ctx);
        if (requestScopePropagator != null) {
            @SuppressWarnings("unused")
            Future<?> possiblyIgnoredError = sendEmailExecutor.submit(requestScopePropagator.wrap(e));
        } else {
            e.run();
        }
    }
    NotifyHandling notify = magicBranch != null ? magicBranch.getNotify(notes) : NotifyHandling.ALL;
    if (shouldPublishComments()) {
        emailCommentsFactory.create(notify, magicBranch != null ? magicBranch.getAccountsToNotify() : ImmutableListMultimap.of(), notes, newPatchSet, ctx.getUser().asIdentifiedUser(), msg, comments, msg.getMessage(), // TODO(dborowitz): Include labels.
        ImmutableList.of()).sendAsync();
    }
    revisionCreated.fire(notes.getChange(), newPatchSet, ctx.getAccount(), ctx.getWhen(), notify);
    try {
        fireCommentAddedEvent(ctx);
    } catch (Exception e) {
        log.warn("comment-added event invocation failed", e);
    }
    if (mergedByPushOp != null) {
        mergedByPushOp.postUpdate(ctx);
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws Exception {
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        // TODO(dborowitz): Merge email templates so we only have to send one.
        Runnable e = new ReplaceEmailTask(ctx);
        if (requestScopePropagator != null) {
            @SuppressWarnings("unused")
            Future<?> possiblyIgnoredError = sendEmailExecutor.submit(requestScopePropagator.wrap(e));
        } else {
            e.run();
        }
    }
    NotifyHandling notify = magicBranch != null && magicBranch.notify != null ? magicBranch.notify : NotifyHandling.ALL;
    if (shouldPublishComments()) {
        emailCommentsFactory.create(notify, magicBranch != null ? magicBranch.getAccountsToNotify() : ImmutableListMultimap.of(), notes, newPatchSet, ctx.getUser().asIdentifiedUser(), msg, comments, msg.getMessage(), // TODO(dborowitz): Include labels.
        ImmutableList.of()).sendAsync();
    }
    revisionCreated.fire(notes.getChange(), newPatchSet, ctx.getAccount(), ctx.getWhen(), notify);
    try {
        fireCommentAddedEvent(ctx);
    } catch (Exception e) {
        log.warn("comment-added event invocation failed", e);
    }
    if (mergedByPushOp != null) {
        mergedByPushOp.postUpdate(ctx);
    }
}
#end_block

#method_before
@Override
public void run() {
    try {
        ReplacePatchSetSender cm = replacePatchSetFactory.create(projectControl.getProject().getNameKey(), notes.getChangeId());
        cm.setFrom(ctx.getAccount().getId());
        cm.setPatchSet(newPatchSet, info);
        cm.setChangeMessage(msg.getMessage(), ctx.getWhen());
        if (magicBranch != null) {
            cm.setNotify(magicBranch.getNotify(notes));
            cm.setAccountsToNotify(magicBranch.getAccountsToNotify());
        }
        cm.addReviewers(recipients.getReviewers());
        cm.addExtraCC(recipients.getCcOnly());
        cm.send();
    } catch (Exception e) {
        log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
    }
}
#method_after
@Override
public void run() {
    try {
        ReplacePatchSetSender cm = replacePatchSetFactory.create(projectControl.getProject().getNameKey(), notes.getChangeId());
        cm.setFrom(ctx.getAccount().getId());
        cm.setPatchSet(newPatchSet, info);
        cm.setChangeMessage(msg.getMessage(), ctx.getWhen());
        if (magicBranch != null) {
            cm.setNotify(magicBranch.notify);
            cm.setAccountsToNotify(magicBranch.getAccountsToNotify());
        }
        cm.addReviewers(recipients.getReviewers());
        cm.addExtraCC(recipients.getCcOnly());
        cm.send();
    } catch (Exception e) {
        log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
    }
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.STARTED)) {
            return Predicate.and(new BooleanPredicate(ChangeField.STARTED, args.fillArgs), ReviewerPredicate.reviewer(args, self()));
        }
        if (args.getSchema().hasField(ChangeField.WIP)) {
            return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP, args.fillArgs)), ReviewerPredicate.reviewer(args, self()));
        }
        return ReviewerPredicate.reviewer(args, self());
    }
    if ("cc".equalsIgnoreCase(value)) {
        return ReviewerPredicate.cc(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.MERGEABLE, args.fillArgs);
    }
    if ("private".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.PRIVATE)) {
            return new BooleanPredicate(ChangeField.PRIVATE, args.fillArgs);
        }
        throw new QueryParseException("'is:private' operator is not supported by change index version");
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    if ("submittable".equalsIgnoreCase(value)) {
        return new SubmittablePredicate(SubmitRecord.Status.OK);
    }
    if ("ignored".equalsIgnoreCase(value)) {
        return star("ignore");
    }
    if ("started".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.STARTED)) {
            return new BooleanPredicate(ChangeField.STARTED, args.fillArgs);
        }
        throw new QueryParseException("'is:started' operator is not supported by change index version");
    }
    if ("wip".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.WIP)) {
            return new BooleanPredicate(ChangeField.WIP, args.fillArgs);
        }
        throw new QueryParseException("'is:wip' operator is not supported by change index version");
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.WIP)) {
            return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP, args.fillArgs)), ReviewerPredicate.reviewer(args, self()));
        }
        return ReviewerPredicate.reviewer(args, self());
    }
    if ("cc".equalsIgnoreCase(value)) {
        return ReviewerPredicate.cc(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.MERGEABLE, args.fillArgs);
    }
    if ("private".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.PRIVATE)) {
            return new BooleanPredicate(ChangeField.PRIVATE, args.fillArgs);
        }
        throw new QueryParseException("'is:private' operator is not supported by change index version");
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    if ("submittable".equalsIgnoreCase(value)) {
        return new SubmittablePredicate(SubmitRecord.Status.OK);
    }
    if ("ignored".equalsIgnoreCase(value)) {
        return star("ignore");
    }
    if ("started".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.STARTED)) {
            return new BooleanPredicate(ChangeField.STARTED, args.fillArgs);
        }
        throw new QueryParseException("'is:started' operator is not supported by change index version");
    }
    if ("wip".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.WIP)) {
            return new BooleanPredicate(ChangeField.WIP, args.fillArgs);
        }
        throw new QueryParseException("'is:wip' operator is not supported by change index version");
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#end_block

#method_before
private Predicate<ChangeData> reviewer(String who, boolean forDefaultField) throws QueryParseException, OrmException {
    Predicate<ChangeData> byState = reviewerByState(who, ReviewerStateInternal.REVIEWER, forDefaultField);
    if (Objects.equals(byState, Predicate.<ChangeData>any())) {
        return Predicate.any();
    }
    if (args.getSchema().hasField(ChangeField.STARTED)) {
        return Predicate.and(new BooleanPredicate(ChangeField.STARTED, args.fillArgs), byState);
    }
    if (args.getSchema().hasField(ChangeField.WIP)) {
        return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP, args.fillArgs)), byState);
    }
    return byState;
}
#method_after
private Predicate<ChangeData> reviewer(String who, boolean forDefaultField) throws QueryParseException, OrmException {
    Predicate<ChangeData> byState = reviewerByState(who, ReviewerStateInternal.REVIEWER, forDefaultField);
    if (Objects.equals(byState, Predicate.<ChangeData>any())) {
        return Predicate.any();
    }
    if (args.getSchema().hasField(ChangeField.WIP)) {
        return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP, args.fillArgs)), byState);
    }
    return byState;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException {
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    change.setWorkInProgress(workInProgress);
    if (!workInProgress) {
        change.setReviewStarted(true);
    }
    change.setLastUpdatedOn(ctx.getWhen());
    update.setWorkInProgress(workInProgress);
    addMessage(ctx, update);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException {
    Change change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    change.setWorkInProgress(workInProgress);
    if (!change.hasReviewStarted() && !workInProgress) {
        change.setReviewStarted(true);
    }
    change.setLastUpdatedOn(ctx.getWhen());
    update.setWorkInProgress(workInProgress);
    addMessage(ctx, update);
    return true;
}
#end_block

#method_before
private void addMessage(ChangeContext ctx, ChangeUpdate update) throws OrmException {
    Change c = ctx.getChange();
    StringBuilder buf = new StringBuilder(c.isWorkInProgress() ? "Set Work In Progress" : "Set Ready For Review");
    String m = Strings.nullToEmpty(in == null ? null : in.message).trim();
    if (!m.isEmpty()) {
        buf.append("\n\n");
        buf.append(m);
    }
    cmsg = ChangeMessagesUtil.newMessage(ctx, buf.toString(), c.isWorkInProgress() ? ChangeMessagesUtil.TAG_SET_WIP : ChangeMessagesUtil.TAG_SET_READY);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
}
#method_after
private void addMessage(ChangeContext ctx, ChangeUpdate update) throws OrmException {
    Change c = ctx.getChange();
    StringBuilder buf = new StringBuilder(c.isWorkInProgress() ? "Set Work In Progress" : "Set Ready For Review");
    String m = Strings.nullToEmpty(in == null ? null : in.message).trim();
    if (!m.isEmpty()) {
        buf.append("\n\n");
        buf.append(m);
    }
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, buf.toString(), c.isWorkInProgress() ? ChangeMessagesUtil.TAG_SET_WIP : ChangeMessagesUtil.TAG_SET_READY);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
}
#end_block

#method_before
static ChangeNotesState empty(Change change) {
    return new AutoValue_ChangeNotesState(null, change.getId(), null, ImmutableSet.of(), ImmutableSet.of(), ImmutableList.of(), ImmutableList.of(), ReviewerSet.empty(), ReviewerByEmailSet.empty(), ImmutableList.of(), ImmutableList.of(), ImmutableList.of(), ImmutableList.of(), ImmutableListMultimap.of(), ImmutableListMultimap.of(), null, null, null, true);
}
#method_after
static ChangeNotesState empty(Change change) {
    return new AutoValue_ChangeNotesState(null, change.getId(), null, ImmutableSet.of(), ImmutableSet.of(), ImmutableList.of(), ImmutableList.of(), ReviewerSet.empty(), ReviewerByEmailSet.empty(), ReviewerSet.empty(), ReviewerByEmailSet.empty(), ImmutableList.of(), ImmutableList.of(), ImmutableList.of(), ImmutableList.of(), ImmutableListMultimap.of(), ImmutableListMultimap.of(), null, null, null, true);
}
#end_block

#method_before
static ChangeNotesState create(@Nullable ObjectId metaId, Change.Id changeId, Change.Key changeKey, Timestamp createdOn, Timestamp lastUpdatedOn, Account.Id owner, String branch, @Nullable PatchSet.Id currentPatchSetId, String subject, @Nullable String topic, @Nullable String originalSubject, @Nullable String submissionId, @Nullable Account.Id assignee, @Nullable Change.Status status, @Nullable Set<Account.Id> pastAssignees, @Nullable Set<String> hashtags, Map<PatchSet.Id, PatchSet> patchSets, ListMultimap<PatchSet.Id, PatchSetApproval> approvals, ReviewerSet reviewers, ReviewerByEmailSet reviewersByEmail, List<Account.Id> allPastReviewers, List<ReviewerStatusUpdate> reviewerUpdates, List<SubmitRecord> submitRecords, List<ChangeMessage> allChangeMessages, ListMultimap<PatchSet.Id, ChangeMessage> changeMessagesByPatchSet, ListMultimap<RevId, Comment> publishedComments, @Nullable Timestamp readOnlyUntil, @Nullable Boolean isPrivate, @Nullable Boolean workInProgress, boolean hasReviewStarted) {
    if (hashtags == null) {
        hashtags = ImmutableSet.of();
    }
    return new AutoValue_ChangeNotesState(metaId, changeId, new AutoValue_ChangeNotesState_ChangeColumns(changeKey, createdOn, lastUpdatedOn, owner, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, assignee, status, isPrivate, workInProgress, hasReviewStarted), ImmutableSet.copyOf(pastAssignees), ImmutableSet.copyOf(hashtags), ImmutableList.copyOf(patchSets.entrySet()), ImmutableList.copyOf(approvals.entries()), reviewers, reviewersByEmail, ImmutableList.copyOf(allPastReviewers), ImmutableList.copyOf(reviewerUpdates), ImmutableList.copyOf(submitRecords), ImmutableList.copyOf(allChangeMessages), ImmutableListMultimap.copyOf(changeMessagesByPatchSet), ImmutableListMultimap.copyOf(publishedComments), readOnlyUntil, isPrivate, workInProgress, hasReviewStarted);
}
#method_after
static ChangeNotesState create(@Nullable ObjectId metaId, Change.Id changeId, Change.Key changeKey, Timestamp createdOn, Timestamp lastUpdatedOn, Account.Id owner, String branch, @Nullable PatchSet.Id currentPatchSetId, String subject, @Nullable String topic, @Nullable String originalSubject, @Nullable String submissionId, @Nullable Account.Id assignee, @Nullable Change.Status status, @Nullable Set<Account.Id> pastAssignees, @Nullable Set<String> hashtags, Map<PatchSet.Id, PatchSet> patchSets, ListMultimap<PatchSet.Id, PatchSetApproval> approvals, ReviewerSet reviewers, ReviewerByEmailSet reviewersByEmail, ReviewerSet pendingReviewers, ReviewerByEmailSet pendingReviewersByEmail, List<Account.Id> allPastReviewers, List<ReviewerStatusUpdate> reviewerUpdates, List<SubmitRecord> submitRecords, List<ChangeMessage> allChangeMessages, ListMultimap<PatchSet.Id, ChangeMessage> changeMessagesByPatchSet, ListMultimap<RevId, Comment> publishedComments, @Nullable Timestamp readOnlyUntil, @Nullable Boolean isPrivate, @Nullable Boolean workInProgress, boolean hasReviewStarted) {
    if (hashtags == null) {
        hashtags = ImmutableSet.of();
    }
    return new AutoValue_ChangeNotesState(metaId, changeId, new AutoValue_ChangeNotesState_ChangeColumns(changeKey, createdOn, lastUpdatedOn, owner, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, assignee, status, isPrivate, workInProgress, hasReviewStarted), ImmutableSet.copyOf(pastAssignees), ImmutableSet.copyOf(hashtags), ImmutableList.copyOf(patchSets.entrySet()), ImmutableList.copyOf(approvals.entries()), reviewers, reviewersByEmail, pendingReviewers, pendingReviewersByEmail, ImmutableList.copyOf(allPastReviewers), ImmutableList.copyOf(reviewerUpdates), ImmutableList.copyOf(submitRecords), ImmutableList.copyOf(allChangeMessages), ImmutableListMultimap.copyOf(changeMessagesByPatchSet), ImmutableListMultimap.copyOf(publishedComments), readOnlyUntil, isPrivate, workInProgress, hasReviewStarted);
}
#end_block

#method_before
protected void setUpDatabase() throws Exception {
    try (ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) {
        schemaCreator.create(underlyingDb);
    }
    db = schemaFactory.open();
    userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    Account userAccount = db.accounts().get(userId);
    String email = "user@example.com";
    externalIdsUpdate.create().insert(ExternalId.createEmail(userId, email));
    userAccount.setPreferredEmail(email);
    db.accounts().update(ImmutableList.of(userAccount));
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userAccount.getId()));
}
#method_after
protected void setUpDatabase() throws Exception {
    try (ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) {
        schemaCreator.create(underlyingDb);
    }
    db = schemaFactory.open();
    userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    Account userAccount = accounts.get(db, userId);
    String email = "user@example.com";
    externalIdsUpdate.create().insert(ExternalId.createEmail(userId, email));
    userAccount.setPreferredEmail(email);
    accountsUpdate.create().update(db, userAccount);
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userAccount.getId()));
}
#end_block

#method_before
private Account.Id createAccount(String username, String fullName, String email, boolean active) throws Exception {
    try (ManualRequestContext ctx = oneOffRequestContext.open()) {
        Account.Id id = accountManager.authenticate(AuthRequest.forUser(username)).getAccountId();
        if (email != null) {
            accountManager.link(id, AuthRequest.forEmail(email));
        }
        Account a = db.accounts().get(id);
        a.setFullName(fullName);
        a.setPreferredEmail(email);
        a.setActive(active);
        db.accounts().update(ImmutableList.of(a));
        accountCache.evict(id);
        return id;
    }
}
#method_after
private Account.Id createAccount(String username, String fullName, String email, boolean active) throws Exception {
    try (ManualRequestContext ctx = oneOffRequestContext.open()) {
        Account.Id id = accountManager.authenticate(AuthRequest.forUser(username)).getAccountId();
        if (email != null) {
            accountManager.link(id, AuthRequest.forEmail(email));
        }
        Account a = accounts.get(db, id);
        a.setFullName(fullName);
        a.setPreferredEmail(email);
        a.setActive(active);
        accountsUpdate.create().update(db, a);
        return id;
    }
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOther() throws Exception {
    TestAccount other = accounts.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange(ALL_COMMENTS);
    review(other, sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).notTo(other).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS);
}
#method_after
@Test
public void commentOnReviewableChangeByOther() throws Exception {
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange(ALL_COMMENTS);
    review(other, sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).notTo(other).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS);
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOtherCcingSelf() throws Exception {
    TestAccount other = accounts.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange(ALL_COMMENTS);
    review(other, sc.changeId, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS);
}
#method_after
@Test
public void commentOnReviewableChangeByOtherCcingSelf() throws Exception {
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange(ALL_COMMENTS);
    review(other, sc.changeId, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS);
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOther() throws Exception {
    TestAccount other = accounts.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange();
    review(other, sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#method_after
@Test
public void commentOnReviewableChangeByOther() throws Exception {
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange();
    review(other, sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOtherCcingSelf() throws Exception {
    TestAccount other = accounts.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange();
    review(other, sc.changeId, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#method_after
@Test
public void commentOnReviewableChangeByOtherCcingSelf() throws Exception {
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange();
    review(other, sc.changeId, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#end_block

#method_before
@Before
public void createExtraAccount() throws Exception {
    voter = accounts.create("voter", "voter@example.com", "voter");
    setEmailStrategy(EmailStrategy.ENABLED);
}
#method_after
@Before
public void createExtraAccount() throws Exception {
    voter = accountCreator.create("voter", "voter@example.com", "voter");
    setEmailStrategy(EmailStrategy.ENABLED);
}
#end_block

#method_before
@Before
public void createOtherAndGrantPermissions() throws Exception {
    other = accounts.create("other", "other@example.com", "other");
    grant(project, "refs/*", Permission.FORGE_COMMITTER, false, REGISTERED_USERS);
}
#method_after
@Before
public void createOtherAndGrantPermissions() throws Exception {
    other = accountCreator.create("other", "other@example.com", "other");
    grant(project, "refs/*", Permission.FORGE_COMMITTER, false, REGISTERED_USERS);
}
#end_block

#method_before
@Test
public void changeAssigneeOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accounts.create("other", "other@example.com", "other");
    assign(sc, sc.owner, other);
    sender.clear();
    assign(sc, sc.owner, sc.assignee);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
}
#method_after
@Test
public void changeAssigneeOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    assign(sc, sc.owner, other);
    sender.clear();
    assign(sc, sc.owner, sc.assignee);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
}
#end_block

#method_before
@Test
public void abandonReviewableChangeByOther() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accounts.create("other", "other@example.com", "other");
    abandon(sc.changeId, other);
    assertThat(sender).sent("abandon", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
}
#method_after
@Test
public void abandonReviewableChangeByOther() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    abandon(sc.changeId, other);
    assertThat(sender).sent("abandon", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
}
#end_block

#method_before
@Test
public void abandonReviewableChangeByOtherCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accounts.create("other", "other@example.com", "other");
    abandon(sc.changeId, other, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("abandon", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
}
#method_after
@Test
public void abandonReviewableChangeByOtherCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    abandon(sc.changeId, other, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("abandon", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
}
#end_block

#method_before
@Test
public void abandonReviewableChangeByOtherCcingSelfNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accounts.create("other", "other@example.com", "other");
    abandon(sc.changeId, other, CC_ON_OWN_COMMENTS, OWNER);
    assertThat(sender).sent("abandon", sc).to(sc.owner).cc(other).noOneElse();
}
#method_after
@Test
public void abandonReviewableChangeByOtherCcingSelfNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    abandon(sc.changeId, other, CC_ON_OWN_COMMENTS, OWNER);
    assertThat(sender).sent("abandon", sc).to(sc.owner).cc(other).noOneElse();
}
#end_block

#method_before
public FakeEmailSenderSubject sent(String messageType, StagedUsers users) {
    message = actual().nextMessage();
    if (message == null) {
        fail("a message was sent");
    }
    recipients = new HashMap<>();
    recipients.put(TO, parseAddresses(message, "To"));
    recipients.put(CC, parseAddresses(message, "CC"));
    recipients.put(BCC, message.rcpt().stream().map(Address::getEmail).filter(e -> !recipients.get(TO).contains(e) && !recipients.get(CC).contains(e)).collect(Collectors.toList()));
    this.users = users;
    if (!message.headers().containsKey("X-Gerrit-MessageType")) {
        fail("a message was sent with X-Gerrit-MessageType header");
    }
    EmailHeader header = message.headers().get("X-Gerrit-MessageType");
    if (!header.equals(new EmailHeader.String(messageType))) {
        fail("message of type " + messageType + " was sent; X-Gerrit-MessageType is " + header);
    }
    // recipients.
    return named(recipientMapToString(recipients));
}
#method_after
public FakeEmailSenderSubject sent(String messageType, StagedUsers users) {
    message = actual().nextMessage();
    if (message == null) {
        fail("a message was sent");
    }
    recipients = new HashMap<>();
    recipients.put(TO, parseAddresses(message, "To"));
    recipients.put(CC, parseAddresses(message, "CC"));
    recipients.put(BCC, message.rcpt().stream().map(Address::getEmail).filter(e -> !recipients.get(TO).contains(e) && !recipients.get(CC).contains(e)).collect(Collectors.toList()));
    this.users = users;
    if (!message.headers().containsKey("X-Gerrit-MessageType")) {
        fail("a message was sent with X-Gerrit-MessageType header");
    }
    EmailHeader header = message.headers().get("X-Gerrit-MessageType");
    if (!header.equals(new EmailHeader.String(messageType))) {
        fail("message of type " + messageType + " was sent; X-Gerrit-MessageType is " + header);
    }
    // recipients.
    return named(recipientMapToString(recipients, e -> users.emailToName(e)));
}
#end_block

#method_before
private static String recipientMapToString(Map<RecipientType, List<String>> recipients) {
    StringBuilder buf = new StringBuilder();
    buf.append('[');
    for (RecipientType type : ImmutableList.of(TO, CC, BCC)) {
        buf.append('\n');
        buf.append(type);
        buf.append(':');
        String delim = " ";
        for (String r : recipients.get(type)) {
            buf.append(delim);
            buf.append(stripUniqueSuffix(r));
            delim = ", ";
        }
    }
    buf.append("\n]");
    return buf.toString();
}
#method_after
private static String recipientMapToString(Map<RecipientType, List<String>> recipients, Function<String, String> emailToName) {
    StringBuilder buf = new StringBuilder();
    buf.append('[');
    for (RecipientType type : ImmutableList.of(TO, CC, BCC)) {
        buf.append('\n');
        buf.append(type);
        buf.append(':');
        String delim = " ";
        for (String r : recipients.get(type)) {
            buf.append(delim);
            buf.append(emailToName.apply(r));
            delim = ", ";
        }
    }
    buf.append("\n]");
    return buf.toString();
}
#end_block

#method_before
private void rcpt(@Nullable RecipientType type, String email, boolean expected) {
    if (recipients.get(type).contains(email) != expected) {
        fail(expected ? "notifies" : "doesn't notify", "]\n" + type + ": " + stripUniqueSuffix(email) + "\n]");
    }
    if (expected) {
        accountedFor.add(email);
    }
}
#method_after
private void rcpt(@Nullable RecipientType type, String email, boolean expected) {
    if (recipients.get(type).contains(email) != expected) {
        fail(expected ? "notifies" : "doesn't notify", "]\n" + type + ": " + users.emailToName(email) + "\n]");
    }
    if (expected) {
        accountedFor.add(email);
    }
}
#end_block

#method_before
public FakeEmailSenderSubject noOneElse() {
    for (Map.Entry<NotifyType, TestAccount> watchEntry : users.watchers.entrySet()) {
        if (!accountedFor.contains(watchEntry.getValue().email)) {
            notTo(watchEntry.getKey());
        }
    }
    Map<RecipientType, List<String>> unaccountedFor = new HashMap<>();
    boolean ok = true;
    for (Map.Entry<RecipientType, List<String>> entry : recipients.entrySet()) {
        unaccountedFor.put(entry.getKey(), new ArrayList<>());
        for (String address : entry.getValue()) {
            if (!accountedFor.contains(address)) {
                unaccountedFor.get(entry.getKey()).add(address);
                ok = false;
            }
        }
    }
    if (!ok) {
        fail("was fully tested, missing assertions for: " + recipientMapToString(unaccountedFor));
    }
    return this;
}
#method_after
public FakeEmailSenderSubject noOneElse() {
    for (Map.Entry<NotifyType, TestAccount> watchEntry : users.watchers.entrySet()) {
        if (!accountedFor.contains(watchEntry.getValue().email)) {
            notTo(watchEntry.getKey());
        }
    }
    Map<RecipientType, List<String>> unaccountedFor = new HashMap<>();
    boolean ok = true;
    for (Map.Entry<RecipientType, List<String>> entry : recipients.entrySet()) {
        unaccountedFor.put(entry.getKey(), new ArrayList<>());
        for (String address : entry.getValue()) {
            if (!accountedFor.contains(address)) {
                unaccountedFor.get(entry.getKey()).add(address);
                ok = false;
            }
        }
    }
    if (!ok) {
        fail("was fully tested, missing assertions for: " + recipientMapToString(unaccountedFor, e -> users.emailToName(e)));
    }
    return this;
}
#end_block

#method_before
public TestAccount testAccount(String name) throws Exception {
    name = withUniqueSuffix(name);
    return accounts.create(name, name + "@example.com", name);
}
#method_after
public TestAccount testAccount(String name) throws Exception {
    String username = name(name);
    TestAccount account = accountCreator.create(username, email(username), name);
    accountsByEmail.put(account.email, account);
    return account;
}
#end_block

#method_before
public TestAccount testAccount(String name, String groupName) throws Exception {
    name = withUniqueSuffix(name);
    return accounts.create(name, name + "@example.com", name, groupName);
}
#method_after
public TestAccount testAccount(String name, String groupName) throws Exception {
    String username = name(name);
    TestAccount account = accountCreator.create(username, email(username), name, groupName);
    accountsByEmail.put(account.email, account);
    return account;
}
#end_block

#method_before
@Before
public void createExtraAccount() throws Exception {
    extraReviewer = accounts.create("extraReviewer", "extraReviewer@example.com", "extraReviewer");
    extraCcer = accounts.create("extraCcer", "extraCcer@example.com", "extraCcer");
}
#method_after
@Before
public void createExtraAccount() throws Exception {
    extraReviewer = accountCreator.create("extraReviewer", "extraReviewer@example.com", "extraReviewer");
    extraCcer = accountCreator.create("extraCcer", "extraCcer@example.com", "extraCcer");
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#method_after
@Test
public void deleteReviewerFromReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    setEmailStrategy(sc.owner, EmailStrategy.CC_ON_OWN_COMMENTS);
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    setEmailStrategy(sc.owner, EmailStrategy.CC_ON_OWN_COMMENTS);
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeByAdmin() throws Exception {
    StagedChange sc = stageReviewableChange();
    setApiUser(admin);
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeByAdmin() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    setApiUser(admin);
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeByAdminCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    setEmailStrategy(admin, EmailStrategy.CC_ON_OWN_COMMENTS);
    setApiUser(admin);
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).cc(admin, extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeByAdminCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    setEmailStrategy(admin, EmailStrategy.CC_ON_OWN_COMMENTS);
    setApiUser(admin);
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).cc(admin, extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#end_block

#method_before
@Test
public void deleteCcerFromReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    removeReviewer(sc, extraCcer);
    assertThat(sender).sent("deleteReviewer", sc).to(extraCcer).cc(extraReviewer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#method_after
@Test
public void deleteCcerFromReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    removeReviewer(sc, extraCcer);
    assertThat(sender).sent("deleteReviewer", sc).to(extraCcer).cc(extraReviewer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChange();
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER_REVIEWERS);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER_REVIEWERS);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).noOneElse();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).noOneElse();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeByOwnerCcingSelfNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    setEmailStrategy(sc.owner, EmailStrategy.CC_ON_OWN_COMMENTS);
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).noOneElse();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeByOwnerCcingSelfNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    setEmailStrategy(sc.owner, EmailStrategy.CC_ON_OWN_COMMENTS);
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).noOneElse();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    removeReviewer(sc, extraReviewer, NotifyHandling.NONE);
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    removeReviewer(sc, extraReviewer, NotifyHandling.NONE);
    assertThat(sender).notSent();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeByOwnerCcingSelfNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    setEmailStrategy(sc.owner, EmailStrategy.CC_ON_OWN_COMMENTS);
    removeReviewer(sc, extraReviewer, NotifyHandling.NONE);
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeByOwnerCcingSelfNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    setEmailStrategy(sc.owner, EmailStrategy.CC_ON_OWN_COMMENTS);
    removeReviewer(sc, extraReviewer, NotifyHandling.NONE);
    assertThat(sender).notSent();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableWipChange() throws Exception {
    StagedChange sc = stageReviewableWipChange();
    removeReviewer(sc, extraReviewer);
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerFromReviewableWipChange() throws Exception {
    StagedChange sc = stageReviewableWipChangeWithExtraReviewer();
    removeReviewer(sc, extraReviewer);
    assertThat(sender).notSent();
}
#end_block

#method_before
@Test
public void deleteReviewerFromWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    removeReviewer(sc, extraReviewer);
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerFromWipChange() throws Exception {
    StagedChange sc = stageWipChangeWithExtraReviewer();
    removeReviewer(sc, extraReviewer);
    assertThat(sender).notSent();
}
#end_block

#method_before
@Test
public void deleteReviewerFromWipChangeNotifyAll() throws Exception {
    StagedChange sc = stageWipChange();
    removeReviewer(sc, extraReviewer, NotifyHandling.ALL);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#method_after
@Test
public void deleteReviewerFromWipChangeNotifyAll() throws Exception {
    StagedChange sc = stageWipChangeWithExtraReviewer();
    removeReviewer(sc, extraReviewer, NotifyHandling.ALL);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
}
#end_block

#method_before
@Test
public void deleteReviewerWithApprovalFromWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    setApiUser(extraReviewer);
    gApi.changes().id(sc.changeId).revision("current").review(ReviewInput.recommend());
    sender.clear();
    setApiUser(sc.owner);
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).noOneElse();
}
#method_after
@Test
public void deleteReviewerWithApprovalFromWipChange() throws Exception {
    StagedChange sc = stageWipChangeWithExtraReviewer();
    setApiUser(extraReviewer);
    gApi.changes().id(sc.changeId).revision("current").review(ReviewInput.recommend());
    sender.clear();
    setApiUser(sc.owner);
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).noOneElse();
}
#end_block

#method_before
@Test
public void deleteReviewerByEmailFromWipChangeInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    StagedChange sc = stageWipChange();
    gApi.changes().id(sc.changeId).reviewer(sc.reviewerByEmail).remove();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerByEmailFromWipChangeInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    StagedChange sc = stageWipChangeWithExtraReviewer();
    gApi.changes().id(sc.changeId).reviewer(sc.reviewerByEmail).remove();
    assertThat(sender).notSent();
}
#end_block

#method_before
@Before
public void createOther() throws Exception {
    other = accounts.create("other", "other@example.com", "other");
}
#method_after
@Before
public void createOther() throws Exception {
    other = accountCreator.create("other", "other@example.com", "other");
}
#end_block

#method_before
@Before
public void createOther() throws Exception {
    other = accounts.create("other", "other@example.com", "other");
}
#method_after
@Before
public void createOther() throws Exception {
    other = accountCreator.create("other", "other@example.com", "other");
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeInReviewDb() throws Exception {
    forAll(adder -> {
        assume().that(notesMigration.readChanges()).isFalse();
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accounts.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#method_after
@Test
public void addReviewerToReviewableChangeInReviewDb() throws Exception {
    forAll(adder -> {
        assume().that(notesMigration.readChanges()).isFalse();
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accounts.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#method_after
@Test
public void addReviewerToReviewableChangeInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeByOwnerCcingSelfInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accounts.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email, CC_ON_OWN_COMMENTS, null);
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#method_after
@Test
public void addReviewerToReviewableChangeByOwnerCcingSelfInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email, CC_ON_OWN_COMMENTS, null);
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeByOtherInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    TestAccount other = accounts.create("other", "other@example.com", "other");
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accounts.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, other, reviewer.email);
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#method_after
@Test
public void addReviewerToReviewableChangeByOtherInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, other, reviewer.email);
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeByOtherCcingSelfInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    TestAccount other = accounts.create("other", "other@example.com", "other");
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accounts.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, other, reviewer.email, CC_ON_OWN_COMMENTS, null);
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#method_after
@Test
public void addReviewerToReviewableChangeByOtherCcingSelfInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, other, reviewer.email, CC_ON_OWN_COMMENTS, null);
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#end_block

#method_before
@Test
public void addReviewerToWipChange() throws Exception {
    forAll(adder -> {
        StagedChange sc = stageWipChange();
        TestAccount reviewer = accounts.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
        assertThat(sender).notSent();
    });
}
#method_after
@Test
public void addReviewerToWipChange() throws Exception {
    forAll(adder -> {
        StagedChange sc = stageWipChange();
        TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
        assertThat(sender).notSent();
    });
}
#end_block

#method_before
@Test
public void addReviewerToReviewableWipChange() throws Exception {
    forAll(adder -> {
        StagedChange sc = stageReviewableWipChange();
        TestAccount reviewer = accounts.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
        assertThat(sender).notSent();
    });
}
#method_after
@Test
public void addReviewerToReviewableWipChange() throws Exception {
    forAll(adder -> {
        StagedChange sc = stageReviewableWipChange();
        TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
        assertThat(sender).notSent();
    });
}
#end_block

#method_before
@Test
public void addReviewerToWipChangeInNoteDbNotifyAll() throws Exception {
    forAll(adder -> {
        assume().that(notesMigration.readChanges()).isTrue();
        StagedChange sc = stageWipChange();
        TestAccount reviewer = accounts.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email, NotifyHandling.ALL);
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#method_after
@Test
public void addReviewerToWipChangeInNoteDbNotifyAll() throws Exception {
    forAll(adder -> {
        assume().that(notesMigration.readChanges()).isTrue();
        StagedChange sc = stageWipChange();
        TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email, NotifyHandling.ALL);
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#end_block

#method_before
@Test
public void addReviewerToWipChangeInReviewDbNotifyAll() throws Exception {
    forAll(adder -> {
        assume().that(notesMigration.readChanges()).isFalse();
        StagedChange sc = stageWipChange();
        TestAccount reviewer = accounts.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email, NotifyHandling.ALL);
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#method_after
@Test
public void addReviewerToWipChangeInReviewDbNotifyAll() throws Exception {
    forAll(adder -> {
        assume().that(notesMigration.readChanges()).isFalse();
        StagedChange sc = stageWipChange();
        TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email, NotifyHandling.ALL);
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeInNoteDbNotifyOwnerReviewers() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accounts.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email, OWNER_REVIEWERS);
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#method_after
@Test
public void addReviewerToReviewableChangeInNoteDbNotifyOwnerReviewers() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email, OWNER_REVIEWERS);
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    });
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeInNoteDbByOwnerCcingSelfNotifyOwner() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accounts.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email, CC_ON_OWN_COMMENTS, OWNER);
        assertThat(sender).notSent();
    });
}
#method_after
@Test
public void addReviewerToReviewableChangeInNoteDbByOwnerCcingSelfNotifyOwner() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email, CC_ON_OWN_COMMENTS, OWNER);
        assertThat(sender).notSent();
    });
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeInNoteDbByOwnerCcingSelfNotifyNone() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accounts.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email, CC_ON_OWN_COMMENTS, NONE);
        assertThat(sender).notSent();
    });
}
#method_after
@Test
public void addReviewerToReviewableChangeInNoteDbByOwnerCcingSelfNotifyNone() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email, CC_ON_OWN_COMMENTS, NONE);
        assertThat(sender).notSent();
    });
}
#end_block

#method_before
public FakeEmailSenderSubject sent(String messageType, StagedUsers users) {
    message = actual().nextMessage();
    if (message == null) {
        fail("a message was sent");
    }
    recipients = new HashMap<>();
    recipients.put(TO, parseAddresses(message, "To"));
    recipients.put(CC, parseAddresses(message, "CC"));
    recipients.put(BCC, message.rcpt().stream().map(Address::getEmail).filter(e -> !recipients.get(TO).contains(e) && !recipients.get(CC).contains(e)).collect(Collectors.toList()));
    this.users = users;
    if (!message.headers().containsKey("X-Gerrit-MessageType")) {
        fail("a message was sent with X-Gerrit-MessageType header");
    }
    EmailHeader header = message.headers().get("X-Gerrit-MessageType");
    if (!header.equals(new EmailHeader.String(messageType))) {
        fail("message of type " + messageType + " was sent; X-Gerrit-MessageType is " + header);
    }
    // Return a named subject that displays a human-readable table of
    // recipients.
    StringBuilder buf = new StringBuilder();
    buf.append('[');
    for (RecipientType type : ImmutableList.of(TO, CC, BCC)) {
        buf.append('\n');
        buf.append(type);
        buf.append(':');
        String delim = " ";
        for (String r : recipients.get(type)) {
            buf.append(delim);
            buf.append(stripUniqueSuffix(r));
            delim = ", ";
        }
    }
    buf.append("\n]");
    return named(buf.toString());
}
#method_after
public FakeEmailSenderSubject sent(String messageType, StagedUsers users) {
    message = actual().nextMessage();
    if (message == null) {
        fail("a message was sent");
    }
    recipients = new HashMap<>();
    recipients.put(TO, parseAddresses(message, "To"));
    recipients.put(CC, parseAddresses(message, "CC"));
    recipients.put(BCC, message.rcpt().stream().map(Address::getEmail).filter(e -> !recipients.get(TO).contains(e) && !recipients.get(CC).contains(e)).collect(Collectors.toList()));
    this.users = users;
    if (!message.headers().containsKey("X-Gerrit-MessageType")) {
        fail("a message was sent with X-Gerrit-MessageType header");
    }
    EmailHeader header = message.headers().get("X-Gerrit-MessageType");
    if (!header.equals(new EmailHeader.String(messageType))) {
        fail("message of type " + messageType + " was sent; X-Gerrit-MessageType is " + header);
    }
    // Return a named subject that displays a human-readable table of
    // recipients.
    StringBuilder buf = new StringBuilder();
    buf.append('[');
    for (RecipientType type : ImmutableList.of(TO, CC, BCC)) {
        buf.append('\n');
        buf.append(type);
        buf.append(':');
        String delim = " ";
        for (String r : recipients.get(type)) {
            buf.append(delim);
            buf.append(users.emailToName(r));
            delim = ", ";
        }
    }
    buf.append("\n]");
    return named(buf.toString());
}
#end_block

#method_before
private void rcpt(@Nullable RecipientType type, String email, boolean expected) {
    if (recipients.get(type).contains(email) != expected) {
        fail(expected ? "notifies" : "doesn't notify", "]\n" + type + ": " + stripUniqueSuffix(email) + "\n]");
    }
}
#method_after
private void rcpt(@Nullable RecipientType type, String email, boolean expected) {
    if (recipients.get(type).contains(email) != expected) {
        fail(expected ? "notifies" : "doesn't notify", "]\n" + type + ": " + users.emailToName(email) + "\n]");
    }
}
#end_block

#method_before
public TestAccount testAccount(String name) throws Exception {
    name = withUniqueSuffix(name);
    return accounts.create(name, name + "@example.com", name);
}
#method_after
public TestAccount testAccount(String name) throws Exception {
    String username = name(name);
    TestAccount account = accountCreator.create(username, email(username), name);
    accountsByEmail.put(account.email, account);
    return account;
}
#end_block

#method_before
public TestAccount testAccount(String name, String groupName) throws Exception {
    name = withUniqueSuffix(name);
    return accounts.create(name, name + "@example.com", name, groupName);
}
#method_after
public TestAccount testAccount(String name, String groupName) throws Exception {
    String username = name(name);
    TestAccount account = accountCreator.create(username, email(username), name, groupName);
    accountsByEmail.put(account.email, account);
    return account;
}
#end_block

#method_before
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(db, rp.getRepository(), obj)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        actualCommands.add(cmd);
    } else {
        reject(cmd, "prohibited by Gerrit: create access denied for " + cmd.getRefName());
    }
}
#method_after
private void parseCreate(ReceiveCommand cmd) throws PermissionBackendException {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    boolean ok;
    try {
        permissions.ref(cmd.getRefName()).check(RefPermission.CREATE);
        ok = true;
    } catch (AuthException err) {
        ok = false;
    }
    if (ok && ctl.canCreate(rp.getRepository(), obj)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        actualCommands.add(cmd);
    } else {
        reject(cmd, "prohibited by Gerrit: create access denied for " + cmd.getRefName());
    }
}
#end_block

#method_before
@Option(name = "--message", aliases = { "-m" }, metaVar = "MESSAGE", usage = "Comment message to apply to the review")
void addMessage(final String token) {
    // git push does not allow spaces in refs.
    message = token.replace("_", " ");
}
#method_after
@Option(name = "--message", aliases = { "-m" }, metaVar = "MESSAGE", usage = "Comment message to apply to the review")
void addMessage(String token) {
    // git push does not allow spaces in refs.
    message = token.replace("_", " ");
}
#end_block

#method_before
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(user, cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (projectControl.getProject().getState() != com.google.gerrit.extensions.client.ProjectState.ACTIVE) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef(MagicBranch.NEW_DRAFT_CHANGE + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isPrivate && magicBranch.removePrivate) {
        reject(cmd, "the options 'private' and 'remove-private' are mutually exclusive");
        return;
    }
    if (magicBranch.workInProgress && magicBranch.ready) {
        reject(cmd, "the options 'wip' and 'ready' are mutually exclusive");
        return;
    }
    if (magicBranch.publishComments && magicBranch.noPublishComments) {
        reject(cmd, "the options 'publish-comments' and 'no-publish-comments' are mutually exclusive");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit(true)) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    String destBranch = magicBranch.dest.get();
    try {
        if (magicBranch.merged) {
            if (magicBranch.draft) {
                reject(cmd, "cannot be draft & merged");
                return;
            }
            if (magicBranch.base != null) {
                reject(cmd, "cannot use merged with base");
                return;
            }
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            if (!walk.isMergedInto(tip, branchTip)) {
                reject(cmd, "not merged into branch");
                return;
            }
        }
        // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
        if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
            logDebug("Forcing newChangeForAllNotInTarget = false");
            newChangeForAllNotInTarget = false;
        }
        if (magicBranch.base != null) {
            logDebug("Handling %base: {}", magicBranch.base);
            magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
            for (ObjectId id : magicBranch.base) {
                try {
                    magicBranch.baseCommit.add(walk.parseCommit(id));
                } catch (IncorrectObjectTypeException notCommit) {
                    reject(cmd, "base must be a commit");
                    return;
                } catch (MissingObjectException e) {
                    reject(cmd, "base not found");
                    return;
                } catch (IOException e) {
                    logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                    reject(cmd, "internal server error");
                    return;
                }
            }
        } else if (newChangeForAllNotInTarget) {
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            magicBranch.baseCommit = Collections.singletonList(branchTip);
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        }
    } catch (IOException ex) {
        logWarn(String.format("Error walking to %s in project %s", destBranch, project.getName()), ex);
        reject(cmd, "internal server error");
        return;
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) throws PermissionBackendException {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(user, cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    magicBranch.perm = permissions.ref(ref);
    if (projectControl.getProject().getState() != com.google.gerrit.extensions.client.ProjectState.ACTIVE) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef(MagicBranch.NEW_DRAFT_CHANGE + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    try {
        magicBranch.perm.check(RefPermission.CREATE_CHANGE);
    } catch (AuthException denied) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, denied.getMessage());
        return;
    }
    if (magicBranch.isPrivate && magicBranch.removePrivate) {
        reject(cmd, "the options 'private' and 'remove-private' are mutually exclusive");
        return;
    }
    if (magicBranch.workInProgress && magicBranch.ready) {
        reject(cmd, "the options 'wip' and 'ready' are mutually exclusive");
        return;
    }
    if (magicBranch.publishComments && magicBranch.noPublishComments) {
        reject(cmd, "the options 'publish-comments' and 'no-publish-comments' are mutually exclusive");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit) {
        try {
            permissions.ref(ref).check(RefPermission.UPDATE_BY_SUBMIT);
        } catch (AuthException e) {
            reject(cmd, e.getMessage());
            return;
        }
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    String destBranch = magicBranch.dest.get();
    try {
        if (magicBranch.merged) {
            if (magicBranch.draft) {
                reject(cmd, "cannot be draft & merged");
                return;
            }
            if (magicBranch.base != null) {
                reject(cmd, "cannot use merged with base");
                return;
            }
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            if (!walk.isMergedInto(tip, branchTip)) {
                reject(cmd, "not merged into branch");
                return;
            }
        }
        // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
        if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
            logDebug("Forcing newChangeForAllNotInTarget = false");
            newChangeForAllNotInTarget = false;
        }
        if (magicBranch.base != null) {
            logDebug("Handling %base: {}", magicBranch.base);
            magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
            for (ObjectId id : magicBranch.base) {
                try {
                    magicBranch.baseCommit.add(walk.parseCommit(id));
                } catch (IncorrectObjectTypeException notCommit) {
                    reject(cmd, "base must be a commit");
                    return;
                } catch (MissingObjectException e) {
                    reject(cmd, "base not found");
                    return;
                } catch (IOException e) {
                    logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                    reject(cmd, "internal server error");
                    return;
                }
            }
        } else if (newChangeForAllNotInTarget) {
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            magicBranch.baseCommit = Collections.singletonList(branchTip);
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        }
    } catch (IOException ex) {
        logWarn(String.format("Error walking to %s in project %s", destBranch, project.getName()), ex);
        reject(cmd, "internal server error");
        return;
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    ListMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return;
        }
        LinkedHashMap<RevCommit, ChangeLookup> pending = new LinkedHashMap<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            rp.getRevWalk().parseBody(c);
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            boolean commitAlreadyTracked = !existingRefs.isEmpty();
            if (commitAlreadyTracked) {
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            String idStr = !idList.isEmpty() ? idList.get(idList.size() - 1).trim() : null;
            if (idStr != null) {
                pending.put(c, new ChangeLookup(c, new Change.Key(idStr)));
            } else {
                pending.put(c, new ChangeLookup(c));
            }
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
            if (commitAlreadyTracked) {
                boolean changeExistsOnDestBranch = false;
                for (ChangeData cd : pending.get(c).destChanges) {
                    if (cd.change().getDest().equals(magicBranch.dest)) {
                        changeExistsOnDestBranch = true;
                        break;
                    }
                }
                if (changeExistsOnDestBranch) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.values().iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (p.changeKey == null) {
                continue;
            }
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in branch {} with Change-Id {}: {}", magicBranch.dest, p.changeKey, changes.stream().map(cd -> cd.getId().toString()).collect(joining()));
                // WTF, multiple changes in this branch have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique per branch.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                // double check against the existing refs
                if (foundInExistingRef(existing.get(p.commit))) {
                    if (pending.size() == 1) {
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                        newChanges = Collections.emptyList();
                        return;
                    }
                    itr.remove();
                    continue;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    ListMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return;
        }
        LinkedHashMap<RevCommit, ChangeLookup> pending = new LinkedHashMap<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            rp.getRevWalk().parseBody(c);
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            boolean commitAlreadyTracked = !existingRefs.isEmpty();
            if (commitAlreadyTracked) {
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            String idStr = !idList.isEmpty() ? idList.get(idList.size() - 1).trim() : null;
            if (idStr != null) {
                pending.put(c, new ChangeLookup(c, new Change.Key(idStr)));
            } else {
                pending.put(c, new ChangeLookup(c));
            }
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
            if (commitAlreadyTracked) {
                boolean changeExistsOnDestBranch = false;
                for (ChangeData cd : pending.get(c).destChanges) {
                    if (cd.change().getDest().equals(magicBranch.dest)) {
                        changeExistsOnDestBranch = true;
                        break;
                    }
                }
                if (changeExistsOnDestBranch) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.perm, magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.values().iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (p.changeKey == null) {
                continue;
            }
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in branch {} with Change-Id {}: {}", magicBranch.dest, p.changeKey, changes.stream().map(cd -> cd.getId().toString()).collect(joining()));
                // WTF, multiple changes in this branch have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique per branch.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                // double check against the existing refs
                if (foundInExistingRef(existing.get(p.commit))) {
                    if (pending.size() == 1) {
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                        newChanges = Collections.emptyList();
                        return;
                    }
                    itr.remove();
                    continue;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException, PermissionBackendException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (notes == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    Change change = notes.getChange();
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    try {
        permissions.change(notes).database(db).check(ChangePermission.ADD_PATCH_SET);
    } catch (AuthException no) {
        String locked = ".";
        if (projectControl.controlFor(notes).isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot add patch set to " + ontoChange + locked);
        return false;
    }
    if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    ChangeControl changeCtl = projectControl.controlFor(notes);
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException, PermissionBackendException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (notes == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    Change change = notes.getChange();
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    try {
        permissions.change(notes).database(db).check(ChangePermission.ADD_PATCH_SET);
    } catch (AuthException no) {
        String locked = ".";
        if (projectControl.controlFor(notes).isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot add patch set to " + ontoChange + locked);
        return false;
    }
    if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    PermissionBackend.ForRef perm = permissions.ref(change.getDest().get());
    RefControl refctl = projectControl.controlForRef(change.getDest());
    if (!validCommit(rp.getRevWalk(), perm, refctl, inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        logDebug("Short-circuiting new commit validation");
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        ListMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        int i = 0;
        for (RevCommit c; (c = walk.next()) != null; ) {
            i++;
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    logWarn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
        logDebug("Validated {} new commits", i);
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) throws PermissionBackendException {
    PermissionBackend.ForRef perm = permissions.ref(ctl.getRefName());
    if (!RefNames.REFS_CONFIG.equals(cmd.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches()) && pushOptions.containsKey(BYPASS_REVIEW)) {
        try {
            perm.check(RefPermission.BYPASS_REVIEW);
            if (!Iterables.isEmpty(rejectCommits)) {
                throw new AuthException("reject-commits prevents " + BYPASS_REVIEW);
            }
            logDebug("Short-circuiting new commit validation");
        } catch (AuthException denied) {
            reject(cmd, denied.getMessage());
        }
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        ListMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        int i = 0;
        for (RevCommit c; (c = walk.next()) != null; ) {
            i++;
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, perm, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = accounts.get(db, user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        accountsUpdate.create().update(db, a);
                        user.getAccount().setFullName(a.getFullName());
                    }
                } catch (OrmException e) {
                    logWarn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
        logDebug("Validated {} new commits", i);
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    try (CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), rw.getObjectReader(), c, user)) {
        boolean isMerged = magicBranch != null && cmd.getRefName().equals(magicBranch.cmd.getRefName()) && magicBranch.merged;
        CommitValidators validators = isMerged ? commitValidatorsFactory.forMergedCommits(ctl) : commitValidatorsFactory.forReceiveCommits(ctl, sshInfo, repo, rw);
        messages.addAll(validators.validate(receiveEvent));
    } catch (CommitValidationException e) {
        logDebug("Commit validation failed on {}", c.name());
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#method_after
private boolean validCommit(RevWalk rw, PermissionBackend.ForRef perm, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    try (CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), rw.getObjectReader(), c, user)) {
        boolean isMerged = magicBranch != null && cmd.getRefName().equals(magicBranch.cmd.getRefName()) && magicBranch.merged;
        CommitValidators validators = isMerged ? commitValidatorsFactory.forMergedCommits(perm, ctl) : commitValidatorsFactory.forReceiveCommits(perm, ctl, sshInfo, repo, rw);
        messages.addAll(validators.validate(receiveEvent));
    } catch (CommitValidationException e) {
        logDebug("Commit validation failed on {}", c.name());
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    logDebug("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        ListMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        int existingPatchSets = 0;
        int newPatchSets = 0;
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                existingPatchSets++;
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    newPatchSets++;
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (final ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                logDebug("Not closing {} because validation failed", id);
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        logDebug("Auto-closing {} changes with existing patch sets and {} with new patch sets", existingPatchSets, newPatchSets);
        bu.execute();
    } catch (RestApiException e) {
        logError("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException | PermissionBackendException e) {
        logError("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(ReceiveCommand cmd) {
    logDebug("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        ListMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        int existingPatchSets = 0;
        int newPatchSets = 0;
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                existingPatchSets++;
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    newPatchSets++;
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                logDebug("Not closing {} because validation failed", id);
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        logDebug("Auto-closing {} changes with existing patch sets and {} with new patch sets", existingPatchSets, newPatchSets);
        bu.execute();
    } catch (RestApiException e) {
        logError("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException | PermissionBackendException e) {
        logError("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
@Test
public void changeAssigneeOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accounts.create("other", "other@example.com", "other");
    assign(sc, sc.owner, other);
    sender.clear();
    assign(sc, sc.owner, sc.assignee);
    assertThat(sender).sent("setassignee", sc).notTo(sc.owner, sc.reviewer, sc.ccer, sc.starrer, other).to(// TODO(logan): This is probably not intended!
    sc.reviewerByEmail).cc(// TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee);
}
#method_after
@Test
public void changeAssigneeOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    assign(sc, sc.owner, other);
    sender.clear();
    assign(sc, sc.owner, sc.assignee);
    assertThat(sender).sent("setassignee", sc).notTo(sc.owner, sc.reviewer, sc.ccer, sc.starrer, other).to(// TODO(logan): This is probably not intended!
    sc.reviewerByEmail).cc(// TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee);
}
#end_block

#method_before
protected void beforeTest(Description description) throws Exception {
    this.description = description;
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setString("gerrit", null, "tempSiteDir", tempSiteDir.getRoot().getPath());
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.start(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.start(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    admin = accounts.admin();
    user = accounts.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    db = reviewDbProvider.open();
    if (classDesc.useSsh() || methodDesc.useSsh()) {
        useSsh = true;
        if (SshMode.useSsh() && (adminSshSession == null || userSshSession == null)) {
            // Create Ssh sessions
            initSsh(admin);
            Context ctx = newRequestContext(user);
            atrScope.set(ctx);
            userSshSession = ctx.getSession();
            userSshSession.open();
            ctx = newRequestContext(admin);
            atrScope.set(ctx);
            adminSshSession = ctx.getSession();
            adminSshSession.open();
        }
    } else {
        useSsh = false;
    }
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#method_after
protected void beforeTest(Description description) throws Exception {
    this.description = description;
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setString("gerrit", null, "tempSiteDir", tempSiteDir.getRoot().getPath());
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.start(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.start(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    admin = accountCreator.admin();
    user = accountCreator.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    db = reviewDbProvider.open();
    if (classDesc.useSsh() || methodDesc.useSsh()) {
        useSsh = true;
        if (SshMode.useSsh() && (adminSshSession == null || userSshSession == null)) {
            // Create Ssh sessions
            initSsh(admin);
            Context ctx = newRequestContext(user);
            atrScope.set(ctx);
            userSshSession = ctx.getSession();
            userSshSession.open();
            ctx = newRequestContext(admin);
            atrScope.set(ctx);
            adminSshSession = ctx.getSession();
            adminSshSession.open();
        }
    } else {
        useSsh = false;
    }
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#end_block

#method_before
private TestAccount getCloneAsAccount(Description description) {
    TestProjectInput ann = description.getAnnotation(TestProjectInput.class);
    return accounts.get(ann != null ? ann.cloneAs() : "admin");
}
#method_after
private TestAccount getCloneAsAccount(Description description) {
    TestProjectInput ann = description.getAnnotation(TestProjectInput.class);
    return accountCreator.get(ann != null ? ann.cloneAs() : "admin");
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOther() throws Exception {
    TestAccount other = accounts.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange(ALL_COMMENTS);
    review(other, sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).notTo(other).to(sc.owner).to(// TODO(logan): This is unintentionally TO, should be CC.
    sc.reviewerByEmail).cc(sc.reviewer, sc.ccer).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS);
}
#method_after
@Test
public void commentOnReviewableChangeByOther() throws Exception {
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange(ALL_COMMENTS);
    review(other, sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).notTo(other).to(sc.owner).to(// TODO(logan): This is unintentionally TO, should be CC.
    sc.reviewerByEmail).cc(sc.reviewer, sc.ccer).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS);
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOtherCcingSelf() throws Exception {
    TestAccount other = accounts.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange(ALL_COMMENTS);
    review(other, sc.changeId, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("comment", sc).to(sc.owner).to(// TODO(logan): This is unintentionally TO, should be CC.
    sc.reviewerByEmail).cc(sc.reviewer, sc.ccer, other).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS);
}
#method_after
@Test
public void commentOnReviewableChangeByOtherCcingSelf() throws Exception {
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange(ALL_COMMENTS);
    review(other, sc.changeId, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("comment", sc).to(sc.owner).to(// TODO(logan): This is unintentionally TO, should be CC.
    sc.reviewerByEmail).cc(sc.reviewer, sc.ccer, other).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS);
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    notes = ctx.getNotes();
    Change change = notes.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), notes);
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String reviewMessage = null;
    String psDescription = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        reviewMessage = magicBranch.message;
        psDescription = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
        if (magicBranch.removePrivate) {
            change.setPrivate(false);
            update.setPrivate(false);
        } else if (magicBranch.isPrivate) {
            change.setPrivate(true);
            update.setPrivate(true);
        }
        if (magicBranch.ready) {
            change.setWorkInProgress(false);
            update.setWorkInProgress(false);
        } else if (magicBranch.workInProgress) {
            change.setWorkInProgress(true);
            update.setWorkInProgress(true);
        }
        if (shouldPublishComments()) {
            comments = publishComments(ctx);
        }
    }
    boolean draft = magicBranch != null && magicBranch.draft;
    if (change.getStatus() == Change.Status.DRAFT && !draft) {
        update.setStatus(Change.Status.NEW);
    }
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commitId, draft, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null, psDescription);
    update.setPsDescription(psDescription);
    recipients.add(getRecipientsFromFooters(ctx.getDb(), accountResolver, draft, commit.getFooterLines()));
    recipients.remove(ctx.getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    Iterable<PatchSetApproval> newApprovals = approvalsUtil.addApprovalsForNewPatchSet(ctx.getDb(), update, projectControl.getLabelTypes(), newPatchSet, ctx.getControl(), approvals);
    approvalCopier.copy(ctx.getDb(), ctx.getControl(), newPatchSet, newApprovals);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    // reviewer which is needed in several other code paths.
    if (magicBranch != null && !magicBranch.labels.isEmpty()) {
        update.putReviewer(ctx.getAccountId(), REVIEWER);
    }
    recipients.add(oldRecipients);
    msg = createChangeMessage(ctx, reviewMessage);
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedByPushOp == null) {
        resetChange(ctx);
    } else {
        mergedByPushOp.setPatchSetProvider(Providers.of(newPatchSet)).updateChange(ctx);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    notes = ctx.getNotes();
    Change change = notes.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), notes);
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String reviewMessage = null;
    String psDescription = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        reviewMessage = magicBranch.message;
        psDescription = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
        if (magicBranch.removePrivate) {
            change.setPrivate(false);
            update.setPrivate(false);
        } else if (magicBranch.isPrivate) {
            change.setPrivate(true);
            update.setPrivate(true);
        }
        if (magicBranch.ready) {
            change.setWorkInProgress(false);
            change.setReviewStarted(true);
            update.setWorkInProgress(false);
        } else if (magicBranch.workInProgress) {
            change.setWorkInProgress(true);
            update.setWorkInProgress(true);
        }
        if (shouldPublishComments()) {
            comments = publishComments(ctx);
        }
    }
    boolean draft = magicBranch != null && magicBranch.draft;
    if (change.getStatus() == Change.Status.DRAFT && !draft) {
        update.setStatus(Change.Status.NEW);
    }
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commitId, draft, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null, psDescription);
    update.setPsDescription(psDescription);
    recipients.add(getRecipientsFromFooters(ctx.getDb(), accountResolver, draft, commit.getFooterLines()));
    recipients.remove(ctx.getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    Iterable<PatchSetApproval> newApprovals = approvalsUtil.addApprovalsForNewPatchSet(ctx.getDb(), update, projectControl.getLabelTypes(), newPatchSet, ctx.getControl(), approvals);
    approvalCopier.copy(ctx.getDb(), ctx.getControl(), newPatchSet, newApprovals);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    // reviewer which is needed in several other code paths.
    if (magicBranch != null && !magicBranch.labels.isEmpty()) {
        update.putReviewer(ctx.getAccountId(), REVIEWER);
    }
    recipients.add(oldRecipients);
    msg = createChangeMessage(ctx, reviewMessage);
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedByPushOp == null) {
        resetChange(ctx);
    } else {
        mergedByPushOp.setPatchSetProvider(Providers.of(newPatchSet)).updateChange(ctx);
    }
    return true;
}
#end_block

#method_before
@Before
public void createOtherAndGrantPermissions() throws Exception {
    other = accounts.create("other", "other@example.com", "other");
    grant(project, "refs/*", Permission.FORGE_COMMITTER, false, REGISTERED_USERS);
}
#method_after
@Before
public void createOtherAndGrantPermissions() throws Exception {
    other = accountCreator.create("other", "other@example.com", "other");
    grant(project, "refs/*", Permission.FORGE_COMMITTER, false, REGISTERED_USERS);
}
#end_block

#method_before
@Test
public void newPatchSetByOtherOnReviewableChangeInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    StagedChange sc = stageReviewableChange(NEW_PATCHSETS);
    pushTo(sc, "refs/for/master", other);
    assertThat(sender).sent("newpatchset", sc).notTo(sc.owner).to(sc.reviewer, other).to(sc.reviewerByEmail).cc(sc.ccer).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS);
}
#method_after
@Test
public void newPatchSetByOtherOnReviewableChangeInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    StagedChange sc = stageReviewableChange(NEW_PATCHSETS);
    pushTo(sc, "refs/for/master", other);
    assertThat(sender).sent("newpatchset", sc).notTo(// TODO(logan): This email shouldn't come from the owner.
    sc.owner).to(sc.reviewer, other).to(sc.reviewerByEmail).cc(sc.ccer).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS);
}
#end_block

#method_before
@Test
public void newPatchSetByOtherOnReviewableChangeInReviewDb() throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    StagedChange sc = stageReviewableChange(NEW_PATCHSETS);
    pushTo(sc, "refs/for/master", other);
    assertThat(sender).sent("newpatchset", sc).notTo(sc.owner).to(sc.reviewer, sc.ccer, other).notTo(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS);
}
#method_after
@Test
public void newPatchSetByOtherOnReviewableChangeInReviewDb() throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    StagedChange sc = stageReviewableChange(NEW_PATCHSETS);
    pushTo(sc, "refs/for/master", other);
    assertThat(sender).sent("newpatchset", sc).notTo(// TODO(logan): This email shouldn't come from the owner.
    sc.owner).to(sc.reviewer, sc.ccer, other).notTo(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS);
}
#end_block

#method_before
@Test
public void newPatchSetByOtherOnReviewableChangeNotifyOwnerReviewersInReviewDb() throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    StagedChange sc = stageReviewableChange(NEW_PATCHSETS);
    pushTo(sc, "refs/for/master%notify=OWNER_REVIEWERS", other);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer, sc.ccer).notTo(sc.starrer, other).notTo(// TODO(logan): Why?
    sc.owner).notTo(sc.reviewerByEmail, sc.ccerByEmail).notTo(NEW_PATCHSETS);
}
#method_after
@Test
public void newPatchSetByOtherOnReviewableChangeNotifyOwnerReviewersInReviewDb() throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    StagedChange sc = stageReviewableChange(NEW_PATCHSETS);
    pushTo(sc, "refs/for/master%notify=OWNER_REVIEWERS", other);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer, sc.ccer).notTo(sc.starrer, other).notTo(// TODO(logan): This email shouldn't come from the owner.
    sc.owner).notTo(sc.reviewerByEmail, sc.ccerByEmail).notTo(NEW_PATCHSETS);
}
#end_block

#method_before
@Test
public void newPatchSetByOtherOnReviewableChangeOwnerSelfCcNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange(NEW_PATCHSETS);
    pushTo(sc, "refs/for/master%notify=OWNER", other, EmailStrategy.CC_ON_OWN_COMMENTS);
    // Although owner would be CCed, there's no one else to send the email to.
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetByOtherOnReviewableChangeOwnerSelfCcNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange(NEW_PATCHSETS);
    pushTo(sc, "refs/for/master%notify=OWNER", other, EmailStrategy.CC_ON_OWN_COMMENTS);
    // TODO(logan): This email shouldn't come from the owner, and that's why
    // no email is currently sent (owner isn't CCing self).
    assertThat(sender).notSent();
}
#end_block

#method_before
@Test
public void newPatchSetByOtherOnReviewableChangeNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange(NEW_PATCHSETS);
    pushTo(sc, "refs/for/master%notify=NONE", other);
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetByOtherOnReviewableChangeNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange(NEW_PATCHSETS);
    pushTo(sc, "refs/for/master%notify=NONE", other);
    // TODO(logan): This email shouldn't come from the owner, and that's why
    // no email is currently sent (owner isn't CCing self).
    assertThat(sender).notSent();
}
#end_block

#method_before
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(db, rp.getRepository(), obj)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        actualCommands.add(cmd);
    } else {
        reject(cmd, "prohibited by Gerrit: create access denied for " + cmd.getRefName());
    }
}
#method_after
private void parseCreate(ReceiveCommand cmd) throws PermissionBackendException {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    boolean ok;
    try {
        permissions.ref(cmd.getRefName()).check(RefPermission.CREATE);
        ok = true;
    } catch (AuthException err) {
        ok = false;
    }
    if (ok && ctl.canCreate(rp.getRepository(), obj)) {
        if (!validRefOperation(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        actualCommands.add(cmd);
    } else {
        reject(cmd, "prohibited by Gerrit: create access denied for " + cmd.getRefName());
    }
}
#end_block

#method_before
@Option(name = "--message", aliases = { "-m" }, metaVar = "MESSAGE", usage = "Comment message to apply to the review")
void addMessage(final String token) {
    // git push does not allow spaces in refs.
    message = token.replace("_", " ");
}
#method_after
@Option(name = "--message", aliases = { "-m" }, metaVar = "MESSAGE", usage = "Comment message to apply to the review")
void addMessage(String token) {
    // git push does not allow spaces in refs.
    message = token.replace("_", " ");
}
#end_block

#method_before
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(user, cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (projectControl.getProject().getState() != com.google.gerrit.extensions.client.ProjectState.ACTIVE) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef(MagicBranch.NEW_DRAFT_CHANGE + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isPrivate && magicBranch.removePrivate) {
        reject(cmd, "the options 'private' and 'remove-private' are mutually exclusive");
        return;
    }
    if (magicBranch.workInProgress && magicBranch.ready) {
        reject(cmd, "the options 'wip' and 'ready' are mutually exclusive");
        return;
    }
    if (magicBranch.publishComments && magicBranch.noPublishComments) {
        reject(cmd, "the options 'publish-comments' and 'no-publish-comments' are mutually exclusive");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit(true)) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    String destBranch = magicBranch.dest.get();
    try {
        if (magicBranch.merged) {
            if (magicBranch.draft) {
                reject(cmd, "cannot be draft & merged");
                return;
            }
            if (magicBranch.base != null) {
                reject(cmd, "cannot use merged with base");
                return;
            }
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            if (!walk.isMergedInto(tip, branchTip)) {
                reject(cmd, "not merged into branch");
                return;
            }
        }
        // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
        if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
            logDebug("Forcing newChangeForAllNotInTarget = false");
            newChangeForAllNotInTarget = false;
        }
        if (magicBranch.base != null) {
            logDebug("Handling %base: {}", magicBranch.base);
            magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
            for (ObjectId id : magicBranch.base) {
                try {
                    magicBranch.baseCommit.add(walk.parseCommit(id));
                } catch (IncorrectObjectTypeException notCommit) {
                    reject(cmd, "base must be a commit");
                    return;
                } catch (MissingObjectException e) {
                    reject(cmd, "base not found");
                    return;
                } catch (IOException e) {
                    logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                    reject(cmd, "internal server error");
                    return;
                }
            }
        } else if (newChangeForAllNotInTarget) {
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            magicBranch.baseCommit = Collections.singletonList(branchTip);
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        }
    } catch (IOException ex) {
        logWarn(String.format("Error walking to %s in project %s", destBranch, project.getName()), ex);
        reject(cmd, "internal server error");
        return;
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) throws PermissionBackendException {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(user, cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    magicBranch.perm = permissions.ref(ref);
    if (projectControl.getProject().getState() != com.google.gerrit.extensions.client.ProjectState.ACTIVE) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef(MagicBranch.NEW_DRAFT_CHANGE + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    try {
        magicBranch.perm.check(RefPermission.CREATE_CHANGE);
    } catch (AuthException denied) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, denied.getMessage());
        return;
    }
    if (magicBranch.isPrivate && magicBranch.removePrivate) {
        reject(cmd, "the options 'private' and 'remove-private' are mutually exclusive");
        return;
    }
    if (magicBranch.workInProgress && magicBranch.ready) {
        reject(cmd, "the options 'wip' and 'ready' are mutually exclusive");
        return;
    }
    if (magicBranch.publishComments && magicBranch.noPublishComments) {
        reject(cmd, "the options 'publish-comments' and 'no-publish-comments' are mutually exclusive");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit) {
        try {
            permissions.ref(ref).check(RefPermission.UPDATE_BY_SUBMIT);
        } catch (AuthException e) {
            reject(cmd, e.getMessage());
            return;
        }
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    String destBranch = magicBranch.dest.get();
    try {
        if (magicBranch.merged) {
            if (magicBranch.draft) {
                reject(cmd, "cannot be draft & merged");
                return;
            }
            if (magicBranch.base != null) {
                reject(cmd, "cannot use merged with base");
                return;
            }
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            if (!walk.isMergedInto(tip, branchTip)) {
                reject(cmd, "not merged into branch");
                return;
            }
        }
        // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
        if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
            logDebug("Forcing newChangeForAllNotInTarget = false");
            newChangeForAllNotInTarget = false;
        }
        if (magicBranch.base != null) {
            logDebug("Handling %base: {}", magicBranch.base);
            magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
            for (ObjectId id : magicBranch.base) {
                try {
                    magicBranch.baseCommit.add(walk.parseCommit(id));
                } catch (IncorrectObjectTypeException notCommit) {
                    reject(cmd, "base must be a commit");
                    return;
                } catch (MissingObjectException e) {
                    reject(cmd, "base not found");
                    return;
                } catch (IOException e) {
                    logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                    reject(cmd, "internal server error");
                    return;
                }
            }
        } else if (newChangeForAllNotInTarget) {
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            magicBranch.baseCommit = Collections.singletonList(branchTip);
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        }
    } catch (IOException ex) {
        logWarn(String.format("Error walking to %s in project %s", destBranch, project.getName()), ex);
        reject(cmd, "internal server error");
        return;
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    ListMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return;
        }
        LinkedHashMap<RevCommit, ChangeLookup> pending = new LinkedHashMap<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            rp.getRevWalk().parseBody(c);
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            boolean commitAlreadyTracked = !existingRefs.isEmpty();
            if (commitAlreadyTracked) {
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            String idStr = !idList.isEmpty() ? idList.get(idList.size() - 1).trim() : null;
            if (idStr != null) {
                pending.put(c, new ChangeLookup(c, new Change.Key(idStr)));
            } else {
                pending.put(c, new ChangeLookup(c));
            }
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
            if (commitAlreadyTracked) {
                boolean changeExistsOnDestBranch = false;
                for (ChangeData cd : pending.get(c).destChanges) {
                    if (cd.change().getDest().equals(magicBranch.dest)) {
                        changeExistsOnDestBranch = true;
                        break;
                    }
                }
                if (changeExistsOnDestBranch) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.values().iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (p.changeKey == null) {
                continue;
            }
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in branch {} with Change-Id {}: {}", magicBranch.dest, p.changeKey, changes.stream().map(cd -> cd.getId().toString()).collect(joining()));
                // WTF, multiple changes in this branch have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique per branch.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                // double check against the existing refs
                if (foundInExistingRef(existing.get(p.commit))) {
                    if (pending.size() == 1) {
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                        newChanges = Collections.emptyList();
                        return;
                    }
                    itr.remove();
                    continue;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    ListMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return;
        }
        LinkedHashMap<RevCommit, ChangeLookup> pending = new LinkedHashMap<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            rp.getRevWalk().parseBody(c);
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            boolean commitAlreadyTracked = !existingRefs.isEmpty();
            if (commitAlreadyTracked) {
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            String idStr = !idList.isEmpty() ? idList.get(idList.size() - 1).trim() : null;
            if (idStr != null) {
                pending.put(c, new ChangeLookup(c, new Change.Key(idStr)));
            } else {
                pending.put(c, new ChangeLookup(c));
            }
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
            if (commitAlreadyTracked) {
                boolean changeExistsOnDestBranch = false;
                for (ChangeData cd : pending.get(c).destChanges) {
                    if (cd.change().getDest().equals(magicBranch.dest)) {
                        changeExistsOnDestBranch = true;
                        break;
                    }
                }
                if (changeExistsOnDestBranch) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.perm, magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.values().iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (p.changeKey == null) {
                continue;
            }
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in branch {} with Change-Id {}: {}", magicBranch.dest, p.changeKey, changes.stream().map(cd -> cd.getId().toString()).collect(joining()));
                // WTF, multiple changes in this branch have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique per branch.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                // double check against the existing refs
                if (foundInExistingRef(existing.get(p.commit))) {
                    if (pending.size() == 1) {
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                        newChanges = Collections.emptyList();
                        return;
                    }
                    itr.remove();
                    continue;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException, PermissionBackendException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (notes == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    Change change = notes.getChange();
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    try {
        permissions.change(notes).database(db).check(ChangePermission.ADD_PATCH_SET);
    } catch (AuthException no) {
        String locked = ".";
        if (projectControl.controlFor(notes).isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot add patch set to " + ontoChange + locked);
        return false;
    }
    if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    ChangeControl changeCtl = projectControl.controlFor(notes);
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException, PermissionBackendException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (notes == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    Change change = notes.getChange();
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    try {
        permissions.change(notes).database(db).check(ChangePermission.ADD_PATCH_SET);
    } catch (AuthException no) {
        String locked = ".";
        if (projectControl.controlFor(notes).isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot add patch set to " + ontoChange + locked);
        return false;
    }
    if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    PermissionBackend.ForRef perm = permissions.ref(change.getDest().get());
    RefControl refctl = projectControl.controlForRef(change.getDest());
    if (!validCommit(rp.getRevWalk(), perm, refctl, inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        logDebug("Short-circuiting new commit validation");
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        ListMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        int i = 0;
        for (RevCommit c; (c = walk.next()) != null; ) {
            i++;
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    logWarn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
        logDebug("Validated {} new commits", i);
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) throws PermissionBackendException {
    PermissionBackend.ForRef perm = permissions.ref(ctl.getRefName());
    if (!RefNames.REFS_CONFIG.equals(cmd.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches()) && pushOptions.containsKey(BYPASS_REVIEW)) {
        try {
            perm.check(RefPermission.BYPASS_REVIEW);
            if (!Iterables.isEmpty(rejectCommits)) {
                throw new AuthException("reject-commits prevents " + BYPASS_REVIEW);
            }
            logDebug("Short-circuiting new commit validation");
        } catch (AuthException denied) {
            reject(cmd, denied.getMessage());
        }
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        ListMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        int i = 0;
        for (RevCommit c; (c = walk.next()) != null; ) {
            i++;
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, perm, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = accounts.get(db, user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        accountsUpdate.create().update(db, a);
                        user.getAccount().setFullName(a.getFullName());
                    }
                } catch (OrmException e) {
                    logWarn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
        logDebug("Validated {} new commits", i);
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    try (CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), rw.getObjectReader(), c, user)) {
        boolean isMerged = magicBranch != null && cmd.getRefName().equals(magicBranch.cmd.getRefName()) && magicBranch.merged;
        CommitValidators validators = isMerged ? commitValidatorsFactory.forMergedCommits(ctl) : commitValidatorsFactory.forReceiveCommits(ctl, sshInfo, repo, rw);
        messages.addAll(validators.validate(receiveEvent));
    } catch (CommitValidationException e) {
        logDebug("Commit validation failed on {}", c.name());
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#method_after
private boolean validCommit(RevWalk rw, PermissionBackend.ForRef perm, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    try (CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), rw.getObjectReader(), c, user)) {
        boolean isMerged = magicBranch != null && cmd.getRefName().equals(magicBranch.cmd.getRefName()) && magicBranch.merged;
        CommitValidators validators = isMerged ? commitValidatorsFactory.forMergedCommits(perm, ctl) : commitValidatorsFactory.forReceiveCommits(perm, ctl, sshInfo, repo, rw);
        messages.addAll(validators.validate(receiveEvent));
    } catch (CommitValidationException e) {
        logDebug("Commit validation failed on {}", c.name());
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    logDebug("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        ListMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        int existingPatchSets = 0;
        int newPatchSets = 0;
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                existingPatchSets++;
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    newPatchSets++;
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (final ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                logDebug("Not closing {} because validation failed", id);
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        logDebug("Auto-closing {} changes with existing patch sets and {} with new patch sets", existingPatchSets, newPatchSets);
        bu.execute();
    } catch (RestApiException e) {
        logError("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException | PermissionBackendException e) {
        logError("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(ReceiveCommand cmd) {
    logDebug("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        ListMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        int existingPatchSets = 0;
        int newPatchSets = 0;
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                existingPatchSets++;
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    newPatchSets++;
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                logDebug("Not closing {} because validation failed", id);
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        logDebug("Auto-closing {} changes with existing patch sets and {} with new patch sets", existingPatchSets, newPatchSets);
        bu.execute();
    } catch (RestApiException e) {
        logError("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException | PermissionBackendException e) {
        logError("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
public FakeEmailSenderSubject sent(String messageType, StagedUsers users) {
    message = actual().nextMessage();
    if (message == null) {
        fail("a message was sent");
    }
    recipients = new HashMap<>();
    recipients.put(TO, parseAddresses(message, "To"));
    recipients.put(CC, parseAddresses(message, "CC"));
    recipients.put(BCC, message.rcpt().stream().map(Address::getEmail).filter(e -> !recipients.get(TO).contains(e) && !recipients.get(CC).contains(e)).collect(Collectors.toList()));
    this.users = users;
    if (!message.headers().containsKey("X-Gerrit-MessageType")) {
        fail("a message was sent with X-Gerrit-MessageType header");
    }
    EmailHeader header = message.headers().get("X-Gerrit-MessageType");
    if (!header.equals(new EmailHeader.String(messageType))) {
        fail("message of type " + messageType + " was sent; X-Gerrit-MessageType is " + header);
    }
    // Return a named subject that displays a human-readable table of
    // recipients.
    StringBuilder buf = new StringBuilder();
    buf.append('[');
    for (RecipientType type : ImmutableList.of(TO, CC, BCC)) {
        buf.append('\n');
        buf.append(type);
        buf.append(':');
        String delim = " ";
        for (String r : recipients.get(type)) {
            buf.append(delim);
            buf.append(stripUniqueSuffix(r));
            delim = ", ";
        }
    }
    buf.append("\n]");
    return named(buf.toString());
}
#method_after
public FakeEmailSenderSubject sent(String messageType, StagedUsers users) {
    message = actual().nextMessage();
    if (message == null) {
        fail("a message was sent");
    }
    recipients = new HashMap<>();
    recipients.put(TO, parseAddresses(message, "To"));
    recipients.put(CC, parseAddresses(message, "CC"));
    recipients.put(BCC, message.rcpt().stream().map(Address::getEmail).filter(e -> !recipients.get(TO).contains(e) && !recipients.get(CC).contains(e)).collect(Collectors.toList()));
    this.users = users;
    if (!message.headers().containsKey("X-Gerrit-MessageType")) {
        fail("a message was sent with X-Gerrit-MessageType header");
    }
    EmailHeader header = message.headers().get("X-Gerrit-MessageType");
    if (!header.equals(new EmailHeader.String(messageType))) {
        fail("message of type " + messageType + " was sent; X-Gerrit-MessageType is " + header);
    }
    // Return a named subject that displays a human-readable table of
    // recipients.
    StringBuilder buf = new StringBuilder();
    buf.append('[');
    for (RecipientType type : ImmutableList.of(TO, CC, BCC)) {
        buf.append('\n');
        buf.append(type);
        buf.append(':');
        String delim = " ";
        for (String r : recipients.get(type)) {
            buf.append(delim);
            buf.append(users.emailToName(r));
            delim = ", ";
        }
    }
    buf.append("\n]");
    return named(buf.toString());
}
#end_block

#method_before
private void rcpt(@Nullable RecipientType type, String email, boolean expected) {
    if (recipients.get(type).contains(email) != expected) {
        fail(expected ? "notifies" : "doesn't notify", "]\n" + type + ": " + stripUniqueSuffix(email) + "\n]");
    }
}
#method_after
private void rcpt(@Nullable RecipientType type, String email, boolean expected) {
    if (recipients.get(type).contains(email) != expected) {
        fail(expected ? "notifies" : "doesn't notify", "]\n" + type + ": " + users.emailToName(email) + "\n]");
    }
}
#end_block

#method_before
public TestAccount testAccount(String name) throws Exception {
    name = withUniqueSuffix(name);
    return accounts.create(name, name + "@example.com", name);
}
#method_after
public TestAccount testAccount(String name) throws Exception {
    String username = name(name);
    TestAccount account = accountCreator.create(username, email(username), name);
    accountsByEmail.put(account.email, account);
    return account;
}
#end_block

#method_before
public TestAccount testAccount(String name, String groupName) throws Exception {
    name = withUniqueSuffix(name);
    return accounts.create(name, name + "@example.com", name, groupName);
}
#method_after
public TestAccount testAccount(String name, String groupName) throws Exception {
    String username = name(name);
    TestAccount account = accountCreator.create(username, email(username), name, groupName);
    accountsByEmail.put(account.email, account);
    return account;
}
#end_block

#method_before
public void addReviewers(final Collection<Account.Id> cc) {
    reviewers.addAll(cc);
}
#method_after
public void addReviewers(Collection<Account.Id> cc) {
    reviewers.addAll(cc);
}
#end_block

#method_before
public void addExtraCC(final Collection<Account.Id> cc) {
    extraCC.addAll(cc);
}
#method_after
public void addExtraCC(Collection<Account.Id> cc) {
    extraCC.addAll(cc);
}
#end_block

#method_before
@Override
protected void init() throws EmailException {
    super.init();
    if (fromId != null) {
        // Don't call yourself a reviewer of your own patch set.
        // 
        reviewers.remove(fromId);
    }
    if (notify.equals(NotifyHandling.ALL) || notify.equals(NotifyHandling.OWNER_REVIEWERS)) {
        add(RecipientType.TO, reviewers);
        add(RecipientType.CC, extraCC);
    }
    rcptToAuthors(RecipientType.CC);
    bccStarredBy();
    includeWatchers(NotifyType.NEW_PATCHSETS, !patchSet.isDraft() && !change.isWorkInProgress() && !change.isPrivate());
    removeUsersThatIgnoredTheChange();
}
#method_after
@Override
protected void init() throws EmailException {
    super.init();
    if (fromId != null) {
        // Don't call yourself a reviewer of your own patch set.
        // 
        reviewers.remove(fromId);
    }
    if (notify == NotifyHandling.ALL || notify == NotifyHandling.OWNER_REVIEWERS) {
        add(RecipientType.TO, reviewers);
        add(RecipientType.CC, extraCC);
    }
    rcptToAuthors(RecipientType.CC);
    bccStarredBy();
    includeWatchers(NotifyType.NEW_PATCHSETS, !patchSet.isDraft() && !change.isWorkInProgress() && !change.isPrivate());
    removeUsersThatIgnoredTheChange();
}
#end_block

#method_before
@Before
public void createOther() throws Exception {
    other = accounts.create("other", "other@example.com", "other");
}
#method_after
@Before
public void createOther() throws Exception {
    other = accountCreator.create("other", "other@example.com", "other");
}
#end_block

#method_before
@Before
public void createExtraAccount() throws Exception {
    extraReviewer = accounts.create("extraReviewer", "extraReviewer@example.com", "extraReviewer");
    extraCcer = accounts.create("extraCcer", "extraCcer@example.com", "extraCcer");
}
#method_after
@Before
public void createExtraAccount() throws Exception {
    extraReviewer = accountCreator.create("extraReviewer", "extraReviewer@example.com", "extraReviewer");
    extraCcer = accountCreator.create("extraCcer", "extraCcer@example.com", "extraCcer");
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER);
    assertThat(sender).sent("deleteReviewer", sc).notTo(sc.owner).to(extraReviewer).notTo(extraCcer, sc.reviewer, sc.ccer).notTo(sc.reviewerByEmail, sc.ccerByEmail).notTo(sc.starrer).notTo(ALL_COMMENTS);
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).notTo(extraCcer, sc.owner, sc.reviewer, sc.ccer).notTo(sc.reviewerByEmail, sc.ccerByEmail).notTo(sc.starrer).notTo(ALL_COMMENTS);
}
#end_block

#method_before
@Test
public void deleteReviewerFromWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).notTo(sc.owner).to(extraReviewer).to(// TODO(logan): This should probably be CC.
    sc.reviewerByEmail).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS);
}
#method_after
@Test
public void deleteReviewerFromWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    removeReviewer(sc, extraReviewer);
    // TODO(logan): This should behave like notify=OWNER
    assertThat(sender).sent("deleteReviewer", sc).notTo(sc.owner).to(extraReviewer).to(// TODO(logan): This should probably be CC.
    sc.reviewerByEmail).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS);
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOwner() throws Exception {
    StagedChange sc = stageReviewableChange(ALL_COMMENTS, REVIEW_STARTED_CHANGES);
    setApiUser(sc.owner);
    review(sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).notTo(sc.owner).to(// TODO(logan): This is unintentionally TO, should be CC.
    sc.reviewerByEmail).cc(sc.reviewer, sc.ccer).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS, REVIEW_STARTED_CHANGES);
}
#method_after
@Test
public void commentOnReviewableChangeByOwner() throws Exception {
    StagedChange sc = stageReviewableChange(ALL_COMMENTS);
    setApiUser(sc.owner);
    review(sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).notTo(sc.owner).to(// TODO(logan): This is unintentionally TO, should be CC.
    sc.reviewerByEmail).cc(sc.reviewer, sc.ccer).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS);
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByReviewer() throws Exception {
    StagedChange sc = stageReviewableChange(ALL_COMMENTS, REVIEW_STARTED_CHANGES);
    setApiUser(sc.reviewer);
    review(sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).notTo(sc.reviewer).to(sc.owner).to(// TODO(logan): This is unintentionally TO, should be CC.
    sc.reviewerByEmail).cc(sc.ccer).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS, REVIEW_STARTED_CHANGES);
}
#method_after
@Test
public void commentOnReviewableChangeByReviewer() throws Exception {
    StagedChange sc = stageReviewableChange(ALL_COMMENTS);
    setApiUser(sc.reviewer);
    review(sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).notTo(sc.reviewer).to(sc.owner).to(// TODO(logan): This is unintentionally TO, should be CC.
    sc.reviewerByEmail).cc(sc.ccer).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS);
}
#end_block

#method_before
private void review(String changeId, EmailStrategy strategy) throws Exception {
    GeneralPreferencesInfo prefs = gApi.accounts().self().getPreferences();
    prefs.emailStrategy = strategy;
    gApi.accounts().self().setPreferences(prefs);
    gApi.changes().id(changeId).revision("current").review(ReviewInput.recommend());
}
#method_after
private void review(String changeId, EmailStrategy strategy) throws Exception {
    review(changeId, strategy, null);
}
#end_block

#method_before
private void review(String changeId, EmailStrategy strategy) throws Exception {
    GeneralPreferencesInfo prefs = gApi.accounts().self().getPreferences();
    prefs.emailStrategy = strategy;
    gApi.accounts().self().setPreferences(prefs);
    gApi.changes().id(changeId).revision("current").review(ReviewInput.recommend());
}
#method_after
private void review(String changeId, EmailStrategy strategy, @Nullable NotifyHandling notify) throws Exception {
    GeneralPreferencesInfo prefs = gApi.accounts().self().getPreferences();
    prefs.emailStrategy = strategy;
    gApi.accounts().self().setPreferences(prefs);
    ReviewInput in = ReviewInput.recommend();
    in.notify = notify;
    gApi.changes().id(changeId).revision("current").review(in);
}
#end_block

#method_before
private Adder singly() {
    return (String changeId, String reviewer) -> gApi.changes().id(changeId).addReviewer(reviewer);
}
#method_after
private Adder singly() {
    return (String changeId, String reviewer, @Nullable NotifyHandling notify) -> {
        AddReviewerInput in = new AddReviewerInput();
        in.reviewer = reviewer;
        if (notify != null) {
            in.notify = notify;
        }
        gApi.changes().id(changeId).addReviewer(in);
    };
}
#end_block

#method_before
private Adder batch() {
    return (String changeId, String reviewer) -> {
        ReviewInput in = ReviewInput.noScore();
        in.reviewer(reviewer);
        gApi.changes().id(changeId).revision("current").review(in);
    };
}
#method_after
private Adder batch() {
    return (String changeId, String reviewer, @Nullable NotifyHandling notify) -> {
        ReviewInput in = ReviewInput.noScore();
        in.reviewer(reviewer);
        if (notify != null) {
            in.notify = notify;
        }
        gApi.changes().id(changeId).revision("current").review(in);
    };
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeInReviewDb() throws Exception {
    forAll(adder -> {
        assume().that(notesMigration.enabled()).isFalse();
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accounts.create("added", "added@example.com", "added");
        adder.addReviewer(sc.changeId, reviewer.email);
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).notTo(sc.owner, sc.starrer);
    });
}
#method_after
@Test
public void addReviewerToReviewableChangeInReviewDb() throws Exception {
    forAll(adder -> {
        assume().that(notesMigration.readChanges()).isFalse();
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
        assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).notTo(sc.owner, sc.starrer);
    });
}
#end_block

#method_before
@Test
public void addReviewerToReviewableChangeInNoteDb() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accounts.create("added", "added@example.com", "added");
        addReviewer(singly(), sc.changeId, reviewer.email);
        // TODO(logan): Existing reviewers by email should be CC.
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(reviewer).to(sc.reviewerByEmail).cc(sc.reviewer).cc(sc.ccerByEmail).notTo(sc.owner, sc.starrer);
    });
}
#method_after
@Test
public void addReviewerToReviewableChangeInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    forAll(adder -> {
        StagedChange sc = stageReviewableChange();
        TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
        addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
        // TODO(logan): Existing reviewers by email should be CC.
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(reviewer).to(sc.reviewerByEmail).cc(sc.reviewer).cc(sc.ccerByEmail).notTo(sc.owner, sc.starrer);
    });
}
#end_block

#method_before
@Test
public void addReviewerByEmailToReviewableChangeInReviewDb() throws Exception {
    assume().that(notesMigration.enabled()).isFalse();
    forAll(adder -> {
        String email = "addedbyemail@example.com";
        StagedChange sc = stageReviewableChange();
        addReviewer(singly(), sc.changeId, email);
        assertThat(sender).notSent();
    });
}
#method_after
@Test
public void addReviewerByEmailToReviewableChangeInReviewDb() throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    forAll(adder -> {
        String email = "addedbyemail@example.com";
        StagedChange sc = stageReviewableChange();
        addReviewer(adder, sc.changeId, sc.owner, email);
        assertThat(sender).notSent();
    });
}
#end_block

#method_before
@Test
public void addReviewerByEmailToReviewableChangeInNoteDb() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    forAll(adder -> {
        String email = "addedbyemail@example.com";
        StagedChange sc = stageReviewableChange();
        addReviewer(singly(), sc.changeId, email);
        // TODO(logan): Existing reviewers by email should be CC.
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(email, sc.reviewerByEmail).cc(sc.reviewer).cc(sc.ccerByEmail).notTo(sc.owner, sc.starrer);
    });
}
#method_after
@Test
public void addReviewerByEmailToReviewableChangeInNoteDb() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    forAll(adder -> {
        String email = "addedbyemail@example.com";
        StagedChange sc = stageReviewableChange();
        addReviewer(adder, sc.changeId, sc.owner, email);
        // TODO(logan): Existing reviewers by email should be CC.
        // TODO(logan): Should CCs be included?
        assertThat(sender).sent("newchange", sc).to(email, sc.reviewerByEmail).cc(sc.reviewer).cc(sc.ccerByEmail).notTo(sc.owner, sc.starrer);
    });
}
#end_block

#method_before
private void addReviewer(Adder adder, String changeId, String reviewer) throws Exception {
    adder.addReviewer(changeId, reviewer);
}
#method_after
private void addReviewer(Adder adder, String changeId, TestAccount by, String reviewer) throws Exception {
    addReviewer(adder, changeId, by, reviewer, EmailStrategy.ENABLED, null);
}
#end_block

#method_before
@Test
public void abandonReviewableChangeNotifyOwnersReviewers() throws Exception {
    StagedChange sc = stageReviewableChange(ABANDONED_CHANGES, REVIEW_STARTED_CHANGES);
    abandon(sc.changeId, OWNER_REVIEWERS);
    assertThat(sender).sent("abandon", sc).notTo(sc.owner, sc.starrer).cc(sc.reviewer, sc.ccer).to(// TODO(logan): This is unintentionally TO, should be CC.
    sc.reviewerByEmail).cc(sc.ccerByEmail).notTo(ABANDONED_CHANGES, REVIEW_STARTED_CHANGES);
}
#method_after
@Test
public void abandonReviewableChangeNotifyOwnersReviewers() throws Exception {
    StagedChange sc = stageReviewableChange(ABANDONED_CHANGES);
    abandon(sc.changeId, sc.owner, OWNER_REVIEWERS);
    assertThat(sender).sent("abandon", sc).notTo(sc.owner, sc.starrer).cc(sc.reviewer, sc.ccer).to(// TODO(logan): This is unintentionally TO, should be CC.
    sc.reviewerByEmail).cc(sc.ccerByEmail).notTo(ABANDONED_CHANGES);
}
#end_block

#method_before
@Test
public void abandonReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange(ABANDONED_CHANGES, REVIEW_STARTED_CHANGES);
    abandon(sc.changeId, OWNER);
    assertThat(sender).notSent();
}
#method_after
@Test
public void abandonReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange(ABANDONED_CHANGES);
    abandon(sc.changeId, sc.owner, OWNER);
    assertThat(sender).notSent();
}
#end_block

#method_before
@Test
public void abandonReviewableWipChange() throws Exception {
    StagedChange sc = stageReviewableWipChange(ABANDONED_CHANGES, REVIEW_STARTED_CHANGES);
    abandon(sc.changeId);
    assertThat(sender).sent("abandon", sc).notTo(sc.owner).cc(sc.reviewer, sc.ccer).to(// TODO(logan): This is unintentionally TO, should be CC.
    sc.reviewerByEmail).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES, REVIEW_STARTED_CHANGES);
}
#method_after
@Test
public void abandonReviewableWipChange() throws Exception {
    StagedChange sc = stageReviewableWipChange(ABANDONED_CHANGES);
    abandon(sc.changeId, sc.owner);
    assertThat(sender).sent("abandon", sc).notTo(sc.owner).cc(sc.reviewer, sc.ccer).to(// TODO(logan): This is unintentionally TO, should be CC.
    sc.reviewerByEmail).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES);
}
#end_block

#method_before
private void abandon(String changeId, NotifyHandling notify) throws Exception {
    AbandonInput in = new AbandonInput();
    in.notify = notify;
    gApi.changes().id(changeId).abandon(in);
}
#method_after
private void abandon(String changeId, TestAccount by) throws Exception {
    abandon(changeId, by, EmailStrategy.ENABLED);
}
#end_block

#method_before
protected void beforeTest(Description description) throws Exception {
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setString("gerrit", null, "tempSiteDir", tempSiteDir.getRoot().getPath());
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.start(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.start(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    admin = accounts.admin();
    user = accounts.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    db = reviewDbProvider.open();
    if (classDesc.useSsh() || methodDesc.useSsh()) {
        useSsh = true;
        if (SshMode.useSsh() && (adminSshSession == null || userSshSession == null)) {
            // Create Ssh sessions
            initSsh(admin);
            Context ctx = newRequestContext(user);
            atrScope.set(ctx);
            userSshSession = ctx.getSession();
            userSshSession.open();
            ctx = newRequestContext(admin);
            atrScope.set(ctx);
            adminSshSession = ctx.getSession();
            adminSshSession.open();
        }
    } else {
        useSsh = false;
    }
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#method_after
protected void beforeTest(Description description) throws Exception {
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setString("gerrit", null, "tempSiteDir", tempSiteDir.getRoot().getPath());
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.start(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.start(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    admin = accountCreator.admin();
    user = accountCreator.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    db = reviewDbProvider.open();
    if (classDesc.useSsh() || methodDesc.useSsh()) {
        useSsh = true;
        if (SshMode.useSsh() && (adminSshSession == null || userSshSession == null)) {
            // Create Ssh sessions
            initSsh(admin);
            Context ctx = newRequestContext(user);
            atrScope.set(ctx);
            userSshSession = ctx.getSession();
            userSshSession.open();
            ctx = newRequestContext(admin);
            atrScope.set(ctx);
            adminSshSession = ctx.getSession();
            adminSshSession.open();
        }
    } else {
        useSsh = false;
    }
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#end_block

#method_before
private TestAccount getCloneAsAccount(Description description) {
    TestProjectInput ann = description.getAnnotation(TestProjectInput.class);
    return accounts.get(ann != null ? ann.cloneAs() : "admin");
}
#method_after
private TestAccount getCloneAsAccount(Description description) {
    TestProjectInput ann = description.getAnnotation(TestProjectInput.class);
    return accountCreator.get(ann != null ? ann.cloneAs() : "admin");
}
#end_block

#method_before
public void notSent() {
    if (messages.hasNext()) {
        fail("a message wasn't sent");
    }
}
#method_after
public FakeEmailSenderSubject notSent() {
    if (actual().peekMessage() != null) {
        fail("a message wasn't sent");
    }
    return this;
}
#end_block

#method_before
public NotificationsSubject sent(String messageType, StagedUsers users) {
    if (!messages.hasNext()) {
        fail("a message was sent");
    }
    Message msg = messages.next();
    if (!msg.headers().containsKey("X-Gerrit-MessageType")) {
        fail("a message was sent with X-Gerrit-MessageType header");
    }
    EmailHeader header = msg.headers().get("X-Gerrit-MessageType");
    if (!header.equals(new EmailHeader.String(messageType))) {
        fail("message of type " + messageType + " was sent; X-Gerrit-MessageType is " + header);
    }
    return assertThat(new Notifications(msg, users));
}
#method_after
public FakeEmailSenderSubject sent(String messageType, StagedUsers users) {
    message = actual().nextMessage();
    if (message == null) {
        fail("a message was sent");
    }
    recipients = new HashMap<>();
    recipients.put(TO, parseAddresses(message, "To"));
    recipients.put(CC, parseAddresses(message, "CC"));
    recipients.put(BCC, message.rcpt().stream().map(Address::getEmail).filter(e -> !recipients.get(TO).contains(e) && !recipients.get(CC).contains(e)).collect(Collectors.toList()));
    this.users = users;
    if (!message.headers().containsKey("X-Gerrit-MessageType")) {
        fail("a message was sent with X-Gerrit-MessageType header");
    }
    EmailHeader header = message.headers().get("X-Gerrit-MessageType");
    if (!header.equals(new EmailHeader.String(messageType))) {
        fail("message of type " + messageType + " was sent; X-Gerrit-MessageType is " + header);
    }
    // Return a named subject that displays a human-readable table of
    // recipients.
    StringBuilder buf = new StringBuilder();
    buf.append('[');
    for (RecipientType type : ImmutableList.of(TO, CC, BCC)) {
        buf.append('\n');
        buf.append(type);
        buf.append(':');
        String delim = " ";
        for (String r : recipients.get(type)) {
            buf.append(delim);
            buf.append(users.emailToName(r));
            delim = ", ";
        }
    }
    buf.append("\n]");
    return named(buf.toString());
}
#end_block

#method_before
TestAccount testAccount(String name) throws Exception {
    return accounts.create(name, name + "@example.com", name);
}
#method_after
TestAccount testAccount(String name) throws Exception {
    String username = name(name);
    TestAccount account = accountCreator.create(username, email(username), name);
    accountsByEmail.put(account.email, account);
    return account;
}
#end_block

#method_before
TestAccount testAccount(String name, String groupName) throws Exception {
    return accounts.create(name, name + "@example.com", name, groupName);
}
#method_after
TestAccount testAccount(String name, String groupName) throws Exception {
    String username = name(name);
    TestAccount account = accountCreator.create(username, email(username), name, groupName);
    accountsByEmail.put(account.email, account);
    return account;
}
#end_block

#method_before
protected StagedPreChange stagePreChange(String ref, NotifyType... watches) throws Exception {
    return new StagedPreChange(ref, ImmutableList.copyOf(watches));
}
#method_after
protected StagedPreChange stagePreChange(String ref, @Nullable PushOptionGenerator pushOptionGenerator, NotifyType... watches) throws Exception {
    return new StagedPreChange(ref, pushOptionGenerator, ImmutableList.copyOf(watches));
}
#end_block

#method_before
@Test
public void watchFile() throws Exception {
    String watchedProject = createProject("watchedProject").get();
    String otherWatchedProject = createProject("otherWatchedProject").get();
    setApiUser(user);
    // watch file in project as user
    watch(watchedProject, "file:a.txt");
    // watch other project as user
    watch(otherWatchedProject);
    // push a change to watched file -> should trigger email notification for
    // user
    setApiUser(admin);
    TestRepository<InMemoryRepository> watchedRepo = cloneProject(new Project.NameKey(watchedProject), admin);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), watchedRepo, "TRIGGER", "a.txt", "a1").to("refs/for/master");
    r.assertOkStatus();
    // assert email notification for user
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
    sender.clear();
    // watch project as user2
    TestAccount user2 = accounts.create("user2", "user2@test.com", "User2");
    setApiUser(user2);
    watch(watchedProject);
    // push a change to non-watched file -> should not trigger email
    // notification for user, only for user2
    r = pushFactory.create(db, admin.getIdent(), watchedRepo, "TRIGGER_USER2", "b.txt", "b1").to("refs/for/master");
    r.assertOkStatus();
    // assert email notification
    messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user2.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER_USER2\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
}
#method_after
@Test
public void watchFile() throws Exception {
    String watchedProject = createProject("watchedProject").get();
    String otherWatchedProject = createProject("otherWatchedProject").get();
    setApiUser(user);
    // watch file in project as user
    watch(watchedProject, "file:a.txt");
    // watch other project as user
    watch(otherWatchedProject);
    // push a change to watched file -> should trigger email notification for
    // user
    setApiUser(admin);
    TestRepository<InMemoryRepository> watchedRepo = cloneProject(new Project.NameKey(watchedProject), admin);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), watchedRepo, "TRIGGER", "a.txt", "a1").to("refs/for/master");
    r.assertOkStatus();
    // assert email notification for user
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
    sender.clear();
    // watch project as user2
    TestAccount user2 = accountCreator.create("user2", "user2@test.com", "User2");
    setApiUser(user2);
    watch(watchedProject);
    // push a change to non-watched file -> should not trigger email
    // notification for user, only for user2
    r = pushFactory.create(db, admin.getIdent(), watchedRepo, "TRIGGER_USER2", "b.txt", "b1").to("refs/for/master");
    r.assertOkStatus();
    // assert email notification
    messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user2.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER_USER2\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
}
#end_block

#method_before
@Test
public void watchFileAllProjects() throws Exception {
    String anyProject = createProject("anyProject").get();
    setApiUser(user);
    // watch file in All-Projects project as user to watch the file in all
    // projects
    watch(allProjects.get(), "file:a.txt");
    // push a change to watched file in any project -> should trigger email
    // notification for user
    setApiUser(admin);
    TestRepository<InMemoryRepository> anyRepo = cloneProject(new Project.NameKey(anyProject), admin);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), anyRepo, "TRIGGER", "a.txt", "a1").to("refs/for/master");
    r.assertOkStatus();
    // assert email notification for user
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
    sender.clear();
    // watch project as user2
    TestAccount user2 = accounts.create("user2", "user2@test.com", "User2");
    setApiUser(user2);
    watch(anyProject);
    // push a change to non-watched file in any project -> should not trigger
    // email notification for user, only for user2
    r = pushFactory.create(db, admin.getIdent(), anyRepo, "TRIGGER_USER2", "b.txt", "b1").to("refs/for/master");
    r.assertOkStatus();
    // assert email notification
    messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user2.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER_USER2\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
}
#method_after
@Test
public void watchFileAllProjects() throws Exception {
    String anyProject = createProject("anyProject").get();
    setApiUser(user);
    // watch file in All-Projects project as user to watch the file in all
    // projects
    watch(allProjects.get(), "file:a.txt");
    // push a change to watched file in any project -> should trigger email
    // notification for user
    setApiUser(admin);
    TestRepository<InMemoryRepository> anyRepo = cloneProject(new Project.NameKey(anyProject), admin);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), anyRepo, "TRIGGER", "a.txt", "a1").to("refs/for/master");
    r.assertOkStatus();
    // assert email notification for user
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
    sender.clear();
    // watch project as user2
    TestAccount user2 = accountCreator.create("user2", "user2@test.com", "User2");
    setApiUser(user2);
    watch(anyProject);
    // push a change to non-watched file in any project -> should not trigger
    // email notification for user, only for user2
    r = pushFactory.create(db, admin.getIdent(), anyRepo, "TRIGGER_USER2", "b.txt", "b1").to("refs/for/master");
    r.assertOkStatus();
    // assert email notification
    messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user2.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER_USER2\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
}
#end_block

#method_before
@Test
public void watchProjectNotifyOnDraftChange() throws Exception {
    String watchedProject = createProject("watchedProject").get();
    // create group that can view all drafts
    GroupInfo groupThatCanViewDrafts = gApi.groups().create("groupThatCanViewDrafts").get();
    grant(new Project.NameKey(watchedProject), "refs/*", Permission.VIEW_DRAFTS, false, new AccountGroup.UUID(groupThatCanViewDrafts.id));
    // watch project as user that can't view drafts
    setApiUser(user);
    watch(watchedProject);
    // watch project as user that can view all drafts
    TestAccount userThatCanViewDrafts = accounts.create("user2", "user2@test.com", "User2", groupThatCanViewDrafts.name);
    setApiUser(userThatCanViewDrafts);
    watch(watchedProject);
    // push a draft change to watched project -> should trigger email notification for
    // userThatCanViewDrafts, but not for user
    setApiUser(admin);
    TestRepository<InMemoryRepository> watchedRepo = cloneProject(new Project.NameKey(watchedProject), admin);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), watchedRepo, "TRIGGER", "a", "a1").to("refs/for/master%draft");
    r.assertOkStatus();
    // assert email notification
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(userThatCanViewDrafts.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
}
#method_after
@Test
public void watchProjectNotifyOnDraftChange() throws Exception {
    String watchedProject = createProject("watchedProject").get();
    // create group that can view all drafts
    GroupInfo groupThatCanViewDrafts = gApi.groups().create("groupThatCanViewDrafts").get();
    grant(new Project.NameKey(watchedProject), "refs/*", Permission.VIEW_DRAFTS, false, new AccountGroup.UUID(groupThatCanViewDrafts.id));
    // watch project as user that can't view drafts
    setApiUser(user);
    watch(watchedProject);
    // watch project as user that can view all drafts
    TestAccount userThatCanViewDrafts = accountCreator.create("user2", "user2@test.com", "User2", groupThatCanViewDrafts.name);
    setApiUser(userThatCanViewDrafts);
    watch(watchedProject);
    // push a draft change to watched project -> should trigger email notification for
    // userThatCanViewDrafts, but not for user
    setApiUser(admin);
    TestRepository<InMemoryRepository> watchedRepo = cloneProject(new Project.NameKey(watchedProject), admin);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), watchedRepo, "TRIGGER", "a", "a1").to("refs/for/master%draft");
    r.assertOkStatus();
    // assert email notification
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(userThatCanViewDrafts.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
}
#end_block

#method_before
@Test
public void deleteAllProjectWatchesIfWatchConfigIsTheOnlyFileInUserBranch() throws Exception {
    // Create account that has no files in its refs/users/ branch.
    Account.Id id = accounts.create().id;
    // Add a project watch so that a watch.config file in the refs/users/ branch is created.
    Map<ProjectWatchKey, Set<NotifyType>> watches = new HashMap<>();
    watches.put(ProjectWatchKey.create(project, "*"), ImmutableSet.of(NotifyType.ALL));
    watchConfig.upsertProjectWatches(id, watches);
    assertThat(watchConfig.getProjectWatches(id)).isNotEmpty();
    // Delete all project watches so that the watch.config file in the refs/users/ branch is
    // deleted.
    watchConfig.deleteAllProjectWatches(id);
    assertThat(watchConfig.getProjectWatches(id)).isEmpty();
}
#method_after
@Test
public void deleteAllProjectWatchesIfWatchConfigIsTheOnlyFileInUserBranch() throws Exception {
    // Create account that has no files in its refs/users/ branch.
    Account.Id id = accountCreator.create().id;
    // Add a project watch so that a watch.config file in the refs/users/ branch is created.
    Map<ProjectWatchKey, Set<NotifyType>> watches = new HashMap<>();
    watches.put(ProjectWatchKey.create(project, "*"), ImmutableSet.of(NotifyType.ALL));
    watchConfig.upsertProjectWatches(id, watches);
    assertThat(watchConfig.getProjectWatches(id)).isNotEmpty();
    // Delete all project watches so that the watch.config file in the refs/users/ branch is
    // deleted.
    watchConfig.deleteAllProjectWatches(id);
    assertThat(watchConfig.getProjectWatches(id)).isEmpty();
}
#end_block

#method_before
@Test
public void watchProjectNotifyOnPrivateChange() throws Exception {
    String watchedProject = createProject("watchedProject").get();
    // create group that can view all private changes
    GroupInfo groupThatCanViewPrivateChanges = gApi.groups().create("groupThatCanViewPrivateChanges").get();
    grant(new Project.NameKey(watchedProject), "refs/*", Permission.VIEW_PRIVATE_CHANGES, false, new AccountGroup.UUID(groupThatCanViewPrivateChanges.id));
    // watch project as user that can't view private changes
    setApiUser(user);
    watch(watchedProject);
    // watch project as user that can view all private change
    TestAccount userThatCanViewPrivateChanges = accounts.create("user2", "user2@test.com", "User2", groupThatCanViewPrivateChanges.name);
    setApiUser(userThatCanViewPrivateChanges);
    watch(watchedProject);
    // push a private change to watched project -> should trigger email notification for
    // userThatCanViewPrivateChanges, but not for user
    setApiUser(admin);
    TestRepository<InMemoryRepository> watchedRepo = cloneProject(new Project.NameKey(watchedProject), admin);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), watchedRepo, "TRIGGER", "a", "a1").to("refs/for/master%private");
    r.assertOkStatus();
    // assert email notification
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(userThatCanViewPrivateChanges.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
}
#method_after
@Test
public void watchProjectNotifyOnPrivateChange() throws Exception {
    String watchedProject = createProject("watchedProject").get();
    // create group that can view all private changes
    GroupInfo groupThatCanViewPrivateChanges = gApi.groups().create("groupThatCanViewPrivateChanges").get();
    grant(new Project.NameKey(watchedProject), "refs/*", Permission.VIEW_PRIVATE_CHANGES, false, new AccountGroup.UUID(groupThatCanViewPrivateChanges.id));
    // watch project as user that can't view private changes
    setApiUser(user);
    watch(watchedProject);
    // watch project as user that can view all private change
    TestAccount userThatCanViewPrivateChanges = accountCreator.create("user2", "user2@test.com", "User2", groupThatCanViewPrivateChanges.name);
    setApiUser(userThatCanViewPrivateChanges);
    watch(watchedProject);
    // push a private change to watched project -> should trigger email notification for
    // userThatCanViewPrivateChanges, but not for user
    setApiUser(admin);
    TestRepository<InMemoryRepository> watchedRepo = cloneProject(new Project.NameKey(watchedProject), admin);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), watchedRepo, "TRIGGER", "a", "a1").to("refs/for/master%private");
    r.assertOkStatus();
    // assert email notification
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(userThatCanViewPrivateChanges.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
}
#end_block

#method_before
@Test
public void createChangeOnInvisibleBranchFails() throws Exception {
    changeInTwoBranches("invisible-branch", "a.txt", "branchB", "b.txt");
    block(project, "refs/heads/invisible-branch", READ, REGISTERED_USERS);
    ChangeInput in = newChangeInput(ChangeStatus.NEW);
    in.branch = "invisible-branch";
    assertCreateFails(in, AuthException.class, "cannot upload review");
}
#method_after
@Test
public void createChangeOnInvisibleBranchFails() throws Exception {
    changeInTwoBranches("invisible-branch", "a.txt", "branchB", "b.txt");
    block(project, "refs/heads/invisible-branch", READ, REGISTERED_USERS);
    ChangeInput in = newChangeInput(ChangeStatus.NEW);
    in.branch = "invisible-branch";
    assertCreateFails(in, ResourceNotFoundException.class, "");
}
#end_block

#method_before
@Test
public void cherryPickCommitWithoutChangeId() throws Exception {
    // This test is a little superfluous, since the current cherry-pick code ignores
    // the commit message of the to-be-cherry-picked change, using the one in
    // CherryPickInput instead.
    CherryPickInput input = new CherryPickInput();
    input.destination = "foo";
    input.message = "it goes to foo branch";
    gApi.projects().name(project.get()).branch(input.destination).create(new BranchInput());
    RevCommit revCommit = createNewCommitWithoutChangeId();
    ChangeInfo changeInfo = gApi.projects().name(project.get()).commit(revCommit.getName()).cherryPick(input).get();
    assertThat(changeInfo.messages).hasSize(1);
    Iterator<ChangeMessageInfo> messageIterator = changeInfo.messages.iterator();
    String expectedMessage = String.format("Patch Set 1: Cherry Picked from commit %s.", revCommit.getName());
    assertThat(messageIterator.next().message).isEqualTo(expectedMessage);
    RevisionInfo revInfo = changeInfo.revisions.get(changeInfo.currentRevision);
    assertThat(revInfo).isNotNull();
    CommitInfo commitInfo = revInfo.commit;
    assertThat(commitInfo.message).isEqualTo(input.message + "\n\nChange-Id: " + changeInfo.changeId + "\n");
}
#method_after
@Test
public void cherryPickCommitWithoutChangeId() throws Exception {
    // This test is a little superfluous, since the current cherry-pick code ignores
    // the commit message of the to-be-cherry-picked change, using the one in
    // CherryPickInput instead.
    CherryPickInput input = new CherryPickInput();
    input.destination = "foo";
    input.message = "it goes to foo branch";
    gApi.projects().name(project.get()).branch(input.destination).create(new BranchInput());
    RevCommit revCommit = createNewCommitWithoutChangeId("refs/heads/master", "a.txt", "content");
    ChangeInfo changeInfo = gApi.projects().name(project.get()).commit(revCommit.getName()).cherryPick(input).get();
    assertThat(changeInfo.messages).hasSize(1);
    Iterator<ChangeMessageInfo> messageIterator = changeInfo.messages.iterator();
    String expectedMessage = String.format("Patch Set 1: Cherry Picked from commit %s.", revCommit.getName());
    assertThat(messageIterator.next().message).isEqualTo(expectedMessage);
    RevisionInfo revInfo = changeInfo.revisions.get(changeInfo.currentRevision);
    assertThat(revInfo).isNotNull();
    CommitInfo commitInfo = revInfo.commit;
    assertThat(commitInfo.message).isEqualTo(input.message + "\n\nChange-Id: " + changeInfo.changeId + "\n");
}
#end_block

#method_before
public Response<ReviewResult> apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException, PermissionBackendException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    } else if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        cleanUpComments(input.comments);
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    if (input.notify == null) {
        input.notify = revision.getChange().isWorkInProgress() ? NotifyHandling.OWNER : NotifyHandling.ALL;
    }
    ListMultimap<RecipientType, Account.Id> accountsToNotify = notifyUtil.resolveAccounts(input.notifyDetails);
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            // Prevent notifications because setting reviewers is batched.
            reviewerInput.notify = NotifyHandling.NONE;
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput, true);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        Account.Id id = revision.getUser().getAccountId();
        boolean ccOrReviewer = false;
        if (input.labels != null && !input.labels.isEmpty()) {
            ccOrReviewer = input.labels.values().stream().filter(v -> v != 0).findFirst().isPresent();
        }
        if (!ccOrReviewer) {
            // Check if user was already CCed or reviewing prior to this review.
            ReviewerSet currentReviewers = approvalsUtil.getReviewers(db.get(), revision.getChangeResource().getNotes());
            ccOrReviewer = currentReviewers.all().contains(id);
        }
        // themselves as a reviewer or to the CC list.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
            if (!ccOrReviewer && reviewerResult.result.reviewers != null) {
                for (ReviewerInfo reviewerInfo : reviewerResult.result.reviewers) {
                    if (Objects.equals(id.get(), reviewerInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
            if (!ccOrReviewer && reviewerResult.result.ccs != null) {
                for (AccountInfo accountInfo : reviewerResult.result.ccs) {
                    if (Objects.equals(id.get(), accountInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
        }
        if (!ccOrReviewer) {
            // User posting this review isn't currently in the reviewer or CC list,
            // isn't being explicitly added, and isn't voting on any label.
            // Automatically CC them on this change so they receive replies.
            PostReviewers.Addition selfAddition = postReviewers.ccCurrentUser(revision.getUser(), revision);
            bu.addOp(revision.getChange().getId(), selfAddition.op);
        }
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input, accountsToNotify));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
        emailReviewers(revision.getChange(), reviewerResults, input.notify, accountsToNotify);
    }
    return Response.ok(output);
}
#method_after
public Response<ReviewResult> apply(BatchUpdate.Factory updateFactory, RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException, PermissionBackendException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    } else if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        cleanUpComments(input.comments);
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    if (input.notify == null) {
        input.notify = revision.getChange().isWorkInProgress() ? NotifyHandling.OWNER : NotifyHandling.ALL;
    }
    ListMultimap<RecipientType, Account.Id> accountsToNotify = notifyUtil.resolveAccounts(input.notifyDetails);
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            // Prevent notifications because setting reviewers is batched.
            reviewerInput.notify = NotifyHandling.NONE;
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput, true);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = updateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        Account.Id id = revision.getUser().getAccountId();
        boolean ccOrReviewer = false;
        if (input.labels != null && !input.labels.isEmpty()) {
            ccOrReviewer = input.labels.values().stream().filter(v -> v != 0).findFirst().isPresent();
        }
        if (!ccOrReviewer) {
            // Check if user was already CCed or reviewing prior to this review.
            ReviewerSet currentReviewers = approvalsUtil.getReviewers(db.get(), revision.getChangeResource().getNotes());
            ccOrReviewer = currentReviewers.all().contains(id);
        }
        // themselves as a reviewer or to the CC list.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
            if (!ccOrReviewer && reviewerResult.result.reviewers != null) {
                for (ReviewerInfo reviewerInfo : reviewerResult.result.reviewers) {
                    if (Objects.equals(id.get(), reviewerInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
            if (!ccOrReviewer && reviewerResult.result.ccs != null) {
                for (AccountInfo accountInfo : reviewerResult.result.ccs) {
                    if (Objects.equals(id.get(), accountInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
        }
        if (!ccOrReviewer) {
            // User posting this review isn't currently in the reviewer or CC list,
            // isn't being explicitly added, and isn't voting on any label.
            // Automatically CC them on this change so they receive replies.
            PostReviewers.Addition selfAddition = postReviewers.ccCurrentUser(revision.getUser(), revision);
            bu.addOp(revision.getChange().getId(), selfAddition.op);
        }
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input, accountsToNotify));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
        emailReviewers(revision.getChange(), reviewerResults, input.notify, accountsToNotify);
    }
    return Response.ok(output);
}
#end_block

#method_before
@Test
public void setPrivateByOwner() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    setApiUser(user);
    String changeId = result.getChangeId();
    assertThat(gApi.changes().id(changeId).get().isPrivate).isNull();
    gApi.changes().id(changeId).setPrivate(true);
    ChangeInfo info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isTrue();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set private");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_PRIVATE);
    gApi.changes().id(changeId).setPrivate(false);
    info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isNull();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Unset private");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_UNSET_PRIVATE);
}
#method_after
@Test
public void setPrivateByOwner() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    setApiUser(user);
    String changeId = result.getChangeId();
    assertThat(gApi.changes().id(changeId).get().isPrivate).isNull();
    gApi.changes().id(changeId).setPrivate(true, null);
    ChangeInfo info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isTrue();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set private");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_PRIVATE);
    gApi.changes().id(changeId).setPrivate(false, null);
    info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isNull();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Unset private");
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_UNSET_PRIVATE);
    String msg = "This is a security fix that must not be public.";
    gApi.changes().id(changeId).setPrivate(true, msg);
    info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isTrue();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Set private\n\n" + msg);
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_SET_PRIVATE);
    msg = "After this security fix has been released we can make it public now.";
    gApi.changes().id(changeId).setPrivate(false, msg);
    info = gApi.changes().id(changeId).get();
    assertThat(info.isPrivate).isNull();
    assertThat(Iterables.getLast(info.messages).message).isEqualTo("Unset private\n\n" + msg);
    assertThat(Iterables.getLast(info.messages).tag).contains(ChangeMessagesUtil.TAG_UNSET_PRIVATE);
}
#end_block

#method_before
@Test
public void accessPrivate() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    setApiUser(user);
    gApi.changes().id(result.getChangeId()).setPrivate(true);
    // Owner can always access its private changes.
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isTrue();
    // Add admin as a reviewer.
    gApi.changes().id(result.getChangeId()).addReviewer(admin.getId().toString());
    // This change should be visible for admin as a reviewer.
    setApiUser(admin);
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isTrue();
    // Remove admin from reviewers.
    gApi.changes().id(result.getChangeId()).reviewer(admin.getId().toString()).remove();
    // This change should not be visible for admin anymore.
    exception.expect(ResourceNotFoundException.class);
    exception.expectMessage("Not found: " + result.getChangeId());
    gApi.changes().id(result.getChangeId());
}
#method_after
@Test
public void accessPrivate() throws Exception {
    TestRepository<InMemoryRepository> userRepo = cloneProject(project, user);
    PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master");
    setApiUser(user);
    gApi.changes().id(result.getChangeId()).setPrivate(true, null);
    // Owner can always access its private changes.
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isTrue();
    // Add admin as a reviewer.
    gApi.changes().id(result.getChangeId()).addReviewer(admin.getId().toString());
    // This change should be visible for admin as a reviewer.
    setApiUser(admin);
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isTrue();
    // Remove admin from reviewers.
    gApi.changes().id(result.getChangeId()).reviewer(admin.getId().toString()).remove();
    // This change should not be visible for admin anymore.
    exception.expect(ResourceNotFoundException.class);
    exception.expectMessage("Not found: " + result.getChangeId());
    gApi.changes().id(result.getChangeId());
}
#end_block

#method_before
@Test
public void privateChangeOfOtherUserCanBeAccessedWithPermission() throws Exception {
    PushOneCommit.Result result = createChange();
    gApi.changes().id(result.getChangeId()).setPrivate(true);
    allow(Permission.VIEW_PRIVATE_CHANGES, REGISTERED_USERS, "refs/*");
    setApiUser(user);
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isTrue();
}
#method_after
@Test
public void privateChangeOfOtherUserCanBeAccessedWithPermission() throws Exception {
    PushOneCommit.Result result = createChange();
    gApi.changes().id(result.getChangeId()).setPrivate(true, null);
    allow(Permission.VIEW_PRIVATE_CHANGES, REGISTERED_USERS, "refs/*");
    setApiUser(user);
    assertThat(gApi.changes().id(result.getChangeId()).get().isPrivate).isTrue();
}
#end_block

#method_before
@Test
public void rebaseAllowedWithPermission() throws Exception {
    // Create two changes both with the same parent
    PushOneCommit.Result r = createChange();
    testRepo.reset("HEAD~1");
    PushOneCommit.Result r2 = createChange();
    // Approve and submit the first change
    RevisionApi revision = gApi.changes().id(r.getChangeId()).current();
    revision.review(ReviewInput.approve());
    revision.submit();
    grant(Permission.REBASE, project, "refs/heads/master", false, REGISTERED_USERS);
    // Rebase the second
    String changeId = r2.getChangeId();
    setApiUser(user);
    gApi.changes().id(changeId).rebase();
}
#method_after
@Test
public void rebaseAllowedWithPermission() throws Exception {
    // Create two changes both with the same parent
    PushOneCommit.Result r = createChange();
    testRepo.reset("HEAD~1");
    PushOneCommit.Result r2 = createChange();
    // Approve and submit the first change
    RevisionApi revision = gApi.changes().id(r.getChangeId()).current();
    revision.review(ReviewInput.approve());
    revision.submit();
    grant(project, "refs/heads/master", Permission.REBASE, false, REGISTERED_USERS);
    // Rebase the second
    String changeId = r2.getChangeId();
    setApiUser(user);
    gApi.changes().id(changeId).rebase();
}
#end_block

#method_before
@Test
@TestProjectInput(cloneAs = "user")
public void deleteChangeAsUserWithDeleteOwnChangesPermission() throws Exception {
    allow(Permission.DELETE_OWN_CHANGES, REGISTERED_USERS, "refs/*");
    try {
        PushOneCommit.Result changeResult = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
        String changeId = changeResult.getChangeId();
        int id = changeResult.getChange().getId().id;
        RevCommit commit = changeResult.getCommit();
        setApiUser(user);
        gApi.changes().id(changeId).delete();
        assertThat(query(changeId)).isEmpty();
        String ref = new Change.Id(id).toRefPrefix() + "1";
        eventRecorder.assertRefUpdatedEvents(project.get(), ref, null, commit, commit, null);
    } finally {
        removePermission(Permission.DELETE_OWN_CHANGES, project, "refs/*");
    }
}
#method_after
@Test
@TestProjectInput(cloneAs = "user")
public void deleteChangeAsUserWithDeleteOwnChangesPermission() throws Exception {
    allow(Permission.DELETE_OWN_CHANGES, REGISTERED_USERS, "refs/*");
    try {
        PushOneCommit.Result changeResult = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
        String changeId = changeResult.getChangeId();
        int id = changeResult.getChange().getId().id;
        RevCommit commit = changeResult.getCommit();
        setApiUser(user);
        gApi.changes().id(changeId).delete();
        assertThat(query(changeId)).isEmpty();
        String ref = new Change.Id(id).toRefPrefix() + "1";
        eventRecorder.assertRefUpdatedEvents(project.get(), ref, null, commit, commit, null);
    } finally {
        removePermission(project, "refs/*", Permission.DELETE_OWN_CHANGES);
    }
}
#end_block

#method_before
@Test
public void deleteNewChangeOfAnotherUserWithDeleteOwnChangesPermission() throws Exception {
    allow(Permission.DELETE_OWN_CHANGES, REGISTERED_USERS, "refs/*");
    try {
        PushOneCommit.Result changeResult = createChange();
        String changeId = changeResult.getChangeId();
        setApiUser(user);
        exception.expect(AuthException.class);
        exception.expectMessage("delete not permitted");
        gApi.changes().id(changeId).delete();
    } finally {
        removePermission(Permission.DELETE_OWN_CHANGES, project, "refs/*");
    }
}
#method_after
@Test
public void deleteNewChangeOfAnotherUserWithDeleteOwnChangesPermission() throws Exception {
    allow(Permission.DELETE_OWN_CHANGES, REGISTERED_USERS, "refs/*");
    try {
        PushOneCommit.Result changeResult = createChange();
        String changeId = changeResult.getChangeId();
        setApiUser(user);
        exception.expect(AuthException.class);
        exception.expectMessage("delete not permitted");
        gApi.changes().id(changeId).delete();
    } finally {
        removePermission(project, "refs/*", Permission.DELETE_OWN_CHANGES);
    }
}
#end_block

#method_before
@Test
@TestProjectInput(cloneAs = "user")
public void deleteMergedChangeWithDeleteOwnChangesPermission() throws Exception {
    allow(Permission.DELETE_OWN_CHANGES, REGISTERED_USERS, "refs/*");
    try {
        PushOneCommit.Result changeResult = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
        String changeId = changeResult.getChangeId();
        merge(changeResult);
        setApiUser(user);
        exception.expect(MethodNotAllowedException.class);
        exception.expectMessage("delete not permitted");
        gApi.changes().id(changeId).delete();
    } finally {
        removePermission(Permission.DELETE_OWN_CHANGES, project, "refs/*");
    }
}
#method_after
@Test
@TestProjectInput(cloneAs = "user")
public void deleteMergedChangeWithDeleteOwnChangesPermission() throws Exception {
    allow(Permission.DELETE_OWN_CHANGES, REGISTERED_USERS, "refs/*");
    try {
        PushOneCommit.Result changeResult = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
        String changeId = changeResult.getChangeId();
        merge(changeResult);
        setApiUser(user);
        exception.expect(MethodNotAllowedException.class);
        exception.expectMessage("delete not permitted");
        gApi.changes().id(changeId).delete();
    } finally {
        removePermission(project, "refs/*", Permission.DELETE_OWN_CHANGES);
    }
}
#end_block

#method_before
@Test
public void deleteVoteNotifyAccount() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    DeleteVoteInput in = new DeleteVoteInput();
    in.label = "Code-Review";
    in.notify = NotifyHandling.NONE;
    // notify unrelated account as TO
    TestAccount user2 = accounts.user2();
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.TO, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyTo(user2);
    // notify unrelated account as CC
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.CC, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyCc(user2);
    // notify unrelated account as BCC
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.BCC, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyBcc(user2);
}
#method_after
@Test
public void deleteVoteNotifyAccount() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    DeleteVoteInput in = new DeleteVoteInput();
    in.label = "Code-Review";
    in.notify = NotifyHandling.NONE;
    // notify unrelated account as TO
    TestAccount user2 = accountCreator.user2();
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.TO, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyTo(user2);
    // notify unrelated account as CC
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.CC, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyCc(user2);
    // notify unrelated account as BCC
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.BCC, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyBcc(user2);
}
#end_block

#method_before
@Test
public void editTopicWithPermissionAllowed() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(gApi.changes().id(r.getChangeId()).topic()).isEqualTo("");
    grant(Permission.EDIT_TOPIC_NAME, project, "refs/heads/master", false, REGISTERED_USERS);
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).topic("mytopic");
    assertThat(gApi.changes().id(r.getChangeId()).topic()).isEqualTo("mytopic");
}
#method_after
@Test
public void editTopicWithPermissionAllowed() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(gApi.changes().id(r.getChangeId()).topic()).isEqualTo("");
    grant(project, "refs/heads/master", Permission.EDIT_TOPIC_NAME, false, REGISTERED_USERS);
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).topic("mytopic");
    assertThat(gApi.changes().id(r.getChangeId()).topic()).isEqualTo("mytopic");
}
#end_block

#method_before
@Test
public void submitAllowedWithPermission() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    grant(Permission.SUBMIT, project, "refs/heads/master", false, REGISTERED_USERS);
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    assertThat(gApi.changes().id(r.getChangeId()).info().status).isEqualTo(ChangeStatus.MERGED);
}
#method_after
@Test
public void submitAllowedWithPermission() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    grant(project, "refs/heads/master", Permission.SUBMIT, false, REGISTERED_USERS);
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    assertThat(gApi.changes().id(r.getChangeId()).info().status).isEqualTo(ChangeStatus.MERGED);
}
#end_block

#method_before
@Test
public void createNewPatchSetWithoutPermission() throws Exception {
    // Create new project with clean permissions
    Project.NameKey p = createProject("addPatchSet1");
    // Clone separate repositories of the same project as admin and as user
    TestRepository<InMemoryRepository> adminTestRepo = cloneProject(p, admin);
    TestRepository<InMemoryRepository> userTestRepo = cloneProject(p, user);
    // Block default permission
    block(Permission.ADD_PATCH_SET, REGISTERED_USERS, "refs/for/*", p);
    // Create change as admin
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), adminTestRepo);
    PushOneCommit.Result r1 = push.to("refs/for/master");
    r1.assertOkStatus();
    // Fetch change
    GitUtil.fetch(userTestRepo, r1.getPatchSet().getRefName() + ":ps");
    userTestRepo.reset("ps");
    // Amend change as user
    PushOneCommit.Result r2 = amendChange(r1.getChangeId(), "refs/for/master", user, userTestRepo);
    r2.assertErrorStatus("cannot add patch set to " + r1.getChange().getId().id + ".");
}
#method_after
@Test
public void createNewPatchSetWithoutPermission() throws Exception {
    // Create new project with clean permissions
    Project.NameKey p = createProject("addPatchSet1");
    // Clone separate repositories of the same project as admin and as user
    TestRepository<InMemoryRepository> adminTestRepo = cloneProject(p, admin);
    TestRepository<InMemoryRepository> userTestRepo = cloneProject(p, user);
    // Block default permission
    block(p, "refs/for/*", Permission.ADD_PATCH_SET, REGISTERED_USERS);
    // Create change as admin
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), adminTestRepo);
    PushOneCommit.Result r1 = push.to("refs/for/master");
    r1.assertOkStatus();
    // Fetch change
    GitUtil.fetch(userTestRepo, r1.getPatchSet().getRefName() + ":ps");
    userTestRepo.reset("ps");
    // Amend change as user
    PushOneCommit.Result r2 = amendChange(r1.getChangeId(), "refs/for/master", user, userTestRepo);
    r2.assertErrorStatus("cannot add patch set to " + r1.getChange().getId().id + ".");
}
#end_block

#method_before
@Test
public void createNewPatchSetAsOwnerWithoutPermission() throws Exception {
    // Create new project with clean permissions
    Project.NameKey p = createProject("addPatchSet2");
    // Clone separate repositories of the same project as admin and as user
    TestRepository<?> adminTestRepo = cloneProject(project, admin);
    // Block default permission
    block(Permission.ADD_PATCH_SET, REGISTERED_USERS, "refs/for/*", p);
    // Create change as admin
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), adminTestRepo);
    PushOneCommit.Result r1 = push.to("refs/for/master");
    r1.assertOkStatus();
    // Fetch change
    GitUtil.fetch(adminTestRepo, r1.getPatchSet().getRefName() + ":ps");
    adminTestRepo.reset("ps");
    // Amend change as admin
    PushOneCommit.Result r2 = amendChange(r1.getChangeId(), "refs/for/master", admin, adminTestRepo);
    r2.assertOkStatus();
}
#method_after
@Test
public void createNewPatchSetAsOwnerWithoutPermission() throws Exception {
    // Create new project with clean permissions
    Project.NameKey p = createProject("addPatchSet2");
    // Clone separate repositories of the same project as admin and as user
    TestRepository<?> adminTestRepo = cloneProject(project, admin);
    // Block default permission
    block(p, "refs/for/*", Permission.ADD_PATCH_SET, REGISTERED_USERS);
    // Create change as admin
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), adminTestRepo);
    PushOneCommit.Result r1 = push.to("refs/for/master");
    r1.assertOkStatus();
    // Fetch change
    GitUtil.fetch(adminTestRepo, r1.getPatchSet().getRefName() + ":ps");
    adminTestRepo.reset("ps");
    // Amend change as admin
    PushOneCommit.Result r2 = amendChange(r1.getChangeId(), "refs/for/master", admin, adminTestRepo);
    r2.assertOkStatus();
}
#end_block

#method_before
@Test
public void createNewDraftPatchSetOnDraftChange() throws Exception {
    // Create new project with clean permissions
    Project.NameKey p = createProject("addPatchSet4");
    // Clone separate repositories of the same project as admin and as user
    TestRepository<?> adminTestRepo = cloneProject(p, admin);
    TestRepository<?> userTestRepo = cloneProject(p, user);
    // Block default permission
    block(Permission.ADD_PATCH_SET, REGISTERED_USERS, "refs/for/*", p);
    // Create change as admin
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), adminTestRepo);
    PushOneCommit.Result r1 = push.to("refs/drafts/master");
    r1.assertOkStatus();
    // Add user as reviewer
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r1.getChangeId()).addReviewer(in);
    // Fetch change
    GitUtil.fetch(userTestRepo, r1.getPatchSet().getRefName() + ":ps");
    userTestRepo.reset("ps");
    // Amend change as user
    PushOneCommit.Result r2 = amendChange(r1.getChangeId(), "refs/drafts/master", user, userTestRepo);
    r2.assertErrorStatus("cannot add patch set to " + r1.getChange().getId().id + ".");
}
#method_after
@Test
public void createNewDraftPatchSetOnDraftChange() throws Exception {
    // Create new project with clean permissions
    Project.NameKey p = createProject("addPatchSet4");
    // Clone separate repositories of the same project as admin and as user
    TestRepository<?> adminTestRepo = cloneProject(p, admin);
    TestRepository<?> userTestRepo = cloneProject(p, user);
    // Block default permission
    block(p, "refs/for/*", Permission.ADD_PATCH_SET, REGISTERED_USERS);
    // Create change as admin
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), adminTestRepo);
    PushOneCommit.Result r1 = push.to("refs/drafts/master");
    r1.assertOkStatus();
    // Add user as reviewer
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r1.getChangeId()).addReviewer(in);
    // Fetch change
    GitUtil.fetch(userTestRepo, r1.getPatchSet().getRefName() + ":ps");
    userTestRepo.reset("ps");
    // Amend change as user
    PushOneCommit.Result r2 = amendChange(r1.getChangeId(), "refs/drafts/master", user, userTestRepo);
    r2.assertErrorStatus("cannot add patch set to " + r1.getChange().getId().id + ".");
}
#end_block

#method_before
public static DiffSummaryKey fromPatchListKey(PatchListKey plk) {
    Preconditions.checkState(plk.getAlgorithm() == PatchListKey.Algorithm.OPTIMIZED_DIFF);
    return new DiffSummaryKey(plk.getOldId(), plk.getParentNum(), plk.getNewId(), plk.getWhitespace());
}
#method_after
public static DiffSummaryKey fromPatchListKey(PatchListKey plk) {
    Preconditions.checkArgument(plk.getAlgorithm() == PatchListKey.Algorithm.OPTIMIZED_DIFF);
    return new DiffSummaryKey(plk.getOldId(), plk.getParentNum(), plk.getNewId(), plk.getWhitespace());
}
#end_block

#method_before
private Multimap<String, Edit> getEditsDueToRebasePerFilePath(RevCommit commitA, RevCommit commitB) throws PatchListNotAvailableException {
    if (!arePatchSetCommitsWithRebaseInBetween(commitA, commitB)) {
        return ImmutableMultimap.of();
    }
    PatchListKey parentDiffKey = PatchListKey.againstCommitWithPureTreeDiff(commitA.getParent(0), commitB.getParent(0), key.getWhitespace());
    PatchList parentPatchList = patchListCache.get(parentDiffKey, project);
    PatchListKey oldKey = PatchListKey.againstDefaultBase(key.getOldId(), key.getWhitespace());
    PatchList oldPatchList = patchListCache.get(oldKey, project);
    PatchListKey newKey = PatchListKey.againstDefaultBase(key.getNewId(), key.getWhitespace());
    PatchList newPatchList = patchListCache.get(newKey, project);
    EditTransformer editTransformer = new EditTransformer(parentPatchList.getPatches());
    editTransformer.transformReferencesOfSideA(oldPatchList.getPatches());
    editTransformer.transformReferencesOfSideB(newPatchList.getPatches());
    return editTransformer.getEditsPerFilePath();
}
#method_after
private Multimap<String, Edit> getEditsDueToRebasePerFilePath(RevCommit commitA, RevCommit commitB) throws PatchListNotAvailableException {
    if (commitA == null || isRootOrMergeCommit(commitA) || isRootOrMergeCommit(commitB) || areParentChild(commitA, commitB) || haveCommonParent(commitA, commitB)) {
        return ImmutableMultimap.of();
    }
    PatchListKey parentDiffKey = PatchListKey.againstCommitWithPureTreeDiff(commitA.getParent(0), commitB.getParent(0), key.getWhitespace());
    PatchList parentPatchList = patchListCache.get(parentDiffKey, project);
    PatchListKey oldKey = PatchListKey.againstDefaultBase(key.getOldId(), key.getWhitespace());
    PatchList oldPatchList = patchListCache.get(oldKey, project);
    PatchListKey newKey = PatchListKey.againstDefaultBase(key.getNewId(), key.getWhitespace());
    PatchList newPatchList = patchListCache.get(newKey, project);
    EditTransformer editTransformer = new EditTransformer(parentPatchList.getPatches());
    editTransformer.transformReferencesOfSideA(oldPatchList.getPatches());
    editTransformer.transformReferencesOfSideB(newPatchList.getPatches());
    return editTransformer.getEditsPerFilePath();
}
#end_block

#method_before
public RestApi addParameter(String name, String... value) {
    for (String val : value) {
        addParameter(name, val);
    }
    return this;
}
#method_after
public RestApi addParameter(String name, String value) {
    return addParameterRaw(name, URL.encodeQueryString(value));
}
#end_block

#method_before
public RestApi addParameter(String name, Enum<?> value) {
    return addParameterRaw(name, value.name());
}
#method_after
public RestApi addParameter(String name, String... value) {
    for (String val : value) {
        addParameter(name, val);
    }
    return this;
}
#end_block

#method_before
public boolean canAddRefs() {
    return (canPerformOnAnyRef(Permission.CREATE) || isOwnerAnyRef());
}
#method_after
private boolean canAddRefs() {
    return (canPerformOnAnyRef(Permission.CREATE) || isOwnerAnyRef());
}
#end_block

#method_before
private boolean can(ProjectPermission perm) throws PermissionBackendException {
    switch(perm) {
        case ACCESS:
            return (!isHidden() && (user.isInternalUser() || canPerformOnAnyRef(Permission.READ))) || isOwner();
        case READ:
            return !isHidden() && allRefsAreVisible(Collections.emptySet());
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#method_after
private boolean can(ProjectPermission perm) throws PermissionBackendException {
    switch(perm) {
        case ACCESS:
            return (!isHidden() && (user.isInternalUser() || canPerformOnAnyRef(Permission.READ))) || isOwner();
        case READ:
            return !isHidden() && allRefsAreVisible(Collections.emptySet());
        case CREATE_REF:
            return canAddRefs();
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#end_block

#method_before
private boolean canRebase(ReviewDb db) throws OrmException {
    return (isOwner() || getRefControl().canSubmit(isOwner()) || getRefControl().canRebase()) && getRefControl().canUpload() && !isPatchSetLocked(db);
}
#method_after
private boolean canRebase(ReviewDb db) throws OrmException {
    return (isOwner() || getRefControl().canSubmit(isOwner()) || getRefControl().canRebase()) && refControl.asForRef().testOrFalse(RefPermission.CREATE_CHANGE) && !isPatchSetLocked(db);
}
#end_block

#method_before
private boolean canRestore(ReviewDb db) throws OrmException {
    return // Anyone who can abandon the change can restore it back
    canAbandon(db) && // as long as you can upload too
    getRefControl().canUpload();
}
#method_after
private boolean canRestore(ReviewDb db) throws OrmException {
    // Anyone who can abandon the change can restore it, as long as they can create changes.
    return canAbandon(db) && refControl.asForRef().testOrFalse(RefPermission.CREATE_CHANGE);
}
#end_block

#method_before
private boolean canAddPatchSet(ReviewDb db) throws OrmException {
    if (!getRefControl().canUpload() || isPatchSetLocked(db) || !isPatchVisible(patchSetUtil.current(db, notes), db)) {
        return false;
    }
    if (isOwner()) {
        return true;
    }
    return getRefControl().canAddPatchSet();
}
#method_after
private boolean canAddPatchSet(ReviewDb db) throws OrmException {
    if (!refControl.asForRef().testOrFalse(RefPermission.CREATE_CHANGE) || isPatchSetLocked(db) || !isPatchVisible(patchSetUtil.current(db, notes), db)) {
        return false;
    }
    if (isOwner()) {
        return true;
    }
    return getRefControl().canAddPatchSet();
}
#end_block

#method_before
private void validate(RepoContext ctx) throws IOException, ResourceConflictException {
    if (!validate) {
        return;
    }
    try {
        RefControl refControl = projectControlFactory.controlFor(ctx.getProject(), ctx.getUser()).controlForRef(refName);
        try (CommitReceivedEvent event = new CommitReceivedEvent(cmd, refControl.getProjectControl().getProject(), change.getDest().get(), ctx.getRevWalk().getObjectReader(), commitId, ctx.getIdentifiedUser())) {
            commitValidatorsFactory.forGerritCommits(refControl, new NoSshInfo(), ctx.getRevWalk()).validate(event);
        }
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    } catch (NoSuchProjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
private void validate(RepoContext ctx) throws IOException, ResourceConflictException {
    if (!validate) {
        return;
    }
    PermissionBackend.ForRef perm = permissionBackend.user(ctx.getUser()).project(ctx.getProject()).ref(refName);
    try {
        RefControl refControl = projectControlFactory.controlFor(ctx.getProject(), ctx.getUser()).controlForRef(refName);
        try (CommitReceivedEvent event = new CommitReceivedEvent(cmd, refControl.getProjectControl().getProject(), change.getDest().get(), ctx.getRevWalk().getObjectReader(), commitId, ctx.getIdentifiedUser())) {
            commitValidatorsFactory.forGerritCommits(perm, refControl, new NoSshInfo(), ctx.getRevWalk()).validate(event);
        }
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    } catch (NoSuchProjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
public CommitValidators forReceiveCommits(RefControl refControl, SshInfo sshInfo, Repository repo, RevWalk rw) throws IOException {
    NoteMap rejectCommits = BanCommit.loadRejectCommitsMap(repo, rw);
    return new CommitValidators(ImmutableList.of(new UploadMergesPermissionValidator(refControl), new AmendedGerritMergeCommitValidationListener(refControl, gerritIdent), new AuthorUploaderValidator(refControl, canonicalWebUrl), new CommitterUploaderValidator(refControl, canonicalWebUrl), new SignedOffByValidator(refControl), new ChangeIdValidator(refControl, canonicalWebUrl, installCommitMsgHookCommand, sshInfo), new ConfigValidator(refControl, rw, allUsers), new BannedCommitsValidator(rejectCommits), new PluginCommitValidationListener(pluginValidators), new ExternalIdUpdateListener(allUsers, externalIdsConsistencyChecker)));
}
#method_after
public CommitValidators forReceiveCommits(PermissionBackend.ForRef perm, RefControl refctl, SshInfo sshInfo, Repository repo, RevWalk rw) throws IOException {
    NoteMap rejectCommits = BanCommit.loadRejectCommitsMap(repo, rw);
    IdentifiedUser user = refctl.getUser().asIdentifiedUser();
    return new CommitValidators(ImmutableList.of(new UploadMergesPermissionValidator(refctl), new AmendedGerritMergeCommitValidationListener(perm, gerritIdent), new AuthorUploaderValidator(user, perm, canonicalWebUrl), new CommitterUploaderValidator(user, perm, canonicalWebUrl), new SignedOffByValidator(user, perm, refctl.getProjectControl().getProjectState()), new ChangeIdValidator(refctl, canonicalWebUrl, installCommitMsgHookCommand, sshInfo), new ConfigValidator(refctl, rw, allUsers), new BannedCommitsValidator(rejectCommits), new PluginCommitValidationListener(pluginValidators), new ExternalIdUpdateListener(allUsers, externalIdsConsistencyChecker)));
}
#end_block

#method_before
public CommitValidators forGerritCommits(RefControl refControl, SshInfo sshInfo, RevWalk rw) {
    return new CommitValidators(ImmutableList.of(new UploadMergesPermissionValidator(refControl), new AmendedGerritMergeCommitValidationListener(refControl, gerritIdent), new AuthorUploaderValidator(refControl, canonicalWebUrl), new SignedOffByValidator(refControl), new ChangeIdValidator(refControl, canonicalWebUrl, installCommitMsgHookCommand, sshInfo), new ConfigValidator(refControl, rw, allUsers), new PluginCommitValidationListener(pluginValidators), new ExternalIdUpdateListener(allUsers, externalIdsConsistencyChecker)));
}
#method_after
public CommitValidators forGerritCommits(PermissionBackend.ForRef perm, RefControl refctl, SshInfo sshInfo, RevWalk rw) {
    IdentifiedUser user = refctl.getUser().asIdentifiedUser();
    return new CommitValidators(ImmutableList.of(new UploadMergesPermissionValidator(refctl), new AmendedGerritMergeCommitValidationListener(perm, gerritIdent), new AuthorUploaderValidator(user, perm, canonicalWebUrl), new SignedOffByValidator(user, perm, refctl.getProjectControl().getProjectState()), new ChangeIdValidator(refctl, canonicalWebUrl, installCommitMsgHookCommand, sshInfo), new ConfigValidator(refctl, rw, allUsers), new PluginCommitValidationListener(pluginValidators), new ExternalIdUpdateListener(allUsers, externalIdsConsistencyChecker)));
}
#end_block

#method_before
public CommitValidators forMergedCommits(RefControl refControl) {
    // formats, so we play it safe and exclude them.
    return new CommitValidators(ImmutableList.of(new UploadMergesPermissionValidator(refControl), new AuthorUploaderValidator(refControl, canonicalWebUrl), new CommitterUploaderValidator(refControl, canonicalWebUrl)));
}
#method_after
public CommitValidators forMergedCommits(PermissionBackend.ForRef perm, RefControl refControl) {
    IdentifiedUser user = refControl.getUser().asIdentifiedUser();
    // formats, so we play it safe and exclude them.
    return new CommitValidators(ImmutableList.of(new UploadMergesPermissionValidator(refControl), new AuthorUploaderValidator(user, perm, canonicalWebUrl), new CommitterUploaderValidator(user, perm, canonicalWebUrl)));
}
#end_block

#method_before
private CommitValidationMessage getMissingChangeIdErrorMsg(final String errMsg, RevCommit c) {
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    if (c.getFullMessage().indexOf(CHANGE_ID_PREFIX) >= 0) {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(CHANGE_ID_PREFIX) == -1) {
            sb.append('\n');
            sb.append('\n');
            sb.append("Hint: A potential ");
            sb.append(FooterConstants.CHANGE_ID.getName());
            sb.append("Change-Id was found, but it was not in the ");
            sb.append("footer (last paragraph) of the commit message.");
        }
    }
    sb.append('\n');
    sb.append('\n');
    sb.append("Hint: To automatically insert ");
    sb.append(FooterConstants.CHANGE_ID.getName());
    sb.append(", install the hook:\n");
    sb.append(getCommitMessageHookInstallationHint());
    sb.append('\n');
    sb.append("And then amend the commit:\n");
    sb.append("  git commit --amend\n");
    return new CommitValidationMessage(sb.toString(), false);
}
#method_after
private CommitValidationMessage getMissingChangeIdErrorMsg(String errMsg, RevCommit c) {
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    if (c.getFullMessage().indexOf(CHANGE_ID_PREFIX) >= 0) {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(CHANGE_ID_PREFIX) == -1) {
            sb.append('\n');
            sb.append('\n');
            sb.append("Hint: A potential ");
            sb.append(FooterConstants.CHANGE_ID.getName());
            sb.append("Change-Id was found, but it was not in the ");
            sb.append("footer (last paragraph) of the commit message.");
        }
    }
    sb.append('\n');
    sb.append('\n');
    sb.append("Hint: To automatically insert ");
    sb.append(FooterConstants.CHANGE_ID.getName());
    sb.append(", install the hook:\n");
    sb.append(getCommitMessageHookInstallationHint());
    sb.append('\n');
    sb.append("And then amend the commit:\n");
    sb.append("  git commit --amend\n");
    return new CommitValidationMessage(sb.toString(), false);
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    IdentifiedUser currentUser = refControl.getUser().asIdentifiedUser();
    final PersonIdent committer = receiveEvent.commit.getCommitterIdent();
    final PersonIdent author = receiveEvent.commit.getAuthorIdent();
    final ProjectControl projectControl = refControl.getProjectControl();
    if (projectControl.getProjectState().isUseSignedOffBy()) {
        boolean sboAuthor = false;
        boolean sboCommitter = false;
        boolean sboMe = false;
        for (FooterLine footer : receiveEvent.commit.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.hasEmailAddress(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !refControl.canForgeCommitter()) {
            throw new CommitValidationException("not Signed-off-by author/committer/uploader in commit message footer");
        }
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    if (!state.isUseSignedOffBy()) {
        return Collections.emptyList();
    }
    RevCommit commit = receiveEvent.commit;
    PersonIdent committer = commit.getCommitterIdent();
    PersonIdent author = commit.getAuthorIdent();
    boolean sboAuthor = false;
    boolean sboCommitter = false;
    boolean sboMe = false;
    for (FooterLine footer : commit.getFooterLines()) {
        if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
            String e = footer.getEmailAddress();
            if (e != null) {
                sboAuthor |= author.getEmailAddress().equals(e);
                sboCommitter |= committer.getEmailAddress().equals(e);
                sboMe |= user.hasEmailAddress(e);
            }
        }
    }
    if (!sboAuthor && !sboCommitter && !sboMe) {
        try {
            perm.check(RefPermission.FORGE_COMMITTER);
        } catch (AuthException denied) {
            throw new CommitValidationException("not Signed-off-by author/committer/uploader in commit message footer");
        } catch (PermissionBackendException e) {
            log.error("cannot check FORGE_COMMITTER", e);
            throw new CommitValidationException("internal auth error");
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    IdentifiedUser currentUser = refControl.getUser().asIdentifiedUser();
    final PersonIdent author = receiveEvent.commit.getAuthorIdent();
    if (!currentUser.hasEmailAddress(author.getEmailAddress()) && !refControl.canForgeAuthor()) {
        List<CommitValidationMessage> messages = new ArrayList<>();
        messages.add(getInvalidEmailError(receiveEvent.commit, "author", author, currentUser, canonicalWebUrl));
        throw new CommitValidationException("invalid author", messages);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    PersonIdent author = receiveEvent.commit.getAuthorIdent();
    if (user.hasEmailAddress(author.getEmailAddress())) {
        return Collections.emptyList();
    }
    try {
        perm.check(RefPermission.FORGE_AUTHOR);
        return Collections.emptyList();
    } catch (AuthException e) {
        throw new CommitValidationException("invalid author", invalidEmail(receiveEvent.commit, "author", author, user, canonicalWebUrl));
    } catch (PermissionBackendException e) {
        log.error("cannot check FORGE_AUTHOR", e);
        throw new CommitValidationException("internal auth error");
    }
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    IdentifiedUser currentUser = refControl.getUser().asIdentifiedUser();
    final PersonIdent committer = receiveEvent.commit.getCommitterIdent();
    if (!currentUser.hasEmailAddress(committer.getEmailAddress()) && !refControl.canForgeCommitter()) {
        List<CommitValidationMessage> messages = new ArrayList<>();
        messages.add(getInvalidEmailError(receiveEvent.commit, "committer", committer, currentUser, canonicalWebUrl));
        throw new CommitValidationException("invalid committer", messages);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    PersonIdent committer = receiveEvent.commit.getCommitterIdent();
    if (user.hasEmailAddress(committer.getEmailAddress())) {
        return Collections.emptyList();
    }
    try {
        perm.check(RefPermission.FORGE_COMMITTER);
        return Collections.emptyList();
    } catch (AuthException e) {
        throw new CommitValidationException("invalid committer", invalidEmail(receiveEvent.commit, "committer", committer, user, canonicalWebUrl));
    } catch (PermissionBackendException e) {
        log.error("cannot check FORGE_COMMITTER", e);
        throw new CommitValidationException("internal auth error");
    }
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    final PersonIdent author = receiveEvent.commit.getAuthorIdent();
    if (receiveEvent.commit.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !refControl.canForgeGerritServerIdentity()) {
        throw new CommitValidationException("do not amend merges not made by you");
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    PersonIdent author = receiveEvent.commit.getAuthorIdent();
    if (receiveEvent.commit.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress())) {
        try {
            perm.check(RefPermission.FORGE_SERVER);
        } catch (AuthException denied) {
            throw new CommitValidationException("do not amend merges not made by you");
        } catch (PermissionBackendException e) {
            log.error("cannot check FORGE_SERVER", e);
            throw new CommitValidationException("internal auth error");
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
private void integrateIntoHistory(ChangeSet cs) throws IntegrationException, RestApiException {
    checkArgument(!cs.furtherHiddenChanges(), "cannot integrate hidden changes into history");
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    ListMultimap<Branch.NameKey, ChangeData> cbb;
    try {
        cbb = cs.changesByBranch();
    } catch (OrmException e) {
        throw new IntegrationException("Error reading changes to submit", e);
    }
    Set<Branch.NameKey> branches = cbb.keySet();
    int projects = 0;
    for (Branch.NameKey branch : branches) {
        OpenRepo or = openRepo(branch.getParentKey());
        if (or != null) {
            BranchBatch bb = validateChangeList(or, cbb.get(branch));
            toSubmit.put(branch, bb);
            if (!bb.commits().isEmpty()) {
                projects++;
            }
        }
    }
    if (projects > 1) {
        topicMetrics.topicSubmissions.increment();
    }
    // Done checks that don't involve running submit strategies.
    commitStatus.maybeFailVerbose();
    try {
        SubmoduleOp submoduleOp = subOpFactory.create(branches, orm);
        List<SubmitStrategy> strategies = getSubmitStrategies(toSubmit, submoduleOp, dryrun);
        this.allProjects = submoduleOp.getProjectsInOrder();
        batchUpdateFactory.execute(orm.batchUpdates(batchUpdateFactory, allProjects), new SubmitStrategyListener(submitInput, strategies, commitStatus), submissionId, dryrun);
    } catch (NoSuchProjectException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (IOException | SubmoduleException e) {
        throw new IntegrationException(e);
    } catch (UpdateException e) {
        // BatchUpdate may have inadvertently wrapped an IntegrationException
        // thrown by some legacy SubmitStrategyOp code that intended the error
        // message to be user-visible. Copy the message from the wrapped
        // exception.
        // 
        // If you happen across one of these, the correct fix is to convert the
        // inner IntegrationException to a ResourceConflictException.
        String msg;
        if (e.getCause() instanceof IntegrationException) {
            msg = e.getCause().getMessage();
        } else {
            msg = "Error submitting change" + (cs.size() != 1 ? "s" : "");
        }
        throw new IntegrationException(msg, e);
    }
    if (projects > 1) {
        topicMetrics.topicSubmissionsCompleted.increment();
    }
}
#method_after
private void integrateIntoHistory(ChangeSet cs) throws IntegrationException, RestApiException {
    checkArgument(!cs.furtherHiddenChanges(), "cannot integrate hidden changes into history");
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    ListMultimap<Branch.NameKey, ChangeData> cbb;
    try {
        cbb = cs.changesByBranch();
    } catch (OrmException e) {
        throw new IntegrationException("Error reading changes to submit", e);
    }
    Set<Branch.NameKey> branches = cbb.keySet();
    int projects = 0;
    for (Branch.NameKey branch : branches) {
        OpenRepo or = openRepo(branch.getParentKey());
        if (or != null) {
            BranchBatch bb = validateChangeList(or, cbb.get(branch));
            toSubmit.put(branch, bb);
            if (!bb.commits().isEmpty()) {
                projects++;
            }
        }
    }
    // Done checks that don't involve running submit strategies.
    commitStatus.maybeFailVerbose();
    if (projects > 1) {
        topicMetrics.topicSubmissions.increment();
    }
    try {
        SubmoduleOp submoduleOp = subOpFactory.create(branches, orm);
        List<SubmitStrategy> strategies = getSubmitStrategies(toSubmit, submoduleOp, dryrun);
        this.allProjects = submoduleOp.getProjectsInOrder();
        batchUpdateFactory.execute(orm.batchUpdates(batchUpdateFactory, allProjects), new SubmitStrategyListener(submitInput, strategies, commitStatus), submissionId, dryrun);
    } catch (NoSuchProjectException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (IOException | SubmoduleException e) {
        throw new IntegrationException(e);
    } catch (UpdateException e) {
        // BatchUpdate may have inadvertently wrapped an IntegrationException
        // thrown by some legacy SubmitStrategyOp code that intended the error
        // message to be user-visible. Copy the message from the wrapped
        // exception.
        // 
        // If you happen across one of these, the correct fix is to convert the
        // inner IntegrationException to a ResourceConflictException.
        String msg;
        if (e.getCause() instanceof IntegrationException) {
            msg = e.getCause().getMessage();
        } else {
            msg = "Error submitting change" + (cs.size() != 1 ? "s" : "");
        }
        throw new IntegrationException(msg, e);
    }
    if (projects > 1) {
        topicMetrics.topicSubmissionsCompleted.increment();
    }
}
#end_block

#method_before
@Test
public void postSubmitApprovalAfterVoteRemoved() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = project.get() + "~master~" + r.getChangeId();
    setApiUser(admin);
    revision(r).review(ReviewInput.approve());
    setApiUser(user);
    revision(r).review(ReviewInput.recommend());
    setApiUser(admin);
    gApi.changes().id(changeId).reviewer(user.username).deleteVote("Code-Review");
    Optional<ApprovalInfo> crUser = get(changeId, DETAILED_LABELS).labels.get("Code-Review").all.stream().filter(a -> a._accountId == user.id.get()).findFirst();
    assertThat(crUser.isPresent()).isTrue();
    assertThat(crUser.get().value).isEqualTo(0);
    revision(r).submit();
    setApiUser(user);
    ReviewInput in = new ReviewInput();
    in.label("Code-Review", 1);
    in.message = "Still LGTM";
    revision(r).review(in);
    ApprovalInfo cr = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.DETAILED_LABELS)).labels.get("Code-Review").all.stream().filter(a -> a._accountId == user.getId().get()).findFirst().get();
    assertThat(cr.postSubmit).isTrue();
}
#method_after
@Test
public void postSubmitApprovalAfterVoteRemoved() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = project.get() + "~master~" + r.getChangeId();
    setApiUser(admin);
    revision(r).review(ReviewInput.approve());
    setApiUser(user);
    revision(r).review(ReviewInput.recommend());
    setApiUser(admin);
    gApi.changes().id(changeId).reviewer(user.username).deleteVote("Code-Review");
    Optional<ApprovalInfo> crUser = get(changeId, DETAILED_LABELS).labels.get("Code-Review").all.stream().filter(a -> a._accountId == user.id.get()).findFirst();
    assertThat(crUser).isPresent();
    assertThat(crUser.get().value).isEqualTo(0);
    revision(r).submit();
    setApiUser(user);
    ReviewInput in = new ReviewInput();
    in.label("Code-Review", 1);
    in.message = "Still LGTM";
    revision(r).review(in);
    ApprovalInfo cr = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.DETAILED_LABELS)).labels.get("Code-Review").all.stream().filter(a -> a._accountId == user.getId().get()).findFirst().get();
    assertThat(cr.postSubmit).isTrue();
}
#end_block

#method_before
@Test
public void setDescriptionAllowedWithPermission() throws Exception {
    PushOneCommit.Result r = createChange();
    assertDescription(r, "");
    grant(Permission.OWNER, project, "refs/heads/master", false, REGISTERED_USERS);
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).description("test");
    assertDescription(r, "test");
}
#method_after
@Test
public void setDescriptionAllowedWithPermission() throws Exception {
    PushOneCommit.Result r = createChange();
    assertDescription(r, "");
    grant(project, "refs/heads/master", Permission.OWNER, false, REGISTERED_USERS);
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).description("test");
    assertDescription(r, "test");
}
#end_block

#method_before
public Change.Id cherryPick(@Nullable Change.Id sourceChangeId, @Nullable PatchSet.Id sourcePatchId, @Nullable Branch.NameKey sourceBranch, @Nullable String sourceChangeTopic, ObjectId sourceObjectId, String message, ProjectControl projectControl, CherryPickDestination destination, int parent) throws OrmException, IOException, InvalidChangeOperationException, IntegrationException, UpdateException, RestApiException {
    Project.NameKey project = projectControl.getProject().getNameKey();
    try (Repository repo = repoManager.openRepository(project);
        // ensure the cherry-picked commit is flushed before patch sets are updated.
        ObjectInserter oi = repo.newObjectInserter();
        ObjectReader reader = oi.newReader();
        CodeReviewRevWalk revWalk = CodeReviewCommit.newRevWalk(reader)) {
        CodeReviewCommit sourceCommit = revWalk.parseCommit(sourceObjectId);
        if (parent <= 0 || parent > sourceCommit.getParentCount()) {
            throw new InvalidChangeOperationException(String.format("Cherry Pick: Parent %s does not exist. Please specify a parent in" + " range [1, %s].", parent, sourceCommit.getParentCount()));
        }
        Timestamp now = TimeUtil.nowTs();
        PersonIdent committerIdent = userProvider.get().newCommitterIdent(now, serverTimeZone);
        CodeReviewCommit mergeTip = revWalk.parseCommit(destination.mergeTip());
        ObjectId computedChangeId = ChangeIdUtil.computeChangeId(sourceCommit.getTree(), mergeTip, sourceCommit.getAuthorIdent(), committerIdent, message);
        String commitMessage = ChangeIdUtil.insertId(message, computedChangeId).trim() + '\n';
        CodeReviewCommit commit;
        try {
            commit = mergeUtilFactory.create(projectControl.getProjectState()).createCherryPickFromCommit(oi, repo.getConfig(), mergeTip, sourceCommit, committerIdent, commitMessage, revWalk, parent - 1, false);
            Change.Key changeKey;
            final List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                changeKey = new Change.Key(idStr);
            } else {
                changeKey = new Change.Key("I" + computedChangeId.name());
            }
            String targetRef = destination.targetRef();
            Branch.NameKey newDest = new Branch.NameKey(project, targetRef);
            List<ChangeData> destChanges = queryProvider.get().setLimit(2).byBranchKey(newDest, changeKey);
            if (destination.targetAtChange()) {
                if (destChanges.size() > 0) {
                    throw new ResourceConflictException("target branch contains a change with key " + changeKey);
                }
            } else if (destChanges.size() > 1) {
                throw new InvalidChangeOperationException("target branch contains several changes with key " + changeKey + ". Cannot create a new patch set.");
            }
            try (BatchUpdate bu = updateFactory.create(dbProvider.get(), project, userProvider.get(), now)) {
                bu.setRepository(repo, revWalk, oi);
                Change.Id result;
                if (destChanges.size() == 1) {
                    // The change key exists on the destination branch. The cherry pick will be added as a
                    // new patch set.
                    ChangeControl destCtl = projectControl.controlFor(destChanges.get(0).notes());
                    result = insertPatchSet(bu, repo, destCtl, commit);
                } else {
                    // Change key not found on destination branch. We can create a new change.
                    String newTopic = null;
                    if (!Strings.isNullOrEmpty(sourceChangeTopic)) {
                        newTopic = sourceChangeTopic + "-" + newDest.getShortName();
                    }
                    result = createNewChange(bu, commit, targetRef, newTopic, sourceBranch, sourceObjectId);
                    if (sourceChangeId != null && sourcePatchId != null) {
                        bu.addOp(sourceChangeId, new AddMessageToSourceChangeOp(changeMessagesUtil, sourcePatchId, newDest.getShortName(), commit));
                    }
                }
                bu.execute();
                return result;
            }
        } catch (MergeIdenticalTreeException | MergeConflictException e) {
            throw new IntegrationException("Cherry pick failed: " + e.getMessage());
        }
    }
}
#method_after
public Change.Id cherryPick(BatchUpdate.Factory batchUpdateFactory, Change change, PatchSet patch, CherryPickInput input, RefControl refControl) throws OrmException, IOException, InvalidChangeOperationException, IntegrationException, UpdateException, RestApiException {
    return cherryPick(batchUpdateFactory, change.getId(), patch.getId(), change.getDest(), change.getTopic(), change.getProject(), ObjectId.fromString(patch.getRevision().get()), input, refControl);
}
#end_block

#method_before
private Change.Id insertPatchSet(BatchUpdate bu, Repository git, ChangeControl destCtl, CodeReviewCommit cherryPickCommit) throws IOException, OrmException {
    Change destChange = destCtl.getChange();
    PatchSet.Id psId = ChangeUtil.nextPatchSetId(git, destChange.currentPatchSetId());
    PatchSetInserter inserter = patchSetInserterFactory.create(destCtl, psId, cherryPickCommit);
    PatchSet.Id newPatchSetId = inserter.getPatchSetId();
    PatchSet current = psUtil.current(dbProvider.get(), destCtl.getNotes());
    bu.addOp(destChange.getId(), inserter.setMessage("Uploaded patch set " + newPatchSetId.get() + ".").setDraft(current.isDraft()).setNotify(NotifyHandling.NONE));
    return destChange.getId();
}
#method_after
private Change.Id insertPatchSet(BatchUpdate bu, Repository git, ChangeControl destCtl, CodeReviewCommit cherryPickCommit, CherryPickInput input) throws IOException, OrmException, BadRequestException {
    Change destChange = destCtl.getChange();
    PatchSet.Id psId = ChangeUtil.nextPatchSetId(git, destChange.currentPatchSetId());
    PatchSet current = psUtil.current(dbProvider.get(), destCtl.getNotes());
    PatchSetInserter inserter = patchSetInserterFactory.create(destCtl, psId, cherryPickCommit);
    inserter.setMessage("Uploaded patch set " + inserter.getPatchSetId().get() + ".").setDraft(current.isDraft()).setNotify(input.notify).setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
    bu.addOp(destChange.getId(), inserter);
    return destChange.getId();
}
#end_block

#method_before
private Change.Id createNewChange(BatchUpdate bu, CodeReviewCommit cherryPickCommit, String refName, String topic, Branch.NameKey sourceBranch, ObjectId sourceCommit) throws OrmException, IOException {
    Change.Id changeId = new Change.Id(seq.nextChangeId());
    ChangeInserter ins = changeInserterFactory.create(changeId, cherryPickCommit, refName).setTopic(topic);
    ins.setMessage(messageForDestinationChange(ins.getPatchSetId(), sourceBranch, sourceCommit));
    bu.insertChange(ins);
    return changeId;
}
#method_after
private Change.Id createNewChange(BatchUpdate bu, CodeReviewCommit cherryPickCommit, String refName, String topic, Branch.NameKey sourceBranch, ObjectId sourceCommit, CherryPickInput input) throws OrmException, IOException, BadRequestException {
    Change.Id changeId = new Change.Id(seq.nextChangeId());
    ChangeInserter ins = changeInserterFactory.create(changeId, cherryPickCommit, refName).setTopic(topic);
    ins.setMessage(messageForDestinationChange(ins.getPatchSetId(), sourceBranch, sourceCommit)).setNotify(input.notify).setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
    bu.insertChange(ins);
    return changeId;
}
#end_block

#method_before
@Override
protected ChangeInfo applyImpl(BatchUpdate.Factory updateFactory, RevisionResource revision, CherryPickInput input) throws OrmException, IOException, UpdateException, RestApiException {
    if (input == null) {
        input = new CherryPickInput();
    }
    String message = Strings.nullToEmpty(input.message).trim();
    if (message.isEmpty()) {
        throw new BadRequestException("message must be non-empty");
    }
    String destination = Strings.nullToEmpty(input.destination).trim();
    if (destination.isEmpty()) {
        throw new BadRequestException("destination must be non-empty");
    }
    ChangeControl control = revision.getControl();
    if (!control.isVisible(dbProvider.get())) {
        throw new AuthException("Cherry pick not permitted");
    }
    ProjectControl projectControl = control.getProjectControl();
    Capable capable = projectControl.canPushToAtLeastOneRef();
    if (capable != Capable.OK) {
        throw new AuthException(capable.getMessage());
    }
    CherryPickDestination dest = cherryPickUtil.parseDestination(projectControl, destination);
    RefControl refControl = projectControl.controlForRef(dest.targetRef());
    if (!refControl.canUpload()) {
        throw new AuthException("Not allowed to cherry pick " + revision.getChange().getId().toString() + " to " + destination);
    }
    int parent = input.parent == null ? 1 : input.parent;
    try {
        Change.Id cherryPickedChangeId = // TODO(dborowitz): Pass updateFactory here.
        cherryPickChange.cherryPick(revision.getChange(), revision.getPatchSet(), message, projectControl, dest, parent);
        return json.noOptions().format(revision.getProject(), cherryPickedChangeId);
    } catch (InvalidChangeOperationException e) {
        throw new BadRequestException(e.getMessage());
    } catch (IntegrationException | NoSuchChangeException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
@Override
protected ChangeInfo applyImpl(BatchUpdate.Factory updateFactory, RevisionResource revision, CherryPickInput input) throws OrmException, IOException, UpdateException, RestApiException {
    final ChangeControl control = revision.getControl();
    input.parent = input.parent == null ? 1 : input.parent;
    if (input.message == null || input.message.trim().isEmpty()) {
        throw new BadRequestException("message must be non-empty");
    } else if (input.destination == null || input.destination.trim().isEmpty()) {
        throw new BadRequestException("destination must be non-empty");
    }
    if (!control.isVisible(dbProvider.get())) {
        throw new AuthException("Cherry pick not permitted");
    }
    ProjectControl projectControl = control.getProjectControl();
    Capable capable = projectControl.canPushToAtLeastOneRef();
    if (capable != Capable.OK) {
        throw new AuthException(capable.getMessage());
    }
    RefControl refControl = projectControl.controlForRef(RefNames.fullName(input.destination));
    if (!refControl.canUpload()) {
        throw new AuthException("Not allowed to cherry pick " + revision.getChange().getId().toString() + " to " + input.destination);
    }
    try {
        Change.Id cherryPickedChangeId = cherryPickChange.cherryPick(updateFactory, revision.getChange(), revision.getPatchSet(), input, refControl);
        return json.noOptions().format(revision.getProject(), cherryPickedChangeId);
    } catch (InvalidChangeOperationException e) {
        throw new BadRequestException(e.getMessage());
    } catch (IntegrationException | NoSuchChangeException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
@Test
public void cherryPickCommitWithoutChangeId() throws Exception {
    // This test is a little superfluous, since the current cherry-pick code ignores
    // the commit message of the to-be-cherry-picked change, using the one in
    // CherryPickInput instead.
    CherryPickInput input = new CherryPickInput();
    input.destination = "foo";
    input.message = "it goes to foo branch";
    gApi.projects().name(project.get()).branch(input.destination).create(new BranchInput());
    RevCommit revCommit = createNewCommitWithoutChangeId();
    ChangeInfo changeInfo = gApi.projects().name(project.get()).commit(revCommit.getName()).cherryPick(input).get();
    assertThat(changeInfo.messages).hasSize(1);
    Iterator<ChangeMessageInfo> messageIterator = changeInfo.messages.iterator();
    String expectedMessage = String.format("Patch Set 1: Cherry Picked from commit %s.", revCommit.getName());
    assertThat(messageIterator.next().message).isEqualTo(expectedMessage);
    RevisionInfo revInfo = changeInfo.revisions.get(changeInfo.currentRevision);
    assertThat(revInfo).isNotNull();
    CommitInfo commitInfo = revInfo.commit;
    assertThat(commitInfo.message).isEqualTo(input.message + "\n\nChange-Id: " + changeInfo.changeId + "\n");
}
#method_after
@Test
public void cherryPickCommitWithoutChangeId() throws Exception {
    // This test is a little superfluous, since the current cherry-pick code ignores
    // the commit message of the to-be-cherry-picked change, using the one in
    // CherryPickInput instead.
    CherryPickInput input = new CherryPickInput();
    input.destination = "foo";
    input.message = "it goes to foo branch";
    gApi.projects().name(project.get()).branch(input.destination).create(new BranchInput());
    RevCommit revCommit = createNewCommitWithoutChangeId("refs/heads/master", "a.txt", "content");
    ChangeInfo changeInfo = gApi.projects().name(project.get()).commit(revCommit.getName()).cherryPick(input).get();
    assertThat(changeInfo.messages).hasSize(1);
    Iterator<ChangeMessageInfo> messageIterator = changeInfo.messages.iterator();
    String expectedMessage = String.format("Patch Set 1: Cherry Picked from commit %s.", revCommit.getName());
    assertThat(messageIterator.next().message).isEqualTo(expectedMessage);
    RevisionInfo revInfo = changeInfo.revisions.get(changeInfo.currentRevision);
    assertThat(revInfo).isNotNull();
    CommitInfo commitInfo = revInfo.commit;
    assertThat(commitInfo.message).isEqualTo(input.message + "\n\nChange-Id: " + changeInfo.changeId + "\n");
}
#end_block

#method_before
private void changeInTwoBranches(String branchA, String fileA, String branchB, String fileB) throws Exception {
    // create a initial commit in master
    Result initialCommit = pushFactory.create(db, user.getIdent(), testRepo, "initial commit", "readme.txt", "initial commit").to("refs/heads/master");
    initialCommit.assertOkStatus();
    // create two new branches
    createBranch(new Branch.NameKey(project, branchA));
    createBranch(new Branch.NameKey(project, branchB));
    // create a commit in branchA
    Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", fileA, "A content").to("refs/heads/" + branchA);
    changeA.assertOkStatus();
    // create a commit in branchB
    PushOneCommit commitB = pushFactory.create(db, user.getIdent(), testRepo, "change B", fileB, "B content");
    commitB.setParent(initialCommit.getCommit());
    Result changeB = commitB.to("refs/heads/" + branchB);
    changeB.assertOkStatus();
}
#method_after
private Map<String, Result> changeInTwoBranches(String branchA, String fileA, String branchB, String fileB) throws Exception {
    // create a initial commit in master
    Result initialCommit = pushFactory.create(db, user.getIdent(), testRepo, "initial commit", "readme.txt", "initial commit").to("refs/heads/master");
    initialCommit.assertOkStatus();
    // create two new branches
    createBranch(new Branch.NameKey(project, branchA));
    createBranch(new Branch.NameKey(project, branchB));
    // create a commit in branchA
    Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", fileA, "A content").to("refs/heads/" + branchA);
    changeA.assertOkStatus();
    // create a commit in branchB
    PushOneCommit commitB = pushFactory.create(db, user.getIdent(), testRepo, "change B", fileB, "B content");
    commitB.setParent(initialCommit.getCommit());
    Result changeB = commitB.to("refs/heads/" + branchB);
    changeB.assertOkStatus();
    return ImmutableMap.of("master", initialCommit, branchA, changeA, branchB, changeB);
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), ctx.getRevWalk().parseCommit(commitId), psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setChangeId(change.getKey().get());
    update.setSubjectForCommit("Create change");
    update.setBranch(change.getDest().get());
    update.setTopic(change.getTopic());
    update.setPsDescription(patchSetDescription);
    update.setPrivate(isPrivate);
    update.setWorkInProgress(workInProgress);
    boolean draft = status == Change.Status.DRAFT;
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        newGroups = GroupCollector.getDefaultGroups(commitId);
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commitId, draft, newGroups, pushCert, patchSetDescription);
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    Set<Account.Id> reviewersToAdd = new HashSet<>(reviewers);
    if (migration.readChanges()) {
        approvalsUtil.addCcs(ctx.getNotes(), update, extraCC);
    } else {
        reviewersToAdd.addAll(extraCC);
    }
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, filterOnChangeVisibility(db, ctx.getNotes(), reviewersToAdd), Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovalsForNewPatchSet(db, update, labelTypes, patchSet, ctx.getControl(), approvals);
    // reviewer which is needed in several other code paths.
    if (!approvals.isEmpty()) {
        update.putReviewer(ctx.getAccountId(), REVIEWER);
    }
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(patchSet.getId(), ctx.getUser(), patchSet.getCreatedOn(), message, ChangeMessagesUtil.uploadedPatchSetTag(workInProgress));
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), ctx.getRevWalk().parseCommit(commitId), psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setChangeId(change.getKey().get());
    update.setSubjectForCommit("Create change");
    update.setBranch(change.getDest().get());
    update.setTopic(change.getTopic());
    update.setPsDescription(patchSetDescription);
    update.setPrivate(isPrivate);
    update.setWorkInProgress(workInProgress);
    boolean draft = status == Change.Status.DRAFT;
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        newGroups = GroupCollector.getDefaultGroups(commitId);
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commitId, draft, newGroups, pushCert, patchSetDescription);
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    Set<Account.Id> reviewersToAdd = new HashSet<>(reviewers);
    if (migration.readChanges()) {
        approvalsUtil.addCcs(ctx.getNotes(), update, filterOnChangeVisibility(db, ctx.getNotes(), extraCC));
    } else {
        reviewersToAdd.addAll(extraCC);
    }
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, filterOnChangeVisibility(db, ctx.getNotes(), reviewersToAdd), Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovalsForNewPatchSet(db, update, labelTypes, patchSet, ctx.getControl(), approvals);
    // reviewer which is needed in several other code paths.
    if (!approvals.isEmpty()) {
        update.putReviewer(ctx.getAccountId(), REVIEWER);
    }
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(patchSet.getId(), ctx.getUser(), patchSet.getCreatedOn(), message, ChangeMessagesUtil.uploadedPatchSetTag(workInProgress));
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
public void assertChange(Change.Status expectedStatus, String expectedTopic, TestAccount... expectedReviewers) throws OrmException {
    assertChange(expectedStatus, expectedTopic, false, Arrays.asList(expectedReviewers), ImmutableList.of());
}
#method_after
public void assertChange(Change.Status expectedStatus, String expectedTopic, TestAccount... expectedReviewers) throws OrmException {
    assertChange(expectedStatus, expectedTopic, Arrays.asList(expectedReviewers), ImmutableList.of());
}
#end_block

#method_before
public void assertChange(Change.Status expectedStatus, String expectedTopic, boolean legacyCcs, List<TestAccount> expectedReviewers, List<TestAccount> expectedCcs) throws OrmException {
    Change c = getChange().change();
    assertThat(c.getSubject()).isEqualTo(resSubj);
    assertThat(c.getStatus()).isEqualTo(expectedStatus);
    assertThat(Strings.emptyToNull(c.getTopic())).isEqualTo(expectedTopic);
    if (legacyCcs) {
        assertReviewers(c, ReviewerStateInternal.REVIEWER, Stream.concat(expectedReviewers.stream(), expectedCcs.stream()).collect(toList()));
    } else {
        assertReviewers(c, ReviewerStateInternal.REVIEWER, expectedReviewers);
        assertReviewers(c, ReviewerStateInternal.CC, expectedCcs);
    }
}
#method_after
public void assertChange(Change.Status expectedStatus, String expectedTopic, List<TestAccount> expectedReviewers, List<TestAccount> expectedCcs) throws OrmException {
    Change c = getChange().change();
    assertThat(c.getSubject()).isEqualTo(resSubj);
    assertThat(c.getStatus()).isEqualTo(expectedStatus);
    assertThat(Strings.emptyToNull(c.getTopic())).isEqualTo(expectedTopic);
    if (notesMigration.readChanges()) {
        assertReviewers(c, ReviewerStateInternal.REVIEWER, expectedReviewers);
        assertReviewers(c, ReviewerStateInternal.CC, expectedCcs);
    } else {
        assertReviewers(c, ReviewerStateInternal.REVIEWER, Stream.concat(expectedReviewers.stream(), expectedCcs.stream()).collect(toList()));
    }
}
#end_block

#method_before
@Test
public void pushForMasterWithCc() throws Exception {
    // cc one user
    String topic = "my/topic";
    PushOneCommit.Result r = pushTo("refs/for/master/" + topic + "%cc=" + user.email);
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, topic, !notesMigration.readChanges(), ImmutableList.of(), ImmutableList.of(user));
    // cc several users
    r = pushTo("refs/for/master/" + topic + "%cc=" + admin.email + ",cc=" + user.email + ",cc=" + accounts.user2().email);
    r.assertOkStatus();
    // Check that admin isn't CC'd as they own the change
    r.assertChange(Change.Status.NEW, topic, !notesMigration.readChanges(), ImmutableList.of(), ImmutableList.of(user, accounts.user2()));
    // cc non-existing user
    String nonExistingEmail = "non.existing@example.com";
    r = pushTo("refs/for/master/" + topic + "%cc=" + admin.email + ",cc=" + nonExistingEmail + ",cc=" + user.email);
    r.assertErrorStatus("user \"" + nonExistingEmail + "\" not found");
}
#method_after
@Test
public void pushForMasterWithCc() throws Exception {
    // cc one user
    String topic = "my/topic";
    PushOneCommit.Result r = pushTo("refs/for/master/" + topic + "%cc=" + user.email);
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, topic, ImmutableList.of(), ImmutableList.of(user));
    // cc several users
    r = pushTo("refs/for/master/" + topic + "%cc=" + admin.email + ",cc=" + user.email + ",cc=" + accounts.user2().email);
    r.assertOkStatus();
    // Check that admin isn't CC'd as they own the change
    r.assertChange(Change.Status.NEW, topic, ImmutableList.of(), ImmutableList.of(user, accounts.user2()));
    // cc non-existing user
    String nonExistingEmail = "non.existing@example.com";
    r = pushTo("refs/for/master/" + topic + "%cc=" + admin.email + ",cc=" + nonExistingEmail + ",cc=" + user.email);
    r.assertErrorStatus("user \"" + nonExistingEmail + "\" not found");
}
#end_block

#method_before
@Test
public void revertPreservesReviewersAndCcs() throws Exception {
    PushOneCommit.Result r = createChange();
    ReviewInput in = ReviewInput.approve();
    in.reviewer(user.email);
    in.reviewer(accounts.user2().email, ReviewerState.CC, true);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(in);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    // expect both the original reviewers and CCs to be preserved
    // original owner should be added as reviewer, user requesting the revert (new owner) removed
    setApiUser(accounts.admin2());
    Map<ReviewerState, Collection<AccountInfo>> result = gApi.changes().id(r.getChangeId()).revert().get().reviewers;
    assertThat(result.containsKey(ReviewerState.REVIEWER)).isTrue();
    List<Integer> reviewers = result.get(ReviewerState.REVIEWER).stream().map(a -> a._accountId).collect(toList());
    assertThat(reviewers).containsAllOf(user.id.get(), admin.id.get());
    if (notesMigration.readChanges()) {
        assertThat(result.containsKey(ReviewerState.CC)).isTrue();
        List<Integer> ccs = result.get(ReviewerState.CC).stream().map(a -> a._accountId).collect(toList());
        assertThat(ccs).containsExactly(accounts.user2().id.get());
    } else {
        assertThat(reviewers).contains(accounts.user2().id.get());
    }
}
#method_after
@Test
public void revertPreservesReviewersAndCcs() throws Exception {
    PushOneCommit.Result r = createChange();
    ReviewInput in = ReviewInput.approve();
    in.reviewer(user.email);
    in.reviewer(accounts.user2().email, ReviewerState.CC, true);
    // Add user as reviewer that will create the revert
    in.reviewer(accounts.admin2().email);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(in);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    // expect both the original reviewers and CCs to be preserved
    // original owner should be added as reviewer, user requesting the revert (new owner) removed
    setApiUser(accounts.admin2());
    Map<ReviewerState, Collection<AccountInfo>> result = gApi.changes().id(r.getChangeId()).revert().get().reviewers;
    assertThat(result).containsKey(ReviewerState.REVIEWER);
    List<Integer> reviewers = result.get(ReviewerState.REVIEWER).stream().map(a -> a._accountId).collect(toList());
    if (notesMigration.readChanges()) {
        assertThat(result).containsKey(ReviewerState.CC);
        List<Integer> ccs = result.get(ReviewerState.CC).stream().map(a -> a._accountId).collect(toList());
        assertThat(ccs).containsExactly(accounts.user2().id.get());
        assertThat(reviewers).containsExactly(user.id.get(), admin.id.get());
    } else {
        assertThat(reviewers).containsExactly(user.id.get(), admin.id.get(), accounts.user2().id.get());
    }
}
#end_block

#method_before
private Change.Id revert(BatchUpdate.Factory updateFactory, ChangeControl ctl, String message) throws OrmException, IOException, RestApiException, UpdateException {
    Change.Id changeIdToRevert = ctl.getChange().getId();
    PatchSet.Id patchSetId = ctl.getChange().currentPatchSetId();
    PatchSet patch = psUtil.get(db.get(), ctl.getNotes(), patchSetId);
    if (patch == null) {
        throw new ResourceNotFoundException(changeIdToRevert.toString());
    }
    Project.NameKey project = ctl.getProject().getNameKey();
    CurrentUser user = ctl.getUser();
    try (Repository git = repoManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk revWalk = new RevWalk(reader)) {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        if (commitToRevert.getParentCount() == 0) {
            throw new ResourceConflictException("Cannot revert initial commit");
        }
        Timestamp now = TimeUtil.nowTs();
        PersonIdent committerIdent = new PersonIdent(serverIdent, now);
        PersonIdent authorIdent = user.asIdentifiedUser().newCommitterIdent(now, committerIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(authorIdent);
        Change changeToRevert = ctl.getChange();
        if (message == null) {
            message = MessageFormat.format(ChangeMessages.get().revertChangeDefaultMessage, changeToRevert.getSubject(), patch.getRevision().get());
        }
        ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, committerIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ObjectId id = oi.insert(revertCommitBuilder);
        RevCommit revertCommit = revWalk.parseCommit(id);
        ChangeInserter ins = changeInserterFactory.create(changeId, revertCommit, ctl.getChange().getDest().get()).setTopic(changeToRevert.getTopic());
        ins.setMessage("Uploaded patch set 1.");
        ReviewerSet reviewerSet = approvalsUtil.getReviewers(db.get(), ctl.getNotes());
        Set<Account.Id> reviewers = new HashSet<>();
        reviewers.add(changeToRevert.getOwner());
        reviewers.addAll(reviewerSet.byState(ReviewerStateInternal.REVIEWER));
        reviewers.remove(user.getAccountId());
        ins.setReviewers(reviewers);
        Set<Account.Id> ccs = new HashSet<>();
        ccs.addAll(reviewerSet.byState(ReviewerStateInternal.CC));
        ccs.remove(user.getAccountId());
        ins.setCcs(ccs);
        try (BatchUpdate bu = updateFactory.create(db.get(), project, user, now)) {
            bu.setRepository(git, revWalk, oi);
            bu.insertChange(ins);
            bu.addOp(changeId, new NotifyOp(ctl.getChange(), ins));
            bu.addOp(changeToRevert.getId(), new PostRevertedMessageOp(computedChangeId));
            bu.execute();
        }
        return changeId;
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(changeIdToRevert.toString(), e);
    }
}
#method_after
private Change.Id revert(BatchUpdate.Factory updateFactory, ChangeControl ctl, String message) throws OrmException, IOException, RestApiException, UpdateException {
    Change.Id changeIdToRevert = ctl.getChange().getId();
    PatchSet.Id patchSetId = ctl.getChange().currentPatchSetId();
    PatchSet patch = psUtil.get(db.get(), ctl.getNotes(), patchSetId);
    if (patch == null) {
        throw new ResourceNotFoundException(changeIdToRevert.toString());
    }
    Project.NameKey project = ctl.getProject().getNameKey();
    CurrentUser user = ctl.getUser();
    try (Repository git = repoManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk revWalk = new RevWalk(reader)) {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        if (commitToRevert.getParentCount() == 0) {
            throw new ResourceConflictException("Cannot revert initial commit");
        }
        Timestamp now = TimeUtil.nowTs();
        PersonIdent committerIdent = new PersonIdent(serverIdent, now);
        PersonIdent authorIdent = user.asIdentifiedUser().newCommitterIdent(now, committerIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(authorIdent);
        Change changeToRevert = ctl.getChange();
        if (message == null) {
            message = MessageFormat.format(ChangeMessages.get().revertChangeDefaultMessage, changeToRevert.getSubject(), patch.getRevision().get());
        }
        ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, committerIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ObjectId id = oi.insert(revertCommitBuilder);
        RevCommit revertCommit = revWalk.parseCommit(id);
        ChangeInserter ins = changeInserterFactory.create(changeId, revertCommit, ctl.getChange().getDest().get()).setTopic(changeToRevert.getTopic());
        ins.setMessage("Uploaded patch set 1.");
        ReviewerSet reviewerSet = approvalsUtil.getReviewers(db.get(), ctl.getNotes());
        Set<Account.Id> reviewers = new HashSet<>();
        reviewers.add(changeToRevert.getOwner());
        reviewers.addAll(reviewerSet.byState(ReviewerStateInternal.REVIEWER));
        reviewers.remove(user.getAccountId());
        ins.setReviewers(reviewers);
        Set<Account.Id> ccs = new HashSet<>(reviewerSet.byState(ReviewerStateInternal.CC));
        ccs.remove(user.getAccountId());
        ins.setExtraCC(ccs);
        try (BatchUpdate bu = updateFactory.create(db.get(), project, user, now)) {
            bu.setRepository(git, revWalk, oi);
            bu.insertChange(ins);
            bu.addOp(changeId, new NotifyOp(ctl.getChange(), ins));
            bu.addOp(changeToRevert.getId(), new PostRevertedMessageOp(computedChangeId));
            bu.execute();
        }
        return changeId;
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(changeIdToRevert.toString(), e);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    factory(LfsGetLocksAction.Factory.class);
    factory(LfsPutLocksAction.Factory.class);
    factory(LfsProjectLocks.Factory.class);
}
#method_after
@Override
protected void configure() {
    factory(LfsGetLocksAction.Factory.class);
    factory(LfsPutLocksAction.Factory.class);
    factory(LfsProjectLocks.Factory.class);
    install(LfsLocksHandler.module());
}
#end_block

#method_before
LfsLockResponse createLock(String project, CurrentUser user, LfsCreateLockInput input) throws LfsException {
    log.debug("Create lock for {} in project {}", input.path, project);
    LfsProjectLocks locks = projects.getUnchecked(project);
    LfsLock lock = locks.createLock(user, input);
    return new LfsLockResponse(lock);
}
#method_after
LfsLockResponse createLock(Project.NameKey project, CurrentUser user, LfsCreateLockInput input) throws LfsException {
    log.debug("Create lock for {} in project {}", input.path, project);
    LfsProjectLocks locks = projectLocks.getUnchecked(project);
    LfsLock lock = locks.createLock(user, input);
    return new LfsLockResponse(lock);
}
#end_block

#method_before
LfsLockResponse deleteLock(String project, CurrentUser user, String lockId, LfsDeleteLockInput input) throws LfsException {
    log.debug("Delete (-f {}) lock for {} in project {}", Boolean.TRUE.equals(input.force), lockId, project);
    LfsProjectLocks locks = projects.getUnchecked(project);
    Optional<LfsLock> hasLock = locks.getLock(lockId);
    if (!hasLock.isPresent()) {
        throw new LfsException(String.format("there is no lock id %s in project %s", lockId, project));
    }
    LfsLock lock = hasLock.get();
    if (lock.owner.name.equals(user.getUserName())) {
        locks.deleteLock(lock);
        return new LfsLockResponse(lock);
    } else if (input.force) {
        locks.deleteLock(lock);
        return new LfsLockResponse(lock);
    }
    throw new LfsException(String.format("Lock %s is owned by different user %s", lockId, lock.owner.name));
}
#method_after
LfsLockResponse deleteLock(Project.NameKey project, CurrentUser user, String lockId, LfsDeleteLockInput input) throws LfsException {
    log.debug("Delete (-f {}) lock for {} in project {}", Boolean.TRUE.equals(input.force), lockId, project);
    LfsProjectLocks locks = projectLocks.getUnchecked(project);
    Optional<LfsLock> hasLock = locks.getLock(lockId);
    if (!hasLock.isPresent()) {
        throw new LfsException(String.format("there is no lock id %s in project %s", lockId, project));
    }
    LfsLock lock = hasLock.get();
    if (lock.owner.name.equals(user.getUserName())) {
        locks.deleteLock(lock);
        return new LfsLockResponse(lock);
    } else if (input.force) {
        locks.deleteLock(lock);
        return new LfsLockResponse(lock);
    }
    throw new LfsException(String.format("Lock %s is owned by different user %s", lockId, lock.owner.name));
}
#end_block

#method_before
LfsVerifyLocksResponse verifyLocks(String project, final CurrentUser user) {
    log.debug("Verify list of locks for {} project and user {}", project, user);
    LfsProjectLocks locks = projects.getUnchecked(project);
    Function<LfsLock, Boolean> isOurs = new Function<LfsLock, Boolean>() {

        @Override
        public Boolean apply(LfsLock input) {
            return input.owner.name.equals(user.getUserName());
        }
    };
    Map<Boolean, List<LfsLock>> groupByOurs = locks.getLocks().stream().collect(Collectors.groupingBy(isOurs));
    return new LfsVerifyLocksResponse(groupByOurs.get(true), groupByOurs.get(false), null);
}
#method_after
LfsVerifyLocksResponse verifyLocks(Project.NameKey project, final CurrentUser user) {
    log.debug("Verify list of locks for {} project and user {}", project, user);
    LfsProjectLocks locks = projectLocks.getUnchecked(project);
    Function<LfsLock, Boolean> isOurs = new Function<LfsLock, Boolean>() {

        @Override
        public Boolean apply(LfsLock input) {
            return input.owner.name.equals(user.getUserName());
        }
    };
    Map<Boolean, List<LfsLock>> groupByOurs = locks.getLocks().stream().collect(Collectors.groupingBy(isOurs));
    return new LfsVerifyLocksResponse(groupByOurs.get(true), groupByOurs.get(false), null);
}
#end_block

#method_before
LfsGetLocksResponse listLocksByPath(String project, String path) {
    log.debug("Get lock for {} path in {} project", path, project);
    String lockId = toLockId.apply(path);
    return listLocksById(project, lockId);
}
#method_after
LfsGetLocksResponse listLocksByPath(Project.NameKey project, String path) {
    log.debug("Get lock for {} path in {} project", path, project);
    String lockId = toLockId.apply(path);
    return listLocksById(project, lockId);
}
#end_block

#method_before
LfsGetLocksResponse listLocksById(String project, String id) {
    log.debug("Get lock for {} id in {} project", id, project);
    LfsProjectLocks locks = projects.getUnchecked(project);
    Optional<LfsLock> lock = locks.getLock(id);
    List<LfsLock> locksById = (lock.isPresent() ? Lists.newArrayList(lock.get()) : Collections.emptyList());
    return new LfsGetLocksResponse(locksById, null);
}
#method_after
LfsGetLocksResponse listLocksById(Project.NameKey project, String id) {
    log.debug("Get lock for {} id in {} project", id, project);
    LfsProjectLocks locks = projectLocks.getUnchecked(project);
    Optional<LfsLock> lock = locks.getLock(id);
    List<LfsLock> locksById = (lock.isPresent() ? ImmutableList.of(lock.get()) : Collections.emptyList());
    return new LfsGetLocksResponse(locksById, null);
}
#end_block

#method_before
LfsGetLocksResponse listLocks(String project) {
    log.debug("Get locks for {} project", project);
    return new LfsGetLocksResponse(projects.getUnchecked(project).getLocks(), null);
}
#method_after
LfsGetLocksResponse listLocks(Project.NameKey project) {
    log.debug("Get locks for {} project", project);
    return new LfsGetLocksResponse(projectLocks.getUnchecked(project).getLocks(), null);
}
#end_block

#method_before
@Override
public LfsProjectLocks load(String project) throws Exception {
    LfsProjectLocks locks = factory.create(project);
    locks.load();
    return locks;
}
#method_after
@Override
public LfsProjectLocks load(Project.NameKey project) throws Exception {
    LfsProjectLocks locks = factory.create(project);
    locks.load();
    return locks;
}
#end_block

#method_before
Optional<LfsLock> getLock(String lockId) {
    return Optional.fromNullable(locks.getIfPresent(lockId));
}
#method_after
Optional<LfsLock> getLock(String lockId) {
    return Optional.ofNullable(locks.getIfPresent(lockId));
}
#end_block

#method_before
LfsLock createLock(CurrentUser user, LfsCreateLockInput input) throws LfsException {
    log.debug("Create lock for {} in project {}", input.path, project);
    String lockId = toLockId.apply(input.path);
    LfsLock lock = locks.getIfPresent(lockId);
    if (lock != null) {
        throw new LfsLockExistsException(lock);
    }
    lock = new LfsLock(lockId, input.path, now(), new LfsLockOwner(user.getUserName()));
    LockFile fileLock = new LockFile(locksPath.resolve(lockId).toFile());
    try {
        if (!fileLock.lock()) {
            log.warn("Cannot lock path [{}] in project {}", input.path, project);
            throw new LfsLockExistsException(lock);
        }
    } catch (IOException e) {
        String error = String.format("Locking path [%s] in project %s failed with error %s", input.path, project, e.getMessage());
        log.warn(error);
        throw new LfsException(error);
    }
    try {
        try (OutputStreamWriter out = new OutputStreamWriter(fileLock.getOutputStream())) {
            gson.toJson(lock, out);
        } catch (IOException e) {
            String error = String.format("Locking path [%s] in project %s failed during write with error %s", input.path, project, e.getMessage());
            log.warn(error);
            throw new LfsException(error);
        }
        if (!fileLock.commit()) {
            String error = String.format("Committing locking to path [%s] in project %s failed", input.path, project);
            log.warn(error);
            throw new LfsException(error);
        }
    } finally {
        fileLock.unlock();
    }
    locks.put(lockId, lock);
    return lock;
}
#method_after
LfsLock createLock(CurrentUser user, LfsCreateLockInput input) throws LfsException {
    log.debug("Create lock for {} in project {}", input.path, project);
    String lockId = toLockId.apply(input.path);
    LfsLock lock = locks.getIfPresent(lockId);
    if (lock != null) {
        throw new LfsLockExistsException(lock);
    }
    lock = new LfsLock(lockId, input.path, now(), new LfsLockOwner(user.getUserName()));
    LockFile fileLock = new LockFile(locksPath.resolve(lockId).toFile());
    try {
        if (!fileLock.lock()) {
            log.warn("Cannot lock path [{}] in project {}", input.path, project);
            throw new LfsLockExistsException(lock);
        }
    } catch (IOException e) {
        String error = String.format("Locking path [%s] in project %s failed with error %s", input.path, project, e.getMessage());
        log.warn(error);
        throw new LfsException(error);
    }
    try {
        try (OutputStreamWriter out = new OutputStreamWriter(fileLock.getOutputStream())) {
            gson.toJson(lock, out);
        } catch (IOException e) {
            String error = String.format("Locking path [%s] in project %s failed during write with error %s", input.path, project, e.getMessage());
            log.warn(error);
            throw new LfsException(error);
        }
        if (!fileLock.commit()) {
            String error = String.format("Committing lock to path [%s] in project %s failed", input.path, project);
            log.warn(error);
            throw new LfsException(error);
        }
        // put lock object to cache while file lock is being hold so that
        // there is no chance that other process performs lock operation
        // in the meantime (either cache returns with existing object or
        // LockFile.lock fails on locking attempt)
        locks.put(lockId, lock);
    } finally {
        fileLock.unlock();
    }
    return lock;
}
#end_block

#method_before
@Override
protected String getProjectName() throws LfsException {
    Matcher matcher = LFS_LOCKS_URL.matcher(context.path);
    if (matcher.matches()) {
        return matcher.group(1);
    }
    throw new LfsException("no repository at " + context.path);
}
#method_after
@Override
protected String getProjectName() throws LfsException {
    Matcher matcher = LFS_LOCKS_URL_PATTERN.matcher(context.path);
    if (matcher.matches()) {
        return matcher.group(1);
    }
    throw new LfsException("no repository at " + context.path);
}
#end_block

#method_before
@Override
protected void authorizeUser(ProjectControl control) throws LfsUnauthorized {
    if (!control.isReadable()) {
        throwUnauthroizedOp("list locks", control, log);
    }
}
#method_after
@Override
protected void authorizeUser(ProjectControl control) throws LfsUnauthorized {
    if (!control.isReadable()) {
        throwUnauthorizedOp("list locks", control);
    }
}
#end_block

#method_before
@Override
protected String getProjectName() throws LfsException {
    Matcher matcher = LFS_LOCKS_URL.matcher(context.path);
    if (matcher.matches()) {
        String project = matcher.group(1);
        String lockId = matcher.group(2);
        if (Strings.isNullOrEmpty(lockId)) {
            action = new CreateLock();
        } else {
            action = new DeleteLock(lockId);
        }
        return project;
    }
    matcher = LFS_VERIFICATION_URL.matcher(context.path);
    if (matcher.matches()) {
        action = new VerifyLock();
        return matcher.group(1);
    }
    throw new LfsException(String.format("Unsupported path %s was provided", context.path));
}
#method_after
@Override
protected String getProjectName() throws LfsException {
    Matcher matcher = LFS_LOCKS_URL_PATTERN.matcher(context.path);
    if (matcher.matches()) {
        String project = matcher.group(1);
        String lockId = matcher.group(2);
        if (Strings.isNullOrEmpty(lockId)) {
            action = new CreateLock();
        } else {
            action = new DeleteLock(lockId);
        }
        return project;
    }
    matcher = LFS_VERIFICATION_URL_PATTERN.matcher(context.path);
    if (matcher.matches()) {
        action = new VerifyLock();
        return matcher.group(1);
    }
    throw new LfsException(String.format("Unsupported path %s was provided", context.path));
}
#end_block

#method_before
@Override
protected void authorizeUser(ProjectControl control) throws LfsUnauthorized {
    // all operations require push permission
    if (Capable.OK != control.canPushToAtLeastOneRef()) {
        throwUnauthroizedOp(action.getName(), control, log);
    }
}
#method_after
@Override
protected void authorizeUser(ProjectControl control) throws LfsUnauthorized {
    // all operations require push permission
    if (Capable.OK != control.canPushToAtLeastOneRef()) {
        throwUnauthorizedOp(action.getName(), control);
    }
}
#end_block

#method_before
@Override
protected void doRun() throws LfsException, IOException {
    Matcher matcher = LFS_LOCKS_URL.matcher(context.path);
    if (matcher.matches()) {
        String project = matcher.group(1);
        String lockId = matcher.group(2);
        if (Strings.isNullOrEmpty(lockId)) {
            createLock(project, context);
        } else {
            deleteLock(project, lockId, context);
        }
        return;
    }
    matcher = LFS_VERIFICATION_URL.matcher(context.path);
    if (matcher.matches()) {
        verifyLocks(matcher.group(1), context);
        return;
    }
    throw new LfsException(String.format("Unsupported path %s was provided", context.path));
}
#method_after
@Override
protected void doRun() throws LfsException, IOException {
    Matcher matcher = LFS_LOCKS_URL_PATTERN.matcher(context.path);
    if (matcher.matches()) {
        String project = matcher.group(1);
        String lockId = matcher.group(2);
        if (Strings.isNullOrEmpty(lockId)) {
            createLock(project, context);
        } else {
            deleteLock(project, lockId, context);
        }
        return;
    }
    matcher = LFS_VERIFICATION_URL_PATTERN.matcher(context.path);
    if (matcher.matches()) {
        verifyLocks(matcher.group(1), context);
        return;
    }
    throw new LfsException(String.format("Unsupported path %s was provided", context.path));
}
#end_block

#method_before
@Override
protected void doRun() throws LfsException, IOException {
    Matcher matcher = LFS_LOCKS_URL.matcher(context.path);
    if (matcher.matches()) {
        String project = matcher.group(1);
        listLocks(project);
    }
    throw new LfsException("no repository at " + context.path);
}
#method_after
@Override
protected void doRun() throws LfsException, IOException {
    Matcher matcher = LFS_LOCKS_URL_PATTERN.matcher(context.path);
    if (matcher.matches()) {
        String project = matcher.group(1);
        listLocks(project);
    }
    throw new LfsException("no repository at " + context.path);
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    Action action = new Action(req, resp);
    Matcher matcher = LFS_LOCKS_URL.matcher(action.path);
    if (!matcher.matches()) {
        action.sendError(SC_INTERNAL_SERVER_ERROR, String.format("Unsupported path %s was provided", action.path));
        return;
    }
    String project = matcher.group(1);
    listLocks(project, action);
}
#method_after
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    Action action = new Action(req, resp);
    Matcher matcher = LFS_LOCKS_URL_PATTERN.matcher(action.path);
    if (matcher.matches()) {
        String project = matcher.group(1);
        listLocks(project, action);
        return;
    }
    action.sendError(SC_INTERNAL_SERVER_ERROR, String.format("Unsupported path %s was provided", action.path));
}
#end_block

#method_before
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    Action action = new Action(req, resp);
    Matcher matcher = LFS_LOCKS_URL.matcher(action.path);
    if (matcher.matches()) {
        String project = matcher.group(1);
        String lockId = matcher.group(2);
        if (Strings.isNullOrEmpty(lockId)) {
            createLock(project, action);
        } else {
            deleteLock(project, lockId, action);
        }
        return;
    }
    matcher = LFS_VERIFICATION_URL.matcher(action.path);
    if (matcher.matches()) {
        verifyLocks(matcher.group(1), action);
    } else {
        action.sendError(SC_INTERNAL_SERVER_ERROR, String.format("Unsupported path %s was provided", action.path));
    }
}
#method_after
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    Action action = new Action(req, resp);
    Matcher matcher = LFS_LOCKS_URL_PATTERN.matcher(action.path);
    if (matcher.matches()) {
        String project = matcher.group(1);
        String lockId = matcher.group(2);
        if (Strings.isNullOrEmpty(lockId)) {
            createLock(project, action);
        } else {
            deleteLock(project, lockId, action);
        }
        return;
    }
    matcher = LFS_VERIFICATION_URL_PATTERN.matcher(action.path);
    if (matcher.matches()) {
        verifyLocks(matcher.group(1), action);
        return;
    }
    action.sendError(SC_INTERNAL_SERVER_ERROR, String.format("Unsupported path %s was provided", action.path));
}
#end_block

#method_before
private void listLocks(String project, Action action) throws IOException {
    LfsListLocksInput input = action.input(LfsListLocksInput.class);
    log.debug("Get list of locks for {} project", project);
    // TODO method stub for getting project's locks list
    action.sendResponse(new LfsGetLocksResponse(Collections.emptyList(), input.cursor));
}
#method_after
private void listLocks(String project, Action action) throws IOException {
    log.debug("Get list of locks for {} project", project);
    // TODO method stub for getting project's locks list
    // stub for searching lock by path
    String path = action.getParam("path");
    if (!Strings.isNullOrEmpty(path)) {
        action.sendResponse(new LfsGetLocksResponse(ImmutableList.<LfsLock>builder().add(new LfsLock("random_id", path, now(), new LfsLockOwner("Lock Owner <lock_owner@example.com>"))).build(), null));
        return;
    }
    // stub for searching lock by id
    String id = action.getParam("id");
    if (!Strings.isNullOrEmpty(id)) {
        action.sendResponse(new LfsGetLocksResponse(ImmutableList.<LfsLock>builder().add(new LfsLock(id, "path/to/file", now(), new LfsLockOwner("Lock Owner <lock_owner@example.com>"))).build(), null));
        return;
    }
    // stub for returning all locks
    action.sendResponse(new LfsGetLocksResponse(Collections.emptyList(), null));
}
#end_block

#method_before
@Override
protected void configureServlets() {
    serveRegex(LFS_OBJECTS_REST).with(LfsApiServlet.class);
    serveRegex(LFS_LOCKS_REST).with(LfsLocksServlet.class);
    populateRepository(defaultBackend);
    for (LfsBackend backend : backends.values()) {
        populateRepository(backend);
    }
    DynamicSet.bind(binder(), WebUiPlugin.class).toInstance(new JavaScriptPlugin("lfs-project-info.js"));
}
#method_after
@Override
protected void configureServlets() {
    serveRegex(LFS_OBJECTS_REGEX_REST).with(LfsApiServlet.class);
    serveRegex(LFS_LOCKS_REGEX_REST).with(LfsLocksServlet.class);
    populateRepository(defaultBackend);
    for (LfsBackend backend : backends.values()) {
        populateRepository(backend);
    }
    DynamicSet.bind(binder(), WebUiPlugin.class).toInstance(new JavaScriptPlugin("lfs-project-info.js"));
}
#end_block

#method_before
private Injector createDbInjector() {
    final List<Module> modules = new ArrayList<>();
    AbstractModule secureStore = createSecureStoreModule();
    modules.add(secureStore);
    if (sitePath != null) {
        Module sitePathModule = new AbstractModule() {

            @Override
            protected void configure() {
                bind(Path.class).annotatedWith(SitePath.class).toInstance(sitePath);
            }
        };
        modules.add(sitePathModule);
        Module configModule = new GerritServerConfigModule();
        modules.add(configModule);
        Injector cfgInjector = Guice.createInjector(sitePathModule, configModule, secureStore);
        Config cfg = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        String dbType = cfg.getString("database", null, "type");
        final DataSourceType dst = Guice.createInjector(new DataSourceModule(), configModule, sitePathModule, secureStore).getInstance(Key.get(DataSourceType.class, Names.named(dbType.toLowerCase())));
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(DataSourceType.class).toInstance(dst);
                bind(DataSourceProvider.Context.class).toInstance(DataSourceProvider.Context.MULTI_USER);
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(DataSourceProvider.class).in(SINGLETON);
                listener().to(DataSourceProvider.class);
            }
        });
    } else {
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(ReviewDbDataSourceProvider.class).in(SINGLETON);
                listener().to(ReviewDbDataSourceProvider.class);
            }
        });
    }
    modules.add(new DatabaseModule());
    modules.add(new ConfigNotesMigration.Module());
    modules.add(new DropWizardMetricMaker.ApiModule());
    return Guice.createInjector(PRODUCTION, modules);
}
#method_after
private Injector createDbInjector() {
    final List<Module> modules = new ArrayList<>();
    AbstractModule secureStore = createSecureStoreModule();
    modules.add(secureStore);
    if (sitePath != null) {
        Module sitePathModule = new AbstractModule() {

            @Override
            protected void configure() {
                bind(Path.class).annotatedWith(SitePath.class).toInstance(sitePath);
            }
        };
        modules.add(sitePathModule);
        Module configModule = new GerritServerConfigModule();
        modules.add(configModule);
        Injector cfgInjector = Guice.createInjector(sitePathModule, configModule, secureStore);
        Config cfg = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        String dbType = cfg.getString("database", null, "type");
        final DataSourceType dst = Guice.createInjector(new DataSourceModule(), configModule, sitePathModule, secureStore).getInstance(Key.get(DataSourceType.class, Names.named(dbType.toLowerCase())));
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(DataSourceType.class).toInstance(dst);
                bind(DataSourceProvider.Context.class).toInstance(DataSourceProvider.Context.MULTI_USER);
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(DataSourceProvider.class).in(SINGLETON);
                listener().to(DataSourceProvider.class);
            }
        });
    } else {
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(ReviewDbDataSourceProvider.class).in(SINGLETON);
                listener().to(ReviewDbDataSourceProvider.class);
            }
        });
        // If we didn't get the site path from the system property
        // we need to get it from the database, as that's our old
        // method of locating the site path on disk.
        // 
        modules.add(new AbstractModule() {

            @Override
            protected void configure() {
                bind(Path.class).annotatedWith(SitePath.class).toProvider(SitePathFromSystemConfigProvider.class).in(SINGLETON);
            }
        });
        modules.add(new GerritServerConfigModule());
    }
    modules.add(new DatabaseModule());
    modules.add(new ConfigNotesMigration.Module());
    modules.add(new DropWizardMetricMaker.ApiModule());
    return Guice.createInjector(PRODUCTION, modules);
}
#end_block

#method_before
private Injector createCfgInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sitePath == null) {
        // If we didn't get the site path from the system property
        // we need to get it from the database, as that's our old
        // method of locating the site path on disk.
        // 
        modules.add(new AbstractModule() {

            @Override
            protected void configure() {
                bind(Path.class).annotatedWith(SitePath.class).toProvider(SitePathFromSystemConfigProvider.class).in(SINGLETON);
            }
        });
        modules.add(new GerritServerConfigModule());
    }
    modules.add(new SchemaModule());
    modules.add(SchemaVersionCheck.module());
    modules.add(new AuthConfigModule());
    return dbInjector.createChildInjector(modules);
}
#method_after
private Injector createCfgInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new SchemaModule());
    modules.add(SchemaVersionCheck.module());
    modules.add(new AuthConfigModule());
    return dbInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(sysInjector.getInstance(SshModule.class));
    modules.add(new SshHostKeyModule());
    modules.add(new DefaultCommandModule(false, sysInjector.getInstance(DownloadConfig.class)));
    if (indexType == IndexType.LUCENE) {
        modules.add(new IndexCommandsModule());
    }
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(sysInjector.getInstance(SshModule.class));
    modules.add(new SshHostKeyModule());
    modules.add(new DefaultCommandModule(false, sysInjector.getInstance(DownloadConfig.class), sysInjector.getInstance(LfsPluginAuthCommand.Module.class)));
    if (indexType == IndexType.LUCENE) {
        modules.add(new IndexCommandsModule());
    }
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
static Map<String, Config> parse(GerritPluginConfigs annotation) {
    if (annotation == null || annotation.value().length < 1) {
        return null;
    }
    HashMap<String, Config> result = new HashMap<>();
    for (GerritPluginConfig c : annotation.value()) {
        String pluginName = c.pluginName();
        Config config;
        if (result.containsKey(pluginName)) {
            config = result.get(pluginName);
        } else {
            config = new Config();
            result.put(pluginName, config);
        }
        parseAnnotation(config, new GerritPluginConfigToGerritConfig(c));
    }
    return result;
}
#method_after
static Map<String, Config> parse(GlobalPluginConfig annotation) {
    if (annotation == null) {
        return null;
    }
    Map<String, Config> result = new HashMap<>();
    Config cfg = new Config();
    parseAnnotation(cfg, new GlobalPluginConfigToGerritConfig(annotation));
    result.put(annotation.pluginName(), cfg);
    return result;
}
#end_block

#method_before
static Description forTestClass(org.junit.runner.Description testDesc, String configName) {
    return new AutoValue_GerritServer_Description(testDesc, configName, // @UseLocalDisk is only valid on methods.
    true, !has(NoHttpd.class, testDesc.getTestClass()), has(Sandboxed.class, testDesc.getTestClass()), has(UseSsh.class, testDesc.getTestClass()), // @GerritConfig is only valid on methods.
    null, // @GerritConfigs is only valid on methods.
    null, // @GerritPluginConfig is only valid on methods.
    null, // @GerritPluginConfigs is only valid on methods.
    null);
}
#method_after
static Description forTestClass(org.junit.runner.Description testDesc, String configName) {
    return new AutoValue_GerritServer_Description(testDesc, configName, // @UseLocalDisk is only valid on methods.
    true, !has(NoHttpd.class, testDesc.getTestClass()), has(Sandboxed.class, testDesc.getTestClass()), has(UseSsh.class, testDesc.getTestClass()), // @GerritConfig is only valid on methods.
    null, // @GerritConfigs is only valid on methods.
    null, // @GlobalPluginConfig is only valid on methods.
    null, // @GlobalPluginConfigs is only valid on methods.
    null);
}
#end_block

#method_before
static Description forTestMethod(org.junit.runner.Description testDesc, String configName) {
    return new AutoValue_GerritServer_Description(testDesc, configName, testDesc.getAnnotation(UseLocalDisk.class) == null, testDesc.getAnnotation(NoHttpd.class) == null && !has(NoHttpd.class, testDesc.getTestClass()), testDesc.getAnnotation(Sandboxed.class) != null || has(Sandboxed.class, testDesc.getTestClass()), testDesc.getAnnotation(UseSsh.class) != null || has(UseSsh.class, testDesc.getTestClass()), testDesc.getAnnotation(GerritConfig.class), testDesc.getAnnotation(GerritConfigs.class), testDesc.getAnnotation(GerritPluginConfig.class), testDesc.getAnnotation(GerritPluginConfigs.class));
}
#method_after
static Description forTestMethod(org.junit.runner.Description testDesc, String configName) {
    return new AutoValue_GerritServer_Description(testDesc, configName, testDesc.getAnnotation(UseLocalDisk.class) == null, testDesc.getAnnotation(NoHttpd.class) == null && !has(NoHttpd.class, testDesc.getTestClass()), testDesc.getAnnotation(Sandboxed.class) != null || has(Sandboxed.class, testDesc.getTestClass()), testDesc.getAnnotation(UseSsh.class) != null || has(UseSsh.class, testDesc.getTestClass()), testDesc.getAnnotation(GerritConfig.class), testDesc.getAnnotation(GerritConfigs.class), testDesc.getAnnotation(GlobalPluginConfig.class), testDesc.getAnnotation(GlobalPluginConfigs.class));
}
#end_block

#method_before
private Config buildConfig(Config baseConfig) {
    if (configs() != null && config() != null) {
        throw new IllegalStateException("Use either @GerritConfigs or @GerritConfig not both");
    }
    if (configs() != null) {
        return ConfigAnnotationParser.parse(baseConfig, configs());
    } else if (config() != null) {
        return ConfigAnnotationParser.parse(baseConfig, config());
    } else {
        return baseConfig;
    }
}
#method_after
private Config buildConfig(Config baseConfig) {
    if (configs() != null) {
        return ConfigAnnotationParser.parse(baseConfig, configs());
    } else if (config() != null) {
        return ConfigAnnotationParser.parse(baseConfig, config());
    } else {
        return baseConfig;
    }
}
#end_block

#method_before
private Map<String, Config> buildPluginConfigs() {
    if (pluginConfigs() != null && pluginConfig() != null) {
        throw new IllegalStateException("Use either @GerritPluginConfig or @GerritPluginConfigs not both");
    }
    if ((pluginConfigs() != null || pluginConfig() != null) && memory()) {
        throw new IllegalStateException("Must use @UseLocalDisk with @GerritPluginConfig(s)");
    }
    if (pluginConfigs() != null) {
        return ConfigAnnotationParser.parse(pluginConfigs());
    } else if (pluginConfig() != null) {
        return ConfigAnnotationParser.parse(pluginConfig());
    }
    return new HashMap<>();
}
#method_after
private Map<String, Config> buildPluginConfigs() {
    if (pluginConfigs() != null) {
        return ConfigAnnotationParser.parse(pluginConfigs());
    } else if (pluginConfig() != null) {
        return ConfigAnnotationParser.parse(pluginConfig());
    }
    return new HashMap<>();
}
#end_block

#method_before
static GerritServer start(Description desc, Config baseConfig) throws Exception {
    Config cfg = desc.buildConfig(baseConfig);
    Logger.getLogger("com.google.gerrit").setLevel(Level.DEBUG);
    final CyclicBarrier serverStarted = new CyclicBarrier(2);
    final Daemon daemon = new Daemon(new Runnable() {

        @Override
        public void run() {
            try {
                serverStarted.await();
            } catch (InterruptedException | BrokenBarrierException e) {
                throw new RuntimeException(e);
            }
        }
    }, Paths.get(baseConfig.getString("gerrit", null, "tempSiteDir")));
    daemon.setEmailModuleForTesting(new FakeEmailSender.Module());
    daemon.setEnableSshd(SshMode.useSsh());
    final File site;
    ExecutorService daemonService = null;
    if (desc.memory()) {
        site = null;
        mergeTestConfig(cfg);
        // Set the log4j configuration to an invalid one to prevent system logs
        // from getting configured and creating log files.
        System.setProperty(SystemLog.LOG4J_CONFIGURATION, "invalidConfiguration");
        cfg.setBoolean("httpd", null, "requestLog", false);
        cfg.setBoolean("sshd", null, "requestLog", false);
        cfg.setBoolean("index", "lucene", "testInmemory", true);
        cfg.setString("gitweb", null, "cgi", "");
        daemon.setEnableHttpd(desc.httpd());
        daemon.setLuceneModule(LuceneIndexModule.singleVersionAllLatest(0));
        daemon.setDatabaseForTesting(ImmutableList.<Module>of(new InMemoryTestingDatabaseModule(cfg)));
        daemon.start();
    } else {
        site = initSite(cfg, desc.buildPluginConfigs());
        daemonService = Executors.newSingleThreadExecutor();
        @SuppressWarnings("unused")
        Future<?> possiblyIgnoredError = daemonService.submit(new Callable<Void>() {

            @Override
            public Void call() throws Exception {
                int rc = daemon.main(new String[] { "-d", site.getPath(), "--headless", "--console-log", "--show-stack-trace" });
                if (rc != 0) {
                    System.err.println("Failed to start Gerrit daemon");
                    serverStarted.reset();
                }
                return null;
            }
        });
        serverStarted.await();
        System.out.println("Gerrit Server Started");
    }
    Injector i = createTestInjector(daemon);
    return new GerritServer(desc, i, daemon, daemonService);
}
#method_after
static GerritServer start(Description desc, Config baseConfig) throws Exception {
    desc.checkValidAnnotations();
    Config cfg = desc.buildConfig(baseConfig);
    Logger.getLogger("com.google.gerrit").setLevel(Level.DEBUG);
    final CyclicBarrier serverStarted = new CyclicBarrier(2);
    final Daemon daemon = new Daemon(new Runnable() {

        @Override
        public void run() {
            try {
                serverStarted.await();
            } catch (InterruptedException | BrokenBarrierException e) {
                throw new RuntimeException(e);
            }
        }
    }, Paths.get(baseConfig.getString("gerrit", null, "tempSiteDir")));
    daemon.setEmailModuleForTesting(new FakeEmailSender.Module());
    daemon.setEnableSshd(SshMode.useSsh());
    final File site;
    ExecutorService daemonService = null;
    if (desc.memory()) {
        site = null;
        mergeTestConfig(cfg);
        // Set the log4j configuration to an invalid one to prevent system logs
        // from getting configured and creating log files.
        System.setProperty(SystemLog.LOG4J_CONFIGURATION, "invalidConfiguration");
        cfg.setBoolean("httpd", null, "requestLog", false);
        cfg.setBoolean("sshd", null, "requestLog", false);
        cfg.setBoolean("index", "lucene", "testInmemory", true);
        cfg.setString("gitweb", null, "cgi", "");
        daemon.setEnableHttpd(desc.httpd());
        daemon.setLuceneModule(LuceneIndexModule.singleVersionAllLatest(0));
        daemon.setDatabaseForTesting(ImmutableList.<Module>of(new InMemoryTestingDatabaseModule(cfg)));
        daemon.start();
    } else {
        site = initSite(cfg, desc.buildPluginConfigs());
        daemonService = Executors.newSingleThreadExecutor();
        @SuppressWarnings("unused")
        Future<?> possiblyIgnoredError = daemonService.submit(new Callable<Void>() {

            @Override
            public Void call() throws Exception {
                int rc = daemon.main(new String[] { "-d", site.getPath(), "--headless", "--console-log", "--show-stack-trace" });
                if (rc != 0) {
                    System.err.println("Failed to start Gerrit daemon");
                    serverStarted.reset();
                }
                return null;
            }
        });
        serverStarted.await();
        System.out.println("Gerrit Server Started");
    }
    Injector i = createTestInjector(daemon);
    return new GerritServer(desc, i, daemon, daemonService);
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    ResultSet<AccountGroup> accountGroups = db.accountGroups().all();
    for (AccountGroup accountGroup : accountGroups) {
        ResultSet<AccountGroupMemberAudit> groupMemberAudits = db.accountGroupMembersAudit().byGroup(accountGroup.getId());
        Optional<Timestamp> firstTimeMentioned = Streams.stream(groupMemberAudits).map(AccountGroupMemberAudit::getKey).map(Key::getAddedOn).min(Comparator.naturalOrder());
        Timestamp auditAddedOn = Timestamp.from(LocalDateTime.of(2009, Month.JUNE, 8, 19, 31).toInstant(ZoneOffset.UTC));
        Timestamp createdOn = firstTimeMentioned.orElse(auditAddedOn);
        accountGroup.setCreatedOn(createdOn);
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    List<AccountGroup> accountGroups = db.accountGroups().all().toList();
    for (AccountGroup accountGroup : accountGroups) {
        ResultSet<AccountGroupMemberAudit> groupMemberAudits = db.accountGroupMembersAudit().byGroup(accountGroup.getId());
        Optional<Timestamp> firstTimeMentioned = Streams.stream(groupMemberAudits).map(AccountGroupMemberAudit::getKey).map(Key::getAddedOn).min(Comparator.naturalOrder());
        Timestamp createdOn = firstTimeMentioned.orElseGet(() -> Timestamp.from(AUDIT_CREATION_INSTANT));
        accountGroup.setCreatedOn(createdOn);
    }
    db.accountGroups().update(accountGroups);
}
#end_block

#method_before
private static List<Runner> runnersFor(Class<?> clazz) {
    Method defaultConfig = getDefaultConfig(clazz);
    List<Method> configs = getConfigs(clazz);
    Method configMap = getConfigMap(clazz);
    Field parameterField = getOnlyField(clazz, Parameter.class);
    checkArgument(parameterField != null, "No @ConfigSuite.Field found");
    Field nameField = getOnlyField(clazz, Name.class);
    List<Runner> result = Lists.newArrayListWithCapacity(configs.size() + 1);
    try {
        result.add(new ConfigRunner(clazz, parameterField, nameField, null, callConfigMethod(defaultConfig)));
        for (Method m : configs) {
            result.add(new ConfigRunner(clazz, parameterField, nameField, m.getName(), callConfigMethod(m)));
        }
        for (Map.Entry<String, org.eclipse.jgit.lib.Config> e : callConfigMapMethod(configMap).entrySet()) {
            result.add(new ConfigRunner(clazz, parameterField, nameField, e.getKey(), e.getValue()));
        }
        return result;
    } catch (InitializationError e) {
        System.err.println("Errors initializing runners:");
        for (Throwable t : e.getCauses()) {
            t.printStackTrace();
        }
        throw new RuntimeException(e);
    }
}
#method_after
private static List<Runner> runnersFor(Class<?> clazz) {
    Method defaultConfig = getDefaultConfig(clazz);
    List<Method> configs = getConfigs(clazz);
    Map<String, org.eclipse.jgit.lib.Config> configMap = callConfigMapMethod(getConfigMap(clazz), configs);
    Field parameterField = getOnlyField(clazz, Parameter.class);
    checkArgument(parameterField != null, "No @ConfigSuite.Field found");
    Field nameField = getOnlyField(clazz, Name.class);
    List<Runner> result = Lists.newArrayListWithCapacity(configs.size() + 1);
    try {
        result.add(new ConfigRunner(clazz, parameterField, nameField, null, callConfigMethod(defaultConfig)));
        for (Method m : configs) {
            result.add(new ConfigRunner(clazz, parameterField, nameField, m.getName(), callConfigMethod(m)));
        }
        for (Map.Entry<String, org.eclipse.jgit.lib.Config> e : configMap.entrySet()) {
            result.add(new ConfigRunner(clazz, parameterField, nameField, e.getKey(), e.getValue()));
        }
        return result;
    } catch (InitializationError e) {
        System.err.println("Errors initializing runners:");
        for (Throwable t : e.getCauses()) {
            t.printStackTrace();
        }
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
private static Map<String, org.eclipse.jgit.lib.Config> callConfigMapMethod(Method m) {
    if (m == null) {
        return ImmutableMap.of();
    }
    checkArgument(Map.class.isAssignableFrom(m.getReturnType()), "%s must return Map", m);
    Type[] types = ((ParameterizedType) m.getGenericReturnType()).getActualTypeArguments();
    checkArgument(String.class.getTypeName().equals(types[0].getTypeName()), "The map returned by %s must have String as key", m);
    checkArgument(org.eclipse.jgit.lib.Config.class.getTypeName().equals(types[1].getTypeName()), "The map returned by %s must have Config as value", m);
    checkArgument((m.getModifiers() & Modifier.STATIC) != 0, "%s must be static", m);
    checkArgument(m.getParameterTypes().length == 0, "%s must take no parameters", m);
    try {
        @SuppressWarnings("unchecked")
        Map<String, org.eclipse.jgit.lib.Config> configMap = (Map<String, org.eclipse.jgit.lib.Config>) m.invoke(null);
        return configMap;
    } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
        throw new IllegalArgumentException(e);
    }
}
#method_after
private static Map<String, org.eclipse.jgit.lib.Config> callConfigMapMethod(Method m, List<Method> configs) {
    if (m == null) {
        return ImmutableMap.of();
    }
    checkArgument(Map.class.isAssignableFrom(m.getReturnType()), "%s must return Map", m);
    Type[] types = ((ParameterizedType) m.getGenericReturnType()).getActualTypeArguments();
    checkArgument(String.class.isAssignableFrom((Class<?>) types[0]), "The map returned by %s must have String as key", m);
    checkArgument(org.eclipse.jgit.lib.Config.class.isAssignableFrom((Class<?>) types[1]), "The map returned by %s must have Config as value", m);
    checkArgument((m.getModifiers() & Modifier.STATIC) != 0, "%s must be static", m);
    checkArgument(m.getParameterTypes().length == 0, "%s must take no parameters", m);
    try {
        @SuppressWarnings("unchecked")
        Map<String, org.eclipse.jgit.lib.Config> configMap = (Map<String, org.eclipse.jgit.lib.Config>) m.invoke(null);
        checkArgument(!configMap.containsKey(DEFAULT), "The map returned by %s cannot contain key %s (duplicate test suite name)", m, DEFAULT);
        for (String name : configs.stream().map(cm -> cm.getName()).collect(toSet())) {
            checkArgument(!configMap.containsKey(name), "The map returned by %s cannot contain key %s (duplicate test suite name)", m, name);
        }
        return configMap;
    } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
        throw new IllegalArgumentException(e);
    }
}
#end_block

#method_before
@ConfigSuite.Config
public static Config againstPreviousIndexVersion() {
    Config cfg = defaultConfig();
    SortedMap<Integer, Schema<AccountState>> schemas = SchemaUtil.schemasFromClass(AccountSchemaDefinitions.class, AccountState.class);
    if (schemas.size() > 1) {
        int prevVersion = new ArrayList<>(schemas.keySet()).get(schemas.size() - 2);
        cfg.setInt("index", "lucene", AccountSchemaDefinitions.INSTANCE.getName() + "TestVersion", prevVersion);
    }
    return cfg;
}
#method_after
@ConfigSuite.Config
public static Config againstPreviousIndexVersion() {
    Config cfg = defaultConfig();
    Schema<AccountState> prevSchema = AccountSchemaDefinitions.INSTANCE.getPrevious();
    if (prevSchema != null) {
        cfg.setInt("index", "lucene", AccountSchemaDefinitions.INSTANCE.getName() + "TestVersion", prevSchema.getVersion());
    }
    return cfg;
}
#end_block

#method_before
@ConfigSuite.Config
public static Config againstPreviousIndexVersion() {
    Config cfg = defaultConfig();
    SortedMap<Integer, Schema<ChangeData>> schemas = SchemaUtil.schemasFromClass(ChangeSchemaDefinitions.class, ChangeData.class);
    if (schemas.size() > 1) {
        int prevVersion = new ArrayList<>(schemas.keySet()).get(schemas.size() - 2);
        cfg.setInt("index", "lucene", ChangeSchemaDefinitions.INSTANCE.getName() + "TestVersion", prevVersion);
    }
    return cfg;
}
#method_after
@ConfigSuite.Config
public static Config againstPreviousIndexVersion() {
    Config cfg = defaultConfig();
    Schema<ChangeData> prevSchema = ChangeSchemaDefinitions.INSTANCE.getPrevious();
    if (prevSchema != null) {
        cfg.setInt("index", "lucene", ChangeSchemaDefinitions.INSTANCE.getName() + "TestVersion", prevSchema.getVersion());
    }
    return cfg;
}
#end_block

#method_before
@Before
public void setUpInjector() throws Exception {
    lifecycle = new LifecycleManager();
    Injector injector = createInjector();
    lifecycle.add(injector);
    injector.injectMembers(this);
    lifecycle.start();
    db = schemaFactory.open();
    schemaCreator.create(db);
    Account.Id userId = createAccount("user", "User", "user@example.com", true);
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userId));
    currentUserInfo = gApi.accounts().id(userId.get()).get();
}
#method_after
@Before
public void setUpInjector() throws Exception {
    lifecycle = new LifecycleManager();
    injector = createInjector();
    lifecycle.add(injector);
    injector.injectMembers(this);
    lifecycle.start();
    setUpDatabase();
}
#end_block

#method_before
@Test
public void byInname() throws Exception {
    String namePart = testName.getMethodName();
    namePart = namePart.replaceAll("[\\[\\]]", "");
    GroupInfo group1 = createGroup("group-" + namePart);
    GroupInfo group2 = createGroup("group-" + namePart + "-2");
    GroupInfo group3 = createGroup("group-" + namePart + "3");
    assertQuery("inname:" + namePart, group1, group2, group3);
    assertQuery("inname:" + namePart.toUpperCase(Locale.US), group1, group2, group3);
    assertQuery("inname:" + namePart.toLowerCase(Locale.US), group1, group2, group3);
}
#method_after
@Test
public void byInname() throws Exception {
    String namePart = getSanitizedMethodName();
    namePart = CharMatcher.is('_').removeFrom(namePart);
    GroupInfo group1 = createGroup("group-" + namePart);
    GroupInfo group2 = createGroup("group-" + namePart + "-2");
    GroupInfo group3 = createGroup("group-" + namePart + "3");
    assertQuery("inname:" + namePart, group1, group2, group3);
    assertQuery("inname:" + namePart.toUpperCase(Locale.US), group1, group2, group3);
    assertQuery("inname:" + namePart.toLowerCase(Locale.US), group1, group2, group3);
}
#end_block

#method_before
protected String name(String name) {
    if (name == null) {
        return null;
    }
    String suffix = testName.getMethodName().toLowerCase();
    suffix = suffix.replaceAll("[\\[\\]]", "_");
    if (suffix.endsWith("_")) {
        suffix = suffix.substring(0, suffix.length() - 1);
    }
    return name + "_" + suffix;
}
#method_after
protected String name(String name) {
    if (name == null) {
        return null;
    }
    return name + "_" + getSanitizedMethodName();
}
#end_block

#method_before
@ConfigSuite.Config
public static Config againstPreviousIndexVersion() {
    Config cfg = defaultConfig();
    SortedMap<Integer, Schema<AccountGroup>> schemas = SchemaUtil.schemasFromClass(GroupSchemaDefinitions.class, AccountGroup.class);
    if (schemas.size() > 1) {
        int prevVersion = new ArrayList<>(schemas.keySet()).get(schemas.size() - 2);
        cfg.setInt("index", "lucene", GroupSchemaDefinitions.INSTANCE.getName() + "TestVersion", prevVersion);
    }
    return cfg;
}
#method_after
@ConfigSuite.Config
public static Config againstPreviousIndexVersion() {
    Config cfg = defaultConfig();
    Schema<AccountGroup> prevSchema = GroupSchemaDefinitions.INSTANCE.getPrevious();
    if (prevSchema != null) {
        cfg.setInt("index", "lucene", GroupSchemaDefinitions.INSTANCE.getName() + "TestVersion", prevSchema.getVersion());
    }
    return cfg;
}
#end_block

#method_before
@Before
public void setUpInjector() throws Exception {
    lifecycle = new LifecycleManager();
    Injector injector = createInjector();
    lifecycle.add(injector);
    injector.injectMembers(this);
    lifecycle.start();
    db = schemaFactory.open();
    schemaCreator.create(db);
    Account.Id userId = createAccount("user", "User", "user@example.com", true);
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userId));
    currentUserInfo = gApi.accounts().id(userId.get()).get();
}
#method_after
@Before
public void setUpInjector() throws Exception {
    lifecycle = new LifecycleManager();
    injector = createInjector();
    lifecycle.add(injector);
    injector.injectMembers(this);
    lifecycle.start();
    setUpDatabase();
}
#end_block

#method_before
@Test
public void byName() throws Exception {
    AccountInfo user1 = newAccountWithFullName("jdoe", "John Doe");
    AccountInfo user2 = newAccountWithFullName("jroe", "Jane Roe");
    AccountInfo user3 = newAccountWithFullName("user3", "Mr Selfish");
    assertQuery("notexisting");
    assertQuery("Not Existing");
    assertQuery(quote(user1.name), user1);
    assertQuery("name:" + quote(user1.name), user1);
    assertQuery("John", user1);
    assertQuery("john", user1);
    assertQuery("Doe", user1);
    assertQuery("doe", user1);
    assertQuery("DOE", user1);
    assertQuery("Jo Do", user1);
    assertQuery("jo do", user1);
    assertQuery("self", currentUserInfo, user3);
    assertQuery("name:John", user1);
    assertQuery("name:john", user1);
    assertQuery("name:Doe", user1);
    assertQuery("name:doe", user1);
    assertQuery("name:DOE", user1);
    assertQuery("name:self", user3);
    assertQuery(quote(user2.name), user2);
    assertQuery("name:" + quote(user2.name), user2);
}
#method_after
@Test
public void byName() throws Exception {
    AccountInfo user1 = newAccountWithFullName("jdoe", "John Doe");
    AccountInfo user2 = newAccountWithFullName("jroe", "Jane Roe");
    AccountInfo user3 = newAccountWithFullName("user3", "Mr Selfish");
    assertQuery("notexisting");
    assertQuery("Not Existing");
    assertQuery(quote(user1.name), user1);
    assertQuery("name:" + quote(user1.name), user1);
    assertQuery("John", user1);
    assertQuery("john", user1);
    assertQuery("Doe", user1);
    assertQuery("doe", user1);
    assertQuery("DOE", user1);
    assertQuery("Jo Do", user1);
    assertQuery("jo do", user1);
    assertQuery("self", currentUserInfo, user3);
    assertQuery("me", currentUserInfo);
    assertQuery("name:John", user1);
    assertQuery("name:john", user1);
    assertQuery("name:Doe", user1);
    assertQuery("name:doe", user1);
    assertQuery("name:DOE", user1);
    assertQuery("name:self", user3);
    assertQuery(quote(user2.name), user2);
    assertQuery("name:" + quote(user2.name), user2);
}
#end_block

#method_before
protected String name(String name) {
    if (name == null) {
        return null;
    }
    String suffix = testName.getMethodName().toLowerCase();
    suffix = suffix.replaceAll("[\\[\\]]", "_");
    if (suffix.endsWith("_")) {
        suffix = suffix.substring(0, suffix.length() - 1);
    }
    if (name.contains("@")) {
        return name + "." + suffix;
    }
    return name + "_" + suffix;
}
#method_after
protected String name(String name) {
    if (name == null) {
        return null;
    }
    String suffix = getSanitizedMethodName();
    if (name.contains("@")) {
        return name + "." + suffix;
    }
    return name + "_" + suffix;
}
#end_block

#method_before
protected void setUpDatabase() throws Exception {
    try (ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) {
        schemaCreator.create(underlyingDb);
    }
    db = schemaFactory.open();
    userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    Account userAccount = db.accounts().get(userId);
    userAccount.setPreferredEmail("user@example.com");
    db.accounts().update(ImmutableList.of(userAccount));
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userAccount.getId()));
}
#method_after
protected void setUpDatabase() throws Exception {
    try (ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) {
        schemaCreator.create(underlyingDb);
    }
    db = schemaFactory.open();
    userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    Account userAccount = db.accounts().get(userId);
    String email = "user@example.com";
    externalIdsUpdate.create().insert(ExternalId.createEmail(userId, email));
    userAccount.setPreferredEmail(email);
    db.accounts().update(ImmutableList.of(userAccount));
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userAccount.getId()));
}
#end_block

#method_before
@Test
public void byPrivate() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    Account.Id user2 = accountManager.authenticate(AuthRequest.forUser("anotheruser")).getAccountId();
    Change change2 = insert(repo, newChange(repo), user2);
    // No private changes.
    assertQuery("is:open", change2, change1);
    assertQuery("is:private");
    gApi.changes().id(change1.getChangeId()).setPrivate(true);
    // Change1 is not private, but should be still visible to its owner.
    assertQuery("is:open", change1, change2);
    assertQuery("is:private", change1);
    // Switch request context to user2.
    requestContext.setContext(newRequestContext(user2));
    assertQuery("is:open", change2);
    assertQuery("is:private");
}
#method_after
@Test
public void byPrivate() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    Account.Id user2 = accountManager.authenticate(AuthRequest.forUser("anotheruser")).getAccountId();
    Change change2 = insert(repo, newChange(repo), user2);
    // No private changes.
    assertQuery("is:open", change2, change1);
    assertQuery("is:private");
    gApi.changes().id(change1.getChangeId()).setPrivate(true, null);
    // Change1 is not private, but should be still visible to its owner.
    assertQuery("is:open", change1, change2);
    assertQuery("is:private", change1);
    // Switch request context to user2.
    requestContext.setContext(newRequestContext(user2));
    assertQuery("is:open", change2);
    assertQuery("is:private");
}
#end_block

#method_before
@Test
public void byWip() throws Exception {
    if (getSchemaVersion() < ChangeSchemaDefinitions.V42.getVersion()) {
        assertThat(getSchema().hasField(ChangeField.WIP)).isFalse();
        return;
    }
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    assertQuery("is:open", change1);
    assertQuery("is:wip");
    gApi.changes().id(change1.getChangeId()).setWorkInProgress();
    assertQuery("is:wip", change1);
    gApi.changes().id(change1.getChangeId()).setReadyForReview();
    assertQuery("is:wip");
}
#method_after
@Test
public void byWip() throws Exception {
    if (getSchemaVersion() < 42) {
        assertMissingField(ChangeField.WIP);
        assertFailingQuery("is:wip", "'is:wip' operator is not supported by change index version");
        return;
    }
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    assertQuery("is:open", change1);
    assertQuery("is:wip");
    gApi.changes().id(change1.getChangeId()).setWorkInProgress();
    assertQuery("is:wip", change1);
    gApi.changes().id(change1.getChangeId()).setReadyForReview();
    assertQuery("is:wip");
}
#end_block

#method_before
@Test
public void excludeWipChangeFromReviewersDashboards() throws Exception {
    if (getSchemaVersion() < ChangeSchemaDefinitions.V42.getVersion()) {
        assertThat(getSchema().hasField(ChangeField.WIP)).isFalse();
        return;
    }
    Account.Id user1 = createAccount("user1");
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    AddReviewerInput rin = new AddReviewerInput();
    rin.reviewer = user1.toString();
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change1.getId().get()).addReviewer(rin);
    assertQuery("is:wip");
    assertQuery("reviewer:" + user1, change1);
    gApi.changes().id(change1.getChangeId()).setWorkInProgress();
    assertQuery("is:wip", change1);
    assertQuery("reviewer:" + user1);
    gApi.changes().id(change1.getChangeId()).setReadyForReview();
    assertQuery("is:wip");
    assertQuery("reviewer:" + user1, change1);
}
#method_after
@Test
public void excludeWipChangeFromReviewersDashboards() throws Exception {
    Account.Id user1 = createAccount("user1");
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    AddReviewerInput rin = new AddReviewerInput();
    rin.reviewer = user1.toString();
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change1.getId().get()).addReviewer(rin);
    if (getSchemaVersion() >= 42) {
        assertQuery("is:wip");
        assertQuery("reviewer:" + user1, change1);
        gApi.changes().id(change1.getChangeId()).setWorkInProgress();
        assertQuery("is:wip", change1);
        assertQuery("reviewer:" + user1);
        gApi.changes().id(change1.getChangeId()).setReadyForReview();
        assertQuery("is:wip");
        assertQuery("reviewer:" + user1, change1);
    } else {
        assertMissingField(ChangeField.WIP);
        assertFailingQuery("is:wip", "'is:wip' operator is not supported by change index version");
        assertQuery("reviewer:" + user1, change1);
        gApi.changes().id(change1.getChangeId()).setWorkInProgress();
        assertQuery("reviewer:" + user1, change1);
    }
}
#end_block

#method_before
private Account.Id createAccount(String name) throws Exception {
    return accountManager.authenticate(AuthRequest.forUser(name)).getAccountId();
}
#method_after
private Account.Id createAccount(String username, String fullName, String email, boolean active) throws Exception {
    try (ManualRequestContext ctx = oneOffRequestContext.open()) {
        Account.Id id = accountManager.authenticate(AuthRequest.forUser(username)).getAccountId();
        if (email != null) {
            accountManager.link(id, AuthRequest.forEmail(email));
        }
        Account a = db.accounts().get(id);
        a.setFullName(fullName);
        a.setPreferredEmail(email);
        a.setActive(active);
        db.accounts().update(ImmutableList.of(a));
        accountCache.evict(id);
        return id;
    }
}
#end_block

#method_before
private void setDefaultRenderer(FilterConfig filterConfig) {
    if (renderer == null) {
        renderer = new DefaultRenderer(filterConfig.getServletContext().getContextPath() + STATIC_PREFIX, Arrays.asList(config.getStringList("gitiles", null, "customTemplates")).stream().map(fileUrlMapper()).collect(toList()), firstNonNull(config.getString("gitiles", null, "siteTitle"), "Gitiles"));
    }
}
#method_after
private void setDefaultRenderer(FilterConfig filterConfig) {
    if (renderer == null) {
        renderer = new DefaultRenderer(filterConfig.getServletContext().getContextPath() + STATIC_PREFIX, Arrays.stream(config.getStringList("gitiles", null, "customTemplates")).map(fileUrlMapper()).collect(toList()), firstNonNull(config.getString("gitiles", null, "siteTitle"), "Gitiles"));
    }
}
#end_block

#method_before
private void generateSshHostKeys() throws InterruptedException, IOException {
    if (!exists(site.ssh_key) && (!exists(site.ssh_rsa) || !exists(site.ssh_dsa) || !exists(site.ssh_ed25519) || !exists(site.ssh_ecdsa_256) || !exists(site.ssh_ecdsa_384) || !exists(site.ssh_ecdsa_521))) {
        System.err.print("Generating SSH host key ...");
        System.err.flush();
        // Generate the SSH daemon host key using ssh-keygen.
        // 
        final String comment = "gerrit-code-review@" + hostname();
        // Workaround for JDK-6518827 - zero-length argument ignored on Win32
        String emptyPassphraseArg = HostPlatform.isWin32() ? "\"\"" : "";
        if (!exists(site.ssh_rsa)) {
            System.err.print(" rsa...");
            System.err.flush();
            new ProcessBuilder("ssh-keygen", "-q", /* quiet */
            "-t", "rsa", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_rsa.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
        }
        if (!exists(site.ssh_dsa)) {
            System.err.print(" dsa...");
            System.err.flush();
            new ProcessBuilder("ssh-keygen", "-q", /* quiet */
            "-t", "dsa", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_dsa.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
        }
        if (!exists(site.ssh_ed25519)) {
            System.err.print(" ed25519...");
            System.err.flush();
            try {
                new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                "-t", "ed25519", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_ed25519.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
            } catch (Exception e) {
                // continue since older hosts won't be able to generate ed25519 keys.
                System.err.print(" Failed to generate ed25519 key, continuing...");
                System.err.flush();
            }
        }
        if (!exists(site.ssh_ecdsa_256)) {
            System.err.print(" ecdsa 256...");
            System.err.flush();
            try {
                new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                "-t", "ecdsa", "-b", "256", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_ecdsa_256.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
            } catch (Exception e) {
                // continue since older hosts won't be able to generate ecdsa keys.
                System.err.print(" Failed to generate ecdsa key, continuing...");
                System.err.flush();
            }
        }
        if (!exists(site.ssh_ecdsa_384)) {
            System.err.print(" ecdsa 384...");
            System.err.flush();
            try {
                new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                "-t", "ecdsa", "-b", "384", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_ecdsa_384.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
            } catch (Exception e) {
                // continue since older hosts won't be able to generate ecdsa keys.
                System.err.print(" Failed to generate ecdsa key, continuing...");
                System.err.flush();
            }
        }
        if (!exists(site.ssh_ecdsa_521)) {
            System.err.print(" ecdsa 521...");
            System.err.flush();
            try {
                new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                "-t", "ecdsa", "-b", "521", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_ecdsa_521.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
            } catch (Exception e) {
                // continue since older hosts won't be able to generate ecdsa keys.
                System.err.print(" Failed to generate ecdsa key, continuing...");
                System.err.flush();
            }
        }
        System.err.println(" done");
    }
}
#method_after
private void generateSshHostKeys() throws InterruptedException, IOException {
    if (!exists(site.ssh_key) && (!exists(site.ssh_rsa) || !exists(site.ssh_dsa) || !exists(site.ssh_ed25519) || !exists(site.ssh_ecdsa_256) || !exists(site.ssh_ecdsa_384) || !exists(site.ssh_ecdsa_521))) {
        System.err.print("Generating SSH host key ...");
        System.err.flush();
        // Generate the SSH daemon host key using ssh-keygen.
        // 
        final String comment = "gerrit-code-review@" + hostname();
        // Workaround for JDK-6518827 - zero-length argument ignored on Win32
        String emptyPassphraseArg = HostPlatform.isWin32() ? "\"\"" : "";
        if (!exists(site.ssh_rsa)) {
            System.err.print(" rsa...");
            System.err.flush();
            new ProcessBuilder("ssh-keygen", "-q", /* quiet */
            "-t", "rsa", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_rsa.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
        }
        if (!exists(site.ssh_dsa)) {
            System.err.print(" dsa...");
            System.err.flush();
            new ProcessBuilder("ssh-keygen", "-q", /* quiet */
            "-t", "dsa", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_dsa.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
        }
        if (!exists(site.ssh_ed25519)) {
            System.err.print(" ed25519...");
            System.err.flush();
            try {
                new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                "-t", "ed25519", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_ed25519.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
            } catch (Exception e) {
                // continue since older hosts won't be able to generate ed25519 keys.
                System.err.print(" Failed to generate ed25519 key, continuing...");
                System.err.flush();
            }
        }
        if (!exists(site.ssh_ecdsa_256)) {
            System.err.print(" ecdsa 256...");
            System.err.flush();
            try {
                new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                "-t", "ecdsa", "-b", "256", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_ecdsa_256.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
            } catch (Exception e) {
                // continue since older hosts won't be able to generate ecdsa keys.
                System.err.print(" Failed to generate ecdsa 256 key, continuing...");
                System.err.flush();
            }
        }
        if (!exists(site.ssh_ecdsa_384)) {
            System.err.print(" ecdsa 384...");
            System.err.flush();
            try {
                new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                "-t", "ecdsa", "-b", "384", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_ecdsa_384.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
            } catch (Exception e) {
                // continue since older hosts won't be able to generate ecdsa keys.
                System.err.print(" Failed to generate ecdsa 384 key, continuing...");
                System.err.flush();
            }
        }
        if (!exists(site.ssh_ecdsa_521)) {
            System.err.print(" ecdsa 521...");
            System.err.flush();
            try {
                new ProcessBuilder("ssh-keygen", "-q", /* quiet */
                "-t", "ecdsa", "-b", "521", "-P", emptyPassphraseArg, "-C", comment, "-f", site.ssh_ecdsa_521.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
            } catch (Exception e) {
                // continue since older hosts won't be able to generate ecdsa keys.
                System.err.print(" Failed to generate ecdsa 521 key, continuing...");
                System.err.flush();
            }
        }
        System.err.println(" done");
    }
}
#end_block

#method_before
@Before
public void setUpMocks() {
    id = Change.Id.parse(Integer.toString(CHANGE_ID));
    indexEventHandler = new IndexEventHandler(MoreExecutors.directExecutor(), PLUGIN_NAME, forwarder);
}
#method_after
@Before
public void setUpMocks() {
    changeId = Change.Id.parse(Integer.toString(CHANGE_ID));
    accountId = Account.Id.parse(Integer.toString(ACCOUNT_ID));
    indexEventHandler = new IndexEventHandler(MoreExecutors.directExecutor(), PLUGIN_NAME, forwarder);
}
#end_block

#method_before
@Test
public void shouldIndexInRemoteOnChangeIndexedEvent() throws Exception {
    indexEventHandler.onChangeIndexed(id.get());
    verify(forwarder).indexChange(CHANGE_ID);
}
#method_after
@Test
public void shouldIndexInRemoteOnChangeIndexedEvent() throws Exception {
    indexEventHandler.onChangeIndexed(changeId.get());
    verify(forwarder).indexChange(CHANGE_ID);
}
#end_block

#method_before
@Test
public void shouldDeleteFromIndexInRemoteOnChangeDeletedEvent() throws Exception {
    indexEventHandler.onChangeDeleted(id.get());
    verify(forwarder).deleteChangeFromIndex(CHANGE_ID);
}
#method_after
@Test
public void shouldDeleteFromIndexInRemoteOnChangeDeletedEvent() throws Exception {
    indexEventHandler.onChangeDeleted(changeId.get());
    verify(forwarder).deleteChangeFromIndex(CHANGE_ID);
}
#end_block

#method_before
@Override
public ChangeApi id(String project, int id) throws RestApiException {
    return id(project + "/+/" + id);
}
#method_after
@Override
public ChangeApi id(String project, int id) throws RestApiException {
    return id(Joiner.on('~').join(ImmutableList.of(Url.encode(project), Url.encode(String.valueOf(id)))));
}
#end_block

#method_before
public List<ChangeControl> find(String id, CurrentUser user) throws OrmException {
    if (id.isEmpty()) {
        return Collections.emptyList();
    }
    // Use the index to search for changes, but don't return any stored fields,
    // to force rereading in case the index is stale.
    InternalChangeQuery query = queryProvider.get().noFields();
    // Try project/+/numericChangeId
    if (id.contains(PROJECT_CHANGE_DELIMITER)) {
        int lastDel = id.lastIndexOf(PROJECT_CHANGE_DELIMITER);
        if (lastDel > 0) {
            String project = id.substring(0, lastDel);
            Integer n = Ints.tryParse(id.substring(lastDel + PROJECT_CHANGE_DELIMITER.length()));
            if (n != null) {
                try {
                    return ImmutableList.of(changeControlFactory.controlFor(reviewDb.get(), Project.NameKey.parse(project), new Change.Id(n), user));
                } catch (NoSuchChangeException e) {
                    return Collections.emptyList();
                } catch (IllegalArgumentException e) {
                    // Change or Project unknown. This exception is thrown in checkArgument calls in NoteDb.
                    return Collections.emptyList();
                } catch (OrmException e) {
                    // other OrmExceptions (failure in the persistence layer).
                    if (Throwables.getRootCause(e) instanceof RepositoryNotFoundException) {
                        return Collections.emptyList();
                    }
                    throw e;
                }
            }
        }
    }
    // Try legacy id
    if (id.charAt(0) != '0') {
        Integer n = Ints.tryParse(id);
        if (n != null) {
            return asChangeControls(query.byLegacyChangeId(new Change.Id(n)), user);
        }
    }
    // Try isolated changeId
    if (!id.contains("~")) {
        return asChangeControls(query.byKeyPrefix(id), user);
    }
    // Try change triplet
    Optional<ChangeTriplet> triplet = ChangeTriplet.parse(id);
    if (triplet.isPresent()) {
        return asChangeControls(query.byBranchKey(triplet.get().branch(), triplet.get().id()), user);
    }
    return Collections.emptyList();
}
#method_after
public List<ChangeControl> find(String id, CurrentUser user) throws OrmException {
    if (id.isEmpty()) {
        return Collections.emptyList();
    }
    // Use the index to search for changes, but don't return any stored fields,
    // to force rereading in case the index is stale.
    InternalChangeQuery query = queryProvider.get().noFields();
    int numTwiddles = 0;
    for (char c : id.toCharArray()) {
        if (c == '~') {
            numTwiddles++;
        }
    }
    if (numTwiddles == 1) {
        // Try project~numericChangeId
        String project = id.substring(0, id.indexOf('~'));
        Integer n = Ints.tryParse(id.substring(project.length() + 1));
        if (n != null) {
            Change.Id changeId = new Change.Id(n);
            try {
                return ImmutableList.of(changeControlFactory.controlFor(reviewDb.get(), Project.NameKey.parse(project), changeId, user));
            } catch (NoSuchChangeException e) {
                return Collections.emptyList();
            } catch (IllegalArgumentException e) {
                String changeNotFound = String.format("change %s not found in ReviewDb", changeId);
                String projectNotFound = String.format("passed project %s when creating ChangeNotes for %s, but actual project is", project, changeId);
                if (e.getMessage().equals(changeNotFound) || e.getMessage().startsWith(projectNotFound)) {
                    return Collections.emptyList();
                }
                throw e;
            } catch (OrmException e) {
                // other OrmExceptions (failure in the persistence layer).
                if (Throwables.getRootCause(e) instanceof RepositoryNotFoundException) {
                    return Collections.emptyList();
                }
                throw e;
            }
        }
    } else if (numTwiddles == 2) {
        // Try change triplet
        Optional<ChangeTriplet> triplet = ChangeTriplet.parse(id);
        if (triplet.isPresent()) {
            return asChangeControls(query.byBranchKey(triplet.get().branch(), triplet.get().id()), user);
        }
    }
    // Try numeric changeId
    if (id.charAt(0) != '0') {
        Integer n = Ints.tryParse(id);
        if (n != null) {
            return asChangeControls(query.byLegacyChangeId(new Change.Id(n)), user);
        }
    }
    // Try isolated changeId
    return asChangeControls(query.byKeyPrefix(id), user);
}
#end_block

#method_before
@Test
public void deleteOneCommentMultipleTimes() throws Exception {
    PushOneCommit.Result result = createChange();
    Change.Id id = result.getChange().getId();
    String changeId = result.getChangeId();
    String ps1 = result.getCommit().name();
    CommentInput c1 = newComment(FILE_NAME, "comment 1");
    CommentInput c2 = newComment(FILE_NAME, "comment 2");
    CommentInput c3 = newComment(FILE_NAME, "comment 3");
    addComments(changeId, ps1, c1);
    addComments(changeId, ps1, c2);
    addComments(changeId, ps1, c3);
    List<CommentInfo> commentsBeforeDelete = getChangeSortedComments(changeId);
    assertThat(commentsBeforeDelete).hasSize(3);
    Optional<CommentInfo> targetComment = commentsBeforeDelete.stream().filter(c -> c.message.equals("comment 2")).findFirst();
    assertThat(targetComment.isPresent()).isTrue();
    String uuid = targetComment.get().id;
    setApiUser(admin);
    for (int i = 0; i < 3; i++) {
        List<RevCommit> commitsBeforeDelete = new ArrayList<>();
        if (notesMigration.commitChangeWrites()) {
            commitsBeforeDelete = getCommits(id);
        }
        CommentInfo oldComment = gApi.changes().id(changeId).revision(1).comment(uuid).get();
        DeleteCommentInput input = new DeleteCommentInput("delete comment 2: " + i);
        CommentInfo updatedComment = gApi.changes().id(changeId).revision(1).comment(uuid).delete(input);
        String expectedMsg = String.format("Comment removed by: %s; Reason: %s", admin.fullName, input.reason);
        assertThat(updatedComment.message).isEqualTo(expectedMsg);
        oldComment.message = expectedMsg;
        assertThat(updatedComment).isEqualTo(oldComment);
        if (notesMigration.commitChangeWrites()) {
            assertMetaBranchCommitsAfterRewriting(commitsBeforeDelete, id, uuid, expectedMsg);
        }
        assertThat(getChangeSortedComments(changeId)).hasSize(3);
    }
    CommentInput c4 = newComment(FILE_NAME, "comment 4");
    addComments(changeId, ps1, c4);
    assertThat(getChangeSortedComments(changeId)).hasSize(4);
}
#method_after
@Test
public void deleteOneCommentMultipleTimes() throws Exception {
    PushOneCommit.Result result = createChange();
    Change.Id id = result.getChange().getId();
    String changeId = result.getChangeId();
    String ps1 = result.getCommit().name();
    CommentInput c1 = newComment(FILE_NAME, "comment 1");
    CommentInput c2 = newComment(FILE_NAME, "comment 2");
    CommentInput c3 = newComment(FILE_NAME, "comment 3");
    addComments(changeId, ps1, c1);
    addComments(changeId, ps1, c2);
    addComments(changeId, ps1, c3);
    List<CommentInfo> commentsBeforeDelete = getChangeSortedComments(changeId);
    assertThat(commentsBeforeDelete).hasSize(3);
    Optional<CommentInfo> targetComment = commentsBeforeDelete.stream().filter(c -> c.message.equals("comment 2")).findFirst();
    assertThat(targetComment).isPresent();
    String uuid = targetComment.get().id;
    CommentInfo oldComment = gApi.changes().id(changeId).revision(ps1).comment(uuid).get();
    List<RevCommit> commitsBeforeDelete = new ArrayList<>();
    if (notesMigration.commitChangeWrites()) {
        commitsBeforeDelete = getCommits(id);
    }
    setApiUser(admin);
    for (int i = 0; i < 3; i++) {
        DeleteCommentInput input = new DeleteCommentInput("delete comment 2, iteration: " + i);
        gApi.changes().id(changeId).revision(ps1).comment(uuid).delete(input);
    }
    CommentInfo updatedComment = gApi.changes().id(changeId).revision(ps1).comment(uuid).get();
    String expectedMsg = String.format("Comment removed by: %s; Reason: %s", admin.fullName, "delete comment 2, iteration: 2");
    assertThat(updatedComment.message).isEqualTo(expectedMsg);
    oldComment.message = expectedMsg;
    assertThat(updatedComment).isEqualTo(oldComment);
    if (notesMigration.commitChangeWrites()) {
        assertMetaBranchCommitsAfterRewriting(commitsBeforeDelete, id, uuid, expectedMsg);
    }
    assertThat(getChangeSortedComments(changeId)).hasSize(3);
}
#end_block

#method_before
@Override
public CommitInfo commit(boolean addLinks) throws RestApiException {
    try {
        return getCommit.setAddLinks(addLinks).apply(revision).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve comments", e);
    }
}
#method_after
@Override
public CommitInfo commit(boolean addLinks) throws RestApiException {
    try {
        return getCommit.setAddLinks(addLinks).apply(revision).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve commit", e);
    }
}
#end_block

#method_before
public GetCommit setAddLinks(boolean addLinks) {
    this.addLinks = addLinks;
    return this;
}
#method_after
@Option(name = "--links", usage = "Include weblinks")
public GetCommit setAddLinks(boolean addLinks) {
    this.addLinks = addLinks;
    return this;
}
#end_block

#method_before
@Test
public void commit() throws Exception {
    WebLinkInfo expectedWebLinkInfo = new WebLinkInfo("foo", "imageUrl", "url");
    patchSetLinks.add(new PatchSetWebLink() {

        @Override
        public WebLinkInfo getPatchSetWebLink(String projectName, String commit) {
            return expectedWebLinkInfo;
        }
    });
    Result r = createChange();
    RevCommit c = r.getCommit();
    CommitInfo commitInfo = gApi.changes().id(r.getChangeId()).current().commit(false);
    assertThat(commitInfo.commit).isEqualTo(c.name());
    assertPersonIdent(commitInfo.author, c.getAuthorIdent());
    assertPersonIdent(commitInfo.committer, c.getCommitterIdent());
    assertThat(commitInfo.message).isEqualTo(c.getFullMessage());
    assertThat(commitInfo.subject).isEqualTo(c.getShortMessage());
    assertThat(commitInfo.parents).hasSize(1);
    assertThat(Iterables.getOnlyElement(commitInfo.parents).commit).isEqualTo(c.getParent(0).name());
    assertThat(commitInfo.webLinks).isNull();
    commitInfo = gApi.changes().id(r.getChangeId()).current().commit(true);
    assertThat(commitInfo.webLinks).hasSize(1);
    WebLinkInfo webLinkInfo = Iterables.getOnlyElement(commitInfo.webLinks);
    assertThat(webLinkInfo.name).isEqualTo(expectedWebLinkInfo.name);
    assertThat(webLinkInfo.imageUrl).isEqualTo(expectedWebLinkInfo.imageUrl);
    assertThat(webLinkInfo.url).isEqualTo(expectedWebLinkInfo.url);
    assertThat(webLinkInfo.target).isEqualTo(expectedWebLinkInfo.target);
}
#method_after
@Test
public void commit() throws Exception {
    WebLinkInfo expectedWebLinkInfo = new WebLinkInfo("foo", "imageUrl", "url");
    patchSetLinks.add(new PatchSetWebLink() {

        @Override
        public WebLinkInfo getPatchSetWebLink(String projectName, String commit) {
            return expectedWebLinkInfo;
        }
    });
    PushOneCommit.Result r = createChange();
    RevCommit c = r.getCommit();
    CommitInfo commitInfo = gApi.changes().id(r.getChangeId()).current().commit(false);
    assertThat(commitInfo.commit).isEqualTo(c.name());
    assertPersonIdent(commitInfo.author, c.getAuthorIdent());
    assertPersonIdent(commitInfo.committer, c.getCommitterIdent());
    assertThat(commitInfo.message).isEqualTo(c.getFullMessage());
    assertThat(commitInfo.subject).isEqualTo(c.getShortMessage());
    assertThat(commitInfo.parents).hasSize(1);
    assertThat(Iterables.getOnlyElement(commitInfo.parents).commit).isEqualTo(c.getParent(0).name());
    assertThat(commitInfo.webLinks).isNull();
    commitInfo = gApi.changes().id(r.getChangeId()).current().commit(true);
    assertThat(commitInfo.webLinks).hasSize(1);
    WebLinkInfo webLinkInfo = Iterables.getOnlyElement(commitInfo.webLinks);
    assertThat(webLinkInfo.name).isEqualTo(expectedWebLinkInfo.name);
    assertThat(webLinkInfo.imageUrl).isEqualTo(expectedWebLinkInfo.imageUrl);
    assertThat(webLinkInfo.url).isEqualTo(expectedWebLinkInfo.url);
    assertThat(webLinkInfo.target).isEqualTo(expectedWebLinkInfo.target);
}
#end_block

#method_before
@Override
public void onRevisionCreated(com.google.gerrit.extensions.events.RevisionCreatedListener.Event event) {
    ChangeInfo c = event.getChange();
    Config pluginConfig = cfgFactory.getGlobalPluginConfig(pluginName);
    boolean ignoreDrafts = pluginConfig.getBoolean(pluginName, null, "ignoreDrafts", false);
    if (ignoreDrafts && c.status == ChangeStatus.DRAFT) {
        log.debug("Ignoring draft change");
        return;
    }
    onEvent(new Project.NameKey(c.project), c._number, event.getWho().email);
}
#method_after
@Override
public void onRevisionCreated(RevisionCreatedListener.Event event) {
    ChangeInfo c = event.getChange();
    if (ignoreDrafts && c.status == ChangeStatus.DRAFT) {
        log.debug("Ignoring draft change");
        return;
    }
    onEvent(new Project.NameKey(c.project), c._number, event.getWho().email);
}
#end_block

#method_before
@Override
public void onDraftPublished(com.google.gerrit.extensions.events.DraftPublishedListener.Event event) {
    ChangeInfo c = event.getChange();
    onEvent(new Project.NameKey(c.project), c._number, event.getWho().email);
}
#method_after
@Override
public void onDraftPublished(DraftPublishedListener.Event event) {
    ChangeInfo c = event.getChange();
    onEvent(new Project.NameKey(c.project), c._number, event.getWho().email);
}
#end_block

#method_before
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, notesFactory, changeDataFactory, fillArgs, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, trackingFooters, index, indexConfig, listMembers, starredChangesUtil, accountCache, allowsDrafts);
}
#method_after
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, Providers.of(otherUser), permissionBackend, capabilityControlFactory, changeControlGenericFactory, notesFactory, changeDataFactory, fillArgs, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, trackingFooters, index, indexConfig, listMembers, starredChangesUtil, accountCache, allowsDrafts, notesMigration);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return ReviewerPredicate.create(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(args.fillArgs);
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    if ("submittable".equalsIgnoreCase(value)) {
        return new SubmittablePredicate(SubmitRecord.Status.OK);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.WIP)) {
            return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP, args.fillArgs)), ReviewerPredicate.reviewer(args, self()));
        }
        return ReviewerPredicate.reviewer(args, self());
    }
    if ("cc".equalsIgnoreCase(value)) {
        return ReviewerPredicate.cc(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.MERGEABLE, args.fillArgs);
    }
    if ("private".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.PRIVATE, args.fillArgs);
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    if ("submittable".equalsIgnoreCase(value)) {
        return new SubmittablePredicate(SubmitRecord.Status.OK);
    }
    if ("ignored".equalsIgnoreCase(value)) {
        return star("ignore");
    }
    if ("wip".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.WIP)) {
            return new BooleanPredicate(ChangeField.WIP, args.fillArgs);
        }
        throw new QueryParseException("'is:wip' operator is not supported by change index version");
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(args.db.get(), who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(args.capabilityControlFactory, ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#method_after
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if (isSelf(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(args.db.get(), who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(args.capabilityControlFactory, ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> reviewer(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        p.add(ReviewerPredicate.create(args, id));
    }
    return Predicate.or(p);
}
#method_after
@Operator
public Predicate<ChangeData> reviewer(String who) throws QueryParseException, OrmException {
    return reviewer(who, false);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> reviewer(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        p.add(ReviewerPredicate.create(args, id));
    }
    return Predicate.or(p);
}
#method_after
private Predicate<ChangeData> reviewer(String who, boolean forDefaultField) throws QueryParseException, OrmException {
    Predicate<ChangeData> byState = reviewerByState(who, ReviewerStateInternal.REVIEWER, forDefaultField);
    if (byState == Predicate.<ChangeData>any()) {
        return Predicate.any();
    }
    if (args.getSchema().hasField(ChangeField.WIP)) {
        return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP, args.fillArgs)), byState);
    }
    return byState;
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> author(String who) {
    String email = parseEmail(who);
    if (email.isEmpty()) {
        return new AuthorPredicate(who);
    }
    return Predicate.or(Arrays.asList(new AuthorPredicate(email), new AuthorPredicate(who)));
}
#method_after
@Operator
public Predicate<ChangeData> author(String who) throws QueryParseException {
    if (args.getSchema().hasField(ChangeField.EXACT_AUTHOR)) {
        return getAuthorOrCommitterPredicate(who.trim(), ExactAuthorPredicate::new, AuthorPredicate::new);
    }
    return getAuthorOrCommitterFullTextPredicate(who.trim(), AuthorPredicate::new);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> committer(String who) {
    String email = parseEmail(who);
    if (email.isEmpty()) {
        return new CommitterPredicate(who);
    }
    return Predicate.or(Arrays.asList(new CommitterPredicate(email), new CommitterPredicate(who)));
}
#method_after
@Operator
public Predicate<ChangeData> committer(String who) throws QueryParseException {
    if (args.getSchema().hasField(ChangeField.EXACT_COMMITTER)) {
        return getAuthorOrCommitterPredicate(who.trim(), ExactCommitterPredicate::new, CommitterPredicate::new);
    }
    return getAuthorOrCommitterFullTextPredicate(who.trim(), CommitterPredicate::new);
}
#end_block

#method_before
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        try {
            return change(query);
        } catch (QueryParseException e) {
        // Skip.
        }
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#method_after
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(2);
        try {
            predicates.add(change(query));
        } catch (QueryParseException e) {
        // Skip.
        }
        // For PAT_LEGACY_ID, it may also be the prefix of some commits.
        if (query.length() >= 6 && PAT_LEGACY_ID.matcher(query).matches()) {
            predicates.add(commit(query));
        }
        return Predicate.or(predicates);
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        Predicate<ChangeData> p = ownerDefaultField(query);
        if (p != Predicate.<ChangeData>any()) {
            predicates.add(p);
        }
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        Predicate<ChangeData> p = reviewerDefaultField(query);
        if (p != Predicate.<ChangeData>any()) {
            predicates.add(p);
        }
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(commit(query));
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#end_block

#method_before
private Set<Account.Id> parseAccount(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return Collections.singleton(self());
    }
    Set<Account.Id> matches = args.accountResolver.findAll(args.db.get(), who);
    if (matches.isEmpty()) {
        throw error("User " + who + " not found");
    }
    return matches;
}
#method_after
private Set<Account.Id> parseAccount(String who) throws QueryParseException, OrmException {
    if (isSelf(who)) {
        return Collections.singleton(self());
    }
    Set<Account.Id> matches = args.accountResolver.findAll(args.db.get(), who);
    if (matches.isEmpty()) {
        throw error("User " + who + " not found");
    }
    return matches;
}
#end_block

#method_before
protected void setUpDatabase() throws Exception {
    db = schemaFactory.open();
    schemaCreator.create(db);
    userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    Account userAccount = db.accounts().get(userId);
    userAccount.setPreferredEmail("user@example.com");
    db.accounts().update(ImmutableList.of(userAccount));
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userAccount.getId()));
}
#method_after
protected void setUpDatabase() throws Exception {
    try (ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) {
        schemaCreator.create(underlyingDb);
    }
    db = schemaFactory.open();
    userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    Account userAccount = db.accounts().get(userId);
    userAccount.setPreferredEmail("user@example.com");
    db.accounts().update(ImmutableList.of(userAccount));
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userAccount.getId()));
}
#end_block

#method_before
@After
public void tearDownInjector() {
    if (lifecycle != null) {
        lifecycle.stop();
    }
    requestContext.setContext(null);
    if (db != null) {
        db.close();
    }
    InMemoryDatabase.drop(schemaFactory);
}
#method_after
@After
public void tearDownInjector() {
    if (lifecycle != null) {
        lifecycle.stop();
    }
    requestContext.setContext(null);
    if (db != null) {
        db.close();
    }
    InMemoryDatabase.drop(inMemoryDatabase);
}
#end_block

#method_before
@Test
public void byTriplet() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change = insert(repo, newChangeForBranch(repo, "branch"));
    String k = change.getKey().get();
    assertQuery("repo~branch~" + k, change);
    assertQuery("change:repo~branch~" + k, change);
    assertQuery("repo~refs/heads/branch~" + k, change);
    assertQuery("change:repo~refs/heads/branch~" + k, change);
    assertQuery("repo~branch~" + k.substring(0, 10), change);
    assertQuery("change:repo~branch~" + k.substring(0, 10), change);
    assertQuery("foo~bar");
    assertThatQueryException("change:foo~bar").hasMessage("Invalid change format");
    assertQuery("otherrepo~branch~" + k);
    assertQuery("change:otherrepo~branch~" + k);
    assertQuery("repo~otherbranch~" + k);
    assertQuery("change:repo~otherbranch~" + k);
    assertQuery("repo~branch~I0000000000000000000000000000000000000000");
    assertQuery("change:repo~branch~I0000000000000000000000000000000000000000");
}
#method_after
@Test
public void byTriplet() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change = insert(repo, newChangeForBranch(repo, "branch"));
    String k = change.getKey().get();
    assertQuery("repo~branch~" + k, change);
    assertQuery("change:repo~branch~" + k, change);
    assertQuery("repo~refs/heads/branch~" + k, change);
    assertQuery("change:repo~refs/heads/branch~" + k, change);
    assertQuery("repo~branch~" + k.substring(0, 10), change);
    assertQuery("change:repo~branch~" + k.substring(0, 10), change);
    assertQuery("foo~bar");
    assertThatQueryException("change:foo~bar").hasMessageThat().isEqualTo("Invalid change format");
    assertQuery("otherrepo~branch~" + k);
    assertQuery("change:otherrepo~branch~" + k);
    assertQuery("repo~otherbranch~" + k);
    assertQuery("change:repo~otherbranch~" + k);
    assertQuery("repo~branch~I0000000000000000000000000000000000000000");
    assertQuery("change:repo~branch~I0000000000000000000000000000000000000000");
}
#end_block

#method_before
@Test
public void byStatusPrefix() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    assertQuery("status:n", change1);
    assertQuery("status:ne", change1);
    assertQuery("status:new", change1);
    assertQuery("status:N", change1);
    assertQuery("status:nE", change1);
    assertQuery("status:neW", change1);
    assertThatQueryException("status:nx").hasMessage("invalid change status: nx");
    assertThatQueryException("status:newx").hasMessage("invalid change status: newx");
}
#method_after
@Test
public void byStatusPrefix() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    assertQuery("status:n", change1);
    assertQuery("status:ne", change1);
    assertQuery("status:new", change1);
    assertQuery("status:N", change1);
    assertQuery("status:nE", change1);
    assertQuery("status:neW", change1);
    assertThatQueryException("status:nx").hasMessageThat().isEqualTo("invalid change status: nx");
    assertThatQueryException("status:newx").hasMessageThat().isEqualTo("invalid change status: newx");
}
#end_block

#method_before
@Test
public void byCommit() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins = newChange(repo);
    insert(repo, ins);
    String sha = ins.getCommit().name();
    assertQuery("0000000000000000000000000000000000000000");
    for (int i = 0; i <= 36; i++) {
        String q = sha.substring(0, 40 - i);
        assertQuery(q, ins.getChange());
    }
}
#method_after
@Test
public void byCommit() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins = newChange(repo);
    insert(repo, ins);
    String sha = ins.getCommitId().name();
    assertQuery("0000000000000000000000000000000000000000");
    for (int i = 0; i <= 36; i++) {
        String q = sha.substring(0, 40 - i);
        assertQuery(q, ins.getChange());
    }
}
#end_block

#method_before
@Test
public void maxPages() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change = insert(repo, newChange(repo));
    QueryRequest query = newQuery("status:new").withLimit(10);
    assertQuery(query, change);
    assertQuery(query.withStart(1));
    assertQuery(query.withStart(99));
    assertThatQueryException(query.withStart(100)).hasMessage("Cannot go beyond page 10 of results");
    assertQuery(query.withLimit(100).withStart(100));
}
#method_after
@Test
public void maxPages() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change = insert(repo, newChange(repo));
    QueryRequest query = newQuery("status:new").withLimit(10);
    assertQuery(query, change);
    assertQuery(query.withStart(1));
    assertQuery(query.withStart(99));
    assertThatQueryException(query.withStart(100)).hasMessageThat().isEqualTo("Cannot go beyond page 10 of results");
    assertQuery(query.withLimit(100).withStart(100));
}
#end_block

#method_before
@Test
public void byDraftByExcludesZombieDrafts() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    Project.NameKey project = new Project.NameKey("repo");
    TestRepository<Repo> repo = createProject(project.get());
    Change change = insert(repo, newChange(repo));
    Change.Id id = change.getId();
    DraftInput in = new DraftInput();
    in.line = 1;
    in.message = "nit: trailing whitespace";
    in.path = Patch.COMMIT_MSG;
    gApi.changes().id(id.get()).current().createDraft(in);
    assertQuery("draftby:" + userId, change);
    assertQuery("commentby:" + userId);
    TestRepository<Repo> allUsers = new TestRepository<>(repoManager.openRepository(allUsersName));
    Ref draftsRef = allUsers.getRepository().exactRef(RefNames.refsDraftComments(id, userId));
    assertThat(draftsRef).isNotNull();
    ReviewInput rin = ReviewInput.dislike();
    rin.drafts = DraftHandling.PUBLISH_ALL_REVISIONS;
    gApi.changes().id(id.get()).current().review(rin);
    assertQuery("draftby:" + userId);
    assertQuery("commentby:" + userId, change);
    assertThat(allUsers.getRepository().exactRef(draftsRef.getName())).isNull();
    // Re-add drafts ref and ensure it gets filtered out during indexing.
    allUsers.update(draftsRef.getName(), draftsRef.getObjectId());
    assertThat(allUsers.getRepository().exactRef(draftsRef.getName())).isNotNull();
    if (PrimaryStorage.of(change) == PrimaryStorage.REVIEW_DB) {
        // Record draft ref in noteDbState as well.
        ReviewDb db = ReviewDbUtil.unwrapDb(this.db);
        change = db.changes().get(id);
        NoteDbChangeState.applyDelta(change, NoteDbChangeState.Delta.create(id, Optional.empty(), ImmutableMap.of(userId, draftsRef.getObjectId())));
        db.changes().update(Collections.singleton(change));
    }
    indexer.index(db, project, id);
    assertQuery("draftby:" + userId);
}
#method_after
@Test
public void byDraftByExcludesZombieDrafts() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    Project.NameKey project = new Project.NameKey("repo");
    TestRepository<Repo> repo = createProject(project.get());
    Change change = insert(repo, newChange(repo));
    Change.Id id = change.getId();
    DraftInput in = new DraftInput();
    in.line = 1;
    in.message = "nit: trailing whitespace";
    in.path = Patch.COMMIT_MSG;
    gApi.changes().id(id.get()).current().createDraft(in);
    assertQuery("draftby:" + userId, change);
    assertQuery("commentby:" + userId);
    TestRepository<Repo> allUsers = new TestRepository<>(repoManager.openRepository(allUsersName));
    Ref draftsRef = allUsers.getRepository().exactRef(RefNames.refsDraftComments(id, userId));
    assertThat(draftsRef).isNotNull();
    ReviewInput rin = ReviewInput.dislike();
    rin.drafts = DraftHandling.PUBLISH_ALL_REVISIONS;
    gApi.changes().id(id.get()).current().review(rin);
    assertQuery("draftby:" + userId);
    assertQuery("commentby:" + userId, change);
    assertThat(allUsers.getRepository().exactRef(draftsRef.getName())).isNull();
    // Re-add drafts ref and ensure it gets filtered out during indexing.
    allUsers.update(draftsRef.getName(), draftsRef.getObjectId());
    assertThat(allUsers.getRepository().exactRef(draftsRef.getName())).isNotNull();
    if (PrimaryStorage.of(change) == PrimaryStorage.REVIEW_DB && !notesMigration.disableChangeReviewDb()) {
        // Record draft ref in noteDbState as well.
        ReviewDb db = ReviewDbUtil.unwrapDb(this.db);
        change = db.changes().get(id);
        NoteDbChangeState.applyDelta(change, NoteDbChangeState.Delta.create(id, Optional.empty(), ImmutableMap.of(userId, draftsRef.getObjectId())));
        db.changes().update(Collections.singleton(change));
    }
    indexer.index(db, project, id);
    assertQuery("draftby:" + userId);
}
#end_block

#method_before
@Test
public void byStar() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo));
    Change change2 = insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    gApi.accounts().self().setStars(change1.getId().toString(), new StarsInput(new HashSet<>(Arrays.asList("red", "blue"))));
    gApi.accounts().self().setStars(change2.getId().toString(), new StarsInput(new HashSet<>(Arrays.asList(StarredChangesUtil.DEFAULT_LABEL, "green", "blue"))));
    // check labeled stars
    assertQuery("star:red", change1);
    assertQuery("star:blue", change2, change1);
    assertQuery("has:stars", change2, change1);
    // check default star
    assertQuery("has:star", change2);
    assertQuery("is:starred", change2);
    assertQuery("starredby:self", change2);
    assertQuery("star:" + StarredChangesUtil.DEFAULT_LABEL, change2);
}
#method_after
@Test
public void byStar() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo));
    Change change2 = insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    Change change3 = insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    Change change4 = insert(repo, newChange(repo));
    gApi.accounts().self().setStars(change1.getId().toString(), new StarsInput(new HashSet<>(Arrays.asList("red", "blue"))));
    gApi.accounts().self().setStars(change2.getId().toString(), new StarsInput(new HashSet<>(Arrays.asList(StarredChangesUtil.DEFAULT_LABEL, "green", "blue"))));
    gApi.accounts().self().setStars(change4.getId().toString(), new StarsInput(new HashSet<>(Arrays.asList("ignore"))));
    // check labeled stars
    assertQuery("star:red", change1);
    assertQuery("star:blue", change2, change1);
    assertQuery("has:stars", change4, change2, change1);
    // check default star
    assertQuery("has:star", change2);
    assertQuery("is:starred", change2);
    assertQuery("starredby:self", change2);
    assertQuery("star:" + StarredChangesUtil.DEFAULT_LABEL, change2);
    // check ignored
    assertQuery("is:ignored", change4);
    assertQuery("-is:ignored", change3, change2, change1);
}
#end_block

#method_before
@Test
public void byCommitsOnBranchNotMerged() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    int n = 10;
    List<String> shas = new ArrayList<>(n);
    List<Integer> expectedIds = new ArrayList<>(n);
    Branch.NameKey dest = null;
    for (int i = 0; i < n; i++) {
        ChangeInserter ins = newChange(repo);
        insert(repo, ins);
        if (dest == null) {
            dest = ins.getChange().getDest();
        }
        shas.add(ins.getCommit().name());
        expectedIds.add(ins.getChange().getId().get());
    }
    for (int i = 1; i <= 11; i++) {
        Iterable<ChangeData> cds = internalChangeQuery.byCommitsOnBranchNotMerged(repo.getRepository(), db, dest, shas, i);
        Iterable<Integer> ids = FluentIterable.from(cds).transform(in -> in.getId().get());
        String name = "limit " + i;
        assertThat(ids).named(name).hasSize(n);
        assertThat(ids).named(name).containsExactlyElementsIn(expectedIds);
    }
}
#method_after
@Test
public void byCommitsOnBranchNotMerged() throws Exception {
    TestRepository<Repo> tr = createProject("repo");
    testByCommitsOnBranchNotMerged(tr, ImmutableSet.of());
}
#end_block

#method_before
protected ChangeInserter newChange(TestRepository<Repo> repo, @Nullable RevCommit commit, @Nullable String branch, @Nullable Change.Status status, @Nullable String topic) throws Exception {
    if (commit == null) {
        commit = repo.parseBody(repo.commit().message("message").create());
    }
    branch = MoreObjects.firstNonNull(branch, "refs/heads/master");
    if (!branch.startsWith("refs/heads/")) {
        branch = "refs/heads/" + branch;
    }
    Change.Id id = new Change.Id(seq.nextChangeId());
    ChangeInserter ins = changeFactory.create(id, commit, branch).setValidatePolicy(CommitValidators.Policy.NONE).setStatus(status).setTopic(topic);
    return ins;
}
#method_after
protected ChangeInserter newChange(TestRepository<Repo> repo, @Nullable RevCommit commit, @Nullable String branch, @Nullable Change.Status status, @Nullable String topic) throws Exception {
    if (commit == null) {
        commit = repo.parseBody(repo.commit().message("message").create());
    }
    branch = MoreObjects.firstNonNull(branch, "refs/heads/master");
    if (!branch.startsWith("refs/heads/")) {
        branch = "refs/heads/" + branch;
    }
    Change.Id id = new Change.Id(seq.nextChangeId());
    ChangeInserter ins = changeFactory.create(id, commit, branch).setValidate(false).setStatus(status).setTopic(topic);
    return ins;
}
#end_block

#method_before
protected Change newPatchSet(TestRepository<Repo> repo, Change c) throws Exception {
    // Add a new file so the patch set is not a trivial rebase, to avoid default
    // Code-Review label copying.
    int n = c.currentPatchSetId().get() + 1;
    RevCommit commit = repo.parseBody(repo.commit().message("message").add("file" + n, "contents " + n).create());
    ChangeControl ctl = changeControlFactory.controlFor(db, c, user);
    PatchSetInserter inserter = patchSetFactory.create(ctl, new PatchSet.Id(c.getId(), n), commit).setNotify(NotifyHandling.NONE).setFireRevisionCreated(false).setValidatePolicy(CommitValidators.Policy.NONE);
    try (BatchUpdate bu = updateFactory.create(db, c.getProject(), user, TimeUtil.nowTs());
        ObjectInserter oi = repo.getRepository().newObjectInserter()) {
        bu.setRepository(repo.getRepository(), repo.getRevWalk(), oi);
        bu.addOp(c.getId(), inserter);
        bu.execute();
    }
    return inserter.getChange();
}
#method_after
protected Change newPatchSet(TestRepository<Repo> repo, Change c) throws Exception {
    // Add a new file so the patch set is not a trivial rebase, to avoid default
    // Code-Review label copying.
    int n = c.currentPatchSetId().get() + 1;
    RevCommit commit = repo.parseBody(repo.commit().message("message").add("file" + n, "contents " + n).create());
    ChangeControl ctl = changeControlFactory.controlFor(db, c, user);
    PatchSetInserter inserter = patchSetFactory.create(ctl, new PatchSet.Id(c.getId(), n), commit).setNotify(NotifyHandling.NONE).setFireRevisionCreated(false).setValidate(false);
    try (BatchUpdate bu = updateFactory.create(db, c.getProject(), user, TimeUtil.nowTs());
        ObjectInserter oi = repo.getRepository().newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo.getRepository(), rw, oi);
        bu.addOp(c.getId(), inserter);
        bu.execute();
    }
    return inserter.getChange();
}
#end_block

#method_before
private Account.Id createAccount(String name) throws Exception {
    return accountManager.authenticate(AuthRequest.forUser(name)).getAccountId();
}
#method_after
private Account.Id createAccount(String username, String fullName, String email, boolean active) throws Exception {
    try (ManualRequestContext ctx = oneOffRequestContext.open()) {
        Account.Id id = accountManager.authenticate(AuthRequest.forUser(username)).getAccountId();
        if (email != null) {
            accountManager.link(id, AuthRequest.forEmail(email));
        }
        Account a = db.accounts().get(id);
        a.setFullName(fullName);
        a.setPreferredEmail(email);
        a.setActive(active);
        db.accounts().update(ImmutableList.of(a));
        accountCache.evict(id);
        return id;
    }
}
#end_block

#method_before
@Test
public void deleteCommentByRewritingCommitHistory() throws Exception {
    // Creates the following commit history on the meta branch of the test change. Then try to
    // delete the comments one by one, which will rewrite most of the commits on the 'meta' branch.
    // Commits will be rewritten N times if it puts in N comments. After each deletion, the meta
    // branch should keep its previous state except that the target comment's message should be
    // updated.
    // 1st commit: Create PS1.
    PushOneCommit.Result result1 = createChange(SUBJECT, "a.txt", "a");
    Change.Id id = result1.getChange().getId();
    String changeId = result1.getChangeId();
    String ps1 = result1.getCommit().name();
    // 2nd commit: Add (c1) to PS1.
    CommentInput c1 = newComment("a.txt", "comment 1");
    addComments(changeId, ps1, c1);
    // 3rd commit: Add (c2, c3) to PS1.
    CommentInput c2 = newComment("a.txt", "comment 2");
    CommentInput c3 = newComment("a.txt", "comment 3");
    addComments(changeId, ps1, c2, c3);
    // 4th commit: Add (c4) to PS1.
    CommentInput c4 = newComment("a.txt", "comment 4");
    addComments(changeId, ps1, c4);
    // 5th commit: Create PS2.
    PushOneCommit.Result result2 = amendChange(changeId, "refs/for/master", "b.txt", "b");
    String ps2 = result2.getCommit().name();
    // 6th commit: Add (c5) to PS1.
    CommentInput c5 = newComment("a.txt", "comment 5");
    addComments(changeId, ps1, c5);
    // 7th commit: Add (c6) to PS2.
    CommentInput c6 = newComment("b.txt", "comment 6");
    addComments(changeId, ps2, c6);
    // 8th commit: Create PS3.
    PushOneCommit.Result result3 = amendChange(changeId);
    String ps3 = result3.getCommit().name();
    // 9th commit: Create PS4.
    PushOneCommit.Result result4 = amendChange(changeId, "refs/for/master", "c.txt", "c");
    String ps4 = result4.getCommit().name();
    // 10th commit: Add (c7, c8) to PS4.
    CommentInput c7 = newComment("c.txt", "comment 7");
    CommentInput c8 = newComment("b.txt", "comment 8");
    addComments(changeId, ps4, c7, c8);
    // 11th commit: Add (c4) to PS2.
    CommentInput c9 = newComment("b.txt", "comment 9");
    addComments(changeId, ps2, c9);
    List<CommentInfo> commentsBeforeDelete = getChangeSortedComments(changeId);
    assertThat(commentsBeforeDelete).hasSize(9);
    // PS1 has comments [c1, c2, c3, c4, c5].
    assertThat(getRevisionComments(changeId, ps1)).hasSize(5);
    // PS2 has comments [c6, c9].
    assertThat(getRevisionComments(changeId, ps2)).hasSize(2);
    // PS3 has no comment.
    assertThat(getRevisionComments(changeId, ps3)).hasSize(0);
    // PS4 has comments [c7, c8].
    assertThat(getRevisionComments(changeId, ps4)).hasSize(2);
    setApiUser(admin);
    for (int i = 0; i < commentsBeforeDelete.size(); i++) {
        List<RevCommit> commitsBeforeDelete = new ArrayList<>();
        if (notesMigration.commitChangeWrites()) {
            commitsBeforeDelete = getCommits(id);
        }
        CommentInfo comment = commentsBeforeDelete.get(i);
        String uuid = comment.id;
        int patchSet = comment.patchSet;
        // 'oldComment' has some fields unset compared with 'comment'.
        CommentInfo oldComment = gApi.changes().id(changeId).revision(patchSet).comment(uuid).get();
        DeleteCommentInput input = new DeleteCommentInput("delete comment " + uuid);
        CommentInfo updatedComment = gApi.changes().id(changeId).revision(patchSet).comment(uuid).delete(input);
        String expectedMsg = String.format("Comment removed by: %s; Reason: %s", admin.fullName, input.reason);
        assertThat(updatedComment.message).isEqualTo(expectedMsg);
        oldComment.message = expectedMsg;
        assertThat(updatedComment).isEqualTo(oldComment);
        // Check the NoteDb state after the deletion.
        if (notesMigration.commitChangeWrites()) {
            assertMetaBranchCommitsAfterRewriting(commitsBeforeDelete, id, uuid, expectedMsg);
        }
        comment.message = expectedMsg;
        commentsBeforeDelete.set(i, comment);
        List<CommentInfo> commentsAfterDelete = getChangeSortedComments(changeId);
        assertThat(commentsAfterDelete).isEqualTo(commentsBeforeDelete);
    }
    // Make sure that comments can still be added correctly.
    CommentInput c10 = newComment("a.txt", "comment 10");
    CommentInput c11 = newComment("b.txt", "comment 11");
    CommentInput c12 = newComment("a.txt", "comment 12");
    CommentInput c13 = newComment("c.txt", "comment 13");
    addComments(changeId, ps1, c10);
    addComments(changeId, ps2, c11);
    addComments(changeId, ps3, c12);
    addComments(changeId, ps4, c13);
    assertThat(getChangeSortedComments(changeId)).hasSize(13);
    assertThat(getRevisionComments(changeId, ps1)).hasSize(6);
    assertThat(getRevisionComments(changeId, ps2)).hasSize(3);
    assertThat(getRevisionComments(changeId, ps3)).hasSize(1);
    assertThat(getRevisionComments(changeId, ps4)).hasSize(3);
}
#method_after
@Test
public void deleteCommentByRewritingCommitHistory() throws Exception {
    // Creates the following commit history on the meta branch of the test change. Then tries to
    // delete the comments one by one, which will rewrite most of the commits on the 'meta' branch.
    // Commits will be rewritten N times for N added comments. After each deletion, the meta branch
    // should keep its previous state except that the target comment's message should be updated.
    // 1st commit: Create PS1.
    PushOneCommit.Result result1 = createChange(SUBJECT, "a.txt", "a");
    Change.Id id = result1.getChange().getId();
    String changeId = result1.getChangeId();
    String ps1 = result1.getCommit().name();
    // 2nd commit: Add (c1) to PS1.
    CommentInput c1 = newComment("a.txt", "comment 1");
    addComments(changeId, ps1, c1);
    // 3rd commit: Add (c2, c3) to PS1.
    CommentInput c2 = newComment("a.txt", "comment 2");
    CommentInput c3 = newComment("a.txt", "comment 3");
    addComments(changeId, ps1, c2, c3);
    // 4th commit: Add (c4) to PS1.
    CommentInput c4 = newComment("a.txt", "comment 4");
    addComments(changeId, ps1, c4);
    // 5th commit: Create PS2.
    PushOneCommit.Result result2 = amendChange(changeId, "refs/for/master", "b.txt", "b");
    String ps2 = result2.getCommit().name();
    // 6th commit: Add (c5) to PS1.
    CommentInput c5 = newComment("a.txt", "comment 5");
    addComments(changeId, ps1, c5);
    // 7th commit: Add (c6) to PS2.
    CommentInput c6 = newComment("b.txt", "comment 6");
    addComments(changeId, ps2, c6);
    // 8th commit: Create PS3.
    PushOneCommit.Result result3 = amendChange(changeId);
    String ps3 = result3.getCommit().name();
    // 9th commit: Create PS4.
    PushOneCommit.Result result4 = amendChange(changeId, "refs/for/master", "c.txt", "c");
    String ps4 = result4.getCommit().name();
    // 10th commit: Add (c7, c8) to PS4.
    CommentInput c7 = newComment("c.txt", "comment 7");
    CommentInput c8 = newComment("b.txt", "comment 8");
    addComments(changeId, ps4, c7, c8);
    // 11th commit: Add (c9) to PS2.
    CommentInput c9 = newComment("b.txt", "comment 9");
    addComments(changeId, ps2, c9);
    List<CommentInfo> commentsBeforeDelete = getChangeSortedComments(changeId);
    assertThat(commentsBeforeDelete).hasSize(9);
    // PS1 has comments [c1, c2, c3, c4, c5].
    assertThat(getRevisionComments(changeId, ps1)).hasSize(5);
    // PS2 has comments [c6, c9].
    assertThat(getRevisionComments(changeId, ps2)).hasSize(2);
    // PS3 has no comment.
    assertThat(getRevisionComments(changeId, ps3)).hasSize(0);
    // PS4 has comments [c7, c8].
    assertThat(getRevisionComments(changeId, ps4)).hasSize(2);
    setApiUser(admin);
    for (int i = 0; i < commentsBeforeDelete.size(); i++) {
        List<RevCommit> commitsBeforeDelete = new ArrayList<>();
        if (notesMigration.commitChangeWrites()) {
            commitsBeforeDelete = getCommits(id);
        }
        CommentInfo comment = commentsBeforeDelete.get(i);
        String uuid = comment.id;
        int patchSet = comment.patchSet;
        // 'oldComment' has some fields unset compared with 'comment'.
        CommentInfo oldComment = gApi.changes().id(changeId).revision(patchSet).comment(uuid).get();
        DeleteCommentInput input = new DeleteCommentInput("delete comment " + uuid);
        CommentInfo updatedComment = gApi.changes().id(changeId).revision(patchSet).comment(uuid).delete(input);
        String expectedMsg = String.format("Comment removed by: %s; Reason: %s", admin.fullName, input.reason);
        assertThat(updatedComment.message).isEqualTo(expectedMsg);
        oldComment.message = expectedMsg;
        assertThat(updatedComment).isEqualTo(oldComment);
        // Check the NoteDb state after the deletion.
        if (notesMigration.commitChangeWrites()) {
            assertMetaBranchCommitsAfterRewriting(commitsBeforeDelete, id, uuid, expectedMsg);
        }
        comment.message = expectedMsg;
        commentsBeforeDelete.set(i, comment);
        List<CommentInfo> commentsAfterDelete = getChangeSortedComments(changeId);
        assertThat(commentsAfterDelete).isEqualTo(commentsBeforeDelete);
    }
    // Make sure that comments can still be added correctly.
    CommentInput c10 = newComment("a.txt", "comment 10");
    CommentInput c11 = newComment("b.txt", "comment 11");
    CommentInput c12 = newComment("a.txt", "comment 12");
    CommentInput c13 = newComment("c.txt", "comment 13");
    addComments(changeId, ps1, c10);
    addComments(changeId, ps2, c11);
    addComments(changeId, ps3, c12);
    addComments(changeId, ps4, c13);
    assertThat(getChangeSortedComments(changeId)).hasSize(13);
    assertThat(getRevisionComments(changeId, ps1)).hasSize(6);
    assertThat(getRevisionComments(changeId, ps2)).hasSize(3);
    assertThat(getRevisionComments(changeId, ps3)).hasSize(1);
    assertThat(getRevisionComments(changeId, ps4)).hasSize(3);
}
#end_block

#method_before
private List<CommentInfo> getChangeSortedComments(String changeId) throws Exception {
    List<CommentInfo> comments = new ArrayList<>();
    Map<String, List<CommentInfo>> commentsMap = getPublishedComments(changeId);
    for (Entry<String, List<CommentInfo>> e : commentsMap.entrySet()) {
        for (CommentInfo c : e.getValue()) {
            // Set the comment's path field.
            c.path = e.getKey();
            comments.add(c);
        }
    }
    Collections.sort(comments, (c1, c2) -> c1.id.compareTo(c2.id));
    return comments;
}
#method_after
private List<CommentInfo> getChangeSortedComments(String changeId) throws Exception {
    List<CommentInfo> comments = new ArrayList<>();
    Map<String, List<CommentInfo>> commentsMap = getPublishedComments(changeId);
    for (Entry<String, List<CommentInfo>> e : commentsMap.entrySet()) {
        for (CommentInfo c : e.getValue()) {
            // Set the comment's path field.
            c.path = e.getKey();
            comments.add(c);
        }
    }
    comments.sort(Comparator.comparing(c -> c.id));
    return comments;
}
#end_block

#method_before
private List<CommentInfo> getRevisionComments(String changeId, String revId) throws Exception {
    return getPublishedComments(changeId, revId).values().stream().flatMap(t -> t.stream()).collect(Collectors.toList());
}
#method_after
private List<CommentInfo> getRevisionComments(String changeId, String revId) throws Exception {
    return getPublishedComments(changeId, revId).values().stream().flatMap(List::stream).collect(Collectors.toList());
}
#end_block

#method_before
private void addComments(String changeId, String revision, CommentInput... commentInputs) throws Exception {
    ReviewInput input = new ReviewInput();
    input.comments = new HashMap<>();
    for (int i = 0; i < commentInputs.length; i++) {
        CommentInput c = commentInputs[i];
        if (!input.comments.containsKey(c.path)) {
            input.comments.put(c.path, Lists.newArrayList(c));
        } else {
            input.comments.get(c.path).add(c);
        }
    }
    input.label("Code-Review", 1);
    gApi.changes().id(changeId).revision(revision).review(input);
}
#method_after
private void addComments(String changeId, String revision, CommentInput... commentInputs) throws Exception {
    ReviewInput input = new ReviewInput();
    input.comments = Arrays.stream(commentInputs).collect(Collectors.groupingBy(c -> c.path));
    gApi.changes().id(changeId).revision(revision).review(input);
}
#end_block

#method_before
public ImmutableList<T> getComments() {
    checkParsed();
    return comments != null ? comments : ImmutableList.of();
}
#method_after
public ImmutableList<T> getComments() {
    checkParsed();
    return comments;
}
#end_block

#method_before
public void parse() throws IOException, ConfigInvalidException {
    raw = reader.open(noteId, OBJ_BLOB).getCachedBytes(MAX_NOTE_SZ);
    MutableInteger p = new MutableInteger();
    trimLeadingEmptyLines(raw, p);
    if (p.value >= raw.length) {
        comments = null;
        return;
    }
    comments = ImmutableList.copyOf(parse(raw, p.value));
}
#method_after
public void parse() throws IOException, ConfigInvalidException {
    raw = reader.open(noteId, OBJ_BLOB).getCachedBytes(MAX_NOTE_SZ);
    MutableInteger p = new MutableInteger();
    trimLeadingEmptyLines(raw, p);
    if (p.value >= raw.length) {
        comments = ImmutableList.of();
        return;
    }
    comments = ImmutableList.copyOf(parse(raw, p.value));
}
#end_block

#method_before
private void assertHasNoChildProjects(ProjectResource rsrc) throws CannotDeleteProjectException {
    try {
        List<ProjectInfo> children = listChildProjectsProvider.get().apply(rsrc);
        if (!children.isEmpty()) {
            String childrenString = Joiner.on(", ").join(Iterables.transform(children, new Function<ProjectInfo, String>() {

                @Override
                public String apply(ProjectInfo info) {
                    return info.name;
                }
            }));
            throw new CannotDeleteProjectException("Cannot delete project because " + "it has children: " + childrenString);
        }
    } catch (PermissionBackendException e) {
        throw new CannotDeleteProjectException("Cannot delete project because " + "of failure in permission backend.");
    }
}
#method_after
private void assertHasNoChildProjects(ProjectResource rsrc) throws CannotDeleteProjectException {
    try {
        List<ProjectInfo> children = listChildProjectsProvider.get().apply(rsrc);
        if (!children.isEmpty()) {
            String childrenString = Joiner.on(", ").join(Iterables.transform(children, new Function<ProjectInfo, String>() {

                @Override
                public String apply(ProjectInfo info) {
                    return info.name;
                }
            }));
            throw new CannotDeleteProjectException("Cannot delete project because it has children: " + childrenString);
        }
    } catch (PermissionBackendException e) {
        throw new CannotDeleteProjectException("Cannot delete project because of failure in permission backend.");
    }
}
#end_block

#method_before
protected boolean canDelete(ProjectResource rsrc) {
    WithUser userPermission = permissionBackend.user(userProvider.get());
    return userPermission.testOrFalse(GlobalPermission.ADMINISTRATE_SERVER) || userPermission.testOrFalse(new PluginPermission(pluginName, DELETE_PROJECT)) || (userPermission.testOrFalse(new PluginPermission(pluginName, DELETE_OWN_PROJECT)) && rsrc.getControl().isOwner());
}
#method_after
protected boolean canDelete(ProjectResource rsrc) {
    PermissionBackend.WithUser userPermission = permissionBackend.user(userProvider);
    return userPermission.testOrFalse(GlobalPermission.ADMINISTRATE_SERVER) || userPermission.testOrFalse(new PluginPermission(pluginName, DELETE_PROJECT)) || (userPermission.testOrFalse(new PluginPermission(pluginName, DELETE_OWN_PROJECT)) && rsrc.getControl().isOwner());
}
#end_block

