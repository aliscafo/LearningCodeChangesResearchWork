1253
#method_before
private void writeMetadata() {
    // <domain>
    // ...
    // <metadata>
    // <ovirt-tune:qos/>
    // <ovirt-vm:qos/>
    // </metadata>
    // ...
    // </domain>
    writer.writeStartElement("metadata");
    writeQosMetadata();
    writeVmMetadata();
    writer.writeEndElement();
}
#method_after
private void writeMetadata() {
    // <domain>
    // ...
    // <metadata>
    // <ovirt-tune:qos/>
    // <ovirt-vm:vm/>
    // </metadata>
    // ...
    // </domain>
    writer.writeStartElement("metadata");
    writeQosMetadata();
    writeVmMetadata();
    writer.writeEndElement();
}
#end_block

#method_before
private void writeVmCustomMetadata() {
    writer.writeStartElement(OVIRT_VM_URI, "custom");
    Map<String, String> vmCutomProperties = VmPropertiesUtils.getInstance().getVMProperties(vm.getCompatibilityVersion(), vm.getStaticData());
    vmCutomProperties.entrySet().forEach(property -> writer.writeElement(OVIRT_VM_URI, property.getKey(), property.getValue()));
    writer.writeEndElement();
}
#method_after
private void writeVmCustomMetadata() {
    writer.writeStartElement(OVIRT_VM_URI, "custom");
    Map<String, String> vmCustomProperties = VmPropertiesUtils.getInstance().getVMProperties(vm.getCompatibilityVersion(), vm.getStaticData());
    vmCustomProperties.entrySet().forEach(property -> writer.writeElement(OVIRT_VM_URI, property.getKey(), property.getValue()));
    writer.writeEndElement();
}
#end_block

#method_before
private List<Map<String, Object>> parseDisks(XmlDocument document, List<VmDevice> devices) {
    List<VmDevice> dbDevices = filterDevices(devices, VmDeviceGeneralType.DISK);
    List<Map<String, Object>> result = new ArrayList<>();
    for (XmlNode node : selectNodes(document, VmDeviceGeneralType.DISK)) {
        Map<String, Object> dev = new HashMap<>();
        dev.put(VdsProperties.Type, VmDeviceGeneralType.DISK.getValue());
        String diskType = parseAttribute(node, DEVICE);
        dev.put(VdsProperties.Device, diskType);
        dev.put(VdsProperties.Address, parseAddress(node));
        dev.put(VdsProperties.Alias, parseAlias(node));
        String path = parseDiskPath(node);
        VmDevice dbDev = dbDevices.stream().filter(d -> {
            switch(diskType) {
                case "cdrom":
                    if (!diskType.equals(d.getDevice())) {
                        return false;
                    }
                    String devicePath = (String) d.getSpecParams().get("path");
                    return devicePath == null || path.contains(devicePath);
                case "floppy":
                    return diskType.equals(d.getDevice());
                default:
                    Guid diskId = d.getId().getDeviceId();
                    return path.contains(diskId.toString()) || isPathContainsLunIdOfDisk(path, diskId);
            }
        }).findFirst().orElse(null);
        if (dbDev == null) {
            log.warn("unmanaged disk with path '{}' is ignored", path);
            continue;
        }
        dbDevices.remove(dbDev);
        dev.put(VdsProperties.DeviceId, dbDev.getId().getDeviceId().toString());
        dev.put(VdsProperties.SpecParams, dbDev.getSpecParams());
        result.add(dev);
    }
    return result;
}
#method_after
private List<Map<String, Object>> parseDisks(XmlDocument document, List<VmDevice> devices) {
    List<VmDevice> dbDevices = filterDevices(devices, VmDeviceGeneralType.DISK);
    MemoizingSupplier<Map<Guid, String>> diskToLunSupplier = new MemoizingSupplier<>(() -> diskLunMapDao.getAll().stream().collect(Collectors.toMap(DiskLunMap::getDiskId, DiskLunMap::getLunId)));
    List<Map<String, Object>> result = new ArrayList<>();
    for (XmlNode node : selectNodes(document, VmDeviceGeneralType.DISK)) {
        Map<String, Object> dev = new HashMap<>();
        dev.put(VdsProperties.Type, VmDeviceGeneralType.DISK.getValue());
        String diskType = parseAttribute(node, DEVICE);
        dev.put(VdsProperties.Device, diskType);
        dev.put(VdsProperties.Address, parseAddress(node));
        dev.put(VdsProperties.Alias, parseAlias(node));
        String path = parseDiskPath(node);
        VmDevice dbDev = dbDevices.stream().filter(d -> {
            switch(diskType) {
                case "cdrom":
                    if (!diskType.equals(d.getDevice())) {
                        return false;
                    }
                    String devicePath = (String) d.getSpecParams().get("path");
                    return devicePath == null || path.contains(devicePath);
                case "floppy":
                    return diskType.equals(d.getDevice());
                default:
                    Guid diskId = d.getId().getDeviceId();
                    return path.contains(diskId.toString()) || isPathContainsLunIdOfDisk(path, diskId, diskToLunSupplier);
            }
        }).findFirst().orElse(null);
        if (dbDev == null) {
            log.warn("unmanaged disk with path '{}' is ignored", path);
            continue;
        }
        dbDevices.remove(dbDev);
        dev.put(VdsProperties.DeviceId, dbDev.getId().getDeviceId().toString());
        dev.put(VdsProperties.SpecParams, dbDev.getSpecParams());
        result.add(dev);
    }
    return result;
}
#end_block

#method_before
private boolean isPathContainsLunIdOfDisk(String path, Guid diskId) {
    Map<Guid, String> diskToLunMap = getDiskToLunMap();
    return diskToLunMap.containsKey(diskId) && path.contains(diskToLunMap.get(diskId));
}
#method_after
private boolean isPathContainsLunIdOfDisk(String path, Guid diskId, MemoizingSupplier<Map<Guid, String>> diskToLunSupplier) {
    String lunId = diskToLunSupplier.get().get(diskId);
    return lunId != null && path.contains(lunId);
}
#end_block

#method_before
@Override
protected void onReveal() {
    Event<EventArgs> entityChangedEvent = getModel().getDiskViewType().getEntityChangedEvent();
    if (!entityChangedEvent.getListeners().contains(getView().getDiskTypeChangedEventListener())) {
        entityChangedEvent.addListener(getView().getDiskTypeChangedEventListener());
    }
    Event<EventArgs> diskContentTypeEntityChangedEvent = getModel().getDiskContentType().getEntityChangedEvent();
    if (!diskContentTypeEntityChangedEvent.getListeners().contains(getView().getDiskTypeChangedEventListener())) {
        diskContentTypeEntityChangedEvent.addListener(getView().getDiskContentTypeChangedEventListener());
    }
    super.onReveal();
    getView().handleQuotaColumnVisibility();
}
#method_after
@Override
protected void onReveal() {
    super.onReveal();
    getView().handleQuotaColumnVisibility();
}
#end_block

#method_before
@Override
public void handleQuotaColumnVisibility() {
    isQuotaVisible = false;
    if (dataCenterListModel.getSelectedItem() != null) {
        StoragePool storagePool = dataCenterListModel.getSelectedItem();
        if (QuotaEnforcementTypeEnum.DISABLED != storagePool.getQuotaEnforcementType()) {
            isQuotaVisible = true;
        }
    }
    onDiskViewTypeChanged();
}
#method_after
@Override
public void handleQuotaColumnVisibility() {
    isQuotaVisible = false;
    if (dataCenterListModel.getSelectedItem() != null) {
        StoragePool storagePool = dataCenterListModel.getSelectedItem();
        if (QuotaEnforcementTypeEnum.DISABLED != storagePool.getQuotaEnforcementType()) {
            isQuotaVisible = true;
        }
    }
    onDiskViewTypeChanged(disksViewRadioGroup.getDiskStorageType());
}
#end_block

#method_before
void onDiskViewTypeChanged() {
    boolean all = disksViewRadioGroup.getAllButton().getValue();
    boolean images = disksViewRadioGroup.getImagesButton().getValue();
    boolean luns = disksViewRadioGroup.getLunsButton().getValue();
    boolean cinder = disksViewRadioGroup.getCinderButton().getValue();
    searchByDiskViewType(disksViewRadioGroup.getDiskStorageType(), disksContentTypeRadioGroup.getDiskContentType());
    getTable().ensureColumnVisible(aliasColumn, constants.aliasDisk(), all || images || luns || cinder, // $NON-NLS-1$
    "150px");
    getTable().ensureColumnVisible(idColumn, constants.idDisk(), all || images || luns || cinder, // $NON-NLS-1$
    "150px");
    getTable().ensureColumnVisible(DisksViewColumns.shareableDiskColumn, new ImageResourceHeader(DisksViewColumns.shareableDiskColumn.getDefaultImage(), SafeHtmlUtils.fromSafeConstant(constants.shareable())), all || images || luns || cinder, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnVisible(// $NON-NLS-1$
    DisksViewColumns.diskContainersIconColumn, // $NON-NLS-1$
    "", // $NON-NLS-1$
    all || images || luns || cinder, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnVisible(DisksViewColumns.diskContainersColumn, constants.attachedToDisk(), all || images || luns || cinder, // $NON-NLS-1$
    "125px");
    getTable().ensureColumnVisible(DisksViewColumns.storageDomainsColumn, constants.storageDomainsDisk(), images || cinder, // $NON-NLS-1$
    "180px");
    getTable().ensureColumnVisible(sizeColumn, constants.provisionedSizeDisk(), all || images || luns || cinder, // $NON-NLS-1$
    "110px");
    getTable().ensureColumnVisible(allocationColumn, constants.allocationDisk(), images, // $NON-NLS-1$
    "130px");
    getTable().ensureColumnVisible(cinderVolumeTypeColumn, constants.cinderVolumeTypeDisk(), cinder, // $NON-NLS-1$
    "80px");
    getTable().ensureColumnVisible(dateCreatedColumn, constants.creationDateDisk(), images || cinder, // $NON-NLS-1$
    "130px");
    getTable().ensureColumnVisible(statusColumn, constants.statusDisk(), images || cinder || all, // $NON-NLS-1$
    "80px");
    getTable().ensureColumnVisible(lunIdColumn, constants.lunIdSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnVisible(lunSerialColumn, constants.serialSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnVisible(lunVendorIdColumn, constants.vendorIdSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnVisible(lunProductIdColumn, constants.productIdSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnVisible(qoutaColumn, constants.quotaDisk(), images && isQuotaVisible, // $NON-NLS-1$
    "120px");
    getTable().ensureColumnVisible(diskStorageTypeColumn, constants.typeDisk(), all, // $NON-NLS-1$
    "80px");
    getTable().ensureColumnVisible(descriptionColumn, constants.descriptionDisk(), all || images || luns || cinder, // $NON-NLS-1$
    "90px");
}
#method_after
void onDiskViewTypeChanged(DiskStorageType diskType) {
    boolean all = diskType == null;
    boolean images = diskType == DiskStorageType.IMAGE;
    boolean luns = diskType == DiskStorageType.LUN;
    boolean cinder = diskType == DiskStorageType.CINDER;
    searchByDiskViewType(disksViewRadioGroup.getDiskStorageType(), disksContentTypeRadioGroup.getDiskContentType());
    getTable().ensureColumnVisible(aliasColumn, constants.aliasDisk(), all || images || luns || cinder, // $NON-NLS-1$
    "150px");
    getTable().ensureColumnVisible(idColumn, constants.idDisk(), all || images || luns || cinder, // $NON-NLS-1$
    "150px");
    getTable().ensureColumnVisible(DisksViewColumns.shareableDiskColumn, new ImageResourceHeader(DisksViewColumns.shareableDiskColumn.getDefaultImage(), SafeHtmlUtils.fromSafeConstant(constants.shareable())), all || images || luns || cinder, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnVisible(// $NON-NLS-1$
    DisksViewColumns.diskContainersIconColumn, // $NON-NLS-1$
    "", // $NON-NLS-1$
    all || images || luns || cinder, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnVisible(DisksViewColumns.diskContainersColumn, constants.attachedToDisk(), all || images || luns || cinder, // $NON-NLS-1$
    "125px");
    getTable().ensureColumnVisible(DisksViewColumns.storageDomainsColumn, constants.storageDomainsDisk(), images || cinder, // $NON-NLS-1$
    "180px");
    getTable().ensureColumnVisible(sizeColumn, constants.provisionedSizeDisk(), all || images || luns || cinder, // $NON-NLS-1$
    "110px");
    getTable().ensureColumnVisible(allocationColumn, constants.allocationDisk(), images, // $NON-NLS-1$
    "130px");
    getTable().ensureColumnVisible(cinderVolumeTypeColumn, constants.cinderVolumeTypeDisk(), cinder, // $NON-NLS-1$
    "80px");
    getTable().ensureColumnVisible(dateCreatedColumn, constants.creationDateDisk(), images || cinder, // $NON-NLS-1$
    "130px");
    getTable().ensureColumnVisible(statusColumn, constants.statusDisk(), images || cinder || all, // $NON-NLS-1$
    "80px");
    getTable().ensureColumnVisible(lunIdColumn, constants.lunIdSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnVisible(lunSerialColumn, constants.serialSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnVisible(lunVendorIdColumn, constants.vendorIdSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnVisible(lunProductIdColumn, constants.productIdSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnVisible(qoutaColumn, constants.quotaDisk(), images && isQuotaVisible, // $NON-NLS-1$
    "120px");
    getTable().ensureColumnVisible(diskStorageTypeColumn, constants.typeDisk(), all, // $NON-NLS-1$
    "80px");
    getTable().ensureColumnVisible(descriptionColumn, constants.descriptionDisk(), all || images || luns || cinder, // $NON-NLS-1$
    "90px");
}
#end_block

#method_before
void initTableOverhead() {
    disksViewRadioGroup = new DisksViewRadioGroup();
    disksViewRadioGroup.setClickHandler(clickHandler);
    disksContentTypeRadioGroup = new DisksContentTypeRadioGroup();
    disksContentTypeRadioGroup.setClickHandler(event -> {
        if (((RadioButton) event.getSource()).getValue()) {
            getMainModel().getDiskContentType().setEntity(disksContentTypeRadioGroup.getDiskContentType());
        }
    });
    HorizontalPanel overheadPanel = new HorizontalPanel();
    overheadPanel.add(disksViewRadioGroup);
    overheadPanel.add(disksContentTypeRadioGroup);
    getTable().setTableOverhead(overheadPanel);
}
#method_after
void initTableOverhead() {
    disksViewRadioGroup = new DisksViewRadioGroup();
    disksViewRadioGroup.addChangeHandler(diskViewTypeChange);
    disksContentTypeRadioGroup = new DisksContentTypeRadioGroup();
    disksContentTypeRadioGroup.addChangeHandler(diskContentViewTypeChange);
    FlowPanel overheadPanel = new FlowPanel();
    overheadPanel.add(disksViewRadioGroup);
    overheadPanel.add(disksContentTypeRadioGroup);
    getTable().setTableOverhead(overheadPanel);
}
#end_block

#method_before
private Widget getRadioGroupPanel() {
    buttonToType = new LinkedHashMap<>();
    // $NON-NLS-1$
    RadioButton allButton = new RadioButton("diskContentTypeView");
    buttonToType.put(allButton, null);
    allButton.setText(constants.allDisksLabel());
    for (DiskContentType contentType : DiskContentType.values()) {
        // $NON-NLS-1$
        RadioButton button = new RadioButton("diskContentTypeView");
        buttonToType.put(button, contentType);
    }
    FlowPanel buttonsPanel = new FlowPanel();
    // $NON-NLS-1$ //$NON-NLS-2$
    buttonsPanel.getElement().getStyle().setProperty("marginLeft", "auto");
    // $NON-NLS-1$ //$NON-NLS-2$
    buttonsPanel.getElement().getStyle().setProperty("marginRight", "auto");
    for (RadioButton button : buttonToType.keySet()) {
        button.getElement().getStyle().setMarginRight(20, Style.Unit.PX);
        buttonsPanel.add(button);
    }
    setDiskContentType(null);
    localize();
    return buttonsPanel;
}
#method_after
private Widget getRadioGroupPanel() {
    buttonToType = new LinkedHashMap<>();
    // $NON-NLS-1$
    RadioButton allButton = new RadioButton(BUTTON_GROUP_NAME);
    buttonToType.put(allButton, null);
    allButton.setText(constants.allDisksLabel());
    for (DiskContentType contentType : DiskContentType.values()) {
        // $NON-NLS-1$
        RadioButton button = new RadioButton(BUTTON_GROUP_NAME);
        buttonToType.put(button, contentType);
    }
    ButtonGroup buttonGroup = new ButtonGroup();
    buttonGroup.setDataToggle(Toggle.BUTTONS);
    buttonToType.entrySet().forEach(e -> {
        buttonGroup.add(e.getKey());
        e.getKey().addClickHandler(event -> fireChangeHandlers(e.getValue()));
    });
    setDiskContentType(null);
    localize();
    // $NON-NLS-1$
    buttonGroup.addStyleName("disk-type-buttons-group");
    return buttonGroup;
}
#end_block

#method_before
private Widget getRadioGroupPanel() {
    // $NON-NLS-1$
    allButton = new RadioButton("diskTypeView");
    // $NON-NLS-1$
    imagesButton = new RadioButton("diskTypeView");
    // $NON-NLS-1$
    lunsButton = new RadioButton("diskTypeView");
    // $NON-NLS-1$
    cinderButton = new RadioButton("diskTypeView");
    allButton.getElement().getStyle().setMarginRight(20, Unit.PX);
    imagesButton.getElement().getStyle().setMarginRight(20, Unit.PX);
    lunsButton.getElement().getStyle().setMarginRight(20, Unit.PX);
    cinderButton.getElement().getStyle().setMarginRight(20, Unit.PX);
    FlowPanel buttonsPanel = new FlowPanel();
    // $NON-NLS-1$ //$NON-NLS-2$
    buttonsPanel.getElement().getStyle().setProperty("marginLeft", "auto");
    // $NON-NLS-1$ //$NON-NLS-2$
    buttonsPanel.getElement().getStyle().setProperty("marginRight", "auto");
    buttonsPanel.add(allButton);
    buttonsPanel.add(imagesButton);
    buttonsPanel.add(lunsButton);
    buttonsPanel.add(cinderButton);
    setDiskStorageType(null);
    localize();
    return buttonsPanel;
}
#method_after
private Widget getRadioGroupPanel() {
    allButton = new RadioButton(GROUP_NAME);
    allButton.setText(constants.allDisksLabel());
    allButton.setActive(true);
    allButton.addClickHandler(event -> fireChangeHandlers(null));
    imagesButton = new RadioButton(GROUP_NAME);
    imagesButton.setText(constants.imageDisksLabel());
    imagesButton.addClickHandler(event -> fireChangeHandlers(DiskStorageType.IMAGE));
    lunsButton = new RadioButton(GROUP_NAME);
    lunsButton.setText(constants.lunDisksLabel());
    lunsButton.addClickHandler(event -> fireChangeHandlers(DiskStorageType.LUN));
    cinderButton = new RadioButton(GROUP_NAME);
    cinderButton.setText(constants.cinderDisksLabel());
    cinderButton.addClickHandler(event -> fireChangeHandlers(DiskStorageType.CINDER));
    ButtonGroup buttonGroup = new ButtonGroup();
    buttonGroup.setDataToggle(Toggle.BUTTONS);
    buttonGroup.add(allButton);
    buttonGroup.add(imagesButton);
    buttonGroup.add(lunsButton);
    buttonGroup.add(cinderButton);
    // $NON-NLS-1$
    buttonGroup.addStyleName("disk-type-buttons-group");
    return buttonGroup;
}
#end_block

#method_before
private void handleFinalizingSuccess(final StateContext context) {
    log.info("Finalizing successful transfer for {}", getTransferDescription());
    // If stopping the session did not succeed, don't change the transfer state.
    if (stopImageTransferSession(context.entity)) {
        // Verify image is relevant only on upload
        if (getParameters().getTransferType() == TransferType.Download) {
            unLockImage();
            updateEntityPhase(ImageTransferPhase.FINISHED_SUCCESS);
            return;
        }
        // We want to use the transferring vds for image actions for having a coherent log when transferring.
        Guid transferingVdsId = context.entity.getVdsId();
        if (verifyImage(transferingVdsId)) {
            setVolumeLegalityInStorage(LEGAL_IMAGE);
            if (getImage().getVolumeFormat().equals(VolumeFormat.COW)) {
                setQcowCompat(getImage().getImage(), getStoragePool().getId(), getImage().getImage().getDiskId(), getImage().getImageId(), getStorageDomainId(), transferingVdsId);
                imageDao.update(getImage().getImage());
            }
            unLockImage();
            updateEntityPhase(ImageTransferPhase.FINISHED_SUCCESS);
        } else {
            setImageStatus(ImageStatus.ILLEGAL);
            updateEntityPhase(ImageTransferPhase.FINALIZING_FAILURE);
        }
        // Finished using the image, tear it down.
        tearDownImage(context.entity.getVdsId());
    }
}
#method_after
private void handleFinalizingSuccess(final StateContext context) {
    log.info("Finalizing successful transfer for {}", getTransferDescription());
    // If stopping the session did not succeed, don't change the transfer state.
    if (stopImageTransferSession(context.entity)) {
        Guid transferingVdsId = context.entity.getVdsId();
        // Verify image is relevant only on upload
        if (getParameters().getTransferType() == TransferType.Download) {
            unLockImage();
            updateEntityPhase(ImageTransferPhase.FINISHED_SUCCESS);
        } else // We want to use the transferring vds for image actions for having a coherent log when transferring.
        if (verifyImage(transferingVdsId)) {
            setVolumeLegalityInStorage(LEGAL_IMAGE);
            if (getImage().getVolumeFormat().equals(VolumeFormat.COW)) {
                setQcowCompat(getImage().getImage(), getStoragePool().getId(), getImage().getImage().getDiskId(), getImage().getImageId(), getStorageDomainId(), transferingVdsId);
                imageDao.update(getImage().getImage());
            }
            unLockImage();
            updateEntityPhase(ImageTransferPhase.FINISHED_SUCCESS);
        } else {
            setImageStatus(ImageStatus.ILLEGAL);
            updateEntityPhase(ImageTransferPhase.FINALIZING_FAILURE);
        }
        // Finished using the image, tear it down.
        tearDownImage(context.entity.getVdsId());
    }
}
#end_block

#method_before
private void registerHandlers() {
    model.getPropertyChangedEvent().addListener((ev, sender, args) -> {
        String propName = args.propertyName;
        if ("Window".equals(propName) && model.getWindow() == null) {
            // $NON-NLS-1$
            if (model.getSpecificClusterQuota().getEntity()) {
                quotaClusterTable.asEditor().edit(model.getAllDataCenterClusters());
            } else {
                quotaClusterTable.asEditor().edit(model.getQuotaClusters());
            }
            if (model.getSpecificStorageQuota().getEntity()) {
                quotaStorageTable.asEditor().edit(model.getAllDataCenterStorages());
            } else {
                quotaStorageTable.asEditor().edit(model.getQuotaStorages());
            }
        }
    });
    model.getSpecificClusterQuota().getEntityChangedEvent().addListener((ev, sender, args) -> {
        if (model.getSpecificClusterQuota().getEntity()) {
            quotaClusterTable.insertColumn(0, isClusterInQuotaColumn);
            // $NON-NLS-1$
            quotaClusterTable.setColumnWidth(isClusterInQuotaColumn, "30px");
            quotaClusterTable.asEditor().edit(model.getAllDataCenterClusters());
        } else {
            quotaClusterTable.removeColumn(isClusterInQuotaColumn);
            quotaClusterTable.asEditor().edit(model.getQuotaClusters());
        }
    });
    model.getSpecificStorageQuota().getEntityChangedEvent().addListener((ev, sender, args) -> {
        if (model.getSpecificStorageQuota().getEntity()) {
            quotaStorageTable.insertColumn(0, isStorageInQuotaColumn);
            // $NON-NLS-1$
            quotaStorageTable.setColumnWidth(isStorageInQuotaColumn, "30px");
            quotaStorageTable.asEditor().edit(model.getAllDataCenterStorages());
        } else {
            quotaStorageTable.removeColumn(isStorageInQuotaColumn);
            quotaStorageTable.asEditor().edit(model.getQuotaStorages());
        }
    });
}
#method_after
private void registerHandlers() {
    model.getPropertyChangedEvent().addListener((ev, sender, args) -> {
        String propName = args.propertyName;
        if (Model.PROP_WINDOW.equals(propName) && model.getWindow() == null) {
            if (model.getSpecificClusterQuota().getEntity()) {
                quotaClusterTable.asEditor().edit(model.getAllDataCenterClusters());
            } else {
                quotaClusterTable.asEditor().edit(model.getQuotaClusters());
            }
            if (model.getSpecificStorageQuota().getEntity()) {
                quotaStorageTable.asEditor().edit(model.getAllDataCenterStorages());
            } else {
                quotaStorageTable.asEditor().edit(model.getQuotaStorages());
            }
        }
    });
    model.getSpecificClusterQuota().getEntityChangedEvent().addListener((ev, sender, args) -> {
        if (model.getSpecificClusterQuota().getEntity()) {
            quotaClusterTable.insertColumn(0, isClusterInQuotaColumn);
            // $NON-NLS-1$
            quotaClusterTable.setColumnWidth(isClusterInQuotaColumn, "30px");
            quotaClusterTable.asEditor().edit(model.getAllDataCenterClusters());
        } else {
            quotaClusterTable.removeColumn(isClusterInQuotaColumn);
            quotaClusterTable.asEditor().edit(model.getQuotaClusters());
        }
    });
    model.getSpecificStorageQuota().getEntityChangedEvent().addListener((ev, sender, args) -> {
        if (model.getSpecificStorageQuota().getEntity()) {
            quotaStorageTable.insertColumn(0, isStorageInQuotaColumn);
            // $NON-NLS-1$
            quotaStorageTable.setColumnWidth(isStorageInQuotaColumn, "30px");
            quotaStorageTable.asEditor().edit(model.getAllDataCenterStorages());
        } else {
            quotaStorageTable.removeColumn(isStorageInQuotaColumn);
            quotaStorageTable.asEditor().edit(model.getQuotaStorages());
        }
    });
}
#end_block

#method_before
private void updateProperties() {
    Disk disk = getEntity();
    setImage(disk.getDiskStorageType().isInternal());
    setLun(disk.getDiskStorageType() == DiskStorageType.LUN);
    setAlias(disk.getDiskAlias());
    setDescription(disk.getDiskDescription());
    setDiskId(disk.getId().toString());
    if (disk.getLastAlignmentScan() != null) {
        String lastScanDate = DateTimeFormat.getFormat("yyyy-MM-dd, HH:mm").format(// $NON-NLS-1$
        disk.getLastAlignmentScan());
        setAlignment(ConstantsManager.getInstance().getMessages().diskAlignment(disk.getAlignment().toString(), lastScanDate));
    } else {
        setAlignment(disk.getAlignment().toString());
    }
    setWipeAfterDelete(disk.isWipeAfterDelete());
    if (isImage()) {
        DiskImage diskImage = (DiskImage) disk;
        setDiskProfileName(safeJoin(diskImage.getDiskProfileNames()));
        setQuotaName(safeJoin(diskImage.getQuotaNames()));
        setQuotaAvailable(!diskImage.getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED));
    } else if (isLun()) {
        LunDisk lunDisk = (LunDisk) disk;
        setLunId(lunDisk.getLun().getLUNId());
    }
}
#method_after
private void updateProperties() {
    Disk disk = getEntity();
    setImage(disk.getDiskStorageType().isInternal());
    setLun(disk.getDiskStorageType() == DiskStorageType.LUN);
    setAlias(disk.getDiskAlias());
    setDescription(disk.getDiskDescription());
    setDiskId(disk.getId().toString());
    if (disk.getLastAlignmentScan() != null) {
        String lastScanDate = DateTimeFormat.getFormat("yyyy-MM-dd, HH:mm").format(// $NON-NLS-1$
        disk.getLastAlignmentScan());
        setAlignment(ConstantsManager.getInstance().getMessages().diskAlignment(disk.getAlignment().toString(), lastScanDate));
    } else {
        setAlignment(disk.getAlignment().toString());
    }
    setWipeAfterDelete(disk.isWipeAfterDelete());
    if (isImage()) {
        DiskImage diskImage = (DiskImage) disk;
        // $NON-NLS-1$
        setDiskProfileName(StringHelper.nullSafeJoin(",", diskImage.getDiskProfileNames()));
        // $NON-NLS-1$
        setQuotaName(StringHelper.nullSafeJoin(",", diskImage.getQuotaNames()));
        setQuotaAvailable(!diskImage.getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED));
    } else if (isLun()) {
        LunDisk lunDisk = (LunDisk) disk;
        setLunId(lunDisk.getLun().getLUNId());
    }
}
#end_block

#method_before
protected void addStackedDetailItem(SafeHtml label, String value, DListElement parent) {
    // $NON-NLS-1$
    Element dt = Document.get().createElement("dt");
    // $NON-NLS-1$
    dt.setInnerSafeHtml(label);
    parent.appendChild(dt);
    dt.getStyle().setFloat(Style.Float.LEFT);
    dt.getStyle().setPaddingRight(5, Unit.PX);
    // $NON-NLS-1$
    Element dd = Document.get().createElement("dd");
    dd.setInnerText(value);
    parent.appendChild(dd);
}
#method_after
protected void addStackedDetailItem(SafeHtml label, String value, DListElement parent) {
    // $NON-NLS-1$
    Element dt = Document.get().createElement("dt");
    // $NON-NLS-1$
    dt.setInnerSafeHtml(label);
    parent.appendChild(dt);
    dt.addClassName(STACKED_DETAIL_ITEM);
    dt.getStyle().setFloat(Style.Float.LEFT);
    dt.getStyle().setPaddingRight(5, Unit.PX);
    // $NON-NLS-1$
    Element dd = Document.get().createElement("dd");
    dd.setInnerText(value);
    parent.appendChild(dd);
}
#end_block

#method_before
@Override
public void onClick(ClickEvent event) {
    ExpandableListViewItem eventItem = null;
    if (event.getSource() instanceof ExpandableListViewItem) {
        eventItem = (ExpandableListViewItem) event.getSource();
    }
    if (eventItem != null) {
        boolean active = eventItem.isActive();
        // Hide all, then unhide the one clicked.
        hideAllDetails();
        eventItem.toggleExpanded(!active);
        toggleExpanded();
    } else {
        // Clicked a close icon
        hideAllDetails();
    }
    event.preventDefault();
    event.stopPropagation();
}
#method_after
@Override
public void onClick(ClickEvent event) {
    event.preventDefault();
    event.stopPropagation();
    ExpandableListViewItem eventItem = null;
    if (event.getSource() instanceof ExpandableListViewItem) {
        eventItem = (ExpandableListViewItem) event.getSource();
    }
    if (eventItem != null) {
        boolean active = eventItem.isActive();
        // Hide all, then unhide the one clicked.
        hideAllDetails();
        eventItem.toggleExpanded(!active);
        toggleExpanded();
    } else {
        // Clicked a close icon
        hideAllDetails();
    }
}
#end_block

#method_before
protected ColumnSize calculateColSize(int itemCount) {
    if (itemCount == 3) {
        return ColumnSize.MD_2;
    }
    return ColumnSize.MD_3;
}
#method_after
protected ColumnSize calculateColSize(int index) {
    // For index 3 return 2 so we have enough room for the X.
    if (index == 3) {
        return ColumnSize.MD_2;
    }
    return ColumnSize.MD_3;
}
#end_block

#method_before
@Override
public void restoreStateFromViewItem(PatternflyListViewItem<HostInterfaceLineModel> originalViewItem) {
    super.restoreStateFromViewItem(originalViewItem);
    // from it into a bonded interface will not work.
    if (originalViewItem instanceof HostNetworkInterfaceBondedListViewItem) {
        HostNetworkInterfaceBondedListViewItem original = (HostNetworkInterfaceBondedListViewItem) originalViewItem;
        setSlavesExpanded(original.getSlavesState());
    }
}
#method_after
@Override
public void restoreStateFromViewItem(PatternflyListViewItem<HostInterfaceLineModel> originalViewItem) {
    super.restoreStateFromViewItem(originalViewItem);
    // from it into a bonded interface will not work.
    if (originalViewItem instanceof HostNetworkInterfaceBondedListViewItem) {
        setSlavesExpanded(((HostNetworkInterfaceBondedListViewItem) originalViewItem).getSlavesState());
    }
}
#end_block

#method_before
@Override
protected IsWidget createIcon() {
    InterfaceStatus interfaceStatus = getEntity().getInterface().getStatistics().getStatus();
    SafeHtml bondPropertiesMessage = createBondTooltipMessage(getEntity(), interfaceStatus);
    SafeHtml bondMessage = templates.italicWordWrapMaxWidthWithBoldTitle(constants.bondProperties(), bondPropertiesMessage);
    WidgetTooltip iconTooltip = new WidgetTooltip(new BondedNetworkIcon(getEntity()));
    iconTooltip.setHtml(bondMessage);
    iconPanel.add(iconTooltip);
    return iconPanel;
}
#method_after
@Override
protected IsWidget createIcon() {
    InterfaceStatus interfaceStatus = getEntity().getInterface().getStatistics().getStatus();
    SafeHtml bondPropertiesMessage = createBondTooltipMessage(getEntity(), interfaceStatus);
    SafeHtml bondMessage = templates.italicWordWrapMaxWidthWithBoldTitle(constants.bondProperties(), bondPropertiesMessage);
    WidgetTooltip iconTooltip = new WidgetTooltip(new BondedNetworkIcon());
    iconTooltip.setHtml(bondMessage);
    iconPanel.add(iconTooltip);
    return iconPanel;
}
#end_block

#method_before
private String createActiveBondTooltipMessage(Bond bond, HostInterfaceLineModel lineModel) {
    List<String> bondProperties = new ArrayList<>();
    String adPartnerMac = Objects.toString(bond.getAdPartnerMac(), "");
    bondProperties.add(messages.bondAdPartnerMac(adPartnerMac));
    String adAggregatorId = Objects.toString(bond.getAdAggregatorId(), "");
    bondProperties.add(messages.bondAdAggregatorId(adAggregatorId));
    for (HostInterface nic : lineModel.getInterfaces()) {
        String nicName = nic.getName();
        String nicAggregatorId = Objects.toString(nic.getInterface().getAdAggregatorId(), "");
        bondProperties.add(messages.bondSlaveAdAggregatorId(nicName, nicAggregatorId));
    }
    // $NON-NLS-1$
    return StringUtils.join(bondProperties, "\n");
}
#method_after
private String createActiveBondTooltipMessage(Bond bond, HostInterfaceLineModel lineModel) {
    List<String> bondProperties = new ArrayList<>();
    String adPartnerMac = Objects.toString(bond.getAdPartnerMac(), "");
    bondProperties.add(messages.bondAdPartnerMac(adPartnerMac));
    String adAggregatorId = Objects.toString(bond.getAdAggregatorId(), "");
    bondProperties.add(messages.bondAdAggregatorId(adAggregatorId));
    for (HostInterface nic : lineModel.getInterfaces()) {
        String nicName = nic.getName();
        String nicAggregatorId = Objects.toString(nic.getInterface().getAdAggregatorId(), "");
        bondProperties.add(messages.bondSlaveAdAggregatorId(nicName, nicAggregatorId));
    }
    // $NON-NLS-1$
    return String.join("\n", bondProperties);
}
#end_block

#method_before
@Override
public void restoreStateFromViewItem(PatternflyListViewItem<HostInterfaceLineModel> originalViewItem) {
    if (originalViewItem instanceof HostNetworkInterfaceListViewItem) {
        HostNetworkInterfaceListViewItem original = (HostNetworkInterfaceListViewItem) originalViewItem;
        setLogicalNetworkExpanded(original.getLogicalNetworkState());
    }
}
#method_after
@Override
public void restoreStateFromViewItem(PatternflyListViewItem<HostInterfaceLineModel> originalViewItem) {
    if (originalViewItem instanceof HostNetworkInterfaceListViewItem) {
        setLogicalNetworkExpanded(((HostNetworkInterfaceListViewItem) originalViewItem).getLogicalNetworkState());
    }
}
#end_block

#method_before
private IsWidget createRxColumn(HostInterface hostInterface) {
    Column rxCol = new Column(ColumnSize.SM_3);
    DListElement dl = Document.get().createDLElement();
    addReverseDetailItem(templates.sub(constants.rxRate(), constants.mbps()), rateRenderer.render(new Double[] { hostInterface.getRxRate(), hostInterface.getSpeed().doubleValue() }), dl);
    dl.getStyle().setFloat(Style.Float.LEFT);
    rxCol.getElement().appendChild(dl);
    FlowPanel divider = new FlowPanel();
    divider.addStyleName(RATE_DIVIDER);
    rxCol.add(divider);
    dl = Document.get().createDLElement();
    addReverseDetailItem(templates.sub(constants.rxTotal(), constants.bytes()), hostInterface.getRxTotal() != null ? String.valueOf(hostInterface.getRxTotal()) : constants.notAvailableLabel(), dl);
    dl.getStyle().setFloat(Style.Float.LEFT);
    rxCol.getElement().appendChild(dl);
    return rxCol;
}
#method_after
private IsWidget createRxColumn(HostInterface hostInterface) {
    Column rxCol = new Column(ColumnSize.SM_3);
    DListElement dl = Document.get().createDLElement();
    addReverseDetailItem(templates.sub(constants.rxRate(), constants.mbps()), rateRenderer.render(new Double[] { hostInterface.getRxRate(), hostInterface.getSpeed().doubleValue() }), dl);
    dl.addClassName(Styles.PULL_LEFT);
    rxCol.getElement().appendChild(dl);
    FlowPanel divider = new FlowPanel();
    divider.addStyleName(RATE_DIVIDER);
    rxCol.add(divider);
    dl = Document.get().createDLElement();
    addReverseDetailItem(templates.sub(constants.rxTotal(), constants.bytes()), hostInterface.getRxTotal() != null ? String.valueOf(hostInterface.getRxTotal()) : constants.notAvailableLabel(), dl);
    dl.addClassName(Styles.PULL_LEFT);
    rxCol.getElement().appendChild(dl);
    return rxCol;
}
#end_block

#method_before
private IsWidget createTxColumn(HostInterface hostInterface) {
    Column txCol = new Column(ColumnSize.SM_3);
    DListElement dl = Document.get().createDLElement();
    addReverseDetailItem(templates.sub(constants.txRate(), constants.mbps()), rateRenderer.render(new Double[] { hostInterface.getTxRate(), hostInterface.getSpeed().doubleValue() }), dl);
    dl.getStyle().setFloat(Style.Float.LEFT);
    txCol.getElement().appendChild(dl);
    FlowPanel divider = new FlowPanel();
    divider.addStyleName(RATE_DIVIDER);
    txCol.add(divider);
    dl = Document.get().createDLElement();
    addReverseDetailItem(templates.sub(constants.txTotal(), constants.bytes()), hostInterface.getTxTotal() != null ? String.valueOf(hostInterface.getTxTotal()) : constants.notAvailableLabel(), dl);
    dl.getStyle().setFloat(Style.Float.LEFT);
    txCol.getElement().appendChild(dl);
    return txCol;
}
#method_after
private IsWidget createTxColumn(HostInterface hostInterface) {
    Column txCol = new Column(ColumnSize.SM_3);
    DListElement dl = Document.get().createDLElement();
    addReverseDetailItem(templates.sub(constants.txRate(), constants.mbps()), rateRenderer.render(new Double[] { hostInterface.getTxRate(), hostInterface.getSpeed().doubleValue() }), dl);
    dl.addClassName(Styles.PULL_LEFT);
    txCol.getElement().appendChild(dl);
    FlowPanel divider = new FlowPanel();
    divider.addStyleName(RATE_DIVIDER);
    txCol.add(divider);
    dl = Document.get().createDLElement();
    addReverseDetailItem(templates.sub(constants.txTotal(), constants.bytes()), hostInterface.getTxTotal() != null ? String.valueOf(hostInterface.getTxTotal()) : constants.notAvailableLabel(), dl);
    dl.addClassName(Styles.PULL_LEFT);
    txCol.getElement().appendChild(dl);
    return txCol;
}
#end_block

#method_before
private List<HostVLan> calculateLogicalNetworks(HostInterfaceLineModel entity) {
    List<HostVLan> logicalNetworks = new ArrayList<>();
    VdsNetworkInterface mainInterface = getNetworkInterface();
    if (!StringUtils.isEmpty(mainInterface.getNetworkName())) {
        HostVLan main = new HostVLan();
        main.setInterface(mainInterface);
        main.setNetworkName(mainInterface.getNetworkName());
        main.setIpv4Address(mainInterface.getIpv4Address());
        main.setIpv6Address(mainInterface.getIpv6Address());
        logicalNetworks.add(main);
    }
    if (entity.getVLans() != null) {
        logicalNetworks.addAll(entity.getVLans());
    }
    return logicalNetworks;
}
#method_after
private List<HostVLan> calculateLogicalNetworks(HostInterfaceLineModel entity) {
    List<HostVLan> logicalNetworks = new ArrayList<>();
    VdsNetworkInterface mainInterface = getNetworkInterface();
    if (mainInterface != null && mainInterface.getNetworkName() != null && !mainInterface.getNetworkName().isEmpty()) {
        HostVLan main = new HostVLan();
        main.setInterface(mainInterface);
        main.setNetworkName(mainInterface.getNetworkName());
        main.setIpv4Address(mainInterface.getIpv4Address());
        main.setIpv6Address(mainInterface.getIpv6Address());
        logicalNetworks.add(main);
    }
    if (entity.getVLans() != null) {
        logicalNetworks.addAll(entity.getVLans());
    }
    return logicalNetworks;
}
#end_block

#method_before
private Container createLogicalNetworkContainer() {
    List<HostVLan> logicalNetworks = calculateLogicalNetworks(getEntity());
    Row content = new Row();
    Column gridColumn = new Column(ColumnSize.SM_12);
    content.add(gridColumn);
    Container container = createItemContainerPanel(content);
    CellTable<HostVLan> logicalNetworkTable = new CellTable<>(MAX_LOGICAL_NETWORKS, (Resources) GWT.create(PopupTableResources.class));
    // $NON-NLS-1$
    logicalNetworkTable.getElement().addClassName("table");
    // $NON-NLS-1$
    logicalNetworkTable.getElement().addClassName("table-striped");
    // $NON-NLS-1$
    logicalNetworkTable.getElement().addClassName("table-bordered");
    ListDataProvider<HostVLan> logicalNetworkDataProvider = new ListDataProvider<>();
    logicalNetworkDataProvider.setList(logicalNetworks);
    logicalNetworkDataProvider.addDataDisplay(logicalNetworkTable);
    final HostVLanNameRenderer renderer = new HostVLanNameRenderer();
    // Setup columns
    AbstractIconTypeColumn<HostVLan> management = new AbstractIconTypeColumn<HostVLan>() {

        @Override
        public IconType getValue(HostVLan logicalNetwork) {
            if (logicalNetwork.getInterface() != null && logicalNetwork.getInterface().getIsManagement()) {
                return IconType.INSTITUTION;
            }
            return null;
        }

        @Override
        public SafeHtml getTooltip(HostVLan logicalNetwork) {
            return SafeHtmlUtils.fromSafeConstant(constants.managementNetworkLabel());
        }
    };
    IconTypeHeader managementHeader = new IconTypeHeader(IconType.INSTITUTION, ICON_COLOR, SafeHtmlUtils.fromSafeConstant(constants.managementNetworkLabel()));
    management.getCell().setColor(SafeHtmlUtils.fromSafeConstant(ICON_COLOR));
    logicalNetworkTable.addColumn(management, managementHeader);
    // $NON-NLS-1$
    logicalNetworkTable.setColumnWidth(management, "40px");
    AbstractIconTypeColumn<HostVLan> sync = new AbstractIconTypeColumn<HostVLan>() {

        @Override
        public IconType getValue(HostVLan logicalNetwork) {
            if (logicalNetwork != null && logicalNetwork.getInterface() != null && isOutOfSync(logicalNetwork.getInterface().getNetworkImplementationDetails())) {
                return IconType.CHAIN_BROKEN;
            }
            return null;
        }

        @Override
        public SafeHtml getTooltip(HostVLan logicalNetwork) {
            return SafeHtmlUtils.fromSafeConstant(constants.hostOutOfSync());
        }
    };
    IconTypeHeader syncHeader = new IconTypeHeader(IconType.CHAIN_BROKEN, ICON_COLOR, SafeHtmlUtils.fromSafeConstant(constants.hostOutOfSync()));
    sync.getCell().setColor(SafeHtmlUtils.fromSafeConstant(RED));
    logicalNetworkTable.addColumn(sync, syncHeader);
    // $NON-NLS-1$
    logicalNetworkTable.setColumnWidth(sync, "40px");
    TextColumn<HostVLan> vlan = new TextColumn<HostVLan>() {

        @Override
        public String getValue(HostVLan logicalNetwork) {
            if (StringUtils.isEmpty(logicalNetwork.getName())) {
                // $NON-NLS-1$
                return "";
            }
            return renderer.render(logicalNetwork);
        }
    };
    // $NON-NLS-1$
    logicalNetworkTable.setColumnWidth(vlan, "175px");
    logicalNetworkTable.addColumn(vlan, constants.vlanInterface());
    TextColumn<HostVLan> networkName = new TextColumn<HostVLan>() {

        @Override
        public String getValue(HostVLan logicalNetwork) {
            return logicalNetwork.getNetworkName();
        }
    };
    // $NON-NLS-1$
    logicalNetworkTable.setColumnWidth(networkName, "175px");
    logicalNetworkTable.addColumn(networkName, constants.networkNameInterface());
    TextColumn<HostVLan> ipv4 = new TextColumn<HostVLan>() {

        @Override
        public String getValue(HostVLan logicalNetwork) {
            return logicalNetwork.getIpv4Address() != null ? logicalNetwork.getIpv4Address() : "";
        }
    };
    // $NON-NLS-1$
    logicalNetworkTable.setColumnWidth(ipv4, "175px");
    logicalNetworkTable.addColumn(ipv4, constants.ipv4AddressInterface());
    TextColumn<HostVLan> ipv6 = new TextColumn<HostVLan>() {

        @Override
        public String getValue(HostVLan logicalNetwork) {
            return logicalNetwork.getIpv6Address() != null ? logicalNetwork.getIpv6Address() : "";
        }
    };
    // $NON-NLS-1$
    logicalNetworkTable.setColumnWidth(ipv6, "175px");
    logicalNetworkTable.addColumn(ipv6, constants.ipv6AddressInterface());
    TextColumn<HostVLan> emptyTail = new TextColumn<HostVLan>() {

        @Override
        public String getValue(HostVLan logicalNetwork) {
            return "";
        }
    };
    logicalNetworkTable.addColumn(emptyTail, "");
    gridColumn.add(logicalNetworkTable);
    return container;
}
#method_after
private Container createLogicalNetworkContainer() {
    List<HostVLan> logicalNetworks = calculateLogicalNetworks(getEntity());
    Row content = new Row();
    Column gridColumn = new Column(ColumnSize.SM_12);
    content.add(gridColumn);
    Container container = createItemContainerPanel(content);
    CellTable<HostVLan> logicalNetworkTable = new CellTable<>(MAX_LOGICAL_NETWORKS, (Resources) GWT.create(PopupTableResources.class));
    // $NON-NLS-1$
    logicalNetworkTable.getElement().addClassName("table");
    // $NON-NLS-1$
    logicalNetworkTable.getElement().addClassName("table-striped");
    // $NON-NLS-1$
    logicalNetworkTable.getElement().addClassName("table-bordered");
    ListDataProvider<HostVLan> logicalNetworkDataProvider = new ListDataProvider<>();
    logicalNetworkDataProvider.setList(logicalNetworks);
    logicalNetworkDataProvider.addDataDisplay(logicalNetworkTable);
    final HostVLanNameRenderer renderer = new HostVLanNameRenderer();
    // Setup columns
    AbstractIconTypeColumn<HostVLan> management = new AbstractIconTypeColumn<HostVLan>() {

        @Override
        public IconType getValue(HostVLan logicalNetwork) {
            if (logicalNetwork.getInterface() != null && logicalNetwork.getInterface().getIsManagement()) {
                return IconType.INSTITUTION;
            }
            return null;
        }

        @Override
        public SafeHtml getTooltip(HostVLan logicalNetwork) {
            return SafeHtmlUtils.fromSafeConstant(constants.managementNetworkLabel());
        }
    };
    IconTypeHeader managementHeader = new IconTypeHeader(IconType.INSTITUTION, ICON_COLOR, SafeHtmlUtils.fromSafeConstant(constants.managementNetworkLabel()));
    management.getCell().setColor(SafeHtmlUtils.fromSafeConstant(ICON_COLOR));
    logicalNetworkTable.addColumn(management, managementHeader);
    // $NON-NLS-1$
    logicalNetworkTable.setColumnWidth(management, "40px");
    AbstractIconTypeColumn<HostVLan> sync = new AbstractIconTypeColumn<HostVLan>() {

        @Override
        public IconType getValue(HostVLan logicalNetwork) {
            if (logicalNetwork != null && logicalNetwork.getInterface() != null && isOutOfSync(logicalNetwork.getInterface().getNetworkImplementationDetails())) {
                return IconType.CHAIN_BROKEN;
            }
            return null;
        }

        @Override
        public SafeHtml getTooltip(HostVLan logicalNetwork) {
            return SafeHtmlUtils.fromSafeConstant(constants.hostOutOfSync());
        }
    };
    IconTypeHeader syncHeader = new IconTypeHeader(IconType.CHAIN_BROKEN, ICON_COLOR, SafeHtmlUtils.fromSafeConstant(constants.hostOutOfSync()));
    sync.getCell().setColor(SafeHtmlUtils.fromSafeConstant(RED));
    logicalNetworkTable.addColumn(sync, syncHeader);
    // $NON-NLS-1$
    logicalNetworkTable.setColumnWidth(sync, "40px");
    TextColumn<HostVLan> vlan = new TextColumn<HostVLan>() {

        @Override
        public String getValue(HostVLan logicalNetwork) {
            if (logicalNetwork == null || logicalNetwork.getName() == null || logicalNetwork.getName().isEmpty()) {
                return "";
            }
            return renderer.render(logicalNetwork);
        }
    };
    // $NON-NLS-1$
    logicalNetworkTable.setColumnWidth(vlan, "175px");
    logicalNetworkTable.addColumn(vlan, constants.vlanInterface());
    TextColumn<HostVLan> networkName = new TextColumn<HostVLan>() {

        @Override
        public String getValue(HostVLan logicalNetwork) {
            return logicalNetwork.getNetworkName();
        }
    };
    // $NON-NLS-1$
    logicalNetworkTable.setColumnWidth(networkName, "175px");
    logicalNetworkTable.addColumn(networkName, constants.networkNameInterface());
    TextColumn<HostVLan> ipv4 = new TextColumn<HostVLan>() {

        @Override
        public String getValue(HostVLan logicalNetwork) {
            return logicalNetwork.getIpv4Address() != null ? logicalNetwork.getIpv4Address() : "";
        }
    };
    // $NON-NLS-1$
    logicalNetworkTable.setColumnWidth(ipv4, "175px");
    logicalNetworkTable.addColumn(ipv4, constants.ipv4AddressInterface());
    TextColumn<HostVLan> ipv6 = new TextColumn<HostVLan>() {

        @Override
        public String getValue(HostVLan logicalNetwork) {
            return logicalNetwork.getIpv6Address() != null ? logicalNetwork.getIpv6Address() : "";
        }
    };
    // $NON-NLS-1$
    logicalNetworkTable.setColumnWidth(ipv6, "175px");
    logicalNetworkTable.addColumn(ipv6, constants.ipv6AddressInterface());
    TextColumn<HostVLan> emptyTail = new TextColumn<HostVLan>() {

        @Override
        public String getValue(HostVLan logicalNetwork) {
            return "";
        }
    };
    logicalNetworkTable.addColumn(emptyTail, "");
    gridColumn.add(logicalNetworkTable);
    return container;
}
#end_block

#method_before
protected IsWidget createHasLabelStatusPanel() {
    IconStatusPanel tagPanel = new IconStatusPanel(IconType.TAG);
    tagPanel.getElement().getStyle().setPaddingLeft(5, Unit.PX);
    WidgetTooltip tooltip = new WidgetTooltip(tagPanel);
    tooltip.setHtml(createLabelTooltipText(getNetworkInterface().getLabels()));
    return tooltip;
}
#method_after
protected IsWidget createHasLabelStatusPanel() {
    IconStatusPanel tagPanel = new IconStatusPanel(IconType.TAG);
    tagPanel.addStyleName(PatternflyConstants.LIST_VIEW_ICON_PANEL);
    WidgetTooltip tooltip = new WidgetTooltip(tagPanel);
    tooltip.setHtml(createLabelTooltipText(getNetworkInterface().getLabels()));
    return tooltip;
}
#end_block

#method_before
private Container createGeneralItemContainerPanel(VmNetworkInterface networkInterface) {
    Row content = new Row();
    Column column = new Column(ColumnSize.MD_12);
    content.add(column);
    DListElement dl = Document.get().createDLElement();
    dl.addClassName(DL_HORIZONTAL);
    addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.plugged()), renderPlugged(networkInterface.isPlugged()), dl);
    addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.networkNameInterface()), networkInterface.getNetworkName(), dl);
    addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.profileNameInterface()), networkInterface.getVnicProfileName(), dl);
    addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.vmNetworkQosName()), StringUtils.isEmpty(networkInterface.getQosName()) ? constants.notAvailableLabel() : networkInterface.getQosName(), dl);
    addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.linkStateNetworkInterface()), renderLinkState(networkInterface.isLinked()), dl);
    addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.typeInterface()), VmInterfaceType.forValue(networkInterface.getType()).getDescription(), dl);
    addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.macInterface()), networkInterface.getMacAddress(), dl);
    addDetailItem(templates.sub(constants.speedInterface(), constants.mbps()), String.valueOf(networkInterface.getSpeed()), dl);
    column.getElement().appendChild(dl);
    return createItemContainerPanel(content);
}
#method_after
private Container createGeneralItemContainerPanel(VmNetworkInterface networkInterface) {
    Row content = new Row();
    Column column = new Column(ColumnSize.MD_12);
    content.add(column);
    DListElement dl = Document.get().createDLElement();
    dl.addClassName(DL_HORIZONTAL);
    addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.plugged()), renderPlugged(networkInterface.isPlugged()), dl);
    addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.networkNameInterface()), networkInterface.getNetworkName(), dl);
    addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.profileNameInterface()), networkInterface.getVnicProfileName(), dl);
    addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.vmNetworkQosName()), StringHelper.isNullOrEmpty(networkInterface.getQosName()) ? constants.notAvailableLabel() : networkInterface.getQosName(), dl);
    addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.linkStateNetworkInterface()), renderLinkState(networkInterface.isLinked()), dl);
    addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.typeInterface()), VmInterfaceType.forValue(networkInterface.getType()).getDescription(), dl);
    addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.macInterface()), networkInterface.getMacAddress(), dl);
    addDetailItem(templates.sub(constants.speedInterface(), constants.mbps()), String.valueOf(networkInterface.getSpeed()), dl);
    column.getElement().appendChild(dl);
    return createItemContainerPanel(content);
}
#end_block

#method_before
private Container createGuestAgentContainerPanel(VmNetworkInterface networkInterface, List<VmGuestAgentInterface> allGuestAgentData) {
    Row content = new Row();
    Column column = new Column(ColumnSize.MD_12);
    content.add(column);
    for (VmGuestAgentInterface guestAgentInterface : allGuestAgentData) {
        if (guestAgentInterface.getMacAddress() != null && guestAgentInterface.getMacAddress().equals(networkInterface.getMacAddress())) {
            DListElement dl = Document.get().createDLElement();
            dl.addClassName(DL_HORIZONTAL);
            addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.nameVmGuestAgent()), guestAgentInterface.getInterfaceName(), dl);
            addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.ipv4VmGuestAgent()), guestAgentInterface.getIpv4Addresses() != null ? String.join(", ", guestAgentInterface.getIpv4Addresses()) : constants.notAvailableLabel(), // $NON-NLS-1$
            dl);
            addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.ipv6VmGuestAgent()), guestAgentInterface.getIpv6Addresses() != null ? String.join(", ", guestAgentInterface.getIpv6Addresses()) : constants.notAvailableLabel(), // $NON-NLS-1$
            dl);
            addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.macVmGuestAgent()), guestAgentInterface.getMacAddress(), dl);
            column.getElement().appendChild(dl);
        }
    }
    if (allGuestAgentData.isEmpty()) {
        Span noDataSpan = new Span();
        noDataSpan.setText(constants.notAvailableLabel());
        column.add(noDataSpan);
    }
    return createItemContainerPanel(content);
}
#method_after
private Container createGuestAgentContainerPanel(VmNetworkInterface networkInterface, List<VmGuestAgentInterface> allGuestAgentData) {
    Row content = new Row();
    Column column = new Column(ColumnSize.MD_12);
    content.add(column);
    for (VmGuestAgentInterface guestAgentInterface : allGuestAgentData) {
        if (guestAgentInterface.getMacAddress() != null && guestAgentInterface.getMacAddress().equals(networkInterface.getMacAddress())) {
            DListElement dl = Document.get().createDLElement();
            dl.addClassName(DL_HORIZONTAL);
            addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.nameVmGuestAgent()), guestAgentInterface.getInterfaceName(), dl);
            addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.ipv4VmGuestAgent()), guestAgentInterface.getIpv4Addresses() != null ? String.join(COMMA_DELIMITOR, guestAgentInterface.getIpv4Addresses()) : constants.notAvailableLabel(), // $NON-NLS-1$
            dl);
            addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.ipv6VmGuestAgent()), guestAgentInterface.getIpv6Addresses() != null ? String.join(COMMA_DELIMITOR, guestAgentInterface.getIpv6Addresses()) : constants.notAvailableLabel(), // $NON-NLS-1$
            dl);
            addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.macVmGuestAgent()), guestAgentInterface.getMacAddress(), dl);
            column.getElement().appendChild(dl);
        }
    }
    if (allGuestAgentData.isEmpty()) {
        Span noDataSpan = new Span();
        noDataSpan.setText(constants.notAvailableLabel());
        column.add(noDataSpan);
    }
    return createItemContainerPanel(content);
}
#end_block

#method_before
@Override
protected IsWidget createBodyPanel(String header, VmNetworkInterface networkInterface) {
    descriptionHeaderPanel.getElement().setInnerHTML(header);
    descriptionHeaderPanel.add(createLinkStatusPanel(networkInterface != null ? networkInterface.isLinked() : false));
    descriptionHeaderPanel.add(createCardPluggedStatusPanel(networkInterface != null ? networkInterface.isPlugged() : false));
    createAdditionalInfoPanel();
    return bodyPanel;
}
#method_after
@Override
protected IsWidget createBodyPanel(String header, VmNetworkInterface networkInterface) {
    checkBoxPanel.add(createLinkStatusPanel(isInterfaceUp(networkInterface)));
    checkBoxPanel.add(createCardPluggedStatusPanel(isCardPlugged(networkInterface)));
    descriptionHeaderPanel.getElement().setInnerText(header);
    createAdditionalInfoPanel();
    return bodyPanel;
}
#end_block

#method_before
protected void addNetworkMainInfo(VmNetworkInterface networkInterface, HasWidgets targetPanel) {
    DListElement dl = Document.get().createDLElement();
    StringBuilder ipv4AddressBuilder = new StringBuilder();
    StringBuilder ipv6AddressBuilder = new StringBuilder();
    FlowPanel infoPanel = new FlowPanel();
    for (VmGuestAgentInterface guestAgentInterface : allGuestAgentData) {
        if (guestAgentInterface.getIpv4Addresses() != null) {
            if (ipv4AddressBuilder.length() != 0) {
                // $NON-NLS-1$
                ipv4AddressBuilder.append(", ");
            }
            ipv4AddressBuilder.append(guestAgentInterface.getIpv4Addresses());
        }
        if (guestAgentInterface.getIpv6Addresses() != null) {
            if (ipv6AddressBuilder.length() != 0) {
                // $NON-NLS-1$
                ipv6AddressBuilder.append(", ");
            }
            ipv6AddressBuilder.append(guestAgentInterface.getIpv6Addresses());
        }
    }
    String ipv4Address;
    if (ipv4AddressBuilder.length() == 0) {
        ipv4Address = constants.notAvailableLabel();
    } else {
        ipv4Address = ipv4AddressBuilder.toString();
    }
    String ipv6Address;
    if (ipv6AddressBuilder.length() == 0) {
        ipv6Address = constants.notAvailableLabel();
    } else {
        ipv6Address = ipv6AddressBuilder.toString();
    }
    addStackedDetailItem(SafeHtmlUtils.fromSafeConstant(constants.networkNameInterface()), networkInterface.getNetworkName() != null ? networkInterface.getNetworkName() : constants.unAvailablePropertyLabel(), dl);
    addStackedDetailItem(SafeHtmlUtils.fromSafeConstant(constants.ipv4VmGuestAgent()), ipv4Address, dl);
    addStackedDetailItem(SafeHtmlUtils.fromSafeConstant(constants.ipv6VmGuestAgent()), ipv6Address, dl);
    addStackedDetailItem(SafeHtmlUtils.fromSafeConstant(constants.macVmGuestAgent()), networkInterface.getMacAddress(), dl);
    infoPanel.getElement().appendChild(dl);
    targetPanel.add(infoPanel);
}
#method_after
protected void addNetworkMainInfo(VmNetworkInterface networkInterface, HasWidgets targetPanel) {
    DListElement dl = Document.get().createDLElement();
    FlowPanel infoPanel = new FlowPanel();
    StringJoiner ipv4AddressJoiner = new StringJoiner(COMMA_DELIMITOR);
    StringJoiner ipv6AddressJoiner = new StringJoiner(COMMA_DELIMITOR);
    for (VmGuestAgentInterface guestAgentInterface : allGuestAgentData) {
        if (guestAgentInterface.getIpv4Addresses() != null) {
            ipv4AddressJoiner.add(String.join(COMMA_DELIMITOR, guestAgentInterface.getIpv4Addresses()));
        }
        if (guestAgentInterface.getIpv6Addresses() != null) {
            ipv6AddressJoiner.add(String.join(COMMA_DELIMITOR, guestAgentInterface.getIpv6Addresses()));
        }
    }
    String ipv4Address = ipv4AddressJoiner.toString();
    if (ipv4Address.isEmpty()) {
        ipv4Address = constants.notAvailableLabel();
    }
    String ipv6Address = ipv6AddressJoiner.toString();
    if (ipv6Address.isEmpty()) {
        ipv6Address = constants.notAvailableLabel();
    }
    addStackedDetailItem(SafeHtmlUtils.fromSafeConstant(constants.networkNameInterface()), networkInterface.getNetworkName() != null ? networkInterface.getNetworkName() : constants.unAvailablePropertyLabel(), dl);
    addStackedDetailItem(SafeHtmlUtils.fromSafeConstant(constants.ipv4VmGuestAgent()), ipv4Address, dl);
    addStackedDetailItem(SafeHtmlUtils.fromSafeConstant(constants.ipv6VmGuestAgent()), ipv6Address, dl);
    addStackedDetailItem(SafeHtmlUtils.fromSafeConstant(constants.macVmGuestAgent()), networkInterface.getMacAddress(), dl);
    infoPanel.getElement().appendChild(dl);
    targetPanel.add(infoPanel);
}
#end_block

#method_before
private IsWidget createLinkStatusPanel(boolean isLinked) {
    return new IconStatusPanel(isLinked ? IconType.ARROW_CIRCLE_O_UP : IconType.ARROW_CIRCLE_O_DOWN);
}
#method_after
private IsWidget createLinkStatusPanel(boolean isLinked) {
    IconStatusPanel iconStatusPanel = new IconStatusPanel(isLinked ? IconType.ARROW_CIRCLE_O_UP : IconType.ARROW_CIRCLE_O_DOWN);
    iconStatusPanel.addStyleName(DOUBLE_SIZE);
    iconStatusPanel.getElement().getStyle().setColor(isLinked ? GREEN : RED);
    return iconStatusPanel;
}
#end_block

#method_before
private IsWidget createCardPluggedStatusPanel(boolean isPlugged) {
    Span linkStatusPanel = new Span();
    Span icon = new Span();
    icon.addStyleName(Styles.ICON_STACK);
    Italic plugItalic = new Italic();
    plugItalic.addStyleName(Styles.FONT_AWESOME_BASE);
    plugItalic.addStyleName(Styles.ICON_STACK_TOP);
    plugItalic.addStyleName(ROTATE_270);
    plugItalic.addStyleName(IconType.PLUG.getCssName());
    icon.add(plugItalic);
    if (!isPlugged) {
        Italic unplugged = new Italic();
        unplugged.addStyleName(Styles.FONT_AWESOME_BASE);
        unplugged.addStyleName(Styles.ICON_STACK_TOP);
        unplugged.addStyleName(DANGER);
        unplugged.addStyleName(IconType.BAN.getCssName());
        icon.add(unplugged);
    }
    linkStatusPanel.add(icon);
    return linkStatusPanel;
}
#method_after
private IsWidget createCardPluggedStatusPanel(boolean isPlugged) {
    Span linkStatusPanel = new Span();
    Span icon = new Span();
    icon.addStyleName(Styles.ICON_STACK);
    Italic plugItalic = new Italic();
    plugItalic.addStyleName(Styles.FONT_AWESOME_BASE);
    plugItalic.addStyleName(Styles.ICON_STACK_TOP);
    plugItalic.addStyleName(ROTATE_270);
    plugItalic.addStyleName(IconType.PLUG.getCssName());
    icon.add(plugItalic);
    if (!isPlugged) {
        Italic unplugged = new Italic();
        unplugged.addStyleName(Styles.FONT_AWESOME_BASE);
        unplugged.addStyleName(Styles.ICON_STACK_TOP);
        unplugged.addStyleName(DANGER);
        unplugged.addStyleName(IconType.BAN.getCssName());
        icon.add(unplugged);
    }
    linkStatusPanel.add(icon);
    linkStatusPanel.addStyleName(DOUBLE_SIZE);
    return linkStatusPanel;
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    bindPresenterWidget(AffinityLabelPopupPresenterWidget.class, AffinityLabelPopupPresenterWidget.ViewDef.class, AffinityLabelPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabEngineErrataPresenter.class, MainTabEngineErrataPresenter.ViewDef.class, MainTabEngineErrataView.class, MainTabEngineErrataPresenter.ProxyDef.class);
    bindPresenter(MainTabSessionPresenter.class, MainTabSessionPresenter.ViewDef.class, MainTabSessionView.class, MainTabSessionPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQosPresenter.class, SubTabDataCenterQosPresenter.ViewDef.class, SubTabDataCenterQosView.class, SubTabDataCenterQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<StoragePool, DataCenterListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<DataCenterListModel>>() {
    }, new TypeLiteral<SearchPanelView<DataCenterListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<StoragePool, DataCenterListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<StoragePool>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<StoragePool, DataCenterListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<StoragePool>>() {
    }, new TypeLiteral<ActionPanelView<StoragePool>>() {
    });
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskPresenter.class, SubTabStorageRegisterDiskPresenter.ViewDef.class, SubTabStorageRegisterDiskView.class, SubTabStorageRegisterDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskImagePresenter.class, SubTabStorageRegisterDiskImagePresenter.ViewDef.class, SubTabStorageRegisterDiskImageView.class, SubTabStorageRegisterDiskImagePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDRPresenter.class, SubTabStorageDRPresenter.ViewDef.class, SubTabStorageDRView.class, SubTabStorageDRPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageLeasePresenter.class, SubTabStorageLeasePresenter.ViewDef.class, SubTabStorageLeaseView.class, SubTabStorageLeasePresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<StorageDomain, StorageListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<StorageListModel>>() {
    }, new TypeLiteral<SearchPanelView<StorageListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<StorageDomain, StorageListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<StorageDomain>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<StorageDomain, StorageListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<StorageDomain>>() {
    }, new TypeLiteral<ActionPanelView<StorageDomain>>() {
    });
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    bindPresenterWidget(GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterClusterSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterVolumeSnapshotCreatePopupPresenterWidget.class, GlusterVolumeSnapshotCreatePopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotCreatePopupView.class);
    bindPresenter(SubTabClusterAffinityLabelPresenter.class, SubTabClusterAffinityLabelPresenter.ViewDef.class, SubTabClusterAffinityLabelView.class, SubTabClusterAffinityLabelPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Cluster, ClusterListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<ClusterListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<ClusterListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Cluster, ClusterListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Cluster>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Cluster, ClusterListModel<Void>>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Cluster>>() {
    }, new TypeLiteral<ActionPanelView<Cluster>>() {
    });
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(HostGeneralSubTabPresenter.class, HostGeneralSubTabPresenter.ViewDef.class, HostGeneralSubTabView.class, HostGeneralSubTabPresenter.ProxyDef.class);
    bindPresenter(SubTabHostErrataPresenter.class, SubTabHostErrataPresenter.ViewDef.class, SubTabHostErrataView.class, SubTabHostErrataPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostDevicePresenter.class, SubTabHostDevicePresenter.ViewDef.class, SubTabHostDeviceView.class, SubTabHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterStorageDevicesPresenter.class, SubTabHostGlusterStorageDevicesPresenter.ViewDef.class, SubTabHostGlusterStorageDevicesView.class, SubTabHostGlusterStorageDevicesPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VDS, HostListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<HostListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<HostListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VDS, HostListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VDS>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VDS, HostListModel<Void>>>() {
    });
    bindPresenter(SubTabHostAffinityLabelPresenter.class, SubTabHostAffinityLabelPresenter.ViewDef.class, SubTabHostAffinityLabelView.class, SubTabHostAffinityLabelPresenter.ProxyDef.class);
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VDS>>() {
    }, new TypeLiteral<ActionPanelView<VDS>>() {
    });
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestContainerPresenter.class, SubTabVirtualMachineGuestContainerPresenter.ViewDef.class, SubTabVirtualMachineGuestContainerView.class, SubTabVirtualMachineGuestContainerPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVmDevicePresenter.class, SubTabVirtualMachineVmDevicePresenter.ViewDef.class, SubTabVirtualMachineVmDevicesView.class, SubTabVirtualMachineVmDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestInfoPresenter.class, SubTabVirtualMachineGuestInfoPresenter.ViewDef.class, SubTabVirtualMachineGuestInfoView.class, SubTabVirtualMachineGuestInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineHostDevicePresenter.class, SubTabVirtualMachineHostDevicePresenter.ViewDef.class, SubTabVirtualMachineHostDeviceView.class, SubTabVirtualMachineHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineErrataPresenter.class, SubTabVirtualMachineErrataPresenter.ViewDef.class, SubTabVirtualMachineErrataView.class, SubTabVirtualMachineErrataPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VM, VmListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<VmListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<VmListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VM, VmListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VM>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VM, VmListModel<Void>>>() {
    });
    bindPresenter(SubTabVirtualMachineAffinityLabelPresenter.class, SubTabVirtualMachineAffinityLabelPresenter.ViewDef.class, SubTabVirtualMachineAffinityLabelView.class, SubTabVirtualMachineAffinityLabelPresenter.ProxyDef.class);
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VM>>() {
    }, new TypeLiteral<ActionPanelView<VM>>() {
    });
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VmPool, PoolListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<PoolListModel>>() {
    }, new TypeLiteral<SearchPanelView<PoolListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VmPool, PoolListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VmPool>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VmPool, PoolListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VmPool>>() {
    }, new TypeLiteral<ActionPanelView<VmPool>>() {
    });
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VmTemplate, TemplateListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<TemplateListModel>>() {
    }, new TypeLiteral<SearchPanelView<TemplateListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VmTemplate, TemplateListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VmTemplate>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VmTemplate, TemplateListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VmTemplate>>() {
    }, new TypeLiteral<ActionPanelView<VmTemplate>>() {
    });
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<DbUser, UserListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<UserListModel>>() {
    }, new TypeLiteral<SearchPanelView<UserListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<DbUser, UserListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<DbUser>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<DbUser, UserListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<DbUser>>() {
    }, new TypeLiteral<ActionPanelView<DbUser>>() {
    });
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Quota, QuotaListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<QuotaListModel>>() {
    }, new TypeLiteral<SearchPanelView<QuotaListModel>>() {
    });
    bindPresenterWidget(QuotaBreadCrumbsPresenterWidget.class, QuotaBreadCrumbsPresenterWidget.QuotaBreadCrumbsViewDef.class, QuotaBreadCrumbsView.class);
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Quota>>() {
    }, new TypeLiteral<ActionPanelView<Quota>>() {
    });
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Disk, DiskListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<DiskListModel>>() {
    }, new TypeLiteral<SearchPanelView<DiskListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Disk, DiskListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Disk>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Disk, DiskListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Disk>>() {
    }, new TypeLiteral<ActionPanelView<Disk>>() {
    });
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<NetworkView, NetworkListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<NetworkListModel>>() {
    }, new TypeLiteral<SearchPanelView<NetworkListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<NetworkView, NetworkListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<NetworkView>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<NetworkView, NetworkListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<NetworkView>>() {
    }, new TypeLiteral<ActionPanelView<NetworkView>>() {
    });
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderSecretPresenter.class, SubTabProviderSecretPresenter.ViewDef.class, SubTabProviderSecretView.class, SubTabProviderSecretPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Provider, ProviderListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<ProviderListModel>>() {
    }, new TypeLiteral<SearchPanelView<ProviderListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Provider, ProviderListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Provider>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Provider, ProviderListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Provider>>() {
    }, new TypeLiteral<ActionPanelView<Provider>>() {
    });
    // Errata
    bindPresenter(ErrataSubTabPanelPresenter.class, ErrataSubTabPanelPresenter.ViewDef.class, ErrataSubTabPanelView.class, ErrataSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabEngineErrataDetailsPresenter.class, SubTabEngineErrataDetailsPresenter.ViewDef.class, SubTabEngineErrataDetailsView.class, SubTabEngineErrataDetailsPresenter.ProxyDef.class);
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Erratum, EngineErrataListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Erratum>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Erratum, EngineErrataListModel>>() {
    });
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VnicProfileView, VnicProfileListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VnicProfileView>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VnicProfileView, VnicProfileListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VnicProfileView>>() {
    }, new TypeLiteral<ActionPanelView<VnicProfileView>>() {
    });
    // User Sessions
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<UserSession, SessionListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<SessionListModel>>() {
    }, new TypeLiteral<SearchPanelView<SessionListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<UserSession, SessionListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<UserSession>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<UserSession, SessionListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<UserSession>>() {
    }, new TypeLiteral<ActionPanelView<UserSession>>() {
    });
    // Volume
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<GlusterVolumeEntity, VolumeListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<VolumeListModel>>() {
    }, new TypeLiteral<SearchPanelView<VolumeListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<GlusterVolumeEntity, VolumeListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<GlusterVolumeEntity>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<GlusterVolumeEntity, VolumeListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterVolumeEntity>>() {
    }, new TypeLiteral<ActionPanelView<GlusterVolumeEntity>>() {
    });
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(ClusterWarningsPopupPresenterWidget.class, ClusterWarningsPopupPresenterWidget.ViewDef.class, ClusterWarningsPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.class, GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoReplicationSessionConfigPopupView.class);
    bindPresenterWidget(VolumeGeoRepSessionDetailsPopUpPresenterWidget.class, VolumeGeoRepSessionDetailsPopUpPresenterWidget.ViewDef.class, VolumeGeoRepSessionDetailsPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.class, GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoRepCreateSessionPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    bindPresenterWidget(AddDataCenterClusterPopupPresenterWidget.class, AddDataCenterClusterPopupPresenterWidget.ViewDef.class, AddDataCenterClusterPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(NetworkAttachmentPopupPresenterWidget.class, NetworkAttachmentPopupPresenterWidget.ViewDef.class, NetworkAttachmentPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(VfsConfigPopupPresenterWidget.class, VfsConfigPopupPresenterWidget.ViewDef.class, VfsConfigPopupView.class);
    bindPresenterWidget(SetupNetworksLabelPopupPresenterWidget.class, SetupNetworksLabelPopupPresenterWidget.ViewDef.class, SetupNetworksLabelPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    bindPresenterWidget(HostFenceAgentPopupPresenterWidget.class, HostFenceAgentPopupPresenterWidget.ViewDef.class, HostFenceAgentPopupView.class);
    bindPresenterWidget(HostFenceProxyPopupPresenterWidget.class, HostFenceProxyPopupPresenterWidget.ViewDef.class, HostFenceProxyPopupView.class);
    bindPresenterWidget(HostMaintenanceConfirmationPopupPresenterWidget.class, HostMaintenanceConfirmationPopupPresenterWidget.ViewDef.class, HostMaintenanceConfirmationPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportVmFromExternalProviderPopupPresenterWidget.class, ImportVmFromExternalProviderPopupPresenterWidget.ViewDef.class, ImportVmFromExternalProviderPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(VnicProfileMappingPopupPresenterWidget.class, VnicProfileMappingPopupPresenterWidget.ViewDef.class, VnicProfileMappingPopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    bindPresenterWidget(UploadImagePopupPresenterWidget.class, UploadImagePopupPresenterWidget.ViewDef.class, UploadImagePopupView.class);
    bindPresenterWidget(StorageDRPopupPresenterWidget.class, StorageDRPopupPresenterWidget.ViewDef.class, StorageDRPopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // VM Sparsify Disk
    bindPresenterWidget(VmDiskSparsifyPopupPresenterWidget.class, VmDiskSparsifyPopupPresenterWidget.ViewDef.class, VmDiskSparsifyPopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    bindPresenterWidget(StorageQosRemovePopupPresenterWidget.class, StorageQosRemovePopupPresenterWidget.ViewDef.class, StorageQosRemovePopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Host Devices
    bindPresenterWidget(AddVmHostDevicePopupPresenterWidget.class, AddVmHostDevicePopupPresenterWidget.ViewDef.class, AddVmHostDevicePopupView.class);
    bindPresenterWidget(VmRepinHostPopupPresenterWidget.class, VmRepinHostPopupPresenterWidget.ViewDef.class, VmRepinHostPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenter(SubTabGlusterVolumeSnapshotPresenter.class, SubTabGlusterVolumeSnapshotPresenter.ViewDef.class, SubTabGlusterVolumeSnapshotView.class, SubTabGlusterVolumeSnapshotPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(CreateBrickPopupPresenterWidget.class, CreateBrickPopupPresenterWidget.ViewDef.class, CreateBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<AuditLog, EventListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<EventListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<EventListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<AuditLog, EventListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<AuditLog>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<AuditLog, EventListModel<Void>>>() {
    });
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    bindPresenterWidget(ProviderSecretPopupPresenterWidget.class, ProviderSecretPopupPresenterWidget.ViewDef.class, ProviderSecretPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
    // Errata details
    bindPresenterWidget(HostErrataListWithDetailsPopupPresenterWidget.class, HostErrataListWithDetailsPopupPresenterWidget.ViewDef.class, HostErrataListWithDetailsPopupView.class);
    bindPresenterWidget(VmErrataListWithDetailsPopupPresenterWidget.class, VmErrataListWithDetailsPopupPresenterWidget.ViewDef.class, VmErrataListWithDetailsPopupView.class);
    bindPresenterWidget(ExpandAllButtonPresenterWidget.class, ExpandAllButtonPresenterWidget.ViewDef.class, ExpandAllButtonView.class);
    // Overlays
    // Tasks
    bindPresenter(TasksPresenter.class, TasksPresenter.ViewDef.class, TasksView.class, TasksPresenter.ProxyDef.class);
    // Bookmarks
    bindPresenter(BookmarkPresenter.class, BookmarkPresenter.ViewDef.class, BookmarkView.class, BookmarkPresenter.ProxyDef.class);
    // Tags
    bindPresenter(TagsPresenter.class, TagsPresenter.ViewDef.class, TagsView.class, TagsPresenter.ProxyDef.class);
    // Popup/detail Action panels
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Label>>() {
    }, new TypeLiteral<ActionPanelView<Label>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterHookEntity>>() {
    }, new TypeLiteral<ActionPanelView<GlusterHookEntity>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Network>>() {
    }, new TypeLiteral<ActionPanelView<Network>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<IscsiBond>>() {
    }, new TypeLiteral<ActionPanelView<IscsiBond>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterBrickEntity>>() {
    }, new TypeLiteral<ActionPanelView<GlusterBrickEntity>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterVolumeOptionEntity>>() {
    }, new TypeLiteral<ActionPanelView<GlusterVolumeOptionEntity>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<StorageDevice>>() {
    }, new TypeLiteral<ActionPanelView<StorageDevice>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterVolumeSnapshotEntity>>() {
    }, new TypeLiteral<ActionPanelView<GlusterVolumeSnapshotEntity>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterServerService>>() {
    }, new TypeLiteral<ActionPanelView<GlusterServerService>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<NetworkCluster>>() {
    }, new TypeLiteral<ActionPanelView<NetworkCluster>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<ExternalSubnet>>() {
    }, new TypeLiteral<ActionPanelView<ExternalSubnet>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<LibvirtSecret>>() {
    }, new TypeLiteral<ActionPanelView<LibvirtSecret>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Permission>>() {
    }, new TypeLiteral<ActionPanelView<Permission>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterGeoRepSession>>() {
    }, new TypeLiteral<ActionPanelView<GlusterGeoRepSession>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<PairQueryable<Cluster, NetworkCluster>>>() {
    }, new TypeLiteral<ActionPanelView<PairQueryable<Cluster, NetworkCluster>>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<PairQueryable<VdsNetworkInterface, VDS>>>() {
    }, new TypeLiteral<ActionPanelView<PairQueryable<VdsNetworkInterface, VDS>>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<PairQueryable<VmNetworkInterface, VM>>>() {
    }, new TypeLiteral<ActionPanelView<PairQueryable<VmNetworkInterface, VM>>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<PairQueryable<VmNetworkInterface, VmTemplate>>>() {
    }, new TypeLiteral<ActionPanelView<PairQueryable<VmNetworkInterface, VmTemplate>>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<StorageDomainDR>>() {
    }, new TypeLiteral<ActionPanelView<StorageDomainDR>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<RepoImage>>() {
    }, new TypeLiteral<ActionPanelView<RepoImage>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<DiskModel>>() {
    }, new TypeLiteral<ActionPanelView<DiskModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<EventSubscriber>>() {
    }, new TypeLiteral<ActionPanelView<EventSubscriber>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<AffinityGroup>>() {
    }, new TypeLiteral<ActionPanelView<AffinityGroup>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<MacPool>>() {
    }, new TypeLiteral<ActionPanelView<MacPool>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Role>>() {
    }, new TypeLiteral<ActionPanelView<Role>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<ClusterPolicy>>() {
    }, new TypeLiteral<ActionPanelView<ClusterPolicy>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<InstanceType>>() {
    }, new TypeLiteral<ActionPanelView<InstanceType>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<CpuQos>>() {
    }, new TypeLiteral<ActionPanelView<CpuQos>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<NetworkQoS>>() {
    }, new TypeLiteral<ActionPanelView<NetworkQoS>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<HostNetworkQos>>() {
    }, new TypeLiteral<ActionPanelView<HostNetworkQos>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<DiskProfile>>() {
    }, new TypeLiteral<ActionPanelView<DiskProfile>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<CpuProfile>>() {
    }, new TypeLiteral<ActionPanelView<CpuProfile>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VmNetworkInterface>>() {
    }, new TypeLiteral<ActionPanelView<VmNetworkInterface>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Snapshot>>() {
    }, new TypeLiteral<ActionPanelView<Snapshot>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<HostDeviceView>>() {
    }, new TypeLiteral<ActionPanelView<HostDeviceView>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<HostInterfaceLineModel>>() {
    }, new TypeLiteral<ActionPanelView<HostInterfaceLineModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<StorageQos>>() {
    }, new TypeLiteral<ActionPanelView<StorageQos>>() {
    });
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    bindPresenterWidget(AffinityLabelPopupPresenterWidget.class, AffinityLabelPopupPresenterWidget.ViewDef.class, AffinityLabelPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabEngineErrataPresenter.class, MainTabEngineErrataPresenter.ViewDef.class, MainTabEngineErrataView.class, MainTabEngineErrataPresenter.ProxyDef.class);
    bindPresenter(MainTabSessionPresenter.class, MainTabSessionPresenter.ViewDef.class, MainTabSessionView.class, MainTabSessionPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQosPresenter.class, SubTabDataCenterQosPresenter.ViewDef.class, SubTabDataCenterQosView.class, SubTabDataCenterQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<StoragePool, DataCenterListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<DataCenterListModel>>() {
    }, new TypeLiteral<SearchPanelView<DataCenterListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<StoragePool, DataCenterListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<StoragePool>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<StoragePool, DataCenterListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<StoragePool>>() {
    }, new TypeLiteral<ActionPanelView<StoragePool>>() {
    });
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskPresenter.class, SubTabStorageRegisterDiskPresenter.ViewDef.class, SubTabStorageRegisterDiskView.class, SubTabStorageRegisterDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskImagePresenter.class, SubTabStorageRegisterDiskImagePresenter.ViewDef.class, SubTabStorageRegisterDiskImageView.class, SubTabStorageRegisterDiskImagePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDRPresenter.class, SubTabStorageDRPresenter.ViewDef.class, SubTabStorageDRView.class, SubTabStorageDRPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageLeasePresenter.class, SubTabStorageLeasePresenter.ViewDef.class, SubTabStorageLeaseView.class, SubTabStorageLeasePresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<StorageDomain, StorageListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<StorageListModel>>() {
    }, new TypeLiteral<SearchPanelView<StorageListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<StorageDomain, StorageListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<StorageDomain>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<StorageDomain, StorageListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<StorageDomain>>() {
    }, new TypeLiteral<ActionPanelView<StorageDomain>>() {
    });
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    bindPresenterWidget(GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterClusterSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterVolumeSnapshotCreatePopupPresenterWidget.class, GlusterVolumeSnapshotCreatePopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotCreatePopupView.class);
    bindPresenter(SubTabClusterAffinityLabelPresenter.class, SubTabClusterAffinityLabelPresenter.ViewDef.class, SubTabClusterAffinityLabelView.class, SubTabClusterAffinityLabelPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Cluster, ClusterListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<ClusterListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<ClusterListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Cluster, ClusterListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Cluster>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Cluster, ClusterListModel<Void>>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Cluster>>() {
    }, new TypeLiteral<ActionPanelView<Cluster>>() {
    });
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(HostGeneralSubTabPresenter.class, HostGeneralSubTabPresenter.ViewDef.class, HostGeneralSubTabView.class, HostGeneralSubTabPresenter.ProxyDef.class);
    bindPresenter(SubTabHostErrataPresenter.class, SubTabHostErrataPresenter.ViewDef.class, SubTabHostErrataView.class, SubTabHostErrataPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostDevicePresenter.class, SubTabHostDevicePresenter.ViewDef.class, SubTabHostDeviceView.class, SubTabHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterStorageDevicesPresenter.class, SubTabHostGlusterStorageDevicesPresenter.ViewDef.class, SubTabHostGlusterStorageDevicesView.class, SubTabHostGlusterStorageDevicesPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VDS, HostListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<HostListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<HostListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VDS, HostListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VDS>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VDS, HostListModel<Void>>>() {
    });
    bindPresenter(SubTabHostAffinityLabelPresenter.class, SubTabHostAffinityLabelPresenter.ViewDef.class, SubTabHostAffinityLabelView.class, SubTabHostAffinityLabelPresenter.ProxyDef.class);
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VDS>>() {
    }, new TypeLiteral<ActionPanelView<VDS>>() {
    });
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestContainerPresenter.class, SubTabVirtualMachineGuestContainerPresenter.ViewDef.class, SubTabVirtualMachineGuestContainerView.class, SubTabVirtualMachineGuestContainerPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVmDevicePresenter.class, SubTabVirtualMachineVmDevicePresenter.ViewDef.class, SubTabVirtualMachineVmDevicesView.class, SubTabVirtualMachineVmDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestInfoPresenter.class, SubTabVirtualMachineGuestInfoPresenter.ViewDef.class, SubTabVirtualMachineGuestInfoView.class, SubTabVirtualMachineGuestInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineHostDevicePresenter.class, SubTabVirtualMachineHostDevicePresenter.ViewDef.class, SubTabVirtualMachineHostDeviceView.class, SubTabVirtualMachineHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineErrataPresenter.class, SubTabVirtualMachineErrataPresenter.ViewDef.class, SubTabVirtualMachineErrataView.class, SubTabVirtualMachineErrataPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VM, VmListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<VmListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<VmListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VM, VmListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VM>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VM, VmListModel<Void>>>() {
    });
    bindPresenter(SubTabVirtualMachineAffinityLabelPresenter.class, SubTabVirtualMachineAffinityLabelPresenter.ViewDef.class, SubTabVirtualMachineAffinityLabelView.class, SubTabVirtualMachineAffinityLabelPresenter.ProxyDef.class);
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VM>>() {
    }, new TypeLiteral<ActionPanelView<VM>>() {
    });
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VmPool, PoolListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<PoolListModel>>() {
    }, new TypeLiteral<SearchPanelView<PoolListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VmPool, PoolListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VmPool>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VmPool, PoolListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VmPool>>() {
    }, new TypeLiteral<ActionPanelView<VmPool>>() {
    });
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VmTemplate, TemplateListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<TemplateListModel>>() {
    }, new TypeLiteral<SearchPanelView<TemplateListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VmTemplate, TemplateListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VmTemplate>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VmTemplate, TemplateListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VmTemplate>>() {
    }, new TypeLiteral<ActionPanelView<VmTemplate>>() {
    });
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<DbUser, UserListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<UserListModel>>() {
    }, new TypeLiteral<SearchPanelView<UserListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<DbUser, UserListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<DbUser>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<DbUser, UserListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<DbUser>>() {
    }, new TypeLiteral<ActionPanelView<DbUser>>() {
    });
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Quota, QuotaListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<QuotaListModel>>() {
    }, new TypeLiteral<SearchPanelView<QuotaListModel>>() {
    });
    bindPresenterWidget(QuotaBreadCrumbsPresenterWidget.class, QuotaBreadCrumbsPresenterWidget.QuotaBreadCrumbsViewDef.class, QuotaBreadCrumbsView.class);
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Quota>>() {
    }, new TypeLiteral<ActionPanelView<Quota>>() {
    });
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Disk, DiskListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<DiskListModel>>() {
    }, new TypeLiteral<SearchPanelView<DiskListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Disk, DiskListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Disk>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Disk, DiskListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Disk>>() {
    }, new TypeLiteral<ActionPanelView<Disk>>() {
    });
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<NetworkView, NetworkListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<NetworkListModel>>() {
    }, new TypeLiteral<SearchPanelView<NetworkListModel>>() {
    });
    bindPresenterWidget(NetworkBreadCrumbsPresenterWidget.class, NetworkBreadCrumbsPresenterWidget.NetworkBreadCrumbsViewDef.class, NetworkBreadCrumbsView.class);
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<NetworkView>>() {
    }, new TypeLiteral<ActionPanelView<NetworkView>>() {
    });
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderSecretPresenter.class, SubTabProviderSecretPresenter.ViewDef.class, SubTabProviderSecretView.class, SubTabProviderSecretPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Provider, ProviderListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<ProviderListModel>>() {
    }, new TypeLiteral<SearchPanelView<ProviderListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Provider, ProviderListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Provider>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Provider, ProviderListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Provider>>() {
    }, new TypeLiteral<ActionPanelView<Provider>>() {
    });
    // Errata
    bindPresenter(ErrataSubTabPanelPresenter.class, ErrataSubTabPanelPresenter.ViewDef.class, ErrataSubTabPanelView.class, ErrataSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabEngineErrataDetailsPresenter.class, SubTabEngineErrataDetailsPresenter.ViewDef.class, SubTabEngineErrataDetailsView.class, SubTabEngineErrataDetailsPresenter.ProxyDef.class);
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Erratum, EngineErrataListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Erratum>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Erratum, EngineErrataListModel>>() {
    });
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    bindPresenterWidget(VnicProfileBreadCrumbsPresenterWidget.class, VnicProfileBreadCrumbsPresenterWidget.VnicProfileBreadCrumbsViewDef.class, VnicProfileBreadCrumbsView.class);
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VnicProfileView>>() {
    }, new TypeLiteral<ActionPanelView<VnicProfileView>>() {
    });
    // User Sessions
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<UserSession, SessionListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<SessionListModel>>() {
    }, new TypeLiteral<SearchPanelView<SessionListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<UserSession, SessionListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<UserSession>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<UserSession, SessionListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<UserSession>>() {
    }, new TypeLiteral<ActionPanelView<UserSession>>() {
    });
    // Volume
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<GlusterVolumeEntity, VolumeListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<VolumeListModel>>() {
    }, new TypeLiteral<SearchPanelView<VolumeListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<GlusterVolumeEntity, VolumeListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<GlusterVolumeEntity>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<GlusterVolumeEntity, VolumeListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterVolumeEntity>>() {
    }, new TypeLiteral<ActionPanelView<GlusterVolumeEntity>>() {
    });
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(ClusterWarningsPopupPresenterWidget.class, ClusterWarningsPopupPresenterWidget.ViewDef.class, ClusterWarningsPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.class, GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoReplicationSessionConfigPopupView.class);
    bindPresenterWidget(VolumeGeoRepSessionDetailsPopUpPresenterWidget.class, VolumeGeoRepSessionDetailsPopUpPresenterWidget.ViewDef.class, VolumeGeoRepSessionDetailsPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.class, GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoRepCreateSessionPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    bindPresenterWidget(AddDataCenterClusterPopupPresenterWidget.class, AddDataCenterClusterPopupPresenterWidget.ViewDef.class, AddDataCenterClusterPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(NetworkAttachmentPopupPresenterWidget.class, NetworkAttachmentPopupPresenterWidget.ViewDef.class, NetworkAttachmentPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(VfsConfigPopupPresenterWidget.class, VfsConfigPopupPresenterWidget.ViewDef.class, VfsConfigPopupView.class);
    bindPresenterWidget(SetupNetworksLabelPopupPresenterWidget.class, SetupNetworksLabelPopupPresenterWidget.ViewDef.class, SetupNetworksLabelPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    bindPresenterWidget(HostFenceAgentPopupPresenterWidget.class, HostFenceAgentPopupPresenterWidget.ViewDef.class, HostFenceAgentPopupView.class);
    bindPresenterWidget(HostFenceProxyPopupPresenterWidget.class, HostFenceProxyPopupPresenterWidget.ViewDef.class, HostFenceProxyPopupView.class);
    bindPresenterWidget(HostMaintenanceConfirmationPopupPresenterWidget.class, HostMaintenanceConfirmationPopupPresenterWidget.ViewDef.class, HostMaintenanceConfirmationPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportVmFromExternalProviderPopupPresenterWidget.class, ImportVmFromExternalProviderPopupPresenterWidget.ViewDef.class, ImportVmFromExternalProviderPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(VnicProfileMappingPopupPresenterWidget.class, VnicProfileMappingPopupPresenterWidget.ViewDef.class, VnicProfileMappingPopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    bindPresenterWidget(UploadImagePopupPresenterWidget.class, UploadImagePopupPresenterWidget.ViewDef.class, UploadImagePopupView.class);
    bindPresenterWidget(StorageDRPopupPresenterWidget.class, StorageDRPopupPresenterWidget.ViewDef.class, StorageDRPopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // VM Sparsify Disk
    bindPresenterWidget(VmDiskSparsifyPopupPresenterWidget.class, VmDiskSparsifyPopupPresenterWidget.ViewDef.class, VmDiskSparsifyPopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    bindPresenterWidget(StorageQosRemovePopupPresenterWidget.class, StorageQosRemovePopupPresenterWidget.ViewDef.class, StorageQosRemovePopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Host Devices
    bindPresenterWidget(AddVmHostDevicePopupPresenterWidget.class, AddVmHostDevicePopupPresenterWidget.ViewDef.class, AddVmHostDevicePopupView.class);
    bindPresenterWidget(VmRepinHostPopupPresenterWidget.class, VmRepinHostPopupPresenterWidget.ViewDef.class, VmRepinHostPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenter(SubTabGlusterVolumeSnapshotPresenter.class, SubTabGlusterVolumeSnapshotPresenter.ViewDef.class, SubTabGlusterVolumeSnapshotView.class, SubTabGlusterVolumeSnapshotPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(CreateBrickPopupPresenterWidget.class, CreateBrickPopupPresenterWidget.ViewDef.class, CreateBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<AuditLog, EventListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<EventListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<EventListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<AuditLog, EventListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<AuditLog>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<AuditLog, EventListModel<Void>>>() {
    });
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    bindPresenterWidget(ProviderSecretPopupPresenterWidget.class, ProviderSecretPopupPresenterWidget.ViewDef.class, ProviderSecretPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
    // Errata details
    bindPresenterWidget(HostErrataListWithDetailsPopupPresenterWidget.class, HostErrataListWithDetailsPopupPresenterWidget.ViewDef.class, HostErrataListWithDetailsPopupView.class);
    bindPresenterWidget(VmErrataListWithDetailsPopupPresenterWidget.class, VmErrataListWithDetailsPopupPresenterWidget.ViewDef.class, VmErrataListWithDetailsPopupView.class);
    bindPresenterWidget(ExpandAllButtonPresenterWidget.class, ExpandAllButtonPresenterWidget.ViewDef.class, ExpandAllButtonView.class);
    // Overlays
    // Tasks
    bindPresenter(TasksPresenter.class, TasksPresenter.ViewDef.class, TasksView.class, TasksPresenter.ProxyDef.class);
    // Bookmarks
    bindPresenter(BookmarkPresenter.class, BookmarkPresenter.ViewDef.class, BookmarkView.class, BookmarkPresenter.ProxyDef.class);
    // Tags
    bindPresenter(TagsPresenter.class, TagsPresenter.ViewDef.class, TagsView.class, TagsPresenter.ProxyDef.class);
    // Popup/detail Action panels
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Label>>() {
    }, new TypeLiteral<ActionPanelView<Label>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterHookEntity>>() {
    }, new TypeLiteral<ActionPanelView<GlusterHookEntity>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Network>>() {
    }, new TypeLiteral<ActionPanelView<Network>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<IscsiBond>>() {
    }, new TypeLiteral<ActionPanelView<IscsiBond>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterBrickEntity>>() {
    }, new TypeLiteral<ActionPanelView<GlusterBrickEntity>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterVolumeOptionEntity>>() {
    }, new TypeLiteral<ActionPanelView<GlusterVolumeOptionEntity>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<StorageDevice>>() {
    }, new TypeLiteral<ActionPanelView<StorageDevice>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterVolumeSnapshotEntity>>() {
    }, new TypeLiteral<ActionPanelView<GlusterVolumeSnapshotEntity>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterServerService>>() {
    }, new TypeLiteral<ActionPanelView<GlusterServerService>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<NetworkCluster>>() {
    }, new TypeLiteral<ActionPanelView<NetworkCluster>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<ExternalSubnet>>() {
    }, new TypeLiteral<ActionPanelView<ExternalSubnet>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<LibvirtSecret>>() {
    }, new TypeLiteral<ActionPanelView<LibvirtSecret>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Permission>>() {
    }, new TypeLiteral<ActionPanelView<Permission>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterGeoRepSession>>() {
    }, new TypeLiteral<ActionPanelView<GlusterGeoRepSession>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<PairQueryable<Cluster, NetworkCluster>>>() {
    }, new TypeLiteral<ActionPanelView<PairQueryable<Cluster, NetworkCluster>>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<PairQueryable<VdsNetworkInterface, VDS>>>() {
    }, new TypeLiteral<ActionPanelView<PairQueryable<VdsNetworkInterface, VDS>>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<PairQueryable<VmNetworkInterface, VM>>>() {
    }, new TypeLiteral<ActionPanelView<PairQueryable<VmNetworkInterface, VM>>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<PairQueryable<VmNetworkInterface, VmTemplate>>>() {
    }, new TypeLiteral<ActionPanelView<PairQueryable<VmNetworkInterface, VmTemplate>>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<StorageDomainDR>>() {
    }, new TypeLiteral<ActionPanelView<StorageDomainDR>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<RepoImage>>() {
    }, new TypeLiteral<ActionPanelView<RepoImage>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<DiskModel>>() {
    }, new TypeLiteral<ActionPanelView<DiskModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<EventSubscriber>>() {
    }, new TypeLiteral<ActionPanelView<EventSubscriber>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<AffinityGroup>>() {
    }, new TypeLiteral<ActionPanelView<AffinityGroup>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<MacPool>>() {
    }, new TypeLiteral<ActionPanelView<MacPool>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Role>>() {
    }, new TypeLiteral<ActionPanelView<Role>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<ClusterPolicy>>() {
    }, new TypeLiteral<ActionPanelView<ClusterPolicy>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<InstanceType>>() {
    }, new TypeLiteral<ActionPanelView<InstanceType>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<CpuQos>>() {
    }, new TypeLiteral<ActionPanelView<CpuQos>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<NetworkQoS>>() {
    }, new TypeLiteral<ActionPanelView<NetworkQoS>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<HostNetworkQos>>() {
    }, new TypeLiteral<ActionPanelView<HostNetworkQos>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<DiskProfile>>() {
    }, new TypeLiteral<ActionPanelView<DiskProfile>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<CpuProfile>>() {
    }, new TypeLiteral<ActionPanelView<CpuProfile>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VmNetworkInterface>>() {
    }, new TypeLiteral<ActionPanelView<VmNetworkInterface>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Snapshot>>() {
    }, new TypeLiteral<ActionPanelView<Snapshot>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<HostDeviceView>>() {
    }, new TypeLiteral<ActionPanelView<HostDeviceView>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<HostInterfaceLineModel>>() {
    }, new TypeLiteral<ActionPanelView<HostInterfaceLineModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<StorageQos>>() {
    }, new TypeLiteral<ActionPanelView<StorageQos>>() {
    });
}
#end_block

#method_before
private void addIcon(String iconCss) {
    if (!StringUtils.isEmpty(iconCss)) {
        Span iconPanel = new Span();
        iconPanel.addStyleName(getBaseStyle(iconCss));
        iconPanel.addStyleName(iconCss);
        add(iconPanel);
    }
}
#method_after
private void addIcon(String iconCss) {
    if (iconCss != null && !iconCss.isEmpty()) {
        Span iconPanel = new Span();
        iconPanel.addStyleName(getBaseStyle(iconCss));
        iconPanel.addStyleName(iconCss);
        iconPanel.addStyleName(PatternflyConstants.LIST_VIEW_ICON_PANEL);
        add(iconPanel);
    }
}
#end_block

#method_before
@Override
public void onClick(ClickEvent event) {
    if (event.getSource() instanceof ListGroupItem) {
        PatternflyListViewItem<T> clickedItem = null;
        for (PatternflyListViewItem<T> item : currentState) {
            if (item.asListGroupItem().equals(event.getSource())) {
                clickedItem = item;
                break;
            }
        }
        if (clickedItem != null) {
            for (int i = 0; i < getWidgetCount(); i++) {
                IsWidget widget = getWidget(i);
                widget.asWidget().removeStyleName(Styles.ACTIVE);
            }
            if (!event.isControlKeyDown()) {
                clickedItem.asListGroupItem().addStyleName(Styles.ACTIVE);
                selectionModel.setSelected(clickedItem.getEntity(), true);
                List<T> items = getModel().getItemsAsList();
                if (items != null) {
                    selectedIndex = items.indexOf(clickedItem.getEntity());
                }
                getModel().setSelectedItem(clickedItem.getEntity());
            } else {
                selectionModel.setSelected(clickedItem.getEntity(), false);
                selectedIndex = -1;
                getModel().setSelectedItem(null);
            }
        }
    }
}
#method_after
@Override
public void onClick(ClickEvent event) {
    if (event.getSource() instanceof ListGroupItem) {
        PatternflyListViewItem<T> clickedItem = null;
        for (PatternflyListViewItem<T> item : currentState) {
            if (item.asListGroupItem() == event.getSource()) {
                clickedItem = item;
                break;
            }
        }
        if (clickedItem != null) {
            for (int i = 0; i < getWidgetCount(); i++) {
                IsWidget widget = getWidget(i);
                widget.asWidget().removeStyleName(Styles.ACTIVE);
            }
            if (!event.isControlKeyDown()) {
                clickedItem.asListGroupItem().addStyleName(Styles.ACTIVE);
                selectionModel.setSelected(clickedItem.getEntity(), true);
                List<T> items = getModel().getItemsAsList();
                if (items != null) {
                    selectedIndex = items.indexOf(clickedItem.getEntity());
                }
                getModel().setSelectedItem(clickedItem.getEntity());
            } else {
                selectionModel.setSelected(clickedItem.getEntity(), false);
                selectedIndex = -1;
                getModel().setSelectedItem(null);
            }
        }
    }
}
#end_block

#method_before
private void applySearchString(String searchString) {
    if (modelProvider.getModel() instanceof SearchableListModel) {
        @SuppressWarnings("unchecked")
        SearchableListModel<?, ? extends EntityModel<?>> listModel = modelProvider.getModel();
        if (!StringUtils.isEmpty(searchString) && searchString.startsWith(listModel.getDefaultSearchString())) {
            // search string for this model found.
            listModel.setSearchString(searchString);
            listModel.getSearchCommand().execute();
            MainModelSelectionChangeEvent.fire((HasHandlers) getEventBus(), listModel);
        }
    }
}
#method_after
private void applySearchString(String searchString) {
    if (modelProvider.getModel() instanceof SearchableListModel) {
        @SuppressWarnings("unchecked")
        SearchableListModel<?, ? extends EntityModel<?>> listModel = modelProvider.getModel();
        if (StringHelper.isNotNullOrEmpty(searchString) && searchString.startsWith(listModel.getDefaultSearchString())) {
            // search string for this model found.
            listModel.setSearchString(searchString);
            listModel.getSearchCommand().execute();
            MainModelSelectionChangeEvent.fire((HasHandlers) getEventBus(), listModel);
        }
    }
}
#end_block

#method_before
protected PlaceRequest getSubTabRequest() {
    String subTabName = modelProvider.getModel().getActiveDetailModel().getHashName();
    String requestToken = getMainTabRequest().getNameToken() + WebAdminApplicationPlaces.SUB_TAB_PREFIX + subTabName;
    return PlaceRequestFactory.get(requestToken);
}
#method_after
protected PlaceRequest getSubTabRequest() {
    String subTabName;
    modelProvider.getModel().ensureActiveDetailModel();
    subTabName = modelProvider.getModel().getActiveDetailModel().getHashName();
    String requestToken = getMainTabRequest().getNameToken() + WebAdminApplicationPlaces.SUB_TAB_PREFIX + subTabName;
    return PlaceRequestFactory.get(requestToken);
}
#end_block

#method_before
@Override
protected void onBind() {
    super.onBind();
    OvirtSelectionModel<?> tableSelectionModel = getTable() != null ? getTable().getSelectionModel() : null;
    if (tableSelectionModel != null) {
        registerHandler(tableSelectionModel.addSelectionChangeHandler(event -> {
            // Update detail model selection
            updateDetailModelSelection();
        }));
    }
    initializeHandlers();
    getSelectedMainItems().registerListener(this);
    itemChanged(getSelectedMainItems().getSelectedItem());
    setInSlot(TYPE_SetActionPanel, getActionPanelPresenterWidget());
}
#method_after
@Override
protected void onBind() {
    super.onBind();
    OvirtSelectionModel<?> tableSelectionModel = getTable() != null ? getTable().getSelectionModel() : null;
    if (tableSelectionModel != null) {
        registerHandler(tableSelectionModel.addSelectionChangeHandler(event -> {
            // Update detail model selection
            updateDetailModelSelection();
        }));
    }
    OvirtSelectionModel<T> mainModelSelectionModel = modelProvider.getMainModel().getSelectionModel();
    if (mainModelSelectionModel != null) {
        registerHandler(mainModelSelectionModel.addSelectionChangeHandler(event -> {
            itemChanged(getSelectedMainItems().getSelectedItem());
        }));
    }
    initializeHandlers();
    getSelectedMainItems().registerListener(this);
    itemChanged(getSelectedMainItems().getSelectedItem());
    setInSlot(TYPE_SetActionPanel, getActionPanelPresenterWidget());
}
#end_block

#method_before
@Override
public void itemChanged(T item) {
    if (item != null && getView().asWidget().isVisible()) {
        getView().setMainTabSelectedItem(item);
    }
}
#method_after
@Override
public void itemChanged(T item) {
    if (item != null && getView().asWidget().isVisible()) {
        getView().setMainTabSelectedItem(item);
    } else if (item == null && getView().asWidget().isVisible()) {
        // No selection so we can't positively show anything, switch to grid.
        placeManager.revealPlace(getMainTabRequest());
    }
}
#end_block

#method_before
void initTableOverhead() {
    viewRadioGroup.addClickHandler(event -> {
        if (((RadioButton) event.getSource()).getValue()) {
            handleRadioButtonClick(event);
        }
    });
    getTable().setTableOverhead(viewRadioGroup);
}
#method_after
void initTableOverhead() {
    getTable().setTableOverhead(viewRadioGroup);
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    initTableOverhead();
    handleRadioButtonClick(null);
    initSorting();
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    initTableOverhead();
    onRadioButtonChange(viewRadioGroup.getSelectedValue());
    initSorting();
}
#end_block

#method_before
private Container createDisksItemContainerPanel(List<DiskImage> diskImages) {
    Row content = new Row();
    Column column = new Column(ColumnSize.MD_12);
    content.add(column);
    for (DiskImage image : diskImages) {
        DListElement dl = Document.get().createDLElement();
        dl.addClassName(DL_HORIZONTAL);
        addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.statusDisk()), getImageStatus(image.getImageStatus()), dl);
        addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.aliasDisk()), image.getDiskAlias(), dl);
        addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.provisionedSizeDisk()), String.valueOf(image.getSize()), dl);
        addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.sizeDisk()), String.valueOf(image.getActualSizeInBytes()), dl);
        addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.allocationDisk()), String.valueOf(VolumeType.forValue(image.getVolumeType().getValue())), dl);
        addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.interfaceDisk()), getInterface(image), dl);
        addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.creationDateDisk()), dateRenderer.render(image.getCreationDate()), dl);
        addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.diskSnapshotIDDisk()), String.valueOf(image.getImageId()), dl);
        addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.typeDisk()), String.valueOf(image.getDiskStorageType()), dl);
        addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.descriptionDisk()), StringUtils.isNotEmpty(image.getDiskDescription()) ? image.getDiskDescription() : constants.notAvailableLabel(), dl);
        column.getElement().appendChild(dl);
    }
    if (diskImages.isEmpty()) {
        column.getElement().setInnerHTML(constants.noItemsToDisplay());
    }
    return createItemContainerPanel(content);
}
#method_after
private Container createDisksItemContainerPanel(List<DiskImage> diskImages) {
    Row content = new Row();
    Column column = new Column(ColumnSize.MD_12);
    content.add(column);
    for (DiskImage image : diskImages) {
        DListElement dl = Document.get().createDLElement();
        dl.addClassName(DL_HORIZONTAL);
        addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.statusDisk()), getImageStatus(image.getImageStatus()), dl);
        addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.aliasDisk()), image.getDiskAlias(), dl);
        addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.provisionedSizeDisk()), String.valueOf(image.getSize()), dl);
        addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.sizeDisk()), String.valueOf(image.getActualSizeInBytes()), dl);
        addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.allocationDisk()), String.valueOf(VolumeType.forValue(image.getVolumeType().getValue())), dl);
        addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.interfaceDisk()), getInterface(image), dl);
        addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.creationDateDisk()), dateRenderer.render(image.getCreationDate()), dl);
        addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.diskSnapshotIDDisk()), String.valueOf(image.getImageId()), dl);
        addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.typeDisk()), String.valueOf(image.getDiskStorageType()), dl);
        addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.descriptionDisk()), StringHelper.isNotNullOrEmpty(image.getDiskDescription()) ? image.getDiskDescription() : constants.notAvailableLabel(), dl);
        column.getElement().appendChild(dl);
    }
    if (diskImages.isEmpty()) {
        column.getElement().setInnerHTML(constants.noItemsToDisplay());
    }
    return createItemContainerPanel(content);
}
#end_block

#method_before
private String getDescription(Snapshot snapshot) {
    String description = SafeHtmlUtils.fromString(snapshot.getDescription()).asString();
    if (snapshot.getStatus() == SnapshotStatus.IN_PREVIEW) {
        List<String> previewedItems = new ArrayList<>(Arrays.asList(constants.vmConfiguration()));
        previewedItems.addAll(Linq.getDiskAliases(snapshot.getDiskImages()));
        description = messages.snapshotPreviewing(description, // $NON-NLS-1$
        StringUtils.join(previewedItems, ", "));
    } else if (snapshot.getType() == SnapshotType.STATELESS) {
        // $NON-NLS-1$ //$NON-NLS-2$
        description = description + " (" + constants.readonlyLabel() + ")";
    } else if (snapshot.getType() == SnapshotType.PREVIEW) {
        description = constants.snapshotDescriptionActiveVmBeforePreview();
    } else if (snapshot.getType() == SnapshotType.ACTIVE) {
        description = constants.snapshotDescriptionActiveVm();
    } else if (snapshot.getType() == SnapshotType.REGULAR && !snapshot.getDiskImages().isEmpty()) {
        description = messages.snapshotPreviewing(description, // $NON-NLS-1$
        StringUtils.join(Linq.getDiskAliases(snapshot.getDiskImages()), ", "));
    } else if (snapshot.isVmConfigurationBroken()) {
        // $NON-NLS-1$ //$NON-NLS-2$
        description = description + " (" + constants.brokenVmConfiguration() + ")";
    }
    return description;
}
#method_after
private String getDescription(Snapshot snapshot) {
    String description = SafeHtmlUtils.fromString(snapshot.getDescription()).asString();
    if (snapshot.getStatus() == SnapshotStatus.IN_PREVIEW) {
        List<String> previewedItems = new ArrayList<>(Arrays.asList(constants.vmConfiguration()));
        previewedItems.addAll(Linq.getDiskAliases(snapshot.getDiskImages()));
        description = messages.snapshotPreviewing(description, // $NON-NLS-1$
        String.join(", ", previewedItems));
    } else if (snapshot.getType() == SnapshotType.STATELESS) {
        // $NON-NLS-1$ //$NON-NLS-2$
        description = description + " (" + constants.readonlyLabel() + ")";
    } else if (snapshot.getType() == SnapshotType.PREVIEW) {
        description = constants.snapshotDescriptionActiveVmBeforePreview();
    } else if (snapshot.getType() == SnapshotType.ACTIVE) {
        description = constants.snapshotDescriptionActiveVm();
    } else if (snapshot.getType() == SnapshotType.REGULAR && !snapshot.getDiskImages().isEmpty()) {
        description = messages.snapshotPreviewing(description, // $NON-NLS-1$
        String.join(", ", Linq.getDiskAliases(snapshot.getDiskImages())));
    } else if (snapshot.isVmConfigurationBroken()) {
        // $NON-NLS-1$ //$NON-NLS-2$
        description = description + " (" + constants.brokenVmConfiguration() + ")";
    }
    return description;
}
#end_block

#method_before
private void resizeFrame() {
    int newHeight = getFrameBodyScrollHeight(frame);
    int windowSize = Window.getClientHeight() - HEADER_HEIGHT;
    frame.getElement().getStyle().setHeight(Math.max(windowSize, newHeight), Unit.PX);
}
#method_after
private void resizeFrame() {
    int top = frame.getParent().getAbsoluteTop();
    int windowHeight = Window.getClientHeight();
    int newHeight = windowHeight - top;
    // For some reason we need to give some space around the frame or it will cause a second scroll-bar.
    newHeight -= IFRAME_SUBTRACT;
    if (top > 0 && top < windowHeight) {
        frame.getElement().getStyle().setHeight(newHeight, Unit.PX);
    }
}
#end_block

#method_before
private void initNetworkList(Guid dataCenterId) {
    startProgress();
    IdQueryParameters queryParams = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(QueryType.GetAllNetworks, queryParams, new AsyncQuery<QueryReturnValue>(returnValue -> {
        Collection<Network> networks = returnValue.getReturnValue();
        Network oldSelectedNetwork = getNetwork().getSelectedItem();
        getNetwork().setItems(networks);
        updateNetworks(networks);
        if (oldSelectedNetwork != null) {
            Network newSelectedNetwork = networks.stream().filter(network -> Objects.equals(network.getId(), oldSelectedNetwork.getId())).findFirst().get();
            if (!getNetwork().getSelectedItem().getId().equals(newSelectedNetwork.getId())) {
                getNetwork().setSelectedItem(newSelectedNetwork);
            }
        }
        stopProgress();
    }));
}
#method_after
private void initNetworkList(Guid dataCenterId) {
    startProgress();
    IdQueryParameters queryParams = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(QueryType.GetAllNetworks, queryParams, new AsyncQuery<QueryReturnValue>(returnValue -> {
        Collection<Network> networks = returnValue.getReturnValue();
        getNetwork().setItems(networks);
        updateNetworks(networks);
        stopProgress();
    }));
}
#end_block

#method_before
private void onSave() {
    if (getProgress() != null) {
        return;
    }
    if (!validate()) {
        return;
    }
    // Save changes.
    flush();
    startProgress();
    Frontend.getInstance().runAction(getActionType(), getActionParameters(), result -> {
        VdcReturnValueBase returnValue = result.getReturnValue();
        stopProgress();
        if (returnValue != null && returnValue.getSucceeded()) {
            cancel();
        }
    }, this);
}
#method_after
private void onSave() {
    if (getProgress() != null) {
        return;
    }
    if (!validate()) {
        return;
    }
    // Save changes.
    flush();
    startProgress();
    Frontend.getInstance().runAction(getActionType(), getActionParameters(), result -> {
        ActionReturnValue returnValue = result.getReturnValue();
        stopProgress();
        if (returnValue != null && returnValue.getSucceeded()) {
            cancel();
        }
    }, this);
}
#end_block

#method_before
public boolean validate() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new AsciiNameValidation() });
    return getName().getIsValid() && getCustomPropertySheet().validate();
}
#method_after
public boolean validate() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation() });
    return getName().getIsValid() && getCustomPropertySheet().validate();
}
#end_block

#method_before
public void runMultipleAction(final ActionType actionType, final List<ActionParametersBase> parameters, final boolean isRunOnlyIfAllValidationPass, final IFrontendMultipleActionAsyncCallback callback, final Object state, final boolean showErrorDialog, final boolean waitForResult) {
    VdcOperationCallbackList<VdcOperation<ActionType, ActionParametersBase>, List<ActionReturnValue>> multiCallback = new VdcOperationCallbackList<VdcOperation<ActionType, ActionParametersBase>, List<ActionReturnValue>>() {

        @Override
        public void onSuccess(final List<VdcOperation<ActionType, ActionParametersBase>> operationList, final List<ActionReturnValue> resultObject) {
            // $NON-NLS-1$
            logger.finer("Frontend: successfully executed runMultipleAction, determining result!");
            ArrayList<ActionReturnValue> failed = resultObject.stream().filter(v -> !v.isValid()).collect(Collectors.toCollection(ArrayList::new));
            if (showErrorDialog && !failed.isEmpty()) {
                translateErrors(failed);
                getEventsHandler().runMultipleActionFailed(actionType, failed);
            }
            if (callback != null) {
                callback.executed(new FrontendMultipleActionAsyncResult(actionType, parameters, resultObject, state));
            }
            fireAsyncActionSucceededEvent(state);
        }

        @Override
        public void onFailure(final List<VdcOperation<ActionType, ActionParametersBase>> operation, final Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to execute runMultipleAction: " + caught, caught);
            failureEventHandler(caught);
            if (callback != null) {
                callback.executed(new FrontendMultipleActionAsyncResult(actionType, parameters, null, state));
            }
            fireAsyncActionFailedEvent(state);
        }
    };
    List<VdcOperation<?, ?>> operationList = parameters.stream().map(p -> new VdcOperation<>(actionType, p, !waitForResult, multiCallback, isRunOnlyIfAllValidationPass)).collect(Collectors.toList());
    fireAsyncOperationStartedEvent(state);
    if (operationList.isEmpty()) {
        // it ourselves.
        if (scheduler == null) {
            scheduler = Scheduler.get();
        }
        scheduler.scheduleDeferred(() -> {
            if (callback != null) {
                List<ActionReturnValue> emptyResult = new ArrayList<>();
                callback.executed(new FrontendMultipleActionAsyncResult(actionType, parameters, emptyResult, state));
            }
        });
    } else {
        getOperationManager().addOperationList(operationList);
    }
}
#method_after
public void runMultipleAction(final ActionType actionType, final List<ActionParametersBase> parameters, final boolean isRunOnlyIfAllValidationPass, final IFrontendMultipleActionAsyncCallback callback, final Object state, final boolean showErrorDialog, final boolean waitForResult) {
    VdcOperationCallbackList<VdcOperation<ActionType, ActionParametersBase>, List<ActionReturnValue>> multiCallback = new VdcOperationCallbackList<VdcOperation<ActionType, ActionParametersBase>, List<ActionReturnValue>>() {

        @Override
        public void onSuccess(final List<VdcOperation<ActionType, ActionParametersBase>> operationList, final List<ActionReturnValue> resultObject) {
            // $NON-NLS-1$
            logger.finer("Frontend: successfully executed runMultipleAction, determining result!");
            List<ActionReturnValue> failed = resultObject.stream().filter(v -> !v.isValid()).collect(Collectors.toList());
            if (showErrorDialog && !failed.isEmpty()) {
                translateErrors(failed);
                getEventsHandler().runMultipleActionFailed(actionType, failed);
            }
            if (callback != null) {
                callback.executed(new FrontendMultipleActionAsyncResult(actionType, parameters, resultObject, state));
            }
            fireAsyncActionSucceededEvent(state);
        }

        @Override
        public void onFailure(final List<VdcOperation<ActionType, ActionParametersBase>> operation, final Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to execute runMultipleAction: " + caught, caught);
            failureEventHandler(caught);
            if (callback != null) {
                callback.executed(new FrontendMultipleActionAsyncResult(actionType, parameters, null, state));
            }
            fireAsyncActionFailedEvent(state);
        }
    };
    List<VdcOperation<?, ?>> operationList = parameters.stream().map(p -> new VdcOperation<>(actionType, p, !waitForResult, multiCallback, isRunOnlyIfAllValidationPass)).collect(Collectors.toList());
    fireAsyncOperationStartedEvent(state);
    if (operationList.isEmpty()) {
        // it ourselves.
        if (scheduler == null) {
            scheduler = Scheduler.get();
        }
        scheduler.scheduleDeferred(() -> {
            if (callback != null) {
                List<ActionReturnValue> emptyResult = new ArrayList<>();
                callback.executed(new FrontendMultipleActionAsyncResult(actionType, parameters, emptyResult, state));
            }
        });
    } else {
        getOperationManager().addOperationList(operationList);
    }
}
#end_block

#method_before
protected Comparator<T> getDefaultItemComparator() {
    if (defaultItemComparator == null) {
        final Comparator<T> nameComparator = new Comparator<T>() {

            @Override
            public int compare(T a, T b) {
                String name1 = (a instanceof Nameable) ? ((Nameable) a).getName() : null;
                String name2 = (b instanceof Nameable) ? ((Nameable) b).getName() : null;
                return LexoNumericComparator.comp(name1, name2);
            }
        };
        final Comparator<T> idComparator = new Comparator<T>() {

            // inspired by Java 8 Comparators.NullComparator
            private final Comparator<Comparable> nullComparator = new Comparator<Comparable>() {

                private final boolean nullFirst = false;

                @Override
                public int compare(Comparable a, Comparable b) {
                    if (a == null) {
                        return (b == null) ? 0 : (nullFirst ? -1 : 1);
                    } else if (b == null) {
                        return nullFirst ? 1 : -1;
                    } else {
                        return a.compareTo(b);
                    }
                }
            };

            @Override
            public int compare(T a, T b) {
                Object id1 = (a instanceof IVdcQueryable) ? ((IVdcQueryable) a).getQueryableId() : null;
                Object id2 = (b instanceof IVdcQueryable) ? ((IVdcQueryable) b).getQueryableId() : null;
                Comparable idComp1 = (id1 instanceof Comparable) ? (Comparable) id1 : null;
                Comparable idComp2 = (id2 instanceof Comparable) ? (Comparable) id2 : null;
                return nullComparator.compare(idComp1, idComp2);
            }
        };
        // chain comparators like in Java 8 Comparator.thenComparing
        defaultItemComparator = new Comparator<T>() {

            @Override
            public int compare(T a, T b) {
                int res = nameComparator.compare(a, b);
                return (res != 0) ? res : idComparator.compare(a, b);
            }
        };
    }
    return defaultItemComparator;
}
#method_after
protected Comparator<T> getDefaultItemComparator() {
    if (defaultItemComparator == null) {
        final Comparator<T> nameComparator = new Comparator<T>() {

            @Override
            public int compare(T a, T b) {
                String name1 = (a instanceof Nameable) ? ((Nameable) a).getName() : null;
                String name2 = (b instanceof Nameable) ? ((Nameable) b).getName() : null;
                return LexoNumericComparator.comp(name1, name2);
            }
        };
        final Comparator<T> idComparator = new Comparator<T>() {

            // inspired by Java 8 Comparators.NullComparator (nullFirst = false)
            private final Comparator<Comparable> nullComparator = new Comparator<Comparable>() {

                @Override
                public int compare(Comparable a, Comparable b) {
                    if (a == null) {
                        return (b == null) ? 0 : 1;
                    } else if (b == null) {
                        return -1;
                    } else {
                        return a.compareTo(b);
                    }
                }
            };

            @Override
            public int compare(T a, T b) {
                Object id1 = (a instanceof IVdcQueryable) ? ((IVdcQueryable) a).getQueryableId() : null;
                Object id2 = (b instanceof IVdcQueryable) ? ((IVdcQueryable) b).getQueryableId() : null;
                Comparable idComp1 = (id1 instanceof Comparable) ? (Comparable) id1 : null;
                Comparable idComp2 = (id2 instanceof Comparable) ? (Comparable) id2 : null;
                return nullComparator.compare(idComp1, idComp2);
            }
        };
        // chain comparators like in Java 8 Comparator.thenComparing
        defaultItemComparator = new Comparator<T>() {

            @Override
            public int compare(T a, T b) {
                int res = nameComparator.compare(a, b);
                return (res != 0) ? res : idComparator.compare(a, b);
            }
        };
    }
    return defaultItemComparator;
}
#end_block

#method_before
private void refreshReposIfNeeded(Guid storageDomainId, ImageFileType imageType, Boolean forceRefresh) {
    MutableLong lastRefreshed = domainsLastRefreshedTime.computeIfAbsent(storageDomainId, k -> new MutableLong(-1));
    if (shouldForceRefresh(forceRefresh) || shouldInvalidateCache(lastRefreshed.longValue())) {
        synchronized (lastRefreshed) {
            // Double check as another thread might have already finished a refresh and released the lock
            if (forceRefresh || shouldInvalidateCache(lastRefreshed.longValue())) {
                boolean refreshSucceeded = refreshRepos(storageDomainId, imageType);
                lastRefreshed.setValue(System.currentTimeMillis());
                if (!refreshSucceeded) {
                    throw new EngineException(EngineError.IMAGES_NOT_SUPPORTED_ERROR);
                }
            }
        }
    }
}
#method_after
private void refreshReposIfNeeded(Guid storageDomainId, ImageFileType imageType, Boolean forceRefresh) {
    MutableLong lastRefreshed = domainsLastRefreshedTime.computeIfAbsent(storageDomainId, k -> new MutableLong(-1));
    if (shouldForceRefresh(forceRefresh) || shouldInvalidateCache(lastRefreshed.longValue())) {
        synchronized (lastRefreshed) {
            // Double check as another thread might have already finished a refresh and released the lock
            if (shouldForceRefresh(forceRefresh) || shouldInvalidateCache(lastRefreshed.longValue())) {
                boolean refreshSucceeded = refreshRepos(storageDomainId, imageType);
                lastRefreshed.setValue(System.currentTimeMillis());
                if (!refreshSucceeded) {
                    throw new EngineException(EngineError.IMAGES_NOT_SUPPORTED_ERROR);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public Tab addTab(TabData tabData, String historyToken) {
    TabDefinition newTab = createNewTab(tabData);
    newTab.setTargetHistoryToken(historyToken);
    newTab.setText(tabData.getLabel());
    int index = tabLayout.addGroupedTabData(tabData);
    addTabDefinition(newTab, index);
    // Update tabs to show/hide if needed.
    updateTab(newTab);
    return newTab;
}
#method_after
@Override
public Tab addTab(TabData tabData, String historyToken) {
    TabDefinition newTab = createNewTab(tabData);
    newTab.setTargetHistoryToken(historyToken);
    newTab.setText(tabData.getLabel());
    int index = tabLayout.addGroupedTabData(tabData);
    addTabDefinition(newTab, index);
    actualTabWidgets.put(tabData, navTabs.getWidget(index));
    tabHistoryTokens.put(tabData, historyToken);
    // Update tabs to show/hide if needed.
    updateTab(newTab);
    return newTab;
}
#end_block

#method_before
@Override
public void onLoad() {
    super.onLoad();
    keyHandler = Event.addNativePreviewHandler(event -> {
        NativeEvent nativeEvent = event.getNativeEvent();
        if (breadCrumbs != null) {
            if (event.getTypeInt() == Event.ONKEYDOWN) {
                if (nativeEvent.getCharCode() == 's' || nativeEvent.getKeyCode() == KeyCodes.KEY_S) {
                    if (nativeEvent.getCtrlKey() && nativeEvent.getAltKey()) {
                        nativeEvent.preventDefault();
                        nativeEvent.stopPropagation();
                        SimpleTabPanel.this.breadCrumbs.toggleSearch();
                        event.cancel();
                    }
                } else if (!SimpleTabPanel.this.breadCrumbs.isSearchVisible() && nativeEvent.getKeyCode() == KeyCodes.KEY_DOWN) {
                    nativeEvent.preventDefault();
                    nativeEvent.stopPropagation();
                    SimpleTabPanel.this.breadCrumbs.nextEntity();
                    event.cancel();
                } else if (!SimpleTabPanel.this.breadCrumbs.isSearchVisible() && nativeEvent.getKeyCode() == KeyCodes.KEY_UP) {
                    nativeEvent.preventDefault();
                    nativeEvent.stopPropagation();
                    SimpleTabPanel.this.breadCrumbs.previousEntity();
                    event.cancel();
                }
            }
        }
    });
    if (breadCrumbs != null && breadCrumbsContainer.getWidgetCount() == 0) {
        breadCrumbs.asWidget().getElement().getStyle().setHeight(83, Unit.PX);
        breadCrumbsContainer.add(breadCrumbs);
    }
    if (actionPanel != null && mainActionPanel.getWidgetCount() == 0) {
        mainActionPanel.add(actionPanel);
    }
}
#method_after
@Override
public void onLoad() {
    super.onLoad();
    keyHandler = Event.addNativePreviewHandler(event -> {
        NativeEvent nativeEvent = event.getNativeEvent();
        if (breadCrumbs != null) {
            if (event.getTypeInt() == Event.ONKEYDOWN) {
                if (nativeEvent.getCharCode() == 's' || nativeEvent.getKeyCode() == KeyCodes.KEY_S) {
                    if (nativeEvent.getCtrlKey() && nativeEvent.getAltKey()) {
                        nativeEvent.preventDefault();
                        nativeEvent.stopPropagation();
                        SimpleTabPanel.this.breadCrumbs.toggleSearch();
                        event.cancel();
                    }
                } else if (!SimpleTabPanel.this.breadCrumbs.isSearchVisible() && nativeEvent.getKeyCode() == KeyCodes.KEY_DOWN) {
                    nativeEvent.preventDefault();
                    nativeEvent.stopPropagation();
                    SimpleTabPanel.this.breadCrumbs.nextEntity();
                    event.cancel();
                } else if (!SimpleTabPanel.this.breadCrumbs.isSearchVisible() && nativeEvent.getKeyCode() == KeyCodes.KEY_UP) {
                    nativeEvent.preventDefault();
                    nativeEvent.stopPropagation();
                    SimpleTabPanel.this.breadCrumbs.previousEntity();
                    event.cancel();
                }
            }
        }
    });
    if (breadCrumbs != null && breadCrumbsContainer.getWidgetCount() == 0) {
        breadCrumbsContainer.add(breadCrumbs);
    }
    if (actionPanel != null && mainActionPanel.getWidgetCount() == 0) {
        mainActionPanel.add(actionPanel);
    }
}
#end_block

#method_before
@Override
public ActionButton addMenuListItem(ActionButtonDefinition<T> menuItemDef) {
    ActionAnchorListItem menuItem = new ActionAnchorListItem(menuItemDef.getText());
    // Set menu item ID for better accessibility
    String menuItemId = menuItemDef.getUniqueId();
    if (menuItemId != null) {
        menuItem.asWidget().getElement().setId(ElementIdUtils.createElementId(getElementId(), menuItemId));
    }
    actionItemList.put(menuItemDef, menuItem);
    actionKebab.addMenuItem(menuItem);
    return menuItem;
}
#method_after
@Override
public ActionButton addMenuListItem(ActionButtonDefinition<T> menuItemDef) {
    ActionAnchorListItem menuItem = new ActionAnchorListItem(menuItemDef.getText());
    // Set menu item ID for better accessibility
    String menuItemId = menuItemDef.getUniqueId();
    if (menuItemId != null) {
        menuItem.asWidget().getElement().setId(ElementIdUtils.createElementId(getElementId(), menuItemId));
    }
    actionItemMap.put(menuItemDef, menuItem);
    actionKebab.addMenuItem(menuItem);
    return menuItem;
}
#end_block

#method_before
private void initButton(ActionButtonDefinition<T> buttonDef, ActionButton button) {
    button.setText(buttonDef.getText());
    // Set button element ID for better accessibility
    String buttonId = buttonDef.getUniqueId();
    if (buttonId != null) {
        button.asWidget().getElement().setId(ElementIdUtils.createElementId(getElementId(), buttonId));
    }
    // No insert available so need to remove the kebab and then add it at the end.
    actionFormGroup.remove(actionKebab);
    actionFormGroup.add(button);
    actionFormGroup.add(actionKebab);
    actionItemList.put(buttonDef, button);
}
#method_after
private void initButton(ActionButtonDefinition<T> buttonDef, ActionButton button) {
    button.setText(buttonDef.getText());
    // Set button element ID for better accessibility
    String buttonId = buttonDef.getUniqueId();
    if (buttonId != null) {
        button.asWidget().getElement().setId(ElementIdUtils.createElementId(getElementId(), buttonId));
    }
    // No insert available so need to remove the kebab and then add it at the end.
    actionFormGroup.remove(actionKebab);
    actionFormGroup.add(button);
    actionFormGroup.add(actionKebab);
    actionItemMap.put(buttonDef, button);
}
#end_block

#method_before
@Override
public void updateActionButton(boolean isVisible, boolean isEnabled, ActionButtonDefinition<T> buttonDef) {
    ActionButton button = actionItemList.get(buttonDef);
    if (button != null) {
        button.asWidget().setVisible(isVisible);
        button.setEnabled(isEnabled);
        if (buttonDef.getTooltip() != null) {
            // this Panel is special. show the tooltips below the buttons because they're too
            // hard to read with the default TOP placement.
            button.setTooltip(buttonDef.getTooltip(), Placement.BOTTOM);
        }
    }
}
#method_after
@Override
public void updateActionButton(boolean isVisible, boolean isEnabled, ActionButtonDefinition<T> buttonDef) {
    ActionButton button = actionItemMap.get(buttonDef);
    if (button != null) {
        button.asWidget().setVisible(isVisible);
        button.setEnabled(isEnabled);
        if (buttonDef.getTooltip() != null) {
            // this Panel is special. show the tooltips below the buttons because they're too
            // hard to read with the default TOP placement.
            button.setTooltip(buttonDef.getTooltip(), Placement.BOTTOM);
        }
    }
}
#end_block

#method_before
@Override
public void updateMenuItem(boolean isVisible, boolean isEnabled, ActionButtonDefinition<T> menuItemDef) {
    ActionButton item = actionItemList.get(menuItemDef);
    if (item != null) {
        item.asWidget().setVisible(isVisible);
        item.setEnabled(isEnabled);
        if (menuItemDef.getMenuItemTooltip() != null) {
            ElementTooltipUtils.setTooltipOnElement(item.asWidget().getElement(), menuItemDef.getMenuItemTooltip());
        }
    }
    actionKebab.setVisible(anyVisibleListItems());
}
#method_after
@Override
public void updateMenuItem(boolean isVisible, boolean isEnabled, ActionButtonDefinition<T> menuItemDef) {
    ActionButton item = actionItemMap.get(menuItemDef);
    if (item != null) {
        item.asWidget().setVisible(isVisible);
        item.setEnabled(isEnabled);
        if (menuItemDef.getMenuItemTooltip() != null) {
            ElementTooltipUtils.setTooltipOnElement(item.asWidget().getElement(), menuItemDef.getMenuItemTooltip());
        }
    }
    actionKebab.setVisible(anyVisibleListItems());
}
#end_block

#method_before
private boolean anyVisibleListItems() {
    return actionItemList.values().stream().anyMatch(item -> item.asWidget().isVisible());
}
#method_after
private boolean anyVisibleListItems() {
    return actionItemMap.values().stream().anyMatch(item -> item.asWidget().isVisible());
}
#end_block

#method_before
@Override
public boolean hasActionButtons() {
    return !actionItemList.isEmpty();
}
#method_after
@Override
public boolean hasActionButtons() {
    return !actionItemMap.isEmpty();
}
#end_block

#method_before
@Override
public void buildDisk() {
    XmlNode diskSection = selectSingleNode(_document, "//*/DiskSection");
    XmlNodeList list = diskSection != null ? diskSection.selectNodes("Disk") : selectNodes(_document, "//*/Section/Disk");
    for (XmlNode node : list) {
        String diskId = node.attributes.get("ovf:diskId").getValue();
        // oVirt used the diskId as the file id
        XmlAttributeCollection fileAttributes = fileIdToFileAttributes.get(diskId);
        // Accroding to the OVF specification the fileRef should match the file id instead
        if (fileAttributes == null) {
            fileAttributes = fileIdToFileAttributes.get(node.attributes.get("ovf:fileRef").getValue());
        }
        if (fileAttributes == null) {
            // elements in the References section. We don't support it yet.
            continue;
        }
        // If the disk storage type is Cinder then override the disk image with Cinder object,
        // otherwise use the disk image.
        DiskImage image = new DiskImage();
        XmlAttribute diskStorageType = fileAttributes.get("ovf:disk_storage_type");
        if (diskStorageType == null) {
            diskStorageType = node.attributes.get("ovf:disk_storage_type");
        }
        // image.
        if (diskStorageType != null) {
            if (DiskStorageType.CINDER.name().equals(diskStorageType.getValue())) {
                image = new CinderDisk();
                XmlAttribute cinderVolumeType = fileAttributes.get("ovf:cinder_volume_type");
                if (cinderVolumeType == null) {
                    cinderVolumeType = node.attributes.get("ovf:cinder_volume_type");
                }
                if (cinderVolumeType != null) {
                    image.setCinderVolumeType(cinderVolumeType.getValue());
                }
            }
        }
        try {
            image.setImageId(new Guid(diskId));
        } catch (IllegalArgumentException ex) {
            image.setImageId(Guid.newGuid());
        }
        try {
            image.setId(OvfParser.getImageGroupIdFromImageFile(fileAttributes.get("ovf:href").getValue()));
        } catch (IllegalArgumentException ex) {
            image.setId(Guid.newGuid());
        }
        // Default values:
        image.setActive(true);
        image.setImageStatus(ImageStatus.OK);
        XmlAttribute description = fileAttributes.get("ovf:description");
        if (description == null) {
            description = node.attributes.get("ovf:description");
        }
        image.setDescription(description != null ? description.getValue() : diskId);
        image.setDiskVmElements(Collections.singletonList(new DiskVmElement(image.getId(), vmBase.getId())));
        DiskVmElement dve = image.getDiskVmElementForVm(vmBase.getId());
        if (node.attributes.get("ovf:vm_snapshot_id") != null) {
            image.setVmSnapshotId(new Guid(node.attributes.get("ovf:vm_snapshot_id").getValue()));
        }
        XmlAttribute virtualSize = node.attributes.get("ovf:size");
        if (virtualSize == null) {
            virtualSize = node.attributes.get("ovf:capacity");
        // TODO take ovf:capacityAllocationUnits into account
        }
        if (!StringUtils.isEmpty(virtualSize.getValue())) {
            image.setSize(convertGigabyteToBytes(Long.parseLong(virtualSize.getValue())));
        }
        XmlAttribute actualSize = node.attributes.get("ovf:actual_size");
        if (actualSize == null) {
            actualSize = fileAttributes.get("ovf:size");
            // TODO populatedSize in case of compression
            image.setActualSizeInBytes(Long.parseLong(actualSize.getValue()));
        } else {
            if (!StringUtils.isEmpty(actualSize.getValue())) {
                image.setActualSizeInBytes(convertGigabyteToBytes(Long.parseLong(actualSize.getValue())));
            }
        }
        if (node.attributes.get("ovf:volume-format") != null) {
            if (!StringUtils.isEmpty(node.attributes.get("ovf:volume-format").getValue())) {
                image.setVolumeFormat(VolumeFormat.valueOf(node.attributes.get("ovf:volume-format").getValue()));
            } else {
                image.setVolumeFormat(VolumeFormat.Unassigned);
            }
        } else {
            image.setVolumeFormat(VolumeFormat.Unassigned);
        }
        if (node.attributes.get("ovf:volume-type") != null) {
            if (!StringUtils.isEmpty(node.attributes.get("ovf:volume-type").getValue())) {
                image.setVolumeType(VolumeType.valueOf(node.attributes.get("ovf:volume-type").getValue()));
            } else {
                image.setVolumeType(VolumeType.Unassigned);
            }
        } else {
            image.setVolumeType(VolumeType.Unassigned);
        }
        if (node.attributes.get("ovf:disk-interface") != null) {
            if (!StringUtils.isEmpty(node.attributes.get("ovf:disk-interface").getValue())) {
                dve.setDiskInterface(DiskInterface.valueOf(node.attributes.get("ovf:disk-interface").getValue()));
            }
        } else {
            dve.setDiskInterface(DiskInterface.IDE);
        }
        if (node.attributes.get("ovf:boot") != null) {
            if (!StringUtils.isEmpty(node.attributes.get("ovf:boot").getValue())) {
                dve.setBoot(Boolean.parseBoolean(node.attributes.get("ovf:boot").getValue()));
            }
        }
        if (node.attributes.get("ovf:pass-discard") != null) {
            if (!StringUtils.isEmpty(node.attributes.get("ovf:pass-discard").getValue())) {
                dve.setPassDiscard(Boolean.parseBoolean(node.attributes.get("ovf:pass-discard").getValue()));
            }
        }
        if (node.attributes.get("ovf:wipe-after-delete") != null) {
            if (!StringUtils.isEmpty(node.attributes.get("ovf:wipe-after-delete").getValue())) {
                image.setWipeAfterDelete(Boolean.parseBoolean(node.attributes.get("ovf:wipe-after-delete").getValue()));
            }
        }
        if (node.attributes.get("ovf:disk-alias") != null) {
            if (!StringUtils.isEmpty(node.attributes.get("ovf:disk-alias").getValue())) {
                image.setDiskAlias(String.valueOf(node.attributes.get("ovf:disk-alias").getValue()));
            }
        }
        if (node.attributes.get("ovf:disk-description") != null) {
            if (!StringUtils.isEmpty(node.attributes.get("ovf:disk-description").getValue())) {
                image.setDiskDescription(String.valueOf(node.attributes.get("ovf:disk-description").getValue()));
            }
        }
        _images.add(image);
    }
}
#method_after
@Override
public void buildDisk() {
    XmlNode diskSection = selectSingleNode(_document, "//*/DiskSection");
    XmlNodeList list = diskSection != null ? diskSection.selectNodes("Disk") : selectNodes(_document, "//*/Section/Disk");
    for (XmlNode node : list) {
        String diskId = node.attributes.get("ovf:diskId").getValue();
        // oVirt used the diskId as the file id
        XmlAttributeCollection fileAttributes = fileIdToFileAttributes.get(diskId);
        // Accroding to the OVF specification the fileRef should match the file id instead
        if (fileAttributes == null) {
            fileAttributes = fileIdToFileAttributes.get(node.attributes.get("ovf:fileRef").getValue());
        }
        if (fileAttributes == null) {
            // elements in the References section. We don't support it yet.
            continue;
        }
        // If the disk storage type is Cinder then override the disk image with Cinder object,
        // otherwise use the disk image.
        DiskImage image = new DiskImage();
        XmlAttribute diskStorageType = fileAttributes.get("ovf:disk_storage_type");
        if (diskStorageType == null) {
            diskStorageType = node.attributes.get("ovf:disk_storage_type");
        }
        // image.
        if (diskStorageType != null) {
            if (DiskStorageType.CINDER.name().equals(diskStorageType.getValue())) {
                image = new CinderDisk();
                XmlAttribute cinderVolumeType = fileAttributes.get("ovf:cinder_volume_type");
                if (cinderVolumeType == null) {
                    cinderVolumeType = node.attributes.get("ovf:cinder_volume_type");
                }
                if (cinderVolumeType != null) {
                    image.setCinderVolumeType(cinderVolumeType.getValue());
                }
            }
        }
        try {
            image.setImageId(new Guid(diskId));
        } catch (IllegalArgumentException ex) {
            log.warn("could not retrieve volume id of {} from ovf, generating new guid", diskId);
            image.setImageId(Guid.newGuid());
        }
        try {
            image.setId(OvfParser.getImageGroupIdFromImageFile(fileAttributes.get("ovf:href").getValue()));
        } catch (IllegalArgumentException ex) {
            log.warn("could not retrieve disk id of {} from ovf, generating new guid", diskId);
            image.setId(Guid.newGuid());
        }
        // Default values:
        image.setActive(true);
        image.setImageStatus(ImageStatus.OK);
        XmlAttribute description = fileAttributes.get("ovf:description");
        if (description == null) {
            description = node.attributes.get("ovf:description");
        }
        image.setDescription(description != null ? description.getValue() : diskId);
        image.setDiskVmElements(Collections.singletonList(new DiskVmElement(image.getId(), vmBase.getId())));
        DiskVmElement dve = image.getDiskVmElementForVm(vmBase.getId());
        if (node.attributes.get("ovf:vm_snapshot_id") != null) {
            image.setVmSnapshotId(new Guid(node.attributes.get("ovf:vm_snapshot_id").getValue()));
        }
        XmlAttribute virtualSize = node.attributes.get("ovf:size");
        if (virtualSize == null) {
            virtualSize = node.attributes.get("ovf:capacity");
        // TODO take ovf:capacityAllocationUnits into account
        }
        if (!StringUtils.isEmpty(virtualSize.getValue())) {
            image.setSize(convertGigabyteToBytes(Long.parseLong(virtualSize.getValue())));
        }
        XmlAttribute actualSize = node.attributes.get("ovf:actual_size");
        if (actualSize == null) {
            actualSize = fileAttributes.get("ovf:size");
            // TODO populatedSize in case of compression
            image.setActualSizeInBytes(Long.parseLong(actualSize.getValue()));
        } else {
            if (!StringUtils.isEmpty(actualSize.getValue())) {
                image.setActualSizeInBytes(convertGigabyteToBytes(Long.parseLong(actualSize.getValue())));
            }
        }
        if (node.attributes.get("ovf:volume-format") != null) {
            if (!StringUtils.isEmpty(node.attributes.get("ovf:volume-format").getValue())) {
                image.setVolumeFormat(VolumeFormat.valueOf(node.attributes.get("ovf:volume-format").getValue()));
            } else {
                image.setVolumeFormat(VolumeFormat.Unassigned);
            }
        } else {
            image.setVolumeFormat(VolumeFormat.Unassigned);
        }
        if (node.attributes.get("ovf:volume-type") != null) {
            if (!StringUtils.isEmpty(node.attributes.get("ovf:volume-type").getValue())) {
                image.setVolumeType(VolumeType.valueOf(node.attributes.get("ovf:volume-type").getValue()));
            } else {
                image.setVolumeType(VolumeType.Unassigned);
            }
        } else {
            image.setVolumeType(VolumeType.Unassigned);
        }
        if (node.attributes.get("ovf:disk-interface") != null) {
            if (!StringUtils.isEmpty(node.attributes.get("ovf:disk-interface").getValue())) {
                dve.setDiskInterface(DiskInterface.valueOf(node.attributes.get("ovf:disk-interface").getValue()));
            }
        } else {
            dve.setDiskInterface(DiskInterface.IDE);
        }
        if (node.attributes.get("ovf:boot") != null) {
            if (!StringUtils.isEmpty(node.attributes.get("ovf:boot").getValue())) {
                dve.setBoot(Boolean.parseBoolean(node.attributes.get("ovf:boot").getValue()));
            }
        }
        if (node.attributes.get("ovf:pass-discard") != null) {
            if (!StringUtils.isEmpty(node.attributes.get("ovf:pass-discard").getValue())) {
                dve.setPassDiscard(Boolean.parseBoolean(node.attributes.get("ovf:pass-discard").getValue()));
            }
        }
        if (node.attributes.get("ovf:wipe-after-delete") != null) {
            if (!StringUtils.isEmpty(node.attributes.get("ovf:wipe-after-delete").getValue())) {
                image.setWipeAfterDelete(Boolean.parseBoolean(node.attributes.get("ovf:wipe-after-delete").getValue()));
            }
        }
        if (node.attributes.get("ovf:disk-alias") != null) {
            if (!StringUtils.isEmpty(node.attributes.get("ovf:disk-alias").getValue())) {
                image.setDiskAlias(String.valueOf(node.attributes.get("ovf:disk-alias").getValue()));
            }
        }
        if (node.attributes.get("ovf:disk-description") != null) {
            if (!StringUtils.isEmpty(node.attributes.get("ovf:disk-description").getValue())) {
                image.setDiskDescription(String.valueOf(node.attributes.get("ovf:disk-description").getValue()));
            }
        }
        _images.add(image);
    }
}
#end_block

#method_before
@Override
public void render(Context context, String value, SafeHtmlBuilder sb, String id) {
    if (value != null) {
        SafeHtml safeValue = SafeHtmlUtils.fromString(value);
        sb.append(template.containerAndLink(getStyleClass(), getRenderElementId(context), id, safeValue));
    }
}
#method_after
@Override
public void render(Context context, String value, SafeHtmlBuilder sb, String id) {
    if (value != null) {
        SafeHtml safeValue = SafeHtmlUtils.fromString(value);
        sb.append(template.containerAndLink(getStyleClass(), getRenderElementId(context), safeValue));
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
protected void updateData() {
    List<T> items = getModel().getItems() == null ? null : new ArrayList<T>(getModel().getItems());
    if (items != null) {
        // use default item order, unless the items are already sorted
        if (!getModel().hasItemsSorted()) {
            Collections.sort(items, getDefaultItemComparator());
        }
        updateDataProvider(items);
    }
}
#method_after
@SuppressWarnings("unchecked")
protected void updateData() {
    List<T> items = getModel().getItems() == null ? null : new ArrayList<T>(getModel().getItems());
    if (items != null) {
        // use default item order, unless the items are already sorted
        if (!getModel().hasItemsSorted()) {
            items.sort(getDefaultItemComparator());
        }
        updateDataProvider(items);
    }
}
#end_block

#method_before
private void initSelectedSpiceImpl() {
    SpiceConsoleModel spiceModel = model.getVmConsoles().getConsoleModel(SpiceConsoleModel.class);
    if (spiceModel == null) {
        return;
    }
    spiceModel.initConsole();
    spiceModel.initConsole();
}
#method_after
private void initSelectedSpiceImpl() {
    SpiceConsoleModel spiceModel = model.getVmConsoles().getConsoleModel(SpiceConsoleModel.class);
    if (spiceModel == null) {
        return;
    }
    spiceModel.initConsole();
}
#end_block

#method_before
@Override
public void updateTab(TabDefinition tab) {
    super.updateTab(tab);
    if (tabWidgetHandler != null) {
        tabWidgetHandler.updateTab((TabDefinition) tab);
    }
}
#method_after
@Override
public void updateTab(TabDefinition tab) {
    super.updateTab(tab);
    if (tabWidgetHandler != null) {
        tabWidgetHandler.updateTab(tab);
    }
}
#end_block

#method_before
@Override
public void setActiveTab(Tab tab) {
    super.setActiveTab(tab);
    if (tabWidgetHandler != null) {
        tabWidgetHandler.setActiveTab((TabDefinition) tab);
    }
}
#method_after
@Override
public void setActiveTab(Tab tab) {
    super.setActiveTab(tab);
    if (tabWidgetHandler != null && tab instanceof TabDefinition) {
        tabWidgetHandler.setActiveTab((TabDefinition) tab);
    }
}
#end_block

#method_before
public String toString() {
    return ToStringBuilder.forInstance(this).append("label", // $NON-NLS-1$
    getLabel()).append("priority", // $NON-NLS-1$
    getPriority()).append("groupTitle", // $NON-NLS-1$
    groupTitle).append("groupPriority", // $NON-NLS-1$
    groupPriority).toString();
}
#method_after
public String toString() {
    return ToStringBuilder.forInstance(this).append("label", // $NON-NLS-1$
    getLabel()).append("priority", // $NON-NLS-1$
    getPriority()).append("groupTitle", // $NON-NLS-1$
    groupTitle).append("groupPriority", // $NON-NLS-1$
    groupPriority).build();
}
#end_block

#method_before
public void initializeHandlers() {
    // Notify view when the entity of the detail model changes
    modelProvider.getModel().getEntityChangedEvent().addListener((ev, sender, args) -> {
        Object entity = modelProvider.getModel().getEntity();
        if (entity != null) {
            onDetailModelEntityChange(entity);
        }
    });
    // Notify view when the detail model changes its progress or availability
    modelProvider.getModel().getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if (PropertyChangedEventArgs.PROGRESS.equals(args.propertyName)) {
            if (modelProvider.getModel().getProgress() != null) {
                Scheduler.get().scheduleDeferred(() -> {
                    if (getTable() != null) {
                        getTable().setLoadingState(LoadingState.LOADING);
                    }
                });
            }
        } else if ("IsAvailable".equals(args.propertyName)) {
            // $NON-NLS-1$
            D detailModel = modelProvider.getModel();
            SetTabVisibleEvent.fire(AbstractSubTabPresenter.this, resolveTabData(), detailModel.getIsAvailable());
        }
    });
}
#method_after
public void initializeHandlers() {
    // Notify view when the entity of the detail model changes
    modelProvider.getModel().getEntityChangedEvent().addListener((ev, sender, args) -> {
        Object entity = modelProvider.getModel().getEntity();
        if (entity != null) {
            onDetailModelEntityChange(entity);
        }
    });
    // Notify view when the detail model indicates progress
    modelProvider.getModel().getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if (PropertyChangedEventArgs.PROGRESS.equals(args.propertyName)) {
            if (modelProvider.getModel().getProgress() != null) {
                Scheduler.get().scheduleDeferred(() -> {
                    if (getTable() != null) {
                        getTable().setLoadingState(LoadingState.LOADING);
                    }
                });
            }
        }
    });
}
#end_block

#method_before
@Override
protected void onBind() {
    super.onBind();
    registerHandler(getEventBus().addHandler(SetTabVisibleEvent.getType(), event -> {
        getView().setTabVisible(event.getTabData(), event.isTabVisible());
    }));
}
#method_after
@Override
protected void onBind() {
    super.onBind();
    // initialize detail tab to model mappings
    initDetailTabToModelMapping(detailTabToModelMapping);
    // add IsAvailable property change listener for each detail model
    for (Map.Entry<TabData, Model> entry : detailTabToModelMapping.entrySet()) {
        TabData tabData = entry.getKey();
        Model detailModel = entry.getValue();
        detailModel.getPropertyChangedEvent().addListener((ev, sender, args) -> {
            if ("IsAvailable".equals(args.propertyName)) {
                // $NON-NLS-1$
                updateTabVisibility(tabData, detailModel);
            }
        });
    }
}
#end_block

#method_before
@Override
protected void onReveal() {
    super.onReveal();
    // Show sub tab
    UpdateMainContentLayoutEvent.fire(this, UpdateMainContentLayout.ContentDisplayType.SUB, null);
}
#method_after
@Override
protected void onReveal() {
    super.onReveal();
    // Show sub tab
    UpdateMainContentLayoutEvent.fire(this, UpdateMainContentLayout.ContentDisplayType.SUB, null);
    // make sure all detail tabs have their visibility updated
    for (Map.Entry<TabData, Model> entry : detailTabToModelMapping.entrySet()) {
        TabData tabData = entry.getKey();
        Model detailModel = entry.getValue();
        updateTabVisibility(tabData, detailModel);
    }
}
#end_block

#method_before
@Override
public void setTabVisible(TabData tabData, boolean visible) {
    getTabPanel().getTabWidget(tabData).asWidget().setVisible(visible);
}
#method_after
@Override
public void setTabVisible(TabData tabData, boolean visible) {
    getTabPanel().setTabVisible(tabData, visible);
}
#end_block

#method_before
protected String getActiveTabHistoryToken() {
    return this.activeTabHistoryToken;
}
#method_after
protected String getActiveTabHistoryToken() {
    return activeTabHistoryToken;
}
#end_block

#method_before
public static void setNetworkVdsmName(Network network) {
    if (network == null) {
        return;
    }
    String networkName = network.getName();
    Guid networkId = network.getId();
    if (networkName.length() <= BusinessEntitiesDefinitions.HOST_NIC_NAME_LENGTH || networkId == null) {
        network.setVdsmName(networkName);
    } else {
        network.setVdsmName("on" + networkId.toString().replaceAll("[^a-zA-Z0-9]+", "").substring(0, BusinessEntitiesDefinitions.HOST_NIC_NAME_LENGTH - 2));
    }
}
#method_after
public static void setNetworkVdsmName(Network network) {
    String networkName = network.getName();
    if (VALID_VDS_NAME_PATTERN.matcher(networkName).matches()) {
        network.setVdsmName(networkName);
    } else {
        network.setVdsmName("on" + network.getId().toString().replaceAll("[^a-zA-Z0-9]+", "").substring(0, BusinessEntitiesDefinitions.HOST_NIC_NAME_LENGTH - 2));
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getNetwork().setId(Guid.newGuid());
    NetworkUtils.setNetworkVdsmName(getNetwork());
    TransactionSupport.executeInNewTransaction(() -> {
        networkDao.save(getNetwork());
        if (getNetwork().isVmNetwork() && getParameters().isVnicProfileRequired()) {
            vnicProfileDao.save(NetworkHelper.createVnicProfile(getNetwork(), networkFilterDao));
        }
        NetworkHelper.addPermissionsOnNetwork(getCurrentUser().getId(), getNetwork().getId());
        return null;
    });
    getReturnValue().setActionReturnValue(getNetwork().getId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getNetwork().setId(Guid.newGuid());
    NetworkUtils.setNetworkVdsmName(getNetwork());
    TransactionSupport.executeInNewTransaction(() -> {
        networkDao.save(getNetwork());
        if (getNetwork().isVmNetwork() && getParameters().isVnicProfileRequired()) {
            vnicProfileDao.save(networkHelper.createVnicProfile(getNetwork()));
        }
        networkHelper.addPermissionsOnNetwork(getCurrentUser().getId(), getNetwork().getId());
        return null;
    });
    getReturnValue().setActionReturnValue(getNetwork().getId());
    setSucceeded(true);
}
#end_block

#method_before
private List<HostNetwork> calculateNetworksToConfigure() {
    List<HostNetwork> networksToConfigure = new ArrayList<>(getParameters().getNetworkAttachments().size());
    BusinessEntityMap<VdsNetworkInterface> nics = getExistingNicsBusinessEntityMap();
    for (NetworkAttachment attachment : getParameters().getNetworkAttachments()) {
        Network network = existingNetworkRelatedToAttachment(attachment);
        NetworkCluster networkCluster = network.getCluster();
        HostNetwork networkToConfigure = new HostNetwork(network, attachment);
        networkToConfigure.setBonding(isBonding(attachment, nics));
        if (defaultRouteSupported() && networkCluster.isDefaultRoute()) {
            DnsResolverConfiguration dnsResolverConfiguration = getDnsConfigurationFromNetworkOrItsAttachment(attachment, network);
            if (dnsResolverConfiguration != null) {
                networkToConfigure.setNameServers(dnsResolverConfiguration.getNameServers());
            }
            // TODO: YZ - should default route be set separately for IPv4 and IPv6
            networkToConfigure.setDefaultRoute(true);
        }
        if (NetworkUtils.qosConfiguredOnInterface(attachment, network)) {
            networkToConfigure.setQosConfiguredOnInterface(true);
            HostNetworkQos hostNetworkQos = effectiveHostNetworkQos.getQos(attachment, network);
            networkToConfigure.setQos(hostNetworkQos);
        }
        networksToConfigure.add(networkToConfigure);
    }
    return networksToConfigure;
}
#method_after
private List<HostNetwork> calculateNetworksToConfigure() {
    List<HostNetwork> networksToConfigure = new ArrayList<>(getParameters().getNetworkAttachments().size());
    BusinessEntityMap<VdsNetworkInterface> nics = getExistingNicsBusinessEntityMap();
    for (NetworkAttachment attachment : getParameters().getNetworkAttachments()) {
        Network network = existingNetworkRelatedToAttachment(attachment);
        NetworkCluster networkCluster = network.getCluster();
        HostNetwork networkToConfigure = new HostNetwork(network, attachment);
        networkToConfigure.setBonding(isBonding(attachment, nics));
        boolean isDefaultRoute = defaultRouteSupported() && networkCluster.isDefaultRoute();
        if (isDefaultRoute) {
            DnsResolverConfiguration dnsResolverConfiguration = getDnsConfigurationFromNetworkOrItsAttachment(attachment, network);
            if (dnsResolverConfiguration != null) {
                networkToConfigure.setNameServers(dnsResolverConfiguration.getNameServers());
            }
        }
        // TODO: YZ - should default route be set separately for IPv4 and IPv6
        networkToConfigure.setDefaultRoute(isDefaultRoute);
        if (NetworkUtils.qosConfiguredOnInterface(attachment, network)) {
            networkToConfigure.setQosConfiguredOnInterface(true);
            HostNetworkQos hostNetworkQos = effectiveHostNetworkQos.getQos(attachment, network);
            networkToConfigure.setQos(hostNetworkQos);
        }
        networksToConfigure.add(networkToConfigure);
    }
    return networksToConfigure;
}
#end_block

#method_before
public static void updateVDSDynamicData(VDS vds, Map<String, Object> struct) {
    vds.setSupportedClusterLevels(assignStringValueFromArray(struct, VdsProperties.supported_cluster_levels));
    setDnsResolverConfigurationData(vds, struct);
    updateNetworkData(vds, struct);
    updateNumaNodesData(vds, struct);
    vds.setCpuThreads(assignIntValue(struct, VdsProperties.cpuThreads));
    vds.setCpuCores(assignIntValue(struct, VdsProperties.cpu_cores));
    vds.setCpuSockets(assignIntValue(struct, VdsProperties.cpu_sockets));
    vds.setCpuModel(assignStringValue(struct, VdsProperties.cpu_model));
    vds.setOnlineCpus(assignStringValue(struct, VdsProperties.online_cpus));
    vds.setCpuSpeedMh(assignDoubleValue(struct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(assignIntValue(struct, VdsProperties.physical_mem_mb));
    vds.setKernelArgs(assignStringValue(struct, VdsProperties.kernel_args));
    vds.setKvmEnabled(assignBoolValue(struct, VdsProperties.kvm_enabled));
    vds.setReservedMem(assignIntValue(struct, VdsProperties.reservedMem));
    Integer guestOverhead = assignIntValue(struct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(assignStringValue(struct, VdsProperties.cpu_flags));
    updatePackagesVersions(vds, struct);
    vds.setSupportedEngines(assignStringValueFromArray(struct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(assignStringValue(struct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(assignStringValueFromArray(struct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, struct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (struct.containsKey(VdsProperties.hooks)) {
        hooksStr = struct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) struct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(assignLongValue(struct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(assignIntValue(struct, VdsProperties.KDUMP_STATUS)));
    vds.setHostDevicePassthroughEnabled(assignBoolValue(struct, VdsProperties.HOST_DEVICE_PASSTHROUGH));
    Map<String, Object> selinux = (Map<String, Object>) struct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(assignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
    vds.setHostedEngineConfigured(assignBoolValue(struct, VdsProperties.hosted_engine_configured));
    updateAdditionalFeatures(vds, struct);
}
#method_after
public static void updateVDSDynamicData(VDS vds, Map<String, String> vdsmNameMap, Map<String, Object> struct) {
    vds.setSupportedClusterLevels(assignStringValueFromArray(struct, VdsProperties.supported_cluster_levels));
    setDnsResolverConfigurationData(vds, struct);
    updateNetworkData(vds, vdsmNameMap, struct);
    updateNumaNodesData(vds, struct);
    vds.setCpuThreads(assignIntValue(struct, VdsProperties.cpuThreads));
    vds.setCpuCores(assignIntValue(struct, VdsProperties.cpu_cores));
    vds.setCpuSockets(assignIntValue(struct, VdsProperties.cpu_sockets));
    vds.setCpuModel(assignStringValue(struct, VdsProperties.cpu_model));
    vds.setOnlineCpus(assignStringValue(struct, VdsProperties.online_cpus));
    vds.setCpuSpeedMh(assignDoubleValue(struct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(assignIntValue(struct, VdsProperties.physical_mem_mb));
    vds.setKernelArgs(assignStringValue(struct, VdsProperties.kernel_args));
    vds.setKvmEnabled(assignBoolValue(struct, VdsProperties.kvm_enabled));
    vds.setReservedMem(assignIntValue(struct, VdsProperties.reservedMem));
    Integer guestOverhead = assignIntValue(struct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(assignStringValue(struct, VdsProperties.cpu_flags));
    updatePackagesVersions(vds, struct);
    vds.setSupportedEngines(assignStringValueFromArray(struct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(assignStringValue(struct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(assignStringValueFromArray(struct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, struct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (struct.containsKey(VdsProperties.hooks)) {
        hooksStr = struct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) struct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(assignLongValue(struct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(assignIntValue(struct, VdsProperties.KDUMP_STATUS)));
    vds.setHostDevicePassthroughEnabled(assignBoolValue(struct, VdsProperties.HOST_DEVICE_PASSTHROUGH));
    Map<String, Object> selinux = (Map<String, Object>) struct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(assignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
    vds.setHostedEngineConfigured(assignBoolValue(struct, VdsProperties.hosted_engine_configured));
    updateAdditionalFeatures(vds, struct);
}
#end_block

#method_before
public static void updateNetworkData(VDS vds, Map<String, Object> struct) {
    List<VdsNetworkInterface> oldInterfaces = DbFacade.getInstance().getInterfaceDao().getAllInterfacesForVds(vds.getId());
    vds.getInterfaces().clear();
    addHostNetworkInterfaces(vds, struct);
    addHostVlanDevices(vds, struct);
    addHostBondDevices(vds, struct);
    addHostNetworksAndUpdateInterfaces(vds, struct);
    // set bonding options
    setBondingOptions(vds, oldInterfaces);
    // This information was added in 3.1, so don't use it if it's not there.
    if (struct.containsKey(VdsProperties.netConfigDirty)) {
        vds.setNetConfigDirty(assignBoolValue(struct, VdsProperties.netConfigDirty));
    }
}
#method_after
public static void updateNetworkData(VDS vds, Map<String, String> vdsmNameMap, Map<String, Object> struct) {
    List<VdsNetworkInterface> oldInterfaces = DbFacade.getInstance().getInterfaceDao().getAllInterfacesForVds(vds.getId());
    vds.getInterfaces().clear();
    addHostNetworkInterfaces(vds, struct);
    addHostVlanDevices(vds, struct);
    addHostBondDevices(vds, struct);
    addHostNetworksAndUpdateInterfaces(vds, vdsmNameMap, struct);
    // set bonding options
    setBondingOptions(vds, oldInterfaces);
    // This information was added in 3.1, so don't use it if it's not there.
    if (struct.containsKey(VdsProperties.netConfigDirty)) {
        vds.setNetConfigDirty(assignBoolValue(struct, VdsProperties.netConfigDirty));
    }
}
#end_block

#method_before
private static void addHostNetworksAndUpdateInterfaces(VDS host, Map<String, Object> struct) {
    Map<String, Map<String, Object>> bridges = (Map<String, Map<String, Object>>) struct.get(VdsProperties.NETWORK_BRIDGES);
    final String hostActiveNicName = findActiveNicName(host, bridges);
    host.setActiveNic(hostActiveNicName);
    // Networks collection (name point to list of nics or bonds)
    Map<String, Map<String, Object>> networks = (Map<String, Map<String, Object>>) struct.get(VdsProperties.NETWORKS);
    Map<String, VdsNetworkInterface> vdsInterfaces = Entities.entitiesByName(host.getInterfaces());
    if (networks != null) {
        host.getNetworkNames().clear();
        for (Entry<String, Map<String, Object>> entry : networks.entrySet()) {
            Map<String, Object> networkProperties = entry.getValue();
            String vdsmName = entry.getKey();
            String networkName;
            Network network = DbFacade.getInstance().getNetworkDao().getByVdsmName(vdsmName);
            if (network != null) {
                networkName = network.getName();
            } else {
                networkName = vdsmName;
            }
            if (networkProperties != null) {
                String interfaceName = (String) networkProperties.get(VdsProperties.INTERFACE);
                Map<String, Object> bridgeProperties = (bridges == null) ? null : bridges.get(interfaceName);
                boolean bridgedNetwork = isBridgedNetwork(networkProperties);
                SwitchType switchType = getSwitchType(host.getSupportedClusterVersionsSet().stream().sorted().reduce((first, second) -> second).get(), networkProperties);
                HostNetworkQos qos = new HostNetworkQosMapper(networkProperties).deserialize();
                /**
                 * TODO: remove overly-defensive code in 4.0 - IP address, subnet, gateway and boot protocol should
                 * only be extracted for bridged networks and from bridge entries (not network entries)
                 */
                Map<String, Object> effectiveProperties = (bridgedNetwork && bridgeProperties != null) ? bridgeProperties : networkProperties;
                String v4addr = extractAddress(effectiveProperties);
                String v4Subnet = extractSubnet(effectiveProperties);
                String v4gateway = (String) effectiveProperties.get(VdsProperties.GLOBAL_GATEWAY);
                boolean v4DefaultRoute = assignBoolValue(effectiveProperties, VdsProperties.IPV4_DEFAULT_ROUTE);
                final String rawIpv6Address = getIpv6Address(effectiveProperties);
                String v6Addr = extractIpv6Address(rawIpv6Address);
                Integer v6Prefix = extractIpv6Prefix(rawIpv6Address);
                String v6gateway = (String) effectiveProperties.get(VdsProperties.IPV6_GLOBAL_GATEWAY);
                List<VdsNetworkInterface> interfaces = findNetworkInterfaces(vdsInterfaces, interfaceName, bridgeProperties);
                for (VdsNetworkInterface iface : interfaces) {
                    iface.setNetworkName(networkName);
                    iface.setIpv4Address(v4addr);
                    iface.setIpv4Subnet(v4Subnet);
                    iface.setIpv4DefaultRoute(v4DefaultRoute);
                    iface.setIpv6Address(v6Addr);
                    iface.setIpv6Prefix(v6Prefix);
                    iface.setBridged(bridgedNetwork);
                    iface.setReportedSwitchType(switchType);
                    iface.setQos(qos);
                    // set the management ip
                    if (getManagementNetworkUtil().isManagementNetwork(iface.getNetworkName(), host.getClusterId())) {
                        iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
                    }
                    iface.setIpv4Gateway(v4gateway);
                    iface.setIpv6Gateway(v6gateway);
                    if (bridgedNetwork) {
                        addBootProtocol(effectiveProperties, iface);
                    }
                }
                host.getNetworkNames().add(networkName);
                reportInvalidInterfacesForNetwork(interfaces, networkName, host);
            }
        }
    }
}
#method_after
private static void addHostNetworksAndUpdateInterfaces(VDS host, Map<String, String> vdsmNameMap, Map<String, Object> struct) {
    Map<String, Map<String, Object>> bridges = (Map<String, Map<String, Object>>) struct.get(VdsProperties.NETWORK_BRIDGES);
    final String hostActiveNicName = findActiveNicName(host, bridges);
    host.setActiveNic(hostActiveNicName);
    // Networks collection (name point to list of nics or bonds)
    Map<String, Map<String, Object>> networks = (Map<String, Map<String, Object>>) struct.get(VdsProperties.NETWORKS);
    Map<String, VdsNetworkInterface> vdsInterfaces = Entities.entitiesByName(host.getInterfaces());
    if (networks != null) {
        host.getNetworkNames().clear();
        for (Entry<String, Map<String, Object>> entry : networks.entrySet()) {
            Map<String, Object> networkProperties = entry.getValue();
            String vdsmName = entry.getKey();
            String networkName = vdsmNameMap.containsKey(vdsmName) ? vdsmNameMap.get(vdsmName) : vdsmName;
            if (networkProperties != null) {
                String interfaceName = (String) networkProperties.get(VdsProperties.INTERFACE);
                Map<String, Object> bridgeProperties = (bridges == null) ? null : bridges.get(interfaceName);
                boolean bridgedNetwork = isBridgedNetwork(networkProperties);
                SwitchType switchType = getSwitchType(host.getSupportedClusterVersionsSet().stream().sorted().reduce((first, second) -> second).get(), networkProperties);
                HostNetworkQos qos = new HostNetworkQosMapper(networkProperties).deserialize();
                /**
                 * TODO: remove overly-defensive code in 4.0 - IP address, subnet, gateway and boot protocol should
                 * only be extracted for bridged networks and from bridge entries (not network entries)
                 */
                Map<String, Object> effectiveProperties = (bridgedNetwork && bridgeProperties != null) ? bridgeProperties : networkProperties;
                String v4addr = extractAddress(effectiveProperties);
                String v4Subnet = extractSubnet(effectiveProperties);
                String v4gateway = (String) effectiveProperties.get(VdsProperties.GLOBAL_GATEWAY);
                boolean v4DefaultRoute = assignBoolValue(effectiveProperties, VdsProperties.IPV4_DEFAULT_ROUTE);
                final String rawIpv6Address = getIpv6Address(effectiveProperties);
                String v6Addr = extractIpv6Address(rawIpv6Address);
                Integer v6Prefix = extractIpv6Prefix(rawIpv6Address);
                String v6gateway = (String) effectiveProperties.get(VdsProperties.IPV6_GLOBAL_GATEWAY);
                List<VdsNetworkInterface> interfaces = findNetworkInterfaces(vdsInterfaces, interfaceName, bridgeProperties);
                for (VdsNetworkInterface iface : interfaces) {
                    iface.setNetworkName(networkName);
                    iface.setIpv4Address(v4addr);
                    iface.setIpv4Subnet(v4Subnet);
                    iface.setIpv4DefaultRoute(v4DefaultRoute);
                    iface.setIpv6Address(v6Addr);
                    iface.setIpv6Prefix(v6Prefix);
                    iface.setBridged(bridgedNetwork);
                    iface.setReportedSwitchType(switchType);
                    iface.setQos(qos);
                    // set the management ip
                    if (getManagementNetworkUtil().isManagementNetwork(iface.getNetworkName(), host.getClusterId())) {
                        iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
                    }
                    iface.setIpv4Gateway(v4gateway);
                    iface.setIpv6Gateway(v6gateway);
                    if (bridgedNetwork) {
                        addBootProtocol(effectiveProperties, iface);
                    }
                }
                host.getNetworkNames().add(networkName);
                reportInvalidInterfacesForNetwork(interfaces, networkName, host);
            }
        }
    }
}
#end_block

#method_before
@Override
public String toString() {
    return ToStringBuilder.forInstance(this).append("id", getId()).append("description", getDescription()).append("comment", getComment()).append("subnet", getSubnet()).append("gateway", getGateway()).append("type", getType()).append("vlanId", getVlanId()).append("stp", getStp()).append("dataCenterId", getDataCenterId()).append("mtu", getMtu()).append("vmNetwork", isVmNetwork()).append("cluster", getCluster()).append("providedBy", getProvidedBy()).append("label", getLabel()).append("qosId", getQosId()).append("dnsResolverConfiguration", dnsResolverConfiguration).build();
}
#method_after
@Override
public String toString() {
    return ToStringBuilder.forInstance(this).append("id", getId()).append("description", getDescription()).append("comment", getComment()).append("vdsmName", getVdsmName()).append("subnet", getSubnet()).append("gateway", getGateway()).append("type", getType()).append("vlanId", getVlanId()).append("stp", getStp()).append("dataCenterId", getDataCenterId()).append("mtu", getMtu()).append("vmNetwork", isVmNetwork()).append("cluster", getCluster()).append("providedBy", getProvidedBy()).append("label", getLabel()).append("qosId", getQosId()).append("dnsResolverConfiguration", dnsResolverConfiguration).build();
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(addr, // cluster,
    description, gateway, id, name, dataCenterId, stp, subnet, type, vlanId, mtu, vmNetwork, providedBy, label, qosId, dnsResolverConfiguration);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(addr, // cluster,
    description, gateway, id, name, vdsmName, dataCenterId, stp, subnet, type, vlanId, mtu, vmNetwork, providedBy, label, qosId, dnsResolverConfiguration);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof Network)) {
        return false;
    }
    Network other = (Network) obj;
    return Objects.equals(addr, other.addr) && // && Objects.equals(cluster, other.cluster)
    Objects.equals(description, other.description) && Objects.equals(gateway, other.gateway) && Objects.equals(id, other.id) && Objects.equals(name, other.name) && Objects.equals(dataCenterId, other.dataCenterId) && stp == other.stp && Objects.equals(subnet, other.subnet) && Objects.equals(type, other.type) && Objects.equals(vlanId, other.vlanId) && mtu == other.mtu && vmNetwork == other.vmNetwork && Objects.equals(providedBy, other.providedBy) && Objects.equals(label, other.label) && Objects.equals(qosId, other.qosId) && Objects.equals(dnsResolverConfiguration, other.dnsResolverConfiguration);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof Network)) {
        return false;
    }
    Network other = (Network) obj;
    return Objects.equals(addr, other.addr) && // && Objects.equals(cluster, other.cluster)
    Objects.equals(description, other.description) && Objects.equals(gateway, other.gateway) && Objects.equals(id, other.id) && Objects.equals(name, other.name) && Objects.equals(vdsmName, other.vdsmName) && Objects.equals(dataCenterId, other.dataCenterId) && stp == other.stp && Objects.equals(subnet, other.subnet) && Objects.equals(type, other.type) && Objects.equals(vlanId, other.vlanId) && mtu == other.mtu && vmNetwork == other.vmNetwork && Objects.equals(providedBy, other.providedBy) && Objects.equals(label, other.label) && Objects.equals(qosId, other.qosId) && Objects.equals(dnsResolverConfiguration, other.dnsResolverConfiguration);
}
#end_block

#method_before
@Before
public void setUp() {
    diskImage.setDiskProfileId(Guid.newGuid());
    qos = new StorageQos();
    qos.setId(Guid.newGuid());
    vmDevice = new VmDevice();
    VnicProfile vnicProfile = new VnicProfile();
    vnicProfile.setNetworkFilterId(NETWORK_FILTER_ID);
    when(vnicProfileDao.get(VNIC_PROFILE_ID)).thenReturn(vnicProfile);
    NetworkFilter networkFilter = new NetworkFilter();
    networkFilter.setName(NETWORK_FILTER_NAME);
    when(networkFilterDao.getNetworkFilterById(NETWORK_FILTER_ID)).thenReturn(networkFilter);
    when(vmNicFilterParameterDao.getAllForVmNic(VM_NIC_ID)).thenReturn(createVmNicFilterParameters());
}
#method_after
@Before
public void setUp() {
    injectorRule.bind(AuditLogDirector.class, auditLogDirector);
    diskImage.setDiskProfileId(Guid.newGuid());
    qos = new StorageQos();
    qos.setId(Guid.newGuid());
    vmDevice = new VmDevice();
    VnicProfile vnicProfile = new VnicProfile();
    vnicProfile.setNetworkFilterId(NETWORK_FILTER_ID);
    when(vnicProfileDao.get(VNIC_PROFILE_ID)).thenReturn(vnicProfile);
    NetworkFilter networkFilter = new NetworkFilter();
    networkFilter.setName(NETWORK_FILTER_NAME);
    when(networkFilterDao.getNetworkFilterById(NETWORK_FILTER_ID)).thenReturn(networkFilter);
    when(vmNicFilterParameterDao.getAllForVmNic(VM_NIC_ID)).thenReturn(createVmNicFilterParameters());
}
#end_block

#method_before
@Test
public void testGetVmDeviceUnitMapForScsiDisks() {
    VmDevice lunDiskVmDevice = new VmDevice(new VmDeviceId(LUN_DISK_ID, VM_ID), VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName(), "", 1, null, true, true, null, "", null, null, null);
    VmDevice diskImageVmDevice = new VmDevice(new VmDeviceId(DISK_IMAGE_ID, VM_ID), VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName(), "", 0, null, true, true, null, "", null, null, null);
    VM vm = new VM();
    vm.setId(VM_ID);
    vm.setDiskMap(mockUnsortedDisksMap(lunDiskVmDevice, diskImageVmDevice));
    Map<VmDevice, Integer> vmDeviceUnitMap = underTest.getVmDeviceUnitMapForScsiDisks(vm, DiskInterface.VirtIO_SCSI, false);
    // Ensures that the boot disk unit is lower
    assertEquals(vmDeviceUnitMap.get(lunDiskVmDevice), (Integer) 1);
    assertEquals(vmDeviceUnitMap.get(diskImageVmDevice), (Integer) 0);
}
#method_after
@Test
public void testGetVmDeviceUnitMapForScsiDisks() {
    VmDevice lunDiskVmDevice = new VmDevice(new VmDeviceId(LUN_DISK_ID, VM_ID), VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName(), "", null, true, true, null, "", null, null, null);
    VmDevice diskImageVmDevice = new VmDevice(new VmDeviceId(DISK_IMAGE_ID, VM_ID), VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName(), "", null, true, true, null, "", null, null, null);
    VM vm = new VM();
    vm.setId(VM_ID);
    vm.setDiskMap(mockUnsortedDisksMap(lunDiskVmDevice, diskImageVmDevice));
    vm.setClusterArch(ArchitectureType.x86_64);
    vm.setClusterCompatibilityVersion(Version.v4_1);
    Map<Integer, Map<VmDevice, Integer>> vmDeviceUnitMap = underTest.getVmDeviceUnitMapForScsiDisks(vm, DiskInterface.VirtIO_SCSI, false);
    // Ensures that the boot disk unit is lower
    assertEquals(vmDeviceUnitMap.get(0).get(lunDiskVmDevice), (Integer) 1);
    assertEquals(vmDeviceUnitMap.get(0).get(diskImageVmDevice), (Integer) 0);
}
#end_block

#method_before
public Map<VmDevice, Integer> getVmDeviceUnitMapForVirtioScsiDisks(VM vm) {
    return getVmDeviceUnitMapForScsiDisks(vm, DiskInterface.VirtIO_SCSI, false);
}
#method_after
public Map<Integer, Map<VmDevice, Integer>> getVmDeviceUnitMapForVirtioScsiDisks(VM vm) {
    return getVmDeviceUnitMapForScsiDisks(vm, DiskInterface.VirtIO_SCSI, false);
}
#end_block

#method_before
public Map<VmDevice, Integer> getVmDeviceUnitMapForSpaprScsiDisks(VM vm) {
    return getVmDeviceUnitMapForScsiDisks(vm, DiskInterface.SPAPR_VSCSI, true);
}
#method_after
public Map<Integer, Map<VmDevice, Integer>> getVmDeviceUnitMapForSpaprScsiDisks(VM vm) {
    return getVmDeviceUnitMapForScsiDisks(vm, DiskInterface.SPAPR_VSCSI, true);
}
#end_block

#method_before
protected Map<VmDevice, Integer> getVmDeviceUnitMapForScsiDisks(VM vm, DiskInterface scsiInterface, boolean reserveFirstTwoLuns) {
    List<Disk> disks = getSortedDisks(vm);
    Map<VmDevice, Integer> vmDeviceUnitMap = new HashMap<>();
    LinkedList<VmDevice> vmDeviceList = new LinkedList<>();
    for (Disk disk : disks) {
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        if (dve.getDiskInterface() == scsiInterface) {
            VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
            Map<String, String> address = StringMapUtils.string2Map(vmDevice.getAddress());
            String unitStr = address.get(VdsProperties.Unit);
            // Otherwise, adding to 'vmDeviceList' for setting the unit property later.
            if (StringUtils.isNotEmpty(unitStr)) {
                vmDeviceUnitMap.put(vmDevice, Integer.valueOf(unitStr));
            } else {
                vmDeviceList.add(vmDevice);
            }
        }
    }
    // Find available unit (disk's index in VirtIO-SCSI controller) for disks with empty address
    vmDeviceList.forEach(vmDevice -> {
        int unit = getAvailableUnitForScsiDisk(vmDeviceUnitMap, reserveFirstTwoLuns);
        vmDeviceUnitMap.put(vmDevice, unit);
    });
    return vmDeviceUnitMap;
}
#method_after
protected Map<Integer, Map<VmDevice, Integer>> getVmDeviceUnitMapForScsiDisks(VM vm, DiskInterface scsiInterface, boolean reserveFirstTwoLuns) {
    List<Disk> disks = getSortedDisks(vm);
    Map<Integer, Map<VmDevice, Integer>> vmDeviceUnitMap = new HashMap<>();
    LinkedList<VmDevice> vmDeviceList = new LinkedList<>();
    for (Disk disk : disks) {
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        if (dve.getDiskInterface() == scsiInterface) {
            VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
            Map<String, String> address = StringMapUtils.string2Map(vmDevice.getAddress());
            String unitStr = address.get(VdsProperties.Unit);
            String controllerStr = address.get(VdsProperties.Controller);
            // Otherwise, adding to 'vmDeviceList' for setting the unit property later.
            if (StringUtils.isNotEmpty(unitStr) && StringUtils.isNotEmpty(controllerStr)) {
                Integer controllerInt = Integer.valueOf(controllerStr);
                boolean controllerOutOfRange = controllerInt >= vm.getNumOfIoThreads() + getDefaultVirtioScsiIndex(vm);
                boolean ioThreadsEnabled = vm.getNumOfIoThreads() > 0 && FeatureSupported.virtioScsiIoThread(vm.getCompatibilityVersion());
                if ((ioThreadsEnabled && !controllerOutOfRange) || (controllerInt == getDefaultVirtioScsiIndex(vm))) {
                    if (!vmDeviceUnitMap.containsKey(controllerInt)) {
                        vmDeviceUnitMap.put(controllerInt, new HashMap<>());
                    }
                    vmDeviceUnitMap.get(controllerInt).put(vmDevice, Integer.valueOf(unitStr));
                } else {
                    // controller id not correct, generate the address again later
                    vmDevice.setAddress(null);
                    vmDeviceList.add(vmDevice);
                }
            } else {
                vmDeviceList.add(vmDevice);
            }
        }
    }
    // Find available unit (disk's index in VirtIO-SCSI controller) for disks with empty address\
    IntStream.range(0, vmDeviceList.size()).forEach(index -> {
        VmDevice vmDevice = vmDeviceList.get(index);
        int controller = getControllerForScsiDisk(vmDevice, vm, index);
        if (!vmDeviceUnitMap.containsKey(controller)) {
            vmDeviceUnitMap.put(controller, new HashMap<>());
        }
        int unit = getAvailableUnitForScsiDisk(vmDeviceUnitMap.get(controller), reserveFirstTwoLuns);
        vmDeviceUnitMap.get(controller).put(vmDevice, unit);
    });
    return vmDeviceUnitMap;
}
#end_block

#method_before
public List<Disk> getSortedDisks(VM vm) {
    // order first by drive numbers and then order by boot for the bootable
    // drive to be first (important for IDE to be index 0) !
    List<Disk> disks = new ArrayList<>(vm.getDiskMap().values());
    Collections.sort(disks, new DiskByDiskAliasComparator());
    Collections.sort(disks, Collections.reverseOrder(new DiskByBootAndSnapshotComparator(vm.getId())));
    return disks;
}
#method_after
public List<Disk> getSortedDisks(VM vm) {
    // order first by drive numbers and then order by boot for the bootable
    // drive to be first (important for IDE to be index 0) !
    List<Disk> disks = new ArrayList<>(vm.getDiskMap().values());
    Collections.sort(disks, new LexoNumericNameableComparator<>());
    Collections.sort(disks, Collections.reverseOrder(new DiskByBootAndSnapshotComparator(vm.getId())));
    return disks;
}
#end_block

#method_before
public int getAvailableUnitForScsiDisk(Map<VmDevice, Integer> vmDeviceUnitMap, boolean reserveFirstTwoLuns) {
    int unit = reserveFirstTwoLuns ? 2 : 0;
    while (vmDeviceUnitMap.containsValue(unit)) {
        unit++;
    }
    return unit;
}
#method_after
public int getAvailableUnitForScsiDisk(Map<VmDevice, Integer> vmDeviceUnitMap, boolean reserveFirstTwoLuns) {
    int unit = reserveFirstTwoLuns ? 2 : 0;
    if (vmDeviceUnitMap == null) {
        return unit;
    }
    while (vmDeviceUnitMap.containsValue(unit)) {
        unit++;
    }
    return unit;
}
#end_block

#method_before
private void reportUnsupportedVnicProfileFeatures(VM vm, VmNic nic, VnicProfile vnicProfile, List<VnicProfileProperties> unsupportedFeatures) {
    if (unsupportedFeatures.isEmpty()) {
        return;
    }
    AuditLogableBase event = Injector.injectMembers(new AuditLogableBase());
    event.setVmId(vm.getId());
    event.setClusterId(vm.getClusterId());
    event.setCustomId(nic.getId().toString());
    event.setCompatibilityVersion(vm.getCompatibilityVersion().toString());
    event.addCustomValue("NicName", nic.getName());
    event.addCustomValue("VnicProfile", vnicProfile == null ? null : vnicProfile.getName());
    String[] unsupportedFeatureNames = new String[unsupportedFeatures.size()];
    for (int i = 0; i < unsupportedFeatures.size(); i++) {
        unsupportedFeatureNames[i] = unsupportedFeatures.get(i).getFeatureName();
    }
    event.addCustomValue("UnsupportedFeatures", StringUtils.join(unsupportedFeatureNames, ", "));
    new AuditLogDirector().log(event, AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES);
}
#method_after
private void reportUnsupportedVnicProfileFeatures(VM vm, VmNic nic, VnicProfile vnicProfile, List<VnicProfileProperties> unsupportedFeatures) {
    if (unsupportedFeatures.isEmpty()) {
        return;
    }
    AuditLogable event = new AuditLogableImpl();
    event.setVmId(vm.getId());
    event.setVmName(vm.getName());
    event.setClusterId(vm.getClusterId());
    event.setClusterName(vm.getClusterName());
    event.setCustomId(nic.getId().toString());
    event.setCompatibilityVersion(vm.getCompatibilityVersion().toString());
    event.addCustomValue("NicName", nic.getName());
    event.addCustomValue("VnicProfile", vnicProfile == null ? null : vnicProfile.getName());
    String[] unsupportedFeatureNames = new String[unsupportedFeatures.size()];
    for (int i = 0; i < unsupportedFeatures.size(); i++) {
        unsupportedFeatureNames[i] = unsupportedFeatures.get(i).getFeatureName();
    }
    event.addCustomValue("UnsupportedFeatures", StringUtils.join(unsupportedFeatureNames, ", "));
    auditLogDirector.log(event, AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES);
}
#end_block

#method_before
private boolean isFeatureSupportedAsAdditionalFeature(Guid clusterId, String featureName) {
    Set<SupportedAdditionalClusterFeature> addtionalFeaturesSupported = clusterFeatureDao.getSupportedFeaturesByClusterId(clusterId);
    for (SupportedAdditionalClusterFeature supportedFeature : addtionalFeaturesSupported) {
        if (supportedFeature.getFeature().getName().equalsIgnoreCase(featureName)) {
            return supportedFeature.isEnabled();
        }
    }
    return false;
}
#method_after
private boolean isFeatureSupportedAsAdditionalFeature(Guid clusterId, String featureName) {
    return clusterFeatureDao.getSupportedFeaturesByClusterId(clusterId).stream().filter(SupportedAdditionalClusterFeature::isEnabled).filter(f -> f.getFeature().getName().equals(featureName)).findAny().isPresent();
}
#end_block

#method_before
public static boolean supportedInConfig(ConfigValues feature, Version version, ArchitectureType arch) {
    return Boolean.parseBoolean(((Map<String, String>) Config.<Map>getValue(feature, version.getValue())).get(arch.name()));
}
#method_after
public static boolean supportedInConfig(ConfigValues feature, Version version, ArchitectureType arch) {
    Map<String, String> archOptions = Config.<Map>getValue(feature, version.getValue());
    String value = archOptions.get(arch.name());
    if (value == null) {
        value = archOptions.get(arch.getFamily().name());
    }
    return Boolean.parseBoolean(value);
}
#end_block

#method_before
public void setDiscardAfterDelete(boolean discardAfterDelete) {
    this.discardAfterDelete = discardAfterDelete;
}
#method_after
public void setDiscardAfterDelete(Boolean discardAfterDelete) {
    this.discardAfterDelete = discardAfterDelete;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(id, autoRecoverable, connection, name, storage, storageFormat, storagePoolType, storageType, description, sanState, wipeAfterDelete, discardAfterDelete, firstMetadataDevice, vgMetadataDevice, warningLowSpaceIndicator, criticalSpaceActionBlocker, useForBackup);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(id, autoRecoverable, connection, name, storage, storageFormat, storagePoolType, storageType, description, sanState, wipeAfterDelete, discardAfterDelete, firstMetadataDevice, vgMetadataDevice, warningLowSpaceIndicator, criticalSpaceActionBlocker, backup);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof StorageDomainStatic)) {
        return false;
    }
    StorageDomainStatic other = (StorageDomainStatic) obj;
    return Objects.equals(id, other.id) && autoRecoverable == other.autoRecoverable && Objects.equals(connection, other.connection) && Objects.equals(name, other.name) && Objects.equals(storage, other.storage) && storageFormat == other.storageFormat && storagePoolType == other.storagePoolType && storageType == other.storageType && sanState == other.sanState && Objects.equals(wipeAfterDelete, other.wipeAfterDelete) && discardAfterDelete == other.discardAfterDelete && Objects.equals(firstMetadataDevice, other.firstMetadataDevice) && Objects.equals(vgMetadataDevice, other.vgMetadataDevice) && Objects.equals(description, other.description) && Objects.equals(warningLowSpaceIndicator, other.warningLowSpaceIndicator) && Objects.equals(criticalSpaceActionBlocker, other.criticalSpaceActionBlocker) && Objects.equals(useForBackup, other.useForBackup);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof StorageDomainStatic)) {
        return false;
    }
    StorageDomainStatic other = (StorageDomainStatic) obj;
    return Objects.equals(id, other.id) && autoRecoverable == other.autoRecoverable && Objects.equals(connection, other.connection) && Objects.equals(name, other.name) && Objects.equals(storage, other.storage) && storageFormat == other.storageFormat && storagePoolType == other.storagePoolType && storageType == other.storageType && sanState == other.sanState && Objects.equals(wipeAfterDelete, other.wipeAfterDelete) && Objects.equals(discardAfterDelete, other.discardAfterDelete) && Objects.equals(firstMetadataDevice, other.firstMetadataDevice) && Objects.equals(vgMetadataDevice, other.vgMetadataDevice) && Objects.equals(description, other.description) && Objects.equals(warningLowSpaceIndicator, other.warningLowSpaceIndicator) && Objects.equals(criticalSpaceActionBlocker, other.criticalSpaceActionBlocker) && Objects.equals(backup, other.backup);
}
#end_block

#method_before
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVdsList(instance.getDedicatedVmForVdsList());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.getGraphicsInfos().putAll(instance.getGraphicsInfos());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setExitReason(instance.getExitReason());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setClusterCompatibilityVersion(instance.getClusterCompatibilityVersion());
    vm.setClusterId(instance.getClusterId());
    vm.setClusterName(instance.getClusterName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setCustomEmulatedMachine(instance.getCustomEmulatedMachine());
    vm.setCustomCpuName(instance.getCustomCpuName());
    vm.setCustomCompatibilityVersion(instance.getCustomCompatibilityVersion());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setIp(instance.getIp());
    vm.setFqdn(instance.getFqdn());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    vm.setMigrationDowntime(instance.getMigrationDowntime());
    vm.setUseLatestVersion(instance.isUseLatestVersion());
    vm.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    vm.setCustomSerialNumber(instance.getCustomSerialNumber());
    vm.setBootMenuEnabled(instance.isBootMenuEnabled());
    vm.setSpiceFileTransferEnabled(instance.isSpiceFileTransferEnabled());
    vm.setSpiceCopyPasteEnabled(instance.isSpiceCopyPasteEnabled());
    vm.setCpuProfileId(instance.getCpuProfileId());
    vm.setAutoConverge(instance.getAutoConverge());
    vm.setMigrateCompressed(instance.getMigrateCompressed());
    vm.setPredefinedProperties(instance.getPredefinedProperties());
    vm.setUserDefinedProperties(instance.getUserDefinedProperties());
    vm.setCustomProperties(instance.getCustomProperties());
    vm.setSingleQxlPci(instance.getSingleQxlPci());
    vm.setMinAllocatedMem(instance.getMinAllocatedMem());
    vm.setGuestOsArch(instance.getGuestOsArch());
    vm.setGuestOsCodename(instance.getGuestOsCodename());
    vm.setGuestOsDistribution(instance.getGuestOsDistribution());
    vm.setGuestOsKernelVersion(instance.getGuestOsKernelVersion());
    vm.setGuestOsType(instance.getGuestOsType());
    vm.setGuestOsVersion(instance.getGuestOsVersion());
    vm.setGuestOsTimezoneName(instance.getGuestOsTimezoneName());
    vm.setGuestOsTimezoneOffset(instance.getGuestOsTimezoneOffset());
    vm.setQuotaId(instance.getQuotaId());
    vm.setQuotaName(instance.getQuotaName());
    return vm;
}
#method_after
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVdsList(instance.getDedicatedVmForVdsList());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.getGraphicsInfos().putAll(instance.getGraphicsInfos());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setExitReason(instance.getExitReason());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setClusterCompatibilityVersion(instance.getClusterCompatibilityVersion());
    vm.setClusterId(instance.getClusterId());
    vm.setClusterName(instance.getClusterName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setCustomEmulatedMachine(instance.getCustomEmulatedMachine());
    vm.setCustomCpuName(instance.getCustomCpuName());
    vm.setCustomCompatibilityVersion(instance.getCustomCompatibilityVersion());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setIp(instance.getIp());
    vm.setFqdn(instance.getFqdn());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    vm.setMigrationDowntime(instance.getMigrationDowntime());
    vm.setUseLatestVersion(instance.isUseLatestVersion());
    vm.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    vm.setCustomSerialNumber(instance.getCustomSerialNumber());
    vm.setBootMenuEnabled(instance.isBootMenuEnabled());
    vm.setSpiceFileTransferEnabled(instance.isSpiceFileTransferEnabled());
    vm.setSpiceCopyPasteEnabled(instance.isSpiceCopyPasteEnabled());
    vm.setCpuProfileId(instance.getCpuProfileId());
    vm.setAutoConverge(instance.getAutoConverge());
    vm.setMigrateCompressed(instance.getMigrateCompressed());
    vm.setPredefinedProperties(instance.getPredefinedProperties());
    vm.setUserDefinedProperties(instance.getUserDefinedProperties());
    vm.setCustomProperties(instance.getCustomProperties());
    vm.setSingleQxlPci(instance.getSingleQxlPci());
    vm.setMinAllocatedMem(instance.getMinAllocatedMem());
    vm.setGuestOsArch(instance.getGuestOsArch());
    vm.setGuestOsCodename(instance.getGuestOsCodename());
    vm.setGuestOsDistribution(instance.getGuestOsDistribution());
    vm.setGuestOsKernelVersion(instance.getGuestOsKernelVersion());
    vm.setGuestOsType(instance.getGuestOsType());
    vm.setGuestOsVersion(instance.getGuestOsVersion());
    vm.setGuestOsTimezoneName(instance.getGuestOsTimezoneName());
    vm.setGuestOsTimezoneOffset(instance.getGuestOsTimezoneOffset());
    vm.setQuotaId(instance.getQuotaId());
    vm.setQuotaName(instance.getQuotaName());
    return vm;
}
#end_block

#method_before
private static StorageDomainStatic cloneStorageDomainStatic(StorageDomainStatic instance) {
    StorageDomainStatic obj = new StorageDomainStatic();
    obj.setConnection(instance.getConnection());
    obj.setId(instance.getId());
    obj.setStorage(instance.getStorage());
    obj.setStorageDomainType(instance.getStorageDomainType());
    obj.setStorageType(instance.getStorageType());
    obj.setStorageName(instance.getStorageName());
    obj.setFirstMetadataDevice(instance.getFirstMetadataDevice());
    obj.setVgMetadataDevice(instance.getVgMetadataDevice());
    obj.setDescription(instance.getDescription());
    obj.setComment(instance.getComment());
    obj.setStorageFormat(instance.getStorageFormat());
    obj.setWipeAfterDelete(instance.getWipeAfterDelete());
    obj.setDiscardAfterDelete(instance.isDiscardAfterDelete());
    obj.setWarningLowSpaceIndicator(instance.getWarningLowSpaceIndicator());
    obj.setCriticalSpaceActionBlocker(instance.getCriticalSpaceActionBlocker());
    obj.setUseForBackup(instance.getUseForBackup());
    return obj;
}
#method_after
private static StorageDomainStatic cloneStorageDomainStatic(StorageDomainStatic instance) {
    StorageDomainStatic obj = new StorageDomainStatic();
    obj.setConnection(instance.getConnection());
    obj.setId(instance.getId());
    obj.setStorage(instance.getStorage());
    obj.setStorageDomainType(instance.getStorageDomainType());
    obj.setStorageType(instance.getStorageType());
    obj.setStorageName(instance.getStorageName());
    obj.setFirstMetadataDevice(instance.getFirstMetadataDevice());
    obj.setVgMetadataDevice(instance.getVgMetadataDevice());
    obj.setDescription(instance.getDescription());
    obj.setComment(instance.getComment());
    obj.setStorageFormat(instance.getStorageFormat());
    obj.setWipeAfterDelete(instance.getWipeAfterDelete());
    obj.setDiscardAfterDelete(instance.getDiscardAfterDelete());
    obj.setWarningLowSpaceIndicator(instance.getWarningLowSpaceIndicator());
    obj.setCriticalSpaceActionBlocker(instance.getCriticalSpaceActionBlocker());
    obj.setBackup(instance.isBackup());
    return obj;
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(StorageDomainStatic domain) {
    return getCustomMapSqlParameterSource().addValue("id", domain.getId()).addValue("storage", domain.getStorage()).addValue("storage_name", domain.getStorageName()).addValue("storage_description", domain.getDescription()).addValue("storage_comment", domain.getComment()).addValue("storage_type", domain.getStorageType()).addValue("storage_domain_type", domain.getStorageDomainType()).addValue("storage_domain_format_type", domain.getStorageFormat()).addValue("last_time_used_as_master", domain.getLastTimeUsedAsMaster()).addValue("wipe_after_delete", domain.getWipeAfterDelete()).addValue("discard_after_delete", domain.isDiscardAfterDelete()).addValue("first_metadata_device", domain.getFirstMetadataDevice()).addValue("vg_metadata_device", domain.getVgMetadataDevice()).addValue("warning_low_space_indicator", domain.getWarningLowSpaceIndicator()).addValue("critical_space_action_blocker", domain.getCriticalSpaceActionBlocker()).addValue("use_for_backup", domain.getUseForBackup());
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(StorageDomainStatic domain) {
    return getCustomMapSqlParameterSource().addValue("id", domain.getId()).addValue("storage", domain.getStorage()).addValue("storage_name", domain.getStorageName()).addValue("storage_description", domain.getDescription()).addValue("storage_comment", domain.getComment()).addValue("storage_type", domain.getStorageType()).addValue("storage_domain_type", domain.getStorageDomainType()).addValue("storage_domain_format_type", domain.getStorageFormat()).addValue("last_time_used_as_master", domain.getLastTimeUsedAsMaster()).addValue("wipe_after_delete", domain.getWipeAfterDelete()).addValue("discard_after_delete", domain.getDiscardAfterDelete()).addValue("first_metadata_device", domain.getFirstMetadataDevice()).addValue("vg_metadata_device", domain.getVgMetadataDevice()).addValue("warning_low_space_indicator", domain.getWarningLowSpaceIndicator()).addValue("critical_space_action_blocker", domain.getCriticalSpaceActionBlocker()).addValue("backup", domain.isBackup());
}
#end_block

#method_before
private void assertGetResult(StorageDomain result) {
    assertNotNull(result);
    assertEquals(existingDomain, result);
    assertEquals("Wrong committed disk size", 8, result.getCommittedDiskSize());
    assertEquals("Wrong actual disk size", 4, result.getActualImagesSize());
    assertEquals("Wrong first metadata device", FixturesTool.LUN_ID_OF_DOMAIN_METADATA, result.getFirstMetadataDevice());
    assertEquals("Wrong vg metadata device", FixturesTool.LUN_ID_OF_DOMAIN_VG_METADATA, result.getVgMetadataDevice());
    assertEquals("Wrong shared status", StorageDomainSharedStatus.Active, result.getStorageDomainSharedStatus());
    assertEquals("Wrong backup flag status", FixturesTool.USE_FOR_BACKUP_FLAG, result.getUseForBackup());
}
#method_after
private void assertGetResult(StorageDomain result) {
    assertNotNull(result);
    assertEquals(existingDomain, result);
    assertEquals("Wrong committed disk size", 8, result.getCommittedDiskSize());
    assertEquals("Wrong actual disk size", 4, result.getActualImagesSize());
    assertEquals("Wrong first metadata device", FixturesTool.LUN_ID_OF_DOMAIN_METADATA, result.getFirstMetadataDevice());
    assertEquals("Wrong vg metadata device", FixturesTool.LUN_ID_OF_DOMAIN_VG_METADATA, result.getVgMetadataDevice());
    assertEquals("Wrong shared status", StorageDomainSharedStatus.Active, result.getStorageDomainSharedStatus());
    assertEquals("Wrong backup flag status", false, result.isBackup());
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getStorageDomainStaticDao();
    dynamicDao = dbFacade.getStorageDomainDynamicDao();
    diskImageDao = dbFacade.getDiskImageDao();
    imageDao = dbFacade.getImageDao();
    existingDomain = dao.get(new Guid("72e3a666-89e1-4005-a7ca-f7548004a9ab"));
    newStaticDomain = new StorageDomainStatic();
    newStaticDomain.setStorageName("NewStorageDomain");
    newStaticDomain.setStorage("fDMzhE-wx3s-zo3q-Qcxd-T0li-yoYU-QvVePl");
    newStaticDomain.setStorageFormat(StorageFormatType.V1);
    newStaticDomain.setWipeAfterDelete(true);
    newStaticDomain.setWarningLowSpaceIndicator(3);
    newStaticDomain.setCriticalSpaceActionBlocker(9);
    newStaticDomain.setFirstMetadataDevice(FixturesTool.LUN_ID2);
    newStaticDomain.setVgMetadataDevice(FixturesTool.LUN_ID2);
    newStaticDomain.setUseForBackup(FixturesTool.USE_FOR_BACKUP_FLAG);
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getStorageDomainStaticDao();
    dynamicDao = dbFacade.getStorageDomainDynamicDao();
    diskImageDao = dbFacade.getDiskImageDao();
    imageDao = dbFacade.getImageDao();
    existingDomain = dao.get(new Guid("72e3a666-89e1-4005-a7ca-f7548004a9ab"));
    newStaticDomain = new StorageDomainStatic();
    newStaticDomain.setStorageName("NewStorageDomain");
    newStaticDomain.setStorage("fDMzhE-wx3s-zo3q-Qcxd-T0li-yoYU-QvVePl");
    newStaticDomain.setStorageFormat(StorageFormatType.V1);
    newStaticDomain.setWipeAfterDelete(true);
    newStaticDomain.setDiscardAfterDelete(false);
    newStaticDomain.setWarningLowSpaceIndicator(3);
    newStaticDomain.setCriticalSpaceActionBlocker(9);
    newStaticDomain.setFirstMetadataDevice(FixturesTool.LUN_ID2);
    newStaticDomain.setVgMetadataDevice(FixturesTool.LUN_ID2);
    newStaticDomain.setBackup(false);
}
#end_block

#method_before
@Test
public void testUpdate() {
    existingDomain.setStorageName("UpdatedName");
    existingDomain.setWipeAfterDelete(true);
    existingDomain.setWarningLowSpaceIndicator(4);
    existingDomain.setCriticalSpaceActionBlocker(8);
    existingDomain.setFirstMetadataDevice(FixturesTool.LUN_ID1);
    existingDomain.setVgMetadataDevice(FixturesTool.LUN_ID1);
    existingDomain.setUseForBackup(true);
    dao.update(existingDomain);
    StorageDomainStatic after = dao.get(existingDomain.getId());
    assertEquals(after, existingDomain);
}
#method_after
@Test
public void testUpdate() {
    existingDomain.setStorageName("UpdatedName");
    existingDomain.setWipeAfterDelete(true);
    existingDomain.setWarningLowSpaceIndicator(4);
    existingDomain.setCriticalSpaceActionBlocker(8);
    existingDomain.setFirstMetadataDevice(FixturesTool.LUN_ID1);
    existingDomain.setVgMetadataDevice(FixturesTool.LUN_ID1);
    existingDomain.setBackup(true);
    dao.update(existingDomain);
    StorageDomainStatic after = dao.get(existingDomain.getId());
    assertEquals(after, existingDomain);
}
#end_block

#method_before
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(MainModelProvider<VmTemplate, TemplateListModel> modelProvider, WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.templateMainTabPlace);
    return new ModelBoundTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getPrimaryPriority(), modelProvider, menuTabDetails.getIcon());
}
#method_after
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.templateMainTabPlace);
    return new GroupedTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryPriority(), menuTabDetails.getIcon());
}
#end_block

#method_before
@Override
protected void onBind() {
    super.onBind();
    M listModel = listModelProvider.getModel();
    listModel.getSelectedItemChangedEvent().addListener((ev, sender, args) -> updateSelectedRows());
    listModel.getSelectedItemsChangedEvent().addListener((ev, sender, args) -> updateSelectedRows());
}
#method_after
@Override
protected void onBind() {
    super.onBind();
    M listModel = getModel();
    listModel.getSelectedItemChangedEvent().addListener((ev, sender, args) -> updateSelectedRows());
    listModel.getSelectedItemsChangedEvent().addListener((ev, sender, args) -> updateSelectedRows());
}
#end_block

#method_before
private void updateSelectedRows() {
    if (updateToFirstRow) {
        updateToFirstRow = false;
        Collection<T> items = listModelProvider.getModel().getItems();
        if (items instanceof List) {
            final List<T> itemsAsList = (List<T>) items;
            if (!itemsAsList.isEmpty()) {
                Scheduler.get().scheduleDeferred(() -> {
                    T firstItem = itemsAsList.get(0);
                    selectionModel.setSelected(firstItem, true);
                    listModelProvider.getModel().setSelectedItem(firstItem);
                    getView().setCurrentSelectedName(getView().getName(firstItem));
                });
            }
        }
    } else if (updateToLastRow) {
        updateToLastRow = false;
        Collection<T> items = listModelProvider.getModel().getItems();
        if (items instanceof List) {
            final List<T> itemsAsList = (List<T>) items;
            if (!itemsAsList.isEmpty()) {
                Scheduler.get().scheduleDeferred(() -> {
                    T lastItem = itemsAsList.get(itemsAsList.size() - 1);
                    selectionModel.setSelected(lastItem, true);
                    listModelProvider.getModel().setSelectedItem(lastItem);
                    getView().setCurrentSelectedName(getView().getName(lastItem));
                });
            }
        }
    }
    if (listModelProvider.getModel().getSelectedItem() != null && showSelectedName) {
        getView().setCurrentSelectedName(getView().getName((T) listModelProvider.getModel().getSelectedItem()));
    }
    getView().buildCrumbs(listModelProvider.getModel().getTitle(), listModelProvider.getModel().getApplicationPlace());
}
#method_after
private void updateSelectedRows() {
    if (updateToFirstRow) {
        updateToFirstRow = false;
        final List<T> itemsAsList = getItemsAsList(getModel());
        if (!itemsAsList.isEmpty()) {
            Scheduler.get().scheduleDeferred(() -> {
                T firstItem = itemsAsList.get(0);
                getSelectionModel().setSelected(firstItem, true);
                getModel().setSelectedItem(firstItem);
                getView().setCurrentSelectedNameForItem(firstItem);
            });
        }
    } else if (updateToLastRow) {
        updateToLastRow = false;
        final List<T> itemsAsList = getItemsAsList(getModel());
        if (!itemsAsList.isEmpty()) {
            Scheduler.get().scheduleDeferred(() -> {
                T lastItem = itemsAsList.get(itemsAsList.size() - 1);
                getSelectionModel().setSelected(lastItem, true);
                getModel().setSelectedItem(lastItem);
                getView().setCurrentSelectedNameForItem(lastItem);
            });
        }
    }
    if (getModel().getSelectedItem() != null && showSelectedName) {
        getView().setCurrentSelectedNameForItem((T) getModel().getSelectedItem());
    }
    getView().buildCrumbs(getModel().getTitle(), getModel().getApplicationPlace());
}
#end_block

#method_before
private List<T> getItemsAsList(M searchableListModel) {
    return new ArrayList<>(searchableListModel.getItems());
}
#method_after
private List<T> getItemsAsList(M searchableListModel) {
    Collection<T> items = searchableListModel.getItems();
    return items != null ? new ArrayList<>(searchableListModel.getItems()) : Collections.EMPTY_LIST;
}
#end_block

#method_before
public void nextEntity() {
    M searchableListModel = listModelProvider.getModel();
    T entity = (T) searchableListModel.getSelectedItem();
    List<T> itemsAsList = getItemsAsList(searchableListModel);
    int currentIndex = itemsAsList.indexOf(entity);
    int newIndex = currentIndex + 1;
    if (newIndex >= itemsAsList.size()) {
        if (searchableListModel.getSearchNextPageCommand().getIsExecutionAllowed() && searchableListModel.getSearchNextPageCommand().getIsAvailable()) {
            searchableListModel.executeCommand(searchableListModel.getSearchNextPageCommand());
            updateToFirstRow = true;
        }
    } else {
        selectionModel.setSelected(itemsAsList.get(newIndex), true);
    }
}
#method_after
public void nextEntity() {
    M searchableListModel = getModel();
    T entity = (T) searchableListModel.getSelectedItem();
    List<T> itemsAsList = getItemsAsList(searchableListModel);
    int currentIndex = itemsAsList.indexOf(entity);
    int newIndex = currentIndex + 1;
    if (newIndex >= itemsAsList.size()) {
        if (searchableListModel.getSearchNextPageCommand().getIsExecutionAllowed() && searchableListModel.getSearchNextPageCommand().getIsAvailable()) {
            searchableListModel.executeCommand(searchableListModel.getSearchNextPageCommand());
            updateToFirstRow = true;
        }
    } else {
        getSelectionModel().setSelected(itemsAsList.get(newIndex), true);
    }
}
#end_block

#method_before
public void previousEntity() {
    M searchableListModel = listModelProvider.getModel();
    T entity = (T) searchableListModel.getSelectedItem();
    List<T> itemsAsList = getItemsAsList(searchableListModel);
    int currentIndex = itemsAsList.indexOf(entity);
    int newIndex = currentIndex - 1;
    if (newIndex < 0) {
        if (searchableListModel.getSearchPreviousPageCommand().getIsExecutionAllowed() && searchableListModel.getSearchPreviousPageCommand().getIsAvailable()) {
            searchableListModel.executeCommand(searchableListModel.getSearchPreviousPageCommand());
            updateToLastRow = true;
        }
    } else {
        selectionModel.setSelected(itemsAsList.get(newIndex), true);
    }
}
#method_after
public void previousEntity() {
    M searchableListModel = getModel();
    T entity = (T) searchableListModel.getSelectedItem();
    List<T> itemsAsList = getItemsAsList(searchableListModel);
    int currentIndex = itemsAsList.indexOf(entity);
    int newIndex = currentIndex - 1;
    if (newIndex < 0) {
        if (searchableListModel.getSearchPreviousPageCommand().getIsExecutionAllowed() && searchableListModel.getSearchPreviousPageCommand().getIsAvailable()) {
            searchableListModel.executeCommand(searchableListModel.getSearchPreviousPageCommand());
            updateToLastRow = true;
        }
    } else {
        getSelectionModel().setSelected(itemsAsList.get(newIndex), true);
    }
}
#end_block

#method_before
@Override
public void modelSelected(T model) {
    getView().hidePopover();
    selectionModel.setSelected(model, true);
}
#method_after
@Override
public void modelSelected(T model) {
    getView().hidePopover();
    getSelectionModel().setSelected(model, true);
}
#end_block

#method_before
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(MainModelProvider<Disk, DiskListModel> modelProvider, WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.diskMainTabPlace);
    return new ModelBoundTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getPrimaryPriority(), modelProvider, menuTabDetails.getIcon());
}
#method_after
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.diskMainTabPlace);
    return new GroupedTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryPriority(), menuTabDetails.getIcon());
}
#end_block

#method_before
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(MainModelProvider<AuditLog, EventListModel<Void>> modelProvider, WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.eventMainTabPlace);
    return new ModelBoundTabData(menuTabDetails.getPrimaryTitle(), 0, null, menuTabDetails.getPrimaryPriority(), modelProvider, menuTabDetails.getIcon());
}
#method_after
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.eventMainTabPlace);
    return new GroupedTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryPriority(), menuTabDetails.getIcon());
}
#end_block

#method_before
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(MainModelProvider<Erratum, EngineErrataListModel> modelErrata, WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.errataMainTabPlace);
    return new ModelBoundTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getPrimaryPriority(), modelErrata, menuTabDetails.getIcon());
}
#method_after
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.errataMainTabPlace);
    return new GroupedTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryPriority(), menuTabDetails.getIcon());
}
#end_block

#method_before
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(MainModelProvider<VM, VmListModel<Void>> modelProvider, WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.virtualMachineMainTabPlace);
    return new ModelBoundTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getPrimaryPriority(), modelProvider, menuTabDetails.getIcon());
}
#method_after
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.virtualMachineMainTabPlace);
    return new GroupedTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryPriority(), menuTabDetails.getIcon());
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    AbstractTextColumn<VnicProfileView> nameColumn = new AbstractLinkColumn<VnicProfileView>(new FieldUpdater<VnicProfileView, String>() {

        @Override
        public void update(int index, VnicProfileView vnicProfile, String value) {
            // The link was clicked, now fire an event to switch to details.
            transitionHandler.handlePlaceTransition(true);
        }
    }) {

        @Override
        public String getValue(VnicProfileView object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVnicProfile(), "200px");
    AbstractTextColumn<VnicProfileView> networkColumn = new AbstractTextColumn<VnicProfileView>() {

        @Override
        public String getValue(VnicProfileView object) {
            return object.getNetworkName();
        }
    };
    networkColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(networkColumn, constants.networkVnicProfile(), "200px");
    AbstractTextColumn<VnicProfileView> dcColumn = new AbstractTextColumn<VnicProfileView>() {

        @Override
        public String getValue(VnicProfileView object) {
            return object.getDataCenterName();
        }
    };
    dcColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(dcColumn, constants.dcVnicProfile(), "200px");
    AbstractTextColumn<VnicProfileView> compatibilityVersionColumn = new AbstractTextColumn<VnicProfileView>() {

        @Override
        public String getValue(VnicProfileView object) {
            return object.getCompatibilityVersion().toString();
        }
    };
    compatibilityVersionColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(compatibilityVersionColumn, constants.compatibilityVersionVnicProfile(), "200px");
    AbstractTextColumn<VnicProfileView> qosColumn = new AbstractTextColumn<VnicProfileView>() {

        @Override
        public String getValue(VnicProfileView object) {
            return object.getNetworkQosName();
        }
    };
    qosColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(qosColumn, constants.qosNameVnicProfile(), "200px");
    AbstractTextColumn<VnicProfileView> networkFilterColumn = new AbstractTextColumn<VnicProfileView>() {

        @Override
        public String getValue(VnicProfileView object) {
            return object.getNetworkFilterName();
        }
    };
    networkFilterColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(networkFilterColumn, constants.networkFilterNameVnicProfile(), "200px");
    AbstractBooleanColumn<VnicProfileView> portMirroringColumn = new AbstractBooleanColumn<VnicProfileView>(constants.portMirroringEnabled()) {

        @Override
        public Boolean getRawValue(VnicProfileView object) {
            return object.isPortMirroring();
        }
    };
    portMirroringColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(portMirroringColumn, constants.portMirroringVnicProfile(), "100px");
    AbstractTextColumn<VnicProfileView> descriptionColumn = new AbstractTextColumn<VnicProfileView>() {

        @Override
        public String getValue(VnicProfileView object) {
            return object.getDescription();
        }
    };
    descriptionColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.descriptionVnicProfile(), "400px");
    addButtonToActionGroup(getTable().addActionButton(new WebAdminButtonDefinition<VnicProfileView>(constants.newVnicProfile()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    }));
    addButtonToActionGroup(getTable().addActionButton(new WebAdminButtonDefinition<VnicProfileView>(constants.editVnicProfile()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    }));
    addButtonToActionGroup(getTable().addActionButton(new WebAdminButtonDefinition<VnicProfileView>(constants.removeVnicProfile()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    }));
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    AbstractTextColumn<VnicProfileView> nameColumn = new AbstractLinkColumn<VnicProfileView>(new FieldUpdater<VnicProfileView, String>() {

        @Override
        public void update(int index, VnicProfileView vnicProfile, String value) {
            // The link was clicked, now fire an event to switch to details.
            transitionHandler.handlePlaceTransition(true);
        }
    }) {

        @Override
        public String getValue(VnicProfileView object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVnicProfile(), "200px");
    AbstractTextColumn<VnicProfileView> networkColumn = new AbstractTextColumn<VnicProfileView>() {

        @Override
        public String getValue(VnicProfileView object) {
            return object.getNetworkName();
        }
    };
    networkColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(networkColumn, constants.networkVnicProfile(), "200px");
    AbstractTextColumn<VnicProfileView> dcColumn = new AbstractTextColumn<VnicProfileView>() {

        @Override
        public String getValue(VnicProfileView object) {
            return object.getDataCenterName();
        }
    };
    dcColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(dcColumn, constants.dcVnicProfile(), "200px");
    AbstractTextColumn<VnicProfileView> compatibilityVersionColumn = new AbstractTextColumn<VnicProfileView>() {

        @Override
        public String getValue(VnicProfileView object) {
            return object.getCompatibilityVersion().toString();
        }
    };
    compatibilityVersionColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(compatibilityVersionColumn, constants.compatibilityVersionVnicProfile(), "200px");
    AbstractTextColumn<VnicProfileView> qosColumn = new AbstractTextColumn<VnicProfileView>() {

        @Override
        public String getValue(VnicProfileView object) {
            return object.getNetworkQosName();
        }
    };
    qosColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(qosColumn, constants.qosNameVnicProfile(), "200px");
    AbstractTextColumn<VnicProfileView> networkFilterColumn = new AbstractTextColumn<VnicProfileView>() {

        @Override
        public String getValue(VnicProfileView object) {
            return object.getNetworkFilterName();
        }
    };
    networkFilterColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(networkFilterColumn, constants.networkFilterNameVnicProfile(), "200px");
    AbstractBooleanColumn<VnicProfileView> portMirroringColumn = new AbstractBooleanColumn<VnicProfileView>(constants.portMirroringEnabled()) {

        @Override
        public Boolean getRawValue(VnicProfileView object) {
            return object.isPortMirroring();
        }
    };
    portMirroringColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(portMirroringColumn, constants.portMirroringVnicProfile(), "100px");
    AbstractTextColumn<VnicProfileView> passthroughColumn = new AbstractTextColumn<VnicProfileView>() {

        @Override
        public String getValue(VnicProfileView object) {
            return object.isPassthrough() ? constants.yes() : constants.no();
        }
    };
    passthroughColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(passthroughColumn, constants.passthroughVnicProfile(), "100px");
    AbstractTextColumn<VnicProfileView> descriptionColumn = new AbstractTextColumn<VnicProfileView>() {

        @Override
        public String getValue(VnicProfileView object) {
            return object.getDescription();
        }
    };
    descriptionColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.descriptionVnicProfile(), "400px");
    addButtonToActionGroup(getTable().addActionButton(new WebAdminButtonDefinition<VnicProfileView>(constants.newVnicProfile()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    }));
    addButtonToActionGroup(getTable().addActionButton(new WebAdminButtonDefinition<VnicProfileView>(constants.editVnicProfile()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    }));
    addButtonToActionGroup(getTable().addActionButton(new WebAdminButtonDefinition<VnicProfileView>(constants.removeVnicProfile()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    }));
}
#end_block

#method_before
public void buildCrumbs(String modelTitle, String modelHref) {
    // Clear the existing path.
    breadCrumbs.clear();
    // Add starting >>
    breadCrumbs.add(new AnchorListItem(""));
    // Add primary menu label.
    String primaryLabel = menuLayout.getPrimaryGroupTitle(modelTitle);
    if (primaryLabel != null) {
        breadCrumbs.add(new ListItem(primaryLabel));
    }
    // Add main model name.
    AnchorListItem mainModelAnchor = new AnchorListItem(modelTitle);
    // $NON-NLS-1$
    mainModelAnchor.setHref("#" + modelHref);
    breadCrumbs.add(mainModelAnchor);
    if (currentSelectedItemWidget != null) {
        breadCrumbs.add(currentSelectedItemWidget);
    }
}
#method_after
@Override
public void buildCrumbs(String modelTitle, String modelHref) {
    // Clear the existing path.
    breadCrumbs.clear();
    // Add starting >>
    breadCrumbs.add(new AnchorListItem());
    // Add primary menu label.
    String primaryLabel = menuLayout.getPrimaryGroupTitle(modelTitle);
    if (primaryLabel != null) {
        breadCrumbs.add(new ListItem(primaryLabel));
    }
    // Add main model name.
    AnchorListItem mainModelAnchor = new AnchorListItem(modelTitle);
    // $NON-NLS-1$
    mainModelAnchor.setHref("#" + modelHref);
    breadCrumbs.add(mainModelAnchor);
    if (currentSelectedItemWidget != null) {
        breadCrumbs.add(currentSelectedItemWidget);
    }
}
#end_block

#method_before
// Can't make this a composite class since I can't put anything inside
// an AnchorListItem besides text using ui.xml files. But manually I can
private AnchorListItem createSelectionDropDown(SafeHtml currentName) {
    OvirtAnchorListItem dropDown = new OvirtAnchorListItem();
    Button exchangeButton = new Button();
    exchangeButton.setIcon(IconType.EXCHANGE);
    exchangeButton.addStyleName(QUICK_SWITCH);
    Anchor anchor = dropDown.getAnchor();
    anchor.setText(currentName.asString());
    anchor.getElement().getStyle().setFontSize(28, Unit.PX);
    anchor.addClickHandler(e -> {
        if (popover.isVisible()) {
            popover.hide();
        } else {
            popover.show();
        }
    });
    anchor.add(exchangeButton);
    createPopover(anchor);
    dropDown.add(anchor);
    return dropDown;
}
#method_after
// Can't make this a composite class since I can't put anything inside
// an AnchorListItem besides text using ui.xml files. But manually I can
private AnchorListItem createSelectionDropDown(SafeHtml currentName) {
    OvirtAnchorListItem dropDown = new OvirtAnchorListItem();
    Button exchangeButton = new Button();
    exchangeButton.setIcon(IconType.EXCHANGE);
    exchangeButton.addStyleName(QUICK_SWITCH);
    exchangeButton.getElement().getStyle().setMarginLeft(10, Unit.PX);
    exchangeButton.getElement().getStyle().setMarginTop(-5, Unit.PX);
    Anchor anchor = dropDown.getAnchor();
    anchor.setText(currentName.asString());
    anchor.getElement().getStyle().setFontSize(28, Unit.PX);
    anchor.addClickHandler(e -> {
        if (popover.isVisible()) {
            popover.hide();
        } else {
            popover.show();
        }
    });
    anchor.add(exchangeButton);
    createPopover(anchor);
    dropDown.add(anchor);
    return dropDown;
}
#end_block

#method_before
private void createPopover(Anchor anchor) {
    popover = new OvirtPopover(anchor);
    popover.setTrigger(Trigger.MANUAL);
    popover.setPlacement(Placement.BOTTOM);
    popover.setContainer(anchor);
    if (searchBox == null) {
        searchBox = createSearchBox();
        searchBox.addModelSelectedCallback(selectionCallback);
    }
    // $NON-NLS-1$
    popover.addContent(searchBox, "searchPanel");
}
#method_after
private void createPopover(Anchor anchor) {
    if (popover != null) {
        popover.destroy();
    }
    popover = new OvirtPopover(anchor);
    popover.setTrigger(Trigger.MANUAL);
    popover.setPlacement(Placement.BOTTOM);
    popover.setContainer(anchor);
    if (searchBox == null) {
        searchBox = createSearchBox();
        searchBox.addModelSelectedCallback(selectionCallback);
    }
    popover.addContent(searchBox, SEARCH_PANEL_CONTENT_ID);
}
#end_block

#method_before
@Override
public SafeHtml getName(T item) {
    String result = "";
    if (item instanceof Nameable) {
        result = ((Nameable) item).getName();
    }
    return SafeHtmlUtils.fromString(result);
}
#method_after
public SafeHtml getName(T item) {
    String result = "";
    if (item instanceof Nameable) {
        result = ((Nameable) item).getName();
    }
    return SafeHtmlUtils.fromString(result);
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    HostStatusColumn<VDS> statusIconColumn = new HostStatusColumn<>();
    statusIconColumn.setContextMenuTitle(constants.statusIconHost());
    // $NON-NLS-1$
    getTable().addColumn(statusIconColumn, constants.empty(), "30px");
    HostAdditionalStatusColumn additionalStatusColumn = new HostAdditionalStatusColumn();
    additionalStatusColumn.setContextMenuTitle(constants.additionalStatusHost());
    // $NON-NLS-1$
    getTable().addColumn(additionalStatusColumn, constants.empty(), "60px");
    AbstractTextColumn<VDS> nameColumn = new AbstractLinkColumn<VDS>(new FieldUpdater<VDS, String>() {

        @Override
        public void update(int index, VDS host, String value) {
            transitionHandler.handlePlaceTransition(true);
        }
    }) {

        @Override
        public String getValue(VDS object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(VdsConditionFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameHost(), "150px");
    CommentColumn<VDS> commentColumn = new CommentColumn<>();
    getTable().addColumnWithHtmlHeader(commentColumn, SafeHtmlUtils.fromSafeConstant(constants.commentLabel()), // $NON-NLS-1$
    "75px");
    AbstractTextColumn<VDS> hostColumn = new AbstractTextColumn<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getHostName();
        }
    };
    hostColumn.makeSortable(VdsConditionFieldAutoCompleter.ADDRESS);
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.ipHost(), "150px");
    AbstractTextColumn<VDS> clusterColumn = new AbstractTextColumn<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getClusterName();
        }
    };
    clusterColumn.makeSortable(VdsConditionFieldAutoCompleter.CLUSTER);
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterHost(), "150px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        AbstractTextColumn<VDS> dcColumn = new AbstractTextColumn<VDS>() {

            @Override
            public String getValue(VDS object) {
                return object.getStoragePoolName();
            }
        };
        dcColumn.makeSortable(VdsConditionFieldAutoCompleter.DATACENTER);
        // $NON-NLS-1$
        getTable().addColumn(dcColumn, constants.dcHost(), "150px");
    }
    AbstractTextColumn<VDS> statusColumn = new AbstractEnumColumn<VDS, VDSStatus>() {

        @Override
        public VDSStatus getRawValue(VDS object) {
            return object.getStatus();
        }
    };
    ReasonColumn<VDS> reasonColumn = new ReasonColumn<VDS>() {

        @Override
        protected String getReason(VDS value) {
            return value.getMaintenanceReason();
        }
    };
    List<HasCell<VDS, ?>> list = new ArrayList<>();
    list.add(statusColumn);
    list.add(reasonColumn);
    Cell<VDS> compositeCell = new StatusCompositeCell<>(list);
    AbstractColumn<VDS, VDS> statusTextColumn = new AbstractColumn<VDS, VDS>(compositeCell) {

        @Override
        public VDS getValue(VDS object) {
            return object;
        }

        @Override
        public SafeHtml getTooltip(VDS value) {
            String maintenanceReason = value.getMaintenanceReason();
            if (maintenanceReason != null && !maintenanceReason.trim().isEmpty()) {
                return SafeHtmlUtils.fromString(maintenanceReason);
            }
            return null;
        }
    };
    statusTextColumn.makeSortable(VdsConditionFieldAutoCompleter.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(statusTextColumn, constants.statusHost(), "100px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        VmCountColumn vmCountColumn = new VmCountColumn();
        vmCountColumn.setHorizontalAlignment(HasHorizontalAlignment.ALIGN_CENTER);
        vmCountColumn.makeSortable(VdsConditionFieldAutoCompleter.ACTIVE_VMS);
        // $NON-NLS-1$
        getTable().addColumn(vmCountColumn, constants.vmsCount(), "110px");
    }
    AbstractPercentColumn<VDS> memColumn = new AbstractPercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getUsageMemPercent();
        }
    };
    memColumn.makeSortable(VdsConditionFieldAutoCompleter.MEM_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(memColumn, constants.memoryHost(), "80px");
    AbstractPercentColumn<VDS> cpuColumn = new AbstractPercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getUsageCpuPercent();
        }
    };
    cpuColumn.makeSortable(VdsConditionFieldAutoCompleter.CPU_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuHost(), "80px");
    AbstractPercentColumn<VDS> netColumn = new AbstractPercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getUsageNetworkPercent();
        }
    };
    netColumn.makeSortable(VdsConditionFieldAutoCompleter.NETWORK_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(netColumn, constants.networkHost(), "80px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        AbstractTextColumn<VDS> spmColumn = new AbstractTextColumn<VDS>() {

            @Override
            public String getValue(VDS object) {
                int value = object.getVdsSpmPriority();
                int lowValue = defaultSpmPriority / 2;
                int highValue = defaultSpmPriority + (maxSpmPriority - defaultSpmPriority) / 2;
                if (object.getSpmStatus() != VdsSpmStatus.None) {
                    return object.getSpmStatus().name();
                }
                if (value == -1) {
                    return constants.spmNeverText();
                } else if (value == lowValue) {
                    return constants.spmLowText();
                } else if (value == defaultSpmPriority) {
                    return constants.spmNormalText();
                } else if (value == highValue) {
                    return constants.spmHighText();
                }
                return constants.spmCustomText();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(spmColumn, constants.spmPriorityHost(), "100px");
    }
    // 
    // Buttons/menu items
    // Create/Edit/Remove Host operations
    // 
    addButtonToActionGroup(getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.newHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    }));
    addButtonToActionGroup(getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.editHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    }));
    addButtonToActionGroup(getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.removeHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    }));
    // Management operations drop down
    List<ActionButtonDefinition<VDS>> managementSubActions = new LinkedList<>();
    // Maintenance button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.maintenanceHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMaintenanceCommand();
        }
    });
    // Activate button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.activateHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getActivateCommand();
        }
    });
    // Refresh capabilities button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.refreshHostCapabilities()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRefreshCapabilitiesCommand();
        }
    });
    // Confirm Host Rebooted button
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VDS>(constants.confirmRebootedHost(), CommandLocation.OnlyFromContext) {

            @Override
            protected UICommand resolveCommand() {
                return getMainModel().getManualFenceCommand();
            }
        }));
    }
    // Power management drop down
    List<ActionButtonDefinition<VDS>> pmSubActions = new LinkedList<>();
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.restartHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRestartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.startHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.stopHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    // Remote management via SSH drop down
    List<ActionButtonDefinition<VDS>> sshSubActions = new LinkedList<>();
    sshSubActions.add(new WebAdminButtonDefinition<VDS>(constants.restartHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getSshRestartCommand();
        }
    });
    sshSubActions.add(new WebAdminButtonDefinition<VDS>(constants.stopHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getSshStopCommand();
        }
    });
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        managementSubActions.add(new WebAdminMenuBarButtonDefinition<>(constants.pmHost(), pmSubActions));
        managementSubActions.add(new WebAdminMenuBarButtonDefinition<>(constants.sshManagement(), sshSubActions));
    }
    // Select as SPM button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.selectHostAsSPM()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getSelectAsSpmCommand();
        }
    });
    // Configure local storage button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.configureLocalStorageHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConfigureLocalStorageCommand();
        }
    });
    // Add management menu bar
    addButtonToActionGroup(getTable().addActionButton(new WebAdminMenuBarButtonDefinition<>(constants.management(), managementSubActions), new DropdownActionButton<VDS>(managementSubActions, new DropdownActionButton.SelectedItemsProvider<VDS>() {

        @Override
        public List<VDS> getSelectedItems() {
            return getMainModel().getSelectedItems();
        }
    })));
    // Installation operations drop down
    List<ActionButtonDefinition<VDS>> moreSubActions = new LinkedList<>();
    // Reinstall button
    moreSubActions.add(new WebAdminButtonDefinition<VDS>(constants.reinstallHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getInstallCommand();
        }
    });
    // Enroll certificate button
    moreSubActions.add(new WebAdminButtonDefinition<VDS>(constants.enrollCertificate()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEnrollCertificateCommand();
        }
    });
    // Check for upgrade button
    moreSubActions.add(new WebAdminButtonDefinition<VDS>(constants.checkForHostUpgrade()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCheckForUpgradeCommand();
        }
    });
    // Upgrade button
    moreSubActions.add(new WebAdminButtonDefinition<VDS>(constants.upgradeHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getUpgradeCommand();
        }
    });
    addButtonToActionGroup(getTable().addActionButton(new WebAdminMenuBarButtonDefinition<>(constants.installation(), moreSubActions), new DropdownActionButton<VDS>(moreSubActions, new DropdownActionButton.SelectedItemsProvider<VDS>() {

        @Override
        public List<VDS> getSelectedItems() {
            return getMainModel().getSelectedItems();
        }
    })));
    // Host Console (link to Cockpit)
    addButtonToActionGroup(getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.hostConsole()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getHostConsoleCommand();
        }
    }));
    // Assign tags
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VDS>(constants.assignTagsHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    }));
    // NUMA support
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VDS>(constants.numaSupport()) {

            @Override
            protected UICommand resolveCommand() {
                return getMainModel().getNumaSupportCommand();
            }
        }));
    }
    // Approve
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VDS>(constants.approveHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getApproveCommand();
        }
    }));
    // HA global maintenance
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VDS>(constants.enableGlobalHaMaintenanceVm(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEnableGlobalHaMaintenanceCommand();
        }
    }));
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VDS>(constants.disableGlobalHaMaintenanceVm(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getDisableGlobalHaMaintenanceCommand();
        }
    }));
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    HostStatusColumn<VDS> statusIconColumn = new HostStatusColumn<>();
    statusIconColumn.setContextMenuTitle(constants.statusIconHost());
    // $NON-NLS-1$
    getTable().addColumn(statusIconColumn, constants.empty(), "35px");
    HostAdditionalStatusColumn additionalStatusColumn = new HostAdditionalStatusColumn();
    additionalStatusColumn.setContextMenuTitle(constants.additionalStatusHost());
    // $NON-NLS-1$
    getTable().addColumn(additionalStatusColumn, constants.empty(), "60px");
    AbstractTextColumn<VDS> nameColumn = new AbstractLinkColumn<VDS>(new FieldUpdater<VDS, String>() {

        @Override
        public void update(int index, VDS host, String value) {
            transitionHandler.handlePlaceTransition(true);
        }
    }) {

        @Override
        public String getValue(VDS object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(VdsConditionFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameHost(), "150px");
    CommentColumn<VDS> commentColumn = new CommentColumn<>();
    getTable().addColumnWithHtmlHeader(commentColumn, SafeHtmlUtils.fromSafeConstant(constants.commentLabel()), // $NON-NLS-1$
    "75px");
    AbstractTextColumn<VDS> hostColumn = new AbstractTextColumn<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getHostName();
        }
    };
    hostColumn.makeSortable(VdsConditionFieldAutoCompleter.ADDRESS);
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.ipHost(), "150px");
    AbstractTextColumn<VDS> clusterColumn = new AbstractTextColumn<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getClusterName();
        }
    };
    clusterColumn.makeSortable(VdsConditionFieldAutoCompleter.CLUSTER);
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterHost(), "150px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        AbstractTextColumn<VDS> dcColumn = new AbstractTextColumn<VDS>() {

            @Override
            public String getValue(VDS object) {
                return object.getStoragePoolName();
            }
        };
        dcColumn.makeSortable(VdsConditionFieldAutoCompleter.DATACENTER);
        // $NON-NLS-1$
        getTable().addColumn(dcColumn, constants.dcHost(), "150px");
    }
    AbstractTextColumn<VDS> statusColumn = new AbstractEnumColumn<VDS, VDSStatus>() {

        @Override
        public VDSStatus getRawValue(VDS object) {
            return object.getStatus();
        }
    };
    ReasonColumn<VDS> reasonColumn = new ReasonColumn<VDS>() {

        @Override
        protected String getReason(VDS value) {
            return value.getMaintenanceReason();
        }
    };
    List<HasCell<VDS, ?>> list = new ArrayList<>();
    list.add(statusColumn);
    list.add(reasonColumn);
    Cell<VDS> compositeCell = new StatusCompositeCell<>(list);
    AbstractColumn<VDS, VDS> statusTextColumn = new AbstractColumn<VDS, VDS>(compositeCell) {

        @Override
        public VDS getValue(VDS object) {
            return object;
        }

        @Override
        public SafeHtml getTooltip(VDS value) {
            String maintenanceReason = value.getMaintenanceReason();
            if (maintenanceReason != null && !maintenanceReason.trim().isEmpty()) {
                return SafeHtmlUtils.fromString(maintenanceReason);
            }
            return null;
        }
    };
    statusTextColumn.makeSortable(VdsConditionFieldAutoCompleter.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(statusTextColumn, constants.statusHost(), "100px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        VmCountColumn vmCountColumn = new VmCountColumn();
        vmCountColumn.setHorizontalAlignment(HasHorizontalAlignment.ALIGN_CENTER);
        vmCountColumn.makeSortable(VdsConditionFieldAutoCompleter.ACTIVE_VMS);
        // $NON-NLS-1$
        getTable().addColumn(vmCountColumn, constants.vmsCount(), "110px");
    }
    AbstractPercentColumn<VDS> memColumn = new AbstractPercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getUsageMemPercent();
        }
    };
    memColumn.makeSortable(VdsConditionFieldAutoCompleter.MEM_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(memColumn, constants.memoryHost(), "80px");
    AbstractPercentColumn<VDS> cpuColumn = new AbstractPercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getUsageCpuPercent();
        }
    };
    cpuColumn.makeSortable(VdsConditionFieldAutoCompleter.CPU_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuHost(), "80px");
    AbstractPercentColumn<VDS> netColumn = new AbstractPercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getUsageNetworkPercent();
        }
    };
    netColumn.makeSortable(VdsConditionFieldAutoCompleter.NETWORK_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(netColumn, constants.networkHost(), "80px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        AbstractTextColumn<VDS> spmColumn = new AbstractTextColumn<VDS>() {

            @Override
            public String getValue(VDS object) {
                int value = object.getVdsSpmPriority();
                int lowValue = defaultSpmPriority / 2;
                int highValue = defaultSpmPriority + (maxSpmPriority - defaultSpmPriority) / 2;
                if (object.getSpmStatus() != VdsSpmStatus.None) {
                    return object.getSpmStatus().name();
                }
                if (value == -1) {
                    return constants.spmNeverText();
                } else if (value == lowValue) {
                    return constants.spmLowText();
                } else if (value == defaultSpmPriority) {
                    return constants.spmNormalText();
                } else if (value == highValue) {
                    return constants.spmHighText();
                }
                return constants.spmCustomText();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(spmColumn, constants.spmPriorityHost(), "100px");
    }
    // 
    // Buttons/menu items
    // Create/Edit/Remove Host operations
    // 
    addButtonToActionGroup(getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.newHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    }));
    addButtonToActionGroup(getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.editHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    }));
    addButtonToActionGroup(getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.removeHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    }));
    // Management operations drop down
    List<ActionButtonDefinition<VDS>> managementSubActions = new LinkedList<>();
    // Maintenance button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.maintenanceHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMaintenanceCommand();
        }
    });
    // Activate button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.activateHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getActivateCommand();
        }
    });
    // Refresh capabilities button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.refreshHostCapabilities()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRefreshCapabilitiesCommand();
        }
    });
    // Confirm Host Rebooted button
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VDS>(constants.confirmRebootedHost(), CommandLocation.OnlyFromContext) {

            @Override
            protected UICommand resolveCommand() {
                return getMainModel().getManualFenceCommand();
            }
        }));
    }
    // Power management drop down
    List<ActionButtonDefinition<VDS>> pmSubActions = new LinkedList<>();
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.restartHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRestartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.startHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.stopHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    // Remote management via SSH drop down
    List<ActionButtonDefinition<VDS>> sshSubActions = new LinkedList<>();
    sshSubActions.add(new WebAdminButtonDefinition<VDS>(constants.restartHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getSshRestartCommand();
        }
    });
    sshSubActions.add(new WebAdminButtonDefinition<VDS>(constants.stopHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getSshStopCommand();
        }
    });
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        managementSubActions.add(new WebAdminMenuBarButtonDefinition<>(constants.pmHost(), pmSubActions));
        managementSubActions.add(new WebAdminMenuBarButtonDefinition<>(constants.sshManagement(), sshSubActions));
    }
    // Select as SPM button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.selectHostAsSPM()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getSelectAsSpmCommand();
        }
    });
    // Configure local storage button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.configureLocalStorageHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConfigureLocalStorageCommand();
        }
    });
    // Add management menu bar
    addButtonToActionGroup(getTable().addActionButton(new WebAdminMenuBarButtonDefinition<>(constants.management(), managementSubActions), new DropdownActionButton<>(managementSubActions, new DropdownActionButton.SelectedItemsProvider<VDS>() {

        @Override
        public List<VDS> getSelectedItems() {
            return getMainModel().getSelectedItems();
        }
    })));
    // Installation operations drop down
    List<ActionButtonDefinition<VDS>> moreSubActions = new LinkedList<>();
    // Reinstall button
    moreSubActions.add(new WebAdminButtonDefinition<VDS>(constants.reinstallHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getInstallCommand();
        }
    });
    // Enroll certificate button
    moreSubActions.add(new WebAdminButtonDefinition<VDS>(constants.enrollCertificate()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEnrollCertificateCommand();
        }
    });
    // Check for upgrade button
    moreSubActions.add(new WebAdminButtonDefinition<VDS>(constants.checkForHostUpgrade()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCheckForUpgradeCommand();
        }
    });
    // Upgrade button
    moreSubActions.add(new WebAdminButtonDefinition<VDS>(constants.upgradeHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getUpgradeCommand();
        }
    });
    addButtonToActionGroup(getTable().addActionButton(new WebAdminMenuBarButtonDefinition<>(constants.installation(), moreSubActions), new DropdownActionButton<>(moreSubActions, new DropdownActionButton.SelectedItemsProvider<VDS>() {

        @Override
        public List<VDS> getSelectedItems() {
            return getMainModel().getSelectedItems();
        }
    })));
    // Host Console (link to Cockpit)
    addButtonToActionGroup(getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.hostConsole()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getHostConsoleCommand();
        }
    }));
    // Assign tags
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VDS>(constants.assignTagsHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    }));
    // NUMA support
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VDS>(constants.numaSupport()) {

            @Override
            protected UICommand resolveCommand() {
                return getMainModel().getNumaSupportCommand();
            }
        }));
    }
    // Approve
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VDS>(constants.approveHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getApproveCommand();
        }
    }));
    // HA global maintenance
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VDS>(constants.enableGlobalHaMaintenanceVm(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEnableGlobalHaMaintenanceCommand();
        }
    }));
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VDS>(constants.disableGlobalHaMaintenanceVm(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getDisableGlobalHaMaintenanceCommand();
        }
    }));
}
#end_block

#method_before
void initTable(VolumeListModel model) {
    getTable().enableColumnResizing();
    VolumeStatusColumn statusColumn = new VolumeStatusColumn(model.getStartCommand());
    statusColumn.setContextMenuTitle(constants.statusVolume());
    statusColumn.makeSortable(Comparator.comparingInt(g -> GlusterVolumeUtils.getVolumeStatus(g).ordinal()));
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.empty(), "30px");
    AbstractTextColumn<GlusterVolumeEntity> nameColumn = new AbstractLinkColumn<GlusterVolumeEntity>(new FieldUpdater<GlusterVolumeEntity, String>() {

        @Override
        public void update(int index, GlusterVolumeEntity volume, String value) {
            // The link was clicked, now fire an event to switch to details.
            transitionHandler.handlePlaceTransition(true);
        }
    }) {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVolume(), "150px");
    AbstractTextColumn<GlusterVolumeEntity> clusterColumn = new AbstractTextColumn<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getClusterName();
        }
    };
    clusterColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    AbstractTextColumn<GlusterVolumeEntity> volumeTypeColumn = new AbstractEnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    volumeTypeColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    // $NON-NLS-1$
    getTable().addColumn(new VolumeBrickStatusColumn(), constants.bricksStatusVolume(), "150px");
    // $NON-NLS-1$
    getTable().addColumn(new VolumeInfoColumn(), constants.volumeInfoVolume(), "100px");
    MenuCell<GlusterTaskSupport> rebalanceMenuCell = getRebalanceActivityMenu();
    MenuCell<GlusterTaskSupport> removeBricksMenuCell = getRemoveBrickActivityMenu();
    List<HasCell<GlusterTaskSupport, ?>> list = new ArrayList<>();
    list.add(new VolumeActivityStatusColumn<>());
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivitySeperatorCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(rebalanceMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(removeBricksMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    List<HasCell<GlusterTaskSupport, ?>> compositeList = new ArrayList<>();
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeTaskWaitingCell<>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivityCompositeCell<>(list)) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    Column<GlusterVolumeEntity, GlusterVolumeEntity> capacityColumn = new Column<GlusterVolumeEntity, GlusterVolumeEntity>(new VolumeCapacityCell()) {

        @Override
        public GlusterVolumeEntity getValue(GlusterVolumeEntity object) {
            return object;
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(capacityColumn, constants.volumeCapacity(), "100px");
    getTable().addColumn(new VolumeActivityColumn<GlusterVolumeEntity>(new VolumeActivityCompositeCell<GlusterTaskSupport>(compositeList)), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    AbstractTextColumn<GlusterVolumeEntity> snapshotCountColumn = new AbstractTextColumn<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getSnapshotsCount().toString();
        }
    };
    snapshotCountColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(snapshotCountColumn, constants.noOfSnapshotsLabel(), "100px");
    addButtonToActionGroup(getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    }));
    addButtonToActionGroup(getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    }));
    addButtonToActionGroup(getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    }));
    addButtonToActionGroup(getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    }));
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    }));
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    }));
    addDividerToKebab();
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolumeProfiling()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartVolumeProfilingCommand();
        }
    }));
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.volumeProfileDetails()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getShowVolumeProfileDetailsCommand();
        }
    }));
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolumeProfiling()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopVolumeProfilingCommand();
        }
    }));
    addDividerToKebab();
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminMenuBarButtonDefinition<>(constants.volumeSnapshotMainTabTitle(), getVolumeSnapshotMenu(), CommandLocation.ContextAndToolBar)));
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminMenuBarButtonDefinition<>(constants.geoReplicationMainTabTitle(), getGeoRepCreateMenu(constants), CommandLocation.ContextAndToolBar)));
}
#method_after
void initTable(VolumeListModel model) {
    getTable().enableColumnResizing();
    VolumeStatusColumn statusColumn = new VolumeStatusColumn(model.getStartCommand());
    statusColumn.setContextMenuTitle(constants.statusVolume());
    statusColumn.makeSortable(Comparator.comparingInt(g -> GlusterVolumeUtils.getVolumeStatus(g).ordinal()));
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.empty(), "30px");
    AbstractTextColumn<GlusterVolumeEntity> nameColumn = new AbstractLinkColumn<GlusterVolumeEntity>(new FieldUpdater<GlusterVolumeEntity, String>() {

        @Override
        public void update(int index, GlusterVolumeEntity volume, String value) {
            // The link was clicked, now fire an event to switch to details.
            transitionHandler.handlePlaceTransition(true);
        }
    }) {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVolume(), "150px");
    AbstractTextColumn<GlusterVolumeEntity> clusterColumn = new AbstractTextColumn<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getClusterName();
        }
    };
    clusterColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    AbstractTextColumn<GlusterVolumeEntity> volumeTypeColumn = new AbstractEnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    volumeTypeColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    // $NON-NLS-1$
    getTable().addColumn(new VolumeBrickStatusColumn(), constants.bricksStatusVolume(), "150px");
    // $NON-NLS-1$
    getTable().addColumn(new VolumeInfoColumn(), constants.volumeInfoVolume(), "100px");
    MenuCell<GlusterTaskSupport> rebalanceMenuCell = getRebalanceActivityMenu();
    MenuCell<GlusterTaskSupport> removeBricksMenuCell = getRemoveBrickActivityMenu();
    List<HasCell<GlusterTaskSupport, ?>> list = new ArrayList<>();
    list.add(new VolumeActivityStatusColumn<>());
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivitySeperatorCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(rebalanceMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(removeBricksMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    List<HasCell<GlusterTaskSupport, ?>> compositeList = new ArrayList<>();
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeTaskWaitingCell<>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivityCompositeCell<>(list)) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    Column<GlusterVolumeEntity, GlusterVolumeEntity> capacityColumn = new Column<GlusterVolumeEntity, GlusterVolumeEntity>(new VolumeCapacityCell()) {

        @Override
        public GlusterVolumeEntity getValue(GlusterVolumeEntity object) {
            return object;
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(capacityColumn, constants.volumeCapacity(), "100px");
    getTable().addColumn(new VolumeActivityColumn<GlusterVolumeEntity>(new VolumeActivityCompositeCell<GlusterTaskSupport>(compositeList)), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    AbstractTextColumn<GlusterVolumeEntity> snapshotCountColumn = new AbstractTextColumn<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getSnapshotsCount().toString();
        }
    };
    snapshotCountColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(snapshotCountColumn, constants.noOfSnapshotsLabel(), "100px");
    addButtonToActionGroup(getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    }));
    addButtonToActionGroup(getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    }));
    addButtonToActionGroup(getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    }));
    addButtonToActionGroup(getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    }));
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    }));
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    }));
    List<ActionButtonDefinition<GlusterVolumeEntity>> volumeProfilingActions = new ArrayList<>();
    volumeProfilingActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolumeProfiling()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartVolumeProfilingCommand();
        }
    });
    volumeProfilingActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.volumeProfileDetails()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getShowVolumeProfileDetailsCommand();
        }
    });
    volumeProfilingActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolumeProfiling()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopVolumeProfilingCommand();
        }
    });
    addButtonToActionGroup(getTable().addActionButton(new WebAdminMenuBarButtonDefinition<>(constants.volumeProfilingAction(), volumeProfilingActions), new DropdownActionButton<GlusterVolumeEntity>(volumeProfilingActions, new DropdownActionButton.SelectedItemsProvider<GlusterVolumeEntity>() {

        @Override
        public List<GlusterVolumeEntity> getSelectedItems() {
            return getMainModel().getSelectedItems();
        }
    })));
    List<ActionButtonDefinition<GlusterVolumeEntity>> volumeSnapshotActions = getVolumeSnapshotMenu();
    addButtonToActionGroup(getTable().addActionButton(new WebAdminMenuBarButtonDefinition<>(constants.volumeSnapshotMainTabTitle(), volumeSnapshotActions), new DropdownActionButton<GlusterVolumeEntity>(volumeSnapshotActions, new DropdownActionButton.SelectedItemsProvider<GlusterVolumeEntity>() {

        @Override
        public List<GlusterVolumeEntity> getSelectedItems() {
            return getMainModel().getSelectedItems();
        }
    })));
    List<ActionButtonDefinition<GlusterVolumeEntity>> volumeGeoRepActions = getGeoRepCreateMenu(constants);
    addButtonToActionGroup(getTable().addActionButton(new WebAdminMenuBarButtonDefinition<>(constants.geoReplicationMainTabTitle(), volumeGeoRepActions), new DropdownActionButton<GlusterVolumeEntity>(volumeGeoRepActions, new DropdownActionButton.SelectedItemsProvider<GlusterVolumeEntity>() {

        @Override
        public List<GlusterVolumeEntity> getSelectedItems() {
            return getMainModel().getSelectedItems();
        }
    })));
}
#end_block

#method_before
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(MainModelProvider<Cluster, ClusterListModel<Void>> modelProvider, WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.clusterMainTabPlace);
    return new ModelBoundTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getPrimaryPriority(), modelProvider, menuTabDetails.getIcon());
}
#method_after
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.clusterMainTabPlace);
    return new GroupedTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryPriority(), menuTabDetails.getIcon());
}
#end_block

#method_before
@Override
public void setSelectionModel(SelectionModel<? super T> selectionModel) {
}
#method_after
@Override
public void setSelectionModel(SelectionModel<? super T> selectionModel) {
// No-op we use the search models own selection model. Just here to satisfy the interface contract.
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    bindPresenterWidget(AffinityLabelPopupPresenterWidget.class, AffinityLabelPopupPresenterWidget.ViewDef.class, AffinityLabelPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabEngineErrataPresenter.class, MainTabEngineErrataPresenter.ViewDef.class, MainTabEngineErrataView.class, MainTabEngineErrataPresenter.ProxyDef.class);
    bindPresenter(MainTabSessionPresenter.class, MainTabSessionPresenter.ViewDef.class, MainTabSessionView.class, MainTabSessionPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQosPresenter.class, SubTabDataCenterQosPresenter.ViewDef.class, SubTabDataCenterQosView.class, SubTabDataCenterQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<StoragePool, DataCenterListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<DataCenterListModel>>() {
    }, new TypeLiteral<SearchPanelView<DataCenterListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<StoragePool, DataCenterListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<StoragePool>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<StoragePool, DataCenterListModel>>() {
    });
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskPresenter.class, SubTabStorageRegisterDiskPresenter.ViewDef.class, SubTabStorageRegisterDiskView.class, SubTabStorageRegisterDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskImagePresenter.class, SubTabStorageRegisterDiskImagePresenter.ViewDef.class, SubTabStorageRegisterDiskImageView.class, SubTabStorageRegisterDiskImagePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDRPresenter.class, SubTabStorageDRPresenter.ViewDef.class, SubTabStorageDRView.class, SubTabStorageDRPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageLeasePresenter.class, SubTabStorageLeasePresenter.ViewDef.class, SubTabStorageLeaseView.class, SubTabStorageLeasePresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<StorageDomain, StorageListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<StorageListModel>>() {
    }, new TypeLiteral<SearchPanelView<StorageListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<StorageDomain, StorageListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<StorageDomain>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<StorageDomain, StorageListModel>>() {
    });
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    bindPresenterWidget(GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterClusterSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterVolumeSnapshotCreatePopupPresenterWidget.class, GlusterVolumeSnapshotCreatePopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotCreatePopupView.class);
    bindPresenter(SubTabClusterAffinityLabelPresenter.class, SubTabClusterAffinityLabelPresenter.ViewDef.class, SubTabClusterAffinityLabelView.class, SubTabClusterAffinityLabelPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Cluster, ClusterListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<ClusterListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<ClusterListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Cluster, ClusterListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Cluster>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Cluster, ClusterListModel<Void>>>() {
    });
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(HostGeneralSubTabPresenter.class, HostGeneralSubTabPresenter.ViewDef.class, HostGeneralSubTabView.class, HostGeneralSubTabPresenter.ProxyDef.class);
    bindPresenter(SubTabHostErrataPresenter.class, SubTabHostErrataPresenter.ViewDef.class, SubTabHostErrataView.class, SubTabHostErrataPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostDevicePresenter.class, SubTabHostDevicePresenter.ViewDef.class, SubTabHostDeviceView.class, SubTabHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterStorageDevicesPresenter.class, SubTabHostGlusterStorageDevicesPresenter.ViewDef.class, SubTabHostGlusterStorageDevicesView.class, SubTabHostGlusterStorageDevicesPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VDS, HostListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<HostListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<HostListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VDS, HostListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VDS>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VDS, HostListModel<Void>>>() {
    });
    bindPresenter(SubTabHostAffinityLabelPresenter.class, SubTabHostAffinityLabelPresenter.ViewDef.class, SubTabHostAffinityLabelView.class, SubTabHostAffinityLabelPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestContainerPresenter.class, SubTabVirtualMachineGuestContainerPresenter.ViewDef.class, SubTabVirtualMachineGuestContainerView.class, SubTabVirtualMachineGuestContainerPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVmDevicePresenter.class, SubTabVirtualMachineVmDevicePresenter.ViewDef.class, SubTabVirtualMachineVmDevicesView.class, SubTabVirtualMachineVmDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestInfoPresenter.class, SubTabVirtualMachineGuestInfoPresenter.ViewDef.class, SubTabVirtualMachineGuestInfoView.class, SubTabVirtualMachineGuestInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineHostDevicePresenter.class, SubTabVirtualMachineHostDevicePresenter.ViewDef.class, SubTabVirtualMachineHostDeviceView.class, SubTabVirtualMachineHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineErrataPresenter.class, SubTabVirtualMachineErrataPresenter.ViewDef.class, SubTabVirtualMachineErrataView.class, SubTabVirtualMachineErrataPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VM, VmListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<VmListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<VmListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VM, VmListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VM>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VM, VmListModel<Void>>>() {
    });
    bindPresenter(SubTabVirtualMachineAffinityLabelPresenter.class, SubTabVirtualMachineAffinityLabelPresenter.ViewDef.class, SubTabVirtualMachineAffinityLabelView.class, SubTabVirtualMachineAffinityLabelPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VmPool, PoolListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<PoolListModel>>() {
    }, new TypeLiteral<SearchPanelView<PoolListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VmPool, PoolListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VmPool>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VmPool, PoolListModel>>() {
    });
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VmTemplate, TemplateListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<TemplateListModel>>() {
    }, new TypeLiteral<SearchPanelView<TemplateListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VmTemplate, TemplateListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VmTemplate>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VmTemplate, TemplateListModel>>() {
    });
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<DbUser, UserListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<UserListModel>>() {
    }, new TypeLiteral<SearchPanelView<UserListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<DbUser, UserListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<DbUser>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<DbUser, UserListModel>>() {
    });
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Quota, QuotaListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<QuotaListModel>>() {
    }, new TypeLiteral<SearchPanelView<QuotaListModel>>() {
    });
    bindPresenterWidget(QuotaBreadCrumbsPresenterWidget.class, QuotaBreadCrumbsPresenterWidget.QuotaViewDef.class, QuotaBreadCrumbsView.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Disk, DiskListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<DiskListModel>>() {
    }, new TypeLiteral<SearchPanelView<DiskListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Disk, DiskListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Disk>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Disk, DiskListModel>>() {
    });
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<NetworkView, NetworkListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<NetworkListModel>>() {
    }, new TypeLiteral<SearchPanelView<NetworkListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<NetworkView, NetworkListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<NetworkView>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<NetworkView, NetworkListModel>>() {
    });
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderSecretPresenter.class, SubTabProviderSecretPresenter.ViewDef.class, SubTabProviderSecretView.class, SubTabProviderSecretPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Provider, ProviderListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<ProviderListModel>>() {
    }, new TypeLiteral<SearchPanelView<ProviderListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Provider, ProviderListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Provider>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Provider, ProviderListModel>>() {
    });
    // Errata
    bindPresenter(ErrataSubTabPanelPresenter.class, ErrataSubTabPanelPresenter.ViewDef.class, ErrataSubTabPanelView.class, ErrataSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabEngineErrataDetailsPresenter.class, SubTabEngineErrataDetailsPresenter.ViewDef.class, SubTabEngineErrataDetailsView.class, SubTabEngineErrataDetailsPresenter.ProxyDef.class);
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Erratum, EngineErrataListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Erratum>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Erratum, EngineErrataListModel>>() {
    });
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VnicProfileView, VnicProfileListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VnicProfileView>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VnicProfileView, VnicProfileListModel>>() {
    });
    // User Sessions
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<UserSession, SessionListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<SessionListModel>>() {
    }, new TypeLiteral<SearchPanelView<SessionListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<UserSession, SessionListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<UserSession>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<UserSession, SessionListModel>>() {
    });
    // Volume
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<GlusterVolumeEntity, VolumeListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<VolumeListModel>>() {
    }, new TypeLiteral<SearchPanelView<VolumeListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<GlusterVolumeEntity, VolumeListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<GlusterVolumeEntity>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<GlusterVolumeEntity, VolumeListModel>>() {
    });
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(ClusterWarningsPopupPresenterWidget.class, ClusterWarningsPopupPresenterWidget.ViewDef.class, ClusterWarningsPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.class, GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoReplicationSessionConfigPopupView.class);
    bindPresenterWidget(VolumeGeoRepSessionDetailsPopUpPresenterWidget.class, VolumeGeoRepSessionDetailsPopUpPresenterWidget.ViewDef.class, VolumeGeoRepSessionDetailsPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.class, GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoRepCreateSessionPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    bindPresenterWidget(AddDataCenterClusterPopupPresenterWidget.class, AddDataCenterClusterPopupPresenterWidget.ViewDef.class, AddDataCenterClusterPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(NetworkAttachmentPopupPresenterWidget.class, NetworkAttachmentPopupPresenterWidget.ViewDef.class, NetworkAttachmentPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(VfsConfigPopupPresenterWidget.class, VfsConfigPopupPresenterWidget.ViewDef.class, VfsConfigPopupView.class);
    bindPresenterWidget(SetupNetworksLabelPopupPresenterWidget.class, SetupNetworksLabelPopupPresenterWidget.ViewDef.class, SetupNetworksLabelPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    bindPresenterWidget(HostFenceAgentPopupPresenterWidget.class, HostFenceAgentPopupPresenterWidget.ViewDef.class, HostFenceAgentPopupView.class);
    bindPresenterWidget(HostFenceProxyPopupPresenterWidget.class, HostFenceProxyPopupPresenterWidget.ViewDef.class, HostFenceProxyPopupView.class);
    bindPresenterWidget(HostMaintenanceConfirmationPopupPresenterWidget.class, HostMaintenanceConfirmationPopupPresenterWidget.ViewDef.class, HostMaintenanceConfirmationPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportVmFromExternalProviderPopupPresenterWidget.class, ImportVmFromExternalProviderPopupPresenterWidget.ViewDef.class, ImportVmFromExternalProviderPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(VnicProfileMappingPopupPresenterWidget.class, VnicProfileMappingPopupPresenterWidget.ViewDef.class, VnicProfileMappingPopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    bindPresenterWidget(UploadImagePopupPresenterWidget.class, UploadImagePopupPresenterWidget.ViewDef.class, UploadImagePopupView.class);
    bindPresenterWidget(StorageDRPopupPresenterWidget.class, StorageDRPopupPresenterWidget.ViewDef.class, StorageDRPopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // VM Sparsify Disk
    bindPresenterWidget(VmDiskSparsifyPopupPresenterWidget.class, VmDiskSparsifyPopupPresenterWidget.ViewDef.class, VmDiskSparsifyPopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    bindPresenterWidget(StorageQosRemovePopupPresenterWidget.class, StorageQosRemovePopupPresenterWidget.ViewDef.class, StorageQosRemovePopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Host Devices
    bindPresenterWidget(AddVmHostDevicePopupPresenterWidget.class, AddVmHostDevicePopupPresenterWidget.ViewDef.class, AddVmHostDevicePopupView.class);
    bindPresenterWidget(VmRepinHostPopupPresenterWidget.class, VmRepinHostPopupPresenterWidget.ViewDef.class, VmRepinHostPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenter(SubTabGlusterVolumeSnapshotPresenter.class, SubTabGlusterVolumeSnapshotPresenter.ViewDef.class, SubTabGlusterVolumeSnapshotView.class, SubTabGlusterVolumeSnapshotPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(CreateBrickPopupPresenterWidget.class, CreateBrickPopupPresenterWidget.ViewDef.class, CreateBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<AuditLog, EventListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<EventListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<EventListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<AuditLog, EventListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<AuditLog>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<AuditLog, EventListModel<Void>>>() {
    });
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    bindPresenterWidget(ProviderSecretPopupPresenterWidget.class, ProviderSecretPopupPresenterWidget.ViewDef.class, ProviderSecretPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
    // Errata details
    bindPresenterWidget(HostErrataListWithDetailsPopupPresenterWidget.class, HostErrataListWithDetailsPopupPresenterWidget.ViewDef.class, HostErrataListWithDetailsPopupView.class);
    bindPresenterWidget(VmErrataListWithDetailsPopupPresenterWidget.class, VmErrataListWithDetailsPopupPresenterWidget.ViewDef.class, VmErrataListWithDetailsPopupView.class);
    // Overlays
    // Tasks
    bindPresenter(TasksPresenter.class, TasksPresenter.ViewDef.class, TasksView.class, TasksPresenter.ProxyDef.class);
    // Bookmarks
    bindPresenter(BookmarkPresenter.class, BookmarkPresenter.ViewDef.class, BookmarkView.class, BookmarkPresenter.ProxyDef.class);
    // Tags
    bindPresenter(TagsPresenter.class, TagsPresenter.ViewDef.class, TagsView.class, TagsPresenter.ProxyDef.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    bindPresenterWidget(AffinityLabelPopupPresenterWidget.class, AffinityLabelPopupPresenterWidget.ViewDef.class, AffinityLabelPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabEngineErrataPresenter.class, MainTabEngineErrataPresenter.ViewDef.class, MainTabEngineErrataView.class, MainTabEngineErrataPresenter.ProxyDef.class);
    bindPresenter(MainTabSessionPresenter.class, MainTabSessionPresenter.ViewDef.class, MainTabSessionView.class, MainTabSessionPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQosPresenter.class, SubTabDataCenterQosPresenter.ViewDef.class, SubTabDataCenterQosView.class, SubTabDataCenterQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<StoragePool, DataCenterListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<DataCenterListModel>>() {
    }, new TypeLiteral<SearchPanelView<DataCenterListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<StoragePool, DataCenterListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<StoragePool>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<StoragePool, DataCenterListModel>>() {
    });
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskPresenter.class, SubTabStorageRegisterDiskPresenter.ViewDef.class, SubTabStorageRegisterDiskView.class, SubTabStorageRegisterDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskImagePresenter.class, SubTabStorageRegisterDiskImagePresenter.ViewDef.class, SubTabStorageRegisterDiskImageView.class, SubTabStorageRegisterDiskImagePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDRPresenter.class, SubTabStorageDRPresenter.ViewDef.class, SubTabStorageDRView.class, SubTabStorageDRPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageLeasePresenter.class, SubTabStorageLeasePresenter.ViewDef.class, SubTabStorageLeaseView.class, SubTabStorageLeasePresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<StorageDomain, StorageListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<StorageListModel>>() {
    }, new TypeLiteral<SearchPanelView<StorageListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<StorageDomain, StorageListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<StorageDomain>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<StorageDomain, StorageListModel>>() {
    });
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    bindPresenterWidget(GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterClusterSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterVolumeSnapshotCreatePopupPresenterWidget.class, GlusterVolumeSnapshotCreatePopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotCreatePopupView.class);
    bindPresenter(SubTabClusterAffinityLabelPresenter.class, SubTabClusterAffinityLabelPresenter.ViewDef.class, SubTabClusterAffinityLabelView.class, SubTabClusterAffinityLabelPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Cluster, ClusterListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<ClusterListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<ClusterListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Cluster, ClusterListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Cluster>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Cluster, ClusterListModel<Void>>>() {
    });
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(HostGeneralSubTabPresenter.class, HostGeneralSubTabPresenter.ViewDef.class, HostGeneralSubTabView.class, HostGeneralSubTabPresenter.ProxyDef.class);
    bindPresenter(SubTabHostErrataPresenter.class, SubTabHostErrataPresenter.ViewDef.class, SubTabHostErrataView.class, SubTabHostErrataPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostDevicePresenter.class, SubTabHostDevicePresenter.ViewDef.class, SubTabHostDeviceView.class, SubTabHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterStorageDevicesPresenter.class, SubTabHostGlusterStorageDevicesPresenter.ViewDef.class, SubTabHostGlusterStorageDevicesView.class, SubTabHostGlusterStorageDevicesPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VDS, HostListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<HostListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<HostListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VDS, HostListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VDS>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VDS, HostListModel<Void>>>() {
    });
    bindPresenter(SubTabHostAffinityLabelPresenter.class, SubTabHostAffinityLabelPresenter.ViewDef.class, SubTabHostAffinityLabelView.class, SubTabHostAffinityLabelPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestContainerPresenter.class, SubTabVirtualMachineGuestContainerPresenter.ViewDef.class, SubTabVirtualMachineGuestContainerView.class, SubTabVirtualMachineGuestContainerPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVmDevicePresenter.class, SubTabVirtualMachineVmDevicePresenter.ViewDef.class, SubTabVirtualMachineVmDevicesView.class, SubTabVirtualMachineVmDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestInfoPresenter.class, SubTabVirtualMachineGuestInfoPresenter.ViewDef.class, SubTabVirtualMachineGuestInfoView.class, SubTabVirtualMachineGuestInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineHostDevicePresenter.class, SubTabVirtualMachineHostDevicePresenter.ViewDef.class, SubTabVirtualMachineHostDeviceView.class, SubTabVirtualMachineHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineErrataPresenter.class, SubTabVirtualMachineErrataPresenter.ViewDef.class, SubTabVirtualMachineErrataView.class, SubTabVirtualMachineErrataPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VM, VmListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<VmListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<VmListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VM, VmListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VM>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VM, VmListModel<Void>>>() {
    });
    bindPresenter(SubTabVirtualMachineAffinityLabelPresenter.class, SubTabVirtualMachineAffinityLabelPresenter.ViewDef.class, SubTabVirtualMachineAffinityLabelView.class, SubTabVirtualMachineAffinityLabelPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VmPool, PoolListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<PoolListModel>>() {
    }, new TypeLiteral<SearchPanelView<PoolListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VmPool, PoolListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VmPool>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VmPool, PoolListModel>>() {
    });
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VmTemplate, TemplateListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<TemplateListModel>>() {
    }, new TypeLiteral<SearchPanelView<TemplateListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VmTemplate, TemplateListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VmTemplate>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VmTemplate, TemplateListModel>>() {
    });
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<DbUser, UserListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<UserListModel>>() {
    }, new TypeLiteral<SearchPanelView<UserListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<DbUser, UserListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<DbUser>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<DbUser, UserListModel>>() {
    });
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Quota, QuotaListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<QuotaListModel>>() {
    }, new TypeLiteral<SearchPanelView<QuotaListModel>>() {
    });
    bindPresenterWidget(QuotaBreadCrumbsPresenterWidget.class, QuotaBreadCrumbsPresenterWidget.QuotaBreadCrumbsViewDef.class, QuotaBreadCrumbsView.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Disk, DiskListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<DiskListModel>>() {
    }, new TypeLiteral<SearchPanelView<DiskListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Disk, DiskListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Disk>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Disk, DiskListModel>>() {
    });
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<NetworkView, NetworkListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<NetworkListModel>>() {
    }, new TypeLiteral<SearchPanelView<NetworkListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<NetworkView, NetworkListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<NetworkView>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<NetworkView, NetworkListModel>>() {
    });
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderSecretPresenter.class, SubTabProviderSecretPresenter.ViewDef.class, SubTabProviderSecretView.class, SubTabProviderSecretPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Provider, ProviderListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<ProviderListModel>>() {
    }, new TypeLiteral<SearchPanelView<ProviderListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Provider, ProviderListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Provider>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Provider, ProviderListModel>>() {
    });
    // Errata
    bindPresenter(ErrataSubTabPanelPresenter.class, ErrataSubTabPanelPresenter.ViewDef.class, ErrataSubTabPanelView.class, ErrataSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabEngineErrataDetailsPresenter.class, SubTabEngineErrataDetailsPresenter.ViewDef.class, SubTabEngineErrataDetailsView.class, SubTabEngineErrataDetailsPresenter.ProxyDef.class);
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Erratum, EngineErrataListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Erratum>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Erratum, EngineErrataListModel>>() {
    });
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VnicProfileView, VnicProfileListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VnicProfileView>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VnicProfileView, VnicProfileListModel>>() {
    });
    // User Sessions
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<UserSession, SessionListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<SessionListModel>>() {
    }, new TypeLiteral<SearchPanelView<SessionListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<UserSession, SessionListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<UserSession>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<UserSession, SessionListModel>>() {
    });
    // Volume
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<GlusterVolumeEntity, VolumeListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<VolumeListModel>>() {
    }, new TypeLiteral<SearchPanelView<VolumeListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<GlusterVolumeEntity, VolumeListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<GlusterVolumeEntity>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<GlusterVolumeEntity, VolumeListModel>>() {
    });
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(ClusterWarningsPopupPresenterWidget.class, ClusterWarningsPopupPresenterWidget.ViewDef.class, ClusterWarningsPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.class, GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoReplicationSessionConfigPopupView.class);
    bindPresenterWidget(VolumeGeoRepSessionDetailsPopUpPresenterWidget.class, VolumeGeoRepSessionDetailsPopUpPresenterWidget.ViewDef.class, VolumeGeoRepSessionDetailsPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.class, GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoRepCreateSessionPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    bindPresenterWidget(AddDataCenterClusterPopupPresenterWidget.class, AddDataCenterClusterPopupPresenterWidget.ViewDef.class, AddDataCenterClusterPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(NetworkAttachmentPopupPresenterWidget.class, NetworkAttachmentPopupPresenterWidget.ViewDef.class, NetworkAttachmentPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(VfsConfigPopupPresenterWidget.class, VfsConfigPopupPresenterWidget.ViewDef.class, VfsConfigPopupView.class);
    bindPresenterWidget(SetupNetworksLabelPopupPresenterWidget.class, SetupNetworksLabelPopupPresenterWidget.ViewDef.class, SetupNetworksLabelPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    bindPresenterWidget(HostFenceAgentPopupPresenterWidget.class, HostFenceAgentPopupPresenterWidget.ViewDef.class, HostFenceAgentPopupView.class);
    bindPresenterWidget(HostFenceProxyPopupPresenterWidget.class, HostFenceProxyPopupPresenterWidget.ViewDef.class, HostFenceProxyPopupView.class);
    bindPresenterWidget(HostMaintenanceConfirmationPopupPresenterWidget.class, HostMaintenanceConfirmationPopupPresenterWidget.ViewDef.class, HostMaintenanceConfirmationPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportVmFromExternalProviderPopupPresenterWidget.class, ImportVmFromExternalProviderPopupPresenterWidget.ViewDef.class, ImportVmFromExternalProviderPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(VnicProfileMappingPopupPresenterWidget.class, VnicProfileMappingPopupPresenterWidget.ViewDef.class, VnicProfileMappingPopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    bindPresenterWidget(UploadImagePopupPresenterWidget.class, UploadImagePopupPresenterWidget.ViewDef.class, UploadImagePopupView.class);
    bindPresenterWidget(StorageDRPopupPresenterWidget.class, StorageDRPopupPresenterWidget.ViewDef.class, StorageDRPopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // VM Sparsify Disk
    bindPresenterWidget(VmDiskSparsifyPopupPresenterWidget.class, VmDiskSparsifyPopupPresenterWidget.ViewDef.class, VmDiskSparsifyPopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    bindPresenterWidget(StorageQosRemovePopupPresenterWidget.class, StorageQosRemovePopupPresenterWidget.ViewDef.class, StorageQosRemovePopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Host Devices
    bindPresenterWidget(AddVmHostDevicePopupPresenterWidget.class, AddVmHostDevicePopupPresenterWidget.ViewDef.class, AddVmHostDevicePopupView.class);
    bindPresenterWidget(VmRepinHostPopupPresenterWidget.class, VmRepinHostPopupPresenterWidget.ViewDef.class, VmRepinHostPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenter(SubTabGlusterVolumeSnapshotPresenter.class, SubTabGlusterVolumeSnapshotPresenter.ViewDef.class, SubTabGlusterVolumeSnapshotView.class, SubTabGlusterVolumeSnapshotPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(CreateBrickPopupPresenterWidget.class, CreateBrickPopupPresenterWidget.ViewDef.class, CreateBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<AuditLog, EventListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<EventListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<EventListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<AuditLog, EventListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<AuditLog>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<AuditLog, EventListModel<Void>>>() {
    });
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    bindPresenterWidget(ProviderSecretPopupPresenterWidget.class, ProviderSecretPopupPresenterWidget.ViewDef.class, ProviderSecretPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
    // Errata details
    bindPresenterWidget(HostErrataListWithDetailsPopupPresenterWidget.class, HostErrataListWithDetailsPopupPresenterWidget.ViewDef.class, HostErrataListWithDetailsPopupView.class);
    bindPresenterWidget(VmErrataListWithDetailsPopupPresenterWidget.class, VmErrataListWithDetailsPopupPresenterWidget.ViewDef.class, VmErrataListWithDetailsPopupView.class);
    // Overlays
    // Tasks
    bindPresenter(TasksPresenter.class, TasksPresenter.ViewDef.class, TasksView.class, TasksPresenter.ProxyDef.class);
    // Bookmarks
    bindPresenter(BookmarkPresenter.class, BookmarkPresenter.ViewDef.class, BookmarkView.class, BookmarkPresenter.ProxyDef.class);
    // Tags
    bindPresenter(TagsPresenter.class, TagsPresenter.ViewDef.class, TagsView.class, TagsPresenter.ProxyDef.class);
}
#end_block

#method_before
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(MainModelProvider<VDS, HostListModel<Void>> modelProvider, WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.hostMainTabPlace);
    return new ModelBoundTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getPrimaryPriority(), modelProvider, menuTabDetails.getIcon());
}
#method_after
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.hostMainTabPlace);
    return new GroupedTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryPriority(), menuTabDetails.getIcon());
}
#end_block

#method_before
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(MainModelProvider<StorageDomain, StorageListModel> modelProvider, WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.storageMainTabPlace);
    return new ModelBoundTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getPrimaryPriority(), modelProvider, menuTabDetails.getIcon());
}
#method_after
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.storageMainTabPlace);
    return new GroupedTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryPriority(), menuTabDetails.getIcon());
}
#end_block

#method_before
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(MainModelProvider<DbUser, UserListModel> modelProvider, WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.userMainTabPlace);
    return new ModelBoundTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getPrimaryPriority(), modelProvider, menuTabDetails.getIcon());
}
#method_after
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.userMainTabPlace);
    return new GroupedTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryPriority(), menuTabDetails.getIcon());
}
#end_block

#method_before
@Override
public void setInSlot(Object slot, IsWidget content) {
    if (slot == AbstractMainTabWithDetailsPresenter.TYPE_SetSearchPanel) {
        if (content != null) {
            actionPanel.setSearchPanel(content);
            actionPanel.setVisible(true);
        }
    } else if (slot == AbstractMainTabWithDetailsPresenter.TYPE_SetBreadCrumbs) {
        if (content != null) {
            breadCrumbsColumn.clear();
            breadCrumbsColumn.add(content);
        }
    } else {
        super.setInSlot(slot, content);
    }
}
#method_after
@Override
public void setInSlot(Object slot, IsWidget content) {
    if (slot == AbstractMainTabWithDetailsPresenter.TYPE_SetSearchPanel) {
        if (content != null) {
            actionPanel.setSearchPanel(content);
            actionPanel.setVisible(true);
        } else {
            actionPanel.setVisible(false);
        }
    } else if (slot == AbstractMainTabWithDetailsPresenter.TYPE_SetBreadCrumbs) {
        breadCrumbsColumn.clear();
        if (content != null) {
            breadCrumbsColumn.add(content);
        }
    } else {
        super.setInSlot(slot, content);
    }
}
#end_block

#method_before
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(MainModelProvider<Quota, QuotaListModel> modelProvider, WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.quotaMainTabPlace);
    return new ModelBoundTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getPrimaryPriority(), modelProvider, menuTabDetails.getIcon());
}
#method_after
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.quotaMainTabPlace);
    return new GroupedTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryPriority(), menuTabDetails.getIcon());
}
#end_block

#method_before
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(MainModelProvider<NetworkView, NetworkListModel> modelProvider, WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.networkMainTabPlace);
    return new ModelBoundTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getPrimaryPriority(), modelProvider, menuTabDetails.getIcon());
}
#method_after
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.networkMainTabPlace);
    return new GroupedTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryPriority(), menuTabDetails.getIcon());
}
#end_block

#method_before
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(MainModelProvider<UserSession, SessionListModel> modelProvider, WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.sessionMainTabPlace);
    return new ModelBoundTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getPrimaryPriority(), modelProvider, menuTabDetails.getIcon());
}
#method_after
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.sessionMainTabPlace);
    return new GroupedTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryPriority(), menuTabDetails.getIcon());
}
#end_block

#method_before
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(MainModelProvider<GlusterVolumeEntity, VolumeListModel> modelProvider, WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.volumeMainTabPlace);
    return new ModelBoundTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getPrimaryPriority(), modelProvider, menuTabDetails.getIcon());
}
#method_after
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.volumeMainTabPlace);
    return new GroupedTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryPriority(), menuTabDetails.getIcon());
}
#end_block

#method_before
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(MainModelProvider<Provider, ProviderListModel> modelProvider, WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.providerMainTabPlace);
    return new ModelBoundTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getPrimaryPriority(), modelProvider, menuTabDetails.getIcon());
}
#method_after
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.providerMainTabPlace);
    return new GroupedTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryPriority(), menuTabDetails.getIcon());
}
#end_block

#method_before
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(MainModelProvider<VnicProfileView, VnicProfileListModel> modelProvider, WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.vnicProfileMainTabPlace);
    return new ModelBoundTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getPrimaryPriority(), modelProvider, menuTabDetails.getIcon());
}
#method_after
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.vnicProfileMainTabPlace);
    return new GroupedTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryPriority(), menuTabDetails.getIcon());
}
#end_block

#method_before
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(MainModelProvider<VmPool, PoolListModel> modelProvider, WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.poolMainTabPlace);
    return new ModelBoundTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getPrimaryPriority(), modelProvider, menuTabDetails.getIcon());
}
#method_after
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.poolMainTabPlace);
    return new GroupedTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryPriority(), menuTabDetails.getIcon());
}
#end_block

#method_before
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(MainModelProvider<StoragePool, DataCenterListModel> modelProvider, WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.dataCenterMainTabPlace);
    return new ModelBoundTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getPrimaryPriority(), modelProvider, menuTabDetails.getIcon());
}
#method_after
@TabInfo(container = MainTabPanelPresenter.class)
static TabData getTabData(WebadminMenuLayout menuLayout) {
    MenuLayoutMenuDetails menuTabDetails = menuLayout.getDetails(WebAdminApplicationPlaces.dataCenterMainTabPlace);
    return new GroupedTabData(menuTabDetails.getSecondaryTitle(), menuTabDetails.getPrimaryTitle(), menuTabDetails.getSecondaryPriority(), menuTabDetails.getPrimaryPriority(), menuTabDetails.getIcon());
}
#end_block

#method_before
@Override
public void onLoad() {
    super.onLoad();
    keyHandler = Event.addNativePreviewHandler(event -> {
        NativeEvent nativeEvent = event.getNativeEvent();
        if (breadCrumbs != null) {
            if (event.getTypeInt() == Event.ONKEYDOWN) {
                if (nativeEvent.getCharCode() == 's' || nativeEvent.getKeyCode() == KeyCodes.KEY_S) {
                    if (nativeEvent.getCtrlKey() && nativeEvent.getAltKey()) {
                        nativeEvent.preventDefault();
                        nativeEvent.stopPropagation();
                        SimpleTabPanel.this.breadCrumbs.getView().toggleSearchWidget();
                        event.cancel();
                    }
                } else if (!SimpleTabPanel.this.breadCrumbs.getView().isSearchVisible() && nativeEvent.getKeyCode() == KeyCodes.KEY_DOWN) {
                    nativeEvent.preventDefault();
                    nativeEvent.stopPropagation();
                    SimpleTabPanel.this.breadCrumbs.nextEntity();
                    event.cancel();
                } else if (!SimpleTabPanel.this.breadCrumbs.getView().isSearchVisible() && nativeEvent.getKeyCode() == KeyCodes.KEY_UP) {
                    nativeEvent.preventDefault();
                    nativeEvent.stopPropagation();
                    SimpleTabPanel.this.breadCrumbs.previousEntity();
                    event.cancel();
                }
            }
        }
    });
    if (breadCrumbs != null) {
        if (breadCrumbsContainer.getWidgetCount() == 0) {
            breadCrumbsContainer.add(breadCrumbs);
        }
    }
}
#method_after
@Override
public void onLoad() {
    super.onLoad();
    keyHandler = Event.addNativePreviewHandler(event -> {
        NativeEvent nativeEvent = event.getNativeEvent();
        if (breadCrumbs != null) {
            if (event.getTypeInt() == Event.ONKEYDOWN) {
                if (nativeEvent.getCharCode() == 's' || nativeEvent.getKeyCode() == KeyCodes.KEY_S) {
                    if (nativeEvent.getCtrlKey() && nativeEvent.getAltKey()) {
                        nativeEvent.preventDefault();
                        nativeEvent.stopPropagation();
                        SimpleTabPanel.this.breadCrumbs.toggleSearch();
                        event.cancel();
                    }
                } else if (!SimpleTabPanel.this.breadCrumbs.isSearchVisible() && nativeEvent.getKeyCode() == KeyCodes.KEY_DOWN) {
                    nativeEvent.preventDefault();
                    nativeEvent.stopPropagation();
                    SimpleTabPanel.this.breadCrumbs.nextEntity();
                    event.cancel();
                } else if (!SimpleTabPanel.this.breadCrumbs.isSearchVisible() && nativeEvent.getKeyCode() == KeyCodes.KEY_UP) {
                    nativeEvent.preventDefault();
                    nativeEvent.stopPropagation();
                    SimpleTabPanel.this.breadCrumbs.previousEntity();
                    event.cancel();
                }
            }
        }
    });
    if (breadCrumbs != null) {
        if (breadCrumbsContainer.getWidgetCount() == 0) {
            breadCrumbsContainer.add(breadCrumbs);
        }
    }
}
#end_block

#method_before
@TabInfo(container = StorageSubTabPanelPresenter.class)
static TabData getTabData(SearchableDetailModelProvider<StorageDomainDR, StorageListModel, StorageDRListModel> modelProvider) {
    return new GroupedTabData(constants.storageDRSubTabLabel(), 12);
}
#method_after
@TabInfo(container = StorageSubTabPanelPresenter.class)
static TabData getTabData() {
    return new GroupedTabData(constants.storageDRSubTabLabel(), 12);
}
#end_block

#method_before
@TabInfo(container = DiskSubTabPanelPresenter.class)
static TabData getTabData(SearchableDetailModelProvider<Permission, DiskListModel, PermissionListModel<Disk>> modelProvider) {
    return new GroupedTabData(constants.diskPermissionSubTabLabel(), 4);
}
#method_after
@TabInfo(container = DiskSubTabPanelPresenter.class)
static TabData getTabData() {
    return new GroupedTabData(constants.diskPermissionSubTabLabel(), 4);
}
#end_block

#method_before
@TabInfo(container = TemplateSubTabPanelPresenter.class)
static TabData getTabData(SearchableDetailModelProvider<Permission, TemplateListModel, PermissionListModel<VmTemplate>> modelProvider) {
    return new GroupedTabData(constants.templatePermissionSubTabLabel(), 5);
}
#method_after
@TabInfo(container = TemplateSubTabPanelPresenter.class)
static TabData getTabData() {
    return new GroupedTabData(constants.templatePermissionSubTabLabel(), 5);
}
#end_block

#method_before
@TabInfo(container = StorageSubTabPanelPresenter.class)
static TabData getTabData(SearchableDetailModelProvider<Permission, StorageListModel, PermissionListModel<StorageDomain>> modelProvider) {
    return new GroupedTabData(constants.storagePermissionSubTabLabel(), 13);
}
#method_after
@TabInfo(container = StorageSubTabPanelPresenter.class)
static TabData getTabData() {
    return new GroupedTabData(constants.storagePermissionSubTabLabel(), 13);
}
#end_block

#method_before
@TabInfo(container = StorageSubTabPanelPresenter.class)
static TabData getTabData(SearchableDetailModelProvider<VmTemplate, StorageListModel, StorageRegisterTemplateListModel> modelProvider) {
    return new GroupedTabData(constants.storageTemplateBackupSubTabLabel(), 3);
}
#method_after
@TabInfo(container = StorageSubTabPanelPresenter.class)
static TabData getTabData() {
    return new GroupedTabData(constants.storageTemplateBackupSubTabLabel(), 3);
}
#end_block

#method_before
@TabInfo(container = VolumeSubTabPanelPresenter.class)
static TabData getTabData(SearchableDetailModelProvider<Permission, VolumeListModel, PermissionListModel<GlusterVolumeEntity>> modelProvider) {
    return new GroupedTabData(constants.volumePermissionSubTabLabel(), 3);
}
#method_after
@TabInfo(container = VolumeSubTabPanelPresenter.class)
static TabData getTabData() {
    return new GroupedTabData(constants.volumePermissionSubTabLabel(), 3);
}
#end_block

#method_before
@TabInfo(container = ErrataSubTabPanelPresenter.class)
static TabData getTabData(DetailTabModelProvider<EngineErrataListModel, EntityModel<Erratum>> modelProvider) {
    return new GroupedTabData(constants.errataDetailsSubTabLabel(), 1);
}
#method_after
@TabInfo(container = ErrataSubTabPanelPresenter.class)
static TabData getTabData() {
    return new GroupedTabData(constants.errataDetailsSubTabLabel(), 1);
}
#end_block

#method_before
@TabInfo(container = VolumeSubTabPanelPresenter.class)
static TabData getTabData(SearchableDetailModelProvider<GlusterGeoRepSession, VolumeListModel, VolumeGeoRepListModel> modelProvider) {
    return new GroupedTabData(constants.volumeGeoRepSubTabLabel(), 4);
}
#method_after
@TabInfo(container = VolumeSubTabPanelPresenter.class)
static TabData getTabData() {
    return new GroupedTabData(constants.volumeGeoRepSubTabLabel(), 4);
}
#end_block

#method_before
@TabInfo(container = PoolSubTabPanelPresenter.class)
static TabData getTabData(SearchableDetailModelProvider<Permission, PoolListModel, PermissionListModel<VmPool>> modelProvider) {
    return new GroupedTabData(constants.poolPermissionSubTabLabel(), 2);
}
#method_after
@TabInfo(container = PoolSubTabPanelPresenter.class)
static TabData getTabData() {
    return new GroupedTabData(constants.poolPermissionSubTabLabel(), 2);
}
#end_block

#method_before
@TabInfo(container = DataCenterSubTabPanelPresenter.class)
static TabData getTabData(SearchableDetailModelProvider<Permission, DataCenterListModel, PermissionListModel<StoragePool>> modelProvider) {
    return new GroupedTabData(constants.dataCenterPermissionSubTabLabel(), 5);
}
#method_after
@TabInfo(container = DataCenterSubTabPanelPresenter.class)
static TabData getTabData() {
    return new GroupedTabData(constants.dataCenterPermissionSubTabLabel(), 5);
}
#end_block

#method_before
public List<RepoImage> getUserRequestForStorageDomainRepoFileList(Guid storageDomainId, ImageFileType imageType, boolean forceRefresh) {
    // Query for storageDoaminId is looking for Active ISO domain
    if (!isStorageDomainIdValid(storageDomainId)) {
        throw new EngineException(EngineError.GetIsoListError);
    }
    if (forceRefresh) {
        if (refreshRepos(storageDomainId, imageType)) {
            throw new EngineException(EngineError.IMAGES_NOT_SUPPORTED_ERROR);
        }
    } else {
        refreshReposIfIntervalPassed(storageDomainId, imageType);
    }
    // In any case, whether refreshed or not, get Iso list from the cache.
    return getCachedIsoListByDomainId(storageDomainId, imageType);
}
#method_after
public List<RepoImage> getUserRequestForStorageDomainRepoFileList(Guid storageDomainId, ImageFileType imageType, boolean forceRefresh) {
    // Query for storageDoaminId is looking for Active ISO domain
    if (!isStorageDomainIdValid(storageDomainId)) {
        throw new EngineException(EngineError.GetIsoListError);
    }
    refreshReposIfNeeded(storageDomainId, imageType, forceRefresh);
    // In any case, whether refreshed or not, get Iso list from the cache.
    return getCachedIsoListByDomainId(storageDomainId, imageType);
}
#end_block

#method_before
private boolean shouldInvalidateCache(long lastRefreshed) {
    return System.currentTimeMillis() > lastRefreshed + invalidateCachePeriod;
}
#method_after
private boolean shouldInvalidateCache(long lastRefreshed) {
    return System.currentTimeMillis() > lastRefreshed + getInvalidateCachePeriodFromConfig();
}
#end_block

#method_before
protected void authenticateWithSso(HttpServletRequest req, HttpServletResponse res) throws ServletException {
    String headerValue = req.getHeader(FiltersHelper.Constants.HEADER_AUTHORIZATION);
    if (headerValue != null && (headerValue.startsWith(BASIC) || headerValue.startsWith(BEARER))) {
        try {
            String token;
            boolean userSessionExists = false;
            if (headerValue.startsWith(BASIC)) {
                log.debug("SsoRestApiAuthFilter authenticating using BASIC header");
                Map<String, Object> response = SsoOAuthServiceUtils.authenticate(req, scope);
                FiltersHelper.isStatusOk(response);
                token = (String) response.get("access_token");
                log.debug("SsoRestApiAuthFilter successfully authenticated using BASIC header");
            } else if (headerValue.startsWith(BEARER)) {
                log.debug("SsoRestApiAuthFilter authenticating using BEARER header");
                token = headerValue.substring("Bearer".length()).trim();
                InitialContext ctx = new InitialContext();
                try {
                    VdcQueryReturnValue queryRetVal = FiltersHelper.getBackend(ctx).runPublicQuery(VdcQueryType.GetEngineSessionIdForSsoToken, new GetEngineSessionIdForSsoTokenQueryParameters(token));
                    if (queryRetVal.getSucceeded() && StringUtils.isNotEmpty(queryRetVal.getReturnValue())) {
                        log.debug("SsoRestApiAuthFilter successfully authenticated using BEARER header");
                        req.setAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY, queryRetVal.getReturnValue());
                        req.setAttribute(FiltersHelper.Constants.REQUEST_LOGIN_FILTER_AUTHENTICATION_DONE, true);
                        userSessionExists = true;
                    }
                } finally {
                    ctx.close();
                }
            } else {
                throw new RuntimeException(String.format("Unsupported authentication header: %s", headerValue));
            }
            if (!userSessionExists) {
                Map<String, Object> payload = FiltersHelper.getPayloadForToken(token);
                String scope = (String) payload.get("scope");
                if (StringUtils.isEmpty(scope) || !Arrays.asList(scope.trim().split("\\s *")).contains("ovirt-app-api")) {
                    throw new RuntimeException("The required scope ovirt-app-api is not granted.");
                }
                SsoUtils.createUserSession(req, payload, false);
            }
        } catch (Exception e) {
            req.setAttribute(SessionConstants.SSO_AUTHENTICATION_ERR_MSG, e.getMessage());
            log.error("Cannot authenticate using authentication Headers: {}", e.getMessage());
            log.debug("Cannot authenticate using authentication Headers", e);
        }
    }
}
#method_after
protected void authenticateWithSso(HttpServletRequest req, HttpServletResponse res) throws ServletException {
    String headerValue = req.getHeader(FiltersHelper.Constants.HEADER_AUTHORIZATION);
    if (headerValue != null && (headerValue.startsWith(BASIC) || headerValue.startsWith(BEARER))) {
        try {
            String token;
            boolean userSessionExists = false;
            if (headerValue.startsWith(BASIC)) {
                log.debug("SsoRestApiAuthFilter authenticating using BASIC header");
                Map<String, Object> response = SsoOAuthServiceUtils.authenticate(req, scope);
                FiltersHelper.isStatusOk(response);
                token = (String) response.get("access_token");
                log.debug("SsoRestApiAuthFilter successfully authenticated using BASIC header");
            } else if (headerValue.startsWith(BEARER)) {
                log.debug("SsoRestApiAuthFilter authenticating using BEARER header");
                token = headerValue.substring("Bearer".length()).trim();
                InitialContext ctx = new InitialContext();
                try {
                    QueryReturnValue queryRetVal = FiltersHelper.getBackend(ctx).runPublicQuery(QueryType.GetEngineSessionIdForSsoToken, new GetEngineSessionIdForSsoTokenQueryParameters(token));
                    if (queryRetVal.getSucceeded() && StringUtils.isNotEmpty(queryRetVal.getReturnValue())) {
                        log.debug("SsoRestApiAuthFilter successfully authenticated using BEARER header");
                        req.setAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY, queryRetVal.getReturnValue());
                        req.setAttribute(FiltersHelper.Constants.REQUEST_LOGIN_FILTER_AUTHENTICATION_DONE, true);
                        userSessionExists = true;
                    }
                } finally {
                    ctx.close();
                }
            } else {
                throw new RuntimeException(String.format("Unsupported authentication header: %s", headerValue));
            }
            if (!userSessionExists) {
                Map<String, Object> payload = FiltersHelper.getPayloadForToken(token);
                String scope = (String) payload.get("scope");
                if (StringUtils.isEmpty(scope) || !Arrays.asList(scope.trim().split("\\s *")).contains("ovirt-app-api")) {
                    throw new RuntimeException("The required scope ovirt-app-api is not granted.");
                }
                SsoUtils.createUserSession(req, payload, false);
            }
        } catch (Exception e) {
            req.setAttribute(SessionConstants.SSO_AUTHENTICATION_ERR_MSG, e.getMessage());
            log.error("Cannot authenticate using authentication Headers: {}", e.getMessage());
            log.debug("Cannot authenticate using authentication Headers", e);
        }
    }
}
#end_block

#method_before
@Override
public void init(FilterConfig filterConfig) throws ServletException {
    for (String paramName : Collections.list(filterConfig.getInitParameterNames())) {
        if (paramName.startsWith("scheme")) {
            additionalSchemes.add(filterConfig.getInitParameter(paramName));
        }
    }
    defaultVersion = EngineLocalConfig.getInstance().getProperty("ENGINE_API_DEFAULT_VERSION");
}
#method_after
@Override
public void init(FilterConfig filterConfig) throws ServletException {
    for (String paramName : Collections.list(filterConfig.getInitParameterNames())) {
        if (paramName.startsWith("scheme")) {
            additionalSchemes.add(filterConfig.getInitParameter(paramName));
        }
    }
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest req = (HttpServletRequest) request;
    HttpServletResponse res = (HttpServletResponse) response;
    if (FiltersHelper.isAuthenticated(req)) {
        chain.doFilter(request, response);
    } else {
        @SuppressWarnings("unchecked")
        List<String> schemes = (List<String>) req.getAttribute(FiltersHelper.Constants.REQUEST_SCHEMES_KEY);
        if (schemes == null) {
            schemes = Collections.emptyList();
        }
        Set<String> allSchemes = new HashSet<>(schemes);
        if (additionalSchemes != null) {
            allSchemes.addAll(additionalSchemes);
        }
        for (String scheme : allSchemes) {
            res.setHeader(FiltersHelper.Constants.HEADER_WWW_AUTHENTICATE, scheme);
        }
        if (req.getContextPath().endsWith("/api")) {
            req.getRequestDispatcher(String.format(ERROR_URL_FORMAT, defaultVersion, req.getAttribute(SessionConstants.SSO_AUTHENTICATION_ERR_MSG))).forward(req, res);
        } else {
            res.sendError(HttpServletResponse.SC_UNAUTHORIZED);
        }
    }
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest req = (HttpServletRequest) request;
    HttpServletResponse res = (HttpServletResponse) response;
    if (FiltersHelper.isAuthenticated(req)) {
        chain.doFilter(request, response);
    } else {
        @SuppressWarnings("unchecked")
        List<String> schemes = (List<String>) req.getAttribute(FiltersHelper.Constants.REQUEST_SCHEMES_KEY);
        if (schemes == null) {
            schemes = Collections.emptyList();
        }
        Set<String> allSchemes = new HashSet<>(schemes);
        if (additionalSchemes != null) {
            allSchemes.addAll(additionalSchemes);
        }
        for (String scheme : allSchemes) {
            res.setHeader(FiltersHelper.Constants.HEADER_WWW_AUTHENTICATE, scheme);
        }
        String errMsg = (String) req.getAttribute(SessionConstants.SSO_AUTHENTICATION_ERR_MSG);
        if (StringUtils.isEmpty(errMsg)) {
            res.sendError(HttpServletResponse.SC_UNAUTHORIZED);
        } else {
            res.sendError(HttpServletResponse.SC_UNAUTHORIZED, errMsg);
        }
    }
}
#end_block

#method_before
@Override
public void taskSubmitted(Future<?> future, ManagedExecutorService managedExecutorService, Object o) {
}
#method_after
@Override
public void taskSubmitted(Future<?> future, ManagedExecutorService managedExecutorService, Object o) {
    log.debug("Task submitted: {}", Thread.currentThread().getName());
}
#end_block

#method_before
@Override
public void run() {
    String threadName = Thread.currentThread().getName();
    log.info("Executing task: {}", threadName);
    CorrelationIdTracker.setCorrelationId(correlationId);
    job.run();
}
#method_after
@Override
public void run() {
    String threadName = Thread.currentThread().getName();
    log.debug("Executing task: {}", threadName);
    CorrelationIdTracker.setCorrelationId(correlationId);
    job.run();
}
#end_block

#method_before
@Before
public void setUpBase() {
    MockitoAnnotations.initMocks(this);
    injectorRule.bind(TransactionManager.class, transactionManager);
    ThreadPoolUtil.setExecutorService(Executors.newFixedThreadPool(5));
}
#method_after
@Before
public void setUpBase() {
    MockitoAnnotations.initMocks(this);
    injectorRule.bind(TransactionManager.class, transactionManager);
    ThreadPoolUtil.setExecutorService(Executors.newFixedThreadPool(1));
}
#end_block

#method_before
public Future<VdcReturnValueBase> executeAsyncCommand(final CommandBase<?> command, final CommandContext cmdContext) {
    Future<VdcReturnValueBase> retVal;
    try {
        retVal = executor.submit(() -> executeCommand(command, cmdContext));
    } catch (RejectedExecutionException ex) {
        command.setCommandStatus(CommandStatus.FAILED);
        log.error("Failed to submit command to executor service, command '{}' status has been set to FAILED", command.getCommandId());
        retVal = new RejectedExecutionFuture();
    }
    return retVal;
}
#method_after
public Future<ActionReturnValue> executeAsyncCommand(final CommandBase<?> command, final CommandContext cmdContext) {
    Future<ActionReturnValue> retVal;
    try {
        retVal = executor.submit(() -> executeCommand(command, cmdContext));
    } catch (RejectedExecutionException ex) {
        command.setCommandStatus(CommandStatus.FAILED);
        log.error("Failed to submit command to executor service, command '{}' status has been set to FAILED", command.getCommandId());
        retVal = new RejectedExecutionFuture();
    }
    return retVal;
}
#end_block

#method_before
private VdcReturnValueBase executeCommand(final CommandBase<?> command, final CommandContext cmdContext) {
    VdcReturnValueBase result = BackendUtils.getBackendCommandObjectsHandler(log).runAction(command, cmdContext != null ? cmdContext.getExecutionContext() : null);
    updateCommandResult(command.getCommandId(), result);
    return result;
}
#method_after
private ActionReturnValue executeCommand(final CommandBase<?> command, final CommandContext cmdContext) {
    ActionReturnValue result = BackendUtils.getBackendCommandObjectsHandler(log).runAction(command, cmdContext != null ? cmdContext.getExecutionContext() : null);
    updateCommandResult(command.getCommandId(), result);
    return result;
}
#end_block

#method_before
private void updateCommandResult(final Guid commandId, final VdcReturnValueBase result) {
    CommandEntity cmdEntity = commandsRepository.getCommandEntity(commandId);
    cmdEntity.setReturnValue(result);
    if (!result.isValid()) {
        cmdEntity.setCommandStatus(CommandStatus.FAILED);
    }
    commandsRepository.persistCommand(cmdEntity);
}
#method_after
private void updateCommandResult(final Guid commandId, final ActionReturnValue result) {
    CommandEntity cmdEntity = commandsRepository.getCommandEntity(commandId);
    cmdEntity.setReturnValue(result);
    if (!result.isValid()) {
        cmdEntity.setCommandStatus(CommandStatus.FAILED);
    }
    commandsRepository.persistCommand(cmdEntity);
}
#end_block

#method_before
@Override
public VdcReturnValueBase get() throws InterruptedException, ExecutionException {
    return retValue;
}
#method_after
@Override
public ActionReturnValue get() throws InterruptedException, ExecutionException {
    return retValue;
}
#end_block

#method_before
@Override
public VdcReturnValueBase get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
    return retValue;
}
#method_after
@Override
public ActionReturnValue get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
    return retValue;
}
#end_block

#method_before
public boolean isWebSocketProxyDefined() {
    String wsConfig = (String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.WebSocketProxy);
    // $NON-NLS-1$ //$NON-NLS-2$
    return wsConfig != null && !"".equals(wsConfig) && !"Off".equalsIgnoreCase(wsConfig);
}
#method_after
public boolean isWebSocketProxyDefined() {
    String wsConfig = (String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigValues.WebSocketProxy);
    // $NON-NLS-1$ //$NON-NLS-2$
    return wsConfig != null && !"".equals(wsConfig) && !"Off".equalsIgnoreCase(wsConfig);
}
#end_block

#method_before
@Override
protected boolean validate() {
    VDS host = getVds();
    final ValidationResult hostValidatorResult = new HostValidator(host, isInternalExecution()).validate();
    if (!hostValidatorResult.isValid()) {
        return validate(hostValidatorResult);
    }
    completeMissingDataInParameters();
    boolean requestValid = validateEntitiesFromRequest(getParameters().getNetworkAttachments()) && validateEntitiesFromRequest(getParameters().getCreateOrUpdateBonds());
    if (!requestValid) {
        return requestValid;
    }
    fillInUnsetBondingOptions();
    IdQueryParameters idParameters = new IdQueryParameters(getVdsId());
    VdcQueryReturnValue existingBondsResponse = runInternalQuery(VdcQueryType.GetHostBondsByHostId, idParameters);
    if (!existingBondsResponse.getSucceeded()) {
        return false;
    }
    List<VdsNetworkInterface> existingBonds = existingBondsResponse.getReturnValue();
    // TODO MMUCHA: Dear code reviewer! but this will remove added attachments. Please advise.
    removeUnchangedAttachments();
    removeUnchangedBonds(existingBonds);
    ValidationResult hostSetupNetworkValidatorResult = validateWithHostSetupNetworksValidator(host);
    if (!hostSetupNetworkValidatorResult.isValid()) {
        return validate(hostSetupNetworkValidatorResult);
    }
    return validate(checkForOutOfSyncNetworks());
}
#method_after
@Override
protected boolean validate() {
    VDS host = getVds();
    final ValidationResult hostValidatorResult = new HostValidator(host, isInternalExecution()).validate();
    if (!hostValidatorResult.isValid()) {
        return validate(hostValidatorResult);
    }
    completeMissingDataInParameters();
    boolean requestValid = validateEntitiesFromRequest(getParameters().getNetworkAttachments()) && validateEntitiesFromRequest(getParameters().getCreateOrUpdateBonds());
    if (!requestValid) {
        return requestValid;
    }
    fillInUnsetBondingOptions();
    IdQueryParameters idParameters = new IdQueryParameters(getVdsId());
    QueryReturnValue existingBondsResponse = runInternalQuery(QueryType.GetHostBondsByHostId, idParameters);
    if (!existingBondsResponse.getSucceeded()) {
        return false;
    }
    List<VdsNetworkInterface> existingBonds = existingBondsResponse.getReturnValue();
    removeUnchangedAttachments();
    removeUnchangedBonds(existingBonds);
    ValidationResult hostSetupNetworkValidatorResult = validateWithHostSetupNetworksValidator(host);
    if (!hostSetupNetworkValidatorResult.isValid()) {
        return validate(hostSetupNetworkValidatorResult);
    }
    return validate(checkForOutOfSyncNetworks());
}
#end_block

#method_before
private List<HostNetwork> calculateNetworksToConfigure() {
    List<HostNetwork> networksToConfigure = new ArrayList<>(getParameters().getNetworkAttachments().size());
    BusinessEntityMap<VdsNetworkInterface> nics = getExistingNicsBusinessEntityMap();
    for (NetworkAttachment attachment : getParameters().getNetworkAttachments()) {
        Network network = existingNetworkRelatedToAttachment(attachment);
        NetworkCluster networkCluster = network.getCluster();
        HostNetwork networkToConfigure = new HostNetwork(network, attachment);
        networkToConfigure.setBonding(isBonding(attachment, nics));
        if (defaultRouteSupported() && new ShouldSetDefaultRouteFlagAndDnsData().test(networkCluster.isDefaultRoute(), attachment)) {
            DnsResolverConfiguration dnsResolverConfiguration = getDnsConfigurationFromNetworkOrItsAttachment(attachment, network);
            if (dnsResolverConfiguration != null) {
                networkToConfigure.setNameServers(dnsResolverConfiguration.getNameServers());
            }
            // TODO: YZ - should default route be set separately for IPv4 and IPv6
            networkToConfigure.setDefaultRoute(true);
        }
        if (NetworkUtils.qosConfiguredOnInterface(attachment, network)) {
            networkToConfigure.setQosConfiguredOnInterface(true);
            HostNetworkQos hostNetworkQos = effectiveHostNetworkQos.getQos(attachment, network);
            networkToConfigure.setQos(hostNetworkQos);
        }
        networksToConfigure.add(networkToConfigure);
    }
    return networksToConfigure;
}
#method_after
private List<HostNetwork> calculateNetworksToConfigure() {
    List<HostNetwork> networksToConfigure = new ArrayList<>(getParameters().getNetworkAttachments().size());
    BusinessEntityMap<VdsNetworkInterface> nics = getExistingNicsBusinessEntityMap();
    for (NetworkAttachment attachment : getParameters().getNetworkAttachments()) {
        Network network = existingNetworkRelatedToAttachment(attachment);
        NetworkCluster networkCluster = network.getCluster();
        HostNetwork networkToConfigure = new HostNetwork(network, attachment);
        networkToConfigure.setBonding(isBonding(attachment, nics));
        boolean isDefaultRoute = defaultRouteSupported() && networkCluster.isDefaultRoute();
        if (isDefaultRoute) {
            DnsResolverConfiguration dnsResolverConfiguration = getDnsConfigurationFromNetworkOrItsAttachment(attachment, network);
            if (dnsResolverConfiguration != null) {
                networkToConfigure.setNameServers(dnsResolverConfiguration.getNameServers());
            }
        }
        // TODO: YZ - should default route be set separately for IPv4 and IPv6
        networkToConfigure.setDefaultRoute(isDefaultRoute);
        if (NetworkUtils.qosConfiguredOnInterface(attachment, network)) {
            networkToConfigure.setQosConfiguredOnInterface(true);
            HostNetworkQos hostNetworkQos = effectiveHostNetworkQos.getQos(attachment, network);
            networkToConfigure.setQos(hostNetworkQos);
        }
        networksToConfigure.add(networkToConfigure);
    }
    return networksToConfigure;
}
#end_block

#method_before
private Map<Guid, List<Pair<VdsNetworkInterface, Network>>> getUpdatedNetworksByHost(Collection<NetworkCluster> updates) {
    Map<Guid, List<Pair<VdsNetworkInterface, Network>>> result = new HashMap<>();
    Map<Guid, List<NetworkCluster>> updatesByClusterId = updates.stream().collect(Collectors.groupingBy(NetworkCluster::getClusterId));
    for (Guid clusterId : updatesByClusterId.keySet()) {
        Map<String, Network> clusterNetworksByName = networkDao.getAllForCluster(clusterId).stream().collect(Collectors.toMap(Network::getName, Function.identity()));
        List<VdsNetworkInterface> interfacesOfCluster = interfaceDao.getAllInterfacesByClusterId(clusterId);
        for (VdsNetworkInterface iface : interfacesOfCluster) {
            if (clusterNetworksByName.containsKey(iface.getNetworkName())) {
                Guid vdsId = iface.getVdsId();
                if (!result.containsKey(vdsId)) {
                    result.put(vdsId, new ArrayList<>());
                }
                Network network = clusterNetworksByName.get(iface.getNetworkName());
                result.get(vdsId).add(new Pair<>(iface, network));
            }
        }
    }
    return result;
}
#method_after
private Map<Guid, List<Network>> getUpdatedNetworksByHost(Collection<NetworkCluster> updates) {
    Map<Guid, List<Network>> result = new HashMap<>();
    Map<Guid, List<NetworkCluster>> updatesByClusterId = updates.stream().collect(Collectors.groupingBy(NetworkCluster::getClusterId));
    Set<Guid> idsOfUpdatedNetworks = updates.stream().map(NetworkCluster::getNetworkId).collect(Collectors.toSet());
    for (Guid clusterId : updatesByClusterId.keySet()) {
        Map<String, Network> clusterNetworksByName = networkDao.getAllForCluster(clusterId).stream().filter(network -> idsOfUpdatedNetworks.contains(network.getId())).collect(Collectors.toMap(Network::getName, Function.identity()));
        List<VdsNetworkInterface> interfacesOfCluster = interfaceDao.getAllInterfacesByClusterId(clusterId);
        for (VdsNetworkInterface iface : interfacesOfCluster) {
            if (!clusterNetworksByName.containsKey(iface.getNetworkName())) {
                continue;
            }
            Network network = clusterNetworksByName.get(iface.getNetworkName());
            Guid vdsId = iface.getVdsId();
            VdsNetworkInterface.NetworkImplementationDetails networkImplementationDetails = networkImplementationDetailsUtils.calculateNetworkImplementationDetails(iface, network);
            boolean networkShouldBeSynced = networkImplementationDetails != null && !networkImplementationDetails.isInSync();
            if (networkShouldBeSynced) {
                if (!result.containsKey(vdsId)) {
                    result.put(vdsId, new ArrayList<>());
                }
                result.get(vdsId).add(network);
            }
        }
    }
    return result;
}
#end_block

#method_before
private List<PersistentHostSetupNetworksParameters> createSetupNetworksParameters(Map<Guid, List<Network>> attachNetworksByHost, Map<Guid, Map<String, VdsNetworkInterface>> labelsToNicsByHost, Map<Guid, List<Network>> detachNetworksByHost, Map<Guid, List<Pair<VdsNetworkInterface, Network>>> updates) {
    final List<PersistentHostSetupNetworksParameters> parameters = new ArrayList<>(attachNetworksByHost.size());
    final ManageLabeledNetworksParametersBuilder builder = manageLabeledNetworksParametersBuilderFactory.create(commandContext, interfaceDao, vdsStaticDao, networkClusterDao, networkAttachmentDao);
    Set<Guid> hostIds = Stream.of(attachNetworksByHost, detachNetworksByHost, updates).flatMap(e -> e.keySet().stream()).collect(Collectors.toSet());
    for (Guid hostId : hostIds) {
        final Map<String, VdsNetworkInterface> nicsByLabel = labelsToNicsByHost.get(hostId);
        parameters.add(builder.buildParameters(hostId, nullToEmptyList(attachNetworksByHost.get(hostId)), nullToEmptyList(detachNetworksByHost.get(hostId)), nicsByLabel == null ? Collections.emptyMap() : nicsByLabel, nullToEmptyList(updates.get(hostId))));
    }
    return parameters;
}
#method_after
private List<PersistentHostSetupNetworksParameters> createSetupNetworksParameters(Map<Guid, List<Network>> attachNetworksByHost, Map<Guid, Map<String, VdsNetworkInterface>> labelsToNicsByHost, Map<Guid, List<Network>> detachNetworksByHost, Map<Guid, List<Network>> updates) {
    final List<PersistentHostSetupNetworksParameters> parameters = new ArrayList<>(attachNetworksByHost.size());
    final ManageNetworksParametersBuilder builder = manageNetworksParametersBuilderFactory.create(commandContext, interfaceDao, vdsStaticDao, networkClusterDao, networkAttachmentDao);
    Set<Guid> hostIds = Stream.of(attachNetworksByHost, detachNetworksByHost, updates).flatMap(e -> e.keySet().stream()).collect(Collectors.toSet());
    for (Guid hostId : hostIds) {
        final Map<String, VdsNetworkInterface> nicsByLabel = labelsToNicsByHost.get(hostId);
        parameters.add(builder.buildParameters(hostId, nullToEmptyList(attachNetworksByHost.get(hostId)), nullToEmptyList(detachNetworksByHost.get(hostId)), nicsByLabel == null ? Collections.emptyMap() : nicsByLabel, nullToEmptyList(updates.get(hostId))));
    }
    return parameters;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    sampleDnsResolverConfiguration = new DnsResolverConfiguration();
    sampleDnsResolverConfiguration.setNameServers(Arrays.asList(new NameServer("192.168.1.1"), new NameServer("2001:0db8:85a3:0000:0000:8a2e:0370:7334")));
    sampleDnsResolverConfiguration2 = new DnsResolverConfiguration();
    sampleDnsResolverConfiguration2.setNameServers(Arrays.asList(new NameServer("192.168.1.2"), new NameServer("2002:0db8:85a3:0000:0000:8a2e:0370:7334")));
    sampleDnsResolverConfigurationWithReversedNameServers = reverseNameServersOrder(sampleDnsResolverConfiguration);
    ifaceQos = new HostNetworkQos();
    networkQos = new HostNetworkQos();
    iface = new VdsNetworkInterface();
    // needed because network is vm network by default
    iface.setBridged(true);
    iface.setQos(ifaceQos);
    iface.setReportedSwitchType(SwitchType.LEGACY);
    iface.setIpv4DefaultRoute(true);
    network = new Network();
    network.setDnsResolverConfiguration(sampleDnsResolverConfiguration);
    testedNetworkAttachment = new NetworkAttachment();
    testedNetworkAttachment.setIpConfiguration(new IpConfiguration());
    cluster = new Cluster();
    cluster.setCompatibilityVersion(Version.v4_1);
    cluster.setRequiredSwitchTypeForCluster(SwitchType.LEGACY);
}
#method_after
@Before
public void setUp() throws Exception {
    sampleDnsResolverConfiguration = new DnsResolverConfiguration();
    sampleDnsResolverConfiguration.setNameServers(Arrays.asList(new NameServer("192.168.1.1"), new NameServer("2001:0db8:85a3:0000:0000:8a2e:0370:7334")));
    sampleDnsResolverConfiguration2 = new DnsResolverConfiguration();
    sampleDnsResolverConfiguration2.setNameServers(Arrays.asList(new NameServer("192.168.1.2"), new NameServer("2002:0db8:85a3:0000:0000:8a2e:0370:7334")));
    sampleDnsResolverConfigurationWithReversedNameServers = reverseNameServersOrder(sampleDnsResolverConfiguration);
    ifaceQos = new HostNetworkQos();
    networkQos = new HostNetworkQos();
    iface = new VdsNetworkInterface();
    // needed because network is vm network by default
    iface.setBridged(true);
    iface.setQos(ifaceQos);
    iface.setReportedSwitchType(SwitchType.LEGACY);
    iface.setIpv4DefaultRoute(false);
    network = new Network();
    network.setDnsResolverConfiguration(sampleDnsResolverConfiguration);
    testedNetworkAttachment = new NetworkAttachment();
    testedNetworkAttachment.setIpConfiguration(new IpConfiguration());
    cluster = new Cluster();
    cluster.setCompatibilityVersion(Version.v4_1);
    cluster.setRequiredSwitchTypeForCluster(SwitchType.LEGACY);
}
#end_block

#method_before
@Test
public void testReportConfigurationsOnHost() throws Exception {
    NetworkInSyncWithVdsNetworkInterface testedInstanceWithSameNonQosValues = createTestedInstanceWithSameNonQosValues();
    ifaceQos.setOutAverageLinkshare(1);
    ifaceQos.setOutAverageUpperlimit(1);
    ifaceQos.setOutAverageRealtime(1);
    ReportedConfigurations reportedConfigurations = testedInstanceWithSameNonQosValues.reportConfigurationsOnHost();
    assertThat(reportedConfigurations.isNetworkInSync(), is(false));
    List<ReportedConfiguration> reportedConfigurationList = reportedConfigurations.getReportedConfigurationList();
    List<ReportedConfiguration> expectedReportedConfigurations = addReportedConfigurations(combineReportedConfigurations(createBasicReportedConfigurations(), reportQos(false), unappliedDnsConfigurations(sampleDnsResolverConfiguration)));
    assertThat(reportedConfigurationList.containsAll(expectedReportedConfigurations), is(true));
    assertThat(reportedConfigurationList.size(), is(expectedReportedConfigurations.size()));
}
#method_after
@Test
public void testReportConfigurationsOnHost() throws Exception {
    NetworkInSyncWithVdsNetworkInterface testedInstanceWithSameNonQosValues = createTestedInstanceWithSameNonQosValues();
    ifaceQos.setOutAverageLinkshare(1);
    ifaceQos.setOutAverageUpperlimit(1);
    ifaceQos.setOutAverageRealtime(1);
    ReportedConfigurations reportedConfigurations = testedInstanceWithSameNonQosValues.reportConfigurationsOnHost();
    assertThat(reportedConfigurations.isNetworkInSync(), is(false));
    List<ReportedConfiguration> reportedConfigurationList = reportedConfigurations.getReportedConfigurationList();
    List<ReportedConfiguration> expectedReportedConfigurations = addReportedConfigurations(combineReportedConfigurations(createBasicReportedConfigurations(), reportQos(false)), defaultRouteReportedConfiguration(false));
    assertThat(reportedConfigurationList.containsAll(expectedReportedConfigurations), is(true));
    assertThat(reportedConfigurationList.size(), is(expectedReportedConfigurations.size()));
}
#end_block

#method_before
@Test
public void testReportConfigurationsOnHostWhenDefaultRouteDiffers() {
    iface.setIpv4DefaultRoute(false);
    // cannot use initIpv4ConfigurationBootProtocol because of 'randomized tests' technique.
    iface.setIpv4BootProtocol(Ipv4BootProtocol.DHCP);
    IPv4Address address = new IPv4Address();
    address.setBootProtocol(Ipv4BootProtocol.DHCP);
    testedNetworkAttachment.getIpConfiguration().setIPv4Addresses(Collections.singletonList(address));
    // network has default route role
    NetworkInSyncWithVdsNetworkInterface testedInstance = createTestedInstanceWithSameNonQosValues(true);
    ReportedConfigurations reportedConfigurations = testedInstance.reportConfigurationsOnHost();
    assertThat(reportedConfigurations.isNetworkInSync(), is(false));
    List<ReportedConfiguration> reportedConfigurationList = reportedConfigurations.getReportedConfigurationList();
    List<ReportedConfiguration> expectedReportedConfigurations = addReportedConfigurations(combineReportedConfigurations(createBasicReportedConfigurations(), reportQos(true)), new ReportedConfiguration(ReportedConfigurationType.IPV4_BOOT_PROTOCOL, iface.getIpv4BootProtocol().name(), /*ipv4Address*/
    address.getBootProtocol().name(), true), new ReportedConfiguration(ReportedConfigurationType.DNS_CONFIGURATION, addressesAsString(sampleDnsResolverConfiguration.getNameServers()), "192.168.1.1,2001:0db8:85a3:0000:0000:8a2e:0370:7334", true), new ReportedConfiguration(ReportedConfigurationType.DEFAULT_ROUTE, false, true, false));
    assertThat(reportedConfigurationList.containsAll(expectedReportedConfigurations), is(true));
    assertThat(reportedConfigurationList.size(), is(expectedReportedConfigurations.size()));
}
#method_after
@Test
public void testReportConfigurationsOnHostWhenDefaultRouteDiffers() {
    // cannot use initIpv4ConfigurationBootProtocol because of 'randomized tests' technique.
    iface.setIpv4BootProtocol(Ipv4BootProtocol.DHCP);
    IPv4Address address = new IPv4Address();
    address.setBootProtocol(Ipv4BootProtocol.DHCP);
    testedNetworkAttachment.getIpConfiguration().setIPv4Addresses(Collections.singletonList(address));
    // network has default route role
    NetworkInSyncWithVdsNetworkInterface testedInstance = createTestedInstanceWithSameNonQosValues(true);
    ReportedConfigurations reportedConfigurations = testedInstance.reportConfigurationsOnHost();
    assertThat(reportedConfigurations.isNetworkInSync(), is(false));
    List<ReportedConfiguration> reportedConfigurationList = reportedConfigurations.getReportedConfigurationList();
    List<ReportedConfiguration> expectedReportedConfigurations = addReportedConfigurations(combineReportedConfigurations(createBasicReportedConfigurations(), reportQos(true)), new ReportedConfiguration(ReportedConfigurationType.IPV4_BOOT_PROTOCOL, iface.getIpv4BootProtocol().name(), /*ipv4Address*/
    address.getBootProtocol().name(), true), new ReportedConfiguration(ReportedConfigurationType.DNS_CONFIGURATION, addressesAsString(sampleDnsResolverConfiguration.getNameServers()), "192.168.1.1,2001:0db8:85a3:0000:0000:8a2e:0370:7334", true), new ReportedConfiguration(ReportedConfigurationType.DEFAULT_ROUTE, false, true, false));
    assertThat(reportedConfigurationList.containsAll(expectedReportedConfigurations), is(true));
    assertThat(reportedConfigurationList.size(), is(expectedReportedConfigurations.size()));
}
#end_block

#method_before
@Test
public void testReportConfigurationsOnHostWhenDnsConfigurationResolverOutOfSync() {
    // cannot use initIpv4ConfigurationBootProtocol because of 'randomized tests' technique.
    iface.setIpv4BootProtocol(Ipv4BootProtocol.DHCP);
    IPv4Address address = new IPv4Address();
    address.setBootProtocol(Ipv4BootProtocol.DHCP);
    testedNetworkAttachment.getIpConfiguration().setIPv4Addresses(Collections.singletonList(address));
    network.setDnsResolverConfiguration(sampleDnsResolverConfiguration2);
    ReportedConfigurations reportedConfigurations = createTestedInstanceWithSameNonQosValues(true).reportConfigurationsOnHost();
    assertThat(reportedConfigurations.isNetworkInSync(), is(false));
    List<ReportedConfiguration> reportedConfigurationList = reportedConfigurations.getReportedConfigurationList();
    List<ReportedConfiguration> expectedReportedConfigurations = addReportedConfigurations(combineReportedConfigurations(createBasicReportedConfigurations(), reportQos(true)), new ReportedConfiguration(ReportedConfigurationType.IPV4_BOOT_PROTOCOL, iface.getIpv4BootProtocol().name(), /*ipv4Address*/
    address.getBootProtocol().name(), true), new ReportedConfiguration(ReportedConfigurationType.DNS_CONFIGURATION, addressesAsString(sampleDnsResolverConfiguration.getNameServers()), addressesAsString(network.getDnsResolverConfiguration().getNameServers()), false), new ReportedConfiguration(ReportedConfigurationType.DEFAULT_ROUTE, true, true, true));
    assertThat(reportedConfigurationList.containsAll(expectedReportedConfigurations), is(true));
    assertThat(reportedConfigurationList.size(), is(expectedReportedConfigurations.size()));
}
#method_after
@Test
public void testReportConfigurationsOnHostWhenDnsConfigurationResolverOutOfSync() {
    iface.setIpv4DefaultRoute(true);
    // cannot use initIpv4ConfigurationBootProtocol because of 'randomized tests' technique.
    iface.setIpv4BootProtocol(Ipv4BootProtocol.DHCP);
    IPv4Address address = new IPv4Address();
    address.setBootProtocol(Ipv4BootProtocol.DHCP);
    testedNetworkAttachment.getIpConfiguration().setIPv4Addresses(Collections.singletonList(address));
    network.setDnsResolverConfiguration(sampleDnsResolverConfiguration2);
    ReportedConfigurations reportedConfigurations = createTestedInstanceWithSameNonQosValues(true).reportConfigurationsOnHost();
    assertThat(reportedConfigurations.isNetworkInSync(), is(false));
    List<ReportedConfiguration> reportedConfigurationList = reportedConfigurations.getReportedConfigurationList();
    List<ReportedConfiguration> expectedReportedConfigurations = addReportedConfigurations(combineReportedConfigurations(createBasicReportedConfigurations(), reportQos(true)), new ReportedConfiguration(ReportedConfigurationType.IPV4_BOOT_PROTOCOL, iface.getIpv4BootProtocol().name(), /*ipv4Address*/
    address.getBootProtocol().name(), true), new ReportedConfiguration(ReportedConfigurationType.DNS_CONFIGURATION, addressesAsString(sampleDnsResolverConfiguration.getNameServers()), addressesAsString(network.getDnsResolverConfiguration().getNameServers()), false), new ReportedConfiguration(ReportedConfigurationType.DEFAULT_ROUTE, true, true, true));
    assertThat(reportedConfigurationList.containsAll(expectedReportedConfigurations), is(true));
    assertThat(reportedConfigurationList.size(), is(expectedReportedConfigurations.size()));
}
#end_block

#method_before
@Test
public void testReportConfigurationsOnHostWhenIfaceQosIsNull() throws Exception {
    ifaceQos = null;
    iface.setQos(null);
    NetworkInSyncWithVdsNetworkInterface testedInstanceWithSameNonQosValues = createTestedInstanceWithSameNonQosValues();
    networkQos.setOutAverageLinkshare(1);
    networkQos.setOutAverageUpperlimit(1);
    networkQos.setOutAverageRealtime(1);
    ReportedConfigurations reportedConfigurations = testedInstanceWithSameNonQosValues.reportConfigurationsOnHost();
    assertThat(createTestedInstanceWithSameNonQosValues().isNetworkInSync(), is(false));
    assertThat(reportedConfigurations.isNetworkInSync(), is(false));
    List<ReportedConfiguration> reportedConfigurationList = reportedConfigurations.getReportedConfigurationList();
    List<ReportedConfiguration> expectedReportedConfigurations = addReportedConfigurations(combineReportedConfigurations(createBasicReportedConfigurations(), unappliedDnsConfigurations(sampleDnsResolverConfiguration)), new ReportedConfiguration(ReportedConfigurationType.OUT_AVERAGE_LINK_SHARE, null, networkQos.getOutAverageLinkshare(), false), new ReportedConfiguration(ReportedConfigurationType.OUT_AVERAGE_REAL_TIME, null, networkQos.getOutAverageRealtime(), false), new ReportedConfiguration(ReportedConfigurationType.OUT_AVERAGE_UPPER_LIMIT, null, networkQos.getOutAverageUpperlimit(), false));
    assertThat(reportedConfigurationList.containsAll(expectedReportedConfigurations), is(true));
    assertThat(reportedConfigurationList.size(), is(expectedReportedConfigurations.size()));
}
#method_after
@Test
public void testReportConfigurationsOnHostWhenIfaceQosIsNull() throws Exception {
    ifaceQos = null;
    iface.setQos(null);
    NetworkInSyncWithVdsNetworkInterface testedInstanceWithSameNonQosValues = createTestedInstanceWithSameNonQosValues();
    networkQos.setOutAverageLinkshare(1);
    networkQos.setOutAverageUpperlimit(1);
    networkQos.setOutAverageRealtime(1);
    ReportedConfigurations reportedConfigurations = testedInstanceWithSameNonQosValues.reportConfigurationsOnHost();
    assertThat(createTestedInstanceWithSameNonQosValues().isNetworkInSync(), is(false));
    assertThat(reportedConfigurations.isNetworkInSync(), is(false));
    List<ReportedConfiguration> reportedConfigurationList = reportedConfigurations.getReportedConfigurationList();
    List<ReportedConfiguration> expectedReportedConfigurations = addReportedConfigurations(createBasicReportedConfigurations(), defaultRouteReportedConfiguration(false), new ReportedConfiguration(ReportedConfigurationType.OUT_AVERAGE_LINK_SHARE, null, networkQos.getOutAverageLinkshare(), false), new ReportedConfiguration(ReportedConfigurationType.OUT_AVERAGE_REAL_TIME, null, networkQos.getOutAverageRealtime(), false), new ReportedConfiguration(ReportedConfigurationType.OUT_AVERAGE_UPPER_LIMIT, null, networkQos.getOutAverageUpperlimit(), false));
    assertThat(reportedConfigurationList.containsAll(expectedReportedConfigurations), is(true));
    assertThat(reportedConfigurationList.size(), is(expectedReportedConfigurations.size()));
}
#end_block

#method_before
@Test
public void testReportConfigurationsOnHostWhenIpv4BootProtocolNotStatic() {
    initIpv4ConfigurationBootProtocolAddress(Ipv4BootProtocol.NONE, false);
    initIpv4ConfigurationBootProtocolNetmask(Ipv4BootProtocol.NONE, false);
    initIpv4ConfigurationBootProtocolGateway(Ipv4BootProtocol.NONE, false);
    NetworkInSyncWithVdsNetworkInterface testedInstanceWithSameNonQosValues = createTestedInstanceWithSameNonQosValues();
    List<ReportedConfiguration> reportedConfigurationList = testedInstanceWithSameNonQosValues.reportConfigurationsOnHost().getReportedConfigurationList();
    IPv4Address primaryAddress = this.testedNetworkAttachment.getIpConfiguration().getIpv4PrimaryAddress();
    List<ReportedConfiguration> expectedReportedConfigurations = addReportedConfigurations(combineReportedConfigurations(createBasicAndQosReportedConfigurations(), unappliedDnsConfigurations(sampleDnsResolverConfiguration)), new ReportedConfiguration(ReportedConfigurationType.IPV4_BOOT_PROTOCOL, iface.getIpv4BootProtocol().name(), primaryAddress.getBootProtocol().name(), true));
    assertThat(reportedConfigurationList.containsAll(expectedReportedConfigurations), is(true));
    assertThat(reportedConfigurationList.size(), is(expectedReportedConfigurations.size()));
}
#method_after
@Test
public void testReportConfigurationsOnHostWhenIpv4BootProtocolNotStatic() {
    initIpv4ConfigurationBootProtocolAddress(Ipv4BootProtocol.NONE, false);
    initIpv4ConfigurationBootProtocolNetmask(Ipv4BootProtocol.NONE, false);
    initIpv4ConfigurationBootProtocolGateway(Ipv4BootProtocol.NONE, false);
    NetworkInSyncWithVdsNetworkInterface testedInstanceWithSameNonQosValues = createTestedInstanceWithSameNonQosValues();
    List<ReportedConfiguration> reportedConfigurationList = testedInstanceWithSameNonQosValues.reportConfigurationsOnHost().getReportedConfigurationList();
    IPv4Address primaryAddress = this.testedNetworkAttachment.getIpConfiguration().getIpv4PrimaryAddress();
    List<ReportedConfiguration> expectedReportedConfigurations = addReportedConfigurations(createBasicAndQosReportedConfigurations(), defaultRouteReportedConfiguration(false), new ReportedConfiguration(ReportedConfigurationType.IPV4_BOOT_PROTOCOL, iface.getIpv4BootProtocol().name(), primaryAddress.getBootProtocol().name(), true));
    assertThat(reportedConfigurationList.containsAll(expectedReportedConfigurations), is(true));
    assertThat(reportedConfigurationList.size(), is(expectedReportedConfigurations.size()));
}
#end_block

#method_before
@Test
public void testReportConfigurationsOnHostWhenIpv4BootProtocolStatic() {
    boolean syncAddress = RandomUtils.instance().nextBoolean();
    boolean syncNetmask = RandomUtils.instance().nextBoolean();
    boolean syncGateway = RandomUtils.instance().nextBoolean();
    initIpv4ConfigurationBootProtocolAddress(Ipv4BootProtocol.STATIC_IP, syncAddress);
    initIpv4ConfigurationBootProtocolNetmask(Ipv4BootProtocol.STATIC_IP, syncNetmask);
    initIpv4ConfigurationBootProtocolGateway(Ipv4BootProtocol.STATIC_IP, syncGateway);
    NetworkInSyncWithVdsNetworkInterface testedInstanceWithSameNonQosValues = createTestedInstanceWithSameNonQosValues();
    List<ReportedConfiguration> reportedConfigurationList = testedInstanceWithSameNonQosValues.reportConfigurationsOnHost().getReportedConfigurationList();
    IPv4Address primaryAddress = this.testedNetworkAttachment.getIpConfiguration().getIpv4PrimaryAddress();
    List<ReportedConfiguration> expectedReportedConfigurations = addReportedConfigurations(combineReportedConfigurations(createBasicAndQosReportedConfigurations(), unappliedDnsConfigurations(sampleDnsResolverConfiguration)), new ReportedConfiguration(ReportedConfigurationType.IPV4_BOOT_PROTOCOL, iface.getIpv4BootProtocol().name(), primaryAddress.getBootProtocol().name(), true), new ReportedConfiguration(ReportedConfigurationType.IPV4_NETMASK, iface.getIpv4Subnet(), primaryAddress.getNetmask(), syncNetmask), new ReportedConfiguration(ReportedConfigurationType.IPV4_ADDRESS, iface.getIpv4Address(), primaryAddress.getAddress(), syncAddress), new ReportedConfiguration(ReportedConfigurationType.IPV4_GATEWAY, iface.getIpv4Gateway(), primaryAddress.getGateway(), syncGateway));
    assertThat(reportedConfigurationList.containsAll(expectedReportedConfigurations), is(true));
    assertThat(reportedConfigurationList.size(), is(expectedReportedConfigurations.size()));
}
#method_after
private void testReportConfigurationsOnHostWhenIpv4BootProtocolStatic(boolean syncAddress, boolean syncNetmask, boolean syncGateway) {
    initIpv4ConfigurationBootProtocolAddress(Ipv4BootProtocol.STATIC_IP, syncAddress);
    initIpv4ConfigurationBootProtocolNetmask(Ipv4BootProtocol.STATIC_IP, syncNetmask);
    initIpv4ConfigurationBootProtocolGateway(Ipv4BootProtocol.STATIC_IP, syncGateway);
    NetworkInSyncWithVdsNetworkInterface testedInstanceWithSameNonQosValues = createTestedInstanceWithSameNonQosValues();
    List<ReportedConfiguration> reportedConfigurationList = testedInstanceWithSameNonQosValues.reportConfigurationsOnHost().getReportedConfigurationList();
    IPv4Address primaryAddress = this.testedNetworkAttachment.getIpConfiguration().getIpv4PrimaryAddress();
    List<ReportedConfiguration> expectedReportedConfigurations = addReportedConfigurations(createBasicAndQosReportedConfigurations(), defaultRouteReportedConfiguration(false), new ReportedConfiguration(ReportedConfigurationType.IPV4_BOOT_PROTOCOL, iface.getIpv4BootProtocol().name(), primaryAddress.getBootProtocol().name(), true), new ReportedConfiguration(ReportedConfigurationType.IPV4_NETMASK, iface.getIpv4Subnet(), primaryAddress.getNetmask(), syncNetmask), new ReportedConfiguration(ReportedConfigurationType.IPV4_ADDRESS, iface.getIpv4Address(), primaryAddress.getAddress(), syncAddress), new ReportedConfiguration(ReportedConfigurationType.IPV4_GATEWAY, iface.getIpv4Gateway(), primaryAddress.getGateway(), syncGateway));
    for (ReportedConfiguration expectedReportedConfiguration : expectedReportedConfigurations) {
        assertThat("expected configuration not reported:" + expectedReportedConfiguration, reportedConfigurationList.contains(expectedReportedConfiguration), is(true));
    }
    assertThat(reportedConfigurationList.size(), is(expectedReportedConfigurations.size()));
}
#end_block

#method_before
private void testDnsResolverConfiguration(DnsResolverConfiguration vdsDnsResolver, DnsResolverConfiguration networkDnsResolver, DnsResolverConfiguration attachmentDnsResolver, boolean expectedInSync) {
    // cannot use initIpv4ConfigurationBootProtocol because of 'randomized tests' technique.
    iface.setIpv4BootProtocol(Ipv4BootProtocol.DHCP);
    IPv4Address address = new IPv4Address();
    address.setBootProtocol(Ipv4BootProtocol.DHCP);
    testedNetworkAttachment.getIpConfiguration().setIPv4Addresses(Collections.singletonList(address));
    network.setDnsResolverConfiguration(networkDnsResolver);
    testedNetworkAttachment.setDnsResolverConfiguration(attachmentDnsResolver);
    assertThat(createTestedInstance(true, vdsDnsResolver).isNetworkInSync(), is(expectedInSync));
}
#method_after
private void testDnsResolverConfiguration(DnsResolverConfiguration vdsDnsResolver, DnsResolverConfiguration networkDnsResolver, DnsResolverConfiguration attachmentDnsResolver, boolean expectedInSync) {
    iface.setIpv4DefaultRoute(true);
    // cannot use initIpv4ConfigurationBootProtocol because of 'randomized tests' technique.
    iface.setIpv4BootProtocol(Ipv4BootProtocol.DHCP);
    IPv4Address address = new IPv4Address();
    address.setBootProtocol(Ipv4BootProtocol.DHCP);
    testedNetworkAttachment.getIpConfiguration().setIPv4Addresses(Collections.singletonList(address));
    network.setDnsResolverConfiguration(networkDnsResolver);
    testedNetworkAttachment.setDnsResolverConfiguration(attachmentDnsResolver);
    assertThat(createTestedInstance(true, vdsDnsResolver).isNetworkInSync(), is(expectedInSync));
}
#end_block

#method_before
@Test
public void testDefaultRouteWhenOutOfSync() {
    iface.setIpv4DefaultRoute(false);
    network.setDnsResolverConfiguration(sampleDnsResolverConfiguration);
    assertThat(createTestedInstance(true, sampleDnsResolverConfiguration).isNetworkInSync(), is(false));
}
#method_after
@Test
public void testDefaultRouteWhenOutOfSync() {
    network.setDnsResolverConfiguration(sampleDnsResolverConfiguration);
    assertThat(createTestedInstance(true, sampleDnsResolverConfiguration).isNetworkInSync(), is(false));
}
#end_block

#method_before
@Test
public void testDnsResolverConfigurationInSyncWithHostWhenDhcpIsUsed() {
    network.setDnsResolverConfiguration(sampleDnsResolverConfiguration2);
    testedNetworkAttachment.setDnsResolverConfiguration(null);
    iface.setIpv4BootProtocol(Ipv4BootProtocol.DHCP);
    IPv4Address address = new IPv4Address();
    address.setBootProtocol(Ipv4BootProtocol.DHCP);
    testedNetworkAttachment.getIpConfiguration().setIPv4Addresses(Collections.singletonList(address));
    assertThat(createTestedInstance(true, sampleDnsResolverConfiguration).isNetworkInSync(), is(false));
}
#method_after
@Test
public void testDnsResolverConfigurationInSyncWithHostWhenDhcpIsUsed() {
    iface.setIpv4DefaultRoute(false);
    network.setDnsResolverConfiguration(sampleDnsResolverConfiguration2);
    testedNetworkAttachment.setDnsResolverConfiguration(null);
    iface.setIpv4BootProtocol(Ipv4BootProtocol.DHCP);
    IPv4Address address = new IPv4Address();
    address.setBootProtocol(Ipv4BootProtocol.DHCP);
    testedNetworkAttachment.getIpConfiguration().setIPv4Addresses(Collections.singletonList(address));
    assertThat(createTestedInstance(true, sampleDnsResolverConfiguration).isNetworkInSync(), is(false));
}
#end_block

#method_before
public ReportedConfigurations reportConfigurationsOnHost() {
    ReportedConfigurations result = new ReportedConfigurations();
    Integer networkMtu = network.getMtu() == 0 ? NetworkUtils.getDefaultMtu() : network.getMtu();
    result.add(ReportedConfigurationType.MTU, iface.getMtu(), networkMtu, isNetworkMtuInSync());
    result.add(ReportedConfigurationType.BRIDGED, iface.isBridged(), network.isVmNetwork());
    result.add(ReportedConfigurationType.VLAN, iface.getVlanId(), network.getVlanId());
    result.add(ReportedConfigurationType.SWITCH_TYPE, iface.getReportedSwitchType(), cluster.getRequiredSwitchTypeForCluster());
    addReportedIpv4Configuration(result);
    /**
     * TODO: YZ - uncomment the method call after v4.0 is branched out.
     *
     * Reporting out-of-sync IPv6 configuration is disabled temporary.
     * It's planned to be re-enabled after v4.0-beta is released.
     *
     * addReportedIpv6Configuration(result);
     */
    boolean reportHostQos = ifaceQos != null || hostNetworkQos != null;
    if (reportHostQos) {
        result.add(OUT_AVERAGE_LINK_SHARE, getOutAverageLinkshare(ifaceQos), getOutAverageLinkshare(hostNetworkQos));
        result.add(OUT_AVERAGE_UPPER_LIMIT, getOutAverageUpperlimit(ifaceQos), getOutAverageUpperlimit(hostNetworkQos));
        result.add(OUT_AVERAGE_REAL_TIME, getOutAverageRealtime(ifaceQos), getOutAverageRealtime(hostNetworkQos));
    }
    addDnsConfiguration(result);
    return result;
}
#method_after
public ReportedConfigurations reportConfigurationsOnHost() {
    ReportedConfigurations result = new ReportedConfigurations();
    Integer networkMtu = network.getMtu() == 0 ? NetworkUtils.getDefaultMtu() : network.getMtu();
    result.add(ReportedConfigurationType.MTU, iface.getMtu(), networkMtu, isNetworkMtuInSync());
    result.add(ReportedConfigurationType.BRIDGED, iface.isBridged(), network.isVmNetwork());
    result.add(ReportedConfigurationType.VLAN, iface.getVlanId(), network.getVlanId());
    result.add(ReportedConfigurationType.SWITCH_TYPE, iface.getReportedSwitchType(), cluster.getRequiredSwitchTypeForCluster());
    addReportedIpv4Configuration(result);
    /**
     * TODO: YZ - uncomment the method call after v4.0 is branched out.
     *
     * Reporting out-of-sync IPv6 configuration is disabled temporary.
     * It's planned to be re-enabled after v4.0-beta is released.
     *
     * addReportedIpv6Configuration(result);
     */
    boolean reportHostQos = ifaceQos != null || hostNetworkQos != null;
    if (reportHostQos) {
        result.add(OUT_AVERAGE_LINK_SHARE, getOutAverageLinkshare(ifaceQos), getOutAverageLinkshare(hostNetworkQos));
        result.add(OUT_AVERAGE_UPPER_LIMIT, getOutAverageUpperlimit(ifaceQos), getOutAverageUpperlimit(hostNetworkQos));
        result.add(OUT_AVERAGE_REAL_TIME, getOutAverageRealtime(ifaceQos), getOutAverageRealtime(hostNetworkQos));
    }
    addDnsConfiguration(result);
    result.add(DEFAULT_ROUTE, iface.isIpv4DefaultRoute(), isDefaultRouteNetwork);
    return result;
}
#end_block

#method_before
private void addDnsConfiguration(ReportedConfigurations result) {
    boolean dnsResolverConfigurationSupported = FeatureSupported.supportedInConfig(ConfigValues.DnsResolverConfigurationSupported, this.cluster.getCompatibilityVersion());
    // DNS configuration is reported only on network having default_route role
    if (!dnsResolverConfigurationSupported) {
        return;
    }
    List<NameServer> nameServersOfNetworkAttachment = getNameServers(networkAttachment.getDnsResolverConfiguration());
    List<NameServer> nameServersOfNetwork = getNameServers(network.getDnsResolverConfiguration());
    List<NameServer> nameServersOfHost = getNameServers(reportedDnsResolverConfiguration);
    boolean engineDefineDnsConfiguration = nameServersOfNetworkAttachment != null || nameServersOfNetwork != null;
    List<NameServer> expectedNameServers = nameServersOfNetworkAttachment != null ? nameServersOfNetworkAttachment : nameServersOfNetwork;
    result.add(DNS_CONFIGURATION, addressesAsString(nameServersOfHost), engineDefineDnsConfiguration && isDefaultRouteNetwork ? addressesAsString(expectedNameServers) : "", !(engineDefineDnsConfiguration && isDefaultRouteNetwork && !Objects.equals(nameServersOfHost, expectedNameServers)));
    /*
         * Network which '!isDefaultRouteNetwork' is always in sync.
         * Network which '!isDefaultRouteNetwork' is not applied, therefore we do not expect anything on nic.
         */
    boolean inSync = !isDefaultRouteNetwork || iface.isIpv4DefaultRoute();
    result.add(DEFAULT_ROUTE, iface.isIpv4DefaultRoute(), isDefaultRouteNetwork ? true : "", inSync);
}
#method_after
private void addDnsConfiguration(ReportedConfigurations result) {
    List<NameServer> nameServersOfHost = getNameServers(reportedDnsResolverConfiguration);
    if (isDefaultRouteNetwork) {
        List<NameServer> expectedNameServers = getExpectedNameServers();
        boolean engineDefineDnsConfiguration = expectedNameServers != null;
        if (engineDefineDnsConfiguration) {
            result.add(DNS_CONFIGURATION, addressesAsString(nameServersOfHost), addressesAsString(expectedNameServers), Objects.equals(nameServersOfHost, expectedNameServers));
        }
    }
}
#end_block

#method_before
private AddVmParameters buildAddVmParameters(String vmName) {
    VmStatic currVm = new VmStatic(getParameters().getVmStaticData());
    currVm.setName(vmName);
    currVm.setStateless(!getVmPool().isStateful());
    if (getParameters().getVmLargeIcon() != null) {
        final VmIconIdSizePair iconIds = IconUtils.ensureIconPairInDatabase(getParameters().getVmLargeIcon());
        currVm.setSmallIconId(iconIds.getSmall());
        currVm.setLargeIconId(iconIds.getLarge());
    }
    AddVmParameters parameters = new AddVmParameters(currVm);
    parameters.setPoolId(getVmPool().getVmPoolId());
    if (getVmPool().isAutoStorageSelect()) {
        parameters.setDiskInfoDestinationMap(autoSelectTargetDomainAndVolumeFormat());
    } else {
        parameters.setDiskInfoDestinationMap(diskInfoDestinationMap);
    }
    if (StringUtils.isEmpty(getParameters().getSessionId())) {
        parameters.setParametersCurrentUser(getCurrentUser());
    } else {
        parameters.setSessionId(getParameters().getSessionId());
    }
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    // check if device is enabled or we need to override it to true
    parameters.setSoundDeviceEnabled(Boolean.TRUE.equals(getParameters().isSoundDeviceEnabled()) || vmDeviceUtils.shouldOverrideSoundDevice(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion(), getParameters().isSoundDeviceEnabled()));
    parameters.setConsoleEnabled(getParameters().isConsoleEnabled());
    parameters.setVirtioScsiEnabled(getParameters().isVirtioScsiEnabled());
    parameters.setBalloonEnabled(getParameters().isBalloonEnabled());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    VmRngDevice rngDevice = getParameters().getRngDevice();
    if (rngDevice != null) {
        parameters.setUpdateRngDevice(true);
        parameters.setRngDevice(rngDevice);
    }
    parameters.getGraphicsDevices().putAll(getParameters().getGraphicsDevices());
    return parameters;
}
#method_after
private AddVmParameters buildAddVmParameters(String vmName) {
    VmStatic currVm = new VmStatic(getParameters().getVmStaticData());
    currVm.setName(vmName);
    currVm.setStateless(!getVmPool().isStateful());
    if (getParameters().getVmLargeIcon() != null) {
        final VmIconIdSizePair iconIds = iconUtils.ensureIconPairInDatabase(getParameters().getVmLargeIcon());
        currVm.setSmallIconId(iconIds.getSmall());
        currVm.setLargeIconId(iconIds.getLarge());
    }
    AddVmParameters parameters = new AddVmParameters(currVm);
    parameters.setPoolId(getVmPool().getVmPoolId());
    if (getVmPool().isAutoStorageSelect()) {
        parameters.setDiskInfoDestinationMap(autoSelectTargetDomainAndVolumeFormat());
    } else {
        parameters.setDiskInfoDestinationMap(diskInfoDestinationMap);
    }
    if (StringUtils.isEmpty(getParameters().getSessionId())) {
        parameters.setParametersCurrentUser(getCurrentUser());
    } else {
        parameters.setSessionId(getParameters().getSessionId());
    }
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    // check if device is enabled or we need to override it to true
    parameters.setSoundDeviceEnabled(Boolean.TRUE.equals(getParameters().isSoundDeviceEnabled()) || vmDeviceUtils.shouldOverrideSoundDevice(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion(), getParameters().isSoundDeviceEnabled()));
    parameters.setConsoleEnabled(getParameters().isConsoleEnabled());
    parameters.setVirtioScsiEnabled(getParameters().isVirtioScsiEnabled());
    parameters.setBalloonEnabled(getParameters().isBalloonEnabled());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    VmRngDevice rngDevice = getParameters().getRngDevice();
    if (rngDevice != null) {
        parameters.setUpdateRngDevice(true);
        parameters.setRngDevice(rngDevice);
    }
    parameters.getGraphicsDevices().putAll(getParameters().getGraphicsDevices());
    return parameters;
}
#end_block

#method_before
private HashMap<Guid, DiskImage> autoSelectTargetDomainAndVolumeFormat() {
    HashMap<Guid, DiskImage> destinationMap = new HashMap<>();
    for (Disk disk : templateDisks) {
        DiskImage diskImage = (DiskImage) disk;
        ArrayList<Guid> storageIds = new ArrayList<>();
        Guid storageId = findAvailableStorageDomain(disk.getSize(), diskToStorageIds.get(disk.getId()));
        storageIds.add(storageId);
        List<Guid> profileIds = diskToProfileMap.get(disk.getId());
        for (Guid profileId : profileIds) {
            DiskProfile profile = diskProfileDao.get(profileId);
            if (profile.getStorageDomainId().equals(storageId)) {
                diskImage.setDiskProfileId(profile.getId());
                break;
            }
        }
        // Set target domain
        diskImage.setStorageIds(storageIds);
        // Set volume format
        if (diskImage.getDiskStorageType() == DiskStorageType.CINDER) {
            diskImage.setVolumeFormat(VolumeFormat.RAW);
        } else {
            diskImage.setVolumeFormat(VolumeFormat.COW);
        }
        destinationMap.put(disk.getId(), diskImage);
    }
    return destinationMap;
}
#method_after
private HashMap<Guid, DiskImage> autoSelectTargetDomainAndVolumeFormat() {
    HashMap<Guid, DiskImage> destinationMap = new HashMap<>();
    for (Disk disk : templateDisks) {
        DiskImage diskImage = (DiskImage) disk;
        ArrayList<Guid> storageIds = new ArrayList<>();
        Guid storageId = findAvailableStorageDomain(disk.getSize(), diskToStorageIds.get(disk.getId()));
        storageIds.add(storageId);
        List<Guid> profileIds = diskToProfileMap.get(disk.getId());
        for (Guid profileId : profileIds) {
            DiskProfile profile = diskProfileDao.get(profileId);
            if (profile.getStorageDomainId().equals(storageId)) {
                diskImage.setDiskProfileId(profile.getId());
                break;
            }
        }
        // Set target domain
        diskImage.setStorageIds(storageIds);
        // validation
        if (diskImage.getDiskStorageType() == DiskStorageType.CINDER) {
            diskImage.setVolumeFormat(VolumeFormat.RAW);
        } else {
            diskImage.setVolumeFormat(VolumeFormat.COW);
        }
        destinationMap.put(disk.getId(), diskImage);
    }
    return destinationMap;
}
#end_block

#method_before
private boolean removeVm() {
    final List<DiskImage> diskImages = DisksFilter.filterImageDisks(getVm().getDiskList(), ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
    final List<LunDisk> lunDisks = DisksFilter.filterLunDisks(getVm().getDiskMap().values(), ONLY_NOT_SHAREABLE);
    for (VmNic nic : getInterfaces()) {
        ExternalNetworkManager.create(nic).deallocateIfExternal();
    }
    removeMemoryVolumes();
    TransactionSupport.executeInNewTransaction(() -> {
        removeVmFromDb();
        if (getParameters().isRemoveDisks()) {
            for (DiskImage image : diskImages) {
                getCompensationContext().snapshotEntityStatus(image.getImage(), ImageStatus.ILLEGAL);
                imagesHandler.updateImageStatus(image.getImage().getId(), ImageStatus.LOCKED);
            }
            for (LunDisk lunDisk : lunDisks) {
                imagesHandler.removeLunDisk(lunDisk);
            }
            getCompensationContext().stateChanged();
        } else {
            for (DiskImage image : diskImages) {
                imageDao.updateImageVmSnapshotId(image.getImageId(), null);
            }
        }
        return null;
    });
    Collection<DiskImage> unremovedDisks = Collections.emptyList();
    if (getParameters().isRemoveDisks()) {
        if (!diskImages.isEmpty()) {
            unremovedDisks = removeVmImages(diskImages).getActionReturnValue();
        }
        unremovedDisks.addAll(removeCinderDisks());
        if (!unremovedDisks.isEmpty()) {
            processUnremovedDisks(unremovedDisks);
            return false;
        }
    }
    vmDeleted.fire(getVmId());
    return true;
}
#method_after
private boolean removeVm() {
    final List<DiskImage> diskImages = DisksFilter.filterImageDisks(getVm().getDiskList(), ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
    final List<LunDisk> lunDisks = DisksFilter.filterLunDisks(getVm().getDiskMap().values(), ONLY_NOT_SHAREABLE);
    for (VmNic nic : getInterfaces()) {
        externalNetworkManagerFactory.create(nic).deallocateIfExternal();
    }
    removeMemoryVolumes();
    TransactionSupport.executeInNewTransaction(() -> {
        removeVmFromDb();
        if (getParameters().isRemoveDisks()) {
            for (DiskImage image : diskImages) {
                getCompensationContext().snapshotEntityStatus(image.getImage(), ImageStatus.ILLEGAL);
                imagesHandler.updateImageStatus(image.getImage().getId(), ImageStatus.LOCKED);
            }
            for (LunDisk lunDisk : lunDisks) {
                imagesHandler.removeLunDisk(lunDisk);
            }
            getCompensationContext().stateChanged();
        } else {
            for (DiskImage image : diskImages) {
                imageDao.updateImageVmSnapshotId(image.getImageId(), null);
            }
        }
        return null;
    });
    Collection<DiskImage> unremovedDisks = Collections.emptyList();
    if (getParameters().isRemoveDisks()) {
        if (!diskImages.isEmpty()) {
            unremovedDisks = removeVmImages(diskImages).getActionReturnValue();
        }
        unremovedDisks.addAll(removeCinderDisks());
        if (!unremovedDisks.isEmpty()) {
            processUnremovedDisks(unremovedDisks);
            return false;
        }
    }
    vmDeleted.fire(getVmId());
    return true;
}
#end_block

#method_before
private void removeMemoryVolumes() {
    Set<String> memoryStates = MemoryUtils.getMemoryVolumesFromSnapshots(snapshotDao.getAll(getVmId()));
    for (String memoryState : memoryStates) {
        VdcReturnValueBase retVal = runInternalAction(VdcActionType.RemoveMemoryVolumes, buildRemoveMemoryVolumesParameters(memoryState, getVmId()), cloneContextAndDetachFromParent());
        if (!retVal.getSucceeded()) {
            log.error("Failed to remove memory volumes while removing vm '{}' (volumes: '{}')", getVmId(), memoryState);
        }
    }
}
#method_after
private void removeMemoryVolumes() {
    Set<String> memoryStates = MemoryUtils.getMemoryVolumesFromSnapshots(snapshotDao.getAll(getVmId()));
    for (String memoryState : memoryStates) {
        ActionReturnValue retVal = runInternalAction(ActionType.RemoveMemoryVolumes, buildRemoveMemoryVolumesParameters(memoryState, getVmId()), cloneContextAndDetachFromParent());
        if (!retVal.getSucceeded()) {
            log.error("Failed to remove memory volumes while removing vm '{}' (volumes: '{}')", getVmId(), memoryState);
        }
    }
}
#end_block

#method_before
protected VdcReturnValueBase removeVmImages(List<DiskImage> images) {
    VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(VdcActionType.RemoveAllVmImages, buildRemoveAllVmImagesParameters(images));
    if (vdcRetValue.getSucceeded()) {
        getTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
    return vdcRetValue;
}
#method_after
protected ActionReturnValue removeVmImages(List<DiskImage> images) {
    ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.RemoveAllVmImages, buildRemoveAllVmImagesParameters(images));
    if (vdcRetValue.getSucceeded()) {
        getTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
    return vdcRetValue;
}
#end_block

#method_before
private Collection<CinderDisk> removeCinderDisks() {
    Collection<CinderDisk> failedRemoveCinderDisks = null;
    if (getParameters().isRemoveDisks()) {
        List<CinderDisk> cinderDisks = getCinderDisks();
        if (cinderDisks.isEmpty()) {
            return Collections.emptyList();
        }
        RemoveAllVmCinderDisksParameters param = new RemoveAllVmCinderDisksParameters(getVmId(), cinderDisks);
        param.setEndProcedure(EndProcedure.COMMAND_MANAGED);
        Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RemoveAllVmCinderDisks, withRootCommandInfo(param), cloneContextAndDetachFromParent());
        try {
            failedRemoveCinderDisks = future.get().getActionReturnValue();
        } catch (InterruptedException | ExecutionException e) {
            failedRemoveCinderDisks = cinderDisks;
            log.error("Exception", e);
        }
    }
    return failedRemoveCinderDisks;
}
#method_after
private Collection<CinderDisk> removeCinderDisks() {
    Collection<CinderDisk> failedRemoveCinderDisks = null;
    if (getParameters().isRemoveDisks()) {
        List<CinderDisk> cinderDisks = getCinderDisks();
        if (cinderDisks.isEmpty()) {
            return Collections.emptyList();
        }
        RemoveAllVmCinderDisksParameters param = new RemoveAllVmCinderDisksParameters(getVmId(), cinderDisks);
        param.setEndProcedure(EndProcedure.COMMAND_MANAGED);
        Future<ActionReturnValue> future = CommandCoordinatorUtil.executeAsyncCommand(ActionType.RemoveAllVmCinderDisks, withRootCommandInfo(param), cloneContextAndDetachFromParent());
        try {
            failedRemoveCinderDisks = future.get().getActionReturnValue();
        } catch (InterruptedException | ExecutionException e) {
            failedRemoveCinderDisks = cinderDisks;
            log.error("Exception", e);
        }
    }
    return failedRemoveCinderDisks;
}
#end_block

#method_before
@Override
public Guid createTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, VdcObjectType entityType, Guid... entityIds) {
    return super.createTaskInCurrentTransaction(taskId, asyncTaskCreationInfo, parentCommand, entityType, entityIds);
}
#method_after
@Override
public Guid createTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, ActionType parentCommand, VdcObjectType entityType, Guid... entityIds) {
    return super.createTaskInCurrentTransaction(taskId, asyncTaskCreationInfo, parentCommand, entityType, entityIds);
}
#end_block

#method_before
@Before
public void setUp() {
    injectorRule.bind(ProviderDao.class, providerDao);
    injectorRule.bind(AuditLogDirector.class, auditLogDirector);
    provider = new Provider<>();
    when(providerDao.get(PROVIDER_ID)).thenReturn(provider);
    doReturn(providerProxyFactory).when(underTest).getProviderProxyFactory();
    when(providerProxyFactory.create(provider)).thenReturn(networkProviderProxy);
}
#method_after
@Before
public void setUp() {
    injectorRule.bind(ProviderDao.class, providerDao);
    injectorRule.bind(AuditLogDirector.class, auditLogDirector);
    provider = new Provider<>();
    when(providerDao.get(PROVIDER_ID)).thenReturn(provider);
    when(providerProxyFactory.create(provider)).thenReturn(networkProviderProxy);
}
#end_block

#method_before
@Test
public void testDeallocateIfExternalThrowException() {
    nic.setName(NIC_NAME);
    nic.setId(NIC_ID);
    provider.setName(PROVIDER_NAME);
    doThrow(new EngineException()).when(networkProviderProxy).deallocate(nic);
    underTest.deallocateIfExternal();
    verify(auditLogDirector).log(auditLogableBaseCaptor.capture(), same(AuditLogType.REMOVE_PORT_FROM_EXTERNAL_PROVIDER_FAILED));
    final Map<String, String> capturedCustomValues = auditLogableBaseCaptor.getValue().getCustomValues();
    assertThat(capturedCustomValues, hasEntry("nicname", NIC_NAME));
    assertThat(capturedCustomValues, hasEntry("nicid", NIC_ID.toString()));
    assertThat(capturedCustomValues, hasEntry("providername", PROVIDER_NAME));
}
#method_after
@Test
public void testDeallocateIfExternalThrowException() {
    nic.setName(NIC_NAME);
    nic.setId(NIC_ID);
    provider.setName(PROVIDER_NAME);
    doThrow(new EngineException()).when(networkProviderProxy).deallocate(nic);
    underTest.deallocateIfExternal();
    verify(auditLogDirector).log(auditLogableCaptor.capture(), same(AuditLogType.REMOVE_PORT_FROM_EXTERNAL_PROVIDER_FAILED));
    final Map<String, String> capturedCustomValues = auditLogableCaptor.getValue().getCustomValues();
    assertThat(capturedCustomValues, hasEntry("nicname", NIC_NAME));
    assertThat(capturedCustomValues, hasEntry("nicid", NIC_ID.toString()));
    assertThat(capturedCustomValues, hasEntry("providername", PROVIDER_NAME));
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    this.setVmName(vmStaticDao.get(getParameters().getVmId()).getName());
    VmNic iface = vmNicDao.get(getParameters().getInterfaceId());
    if (iface != null) {
        interfaceName = iface.getName();
        // Get Interface type.
        String interType = VmInterfaceType.forValue(iface.getType()).getDescription();
        if (interType != null) {
            addCustomValue("InterfaceType", interType);
        }
        ExternalNetworkManager.create(iface).deallocateIfExternal();
        // return mac to pool
        getMacPool().freeMac(iface.getMacAddress());
    }
    // remove from db
    TransactionSupport.executeInNewTransaction(() -> {
        vmStaticDao.incrementDbGeneration(getParameters().getVmId());
        vmNicDao.remove(getParameters().getInterfaceId());
        vmNetworkStatisticsDao.remove(getParameters().getInterfaceId());
        vmDeviceDao.remove(new VmDeviceId(getParameters().getInterfaceId(), getParameters().getVmId()));
        setSucceeded(true);
        return null;
    });
}
#method_after
@Override
protected void executeVmCommand() {
    this.setVmName(vmStaticDao.get(getParameters().getVmId()).getName());
    VmNic iface = vmNicDao.get(getParameters().getInterfaceId());
    if (iface != null) {
        interfaceName = iface.getName();
        // Get Interface type.
        String interType = VmInterfaceType.forValue(iface.getType()).getDescription();
        if (interType != null) {
            addCustomValue("InterfaceType", interType);
        }
        externalNetworkManagerFactory.create(iface).deallocateIfExternal();
        // return mac to pool
        getMacPool().freeMac(iface.getMacAddress());
    }
    // remove from db
    TransactionSupport.executeInNewTransaction(() -> {
        vmStaticDao.incrementDbGeneration(getParameters().getVmId());
        vmNicDao.remove(getParameters().getInterfaceId());
        vmNetworkStatisticsDao.remove(getParameters().getInterfaceId());
        vmDeviceDao.remove(new VmDeviceId(getParameters().getInterfaceId(), getParameters().getVmId()));
        setSucceeded(true);
        return null;
    });
}
#end_block

#method_before
public void auditLogMacInUse(final VmNic iface) {
    TransactionSupport.executeInNewTransaction(() -> {
        AuditLogableBase logable = createAuditLog(iface);
        log(logable, AuditLogType.MAC_ADDRESS_IS_IN_USE);
        log.warn("Network Interface '{}' has MAC address '{}' which is in use, " + "therefore the action for VM '{}' failed.", iface.getName(), iface.getMacAddress(), iface.getVmId());
        return null;
    });
}
#method_after
public void auditLogMacInUse(final VmNic iface) {
    TransactionSupport.executeInNewTransaction(() -> {
        AuditLogable logable = createAuditLog(iface);
        log(logable, AuditLogType.MAC_ADDRESS_IS_IN_USE);
        log.warn("Network Interface '{}' has MAC address '{}' which is in use, " + "therefore the action for VM '{}' failed.", iface.getName(), iface.getMacAddress(), iface.getVmId());
        return null;
    });
}
#end_block

#method_before
public void auditLogMacInUseUnplug(final VmNic iface) {
    TransactionSupport.executeInNewTransaction(() -> {
        AuditLogableBase logable = createAuditLog(iface);
        log(logable, AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG);
        log.warn("Network Interface '{}' has MAC address '{}' which is in use, " + "therefore it is being unplugged from VM '{}'.", iface.getName(), iface.getMacAddress(), iface.getVmId());
        return null;
    });
}
#method_after
public void auditLogMacInUseUnplug(final VmNic iface, String vmName) {
    TransactionSupport.executeInNewTransaction(() -> {
        AuditLogable logable = createAuditLog(iface);
        logable.setVmName(vmName);
        log(logable, AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG);
        log.warn("Network Interface '{}' has MAC address '{}' which is in use, " + "therefore it is being unplugged from VM '{}'.", iface.getName(), iface.getMacAddress(), iface.getVmId());
        return null;
    });
}
#end_block

#method_before
protected void removeFromExternalNetworks(List<VmNic> interfaces) {
    Transaction transaction = TransactionSupport.suspend();
    for (VmNic iface : interfaces) {
        ExternalNetworkManager.create(iface).deallocateIfExternal();
    }
    TransactionSupport.resume(transaction);
}
#method_after
protected void removeFromExternalNetworks(List<VmNic> interfaces) {
    Transaction transaction = TransactionSupport.suspend();
    for (VmNic iface : interfaces) {
        getExternalNetworkManagerFactory().create(iface).deallocateIfExternal();
    }
    TransactionSupport.resume(transaction);
}
#end_block

#method_before
protected void log(AuditLogableBase logable, AuditLogType auditLogType) {
    new AuditLogDirector().log(logable, auditLogType);
}
#method_after
private void log(AuditLogable logable, AuditLogType auditLogType) {
    getAuditLogDirector().log(logable, auditLogType);
}
#end_block

#method_before
private AuditLogableBase createAuditLog(final VmNic iface) {
    AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase());
    logable.setVmId(iface.getVmId());
    logable.addCustomValue("MACAddr", iface.getMacAddress());
    logable.addCustomValue("IfaceName", iface.getName());
    return logable;
}
#method_after
private AuditLogable createAuditLog(final VmNic iface) {
    AuditLogable logable = new AuditLogableImpl();
    logable.addCustomValue("MACAddr", iface.getMacAddress());
    logable.addCustomValue("IfaceName", iface.getName());
    logable.setVmId(iface.getVmId());
    return logable;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    addCustomValue("InterfaceType", VmInterfaceType.forValue(getInterface().getType()).getDescription().toString());
    boolean succeeded = false;
    boolean macAddedToPool = false;
    try {
        if (isVnicProfileChanged(oldIface, getInterface())) {
            Network newNetwork = NetworkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
            Network oldNetwork = NetworkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
            if (!Objects.equals(oldNetwork, newNetwork)) {
                ExternalNetworkManager.create(oldIface).deallocateIfExternal();
            }
        }
        if (macShouldBeChanged) {
            macAddedToPool = addMacToPool(getMacAddress());
        }
        if (mustChangeAddress(oldIface.getType(), getInterface().getType())) {
            vmDeviceDao.clearDeviceAddress(getInterface().getId());
        }
        getInterface().setSpeed(VmInterfaceType.forValue(getInterface().getType()).getSpeed());
        TransactionSupport.executeInNewTransaction(() -> {
            bumpVmVersion();
            updatePassthoughDeviceIfNeeded();
            getCompensationContext().snapshotEntity(oldIface);
            vmNicDao.update(getInterface());
            getCompensationContext().stateChanged();
            return null;
        });
        succeeded = updateHost();
    } finally {
        setSucceeded(succeeded);
        MacPool macPool = getMacPool();
        if (macAddedToPool) {
            if (succeeded) {
                macPool.freeMac(oldIface.getMacAddress());
            } else {
                macPool.freeMac(getMacAddress());
            }
        }
    }
}
#method_after
@Override
protected void executeVmCommand() {
    addCustomValue("InterfaceType", VmInterfaceType.forValue(getInterface().getType()).getDescription().toString());
    boolean succeeded = false;
    boolean macAddedToPool = false;
    try {
        if (isVnicProfileChanged(oldIface, getInterface())) {
            Network newNetwork = NetworkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
            Network oldNetwork = NetworkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
            if (!Objects.equals(oldNetwork, newNetwork)) {
                externalNetworkManagerFactory.create(oldIface).deallocateIfExternal();
            }
        }
        if (macShouldBeChanged) {
            macAddedToPool = addMacToPool(getMacAddress());
        }
        if (mustChangeAddress(oldIface.getType(), getInterface().getType())) {
            vmDeviceDao.clearDeviceAddress(getInterface().getId());
        }
        getInterface().setSpeed(VmInterfaceType.forValue(getInterface().getType()).getSpeed());
        TransactionSupport.executeInNewTransaction(() -> {
            bumpVmVersion();
            updatePassthoughDeviceIfNeeded();
            getCompensationContext().snapshotEntity(oldIface);
            vmNicDao.update(getInterface());
            getCompensationContext().stateChanged();
            return null;
        });
        succeeded = updateHost();
    } finally {
        setSucceeded(succeeded);
        MacPool macPool = getMacPool();
        if (macAddedToPool) {
            if (succeeded) {
                macPool.freeMac(oldIface.getMacAddress());
            } else {
                macPool.freeMac(getMacAddress());
            }
        }
    }
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    if (getSucceeded()) {
        if (oldIface.isLinked() != getInterface().isLinked()) {
            AuditLogType customValue = getInterface().isLinked() ? AuditLogType.NETWORK_UPDATE_VM_INTERFACE_LINK_UP : AuditLogType.NETWORK_UPDATE_VM_INTERFACE_LINK_DOWN;
            addCustomValue("LinkState", auditLogDirector.getMessage(customValue));
        } else {
            addCustomValue("LinkState", " ");
        }
        return AuditLogType.NETWORK_UPDATE_VM_INTERFACE;
    }
    return AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    if (getSucceeded()) {
        if (oldIface.isLinked() != getInterface().isLinked()) {
            AuditLogType customValue = getInterface().isLinked() ? AuditLogType.NETWORK_UPDATE_VM_INTERFACE_LINK_UP : AuditLogType.NETWORK_UPDATE_VM_INTERFACE_LINK_DOWN;
            addCustomValue("LinkState", MessageBundler.getMessage(customValue));
        } else {
            addCustomValue("LinkState", " ");
        }
        return AuditLogType.NETWORK_UPDATE_VM_INTERFACE;
    }
    return AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED;
}
#end_block

#method_before
private void removeNetworks() {
    final List<Network> networks = networkDao.getAllForDataCenter(getStoragePoolId());
    for (Network network : networks) {
        if (network.isExternal()) {
            for (VmNic nic : vmNicDao.getAllForNetwork(network.getId())) {
                ExternalNetworkManager.create(nic, network).deallocateIfExternal();
            }
        }
    }
    TransactionSupport.executeInNewTransaction(() -> {
        for (final Network net : networks) {
            List<VnicProfile> profiles = vnicProfileDao.getAllForNetwork(net.getId());
            for (VnicProfile vnicProfile : profiles) {
                getCompensationContext().snapshotEntity(vnicProfile);
                vnicProfileDao.remove(vnicProfile.getId());
            }
            getCompensationContext().snapshotEntity(net);
            networkDao.remove(net.getId());
        }
        getCompensationContext().stateChanged();
        return null;
    });
}
#method_after
private void removeNetworks() {
    final List<Network> networks = networkDao.getAllForDataCenter(getStoragePoolId());
    for (Network network : networks) {
        if (network.isExternal()) {
            for (VmNic nic : vmNicDao.getAllForNetwork(network.getId())) {
                externalNetworkManagerFactory.create(nic, network).deallocateIfExternal();
            }
        }
    }
    TransactionSupport.executeInNewTransaction(() -> {
        for (final Network net : networks) {
            List<VnicProfile> profiles = vnicProfileDao.getAllForNetwork(net.getId());
            for (VnicProfile vnicProfile : profiles) {
                getCompensationContext().snapshotEntity(vnicProfile);
                vnicProfileDao.remove(vnicProfile.getId());
            }
            getCompensationContext().snapshotEntity(net);
            networkDao.remove(net.getId());
        }
        getCompensationContext().stateChanged();
        return null;
    });
}
#end_block

#method_before
protected boolean removeDomainFromPool(StorageDomain storageDomain, VDS vds) {
    if (storageDomain.getStorageType() != StorageType.LOCALFS || storageDomain.getStorageDomainType() == StorageDomainType.ISO) {
        DetachStorageDomainFromPoolParameters tempVar = new DetachStorageDomainFromPoolParameters(storageDomain.getId(), getStoragePool().getId());
        tempVar.setRemoveLast(true);
        tempVar.setDestroyingPool(true);
        // in detach of one of storage domains
        if (!Backend.getInstance().runInternalAction(VdcActionType.DetachStorageDomainFromPool, tempVar, cloneContext().withoutCompensationContext().withoutExecutionContext()).getSucceeded()) {
            return false;
        }
    } else {
        RemoveStorageDomainParameters tempVar = new RemoveStorageDomainParameters(storageDomain.getId());
        tempVar.setDestroyingPool(true);
        tempVar.setDoFormat(true);
        tempVar.setVdsId(vds.getId());
        if (!runInternalAction(VdcActionType.RemoveStorageDomain, tempVar, cloneContext().withoutLock().withoutExecutionContext()).getSucceeded()) {
            return false;
        }
    }
    return true;
}
#method_after
protected boolean removeDomainFromPool(StorageDomain storageDomain, VDS vds) {
    if (storageDomain.getStorageType() != StorageType.LOCALFS || storageDomain.getStorageDomainType() == StorageDomainType.ISO) {
        DetachStorageDomainFromPoolParameters tempVar = new DetachStorageDomainFromPoolParameters(storageDomain.getId(), getStoragePool().getId());
        tempVar.setRemoveLast(true);
        tempVar.setDestroyingPool(true);
        // in detach of one of storage domains
        if (!Backend.getInstance().runInternalAction(ActionType.DetachStorageDomainFromPool, tempVar, cloneContext().withoutCompensationContext().withoutExecutionContext()).getSucceeded()) {
            return false;
        }
    } else {
        RemoveStorageDomainParameters tempVar = new RemoveStorageDomainParameters(storageDomain.getId());
        tempVar.setDestroyingPool(true);
        tempVar.setDoFormat(true);
        tempVar.setVdsId(vds.getId());
        if (!runInternalAction(ActionType.RemoveStorageDomain, tempVar, cloneContext().withoutLock().withoutExecutionContext()).getSucceeded()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate() || !checkStoragePool() || !checkStoragePoolStatusNotEqual(StoragePoolStatus.Up, EngineMessage.ERROR_CANNOT_REMOVE_ACTIVE_STORAGE_POOL)) {
        return false;
    }
    if (getStoragePool().getStatus() != StoragePoolStatus.Uninitialized && !getParameters().getForceDelete() && !initializeVds()) {
        return false;
    }
    final List<StorageDomain> poolDomains = storageDomainDao.getAllForStoragePool(getStoragePool().getId());
    final List<StorageDomain> activeOrLockedDomains = getActiveOrLockedDomainList(poolDomains);
    if (!activeOrLockedDomains.isEmpty()) {
        return failValidation(EngineMessage.ERROR_CANNOT_REMOVE_POOL_WITH_ACTIVE_DOMAINS);
    }
    if (!getParameters().getForceDelete()) {
        if (poolDomains.size() > 1) {
            return failValidation(EngineMessage.ERROR_CANNOT_REMOVE_STORAGE_POOL_WITH_NONMASTER_DOMAINS);
        }
        if (!poolDomains.isEmpty() && !canDetachStorageDomainWithVmsAndDisks(poolDomains.get(0))) {
            return false;
        }
    } else {
        List<VDS> poolHosts = vdsDao.getAllForStoragePool(getParameters().getStoragePoolId());
        sharedLocks = new HashMap<>();
        for (VDS host : poolHosts) {
            sharedLocks.put(host.getId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VDS, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
        }
        if (!poolHosts.isEmpty() && acquireLockInternal()) {
            for (VDS host : poolHosts) {
                if (host.getStatus() != VDSStatus.Maintenance) {
                    return failValidation(EngineMessage.ERROR_CANNOT_FORCE_REMOVE_STORAGE_POOL_WITH_VDS_NOT_IN_MAINTENANCE);
                }
            }
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate() || !checkStoragePool() || !checkStoragePoolStatusNotEqual(StoragePoolStatus.Up, EngineMessage.ERROR_CANNOT_REMOVE_ACTIVE_STORAGE_POOL)) {
        return false;
    }
    if (getStoragePool().getStatus() != StoragePoolStatus.Uninitialized && !getParameters().getForceDelete() && !initializeVds()) {
        return false;
    }
    final List<StorageDomain> poolDomains = storageDomainDao.getAllForStoragePool(getStoragePool().getId());
    if (!validateDomainsInMaintenance(poolDomains)) {
        return false;
    }
    if (!getParameters().getForceDelete()) {
        if (poolDomains.size() > 1) {
            return failValidation(EngineMessage.ERROR_CANNOT_REMOVE_STORAGE_POOL_WITH_NONMASTER_DOMAINS);
        }
        if (!poolDomains.isEmpty() && !canDetachStorageDomainWithVmsAndDisks(poolDomains.get(0))) {
            return false;
        }
    } else {
        List<VDS> poolHosts = vdsDao.getAllForStoragePool(getParameters().getStoragePoolId());
        sharedLocks = new HashMap<>();
        for (VDS host : poolHosts) {
            sharedLocks.put(host.getId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VDS, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
        }
        if (!poolHosts.isEmpty() && acquireLockInternal()) {
            for (VDS host : poolHosts) {
                if (host.getStatus() != VDSStatus.Maintenance) {
                    return failValidation(EngineMessage.ERROR_CANNOT_FORCE_REMOVE_STORAGE_POOL_WITH_VDS_NOT_IN_MAINTENANCE);
                }
            }
        }
    }
    return true;
}
#end_block

#method_before
protected void connectAllHostToPoolAndDomain(final StorageDomain masterDomain) {
    final List<VDS> vdsList = getAllRunningVdssInPool();
    final StoragePool storagePool = getStoragePool();
    SyncronizeNumberOfAsyncOperations sync = new SyncronizeNumberOfAsyncOperations(vdsList.size(), null, new ActivateDeactivateSingleAsyncOperationFactory() {

        @Override
        public ISingleAsyncOperation createSingleAsyncOperation() {
            return Injector.injectMembers(new ConntectVDSToPoolAndDomains((ArrayList<VDS>) vdsList, masterDomain, storagePool));
        }

        @Override
        public void initialize(ArrayList parameters) {
        // no need to initilalize params
        }
    });
    sync.execute();
}
#method_after
protected void connectAllHostToPoolAndDomain(final StorageDomain masterDomain) {
    final List<VDS> vdsList = getAllRunningVdssInPool();
    final StoragePool storagePool = getStoragePool();
    SynchronizeNumberOfAsyncOperations sync = new SynchronizeNumberOfAsyncOperations(vdsList.size(), null, new ActivateDeactivateSingleAsyncOperationFactory() {

        @Override
        public ISingleAsyncOperation createSingleAsyncOperation() {
            return Injector.injectMembers(new ConnectVDSToPoolAndDomains(vdsList, masterDomain, storagePool));
        }

        @Override
        public void initialize(List parameters) {
        // no need to initilalize params
        }
    });
    sync.execute();
}
#end_block

#method_before
private void plugNic() {
    clearAddressIfPciSlotIsDuplicated(vmDevice);
    // HotPlug in the host is called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        boolean externalNetworkIsPlugged = getNetwork() != null && getNetwork().isExternal();
        if (externalNetworkIsPlugged) {
            plugToExternalNetwork();
        }
        String vfToUse = null;
        try {
            if (isPassthrough()) {
                String preallocatedVfForNic = getVfPreallocatedForNic();
                boolean preallocatedVfExist = preallocatedVfForNic != null;
                if (preallocatedVfExist) {
                    vfToUse = preallocatedVfForNic;
                } else {
                    vfToUse = acquireVF();
                    if (vfToUse == null) {
                        failValidationCannotPlugPassthroughVnicNoSuitableVf();
                        return;
                    }
                    networkDeviceHelper.setVmIdOnVfs(getVdsId(), getVmId(), Collections.singleton(vfToUse));
                }
                vmDevice.setHostDevice(vfToUse);
            }
            if (executePlugOrUnplug(PlugAction.PLUG)) {
                if (isPassthrough()) {
                    runInternalAction(VdcActionType.RefreshHost, new VdsActionParameters(getVdsId()));
                }
            } else {
                clearPassthroughData(vfToUse);
            }
        } catch (EngineException e) {
            if (externalNetworkIsPlugged && getParameters().isNewNic()) {
                unplugFromExternalNetwork();
            }
            clearPassthroughData(vfToUse);
            throw e;
        }
    }
}
#method_after
private void plugNic() {
    clearAddressIfPciSlotIsDuplicated(vmDevice);
    // HotPlug in the host is called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        boolean externalNetworkIsPlugged = getNetwork() != null && getNetwork().isExternal();
        if (externalNetworkIsPlugged) {
            plugToExternalNetwork();
        }
        String vfToUse = null;
        try {
            if (isPassthrough()) {
                String preallocatedVfForNic = getVfPreallocatedForNic();
                boolean preallocatedVfExist = preallocatedVfForNic != null;
                if (preallocatedVfExist) {
                    vfToUse = preallocatedVfForNic;
                } else {
                    vfToUse = acquireVF();
                    if (vfToUse == null) {
                        failValidationCannotPlugPassthroughVnicNoSuitableVf();
                        return;
                    }
                    networkDeviceHelper.setVmIdOnVfs(getVdsId(), getVmId(), Collections.singleton(vfToUse));
                }
                vmDevice.setHostDevice(vfToUse);
            }
            if (executePlugOrUnplug(PlugAction.PLUG)) {
                if (isPassthrough()) {
                    runInternalAction(ActionType.RefreshHost, new VdsActionParameters(getVdsId()));
                }
            } else {
                clearPassthroughData(vfToUse);
            }
        } catch (EngineException e) {
            if (externalNetworkIsPlugged && getParameters().isNewNic()) {
                unplugFromExternalNetwork();
            }
            clearPassthroughData(vfToUse);
            throw e;
        }
    }
}
#end_block

#method_before
private void unplugNic() {
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        if (executePlugOrUnplug(PlugAction.UNPLUG)) {
            if (isPassthrough()) {
                clearPassthroughData(vmDevice.getHostDevice());
                runInternalAction(VdcActionType.RefreshHost, new VdsActionParameters(getVdsId()));
            }
        }
    }
}
#method_after
private void unplugNic() {
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        if (executePlugOrUnplug(PlugAction.UNPLUG)) {
            if (isPassthrough()) {
                clearPassthroughData(vmDevice.getHostDevice());
                runInternalAction(ActionType.RefreshHost, new VdsActionParameters(getVdsId()));
            }
        }
    }
}
#end_block

#method_before
private boolean executePlugOrUnplug(PlugAction action) {
    VDSReturnValue vdsReturnValue = runVdsCommand(action.getvNicVdsCommandType(), new VmNicDeviceVDSParameters(getVdsId(), getVm(), getParameters().getNic(), vmDevice));
    return vdsReturnValue.getSucceeded();
}
#method_after
private boolean executePlugOrUnplug(PlugAction action) {
    VDSReturnValue vdsReturnValue = runVdsCommand(action.getvNicVdsCommandType(), new VmNicDeviceVDSParameters(getVdsId(), getVm(), getParameters().getNic(), vmDevice));
    updateVmDeviceWithDataReturnedFromHost(vdsReturnValue);
    return vdsReturnValue.getSucceeded();
}
#end_block

#method_before
private void unplugFromExternalNetwork() {
    ExternalNetworkManager.create(getParameters().getNic(), getNetwork()).deallocateIfExternal();
}
#method_after
private void unplugFromExternalNetwork() {
    externalNetworkManagerFactory.create(getParameters().getNic(), getNetwork()).deallocateIfExternal();
}
#end_block

#method_before
private NetworkProviderProxy getProviderProxy() {
    if (providerProxy == null) {
        Provider<?> provider = providerDao.get(getNetwork().getProvidedBy().getProviderId());
        providerProxy = ProviderProxyFactory.getInstance().create(provider);
    }
    return providerProxy;
}
#method_after
private NetworkProviderProxy getProviderProxy() {
    if (providerProxy == null) {
        Provider<?> provider = providerDao.get(getNetwork().getProvidedBy().getProviderId());
        providerProxy = providerProxyFactory.create(provider);
    }
    return providerProxy;
}
#end_block

#method_before
public void deallocateIfExternal() {
    if (getNetwork() != null && getNetwork().isExternal()) {
        Provider<?> provider = providerDao.get(getNetwork().getProvidedBy().getProviderId());
        NetworkProviderProxy providerProxy = getProviderProxyFactory().create(provider);
        try {
            providerProxy.deallocate(nic);
        } catch (EngineException e) {
            AuditLogableBase removePortFailureEvent = new AuditLogableBase();
            removePortFailureEvent.addCustomValue("NicName", nic.getName());
            removePortFailureEvent.addCustomValue("NicId", nic.getId().toString());
            removePortFailureEvent.addCustomValue("ProviderName", provider.getName());
            auditLogDirector.log(removePortFailureEvent, AuditLogType.REMOVE_PORT_FROM_EXTERNAL_PROVIDER_FAILED);
        }
    }
}
#method_after
public void deallocateIfExternal() {
    if (getNetwork() != null && getNetwork().isExternal()) {
        Provider<?> provider = providerDao.get(getNetwork().getProvidedBy().getProviderId());
        NetworkProviderProxy providerProxy = providerProxyFactory.create(provider);
        try {
            providerProxy.deallocate(nic);
        } catch (EngineException e) {
            AuditLogable removePortFailureEvent = new AuditLogableImpl();
            removePortFailureEvent.addCustomValue("NicName", nic.getName());
            removePortFailureEvent.addCustomValue("NicId", nic.getId().toString());
            removePortFailureEvent.addCustomValue("ProviderName", provider.getName());
            auditLogDirector.log(removePortFailureEvent, AuditLogType.REMOVE_PORT_FROM_EXTERNAL_PROVIDER_FAILED);
        }
    }
}
#end_block

#method_before
private void addVmRngDevice() {
    VmRngDevice rngDev = getParameters().getRngDevice();
    if (rngDev != null) {
        rngDev.setVmId(getVmId());
        RngDeviceParameters params = new RngDeviceParameters(rngDev, true);
        VdcReturnValueBase result = runInternalAction(ActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            log.error("Couldn't add RNG device for new VM.");
            throw new IllegalArgumentException("Couldn't add RNG device for new VM.");
        }
    }
}
#method_after
private void addVmRngDevice() {
    VmRngDevice rngDev = getParameters().getRngDevice();
    if (rngDev != null) {
        rngDev.setVmId(getVmId());
        RngDeviceParameters params = new RngDeviceParameters(rngDev, true);
        ActionReturnValue result = runInternalAction(ActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            log.error("Couldn't add RNG device for new VM.");
            throw new IllegalArgumentException("Couldn't add RNG device for new VM.");
        }
    }
}
#end_block

#method_before
private void addVmNumaNodes() {
    List<VmNumaNode> numaNodes = getParameters().getVm().getvNumaNodeList();
    if (numaNodes.isEmpty()) {
        return;
    }
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getParameters().getVm(), numaNodes);
    VdcReturnValueBase returnValueBase = getBackend().runInternalAction(ActionType.AddVmNumaNodes, params);
    if (!returnValueBase.getSucceeded()) {
        auditLogDirector.log(this, AuditLogType.NUMA_ADD_VM_NUMA_NODE_FAILED);
    }
}
#method_after
private void addVmNumaNodes() {
    List<VmNumaNode> numaNodes = getParameters().getVm().getvNumaNodeList();
    if (numaNodes.isEmpty()) {
        return;
    }
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getParameters().getVm(), numaNodes);
    ActionReturnValue returnValueBase = getBackend().runInternalAction(ActionType.AddVmNumaNodes, params);
    if (!returnValueBase.getSucceeded()) {
        auditLogDirector.log(this, AuditLogType.NUMA_ADD_VM_NUMA_NODE_FAILED);
    }
}
#end_block

#method_before
protected boolean addVmImages() {
    if (!vmDisksSource.getDiskTemplateMap().isEmpty()) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        lockVM();
        Collection<DiskImage> templateDisks = getImagesToCheckDestinationStorageDomains();
        List<DiskImage> diskImages = DisksFilter.filterImageDisks(templateDisks, ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
        for (DiskImage image : diskImages) {
            VdcReturnValueBase result = runInternalActionWithTasksContext(getDiskCreationCommandType(), buildDiskCreationParameters(image));
            // if couldn't create snapshot then stop the transaction and the command
            if (!result.getSucceeded()) {
                throw new EngineException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(image.getId(), newImage.getId());
            }
        }
        // Clone volumes for Cinder disk templates
        addVmCinderDisks(templateDisks);
    }
    return true;
}
#method_after
protected boolean addVmImages() {
    if (!vmDisksSource.getDiskTemplateMap().isEmpty()) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        lockVM();
        Collection<DiskImage> templateDisks = getImagesToCheckDestinationStorageDomains();
        List<DiskImage> diskImages = DisksFilter.filterImageDisks(templateDisks, ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
        for (DiskImage image : diskImages) {
            ActionReturnValue result = runInternalActionWithTasksContext(getDiskCreationCommandType(), buildDiskCreationParameters(image));
            // if couldn't create snapshot then stop the transaction and the command
            if (!result.getSucceeded()) {
                throw new EngineException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(image.getId(), newImage.getId());
            }
        }
        // Clone volumes for Cinder disk templates
        addVmCinderDisks(templateDisks);
    }
    return true;
}
#end_block

#method_before
protected void addVmCinderDisks(Collection<DiskImage> templateDisks) {
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(templateDisks);
    if (cinderDisks.isEmpty()) {
        return;
    }
    Map<Guid, Guid> diskImageMap = new HashMap<>();
    for (CinderDisk cinderDisk : cinderDisks) {
        ImagesContainterParametersBase params = buildCloneCinderDiskCommandParameters(cinderDisk);
        VdcReturnValueBase vdcReturnValueBase = runInternalAction(ActionType.CloneSingleCinderDisk, params, cloneContext().withoutExecutionContext().withoutLock());
        if (!vdcReturnValueBase.getSucceeded()) {
            log.error("Error cloning Cinder disk '{}': {}", cinderDisk.getDiskAlias());
            getReturnValue().setFault(vdcReturnValueBase.getFault());
            return;
        }
        Guid imageId = vdcReturnValueBase.getActionReturnValue();
        diskImageMap.put(cinderDisk.getId(), imageId);
    }
    srcDiskIdToTargetDiskIdMapping.putAll(diskImageMap);
}
#method_after
protected void addVmCinderDisks(Collection<DiskImage> templateDisks) {
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(templateDisks);
    if (cinderDisks.isEmpty()) {
        return;
    }
    Map<Guid, Guid> diskImageMap = new HashMap<>();
    for (CinderDisk cinderDisk : cinderDisks) {
        ImagesContainterParametersBase params = buildCloneCinderDiskCommandParameters(cinderDisk);
        ActionReturnValue actionReturnValue = runInternalAction(ActionType.CloneSingleCinderDisk, params, cloneContext().withoutExecutionContext().withoutLock());
        if (!actionReturnValue.getSucceeded()) {
            log.error("Error cloning Cinder disk '{}': {}", cinderDisk.getDiskAlias());
            getReturnValue().setFault(actionReturnValue.getFault());
            return;
        }
        Guid imageId = actionReturnValue.getActionReturnValue();
        diskImageMap.put(cinderDisk.getId(), imageId);
    }
    srcDiskIdToTargetDiskIdMapping.putAll(diskImageMap);
}
#end_block

#method_before
private void addVmToPool() {
    AddVmToPoolParameters parameters = new AddVmToPoolParameters(getParameters().getPoolId(), getVmId());
    parameters.setShouldBeLogged(false);
    VdcReturnValueBase result = runInternalActionWithTasksContext(ActionType.AddVmToPool, parameters);
    setSucceeded(result.getSucceeded());
    if (!result.getSucceeded()) {
        log.error("Error adding VM {} to Pool {}", getVmId(), getParameters().getPoolId());
        getReturnValue().setFault(result.getFault());
        return;
    }
    addVmPermission();
}
#method_after
private void addVmToPool() {
    AddVmToPoolParameters parameters = new AddVmToPoolParameters(getParameters().getPoolId(), getVmId());
    parameters.setShouldBeLogged(false);
    ActionReturnValue result = runInternalActionWithTasksContext(ActionType.AddVmToPool, parameters);
    setSucceeded(result.getSucceeded());
    if (!result.getSucceeded()) {
        log.error("Error adding VM {} to Pool {}", getVmId(), getParameters().getPoolId());
        getReturnValue().setFault(result.getFault());
        return;
    }
    addVmPermission();
}
#end_block

#method_before
private void createStatelessSnapshot() {
    warnIfNotAllDisksPermitSnapshots();
    log.info("Creating stateless snapshot for VM '{}' ({})", getVm().getName(), getVm().getId());
    CreateAllSnapshotsFromVmParameters createAllSnapshotsFromVmParameters = buildCreateSnapshotParameters();
    VdcReturnValueBase vdcReturnValue = runInternalAction(ActionType.CreateAllSnapshotsFromVm, createAllSnapshotsFromVmParameters, createContextForStatelessSnapshotCreation());
    // setting lock to null in order not to release lock twice
    setLock(null);
    setSucceeded(vdcReturnValue.getSucceeded());
    if (!vdcReturnValue.getSucceeded()) {
        if (areDisksLocked(vdcReturnValue)) {
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        getReturnValue().setFault(vdcReturnValue.getFault());
        log.error("Failed to create stateless snapshot for VM '{}' ({})", getVm().getName(), getVm().getId());
    }
}
#method_after
private void createStatelessSnapshot() {
    warnIfNotAllDisksPermitSnapshots();
    log.info("Creating stateless snapshot for VM '{}' ({})", getVm().getName(), getVm().getId());
    CreateAllSnapshotsFromVmParameters createAllSnapshotsFromVmParameters = buildCreateSnapshotParameters();
    ActionReturnValue actionReturnValue = runInternalAction(ActionType.CreateAllSnapshotsFromVm, createAllSnapshotsFromVmParameters, createContextForStatelessSnapshotCreation());
    // setting lock to null in order not to release lock twice
    setLock(null);
    setSucceeded(actionReturnValue.getSucceeded());
    if (!actionReturnValue.getSucceeded()) {
        if (areDisksLocked(actionReturnValue)) {
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        getReturnValue().setFault(actionReturnValue.getFault());
        log.error("Failed to create stateless snapshot for VM '{}' ({})", getVm().getName(), getVm().getId());
    }
}
#end_block

#method_before
private boolean areDisksLocked(VdcReturnValueBase vdcReturnValue) {
    return vdcReturnValue.getValidationMessages().contains(EngineMessage.ACTION_TYPE_FAILED_DISKS_LOCKED.name());
}
#method_after
private boolean areDisksLocked(ActionReturnValue actionReturnValue) {
    return actionReturnValue.getValidationMessages().contains(EngineMessage.ACTION_TYPE_FAILED_DISKS_LOCKED.name());
}
#end_block

#method_before
protected CreateVDSCommandParameters buildCreateVmParameters() {
    CreateVDSCommandParameters parameters = new CreateVDSCommandParameters(getVdsId(), getVm());
    parameters.setRunInUnknownStatus(getParameters().isRunInUnknownStatus());
    parameters.setVmPayload(vmPayload);
    parameters.setHibernationVolHandle(getMemoryFromActiveSnapshot());
    parameters.setPassthroughVnicToVfMap(flushPassthroughVnicToVfMap());
    if (initializationType == InitializationType.Sysprep && osRepository.isWindows(getVm().getVmOsId()) && (getVm().getFloppyPath() == null || "".equals(getVm().getFloppyPath()))) {
        parameters.setInitializationType(InitializationType.Sysprep);
    }
    if (initializationType == InitializationType.CloudInit && !osRepository.isWindows(getVm().getVmOsId())) {
        parameters.setInitializationType(InitializationType.CloudInit);
    }
    return parameters;
}
#method_after
protected CreateVDSCommandParameters buildCreateVmParameters() {
    CreateVDSCommandParameters parameters = new CreateVDSCommandParameters(getVdsId(), getVm());
    parameters.setRunInUnknownStatus(getParameters().isRunInUnknownStatus());
    parameters.setVmPayload(vmPayload);
    String memoryFromActiveSnapshot = getMemoryFromActiveSnapshot();
    if (StringUtils.isNotEmpty(memoryFromActiveSnapshot)) {
        parameters.setHibernationVolHandle(memoryFromActiveSnapshot);
        parameters.setDownSince(getVm().getStatus() == VMStatus.Suspended ? getVm().getLastStopTime() : getActiveSnapshot().getCreationDate());
    }
    parameters.setPassthroughVnicToVfMap(flushPassthroughVnicToVfMap());
    if (initializationType == InitializationType.Sysprep && osRepository.isWindows(getVm().getVmOsId()) && (getVm().getFloppyPath() == null || "".equals(getVm().getFloppyPath()))) {
        parameters.setInitializationType(InitializationType.Sysprep);
    }
    if (initializationType == InitializationType.CloudInit && !osRepository.isWindows(getVm().getVmOsId())) {
        parameters.setInitializationType(InitializationType.CloudInit);
    }
    return parameters;
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    if (shouldEndSnapshotCreation()) {
        VdcReturnValueBase vdcReturnValue = getBackend().endAction(ActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), cloneContext().withoutExecutionContext().withoutLock());
        setSucceeded(vdcReturnValue.getSucceeded());
    // we are not running the VM, of course,
    // since we couldn't create a snapshot.
    } else {
        super.endWithFailure();
    }
}
#method_after
@Override
protected void endWithFailure() {
    if (shouldEndSnapshotCreation()) {
        ActionReturnValue actionReturnValue = getBackend().endAction(ActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), cloneContext().withoutExecutionContext().withoutLock());
        setSucceeded(actionReturnValue.getSucceeded());
    // we are not running the VM, of course,
    // since we couldn't create a snapshot.
    } else {
        super.endWithFailure();
    }
}
#end_block

#method_before
private void updateVmTemplateVersion() {
    if (getVm().getStatus() == VMStatus.Down) {
        VdcReturnValueBase result = runInternalActionWithTasksContext(ActionType.UpdateVmVersion, new UpdateVmVersionParameters(getVmId(), getParameters().getVm().getVmtGuid(), getParameters().getVm().isUseLatestVersion()), getLock());
        if (result.getSucceeded()) {
            getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
        }
        setSucceeded(result.getSucceeded());
        setActionReturnValue(ActionType.UpdateVmVersion);
    } else {
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContext());
        setSucceeded(true);
    }
}
#method_after
private void updateVmTemplateVersion() {
    if (getVm().getStatus() == VMStatus.Down) {
        ActionReturnValue result = runInternalActionWithTasksContext(ActionType.UpdateVmVersion, new UpdateVmVersionParameters(getVmId(), getParameters().getVm().getVmtGuid(), getParameters().getVm().isUseLatestVersion()), getLock());
        if (result.getSucceeded()) {
            getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
        }
        setSucceeded(result.getSucceeded());
        setActionReturnValue(ActionType.UpdateVmVersion);
    } else {
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContext());
        setSucceeded(true);
    }
}
#end_block

#method_before
private void updateRngDevice() {
    if (!getParameters().isUpdateRngDevice()) {
        return;
    }
    QueryReturnValue query = runInternalQuery(QueryType.GetRngDevice, new IdQueryParameters(getParameters().getVmId()));
    List<VmRngDevice> rngDevs = query.getReturnValue();
    VdcReturnValueBase rngCommandResult = null;
    if (rngDevs.isEmpty()) {
        if (getParameters().getRngDevice() != null) {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            rngCommandResult = runInternalAction(ActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
        }
    } else {
        if (getParameters().getRngDevice() == null) {
            RngDeviceParameters params = new RngDeviceParameters(rngDevs.get(0), true);
            rngCommandResult = runInternalAction(ActionType.RemoveRngDevice, params, cloneContextAndDetachFromParent());
        } else {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            params.getRngDevice().setDeviceId(rngDevs.get(0).getDeviceId());
            rngCommandResult = runInternalAction(ActionType.UpdateRngDevice, params, cloneContextAndDetachFromParent());
        }
    }
    if (rngCommandResult != null && !rngCommandResult.getSucceeded()) {
        log.error("Updating RNG device of VM {} ({}) failed. Old RNG device = {}. New RNG device = {}.", getVm().getName(), getVm().getId(), rngDevs.isEmpty() ? null : rngDevs.get(0), getParameters().getRngDevice());
    }
}
#method_after
private void updateRngDevice() {
    if (!getParameters().isUpdateRngDevice()) {
        return;
    }
    QueryReturnValue query = runInternalQuery(QueryType.GetRngDevice, new IdQueryParameters(getParameters().getVmId()));
    List<VmRngDevice> rngDevs = query.getReturnValue();
    ActionReturnValue rngCommandResult = null;
    if (rngDevs.isEmpty()) {
        if (getParameters().getRngDevice() != null) {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            rngCommandResult = runInternalAction(ActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
        }
    } else {
        if (getParameters().getRngDevice() == null) {
            RngDeviceParameters params = new RngDeviceParameters(rngDevs.get(0), true);
            rngCommandResult = runInternalAction(ActionType.RemoveRngDevice, params, cloneContextAndDetachFromParent());
        } else {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            params.getRngDevice().setDeviceId(rngDevs.get(0).getDeviceId());
            rngCommandResult = runInternalAction(ActionType.UpdateRngDevice, params, cloneContextAndDetachFromParent());
        }
    }
    if (rngCommandResult != null && !rngCommandResult.getSucceeded()) {
        log.error("Updating RNG device of VM {} ({}) failed. Old RNG device = {}. New RNG device = {}.", getVm().getName(), getVm().getId(), rngDevs.isEmpty() ? null : rngDevs.get(0), getParameters().getRngDevice());
    }
}
#end_block

#method_before
private void hotSetCpus(VM newVm) {
    int currentSockets = getVm().getNumOfSockets();
    int newNumOfSockets = newVm.getNumOfSockets();
    // try hotplug only if topology (cpuPerSocket, threadsPerCpu) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && VmCommonUtils.isCpusToBeHotplugged(getVm(), newVm)) {
        HotSetNumberOfCpusParameters params = new HotSetNumberOfCpusParameters(newVmStatic, currentSockets < newNumOfSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        VdcReturnValueBase setNumberOfCpusResult = runInternalAction(ActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        // into the OVF store and automatically used during the next HE VM start
        if (!getVm().isHostedEngine()) {
            newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newNumOfSockets : currentSockets);
        }
        logHotSetActionEvent(setNumberOfCpusResult, AuditLogType.FAILED_HOT_SET_NUMBER_OF_CPUS);
    }
}
#method_after
private void hotSetCpus(VM newVm) {
    int currentSockets = getVm().getNumOfSockets();
    int newNumOfSockets = newVm.getNumOfSockets();
    // try hotplug only if topology (cpuPerSocket, threadsPerCpu) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && VmCommonUtils.isCpusToBeHotplugged(getVm(), newVm)) {
        HotSetNumberOfCpusParameters params = new HotSetNumberOfCpusParameters(newVmStatic, currentSockets < newNumOfSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        ActionReturnValue setNumberOfCpusResult = runInternalAction(ActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        // into the OVF store and automatically used during the next HE VM start
        if (!getVm().isHostedEngine()) {
            newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newNumOfSockets : currentSockets);
        }
        logHotSetActionEvent(setNumberOfCpusResult, AuditLogType.FAILED_HOT_SET_NUMBER_OF_CPUS);
    }
}
#end_block

#method_before
private void hotPlugMemoryDevice(int currentMemoryMb, int newAmountOfMemoryMb) {
    HotSetAmountOfMemoryParameters params = new HotSetAmountOfMemoryParameters(newVmStatic, currentMemoryMb < newAmountOfMemoryMb ? PlugAction.PLUG : PlugAction.UNPLUG, // We always use node 0, auto-numa should handle the allocation
    0, newAmountOfMemoryMb - currentMemoryMb);
    VdcReturnValueBase setAmountOfMemoryResult = runInternalAction(ActionType.HotSetAmountOfMemory, params, cloneContextAndDetachFromParent());
    // into the OVF store and automatically used during the next HE VM start
    if (!getVm().isHostedEngine()) {
        newVmStatic.setMemSizeMb(setAmountOfMemoryResult.getSucceeded() ? newAmountOfMemoryMb : currentMemoryMb);
    }
    logHotSetActionEvent(setAmountOfMemoryResult, AuditLogType.FAILED_HOT_SET_MEMORY);
}
#method_after
private void hotPlugMemoryDevice(int currentMemoryMb, int newAmountOfMemoryMb) {
    HotSetAmountOfMemoryParameters params = new HotSetAmountOfMemoryParameters(newVmStatic, currentMemoryMb < newAmountOfMemoryMb ? PlugAction.PLUG : PlugAction.UNPLUG, // We always use node 0, auto-numa should handle the allocation
    0, newAmountOfMemoryMb - currentMemoryMb);
    ActionReturnValue setAmountOfMemoryResult = runInternalAction(ActionType.HotSetAmountOfMemory, params, cloneContextAndDetachFromParent());
    // into the OVF store and automatically used during the next HE VM start
    if (!getVm().isHostedEngine()) {
        newVmStatic.setMemSizeMb(setAmountOfMemoryResult.getSucceeded() ? newAmountOfMemoryMb : currentMemoryMb);
    }
    logHotSetActionEvent(setAmountOfMemoryResult, AuditLogType.FAILED_HOT_SET_MEMORY);
}
#end_block

#method_before
private void logHotSetActionEvent(VdcReturnValueBase setActionResult, AuditLogType logType) {
    if (!setActionResult.isValid()) {
        AuditLogable logable = new AuditLogableImpl();
        logable.setVmId(getVmId());
        logable.setVmName(getVmName());
        List<String> validationMessages = getBackend().getErrorsTranslator().translateErrorText(setActionResult.getValidationMessages());
        logable.addCustomValue(HotSetNumberOfCpusCommand.LOGABLE_FIELD_ERROR_MESSAGE, StringUtils.join(validationMessages, ","));
        auditLogDirector.log(logable, logType);
    }
}
#method_after
private void logHotSetActionEvent(ActionReturnValue setActionResult, AuditLogType logType) {
    if (!setActionResult.isValid()) {
        AuditLogable logable = new AuditLogableImpl();
        logable.setVmId(getVmId());
        logable.setVmName(getVmName());
        List<String> validationMessages = getBackend().getErrorsTranslator().translateErrorText(setActionResult.getValidationMessages());
        logable.addCustomValue(HotSetNumberOfCpusCommand.LOGABLE_FIELD_ERROR_MESSAGE, StringUtils.join(validationMessages, ","));
        auditLogDirector.log(logable, logType);
    }
}
#end_block

#method_before
private void addLogMessages(VdcReturnValueBase returnValueBase) {
    if (!returnValueBase.getSucceeded()) {
        auditLogDirector.log(this, AuditLogType.NUMA_UPDATE_VM_NUMA_NODE_FAILED);
    }
}
#method_after
private void addLogMessages(ActionReturnValue returnValueBase) {
    if (!returnValueBase.getSucceeded()) {
        auditLogDirector.log(this, AuditLogType.NUMA_UPDATE_VM_NUMA_NODE_FAILED);
    }
}
#end_block

#method_before
public static void fillImagesMapBasedOnTemplate(VmTemplate template, List<StorageDomain> domains, Map<Guid, DiskImage> diskInfoDestinationMap, Map<Guid, StorageDomain> destStorages) {
    Map<Guid, StorageDomain> storageDomainsMap = domains.stream().filter(ImagesHandler::isDomainValidDestination).collect(Collectors.toMap(StorageDomain::getId, Function.identity()));
    for (DiskImage image : template.getDiskTemplateMap().values()) {
        for (Guid storageId : image.getStorageIds()) {
            if (storageDomainsMap.containsKey(storageId)) {
                ArrayList<Guid> storageIds = new ArrayList<>();
                storageIds.add(storageId);
                image.setStorageIds(storageIds);
                diskInfoDestinationMap.put(image.getId(), image);
                break;
            }
        }
    }
    if (destStorages != null) {
        destStorages.putAll(diskInfoDestinationMap.values().stream().collect(Collectors.toMap(d -> d.getStorageIds().get(0), d -> storageDomainsMap.get(d.getStorageIds().get(0)))));
    }
}
#method_after
public static void fillImagesMapBasedOnTemplate(VmTemplate template, List<StorageDomain> domains, Map<Guid, DiskImage> diskInfoDestinationMap, Map<Guid, StorageDomain> destStorages) {
    Map<Guid, StorageDomain> storageDomainsMap = domains.stream().filter(ImagesHandler::isDomainValidDestination).collect(Collectors.toMap(StorageDomain::getId, Function.identity()));
    for (DiskImage image : template.getDiskTemplateMap().values()) {
        for (Guid storageId : image.getStorageIds()) {
            if (storageDomainsMap.containsKey(storageId)) {
                ArrayList<Guid> storageIds = new ArrayList<>();
                storageIds.add(storageId);
                image.setStorageIds(storageIds);
                diskInfoDestinationMap.put(image.getId(), image);
                break;
            }
        }
    }
    if (destStorages != null) {
        for (DiskImage diskImage : diskInfoDestinationMap.values()) {
            Guid storageDomainId = diskImage.getStorageIds().get(0);
            destStorages.put(storageDomainId, storageDomainsMap.get(storageDomainId));
        }
    }
}
#end_block

#method_before
public Snapshot addActiveSnapshot(Guid snapshotId, VM vm, final CompensationContext compensationContext) {
    return addActiveSnapshot(snapshotId, vm, SnapshotStatus.OK, "", null, compensationContext);
}
#method_after
public Snapshot addActiveSnapshot(Guid snapshotId, VM vm, final CompensationContext compensationContext) {
    return addActiveSnapshot(snapshotId, vm, SnapshotStatus.OK, "", null, null, compensationContext);
}
#end_block

#method_before
public Snapshot addActiveSnapshot(Guid snapshotId, VM vm, SnapshotStatus snapshotStatus, final CompensationContext compensationContext) {
    return addActiveSnapshot(snapshotId, vm, snapshotStatus, "", null, compensationContext);
}
#method_after
public Snapshot addActiveSnapshot(Guid snapshotId, VM vm, SnapshotStatus snapshotStatus, final CompensationContext compensationContext) {
    return addActiveSnapshot(snapshotId, vm, snapshotStatus, "", null, null, compensationContext);
}
#end_block

#method_before
public Snapshot addActiveSnapshot(Guid snapshotId, VM vm, String memoryVolume, final CompensationContext compensationContext) {
    return addActiveSnapshot(snapshotId, vm, SnapshotStatus.OK, memoryVolume, null, compensationContext);
}
#method_after
public Snapshot addActiveSnapshot(Guid snapshotId, VM vm, String memoryVolume, final CompensationContext compensationContext) {
    return addActiveSnapshot(snapshotId, vm, SnapshotStatus.OK, memoryVolume, null, null, compensationContext);
}
#end_block

#method_before
public Snapshot addActiveSnapshot(Guid snapshotId, VM vm, SnapshotStatus snapshotStatus, String memoryVolume, List<DiskImage> disks, final CompensationContext compensationContext) {
    return addSnapshot(snapshotId, "Active VM", snapshotStatus, SnapshotType.ACTIVE, vm, false, memoryVolume, disks, compensationContext);
}
#method_after
public Snapshot addActiveSnapshot(Guid snapshotId, VM vm, String memoryVolume, Date creationDate, List<DiskImage> disks, final CompensationContext compensationContext) {
    return addActiveSnapshot(snapshotId, vm, SnapshotStatus.OK, memoryVolume, creationDate, disks, compensationContext);
}
#end_block

#method_before
public Snapshot addActiveSnapshot(Guid snapshotId, VM vm, SnapshotStatus snapshotStatus, String memoryVolume, final CompensationContext compensationContext) {
    return addActiveSnapshot(snapshotId, vm, snapshotStatus, memoryVolume, null, compensationContext);
}
#method_after
public Snapshot addActiveSnapshot(Guid snapshotId, VM vm, SnapshotStatus snapshotStatus, String memoryVolume, final CompensationContext compensationContext) {
    return addActiveSnapshot(snapshotId, vm, snapshotStatus, memoryVolume, null, null, compensationContext);
}
#end_block

#method_before
public Snapshot addSnapshot(Guid snapshotId, String description, SnapshotType snapshotType, VM vm, String memoryVolume, final CompensationContext compensationContext) {
    return addSnapshot(snapshotId, description, SnapshotStatus.LOCKED, snapshotType, vm, true, memoryVolume, null, compensationContext);
}
#method_after
public Snapshot addSnapshot(Guid snapshotId, String description, SnapshotType snapshotType, VM vm, String memoryVolume, final CompensationContext compensationContext) {
    return addSnapshot(snapshotId, description, SnapshotStatus.LOCKED, snapshotType, vm, true, memoryVolume, null, null, compensationContext);
}
#end_block

#method_before
public Snapshot addSnapshot(Guid snapshotId, String description, SnapshotStatus snapshotStatus, SnapshotType snapshotType, VM vm, boolean saveVmConfiguration, String memoryVolume, List<DiskImage> disks, Map<Guid, VmDevice> vmDevices, final CompensationContext compensationContext) {
    final Snapshot snapshot = new Snapshot(snapshotId, snapshotStatus, vm.getId(), saveVmConfiguration ? generateVmConfiguration(vm, disks, vmDevices) : null, snapshotType, description, new Date(), vm.getAppList(), memoryVolume, MemoryUtils.getMemoryDiskId(memoryVolume), MemoryUtils.getMetadataDiskId(memoryVolume));
    snapshotDao.save(snapshot);
    compensationContext.snapshotNewEntity(snapshot);
    return snapshot;
}
#method_after
public Snapshot addSnapshot(Guid snapshotId, String description, SnapshotStatus snapshotStatus, SnapshotType snapshotType, VM vm, boolean saveVmConfiguration, String memoryVolume, Date creationDate, List<DiskImage> disks, final CompensationContext compensationContext) {
    return addSnapshot(snapshotId, description, snapshotStatus, snapshotType, vm, saveVmConfiguration, memoryVolume, creationDate, disks, null, compensationContext);
}
#end_block

#method_before
public boolean updateVmFromConfiguration(VM vm, String configuration) {
    try {
        VmStatic oldVmStatic = vm.getStaticData();
        VM tempVM = new VM();
        ArrayList<DiskImage> images = new ArrayList<>();
        ArrayList<VmNetworkInterface> interfaces = new ArrayList<>();
        ovfManager.importVm(configuration, tempVM, images, interfaces);
        for (DiskImage diskImage : images) {
            DiskImage dbImage = diskImageDao.getSnapshotById(diskImage.getImageId());
            if (dbImage != null) {
                diskImage.setStorageIds(dbImage.getStorageIds());
            }
        }
        new VMStaticOvfLogHandler(tempVM.getStaticData()).resetDefaults(oldVmStatic);
        vm.setStaticData(tempVM.getStaticData());
        IconUtils.preserveIcons(vm.getStaticData(), oldVmStatic);
        vm.setImages(images);
        vm.setInterfaces(interfaces);
        // These fields are not saved in the OVF, so get them from the current VM.
        vm.setIsoPath(oldVmStatic.getIsoPath());
        vm.setCpuProfileId(oldVmStatic.getCpuProfileId());
        vm.setClusterId(oldVmStatic.getClusterId());
        // The VM configuration does not hold the vds group Id.
        // It is necessary to fetch the vm static from the Db, in order to get this information
        VmStatic vmStaticFromDb = vmStaticDao.get(vm.getId());
        if (vmStaticFromDb != null) {
            Cluster cluster = clusterDao.get(vmStaticFromDb.getClusterId());
            if (cluster != null) {
                vm.setStoragePoolId(cluster.getStoragePoolId());
                vm.setClusterCompatibilityVersion(cluster.getCompatibilityVersion());
                vm.setClusterName(cluster.getName());
                vm.setClusterCpuName(cluster.getCpuName());
            }
        }
        // if the required dedicated host is invalid -> use current VM dedicated host
        if (!vmHandler.validateDedicatedVdsExistOnSameCluster(vm.getStaticData(), null)) {
            vm.setDedicatedVmForVdsList(oldVmStatic.getDedicatedVmForVdsList());
        }
        VmHandler.updateMaxMemorySize(vm.getStaticData(), vm.getCompatibilityVersion());
        validateQuota(vm);
        return true;
    } catch (OvfReaderException e) {
        log.error("Failed to update VM from the configuration '{}': {}", configuration, e.getMessage());
        log.debug("Exception", e);
        return false;
    }
}
#method_after
public boolean updateVmFromConfiguration(VM vm, String configuration) {
    try {
        VmStatic oldVmStatic = vm.getStaticData();
        VM tempVM = new VM();
        if (vm.getDynamicData() != null) {
            tempVM.setDynamicData(vm.getDynamicData());
        }
        ArrayList<DiskImage> images = new ArrayList<>();
        ArrayList<VmNetworkInterface> interfaces = new ArrayList<>();
        ovfManager.importVm(configuration, tempVM, images, interfaces);
        for (DiskImage diskImage : images) {
            DiskImage dbImage = diskImageDao.getSnapshotById(diskImage.getImageId());
            if (dbImage != null) {
                diskImage.setStorageIds(dbImage.getStorageIds());
            }
        }
        new VMStaticOvfLogHandler(tempVM.getStaticData()).resetDefaults(oldVmStatic);
        vm.setStaticData(tempVM.getStaticData());
        IconUtils.preserveIcons(vm.getStaticData(), oldVmStatic);
        vm.setImages(images);
        vm.setInterfaces(interfaces);
        // These fields are not saved in the OVF, so get them from the current VM.
        vm.setIsoPath(oldVmStatic.getIsoPath());
        vm.setCpuProfileId(oldVmStatic.getCpuProfileId());
        vm.setClusterId(oldVmStatic.getClusterId());
        // The VM configuration does not hold the vds group Id.
        // It is necessary to fetch the vm static from the Db, in order to get this information
        VmStatic vmStaticFromDb = vmStaticDao.get(vm.getId());
        if (vmStaticFromDb != null) {
            Cluster cluster = clusterDao.get(vmStaticFromDb.getClusterId());
            if (cluster != null) {
                vm.setStoragePoolId(cluster.getStoragePoolId());
                vm.setClusterCompatibilityVersion(cluster.getCompatibilityVersion());
                vm.setClusterName(cluster.getName());
                vm.setClusterCpuName(cluster.getCpuName());
            }
        }
        // if the required dedicated host is invalid -> use current VM dedicated host
        if (!vmHandler.validateDedicatedVdsExistOnSameCluster(vm.getStaticData(), null)) {
            vm.setDedicatedVmForVdsList(oldVmStatic.getDedicatedVmForVdsList());
        }
        VmHandler.updateMaxMemorySize(vm.getStaticData(), vm.getCompatibilityVersion());
        validateQuota(vm);
        return true;
    } catch (OvfReaderException e) {
        log.error("Failed to update VM from the configuration '{}': {}", configuration, e.getMessage());
        log.debug("Exception", e);
        return false;
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final Guid targetClusterId = getParameters().getClusterId();
    if (getSourceCluster().getId().equals(targetClusterId)) {
        setSucceeded(true);
        return;
    }
    // save the new cluster id
    TransactionSupport.executeInNewTransaction(() -> {
        VdsStatic staticData = getVds().getStaticData();
        getCompensationContext().snapshotEntity(staticData);
        staticData.setClusterId(targetClusterId);
        vdsStaticDao.update(staticData);
        getCompensationContext().stateChanged();
        // remove the server from resource manager and add it back
        initializeVds();
        return null;
    });
    if (targetStoragePool != null && (getSourceCluster().getStoragePoolId() == null || !targetStoragePool.getId().equals(getSourceCluster().getStoragePoolId()))) {
        VdsActionParameters addVdsSpmIdParams = new VdsActionParameters(getVdsIdRef());
        addVdsSpmIdParams.setSessionId(getParameters().getSessionId());
        addVdsSpmIdParams.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(ActionType.AddVdsSpmId, addVdsSpmIdParams, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    if (getSourceCluster().supportsGlusterService() && clusterUtils.hasServers(getSourceCluster().getId())) {
        if (!glusterHostRemove(getSourceCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getTargetCluster().supportsGlusterService() && clusterUtils.hasMultipleServers(getTargetCluster().getId())) {
        if (!glusterHostAdd(getTargetCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getSourceCluster().getStoragePoolId() != null && (targetStoragePool == null || !getSourceCluster().getStoragePoolId().equals(targetStoragePool.getId()))) {
        vdsSpmIdMapDao.removeByVdsAndStoragePool(getVds().getId(), getSourceCluster().getStoragePoolId());
    }
    HostNetworkAttachmentsPersister persister = new HostNetworkAttachmentsPersister(this.networkAttachmentDao, getVdsId(), interfaceDao.getAllInterfacesForVds(getVdsId()), Collections.emptyList(), getTargetClusterNetworks());
    persister.persistNetworkAttachments();
    if (VDSStatus.PendingApproval != getVds().getStatus()) {
        configureNetworks();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    final Guid targetClusterId = getParameters().getClusterId();
    if (getSourceCluster().getId().equals(targetClusterId)) {
        setSucceeded(true);
        return;
    }
    // save the new cluster id
    TransactionSupport.executeInNewTransaction(() -> {
        VdsStatic staticData = getVds().getStaticData();
        getCompensationContext().snapshotEntity(staticData);
        staticData.setClusterId(targetClusterId);
        vdsStaticDao.update(staticData);
        getCompensationContext().stateChanged();
        // remove the server from resource manager and add it back
        initializeVds();
        return null;
    });
    if (targetStoragePool != null && (getSourceCluster().getStoragePoolId() == null || !targetStoragePool.getId().equals(getSourceCluster().getStoragePoolId()))) {
        VdsActionParameters addVdsSpmIdParams = new VdsActionParameters(getVdsIdRef());
        addVdsSpmIdParams.setSessionId(getParameters().getSessionId());
        addVdsSpmIdParams.setCompensationEnabled(true);
        ActionReturnValue addVdsSpmIdReturn = runInternalAction(ActionType.AddVdsSpmId, addVdsSpmIdParams, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    if (getSourceCluster().supportsGlusterService() && clusterUtils.hasServers(getSourceCluster().getId())) {
        if (!glusterHostRemove(getSourceCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getTargetCluster().supportsGlusterService() && clusterUtils.hasMultipleServers(getTargetCluster().getId())) {
        if (!glusterHostAdd(getTargetCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getSourceCluster().getStoragePoolId() != null && (targetStoragePool == null || !getSourceCluster().getStoragePoolId().equals(targetStoragePool.getId()))) {
        vdsSpmIdMapDao.removeByVdsAndStoragePool(getVds().getId(), getSourceCluster().getStoragePoolId());
    }
    HostNetworkAttachmentsPersister persister = new HostNetworkAttachmentsPersister(this.networkAttachmentDao, getVdsId(), interfaceDao.getAllInterfacesForVds(getVdsId()), Collections.emptyList(), getTargetClusterNetworks());
    persister.persistNetworkAttachments();
    if (VDSStatus.PendingApproval != getVds().getStatus()) {
        configureNetworks();
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.error("Failed to remove duplicated oVirt entry with id '{}'. Abort adding oVirt Host type", oVirtId);
            throw new EngineException(EngineError.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(() -> {
        addVdsStaticToDb();
        addVdsDynamicToDb();
        addVdsStatisticsToDb();
        addAffinityLabels();
        getCompensationContext().stateChanged();
        return null;
    });
    if (getParameters().isProvisioned()) {
        HostProviderProxy proxy = providerProxyFactory.create(getHostProvider());
        proxy.provisionHost(getParameters().getvds(), getParameters().getHostGroup(), getParameters().getComputeResource(), getParameters().getHostMac(), getParameters().getDiscoverName(), getParameters().getPassword(), getParameters().getDiscoverIp());
        addCustomValue("HostGroupName", getParameters().getHostGroup().getName());
        auditLogDirector.log(this, AuditLogType.VDS_PROVISION);
    }
    // set vds spm id
    if (getCluster().getStoragePoolId() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(ActionType.AddVdsSpmId, tempVar, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(() -> {
        initializeVds(true);
        alertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
        testVdsPowerManagementStatus(getParameters().getVdsStaticData());
        setSucceeded(true);
        setActionReturnValue(getVdsIdRef());
        // If the installation failed, we don't want to compensate for the failure since it will remove the
        // host, but instead the host should be left in an "install failed" status.
        getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
        return null;
    });
    // clients). they are installed as part of the approve process or automatically after provision
    if (Config.<Boolean>getValue(ConfigValues.InstallVds) && !getParameters().isPending() && !getParameters().isProvisioned()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        installVdsParameters.setAuthMethod(getParameters().getAuthMethod());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setActivateHost(getParameters().getActivateHost());
        installVdsParameters.setNetworkProviderId(getParameters().getVdsStaticData().getOpenstackNetworkProviderId());
        installVdsParameters.setNetworkMappings(getParameters().getNetworkMappings());
        installVdsParameters.setEnableSerialConsole(getParameters().getEnableSerialConsole());
        if (getParameters().getHostedEngineDeployConfiguration() != null) {
            Map<String, String> vdsDeployParams = hostedEngineHelper.createVdsDeployParams(getVdsId(), getParameters().getHostedEngineDeployConfiguration().getDeployAction());
            installVdsParameters.setHostedEngineConfiguration(vdsDeployParams);
        }
        Map<String, String> values = new HashMap<>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getName());
        Step installStep = executionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(() -> runInternalAction(ActionType.InstallVdsInternal, installVdsParameters, cloneContextAndDetachFromParent().withExecutionContext(installCtx)));
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#method_after
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.error("Failed to remove duplicated oVirt entry with id '{}'. Abort adding oVirt Host type", oVirtId);
            throw new EngineException(EngineError.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(() -> {
        addVdsStaticToDb();
        addVdsDynamicToDb();
        addVdsStatisticsToDb();
        addAffinityLabels();
        getCompensationContext().stateChanged();
        return null;
    });
    if (getParameters().isProvisioned()) {
        HostProviderProxy proxy = providerProxyFactory.create(getHostProvider());
        proxy.provisionHost(getParameters().getvds(), getParameters().getHostGroup(), getParameters().getComputeResource(), getParameters().getHostMac(), getParameters().getDiscoverName(), getParameters().getPassword(), getParameters().getDiscoverIp());
        addCustomValue("HostGroupName", getParameters().getHostGroup().getName());
        auditLogDirector.log(this, AuditLogType.VDS_PROVISION);
    }
    // set vds spm id
    if (getCluster().getStoragePoolId() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        ActionReturnValue addVdsSpmIdReturn = runInternalAction(ActionType.AddVdsSpmId, tempVar, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(() -> {
        initializeVds(true);
        alertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
        testVdsPowerManagementStatus(getParameters().getVdsStaticData());
        setSucceeded(true);
        setActionReturnValue(getVdsIdRef());
        // If the installation failed, we don't want to compensate for the failure since it will remove the
        // host, but instead the host should be left in an "install failed" status.
        getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
        return null;
    });
    // clients). they are installed as part of the approve process or automatically after provision
    if (Config.<Boolean>getValue(ConfigValues.InstallVds) && !getParameters().isPending() && !getParameters().isProvisioned()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        installVdsParameters.setAuthMethod(getParameters().getAuthMethod());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setActivateHost(getParameters().getActivateHost());
        installVdsParameters.setNetworkProviderId(getParameters().getVdsStaticData().getOpenstackNetworkProviderId());
        installVdsParameters.setNetworkMappings(getParameters().getNetworkMappings());
        installVdsParameters.setEnableSerialConsole(getParameters().getEnableSerialConsole());
        if (getParameters().getHostedEngineDeployConfiguration() != null) {
            Map<String, String> vdsDeployParams = hostedEngineHelper.createVdsDeployParams(getVdsId(), getParameters().getHostedEngineDeployConfiguration().getDeployAction());
            installVdsParameters.setHostedEngineConfiguration(vdsDeployParams);
        }
        Map<String, String> values = new HashMap<>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getName());
        Step installStep = executionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(() -> runInternalAction(ActionType.InstallVdsInternal, installVdsParameters, cloneContextAndDetachFromParent().withExecutionContext(installCtx)));
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#end_block

#method_before
private boolean removeDeprecatedOvirtEntry(final Guid oVirtId) {
    final VDS vds = vdsDao.get(oVirtId);
    if (vds == null || !VdsHandler.isPendingOvirt(vds)) {
        return false;
    }
    String vdsName = getParameters().getVdsStaticData().getName();
    log.info("Host '{}', id '{}' of type '{}' is being re-registered as Host '{}'", vds.getName(), vds.getId(), vds.getVdsType().name(), vdsName);
    VdcReturnValueBase result = TransactionSupport.executeInNewTransaction(() -> runInternalAction(ActionType.RemoveVds, new RemoveVdsParameters(oVirtId)));
    if (!result.getSucceeded()) {
        String errors = result.isValid() ? result.getFault().getError().name() : StringUtils.join(result.getValidationMessages(), ",");
        log.warn("Failed to remove Host '{}', id '{}', re-registering it as Host '{}' fails with errors {}", vds.getName(), vds.getId(), vdsName, errors);
    } else {
        log.info("Host '{}' is now known as Host '{}'", vds.getName(), vdsName);
    }
    return result.getSucceeded();
}
#method_after
private boolean removeDeprecatedOvirtEntry(final Guid oVirtId) {
    final VDS vds = vdsDao.get(oVirtId);
    if (vds == null || !VdsHandler.isPendingOvirt(vds)) {
        return false;
    }
    String vdsName = getParameters().getVdsStaticData().getName();
    log.info("Host '{}', id '{}' of type '{}' is being re-registered as Host '{}'", vds.getName(), vds.getId(), vds.getVdsType().name(), vdsName);
    ActionReturnValue result = TransactionSupport.executeInNewTransaction(() -> runInternalAction(ActionType.RemoveVds, new RemoveVdsParameters(oVirtId)));
    if (!result.getSucceeded()) {
        String errors = result.isValid() ? result.getFault().getError().name() : StringUtils.join(result.getValidationMessages(), ",");
        log.warn("Failed to remove Host '{}', id '{}', re-registering it as Host '{}' fails with errors {}", vds.getName(), vds.getId(), vdsName, errors);
    } else {
        log.info("Host '{}' is now known as Host '{}'", vds.getName(), vdsName);
    }
    return result.getSucceeded();
}
#end_block

#method_before
private void copyAllMemoryImages(Guid containerID) {
    for (Snapshot snapshot : snapshotsWithMemory) {
        List<Guid> guids = GuidUtils.getGuidListFromString(snapshot.getMemoryVolume());
        // copy the memory dump image
        VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryDumpImage(containerID, guids.get(0), guids.get(2), guids.get(3)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        // copy the memory configuration (of the VM) image
        vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryConfImage(containerID, guids.get(0), guids.get(4), guids.get(5)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#method_after
private void copyAllMemoryImages(Guid containerID) {
    for (Snapshot snapshot : snapshotsWithMemory) {
        List<Guid> guids = GuidUtils.getGuidListFromString(snapshot.getMemoryVolume());
        // copy the memory dump image
        ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryDumpImage(containerID, guids.get(0), guids.get(2), guids.get(3)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        // copy the memory configuration (of the VM) image
        vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryConfImage(containerID, guids.get(0), guids.get(4), guids.get(5)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#end_block

#method_before
@Override
protected void moveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForDisk(containerID, disk));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#method_after
@Override
protected void moveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForDisk(containerID, disk));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#end_block

#method_before
protected boolean checkVmInStorageDomain() {
    boolean retVal = true;
    GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getVm().getStoragePoolId(), getParameters().getStorageDomainId());
    VdcQueryReturnValue qretVal = runInternalQuery(VdcQueryType.GetVmsFromExportDomain, tempVar);
    if (qretVal.getSucceeded()) {
        ArrayList<VM> vms = qretVal.getReturnValue();
        for (VM vm : vms) {
            if (vm.getId().equals(getVm().getId())) {
                if (!getParameters().getForceOverride()) {
                    addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_GUID_ALREADY_EXIST);
                    retVal = false;
                    break;
                }
            } else if (vm.getName().equals(getVm().getName())) {
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                retVal = false;
                break;
            }
        }
    }
    return retVal;
}
#method_after
protected boolean checkVmInStorageDomain() {
    boolean retVal = true;
    GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getVm().getStoragePoolId(), getParameters().getStorageDomainId());
    QueryReturnValue qretVal = runInternalQuery(QueryType.GetVmsFromExportDomain, tempVar);
    if (qretVal.getSucceeded()) {
        ArrayList<VM> vms = qretVal.getReturnValue();
        for (VM vm : vms) {
            if (vm.getId().equals(getVm().getId())) {
                if (!getParameters().getForceOverride()) {
                    addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_GUID_ALREADY_EXIST);
                    retVal = false;
                    break;
                }
            } else if (vm.getName().equals(getVm().getName())) {
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                retVal = false;
                break;
            }
        }
    }
    return retVal;
}
#end_block

#method_before
public static boolean checkTemplateInStorageDomain(Guid storagePoolId, Guid storageDomainId, final Guid tmplId, EngineContext engineContext) {
    boolean retVal = false;
    GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    VdcQueryReturnValue qretVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar, engineContext);
    if (qretVal.getSucceeded()) {
        if (!VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(tmplId)) {
            Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
            retVal = templates.keySet().stream().anyMatch(vmTemplate -> vmTemplate.getId().equals(tmplId));
        } else {
            retVal = true;
        }
    }
    return retVal;
}
#method_after
public static boolean checkTemplateInStorageDomain(Guid storagePoolId, Guid storageDomainId, final Guid tmplId, EngineContext engineContext) {
    boolean retVal = false;
    GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    QueryReturnValue qretVal = Backend.getInstance().runInternalQuery(QueryType.GetTemplatesFromExportDomain, tempVar, engineContext);
    if (qretVal.getSucceeded()) {
        if (!VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(tmplId)) {
            Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
            retVal = templates.keySet().stream().anyMatch(vmTemplate -> vmTemplate.getId().equals(tmplId));
        } else {
            retVal = true;
        }
    }
    return retVal;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Permission perms = getParameters().getPermission();
    Guid userId = perms.getAdElementId();
    // check if vm is from pool and detach it
    if (perms.getObjectType().equals(VdcObjectType.VM) && perms.getRoleId().equals(PredefinedRoles.ENGINE_USER.getId())) {
        VM vm = vmDao.get(perms.getObjectId());
        if (vm != null && vm.getVmPoolId() != null) {
            runInternalActionWithTasksContext(VdcActionType.DetachUserFromVmFromPool, new DetachUserFromVmFromPoolParameters(vm.getVmPoolId(), userId, vm.getId(), true));
        }
    }
    permissionDao.remove(perms.getId());
    dbUserDao.updateLastAdminCheckStatus(userId);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    Permission perms = getParameters().getPermission();
    Guid userId = perms.getAdElementId();
    // check if vm is from pool and detach it
    if (perms.getObjectType().equals(VdcObjectType.VM) && perms.getRoleId().equals(PredefinedRoles.ENGINE_USER.getId())) {
        VM vm = vmDao.get(perms.getObjectId());
        if (vm != null && vm.getVmPoolId() != null) {
            runInternalActionWithTasksContext(ActionType.DetachUserFromVmFromPool, new DetachUserFromVmFromPoolParameters(vm.getVmPoolId(), userId, vm.getId(), true));
        }
    }
    permissionDao.remove(perms.getId());
    dbUserDao.updateLastAdminCheckStatus(userId);
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!isFloatingDisk() && (!validate(new VmValidator(getVm()).isVmExists()) || !validateDiskVmData())) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE || diskInfo.getDiskStorageType() == DiskStorageType.CINDER) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    DiskVmElementValidator diskVmElementValidator = getDiskVmElementValidator(getParameters().getDiskInfo(), getDiskVmElement());
    if (vm != null) {
        if (!validateDiskVmData() || !canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        if (getDiskVmElement().isBoot() && !validate(diskValidator.isVmNotContainsBootDisk(vm))) {
            return false;
        }
        if (!validatePassDiscardSupported(diskVmElementValidator)) {
            return false;
        }
        // if user sent drive check that its not in use
        if (!isDiskPassPciAndIdeLimit()) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failValidation(EngineMessage.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    if (!validate(diskVmElementValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (!validateQuota()) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        if (!checkIfImageDiskCanBeAdded(vm, diskVmElementValidator)) {
            return false;
        }
        return setAndValidateDiskProfiles();
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    if (DiskStorageType.CINDER == getParameters().getDiskInfo().getDiskStorageType()) {
        CinderDisk cinderDisk = (CinderDisk) getParameters().getDiskInfo();
        cinderDisk.setStorageIds(new ArrayList<>(Collections.singletonList(getStorageDomainId())));
        StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisk);
        return validate(storageDomainValidator.isDomainExistAndActive()) && validate(cinderDisksValidator.validateCinderDiskLimits()) && validate(cinderDisksValidator.validateCinderVolumeTypesExist());
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!isFloatingDisk() && (!validate(new VmValidator(getVm()).isVmExists()) || !validateDiskVmData())) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE || diskInfo.getDiskStorageType() == DiskStorageType.CINDER) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    DiskVmElementValidator diskVmElementValidator = getDiskVmElementValidator(getParameters().getDiskInfo(), getDiskVmElement());
    if (vm != null) {
        if (!validateDiskVmData() || !canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        if (getDiskVmElement().isBoot() && !validate(diskValidator.isVmNotContainsBootDisk(vm))) {
            return false;
        }
        if (!validatePassDiscardSupported(diskVmElementValidator)) {
            return false;
        }
        // if user sent drive check that its not in use
        if (!isDiskPassPciAndIdeLimit()) {
            return false;
        }
        if (!validate(diskVmElementValidator.isReadOnlyPropertyCompatibleWithInterface())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failValidation(EngineMessage.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    if (!validateQuota()) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        if (!checkIfImageDiskCanBeAdded(vm, diskVmElementValidator)) {
            return false;
        }
        return setAndValidateDiskProfiles();
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    if (DiskStorageType.CINDER == getParameters().getDiskInfo().getDiskStorageType()) {
        CinderDisk cinderDisk = (CinderDisk) getParameters().getDiskInfo();
        cinderDisk.setStorageIds(new ArrayList<>(Collections.singletonList(getStorageDomainId())));
        StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisk);
        return validate(storageDomainValidator.isDomainExistAndActive()) && validate(cinderDisksValidator.validateCinderDiskLimits()) && validate(cinderDisksValidator.validateCinderVolumeTypesExist());
    }
    return true;
}
#end_block

#method_before
protected List<LUNs> executeGetDeviceList(Guid vdsId, StorageType storageType, String lunId) {
    GetDeviceListVDSCommandParameters parameters = new GetDeviceListVDSCommandParameters(vdsId, storageType, false, Collections.singletonList(lunId));
    return (List<LUNs>) runVdsCommand(VDSCommandType.GetDeviceList, parameters).getReturnValue();
}
#method_after
protected List<LUNs> executeGetDeviceList(Guid vdsId, StorageType storageType, String lunId) {
    GetDeviceListVDSCommandParameters parameters = new GetDeviceListVDSCommandParameters(vdsId, storageType, false, Collections.singleton(lunId));
    return (List<LUNs>) runVdsCommand(VDSCommandType.GetDeviceList, parameters).getReturnValue();
}
#end_block

#method_before
protected VmDevice addManagedDeviceForDisk(Guid diskId) {
    return getVmDeviceUtils().addDiskDevice(getVmId(), diskId, shouldDiskBePlugged(), Boolean.TRUE.equals(getParameters().getDiskInfo().getReadOnly()));
}
#method_after
protected VmDevice addManagedDeviceForDisk(Guid diskId) {
    return getVmDeviceUtils().addDiskDevice(getVmId(), diskId, shouldDiskBePlugged(), Boolean.TRUE.equals(getParameters().getDiskVmElement().isReadOnly()));
}
#end_block

#method_before
private void createDiskBasedOnImage() {
    if (!getParameters().getDiskInfo().isWipeAfterDeleteSet()) {
        getParameters().getDiskInfo().setWipeAfterDelete(getStorageDomain().getWipeAfterDelete());
    }
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskProfileId(getDiskImageInfo().getDiskProfileId());
    parameters.setDiskAlias(getDiskAlias());
    if (getParameters().isUsePassedImageId()) {
        parameters.setDestinationImageId(getDiskImageInfo().getImageId());
    }
    parameters.setLeaveLocked(getParameters().isShouldRemainLockedOnSuccesfulExecution());
    parameters.setShouldRemainIllegalOnFailedExecution(getParameters().isShouldRemainIllegalOnFailedExecution());
    parameters.setStorageDomainId(getStorageDomainId());
    if (useCallback()) {
        parameters.setParentCommand(VdcActionType.AddDisk);
        parameters.setParentParameters(getParameters());
    } else {
        parameters.setParentCommand(getParameters().getParentCommand());
        parameters.setParentParameters(getParameters().getParentParameters());
    }
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setStoragePoolId(getStorageDomain().getStoragePoolId());
    setVmSnapshotIdForDisk(parameters);
    VdcReturnValueBase tmpRetValue = runInternalActionWithTasksContext(VdcActionType.AddImageFromScratch, parameters, getLock());
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    getTaskIdList().addAll(tmpRetValue.getInternalVdsmTaskIdList());
    if (getVm() != null) {
        // The disk VM element has to be added before the VM device since as a part of the VM device creation the
        // boot order is determined so the VM device creation depends on the existence of the disk VM element
        getCompensationContext().snapshotEntity(addDiskVmElementForDisk(getDiskVmElement()));
        getCompensationContext().snapshotNewEntity(addManagedDeviceForDisk(getParameters().getDiskInfo().getId()));
        getCompensationContext().stateChanged();
    }
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#method_after
private void createDiskBasedOnImage() {
    if (!getParameters().getDiskInfo().isWipeAfterDeleteSet()) {
        getParameters().getDiskInfo().setWipeAfterDelete(getStorageDomain().getWipeAfterDelete());
    }
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskProfileId(getDiskImageInfo().getDiskProfileId());
    parameters.setDiskAlias(getDiskAlias());
    if (getParameters().isUsePassedImageId()) {
        parameters.setDestinationImageId(getDiskImageInfo().getImageId());
    }
    parameters.setLeaveLocked(getParameters().isShouldRemainLockedOnSuccesfulExecution());
    parameters.setShouldRemainIllegalOnFailedExecution(getParameters().isShouldRemainIllegalOnFailedExecution());
    parameters.setStorageDomainId(getStorageDomainId());
    if (useCallback()) {
        parameters.setParentCommand(ActionType.AddDisk);
        parameters.setParentParameters(getParameters());
    } else {
        parameters.setParentCommand(getParameters().getParentCommand());
        parameters.setParentParameters(getParameters().getParentParameters());
    }
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setStoragePoolId(getStorageDomain().getStoragePoolId());
    setVmSnapshotIdForDisk(parameters);
    ActionReturnValue tmpRetValue = runInternalActionWithTasksContext(ActionType.AddImageFromScratch, parameters, getLock());
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    getTaskIdList().addAll(tmpRetValue.getInternalVdsmTaskIdList());
    if (getVm() != null) {
        // The disk VM element has to be added before the VM device since as a part of the VM device creation the
        // boot order is determined so the VM device creation depends on the existence of the disk VM element
        getCompensationContext().snapshotEntity(addDiskVmElementForDisk(getDiskVmElement()));
        getCompensationContext().snapshotNewEntity(addManagedDeviceForDisk(getParameters().getDiskInfo().getId()));
        getCompensationContext().stateChanged();
    }
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#end_block

#method_before
private void createDiskBasedOnCinder() {
    // ToDo: upon using CoCo infra in this commnad, move this logic.
    Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.AddCinderDisk, buildAddCinderDiskParameters(), cloneContextAndDetachFromParent());
    try {
        setReturnValue(future.get());
        setSucceeded(getReturnValue().getSucceeded());
    } catch (InterruptedException | ExecutionException e) {
        log.error("Error creating Cinder disk '{}': {}", getParameters().getDiskInfo().getDiskAlias(), e.getMessage());
        log.debug("Exception", e);
    }
}
#method_after
private void createDiskBasedOnCinder() {
    // ToDo: upon using CoCo infra in this commnad, move this logic.
    Future<ActionReturnValue> future = CommandCoordinatorUtil.executeAsyncCommand(ActionType.AddCinderDisk, buildAddCinderDiskParameters(), cloneContextAndDetachFromParent());
    try {
        setReturnValue(future.get());
        setSucceeded(getReturnValue().getSucceeded());
    } catch (InterruptedException | ExecutionException e) {
        log.error("Error creating Cinder disk '{}': {}", getParameters().getDiskInfo().getDiskAlias(), e.getMessage());
        log.debug("Exception", e);
    }
}
#end_block

#method_before
private VdcActionParametersBase buildAddCinderDiskParameters() {
    AddDiskParameters parameters = new AddDiskParameters(new DiskVmElement(null, getVmId()), getParameters().getDiskInfo());
    parameters.setPlugDiskToVm(getParameters().getPlugDiskToVm());
    parameters.setStorageDomainId(getParameters().getStorageDomainId());
    parameters.setQuotaId(getQuotaId());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    if (getVm() != null) {
        parameters.setVmSnapshotId(snapshotDao.getId(getVmId(), SnapshotType.ACTIVE));
        parameters.setDiskVmElement(getParameters().getDiskVmElement());
    }
    return parameters;
}
#method_after
private ActionParametersBase buildAddCinderDiskParameters() {
    AddDiskParameters parameters = new AddDiskParameters(new DiskVmElement(null, getVmId()), getParameters().getDiskInfo());
    parameters.setPlugDiskToVm(getParameters().getPlugDiskToVm());
    parameters.setStorageDomainId(getParameters().getStorageDomainId());
    parameters.setQuotaId(getQuotaId());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    if (getVm() != null) {
        parameters.setVmSnapshotId(snapshotDao.getId(getVmId(), SnapshotType.ACTIVE));
        parameters.setDiskVmElement(getParameters().getDiskVmElement());
    }
    return parameters;
}
#end_block

#method_before
@Override
protected VdcActionType getChildActionType() {
    return VdcActionType.AddImageFromScratch;
}
#method_after
@Override
protected ActionType getChildActionType() {
    return ActionType.AddImageFromScratch;
}
#end_block

#method_before
private void plugDiskToVmIfNeeded() {
    if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm()) && getVm() != null && getVm().getStatus() != VMStatus.Down) {
        VmDiskOperationParameterBase params = new VmDiskOperationParameterBase(new DiskVmElement(getParameters().getDiskInfo().getId(), getVmId()));
        params.setShouldBeLogged(false);
        VdcReturnValueBase returnValue = runInternalAction(VdcActionType.HotPlugDiskToVm, params);
        if (!returnValue.getSucceeded()) {
            auditLogDirector.log(this, AuditLogType.USER_FAILED_HOTPLUG_DISK);
        }
    }
}
#method_after
private void plugDiskToVmIfNeeded() {
    if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm()) && getVm() != null && getVm().getStatus() != VMStatus.Down) {
        VmDiskOperationParameterBase params = new VmDiskOperationParameterBase(new DiskVmElement(getParameters().getDiskInfo().getId(), getVmId()));
        params.setShouldBeLogged(false);
        ActionReturnValue returnValue = runInternalAction(ActionType.HotPlugDiskToVm, params);
        if (!returnValue.getSucceeded()) {
            auditLogDirector.log(this, AuditLogType.USER_FAILED_HOTPLUG_DISK);
        }
    }
}
#end_block

#method_before
protected Map<Guid, Guid> addAllTemplateDisks() {
    VdcReturnValueBase returnValue = runInternalAction(getAddAllTemplateDisksActionType(), buildCreateAllTemplateDisksParameters(), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
    }
    return returnValue.getActionReturnValue();
}
#method_after
protected Map<Guid, Guid> addAllTemplateDisks() {
    ActionReturnValue returnValue = runInternalAction(getAddAllTemplateDisksActionType(), buildCreateAllTemplateDisksParameters(), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
    }
    return returnValue.getActionReturnValue();
}
#end_block

#method_before
protected VdcActionType getAddAllTemplateDisksActionType() {
    return VdcActionType.CreateAllTemplateDisks;
}
#method_after
protected ActionType getAddAllTemplateDisksActionType() {
    return ActionType.CreateAllTemplateDisks;
}
#end_block

#method_before
private void addGraphicsDevice() {
    for (GraphicsDevice graphicsDevice : getParameters().getGraphicsDevices().values()) {
        if (graphicsDevice == null) {
            continue;
        }
        graphicsDevice.setVmId(getVmTemplateId());
        GraphicsParameters parameters = new GraphicsParameters(graphicsDevice).setVm(false);
        getBackend().runInternalAction(VdcActionType.AddGraphicsDevice, parameters);
    }
}
#method_after
private void addGraphicsDevice() {
    for (GraphicsDevice graphicsDevice : getParameters().getGraphicsDevices().values()) {
        if (graphicsDevice == null) {
            continue;
        }
        graphicsDevice.setVmId(getVmTemplateId());
        GraphicsParameters parameters = new GraphicsParameters(graphicsDevice).setVm(false);
        getBackend().runInternalAction(ActionType.AddGraphicsDevice, parameters);
    }
}
#end_block

#method_before
private void assignLegalAndShared(boolean legalAndShared) {
    VdcReturnValueBase returnValue = runInternalAction(VdcActionType.UpdateAllTemplateDisks, buildUpdateAllTemplateDisksParameters(legalAndShared), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
    }
}
#method_after
private void assignLegalAndShared(boolean legalAndShared) {
    ActionReturnValue returnValue = runInternalAction(ActionType.UpdateAllTemplateDisks, buildUpdateAllTemplateDisksParameters(legalAndShared), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
    }
}
#end_block

#method_before
private void sealVmTemplate() {
    VdcReturnValueBase returnValue = runInternalAction(VdcActionType.SealVmTemplate, buildSealVmTemplateParameters(), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
    }
}
#method_after
private void sealVmTemplate() {
    ActionReturnValue returnValue = runInternalAction(ActionType.SealVmTemplate, buildSealVmTemplateParameters(), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
    }
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    if (diskInfoDestinationMap != null && !diskInfoDestinationMap.isEmpty()) {
        Map<DiskImage, Guid> map = new HashMap<>();
        for (DiskImage diskImage : diskInfoDestinationMap.values()) {
            if (diskImage.getDiskStorageType() == DiskStorageType.IMAGE) {
                map.put(diskImage, diskImage.getStorageIds().get(0));
            }
        }
        return validate(diskProfileHelper.setAndValidateDiskProfiles(map, getCurrentUser()));
    }
    return true;
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    if (diskInfoDestinationMap != null && !diskInfoDestinationMap.isEmpty()) {
        Map<DiskImage, Guid> map = diskInfoDestinationMap.values().stream().filter(DisksFilter.ONLY_IMAGES).collect(Collectors.toMap(Function.identity(), d -> d.getStorageIds().get(0)));
        return validate(diskProfileHelper.setAndValidateDiskProfiles(map, getCurrentUser()));
    }
    return true;
}
#end_block

#method_before
private void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getParameters().getMasterVm().getMaxMemorySizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getThreadsPerCpu(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getClusterId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVdsList(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled(), getParameters().getMasterVm().getCpuProfileId(), getParameters().getMasterVm().getNumaTuneMode(), getParameters().getMasterVm().getAutoConverge(), getParameters().getMasterVm().getMigrateCompressed(), getParameters().getMasterVm().getUserDefinedProperties(), getParameters().getMasterVm().getPredefinedProperties(), getParameters().getMasterVm().getCustomProperties(), getParameters().getMasterVm().getCustomEmulatedMachine(), getParameters().getMasterVm().getCustomCpuName(), getParameters().getMasterVm().getSmallIconId(), getParameters().getMasterVm().getLargeIconId(), getParameters().getMasterVm().getNumOfIoThreads(), getParameters().getMasterVm().getConsoleDisconnectAction(), getParameters().getMasterVm().getCustomCompatibilityVersion(), getParameters().getMasterVm().getMigrationPolicyId(), null));
    updateVmIcons();
    vmTemplateDao.save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    vmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    vmHandler.addVmInitToDB(getVmTemplate());
}
#method_after
private void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getParameters().getMasterVm().getMaxMemorySizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getThreadsPerCpu(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getClusterId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVdsList(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled(), getParameters().getMasterVm().getCpuProfileId(), getParameters().getMasterVm().getNumaTuneMode(), getParameters().getMasterVm().getAutoConverge(), getParameters().getMasterVm().getMigrateCompressed(), getParameters().getMasterVm().getUserDefinedProperties(), getParameters().getMasterVm().getPredefinedProperties(), getParameters().getMasterVm().getCustomProperties(), getParameters().getMasterVm().getCustomEmulatedMachine(), getParameters().getMasterVm().getCustomCpuName(), getParameters().getMasterVm().getSmallIconId(), getParameters().getMasterVm().getLargeIconId(), getParameters().getMasterVm().getNumOfIoThreads(), getParameters().getMasterVm().getConsoleDisconnectAction(), getParameters().getMasterVm().getCustomCompatibilityVersion(), getParameters().getMasterVm().getMigrationPolicyId(), getParameters().getMasterVm().getLeaseStorageDomainId()));
    updateVmIcons();
    vmTemplateDao.save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    vmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    vmHandler.addVmInitToDB(getVmTemplate().getVmInit());
}
#end_block

#method_before
private void checkTrustedService() {
    if (getVm().isTrustedService() && !getVmTemplate().isTrustedService()) {
        auditLogDirector.log(this, AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getVm().isTrustedService() && getVmTemplate().isTrustedService()) {
        auditLogDirector.log(this, AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#method_after
private void checkTrustedService() {
    if (!isVmInDb) {
        return;
    }
    if (getVm().isTrustedService() && !getVmTemplate().isTrustedService()) {
        auditLogDirector.log(this, AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getVm().isTrustedService() && getVmTemplate().isTrustedService()) {
        auditLogDirector.log(this, AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("updateVmVersion")
public void updateVmVersion() {
    for (Guid vmId : vmDao.getVmIdsForVersionUpdate(getParameters().getBaseTemplateId())) {
        // if the job was removed, stop executing, we probably have new version creation going on
        if (!updateVmsJobIdMap.containsKey(getParameters().getBaseTemplateId())) {
            break;
        }
        UpdateVmVersionParameters params = new UpdateVmVersionParameters(vmId);
        params.setSessionId(getParameters().getSessionId());
        getBackend().runInternalAction(VdcActionType.UpdateVmVersion, params, cloneContextAndDetachFromParent());
    }
    updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
}
#method_after
@OnTimerMethodAnnotation("updateVmVersion")
public void updateVmVersion() {
    for (Guid vmId : vmDao.getVmIdsForVersionUpdate(getParameters().getBaseTemplateId())) {
        // if the job was removed, stop executing, we probably have new version creation going on
        if (!updateVmsJobIdMap.containsKey(getParameters().getBaseTemplateId())) {
            break;
        }
        UpdateVmVersionParameters params = new UpdateVmVersionParameters(vmId);
        params.setSessionId(getParameters().getSessionId());
        getBackend().runInternalAction(ActionType.UpdateVmVersion, params, cloneContextAndDetachFromParent());
    }
    updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (isVmInDb) {
                if (pendingAsyncTasks) {
                    return getSucceeded() ? AuditLogType.USER_ADD_VM_TEMPLATE : AuditLogType.USER_FAILED_ADD_VM_TEMPLATE;
                } else {
                    return getSucceeded() ? AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS : getAuditLogFailureType();
                }
            } else {
                return getSucceeded() ? AuditLogType.USER_ADD_VM_TEMPLATE_SUCCESS : AuditLogType.USER_ADD_VM_TEMPLATE_FAILURE;
            }
        case END_SUCCESS:
            return getSucceeded() ? AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS : getAuditLogFailureType();
        default:
            return getAuditLogFailureType();
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (isVmInDb) {
                if (pendingAsyncTasks) {
                    return getSucceeded() ? AuditLogType.USER_ADD_VM_TEMPLATE : AuditLogType.USER_FAILED_ADD_VM_TEMPLATE;
                } else {
                    return getSucceeded() ? AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS : getAuditLogFailureType();
                }
            } else {
                return getSucceeded() ? AuditLogType.USER_ADD_VM_TEMPLATE_SUCCESS : AuditLogType.USER_ADD_VM_TEMPLATE_FAILURE;
            }
        case END_SUCCESS:
            if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
                return getSucceeded() ? AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS : getAuditLogFailureType();
            }
            return AuditLogType.UNASSIGNED;
        default:
            return getAuditLogFailureType();
    }
}
#end_block

#method_before
@Override
public Map<String, String> getJobMessageProperties() {
    jobProperties.put("phase", getParameters().getPhase().name());
    return jobProperties;
}
#method_after
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        jobProperties.put("phase", getParameters().getPhase().name());
    }
    return jobProperties;
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    Map<String, Pair<String, String>> locks = new HashMap<>();
    if (isTemplateVersion()) {
        locks.put(getParameters().getBaseTemplateId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.TEMPLATE, EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_VERSION_IS_BEING_CREATED));
    }
    locks.put(getParameters().getVm().getId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_BEING_CREATED_FROM_VM));
    return locks;
}
#method_after
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    Map<String, Pair<String, String>> locks = new HashMap<>();
    if (isTemplateVersion()) {
        locks.put(getParameters().getBaseTemplateId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.TEMPLATE, EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_VERSION_IS_BEING_CREATED));
    }
    if (!Guid.isNullOrEmpty(getParameters().getVm().getId())) {
        locks.put(getParameters().getVm().getId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_BEING_CREATED_FROM_VM));
    }
    return locks;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    if (multiLevelAdministrationHandler.isAdminUser(getUser())) {
        List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getParameters().getId(), VmDeviceGeneralType.DISK);
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                VmPayload payload = new VmPayload(disk);
                for (Map.Entry<String, String> entry : payload.getFiles().entrySet()) {
                    entry.setValue(new String(Base64.decodeBase64(entry.getValue())));
                }
                getQueryReturnValue().setReturnValue(payload);
            }
        }
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    if (multiLevelAdministrationHandler.isAdminUser(getUser())) {
        List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getParameters().getId(), VmDeviceGeneralType.DISK);
        for (VmDevice disk : disks) {
            if (disk.isManaged() && VmPayload.isPayload(disk.getSpecParams())) {
                VmPayload payload = new VmPayload(disk);
                for (Map.Entry<String, String> entry : payload.getFiles().entrySet()) {
                    entry.setValue(new String(Base64.decodeBase64(entry.getValue())));
                }
                getQueryReturnValue().setReturnValue(payload);
            }
        }
    }
}
#end_block

#method_before
private DbUser addUser(DbUser dbUser) {
    // Try to add the user with the external id:
    if (dbUser.getDomain() != null && dbUser.getExternalId() != null) {
        AddUserParameters parameters = new AddUserParameters(dbUser);
        VdcReturnValueBase result = runInternalAction(VdcActionType.AddUser, parameters, cloneContextAndDetachFromParent());
        if (result.getSucceeded()) {
            Guid id = result.getActionReturnValue();
            if (id != null) {
                return dbUserDao.get(id);
            }
            return null;
        }
    }
    // There is no such user in the directory:
    return null;
}
#method_after
private DbUser addUser(DbUser dbUser) {
    // Try to add the user with the external id:
    if (dbUser.getDomain() != null && dbUser.getExternalId() != null) {
        AddUserParameters parameters = new AddUserParameters(dbUser);
        ActionReturnValue result = runInternalAction(ActionType.AddUser, parameters, cloneContextAndDetachFromParent());
        if (result.getSucceeded()) {
            Guid id = result.getActionReturnValue();
            if (id != null) {
                return dbUserDao.get(id);
            }
            return null;
        }
    }
    // There is no such user in the directory:
    return null;
}
#end_block

#method_before
private DbGroup addGroup(DbGroup groupToAdd) {
    // Try to add the user with the external id:
    if (groupToAdd.getDomain() != null && groupToAdd.getExternalId() != null) {
        AddGroupParameters parameters = new AddGroupParameters(groupToAdd);
        VdcReturnValueBase result = runInternalAction(VdcActionType.AddGroup, parameters, cloneContextAndDetachFromParent());
        if (result.getSucceeded()) {
            Guid id = result.getActionReturnValue();
            if (id != null) {
                return dbGroupDao.get(id);
            }
            return null;
        }
    }
    // There is no such group in the directory:
    return null;
}
#method_after
private DbGroup addGroup(DbGroup groupToAdd) {
    // Try to add the user with the external id:
    if (groupToAdd.getDomain() != null && groupToAdd.getExternalId() != null) {
        AddGroupParameters parameters = new AddGroupParameters(groupToAdd);
        ActionReturnValue result = runInternalAction(ActionType.AddGroup, parameters, cloneContextAndDetachFromParent());
        if (result.getSucceeded()) {
            Guid id = result.getActionReturnValue();
            if (id != null) {
                return dbGroupDao.get(id);
            }
            return null;
        }
    }
    // There is no such group in the directory:
    return null;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    if (!isDisksVolumeFormatValid()) {
        return false;
    }
    Version customCompatibilityVersionFromParams = getParameters().getVmStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // check if the OS type is supported
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!validate(VmValidator.validateCpuSockets(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && vmStaticDao.get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!getParameters().getVmStaticData().isAutoStartup()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED_WITH_HA_OFF);
        }
        if (!FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED);
        }
        if (!validateLeaseStorageDomain(getParameters().getVmStaticData().getLeaseStorageDomainId())) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    if (!isDisksVolumeFormatValid()) {
        return false;
    }
    Version customCompatibilityVersionFromParams = getParameters().getVmStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // check if the OS type is supported
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!validate(VmValidator.validateCpuSockets(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && vmStaticDao.get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData()) && !canAddLease()) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean checkTemplateImages(List<String> reasons) {
    if (getParameters().getParentCommand() == VdcActionType.AddVmPool) {
        return true;
    }
    for (StorageDomain storage : destStorages.values()) {
        if (!validate(vmTemplateHandler.isVmTemplateImagesReady(vmDisksSource, storage.getId(), false, false, true, true, storageToDisksMap.get(storage.getId())))) {
            return false;
        }
    }
    return true;
}
#method_after
protected boolean checkTemplateImages(List<String> reasons) {
    if (getParameters().getParentCommand() == ActionType.AddVmPool) {
        return true;
    }
    for (StorageDomain storage : destStorages.values()) {
        if (!validate(vmTemplateHandler.isVmTemplateImagesReady(vmDisksSource, storage.getId(), false, false, true, true, storageToDisksMap.get(storage.getId())))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private DiskImage makeNewImage(Guid storageId, DiskImage image) {
    DiskImage newImage = new DiskImage();
    newImage.setImageId(image.getImageId());
    newImage.setDiskAlias(image.getDiskAlias());
    newImage.setVolumeFormat(image.getVolumeFormat());
    newImage.setVolumeType(image.getVolumeType());
    ArrayList<Guid> storageIds = new ArrayList<>();
    storageIds.add(storageId);
    newImage.setStorageIds(storageIds);
    newImage.setQuotaId(image.getQuotaId());
    newImage.setDiskProfileId(image.getDiskProfileId());
    return newImage;
}
#method_after
private DiskImage makeNewImage(Guid storageId, DiskImage image) {
    DiskImage newImage = new DiskImage();
    newImage.setImageId(image.getImageId());
    newImage.setDiskAlias(image.getDiskAlias());
    newImage.setVolumeFormat(image.getVolumeFormat());
    newImage.setVolumeType(image.getVolumeType());
    ArrayList<Guid> storageIds = new ArrayList<>();
    storageIds.add(storageId);
    newImage.setStorageIds(storageIds);
    newImage.setQuotaId(image.getQuotaId());
    // Find out the correct disk profile for storage domain
    newImage.setDiskProfileId(diskProfileDao.getAllForStorageDomain(storageId).stream().filter(p -> image.getDiskProfileIds().contains(p.getId())).findFirst().map(p -> p.getId()).orElse(null));
    return newImage;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    List<String> errorMessages = new ArrayList<>();
    if (!canAddVm(errorMessages, destStorages.values())) {
        log.error("Failed to add VM. The reasons are: {}", String.join(",", errorMessages));
        return;
    }
    if (!addVmLease(getParameters().getVm().getLeaseStorageDomainId(), getVmId())) {
        return;
    }
    TransactionSupport.executeInNewTransaction(() -> {
        addVmStatic();
        addVmDynamic();
        addVmNetwork();
        addVmNumaNodes();
        addVmStatistics();
        addActiveSnapshot();
        addVmPermission();
        addVmInit();
        addVmRngDevice();
        getCompensationContext().stateChanged();
        return null;
    });
    if (addVmImages()) {
        TransactionSupport.executeInNewTransaction(() -> {
            copyDiskVmElements();
            copyVmDevices();
            addDiskPermissions();
            addVmPayload();
            updateSmartCardDevices();
            addVmWatchdog();
            addGraphicsDevice();
            getVmDeviceUtils().updateVirtioScsiController(getVm().getStaticData(), getParameters().isVirtioScsiEnabled());
            setActionReturnValue(getVm().getId());
            setSucceeded(true);
            return null;
        });
    }
    if (getParameters().getPoolId() != null) {
        addVmToPool();
    }
    discardHelper.logIfDisksWithIllegalPassDiscardExist(getVmId());
}
#method_after
@Override
protected void executeVmCommand() {
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    List<String> errorMessages = new ArrayList<>();
    if (!canAddVm(errorMessages, destStorages.values())) {
        log.error("Failed to add VM. The reasons are: {}", String.join(",", errorMessages));
        return;
    }
    if (!addVmLease(getParameters().getVm().getLeaseStorageDomainId(), getVmId())) {
        return;
    }
    TransactionSupport.executeInNewTransaction(() -> {
        addVmStatic();
        addVmDynamic();
        addVmNetwork();
        addVmNumaNodes();
        addVmStatistics();
        addActiveSnapshot();
        addVmPermission();
        addVmInit();
        addVmRngDevice();
        addAffinityLabels();
        getCompensationContext().stateChanged();
        return null;
    });
    if (addVmImages()) {
        TransactionSupport.executeInNewTransaction(() -> {
            copyDiskVmElements();
            copyVmDevices();
            addDiskPermissions();
            addVmPayload();
            updateSmartCardDevices();
            addVmWatchdog();
            addGraphicsDevice();
            getVmDeviceUtils().updateVirtioScsiController(getVm().getStaticData(), getParameters().isVirtioScsiEnabled());
            setActionReturnValue(getVm().getId());
            setSucceeded(true);
            return null;
        });
    }
    if (getParameters().getPoolId() != null) {
        addVmToPool();
    }
    discardHelper.logIfDisksWithIllegalPassDiscardExist(getVmId());
}
#end_block

#method_before
private void addGraphicsDevice() {
    for (GraphicsDevice graphicsDevice : getParameters().getGraphicsDevices().values()) {
        if (graphicsDevice == null) {
            continue;
        }
        graphicsDevice.setVmId(getVmId());
        getBackend().runInternalAction(VdcActionType.AddGraphicsDevice, new GraphicsParameters(graphicsDevice));
    }
}
#method_after
private void addGraphicsDevice() {
    for (GraphicsDevice graphicsDevice : getParameters().getGraphicsDevices().values()) {
        if (graphicsDevice == null) {
            continue;
        }
        graphicsDevice.setVmId(getVmId());
        getBackend().runInternalAction(ActionType.AddGraphicsDevice, new GraphicsParameters(graphicsDevice));
    }
}
#end_block

#method_before
private void addVmWatchdog() {
    VmWatchdog vmWatchdog = getParameters().getWatchdog();
    if (vmWatchdog != null) {
        VdcActionType actionType = getVmDeviceUtils().hasWatchdog(getVmTemplateId()) ? VdcActionType.UpdateWatchdog : VdcActionType.AddWatchdog;
        runInternalAction(actionType, buildWatchdogParameters(vmWatchdog), cloneContextAndDetachFromParent());
    }
}
#method_after
private void addVmWatchdog() {
    VmWatchdog vmWatchdog = getParameters().getWatchdog();
    if (vmWatchdog != null) {
        ActionType actionType = getVmDeviceUtils().hasWatchdog(getVmTemplateId()) ? ActionType.UpdateWatchdog : ActionType.AddWatchdog;
        runInternalAction(actionType, buildWatchdogParameters(vmWatchdog), cloneContextAndDetachFromParent());
    }
}
#end_block

#method_before
private void addVmRngDevice() {
    VmRngDevice rngDev = getParameters().getRngDevice();
    if (rngDev != null) {
        rngDev.setVmId(getVmId());
        RngDeviceParameters params = new RngDeviceParameters(rngDev, true);
        VdcReturnValueBase result = runInternalAction(VdcActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            log.error("Couldn't add RNG device for new VM.");
            throw new IllegalArgumentException("Couldn't add RNG device for new VM.");
        }
    }
}
#method_after
private void addVmRngDevice() {
    VmRngDevice rngDev = getParameters().getRngDevice();
    if (rngDev != null) {
        rngDev.setVmId(getVmId());
        RngDeviceParameters params = new RngDeviceParameters(rngDev, true);
        ActionReturnValue result = runInternalAction(ActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            log.error("Couldn't add RNG device for new VM.");
            throw new IllegalArgumentException("Couldn't add RNG device for new VM.");
        }
    }
}
#end_block

#method_before
private void copyDiskDevicesFromTemplate() {
    List<VmDevice> disks = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmDisksSource.getId(), VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName());
    getVmDeviceUtils().copyDiskDevices(getVmId(), disks, getSrcDeviceIdToTargetDeviceIdMapping());
}
#method_after
private void copyDiskDevicesFromTemplate() {
    List<VmDevice> disks = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmDisksSource.getId(), VmDeviceGeneralType.DISK, VmDeviceType.DISK);
    getVmDeviceUtils().copyDiskDevices(getVmId(), disks, getSrcDeviceIdToTargetDeviceIdMapping());
}
#end_block

#method_before
private void addVmNumaNodes() {
    List<VmNumaNode> numaNodes = getParameters().getVm().getvNumaNodeList();
    if (numaNodes.isEmpty()) {
        return;
    }
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getParameters().getVm(), numaNodes);
    VdcReturnValueBase returnValueBase = getBackend().runInternalAction(VdcActionType.AddVmNumaNodes, params);
    if (!returnValueBase.getSucceeded()) {
        auditLogDirector.log(this, AuditLogType.NUMA_ADD_VM_NUMA_NODE_FAILED);
    }
}
#method_after
private void addVmNumaNodes() {
    List<VmNumaNode> numaNodes = getParameters().getVm().getvNumaNodeList();
    if (numaNodes.isEmpty()) {
        return;
    }
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getParameters().getVm(), numaNodes);
    ActionReturnValue returnValueBase = getBackend().runInternalAction(ActionType.AddVmNumaNodes, params);
    if (!returnValueBase.getSucceeded()) {
        auditLogDirector.log(this, AuditLogType.NUMA_ADD_VM_NUMA_NODE_FAILED);
    }
}
#end_block

#method_before
private void addVmInit() {
    vmHandler.addVmInitToDB(getParameters().getVmStaticData());
}
#method_after
private void addVmInit() {
    final VmInit vmInit = getParameters().getVmStaticData().getVmInit();
    if (vmInit == null) {
        return;
    }
    if (vmInit.isPasswordAlreadyStored()) {
        final VmInit templateVmInit = vmInitDao.get(getVmTemplateId());
        vmInit.setPasswordAlreadyStored(false);
        vmInit.setRootPassword(templateVmInit.getRootPassword());
    }
    vmHandler.addVmInitToDB(vmInit);
}
#end_block

#method_before
protected boolean addVmImages() {
    if (!vmDisksSource.getDiskTemplateMap().isEmpty()) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        lockVM();
        Collection<DiskImage> templateDisks = getImagesToCheckDestinationStorageDomains();
        List<DiskImage> diskImages = DisksFilter.filterImageDisks(templateDisks, ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
        for (DiskImage image : diskImages) {
            VdcReturnValueBase result = runInternalActionWithTasksContext(getDiskCreationCommandType(), buildDiskCreationParameters(image));
            // if couldn't create snapshot then stop the transaction and the command
            if (!result.getSucceeded()) {
                throw new EngineException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(image.getId(), newImage.getId());
            }
        }
        // Clone volumes for Cinder disk templates
        addVmCinderDisks(templateDisks);
    }
    return true;
}
#method_after
protected boolean addVmImages() {
    if (!vmDisksSource.getDiskTemplateMap().isEmpty()) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        lockVM();
        Collection<DiskImage> templateDisks = getImagesToCheckDestinationStorageDomains();
        List<DiskImage> diskImages = DisksFilter.filterImageDisks(templateDisks, ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
        for (DiskImage image : diskImages) {
            ActionReturnValue result = runInternalActionWithTasksContext(getDiskCreationCommandType(), buildDiskCreationParameters(image));
            // if couldn't create snapshot then stop the transaction and the command
            if (!result.getSucceeded()) {
                throw new EngineException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(image.getId(), newImage.getId());
            }
        }
        // Clone volumes for Cinder disk templates
        addVmCinderDisks(templateDisks);
    }
    return true;
}
#end_block

#method_before
protected VdcActionType getDiskCreationCommandType() {
    return VdcActionType.CreateSnapshotFromTemplate;
}
#method_after
protected ActionType getDiskCreationCommandType() {
    return ActionType.CreateSnapshotFromTemplate;
}
#end_block

#method_before
protected CreateSnapshotFromTemplateParameters buildDiskCreationParameters(DiskImage image) {
    CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(image.getImageId(), getParameters().getVmStaticData().getId());
    tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(image.getId()).getStorageIds().get(0));
    tempVar.setDiskAlias(diskInfoDestinationMap.get(image.getId()).getDiskAlias());
    tempVar.setStorageDomainId(image.getStorageIds().get(0));
    tempVar.setVmSnapshotId(getVmSnapshotId());
    tempVar.setParentCommand(VdcActionType.AddVm);
    tempVar.setEntityInfo(getParameters().getEntityInfo());
    tempVar.setParentParameters(getParameters());
    tempVar.setQuotaId(diskInfoDestinationMap.get(image.getId()).getQuotaId());
    tempVar.setDiskProfileId(diskInfoDestinationMap.get(image.getId()).getDiskProfileId());
    return tempVar;
}
#method_after
protected CreateSnapshotFromTemplateParameters buildDiskCreationParameters(DiskImage image) {
    CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(image.getImageId(), getParameters().getVmStaticData().getId());
    tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(image.getId()).getStorageIds().get(0));
    tempVar.setDiskAlias(diskInfoDestinationMap.get(image.getId()).getDiskAlias());
    tempVar.setStorageDomainId(image.getStorageIds().get(0));
    tempVar.setVmSnapshotId(getVmSnapshotId());
    tempVar.setParentCommand(ActionType.AddVm);
    tempVar.setEntityInfo(getParameters().getEntityInfo());
    tempVar.setParentParameters(getParameters());
    tempVar.setQuotaId(diskInfoDestinationMap.get(image.getId()).getQuotaId());
    tempVar.setDiskProfileId(diskInfoDestinationMap.get(image.getId()).getDiskProfileId());
    return tempVar;
}
#end_block

#method_before
protected void addVmCinderDisks(Collection<DiskImage> templateDisks) {
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(templateDisks);
    if (cinderDisks.isEmpty()) {
        return;
    }
    Map<Guid, Guid> diskImageMap = new HashMap<>();
    for (CinderDisk cinderDisk : cinderDisks) {
        ImagesContainterParametersBase params = buildCloneCinderDiskCommandParameters(cinderDisk);
        VdcReturnValueBase vdcReturnValueBase = runInternalAction(VdcActionType.CloneSingleCinderDisk, params, cloneContext().withoutExecutionContext().withoutLock());
        if (!vdcReturnValueBase.getSucceeded()) {
            log.error("Error cloning Cinder disk '{}': {}", cinderDisk.getDiskAlias());
            getReturnValue().setFault(vdcReturnValueBase.getFault());
            return;
        }
        Guid imageId = vdcReturnValueBase.getActionReturnValue();
        diskImageMap.put(cinderDisk.getId(), imageId);
    }
    srcDiskIdToTargetDiskIdMapping.putAll(diskImageMap);
}
#method_after
protected void addVmCinderDisks(Collection<DiskImage> templateDisks) {
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(templateDisks);
    if (cinderDisks.isEmpty()) {
        return;
    }
    Map<Guid, Guid> diskImageMap = new HashMap<>();
    for (CinderDisk cinderDisk : cinderDisks) {
        ImagesContainterParametersBase params = buildCloneCinderDiskCommandParameters(cinderDisk);
        ActionReturnValue actionReturnValue = runInternalAction(ActionType.CloneSingleCinderDisk, params, cloneContext().withoutExecutionContext().withoutLock());
        if (!actionReturnValue.getSucceeded()) {
            log.error("Error cloning Cinder disk '{}': {}", cinderDisk.getDiskAlias());
            getReturnValue().setFault(actionReturnValue.getFault());
            return;
        }
        Guid imageId = actionReturnValue.getActionReturnValue();
        diskImageMap.put(cinderDisk.getId(), imageId);
    }
    srcDiskIdToTargetDiskIdMapping.putAll(diskImageMap);
}
#end_block

#method_before
private void addVmToPool() {
    AddVmToPoolParameters parameters = new AddVmToPoolParameters(getParameters().getPoolId(), getVmId());
    parameters.setShouldBeLogged(false);
    VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.AddVmToPool, parameters);
    setSucceeded(result.getSucceeded());
    if (!result.getSucceeded()) {
        log.error("Error adding VM {} to Pool {}", getVmId(), getParameters().getPoolId());
        getReturnValue().setFault(result.getFault());
        return;
    }
    addVmPermission();
}
#method_after
private void addVmToPool() {
    AddVmToPoolParameters parameters = new AddVmToPoolParameters(getParameters().getPoolId(), getVmId());
    parameters.setShouldBeLogged(false);
    ActionReturnValue result = runInternalActionWithTasksContext(ActionType.AddVmToPool, parameters);
    setSucceeded(result.getSucceeded());
    if (!result.getSucceeded()) {
        log.error("Error adding VM {} to Pool {}", getVmId(), getParameters().getPoolId());
        getReturnValue().setFault(result.getFault());
        return;
    }
    addVmPermission();
}
#end_block

#method_before
@Override
protected VdcActionType getChildActionType() {
    return VdcActionType.CreateSnapshotFromTemplate;
}
#method_after
@Override
protected ActionType getChildActionType() {
    return ActionType.CreateSnapshotFromTemplate;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // Get the identifier of the group from the parameters:
    Guid id = getParameters().getId();
    // TODO: This should be done without invoking the command to avoid the overhead.
    for (Permission permission : permissionDao.getAllDirectPermissionsForAdElement(id)) {
        PermissionsOperationsParameters param = new PermissionsOperationsParameters(permission);
        param.setSessionId(getParameters().getSessionId());
        runInternalActionWithTasksContext(VdcActionType.RemovePermission, param);
    }
    // Remove the group itself:
    dbGroupDao.remove(id);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // Get the identifier of the group from the parameters:
    Guid id = getParameters().getId();
    // TODO: This should be done without invoking the command to avoid the overhead.
    for (Permission permission : permissionDao.getAllDirectPermissionsForAdElement(id)) {
        PermissionsOperationsParameters param = new PermissionsOperationsParameters(permission);
        param.setSessionId(getParameters().getSessionId());
        runInternalActionWithTasksContext(ActionType.RemovePermission, param);
    }
    // Remove the group itself:
    dbGroupDao.remove(id);
    setSucceeded(true);
}
#end_block

#method_before
private void removeNetworkFromHosts(Network network, CommandContext context, List<VdsNetworkInterface> nics) {
    ArrayList<VdcActionParametersBase> parameters = removeNetworkParametersBuilder.buildParameters(network, nics);
    if (!parameters.isEmpty()) {
        HostSetupNetworksParametersBuilder.updateParametersSequencing(parameters);
        backend.runInternalMultipleActions(VdcActionType.PersistentHostSetupNetworks, parameters, context);
    }
}
#method_after
private void removeNetworkFromHosts(Network network, CommandContext context, List<VdsNetworkInterface> nics) {
    ArrayList<ActionParametersBase> parameters = removeNetworkParametersBuilder.buildParameters(network, nics);
    if (!parameters.isEmpty()) {
        HostSetupNetworksParametersBuilder.updateParametersSequencing(parameters);
        backend.runInternalMultipleActions(ActionType.PersistentHostSetupNetworks, parameters, context);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    ImagesHandler.updateAllDiskImagesSnapshotsStatusInTransactionWithCompensation(getMovedDiskIds(), ImageStatus.LOCKED, ImageStatus.OK, getCompensationContext());
    VdcReturnValueBase vdcReturnValue = runInternalAction(ActionType.CreateAllSnapshotsFromVm, getCreateSnapshotParameters(), ExecutionHandler.createInternalJobContext(getContext()));
    getParameters().setAutoGeneratedSnapshotId(vdcReturnValue.getActionReturnValue());
    persistCommand(getParameters().getParentCommand(), getCallback() != null);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    imagesHandler.updateAllDiskImagesSnapshotsStatusInTransactionWithCompensation(getMovedDiskIds(), ImageStatus.LOCKED, ImageStatus.OK, getCompensationContext());
    ActionReturnValue actionReturnValueurnValue = runInternalAction(ActionType.CreateAllSnapshotsFromVm, getCreateSnapshotParameters(), ExecutionHandler.createInternalJobContext(getContext()));
    getParameters().setAutoGeneratedSnapshotId(actionReturnValueurnValue.getActionReturnValue());
    persistCommand(getParameters().getParentCommand(), getCallback() != null);
    setSucceeded(true);
}
#end_block

#method_before
@Override
public boolean performNextOperation(int completedChildCount) {
    if (getParameters().getStage() == LiveMigrateStage.CREATE_SNAPSHOT) {
        updateStage(LiveMigrateStage.LIVE_MIGRATE_DISK_EXEC_START);
        for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
            parameters.setSessionId(getParameters().getSessionId());
            parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
            parameters.setParentCommand(getActionType());
            parameters.setParentParameters(getParameters());
            parameters.setDestinationImageId(((DiskImage) getDiskImageByDiskId(parameters.getImageGroupID())).getImageId());
            VdcReturnValueBase vdcReturnValue = runInternalAction(ActionType.LiveMigrateDisk, parameters, ExecutionHandler.createInternalJobContext());
            if (!vdcReturnValue.getSucceeded()) {
                imageDao.updateStatusOfImagesByImageGroupId(parameters.getImageGroupID(), ImageStatus.OK);
            }
        }
        updateStage(LiveMigrateStage.LIVE_MIGRATE_DISK_EXEC_COMPLETED);
        return true;
    }
    if (isRemoveAutoGeneratedSnapshotRequired()) {
        updateStage(LiveMigrateStage.AUTO_GENERATED_SNAPSHOT_REMOVE_START);
        removeAutogeneratedSnapshot();
        updateStage(LiveMigrateStage.AUTO_GENERATED_SNAPSHOT_REMOVE_END);
        return true;
    }
    return false;
}
#method_after
@Override
public boolean performNextOperation(int completedChildCount) {
    if (getParameters().getStage() == LiveMigrateStage.CREATE_SNAPSHOT) {
        updateStage(LiveMigrateStage.LIVE_MIGRATE_DISK_EXEC_START);
        for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
            parameters.setSessionId(getParameters().getSessionId());
            parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
            parameters.setParentCommand(getActionType());
            parameters.setParentParameters(getParameters());
            parameters.setDestinationImageId(((DiskImage) getDiskImageByDiskId(parameters.getImageGroupID())).getImageId());
            ActionReturnValue actionReturnValue = runInternalAction(ActionType.LiveMigrateDisk, parameters, ExecutionHandler.createInternalJobContext());
            if (!actionReturnValue.getSucceeded()) {
                imageDao.updateStatusOfImagesByImageGroupId(parameters.getImageGroupID(), ImageStatus.OK);
            }
        }
        updateStage(LiveMigrateStage.LIVE_MIGRATE_DISK_EXEC_COMPLETED);
        return true;
    }
    if (isRemoveAutoGeneratedSnapshotRequired()) {
        updateStage(LiveMigrateStage.AUTO_GENERATED_SNAPSHOT_REMOVE_START);
        removeAutogeneratedSnapshot();
        updateStage(LiveMigrateStage.AUTO_GENERATED_SNAPSHOT_REMOVE_END);
        return true;
    }
    return false;
}
#end_block

#method_before
protected boolean isDiskSnapshotNotPluggedToOtherVmsThatAreNotDown(Guid imageId) {
    return validate(createDiskValidator(getDiskImageByImageId(imageId)).isDiskPluggedToVmsThatAreNotDown(true, null));
}
#method_after
protected boolean isDiskSnapshotNotPluggedToOtherVmsThatAreNotDown(Guid imageId) {
    return validate(createDiskValidator(getDiskImageByImageId(imageId)).isDiskPluggedToAnyNonDownVm(true));
}
#end_block

#method_before
protected boolean validateCreateAllSnapshotsFromVmCommand() {
    VdcReturnValueBase returnValue = CommandHelper.validate(ActionType.CreateAllSnapshotsFromVm, getCreateSnapshotParameters(), getContext().clone());
    if (!returnValue.isValid()) {
        getReturnValue().setValidationMessages(returnValue.getValidationMessages());
        return false;
    }
    return true;
}
#method_after
protected boolean validateCreateAllSnapshotsFromVmCommand() {
    ActionReturnValue returnValue = CommandHelper.validate(ActionType.CreateAllSnapshotsFromVm, getCreateSnapshotParameters(), getContext().clone());
    if (!returnValue.isValid()) {
        getReturnValue().setValidationMessages(returnValue.getValidationMessages());
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public void endWithFailure() {
    if (getParameters().getStage() == LiveMigrateStage.CREATE_SNAPSHOT) {
        ImagesHandler.updateAllDiskImagesSnapshotsStatusInTransactionWithCompensation(getMovedDiskIds(), ImageStatus.OK, ImageStatus.OK, getCompensationContext());
    }
    setSucceeded(true);
}
#method_after
@Override
public void endWithFailure() {
    if (getParameters().getStage() == LiveMigrateStage.CREATE_SNAPSHOT) {
        imagesHandler.updateAllDiskImagesSnapshotsStatusInTransactionWithCompensation(getMovedDiskIds(), ImageStatus.OK, ImageStatus.OK, getCompensationContext());
    }
    setSucceeded(true);
}
#end_block

#method_before
protected void initializeCommand(DiskImage disk, VmEntityType vmEntityType) {
    disk.setVmEntityType(vmEntityType);
    when(diskImageDao.get(any())).thenReturn(disk);
    initializeCommand(disk);
}
#method_after
protected void initializeCommand(DiskImage disk, VmEntityType vmEntityType) {
    disk.setVmEntityType(vmEntityType);
    when(diskDao.get(any())).thenReturn(disk);
    when(diskImageDao.get(any())).thenReturn(disk);
    VM vm = new VM();
    vm.setStatus(VMStatus.Down);
    when(vmDao.get(any())).thenReturn(vm);
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator();
    doReturn(multipleDiskVmElementValidator).when(command).createMultipleDiskVmElementValidator();
    doReturn(diskValidator).when(command).createDiskValidator(disk);
    doReturn(true).when(command).setAndValidateDiskProfiles();
    doReturn(disk.getId()).when(command).getImageGroupId();
    doReturn(ActionType.MoveOrCopyDisk).when(command).getActionType();
    command.init();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (isUnregisteredDiskExistsForCopyTemplate()) {
        addDiskMapping();
        return;
    }
    MoveOrCopyImageGroupParameters p = prepareChildParameters();
    ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(getImagesActionType(), p);
    if (!vdcRetValue.getSucceeded()) {
        setSucceeded(false);
        getReturnValue().setFault(vdcRetValue.getFault());
    } else {
        setSucceeded(true);
        if (isCopyOperation() && !isTemplate()) {
            ImagesHandler.addDiskImageWithNoVmDevice(getImage());
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    if (isUnregisteredDiskExistsForCopyTemplate()) {
        addDiskMapping();
        return;
    }
    MoveOrCopyImageGroupParameters p = prepareChildParameters();
    ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(getImagesActionType(), p);
    if (!vdcRetValue.getSucceeded()) {
        setSucceeded(false);
        getReturnValue().setFault(vdcRetValue.getFault());
    } else {
        setSucceeded(true);
        if (isCopyOperation() && !isTemplate()) {
            imagesHandler.addDiskImageWithNoVmDevice(getImage());
        }
    }
}
#end_block

#method_before
public void removeLunDisk(LunDisk lunDisk) {
    vmDeviceDao.remove(new VmDeviceId(lunDisk.getId(), null));
    LUNs lun = lunDisk.getLun();
    diskLunMapDao.remove(new DiskLunMapId(lunDisk.getId(), lun.getLUNId()));
    baseDiskDao.remove(lunDisk.getId());
    lun.setLunConnections(new ArrayList<>(storageServerConnectionDao.getAllForLun(lun.getLUNId())));
    if (!lun.getLunConnections().isEmpty()) {
        StorageHelperDirector.getInstance().getItem(lun.getLunConnections().get(0).getStorageType()).removeLun(lun);
    } else {
        // if there are no connections then the lun is fcp.
        StorageHelperDirector.getInstance().getItem(StorageType.FCP).removeLun(lun);
    }
}
#method_after
public void removeLunDisk(LunDisk lunDisk) {
    vmDeviceDao.remove(new VmDeviceId(lunDisk.getId(), null));
    LUNs lun = lunDisk.getLun();
    diskLunMapDao.remove(new DiskLunMapId(lunDisk.getId(), lun.getLUNId()));
    baseDiskDao.remove(lunDisk.getId());
    lun.setLunConnections(new ArrayList<>(storageServerConnectionDao.getAllForLun(lun.getLUNId())));
    if (!lun.getLunConnections().isEmpty()) {
        storageHelperDirector.getItem(lun.getLunConnections().get(0).getStorageType()).removeLun(lun);
    } else {
        // if there are no connections then the lun is fcp.
        storageHelperDirector.getItem(StorageType.FCP).removeLun(lun);
    }
}
#end_block

#method_before
private boolean isStorageDomainAttachedToStoragePool(StorageDomain storageDomain) {
    List<StorageDomain> storageDomainList = getBackend().runInternalQuery(VdcQueryType.GetStorageDomainsWithAttachedStoragePoolGuid, new StorageDomainsAndStoragePoolIdQueryParameters(storageDomain, getStoragePoolId(), getVds().getId(), false)).getReturnValue();
    return !storageDomainList.isEmpty();
}
#method_after
private boolean isStorageDomainAttachedToStoragePool(StorageDomain storageDomain) {
    List<StorageDomain> storageDomainList = getBackend().runInternalQuery(QueryType.GetStorageDomainsWithAttachedStoragePoolGuid, new StorageDomainsAndStoragePoolIdQueryParameters(storageDomain, getStoragePoolId(), getVds().getId(), false)).getReturnValue();
    return !storageDomainList.isEmpty();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    StorageDomain newMasterDomain = loadTargetedMasterDomain();
    if (storageHelperDirector.getItem(newMasterDomain.getStorageType()).connectStorageToDomainByVdsId(newMasterDomain, getVds().getId())) {
        getEventQueue().submitEventSync(new Event(getParameters().getStoragePoolId(), getParameters().getNewMasterDomainId(), null, EventType.RECOVERY, ""), () -> {
            getParameters().setStorageDomainId(getMasterDomainIdFromDb());
            StoragePoolIsoMap domainPoolMap = new StoragePoolIsoMap(getParameters().getNewMasterDomainId(), getParameters().getStoragePoolId(), StorageDomainStatus.Active);
            storagePoolIsoMapDao.save(domainPoolMap);
            getParameters().setVdsId(getVds().getId());
            VdcReturnValueBase returnVal = runInternalAction(ActionType.ReconstructMasterDomain, getParameters(), cloneContextAndDetachFromParent());
            boolean reconstructVerbExecuted = (returnVal.getActionReturnValue() != null) ? (Boolean) returnVal.getActionReturnValue() : false;
            storagePoolDao.updateStatus(getStoragePool().getId(), StoragePoolStatus.NonResponsive);
            if (!reconstructVerbExecuted) {
                storagePoolIsoMapDao.remove(domainPoolMap.getId());
            }
            if (returnVal.getSucceeded()) {
                updateStorageDomainFormatIfNeeded(loadTargetedMasterDomain());
            }
            setSucceeded(returnVal.getSucceeded());
            return new EventResult(reconstructVerbExecuted, EventType.RECONSTRUCT);
        });
    } else {
        getReturnValue().setFault(new EngineFault(new EngineException(EngineError.StorageServerConnectionError, "Failed to connect storage"), EngineError.StorageServerConnectionError));
    }
}
#method_after
@Override
protected void executeCommand() {
    StorageDomain newMasterDomain = loadTargetedMasterDomain();
    if (storageHelperDirector.getItem(newMasterDomain.getStorageType()).connectStorageToDomainByVdsId(newMasterDomain, getVds().getId())) {
        getEventQueue().submitEventSync(new Event(getParameters().getStoragePoolId(), getParameters().getNewMasterDomainId(), null, EventType.RECOVERY, ""), () -> {
            getParameters().setStorageDomainId(getMasterDomainIdFromDb());
            StoragePoolIsoMap domainPoolMap = new StoragePoolIsoMap(getParameters().getNewMasterDomainId(), getParameters().getStoragePoolId(), StorageDomainStatus.Active);
            storagePoolIsoMapDao.save(domainPoolMap);
            getParameters().setVdsId(getVds().getId());
            ActionReturnValue returnVal = runInternalAction(ActionType.ReconstructMasterDomain, getParameters(), cloneContextAndDetachFromParent());
            boolean reconstructVerbExecuted = (returnVal.getActionReturnValue() != null) ? (Boolean) returnVal.getActionReturnValue() : false;
            storagePoolDao.updateStatus(getStoragePool().getId(), StoragePoolStatus.NonResponsive);
            if (!reconstructVerbExecuted) {
                storagePoolIsoMapDao.remove(domainPoolMap.getId());
            }
            if (returnVal.getSucceeded()) {
                updateStorageDomainFormatIfNeeded(loadTargetedMasterDomain());
            }
            setSucceeded(returnVal.getSucceeded());
            return new EventResult(reconstructVerbExecuted, EventType.RECONSTRUCT);
        });
    } else {
        getReturnValue().setFault(new EngineFault(new EngineException(EngineError.StorageServerConnectionError, "Failed to connect storage"), EngineError.StorageServerConnectionError));
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate() || !initializeVds() || !checkStorageDomainNameLengthValid()) {
        return false;
    }
    if (isStorageWithSameNameExists()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NAME_ALREADY_EXIST);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ISO && !getStorageDomain().getStorageType().isFileDomain()) {
        addValidationMessageVariable("domainType", StorageConstants.ISO);
        addValidationMessageVariable("storageTypes", StorageConstants.FILE);
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DOMAIN_TYPE_CAN_BE_CREATED_ONLY_ON_SPECIFIC_STORAGE_DOMAINS);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ImportExport && getStorageDomain().getStorageType().isBlockDomain()) {
        addValidationMessageVariable("domainType", StorageConstants.EXPORT);
        addValidationMessageVariable("storageTypes", StorageConstants.FILE);
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DOMAIN_TYPE_CAN_BE_CREATED_ONLY_ON_SPECIFIC_STORAGE_DOMAINS);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (!Guid.isNullOrEmpty(getParameters().getStoragePoolId()) && getTargetStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    ensureStorageFormatInitialized();
    StorageDomainToPoolRelationValidator storageDomainToPoolRelationValidator = getAttachDomainValidator();
    StorageDomainValidator sdValidator = getStorageDomainValidator();
    if (!validate(storageDomainToPoolRelationValidator.isStorageDomainFormatCorrectForDC()) || !validate(sdValidator.isStorageFormatCompatibleWithDomain()) || !validateDiscardAfterDeleteLegal(sdValidator, getTargetStoragePool().getCompatibilityVersion())) {
        return false;
    }
    return canAddDomain();
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate() || !initializeVds() || !checkStorageDomainNameLengthValid()) {
        return false;
    }
    if (isStorageWithSameNameExists()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NAME_ALREADY_EXIST);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ISO && !getStorageDomain().getStorageType().isFileDomain()) {
        addValidationMessageVariable("domainType", StorageConstants.ISO);
        addValidationMessageVariable("storageTypes", StorageConstants.FILE);
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DOMAIN_TYPE_CAN_BE_CREATED_ONLY_ON_SPECIFIC_STORAGE_DOMAINS);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ImportExport && getStorageDomain().getStorageType().isBlockDomain()) {
        addValidationMessageVariable("domainType", StorageConstants.EXPORT);
        addValidationMessageVariable("storageTypes", StorageConstants.FILE);
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DOMAIN_TYPE_CAN_BE_CREATED_ONLY_ON_SPECIFIC_STORAGE_DOMAINS);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    ensureStorageFormatInitialized();
    StorageDomainValidator sdValidator = getStorageDomainValidator();
    if (!validate(sdValidator.isStorageFormatCompatibleWithDomain())) {
        return false;
    }
    initStorageDomainDiscardAfterDeleteIfNeeded();
    if (!validateDiscardAfterDeleteLegal(sdValidator)) {
        return false;
    }
    return canAddDomain();
}
#end_block

#method_before
private void ensureStorageFormatInitialized() {
    StorageDomain sd = getStorageDomain();
    if (sd.getStorageFormat() == null) {
        if (sd.getStorageDomainType().isDataDomain()) {
            StoragePool sp = getTargetStoragePool();
            if (sp != null) {
                sd.setStorageFormat(VersionStorageFormatUtil.getForVersion(sp.getCompatibilityVersion()));
            }
        } else {
            sd.setStorageFormat(StorageFormatType.V1);
        }
    }
}
#method_after
private void ensureStorageFormatInitialized() {
    StorageDomain sd = getStorageDomain();
    if (sd.getStorageFormat() == null) {
        if (sd.getStorageDomainType().isDataDomain()) {
            sd.setStorageFormat(StorageFormatType.getLatest());
        } else {
            sd.setStorageFormat(StorageFormatType.V1);
        }
    }
}
#end_block

#method_before
protected List<DiskImage> getAllOVFDisks(Guid storageDomainId, Guid storagePoolId) {
    // fetched yet.
    if (ovfDisks == null) {
        ovfDisks = new ArrayList<>();
        // Get all unregistered disks.
        List<DiskImage> disksFromStorage = getBackend().runInternalQuery(VdcQueryType.GetUnregisteredDisks, new GetUnregisteredDisksQueryParameters(storageDomainId, storagePoolId)).getReturnValue();
        if (disksFromStorage == null) {
            log.error("An error occurred while fetching unregistered disks from Storage Domain id '{}'", storageDomainId);
            return ovfDisks;
        } else {
            castDiskImagesToUnregisteredDisks(disksFromStorage, storageDomainId);
        }
        for (Disk disk : disksFromStorage) {
            DiskImage ovfStoreDisk = (DiskImage) disk;
            String diskDescription = ovfStoreDisk.getDescription();
            if (diskDescription.contains(OvfInfoFileConstants.OvfStoreDescriptionLabel)) {
                Map<String, Object> diskDescriptionMap;
                try {
                    diskDescriptionMap = JsonHelper.jsonToMap(diskDescription);
                } catch (IOException e) {
                    log.warn("Exception while generating json containing ovf store info: {}", e.getMessage());
                    log.debug("Exception", e);
                    continue;
                }
                // Domain.
                if (!isDomainExistsInDiskDescription(diskDescriptionMap, storageDomainId)) {
                    log.warn("The disk description does not contain the storage domain id '{}'", storageDomainId);
                    continue;
                }
                ovfDisks.add(ovfStoreDisk);
            }
        }
    }
    return ovfDisks;
}
#method_after
protected List<DiskImage> getAllOVFDisks(Guid storageDomainId, Guid storagePoolId) {
    // fetched yet.
    if (ovfDisks == null) {
        ovfDisks = new ArrayList<>();
        // Get all unregistered disks.
        List<DiskImage> disksFromStorage = getBackend().runInternalQuery(QueryType.GetUnregisteredDisks, new GetUnregisteredDisksQueryParameters(storageDomainId, storagePoolId)).getReturnValue();
        if (disksFromStorage == null) {
            log.error("An error occurred while fetching unregistered disks from Storage Domain id '{}'", storageDomainId);
            return ovfDisks;
        } else {
            castDiskImagesToUnregisteredDisks(disksFromStorage, storageDomainId);
        }
        for (Disk disk : disksFromStorage) {
            DiskImage ovfStoreDisk = (DiskImage) disk;
            String diskDescription = ovfStoreDisk.getDescription();
            if (diskDescription.contains(OvfInfoFileConstants.OvfStoreDescriptionLabel)) {
                Map<String, Object> diskDescriptionMap;
                try {
                    diskDescriptionMap = JsonHelper.jsonToMap(diskDescription);
                } catch (IOException e) {
                    log.warn("Exception while generating json containing ovf store info: {}", e.getMessage());
                    log.debug("Exception", e);
                    continue;
                }
                // Domain.
                if (!isDomainExistsInDiskDescription(diskDescriptionMap, storageDomainId)) {
                    log.warn("The disk description does not contain the storage domain id '{}'", storageDomainId);
                    continue;
                }
                ovfDisks.add(ovfStoreDisk);
            }
        }
    }
    return ovfDisks;
}
#end_block

#method_before
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk(Guid storageDomainId, Guid storagePoolId) {
    // Initialize a new ArrayList with all the ovfDisks in the specified Storage Domain,
    // so the entities can be removed from the list every time we register the latest OVF disk and we can keep the
    // ovfDisks cache list updated.
    List<DiskImage> ovfStoreDiskImages = new ArrayList<>(getAllOVFDisks(storageDomainId, storagePoolId));
    if (!ovfStoreDiskImages.isEmpty()) {
        while (!ovfStoreDiskImages.isEmpty()) {
            Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(ovfStoreDiskImages);
            DiskImage ovfDisk = ovfDiskAndSize.getFirst();
            if (ovfDisk != null) {
                try {
                    VdcReturnValueBase vdcReturnValue = runInternalAction(ActionType.RetrieveImageData, new RetrieveImageDataParameters(getParameters().getStoragePoolId(), storageDomainId, ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()), cloneContextAndDetachFromParent());
                    getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                    if (vdcReturnValue.getSucceeded()) {
                        List<OvfEntityData> returnedMap = OvfUtils.getOvfEntities(vdcReturnValue.getActionReturnValue(), unregisteredDisks, storageDomainId);
                        return returnedMap;
                    } else {
                        log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}'", ovfDisk.getId(), storageDomainId);
                    }
                } catch (RuntimeException e) {
                    // We are catching RuntimeException, since the call for OvfUtils.getOvfEntities will throw
                    // a RuntimeException if there is a problem to untar the file.
                    log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}': {}", ovfDisk.getId(), storageDomainId, e.getMessage());
                    log.debug("Exception", e);
                }
                ovfStoreDiskImages.remove(ovfDisk);
            } else {
                log.error("Couldn't find additional ovf store to retrieve the ovf data from in storage domain '{}'", storageDomainId);
                break;
            }
        }
        AuditLogable logable = new AuditLogableImpl();
        logable.setStorageDomainId(storageDomainId);
        logable.setStorageDomainName(storageDomainStaticDao.get(storageDomainId).getName());
        auditLogDirector.log(logable, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
    } else {
        log.warn("There are no OVF_STORE disks on storage domain id {}", storageDomainId);
    }
    return new ArrayList<>();
}
#method_after
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk(Guid storageDomainId, Guid storagePoolId) {
    // Initialize a new ArrayList with all the ovfDisks in the specified Storage Domain,
    // so the entities can be removed from the list every time we register the latest OVF disk and we can keep the
    // ovfDisks cache list updated.
    List<DiskImage> ovfStoreDiskImages = new ArrayList<>(getAllOVFDisks(storageDomainId, storagePoolId));
    if (!ovfStoreDiskImages.isEmpty()) {
        while (!ovfStoreDiskImages.isEmpty()) {
            Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(ovfStoreDiskImages);
            DiskImage ovfDisk = ovfDiskAndSize.getFirst();
            if (ovfDisk != null) {
                try {
                    ActionReturnValue actionReturnValueReturnValue = runInternalAction(ActionType.RetrieveImageData, new RetrieveImageDataParameters(getParameters().getStoragePoolId(), storageDomainId, ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()), cloneContextAndDetachFromParent());
                    getReturnValue().getVdsmTaskIdList().addAll(actionReturnValueReturnValue.getInternalVdsmTaskIdList());
                    if (actionReturnValueReturnValue.getSucceeded()) {
                        List<OvfEntityData> returnedMap = OvfUtils.getOvfEntities(actionReturnValueReturnValue.getActionReturnValue(), unregisteredDisks, storageDomainId);
                        return returnedMap;
                    } else {
                        log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}'", ovfDisk.getId(), storageDomainId);
                    }
                } catch (RuntimeException e) {
                    // We are catching RuntimeException, since the call for OvfUtils.getOvfEntities will throw
                    // a RuntimeException if there is a problem to untar the file.
                    log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}': {}", ovfDisk.getId(), storageDomainId, e.getMessage());
                    log.debug("Exception", e);
                }
                ovfStoreDiskImages.remove(ovfDisk);
            } else {
                log.error("Couldn't find additional ovf store to retrieve the ovf data from in storage domain '{}'", storageDomainId);
                break;
            }
        }
        AuditLogable logable = new AuditLogableImpl();
        logable.setStorageDomainId(storageDomainId);
        logable.setStorageDomainName(storageDomainStaticDao.get(storageDomainId).getName());
        auditLogDirector.log(logable, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
    } else {
        log.warn("There are no OVF_STORE disks on storage domain id {}", storageDomainId);
    }
    return new ArrayList<>();
}
#end_block

#method_before
protected static void mapCommonModelToEntity(org.ovirt.engine.core.common.businessentities.VmBase entity, VmBase model) {
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetMemory()) {
        entity.setMemSizeMb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetIo() && model.getIo().isSetThreads()) {
        entity.setNumOfIoThreads(model.getIo().getThreads());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            entity.setCpuPerSocket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            entity.setNumOfSockets(model.getCpu().getTopology().getSockets());
        }
        if (model.getCpu().getTopology().getThreads() != null) {
            entity.setThreadsPerCpu(model.getCpu().getTopology().getThreads());
        }
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            entity.setAutoStartup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            entity.setPriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            // let backend decide which video device to use
            entity.setDefaultDisplayType(null);
        }
        if (model.getDisplay().isSetMonitors()) {
            entity.setNumOfMonitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetSingleQxlPci()) {
            entity.setSingleQxlPci(model.getDisplay().isSingleQxlPci());
        }
        if (model.getDisplay().isSetSmartcardEnabled()) {
            entity.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
    }
    if (model.isSetMigrationDowntime()) {
        entity.setMigrationDowntime(mapMinusOneToNull(model.getMigrationDowntime()));
    }
    if (model.isSetMigration()) {
        MigrationOptionsMapper.copyMigrationOptions(model.getMigration(), entity);
    }
    if (model.isSetCustomCpuModel()) {
        entity.setCustomCpuName(model.getCustomCpuModel());
    }
    if (model.isSetCustomEmulatedMachine()) {
        entity.setCustomEmulatedMachine(model.getCustomEmulatedMachine());
    }
    if (model.isSetMemoryPolicy() && model.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = model.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        entity.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (model.isSetMemoryPolicy() && model.getMemoryPolicy().isSetMax()) {
        Long maxMemory = model.getMemoryPolicy().getMax() / BYTES_PER_MB;
        entity.setMaxMemorySizeMb(maxMemory.intValue());
    }
    if (model.isSetOs()) {
        Boot boot = model.getOs().getBoot();
        if (boot != null && boot.isSetDevices() && boot.getDevices().isSetDevices()) {
            entity.setDefaultBootSequence(VmMapper.map(model.getOs().getBoot(), null));
        }
    }
    if (model.isSetCustomCompatibilityVersion()) {
        entity.setCustomCompatibilityVersion(model.getCustomCompatibilityVersion().isSetMajor() || model.getCustomCompatibilityVersion().isSetMinor() ? VersionMapper.map(model.getCustomCompatibilityVersion()) : null);
    }
    if (model.isSetLease()) {
        entity.setLeaseStorageDomainId(StorageDomainLeaseMapper.map(model.getLease()));
    }
}
#method_after
protected static void mapCommonModelToEntity(org.ovirt.engine.core.common.businessentities.VmBase entity, VmBase model) {
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetMemory()) {
        entity.setMemSizeMb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetIo() && model.getIo().isSetThreads()) {
        entity.setNumOfIoThreads(model.getIo().getThreads());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            entity.setCpuPerSocket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            entity.setNumOfSockets(model.getCpu().getTopology().getSockets());
        }
        if (model.getCpu().getTopology().getThreads() != null) {
            entity.setThreadsPerCpu(model.getCpu().getTopology().getThreads());
        }
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            entity.setAutoStartup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            entity.setPriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            // let backend decide which video device to use
            entity.setDefaultDisplayType(null);
        }
        if (model.getDisplay().isSetMonitors()) {
            entity.setNumOfMonitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetSingleQxlPci()) {
            entity.setSingleQxlPci(model.getDisplay().isSingleQxlPci());
        }
        if (model.getDisplay().isSetSmartcardEnabled()) {
            entity.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
    }
    if (model.isSetMigrationDowntime()) {
        entity.setMigrationDowntime(mapMinusOneToNull(model.getMigrationDowntime()));
    }
    if (model.isSetMigration()) {
        MigrationOptionsMapper.copyMigrationOptions(model.getMigration(), entity);
    }
    if (model.isSetCustomCpuModel()) {
        entity.setCustomCpuName(model.getCustomCpuModel());
    }
    if (model.isSetCustomEmulatedMachine()) {
        entity.setCustomEmulatedMachine(model.getCustomEmulatedMachine());
    }
    if (model.isSetMemoryPolicy() && model.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = model.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        entity.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (model.isSetMemoryPolicy() && model.getMemoryPolicy().isSetMax()) {
        Long maxMemory = model.getMemoryPolicy().getMax() / BYTES_PER_MB;
        entity.setMaxMemorySizeMb(maxMemory.intValue());
    }
    if (model.isSetOs()) {
        Boot boot = model.getOs().getBoot();
        if (boot != null && boot.isSetDevices() && boot.getDevices().isSetDevices()) {
            entity.setDefaultBootSequence(VmMapper.map(model.getOs().getBoot(), null));
        }
    }
    if (model.isSetCustomCompatibilityVersion()) {
        Version entityMappedVersion = VersionMapper.map(model.getCustomCompatibilityVersion());
        entity.setCustomCompatibilityVersion(entityMappedVersion.isNotValid() ? null : entityMappedVersion);
    }
    if (model.isSetLease()) {
        entity.setLeaseStorageDomainId(StorageDomainLeaseMapper.map(model.getLease()));
    }
}
#end_block

#method_before
private void removeCinderSnapshotDisks() {
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(getImages());
    if (cinderDisks.isEmpty()) {
        return;
    }
    Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(ActionType.RemoveAllCinderSnapshotDisks, buildRemoveCinderSnapshotDiskParameters(cinderDisks), cloneContextAndDetachFromParent());
    try {
        VdcReturnValueBase vdcReturnValueBase = future.get();
        if (!vdcReturnValueBase.getSucceeded()) {
            log.error("Error removing snapshots for Cinder disks");
            endWithFailure();
            getParameters().setTaskGroupSuccess(false);
        } else {
            Snapshot snapshotWithoutImage = null;
            Snapshot snapshot = snapshotDao.get(cinderDisks.get(0).getSnapshotId());
            lockVmSnapshotsWithWait(getVm());
            for (CinderDisk cinderDisk : cinderDisks) {
                snapshotWithoutImage = imagesHandler.prepareSnapshotConfigWithoutImageSingleImage(snapshot, cinderDisk.getImageId(), ovfManager);
            }
            snapshotDao.update(snapshotWithoutImage);
            if (getSnapshotsEngineLock() != null) {
                lockManager.releaseLock(getSnapshotsEngineLock());
            }
            endSuccessfully();
            getParameters().setTaskGroupSuccess(true);
        }
    } catch (InterruptedException | ExecutionException e) {
        log.error("Error removing snapshots for Cinder disks");
        endWithFailure();
        getParameters().setTaskGroupSuccess(false);
    }
}
#method_after
private void removeCinderSnapshotDisks() {
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(getImages());
    if (cinderDisks.isEmpty()) {
        return;
    }
    Future<ActionReturnValue> future = CommandCoordinatorUtil.executeAsyncCommand(ActionType.RemoveAllCinderSnapshotDisks, buildRemoveCinderSnapshotDiskParameters(cinderDisks), cloneContextAndDetachFromParent());
    try {
        ActionReturnValue actionReturnValue = future.get();
        if (!actionReturnValue.getSucceeded()) {
            log.error("Error removing snapshots for Cinder disks");
            endWithFailure();
            getParameters().setTaskGroupSuccess(false);
        } else {
            Snapshot snapshotWithoutImage = null;
            Snapshot snapshot = snapshotDao.get(cinderDisks.get(0).getSnapshotId());
            lockVmSnapshotsWithWait(getVm());
            for (CinderDisk cinderDisk : cinderDisks) {
                snapshotWithoutImage = imagesHandler.prepareSnapshotConfigWithoutImageSingleImage(snapshot, cinderDisk.getImageId(), ovfManager);
            }
            snapshotDao.update(snapshotWithoutImage);
            if (getSnapshotsEngineLock() != null) {
                lockManager.releaseLock(getSnapshotsEngineLock());
            }
            endSuccessfully();
            getParameters().setTaskGroupSuccess(true);
        }
    } catch (InterruptedException | ExecutionException e) {
        log.error("Error removing snapshots for Cinder disks");
        endWithFailure();
        getParameters().setTaskGroupSuccess(false);
    }
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    Guid storagePoolId = getParameters().getStoragePoolId();
    Guid storageDomainId = getParameters().getStorageDomainId();
    Guid diskId = getParameters().getDiskId();
    StorageDomain storageDomain = storageDomainDao.get(storageDomainId);
    if (storageDomain == null) {
        getQueryReturnValue().setExceptionString(EngineMessage.STORAGE_DOMAIN_DOES_NOT_EXIST.toString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    if (storageDomain.getStorageType().isCinderDomain()) {
        VdcQueryReturnValue returnValue = runInternalQuery(VdcQueryType.GetUnregisteredCinderDiskByIdAndStorageDomainId, new GetCinderEntityByStorageDomainIdParameters(diskId, getParameters().getStorageDomainId()));
        setReturnValue(returnValue.getReturnValue());
        return;
    }
    // Now get the list of volumes for each new image.
    StoragePoolDomainAndGroupIdBaseVDSCommandParameters getVolumesParameters = new StoragePoolDomainAndGroupIdBaseVDSCommandParameters(storagePoolId, storageDomainId, diskId);
    VDSReturnValue volumesListReturn = runVdsCommand(VDSCommandType.GetVolumesList, getVolumesParameters);
    if (!volumesListReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(volumesListReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    @SuppressWarnings("unchecked")
    List<Guid> volumesList = (List<Guid>) volumesListReturn.getReturnValue();
    // image. If there are multiple volumes, skip the image and move on to the next.
    if (volumesList.size() != 1) {
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    Guid volumeId = volumesList.get(0);
    // Get the information about the volume from VDSM.
    GetImageInfoVDSCommandParameters imageInfoParameters = new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskId, volumeId);
    VDSReturnValue imageInfoReturn = runVdsCommand(VDSCommandType.GetImageInfo, imageInfoParameters);
    if (!imageInfoReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(imageInfoReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    DiskImage newDiskImage = (DiskImage) imageInfoReturn.getReturnValue();
    if (!fetchQcowCompat(storagePoolId, storageDomainId, diskId, volumeId, newDiskImage)) {
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    if (StringUtils.isNotEmpty(newDiskImage.getDescription())) {
        try {
            MetadataDiskDescriptionHandler.getInstance().enrichDiskByJsonDescription(newDiskImage.getDescription(), newDiskImage);
        } catch (IOException | DecoderException e) {
            log.warn("Exception while parsing JSON for disk. Exception: '{}'", e);
        }
    }
    newDiskImage.setStoragePoolId(storagePoolId);
    getQueryReturnValue().setReturnValue(newDiskImage);
    getQueryReturnValue().setSucceeded(true);
}
#method_after
@Override
protected void executeQueryCommand() {
    Guid storagePoolId = getParameters().getStoragePoolId();
    Guid storageDomainId = getParameters().getStorageDomainId();
    Guid diskId = getParameters().getDiskId();
    StorageDomain storageDomain = storageDomainDao.get(storageDomainId);
    if (storageDomain == null) {
        getQueryReturnValue().setExceptionString(EngineMessage.STORAGE_DOMAIN_DOES_NOT_EXIST.toString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    if (storageDomain.getStorageType().isCinderDomain()) {
        QueryReturnValue returnValue = runInternalQuery(QueryType.GetUnregisteredCinderDiskByIdAndStorageDomainId, new GetCinderEntityByStorageDomainIdParameters(diskId, getParameters().getStorageDomainId()));
        setReturnValue(returnValue.getReturnValue());
        return;
    }
    // Now get the list of volumes for each new image.
    StoragePoolDomainAndGroupIdBaseVDSCommandParameters getVolumesParameters = new StoragePoolDomainAndGroupIdBaseVDSCommandParameters(storagePoolId, storageDomainId, diskId);
    VDSReturnValue volumesListReturn = runVdsCommand(VDSCommandType.GetVolumesList, getVolumesParameters);
    if (!volumesListReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(volumesListReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    @SuppressWarnings("unchecked")
    List<Guid> volumesList = (List<Guid>) volumesListReturn.getReturnValue();
    // image. If there are multiple volumes, skip the image and move on to the next.
    if (volumesList.size() != 1) {
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    Guid volumeId = volumesList.get(0);
    // Get the information about the volume from VDSM.
    GetImageInfoVDSCommandParameters imageInfoParameters = new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskId, volumeId);
    VDSReturnValue imageInfoReturn = runVdsCommand(VDSCommandType.GetImageInfo, imageInfoParameters);
    if (!imageInfoReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(imageInfoReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    DiskImage newDiskImage = (DiskImage) imageInfoReturn.getReturnValue();
    if (!fetchQcowCompat(storagePoolId, storageDomainId, diskId, volumeId, newDiskImage)) {
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    if (StringUtils.isNotEmpty(newDiskImage.getDescription())) {
        try {
            MetadataDiskDescriptionHandler.getInstance().enrichDiskByJsonDescription(newDiskImage.getDescription(), newDiskImage);
        } catch (IOException | DecoderException e) {
            log.warn("Exception while parsing JSON for disk. Exception: '{}'", e);
        }
    }
    newDiskImage.setStoragePoolId(storagePoolId);
    getQueryReturnValue().setReturnValue(newDiskImage);
    getQueryReturnValue().setSucceeded(true);
}
#end_block

#method_before
private void removeImage(Guid storageDomainId) {
    RemoveImageParameters removeImageParams = new RemoveImageParameters(getParameters().getImageId());
    removeImageParams.setStorageDomainId(storageDomainId);
    removeImageParams.setParentCommand(ActionType.RemoveImage);
    removeImageParams.setDbOperationScope(ImageDbOperationScope.NONE);
    removeImageParams.setShouldLockImage(false);
    removeImageParams.setCorrelationId(getParameters().getCorrelationId());
    // TODO: should be removed as async task manager issues would be resolved, done in order
    // to avoid operations on the image to wait for this remove operation as currently async
    // task manager calls the end methods of command based on the entity id.
    // the remove done here is a "clenaup", either on the source domain or on the target - so
    // other operations on the image shouldn't be dependent and wait for it.
    removeImageParams.setEntityInfo(new EntityInfo(VdcObjectType.Disk, Guid.newGuid()));
    VdcReturnValueBase returnValue = runInternalAction(ActionType.RemoveImage, removeImageParams, cloneContextAndDetachFromParent());
    if (returnValue.getSucceeded()) {
        startPollingAsyncTasks(returnValue.getInternalVdsmTaskIdList());
    } else {
        addAuditLogOnRemoveFailure();
    }
}
#method_after
private void removeImage(Guid storageDomainId) {
    RemoveImageParameters removeImageParams = new RemoveImageParameters(getParameters().getImageId());
    removeImageParams.setStorageDomainId(storageDomainId);
    removeImageParams.setParentCommand(ActionType.RemoveImage);
    removeImageParams.setDbOperationScope(ImageDbOperationScope.NONE);
    removeImageParams.setShouldLockImage(false);
    removeImageParams.setCorrelationId(getParameters().getCorrelationId());
    // TODO: should be removed as async task manager issues would be resolved, done in order
    // to avoid operations on the image to wait for this remove operation as currently async
    // task manager calls the end methods of command based on the entity id.
    // the remove done here is a "clenaup", either on the source domain or on the target - so
    // other operations on the image shouldn't be dependent and wait for it.
    removeImageParams.setEntityInfo(new EntityInfo(VdcObjectType.Disk, Guid.newGuid()));
    ActionReturnValue returnValue = runInternalAction(ActionType.RemoveImage, removeImageParams, cloneContextAndDetachFromParent());
    if (returnValue.getSucceeded()) {
        startPollingAsyncTasks(returnValue.getInternalVdsmTaskIdList());
    } else {
        addAuditLogOnRemoveFailure();
    }
}
#end_block

#method_before
protected Map<Guid, Guid> addAllTemplateDisks() {
    VdcReturnValueBase returnValue = runInternalAction(getAddAllTemplateDisksActionType(), buildCreateAllTemplateDisksParameters(), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
    }
    return returnValue.getActionReturnValue();
}
#method_after
protected Map<Guid, Guid> addAllTemplateDisks() {
    ActionReturnValue returnValue = runInternalAction(getAddAllTemplateDisksActionType(), buildCreateAllTemplateDisksParameters(), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
    }
    return returnValue.getActionReturnValue();
}
#end_block

#method_before
private void assignLegalAndShared(boolean legalAndShared) {
    VdcReturnValueBase returnValue = runInternalAction(ActionType.UpdateAllTemplateDisks, buildUpdateAllTemplateDisksParameters(legalAndShared), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
    }
}
#method_after
private void assignLegalAndShared(boolean legalAndShared) {
    ActionReturnValue returnValue = runInternalAction(ActionType.UpdateAllTemplateDisks, buildUpdateAllTemplateDisksParameters(legalAndShared), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
    }
}
#end_block

#method_before
private void sealVmTemplate() {
    VdcReturnValueBase returnValue = runInternalAction(ActionType.SealVmTemplate, buildSealVmTemplateParameters(), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
    }
}
#method_after
private void sealVmTemplate() {
    ActionReturnValue returnValue = runInternalAction(ActionType.SealVmTemplate, buildSealVmTemplateParameters(), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVmTemplate() == null) {
        return false;
    }
    setDescription(getVmTemplateName());
    // check that the storage pool is valid
    if (!checkStoragePool() || !validateTemplateArchitecture() || !isClusterCompatible()) {
        return false;
    }
    // set the source domain and check that it is ImportExport type and active
    setSourceDomainId(getParameters().getSourceDomainId());
    StorageDomainValidator sourceDomainValidator = new StorageDomainValidator(getSourceDomain());
    if (!validate(sourceDomainValidator.isDomainExistAndActive())) {
        return false;
    }
    if ((getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) && !getParameters().isImagesExistOnTargetStorageDomain()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (!getParameters().isImagesExistOnTargetStorageDomain()) {
        // Set the template images from the Export domain and change each image id storage is to the import domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        VdcQueryReturnValue qretVal = runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
        if (!qretVal.getSucceeded()) {
            return false;
        }
        Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
        ArrayList<DiskImage> images = new ArrayList<>();
        for (Map.Entry<VmTemplate, List<DiskImage>> entry : templates.entrySet()) {
            if (entry.getKey().getId().equals(getVmTemplate().getId())) {
                images = new ArrayList<>(entry.getValue());
                getVmTemplate().setInterfaces(entry.getKey().getInterfaces());
                getVmTemplate().setOvfVersion(entry.getKey().getOvfVersion());
                break;
            }
        }
        getParameters().setImages(images);
        getVmTemplate().setImages(images);
        ensureDomainMap(getImages(), getParameters().getDestDomainId());
        HashMap<Guid, DiskImage> imageMap = new HashMap<>();
        for (DiskImage image : images) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            StorageDomain storageDomain = getStorageDomain(imageToDestinationDomainMap.get(image.getId()));
            StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
            if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
                return false;
            }
            StorageDomainStatic targetDomain = storageDomain.getStorageStaticData();
            changeRawToCowIfSparseOnBlockDevice(targetDomain.getStorageType(), image);
            if (!ImagesHandler.checkImageConfiguration(targetDomain, image, getReturnValue().getValidationMessages())) {
                return false;
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            image.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomain.getId())));
            imageMap.put(image.getImageId(), image);
        }
        getVmTemplate().setDiskImageMap(imageMap);
    }
    sourceTemplateId = getVmTemplateId();
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedTemplate();
    }
    VmTemplate duplicateTemplate = vmTemplateDao.get(getParameters().getVmTemplate().getId());
    // check that the template does not exists in the target domain
    if (duplicateTemplate != null) {
        return failValidation(EngineMessage.VMT_CANNOT_IMPORT_TEMPLATE_EXISTS, String.format("$TemplateName %1$s", duplicateTemplate.getName()));
    }
    if (getVmTemplate().isBaseTemplate() && isVmTemplateWithSameNameExist()) {
        return failValidation(EngineMessage.VM_CANNOT_IMPORT_TEMPLATE_NAME_EXISTS);
    }
    if (!validateNoDuplicateDiskImages(getImages())) {
        return false;
    }
    if (getImages() != null && !getImages().isEmpty() && !getParameters().isImagesExistOnTargetStorageDomain()) {
        if (!validateSpaceRequirements(getImages())) {
            return false;
        }
    }
    List<VmNetworkInterface> vmNetworkInterfaces = getVmTemplate().getInterfaces();
    vmNicMacsUtils.replaceInvalidEmptyStringMacAddressesWithNull(vmNetworkInterfaces);
    if (!validate(vmNicMacsUtils.validateMacAddress(vmNetworkInterfaces))) {
        return false;
    }
    // if this is a template version, check base template exist
    if (!getVmTemplate().isBaseTemplate()) {
        VmTemplate baseTemplate = vmTemplateDao.get(getVmTemplate().getBaseTemplateId());
        if (baseTemplate == null) {
            return failValidation(EngineMessage.VMT_CANNOT_IMPORT_TEMPLATE_VERSION_MISSING_BASE);
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getVmTemplate(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getVmTemplate() == null) {
        return false;
    }
    setDescription(getVmTemplateName());
    // check that the storage pool is valid
    if (!checkStoragePool() || !validateTemplateArchitecture() || !isClusterCompatible()) {
        return false;
    }
    // set the source domain and check that it is ImportExport type and active
    setSourceDomainId(getParameters().getSourceDomainId());
    StorageDomainValidator sourceDomainValidator = new StorageDomainValidator(getSourceDomain());
    if (!validate(sourceDomainValidator.isDomainExistAndActive())) {
        return false;
    }
    if ((getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) && !getParameters().isImagesExistOnTargetStorageDomain()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (!getParameters().isImagesExistOnTargetStorageDomain()) {
        // Set the template images from the Export domain and change each image id storage is to the import domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        QueryReturnValue qretVal = runInternalQuery(QueryType.GetTemplatesFromExportDomain, tempVar);
        if (!qretVal.getSucceeded()) {
            return false;
        }
        Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
        ArrayList<DiskImage> images = new ArrayList<>();
        for (Map.Entry<VmTemplate, List<DiskImage>> entry : templates.entrySet()) {
            if (entry.getKey().getId().equals(getVmTemplate().getId())) {
                images = new ArrayList<>(entry.getValue());
                getVmTemplate().setInterfaces(entry.getKey().getInterfaces());
                getVmTemplate().setOvfVersion(entry.getKey().getOvfVersion());
                break;
            }
        }
        getParameters().setImages(images);
        getVmTemplate().setImages(images);
        ensureDomainMap(getImages(), getParameters().getDestDomainId());
        HashMap<Guid, DiskImage> imageMap = new HashMap<>();
        for (DiskImage image : images) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            StorageDomain storageDomain = getStorageDomain(imageToDestinationDomainMap.get(image.getId()));
            StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
            if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
                return false;
            }
            StorageDomainStatic targetDomain = storageDomain.getStorageStaticData();
            changeRawToCowIfSparseOnBlockDevice(targetDomain.getStorageType(), image);
            if (!ImagesHandler.checkImageConfiguration(targetDomain, image, getReturnValue().getValidationMessages())) {
                return false;
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            image.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomain.getId())));
            imageMap.put(image.getImageId(), image);
        }
        getVmTemplate().setDiskImageMap(imageMap);
    }
    sourceTemplateId = getVmTemplateId();
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedTemplate();
    }
    VmTemplate duplicateTemplate = vmTemplateDao.get(getParameters().getVmTemplate().getId());
    // check that the template does not exists in the target domain
    if (duplicateTemplate != null) {
        return failValidation(EngineMessage.VMT_CANNOT_IMPORT_TEMPLATE_EXISTS, String.format("$TemplateName %1$s", duplicateTemplate.getName()));
    }
    if (getVmTemplate().isBaseTemplate() && isVmTemplateWithSameNameExist()) {
        return failValidation(EngineMessage.VM_CANNOT_IMPORT_TEMPLATE_NAME_EXISTS);
    }
    if (!validateNoDuplicateDiskImages(getImages())) {
        return false;
    }
    if (getImages() != null && !getImages().isEmpty() && !getParameters().isImagesExistOnTargetStorageDomain()) {
        if (!validateSpaceRequirements(getImages())) {
            return false;
        }
    }
    List<VmNetworkInterface> vmNetworkInterfaces = getVmTemplate().getInterfaces();
    vmNicMacsUtils.replaceInvalidEmptyStringMacAddressesWithNull(vmNetworkInterfaces);
    if (!validate(vmNicMacsUtils.validateMacAddress(vmNetworkInterfaces))) {
        return false;
    }
    // if this is a template version, check base template exist
    if (!getVmTemplate().isBaseTemplate()) {
        VmTemplate baseTemplate = vmTemplateDao.get(getVmTemplate().getBaseTemplateId());
        if (baseTemplate == null) {
            return failValidation(EngineMessage.VMT_CANNOT_IMPORT_TEMPLATE_VERSION_MISSING_BASE);
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getVmTemplate(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void moveOrCopyAllImageGroups(final Guid containerID, final Iterable<DiskImage> disks) {
    TransactionSupport.executeInNewTransaction(() -> {
        for (DiskImage disk : disks) {
            Guid originalDiskId = newDiskIdForDisk.get(disk.getId()).getId();
            Guid destinationDomain = imageToDestinationDomainMap.get(originalDiskId);
            MoveOrCopyImageGroupParameters p = new MoveOrCopyImageGroupParameters(containerID, originalDiskId, newDiskIdForDisk.get(disk.getId()).getImageId(), disk.getId(), disk.getImageId(), destinationDomain, ImageOperation.Copy);
            p.setParentCommand(getActionType());
            p.setUseCopyCollapse(true);
            p.setVolumeType(disk.getVolumeType());
            p.setVolumeFormat(disk.getVolumeFormat());
            p.setCopyVolumeType(CopyVolumeType.SharedVol);
            p.setSourceDomainId(getParameters().getSourceDomainId());
            p.setForceOverride(getParameters().getForceOverride());
            p.setImportEntity(true);
            p.setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, containerID));
            p.setRevertDbOperationScope(ImageDbOperationScope.IMAGE);
            for (DiskImage diskImage : getParameters().getVmTemplate().getDiskList()) {
                if (originalDiskId.equals(diskImage.getId())) {
                    p.setQuotaId(diskImage.getQuotaId());
                    p.setDiskProfileId(diskImage.getDiskProfileId());
                    break;
                }
            }
            p.setParentParameters(getParameters());
            VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, p);
            if (!vdcRetValue.getSucceeded()) {
                throw vdcRetValue.getFault() != null ? new EngineException(vdcRetValue.getFault().getError()) : new EngineException(EngineError.ENGINE);
            }
            getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        }
        return null;
    });
}
#method_after
@Override
protected void moveOrCopyAllImageGroups(final Guid containerID, final Iterable<DiskImage> disks) {
    TransactionSupport.executeInNewTransaction(() -> {
        for (DiskImage disk : disks) {
            Guid originalDiskId = newDiskIdForDisk.get(disk.getId()).getId();
            Guid destinationDomain = imageToDestinationDomainMap.get(originalDiskId);
            MoveOrCopyImageGroupParameters p = new MoveOrCopyImageGroupParameters(containerID, originalDiskId, newDiskIdForDisk.get(disk.getId()).getImageId(), disk.getId(), disk.getImageId(), destinationDomain, ImageOperation.Copy);
            p.setParentCommand(getActionType());
            p.setUseCopyCollapse(true);
            p.setVolumeType(disk.getVolumeType());
            p.setVolumeFormat(disk.getVolumeFormat());
            p.setCopyVolumeType(CopyVolumeType.SharedVol);
            p.setSourceDomainId(getParameters().getSourceDomainId());
            p.setForceOverride(getParameters().getForceOverride());
            p.setImportEntity(true);
            p.setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, containerID));
            p.setRevertDbOperationScope(ImageDbOperationScope.IMAGE);
            for (DiskImage diskImage : getParameters().getVmTemplate().getDiskList()) {
                if (originalDiskId.equals(diskImage.getId())) {
                    p.setQuotaId(diskImage.getQuotaId());
                    p.setDiskProfileId(diskImage.getDiskProfileId());
                    break;
                }
            }
            p.setParentParameters(getParameters());
            ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, p);
            if (!vdcRetValue.getSucceeded()) {
                throw vdcRetValue.getFault() != null ? new EngineException(vdcRetValue.getFault().getError()) : new EngineException(EngineError.ENGINE);
            }
            getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        }
        return null;
    });
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!validate(new VmValidator(getVm()).isVmExists()) || !isDiskExistAndAttachedToVm(getOldDisk()) || !validateDiskVmData()) {
        return false;
    }
    boolean isDiskImageOrCinder = DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() || DiskStorageType.CINDER == getOldDisk().getDiskStorageType();
    if (isDiskImageOrCinder) {
        ValidationResult imagesNotLocked = new DiskImagesValidator((DiskImage) getOldDisk()).diskImagesNotLocked();
        if (!imagesNotLocked.isValid()) {
            return validate(imagesNotLocked);
        }
    }
    DiskValidator oldDiskValidator = getDiskValidator(getOldDisk());
    ValidationResult isHostedEngineDisk = oldDiskValidator.validateNotHostedEngineDisk();
    if (!isHostedEngineDisk.isValid()) {
        return validate(isHostedEngineDisk);
    }
    if (!checkOperationAllowedOnDiskContentType(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    boolean isDiskInterfaceUpdated = getOldDiskVmElement().getDiskInterface() != getDiskVmElement().getDiskInterface();
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && updateParametersRequiringVmDownRequested()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDiskVmElement().isBoot() && getDiskVmElement().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(oldDiskValidator.isVmNotContainsBootDisk(getVm()))) {
            return false;
        }
        if (isDiskInterfaceUpdated && !isDiskPassPciAndIdeLimit()) {
            return false;
        }
    }
    if (isDiskImageOrCinder && !validateCanResizeDisk()) {
        return false;
    }
    if (resizeDiskImageRequested() && amendDiskRequested()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_AMEND_AND_EXTEND_IN_ONE_OPERATION);
    }
    if (amendDiskRequested() && isAllDiskVolumesRaw()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANT_AMEND_RAW_DISK);
    }
    DiskVmElementValidator diskVmElementValidator = getDiskVmElementValidator(getNewDisk(), getDiskVmElement());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly() && validateVmPoolProperties() && validateQuota() && validate(diskVmElementValidator.isVirtIoScsiValid(getVm())) && (!isDiskInterfaceUpdated || validate(diskVmElementValidator.isDiskInterfaceSupported(getVm()))) && setAndValidateDiskProfiles() && validatePassDiscardSupported(diskVmElementValidator);
}
#method_after
@Override
protected boolean validate() {
    if (!validate(new VmValidator(getVm()).isVmExists()) || !isDiskExistAndAttachedToVm(getOldDisk()) || !validateDiskVmData()) {
        return false;
    }
    boolean isDiskImageOrCinder = DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() || DiskStorageType.CINDER == getOldDisk().getDiskStorageType();
    if (isDiskImageOrCinder) {
        ValidationResult imagesNotLocked = new DiskImagesValidator((DiskImage) getOldDisk()).diskImagesNotLocked();
        if (!imagesNotLocked.isValid()) {
            return validate(imagesNotLocked);
        }
    }
    DiskValidator oldDiskValidator = getDiskValidator(getOldDisk());
    ValidationResult isHostedEngineDisk = oldDiskValidator.validateNotHostedEngineDisk();
    if (!isHostedEngineDisk.isValid()) {
        return validate(isHostedEngineDisk);
    }
    if (!checkOperationAllowedOnDiskContentType(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    boolean isDiskInterfaceUpdated = getOldDiskVmElement().getDiskInterface() != getDiskVmElement().getDiskInterface();
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && updateParametersRequiringVmDownRequested()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDiskVmElement().isBoot() && getDiskVmElement().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(oldDiskValidator.isVmNotContainsBootDisk(getVm()))) {
            return false;
        }
        if (isDiskInterfaceUpdated && !isDiskPassPciAndIdeLimit()) {
            return false;
        }
    }
    if (isDiskImageOrCinder && !validateCanResizeDisk()) {
        return false;
    }
    if (resizeDiskImageRequested() && amendDiskRequested()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_AMEND_AND_EXTEND_IN_ONE_OPERATION);
    }
    if (isQcowCompatChangedOnRawDisk()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANT_AMEND_RAW_DISK);
    }
    DiskVmElementValidator diskVmElementValidator = getDiskVmElementValidator(getNewDisk(), getDiskVmElement());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly() && validateVmPoolProperties() && validateQuota() && validate(diskVmElementValidator.isVirtIoScsiValid(getVm())) && (!isDiskInterfaceUpdated || validate(diskVmElementValidator.isDiskInterfaceSupported(getVm()))) && setAndValidateDiskProfiles() && validatePassDiscardSupported(diskVmElementValidator);
}
#end_block

#method_before
private boolean validateCanUpdateShareable() {
    if (DiskStorageType.LUN == getOldDisk().getDiskStorageType()) {
        return true;
    }
    // Check if VM is not during snapshot.
    if (!isVmNotInPreviewSnapshot()) {
        return false;
    }
    if (isUpdatedToShareable(getOldDisk(), getNewDisk())) {
        StorageDomainStatic sds = storageDomainStaticDao.get(((DiskImage) getNewDisk()).getStorageIds().get(0));
        if (sds.getStorageType() == StorageType.GLUSTERFS) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_SHAREABLE_DISKS_NOT_SUPPORTED_ON_GLUSTER_DOMAIN);
        }
        List<DiskImage> diskImageList = diskImageDao.getAllSnapshotsForImageGroup(getOldDisk().getId());
        // disk and all the other images are the snapshots.
        if ((diskImageList.size() > 1) || !Guid.Empty.equals(((DiskImage) getOldDisk()).getImageTemplateId())) {
            return failValidation(EngineMessage.SHAREABLE_DISK_IS_NOT_SUPPORTED_FOR_DISK);
        }
        if (!isVolumeFormatSupportedForShareable(((DiskImage) getNewDisk()).getVolumeFormat())) {
            return failValidation(EngineMessage.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
        }
    } else if (isUpdatedToNonShareable(getOldDisk(), getNewDisk())) {
        if (vmsDiskOrSnapshotAttachedTo.size() > 1) {
            return failValidation(EngineMessage.DISK_IS_ALREADY_SHARED_BETWEEN_VMS);
        }
    }
    return true;
}
#method_after
private boolean validateCanUpdateShareable() {
    if (DiskStorageType.LUN == getOldDisk().getDiskStorageType()) {
        return true;
    }
    // Check if VM is not during snapshot.
    if (!isVmNotInPreviewSnapshot()) {
        return false;
    }
    if (isUpdatedToShareable(getOldDisk(), getNewDisk())) {
        StorageDomainStatic sds = storageDomainStaticDao.get(((DiskImage) getNewDisk()).getStorageIds().get(0));
        if (sds.getStorageType() == StorageType.GLUSTERFS) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_SHAREABLE_DISKS_NOT_SUPPORTED_ON_GLUSTER_DOMAIN);
        }
        List<DiskImage> diskImageList = getDiskImages(getOldDisk().getId());
        // disk and all the other images are the snapshots.
        if ((diskImageList.size() > 1) || !Guid.Empty.equals(((DiskImage) getOldDisk()).getImageTemplateId())) {
            return failValidation(EngineMessage.SHAREABLE_DISK_IS_NOT_SUPPORTED_FOR_DISK);
        }
        if (!isVolumeFormatSupportedForShareable(((DiskImage) getNewDisk()).getVolumeFormat())) {
            return failValidation(EngineMessage.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
        }
    } else if (isUpdatedToNonShareable(getOldDisk(), getNewDisk())) {
        if (vmsDiskOrSnapshotAttachedTo.size() > 1) {
            return failValidation(EngineMessage.DISK_IS_ALREADY_SHARED_BETWEEN_VMS);
        }
    }
    return true;
}
#end_block

#method_before
private void extendDiskImageSize() {
    lockImageInDb();
    VdcReturnValueBase ret = runInternalActionWithTasksContext(ActionType.ExtendImageSize, createExtendImageSizeParameters());
    if (!ret.getSucceeded()) {
        propagateInternalCommandFailure(ret);
        getReturnValue().setFault(ret.getFault());
    }
    getReturnValue().getVdsmTaskIdList().addAll(ret.getInternalVdsmTaskIdList());
    setSucceeded(ret.getSucceeded());
}
#method_after
private void extendDiskImageSize() {
    lockImageInDb();
    ActionReturnValue ret = runInternalActionWithTasksContext(ActionType.ExtendImageSize, createExtendImageSizeParameters());
    if (!ret.getSucceeded()) {
        propagateInternalCommandFailure(ret);
        getReturnValue().setFault(ret.getFault());
    }
    getReturnValue().getVdsmTaskIdList().addAll(ret.getInternalVdsmTaskIdList());
    setSucceeded(ret.getSucceeded());
}
#end_block

#method_before
protected void amendDiskImage() {
    VdcReturnValueBase ret = runInternalActionWithTasksContext(ActionType.AmendImageGroupVolumes, amendImageGroupVolumesCommandParameters());
    if (!ret.getSucceeded()) {
        propagateInternalCommandFailure(ret);
        getReturnValue().setFault(ret.getFault());
    }
    setSucceeded(ret.getSucceeded());
}
#method_after
protected void amendDiskImage() {
    ActionReturnValue ret = runInternalActionWithTasksContext(ActionType.AmendImageGroupVolumes, amendImageGroupVolumesCommandParameters());
    if (!ret.getSucceeded()) {
        propagateInternalCommandFailure(ret);
        getReturnValue().setFault(ret.getFault());
    }
    setSucceeded(ret.getSucceeded());
}
#end_block

#method_before
private void extendCinderDiskSize() {
    lockImageInDb();
    CinderDisk newCinderDisk = (CinderDisk) getNewDisk();
    Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(ActionType.ExtendCinderDisk, buildExtendCinderDiskParameters(newCinderDisk), cloneContextAndDetachFromParent());
    addCustomValue("NewSize", String.valueOf(getNewDiskSizeInGB()));
    try {
        setReturnValue(future.get());
        setSucceeded(getReturnValue().getSucceeded());
    } catch (InterruptedException | ExecutionException e) {
        log.error("Error extending Cinder disk '{}': {}", getNewDisk().getDiskAlias(), e.getMessage());
        log.debug("Exception", e);
    }
}
#method_after
private void extendCinderDiskSize() {
    lockImageInDb();
    CinderDisk newCinderDisk = (CinderDisk) getNewDisk();
    Future<ActionReturnValue> future = CommandCoordinatorUtil.executeAsyncCommand(ActionType.ExtendCinderDisk, buildExtendCinderDiskParameters(newCinderDisk), cloneContextAndDetachFromParent());
    addCustomValue("NewSize", String.valueOf(getNewDiskSizeInGB()));
    try {
        setReturnValue(future.get());
        setSucceeded(getReturnValue().getSucceeded());
    } catch (InterruptedException | ExecutionException e) {
        log.error("Error extending Cinder disk '{}': {}", getNewDisk().getDiskAlias(), e.getMessage());
        log.debug("Exception", e);
    }
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    if (!isDiskImage()) {
        return;
    }
    VdcReturnValueBase ret = getBackend().endAction(ActionType.ExtendImageSize, createExtendImageSizeParameters(), getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
    if (ret.getSucceeded()) {
        performDiskUpdate(true);
    } else {
        unlockImageInDb();
    }
    getReturnValue().setEndActionTryAgain(false);
    setSucceeded(ret.getSucceeded());
}
#method_after
@Override
protected void endSuccessfully() {
    if (!isDiskImage()) {
        return;
    }
    ActionReturnValue ret = getBackend().endAction(ActionType.ExtendImageSize, createExtendImageSizeParameters(), getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
    if (ret.getSucceeded()) {
        performDiskUpdate(true);
    } else {
        unlockImageInDb();
    }
    getReturnValue().setEndActionTryAgain(false);
    setSucceeded(ret.getSucceeded());
}
#end_block

#method_before
protected boolean amendDiskRequested() {
    if (getNewDisk().getDiskStorageType() == DiskStorageType.IMAGE) {
        DiskImage oldDisk = (DiskImage) getOldDisk();
        return !Objects.equals(oldDisk.getQcowCompat().getCompatValue(), ((DiskImage) getNewDisk()).getQcowCompat().getCompatValue());
    }
    return false;
}
#method_after
protected boolean amendDiskRequested() {
    if (getNewDisk().getDiskStorageType() == DiskStorageType.IMAGE) {
        QcowCompat qcowCompat = ((DiskImage) getNewDisk()).getQcowCompat();
        return getDiskImages(getOldDisk().getId()).stream().anyMatch(disk -> disk.isQcowFormat() && disk.getQcowCompat() != qcowCompat);
    }
    return false;
}
#end_block

#method_before
private void propagateInternalCommandFailure(VdcReturnValueBase internalReturnValue) {
    getReturnValue().getExecuteFailedMessages().clear();
    getReturnValue().getExecuteFailedMessages().addAll(internalReturnValue.getExecuteFailedMessages());
    getReturnValue().setFault(internalReturnValue.getFault());
    getReturnValue().getValidationMessages().clear();
    getReturnValue().getValidationMessages().addAll(internalReturnValue.getValidationMessages());
    getReturnValue().setValid(internalReturnValue.isValid());
}
#method_after
private void propagateInternalCommandFailure(ActionReturnValue internalReturnValue) {
    getReturnValue().getExecuteFailedMessages().clear();
    getReturnValue().getExecuteFailedMessages().addAll(internalReturnValue.getExecuteFailedMessages());
    getReturnValue().setFault(internalReturnValue.getFault());
    getReturnValue().getValidationMessages().clear();
    getReturnValue().getValidationMessages().addAll(internalReturnValue.getValidationMessages());
    getReturnValue().setValid(internalReturnValue.isValid());
}
#end_block

#method_before
protected VM getVmFromConfiguration() {
    VdcQueryReturnValue queryReturnValue = runInternalQuery(VdcQueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(getParameters().getSourceSnapshotId()));
    return queryReturnValue.getSucceeded() ? queryReturnValue.getReturnValue() : null;
}
#method_after
protected VM getVmFromConfiguration() {
    QueryReturnValue queryReturnValue = runInternalQuery(QueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(getParameters().getSourceSnapshotId()));
    return queryReturnValue.getSucceeded() ? queryReturnValue.getReturnValue() : null;
}
#end_block

#method_before
private void addVmsToPool() {
    int subsequentFailedAttempts = 0;
    int vmPoolMaxSubsequentFailures = Config.<Integer>getValue(ConfigValues.VmPoolMaxSubsequentFailures);
    for (int i = 0; i < getParameters().getVmsCount(); i++) {
        String currentVmName = generateUniqueVmName();
        VdcReturnValueBase returnValue = runInternalAction(ActionType.AddVm, buildAddVmParameters(currentVmName), createAddVmStepContext(currentVmName));
        if (returnValue != null && !returnValue.getSucceeded() && !returnValue.getValidationMessages().isEmpty()) {
            for (String msg : returnValue.getValidationMessages()) {
                if (!getReturnValue().getValidationMessages().contains(msg)) {
                    getReturnValue().getValidationMessages().add(msg);
                }
            }
            allAddVmsSucceeded = false;
            subsequentFailedAttempts++;
        } else {
            // Succeed on that, reset subsequentFailedAttempts.
            subsequentFailedAttempts = 0;
            anyAddVmSucceeded = true;
        }
        // if subsequent attempts failure exceeds configuration value , abort the loop.
        if (subsequentFailedAttempts == vmPoolMaxSubsequentFailures) {
            auditLogDirector.log(this, AuditLogType.USER_VM_POOL_MAX_SUBSEQUENT_FAILURES_REACHED);
            break;
        }
    }
}
#method_after
private void addVmsToPool() {
    int subsequentFailedAttempts = 0;
    int vmPoolMaxSubsequentFailures = Config.<Integer>getValue(ConfigValues.VmPoolMaxSubsequentFailures);
    for (int i = 0; i < getParameters().getVmsCount(); i++) {
        String currentVmName = generateUniqueVmName();
        ActionReturnValue returnValue = runInternalAction(ActionType.AddVm, buildAddVmParameters(currentVmName), createAddVmStepContext(currentVmName));
        if (returnValue != null && !returnValue.getSucceeded() && !returnValue.getValidationMessages().isEmpty()) {
            for (String msg : returnValue.getValidationMessages()) {
                if (!getReturnValue().getValidationMessages().contains(msg)) {
                    getReturnValue().getValidationMessages().add(msg);
                }
            }
            allAddVmsSucceeded = false;
            subsequentFailedAttempts++;
        } else {
            // Succeed on that, reset subsequentFailedAttempts.
            subsequentFailedAttempts = 0;
            anyAddVmSucceeded = true;
        }
        // if subsequent attempts failure exceeds configuration value , abort the loop.
        if (subsequentFailedAttempts == vmPoolMaxSubsequentFailures) {
            auditLogDirector.log(this, AuditLogType.USER_VM_POOL_MAX_SUBSEQUENT_FAILURES_REACHED);
            break;
        }
    }
}
#end_block

#method_before
private Snapshot addSnapshotToDB(Guid snapshotId, MemoryImageBuilder memoryImageBuilder) {
    // Reset cachedSelectedActiveDisks so new Cinder volumes can be fetched when calling getDisksList.
    cachedSelectedActiveDisks = null;
    return getSnapshotsManager().addSnapshot(snapshotId, getParameters().getDescription(), SnapshotStatus.LOCKED, getParameters().getSnapshotType(), getVm(), true, memoryImageBuilder.getVolumeStringRepresentation(), getDisksList(), getCompensationContext());
}
#method_after
private Snapshot addSnapshotToDB(Guid snapshotId, MemoryImageBuilder memoryImageBuilder) {
    // Reset cachedSelectedActiveDisks so new Cinder volumes can be fetched when calling getDisksList.
    cachedSelectedActiveDisks = null;
    return getSnapshotsManager().addSnapshot(snapshotId, getParameters().getDescription(), SnapshotStatus.LOCKED, getParameters().getSnapshotType(), getVm(), true, memoryImageBuilder.getVolumeStringRepresentation(), null, getDisksList(), getCompensationContext());
}
#end_block

#method_before
private void createSnapshotsForDisks() {
    for (DiskImage disk : getDisksList()) {
        if (disk.getDiskStorageType() == DiskStorageType.CINDER) {
            CreateCinderSnapshotParameters params = buildChildCommandParameters(disk);
            params.setQuotaId(disk.getQuotaId());
            Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(ActionType.CreateCinderSnapshot, params, cloneContext().withoutCompensationContext().withoutLock());
            try {
                VdcReturnValueBase vdcReturnValueBase = future.get();
                if (!vdcReturnValueBase.getSucceeded()) {
                    log.error("Error creating snapshot for Cinder disk '{}'", disk.getDiskAlias());
                    throw new EngineException(EngineError.CINDER_ERROR, "Failed to create snapshot!");
                }
            } catch (InterruptedException | ExecutionException e) {
                log.error("Error creating snapshot for Cinder disk '{}': {}", disk.getDiskAlias(), e.getMessage());
                throw new EngineException(EngineError.CINDER_ERROR, "Failed to create snapshot!");
            }
            continue;
        }
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(ActionType.CreateSnapshot, buildCreateSnapshotParameters(disk), ExecutionHandler.createDefaultContextForTasks(getContext()));
        if (vdcReturnValue.getSucceeded()) {
            getTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
        } else {
            throw new EngineException(vdcReturnValue.getFault().getError(), "Failed to create snapshot!");
        }
    }
}
#method_after
private void createSnapshotsForDisks() {
    for (DiskImage disk : getDisksList()) {
        if (disk.getDiskStorageType() == DiskStorageType.CINDER) {
            CreateCinderSnapshotParameters params = buildChildCommandParameters(disk);
            params.setQuotaId(disk.getQuotaId());
            Future<ActionReturnValue> future = CommandCoordinatorUtil.executeAsyncCommand(ActionType.CreateCinderSnapshot, params, cloneContext().withoutCompensationContext().withoutLock());
            try {
                ActionReturnValue actionReturnValue = future.get();
                if (!actionReturnValue.getSucceeded()) {
                    log.error("Error creating snapshot for Cinder disk '{}'", disk.getDiskAlias());
                    throw new EngineException(EngineError.CINDER_ERROR, "Failed to create snapshot!");
                }
            } catch (InterruptedException | ExecutionException e) {
                log.error("Error creating snapshot for Cinder disk '{}': {}", disk.getDiskAlias(), e.getMessage());
                throw new EngineException(EngineError.CINDER_ERROR, "Failed to create snapshot!");
            }
            continue;
        }
        ActionReturnValue actionReturnValue = Backend.getInstance().runInternalAction(ActionType.CreateSnapshot, buildCreateSnapshotParameters(disk), ExecutionHandler.createDefaultContextForTasks(getContext()));
        if (actionReturnValue.getSucceeded()) {
            getTaskIdList().addAll(actionReturnValue.getInternalVdsmTaskIdList());
        } else {
            throw new EngineException(actionReturnValue.getFault().getError(), "Failed to create snapshot!");
        }
    }
}
#end_block

#method_before
private void removeMemoryVolumesOfSnapshot(Snapshot snapshot) {
    VdcReturnValueBase retVal = runInternalAction(ActionType.RemoveMemoryVolumes, new RemoveMemoryVolumesParameters(snapshot.getMemoryVolume(), getVmId()), cloneContextAndDetachFromParent());
    if (!retVal.getSucceeded()) {
        log.error("Failed to remove memory volumes of snapshot '{}' ({})", snapshot.getDescription(), snapshot.getId());
    }
}
#method_after
private void removeMemoryVolumesOfSnapshot(Snapshot snapshot) {
    ActionReturnValue retVal = runInternalAction(ActionType.RemoveMemoryVolumes, new RemoveMemoryVolumesParameters(snapshot.getMemoryVolume(), getVmId()), cloneContextAndDetachFromParent());
    if (!retVal.getSucceeded()) {
        log.error("Failed to remove memory volumes of snapshot '{}' ({})", snapshot.getDescription(), snapshot.getId());
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    lockImageInDb();
    List<DiskImage> images = diskImageDao.getAllSnapshotsForImageGroup(getParameters().getImageGroupID());
    getParameters().setImageIds(ImagesHandler.getDiskImageIds(images.stream().filter(DiskImageBase::isQcowFormat).collect(Collectors.toList())));
    persistCommand(getActionType(), getCallback() != null);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    lockImageInDb();
    List<DiskImage> images = diskImageDao.getAllSnapshotsForImageGroup(getParameters().getImageGroupID());
    getParameters().setImageIds(ImagesHandler.getDiskImageIds(images.stream().filter(disk -> disk.isQcowFormat() && disk.getQcowCompat() != getParameters().getQcowCompat()).collect(Collectors.toList())));
    persistCommand(getActionType(), getCallback() != null);
    setSucceeded(true);
}
#end_block

#method_before
private void removeMemoryVolumes() {
    Set<String> memoryStates = MemoryUtils.getMemoryVolumesFromSnapshots(snapshotDao.getAll(getVmId()));
    for (String memoryState : memoryStates) {
        VdcReturnValueBase retVal = runInternalAction(ActionType.RemoveMemoryVolumes, buildRemoveMemoryVolumesParameters(memoryState, getVmId()), cloneContextAndDetachFromParent());
        if (!retVal.getSucceeded()) {
            log.error("Failed to remove memory volumes while removing vm '{}' (volumes: '{}')", getVmId(), memoryState);
        }
    }
}
#method_after
private void removeMemoryVolumes() {
    Set<String> memoryStates = MemoryUtils.getMemoryVolumesFromSnapshots(snapshotDao.getAll(getVmId()));
    for (String memoryState : memoryStates) {
        ActionReturnValue retVal = runInternalAction(ActionType.RemoveMemoryVolumes, buildRemoveMemoryVolumesParameters(memoryState, getVmId()), cloneContextAndDetachFromParent());
        if (!retVal.getSucceeded()) {
            log.error("Failed to remove memory volumes while removing vm '{}' (volumes: '{}')", getVmId(), memoryState);
        }
    }
}
#end_block

#method_before
protected VdcReturnValueBase removeVmImages(List<DiskImage> images) {
    VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(ActionType.RemoveAllVmImages, buildRemoveAllVmImagesParameters(images));
    if (vdcRetValue.getSucceeded()) {
        getTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
    return vdcRetValue;
}
#method_after
protected ActionReturnValue removeVmImages(List<DiskImage> images) {
    ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.RemoveAllVmImages, buildRemoveAllVmImagesParameters(images));
    if (vdcRetValue.getSucceeded()) {
        getTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
    return vdcRetValue;
}
#end_block

#method_before
private Collection<CinderDisk> removeCinderDisks() {
    Collection<CinderDisk> failedRemoveCinderDisks = null;
    if (getParameters().isRemoveDisks()) {
        List<CinderDisk> cinderDisks = getCinderDisks();
        if (cinderDisks.isEmpty()) {
            return Collections.emptyList();
        }
        RemoveAllVmCinderDisksParameters param = new RemoveAllVmCinderDisksParameters(getVmId(), cinderDisks);
        param.setEndProcedure(EndProcedure.COMMAND_MANAGED);
        Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(ActionType.RemoveAllVmCinderDisks, withRootCommandInfo(param), cloneContextAndDetachFromParent());
        try {
            failedRemoveCinderDisks = future.get().getActionReturnValue();
        } catch (InterruptedException | ExecutionException e) {
            failedRemoveCinderDisks = cinderDisks;
            log.error("Exception", e);
        }
    }
    return failedRemoveCinderDisks;
}
#method_after
private Collection<CinderDisk> removeCinderDisks() {
    Collection<CinderDisk> failedRemoveCinderDisks = null;
    if (getParameters().isRemoveDisks()) {
        List<CinderDisk> cinderDisks = getCinderDisks();
        if (cinderDisks.isEmpty()) {
            return Collections.emptyList();
        }
        RemoveAllVmCinderDisksParameters param = new RemoveAllVmCinderDisksParameters(getVmId(), cinderDisks);
        param.setEndProcedure(EndProcedure.COMMAND_MANAGED);
        Future<ActionReturnValue> future = CommandCoordinatorUtil.executeAsyncCommand(ActionType.RemoveAllVmCinderDisks, withRootCommandInfo(param), cloneContextAndDetachFromParent());
        try {
            failedRemoveCinderDisks = future.get().getActionReturnValue();
        } catch (InterruptedException | ExecutionException e) {
            failedRemoveCinderDisks = cinderDisks;
            log.error("Exception", e);
        }
    }
    return failedRemoveCinderDisks;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    switch(getDisk().getDiskStorageType()) {
        case IMAGE:
            VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(ActionType.RemoveImage, buildRemoveImageParameters(getDiskImage()));
            if (vdcReturnValue.getSucceeded()) {
                incrementVmsGeneration();
                getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                setSucceeded(true);
            }
            break;
        case LUN:
            removeLunDisk();
            break;
        case CINDER:
            RemoveCinderDiskParameters params = new RemoveCinderDiskParameters(getParameters().getDiskId());
            params.setEndProcedure(EndProcedure.COMMAND_MANAGED);
            Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(ActionType.RemoveCinderDisk, params, cloneContextAndDetachFromParent());
            try {
                setReturnValue(future.get());
                setSucceeded(getReturnValue().getSucceeded());
            } catch (InterruptedException | ExecutionException e) {
                log.error("Error removing Cinder disk '{}': {}", getDiskImage().getDiskAlias(), e.getMessage());
                log.debug("Exception", e);
            }
            break;
    }
}
#method_after
@Override
protected void executeCommand() {
    switch(getDisk().getDiskStorageType()) {
        case IMAGE:
            ActionReturnValue actionReturnValue = runInternalActionWithTasksContext(ActionType.RemoveImage, buildRemoveImageParameters(getDiskImage()));
            if (actionReturnValue.getSucceeded()) {
                incrementVmsGeneration();
                getReturnValue().getVdsmTaskIdList().addAll(actionReturnValue.getInternalVdsmTaskIdList());
                setSucceeded(true);
            }
            break;
        case LUN:
            removeLunDisk();
            break;
        case CINDER:
            RemoveCinderDiskParameters params = new RemoveCinderDiskParameters(getParameters().getDiskId());
            params.setEndProcedure(EndProcedure.COMMAND_MANAGED);
            Future<ActionReturnValue> future = CommandCoordinatorUtil.executeAsyncCommand(ActionType.RemoveCinderDisk, params, cloneContextAndDetachFromParent());
            try {
                setReturnValue(future.get());
                setSucceeded(getReturnValue().getSucceeded());
            } catch (InterruptedException | ExecutionException e) {
                log.error("Error removing Cinder disk '{}': {}", getDiskImage().getDiskAlias(), e.getMessage());
                log.debug("Exception", e);
            }
            break;
    }
}
#end_block

#method_before
private void revertCinderVolume(CinderDisk diskVolumeVolume) {
    RemoveCinderDiskVolumeParameters removeDiskVolumeParam = new RemoveCinderDiskVolumeParameters(diskVolumeVolume);
    Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(ActionType.RemoveCinderDiskVolume, removeDiskVolumeParam, null);
    try {
        future.get();
    } catch (InterruptedException | ExecutionException e) {
        log.error("Fail to revert snapshot id '{}' for disk id '{}'. Exception: {}", diskVolumeVolume.getImageId(), diskVolumeVolume.getId(), e);
    }
}
#method_after
private void revertCinderVolume(CinderDisk diskVolumeVolume) {
    RemoveCinderDiskVolumeParameters removeDiskVolumeParam = new RemoveCinderDiskVolumeParameters(diskVolumeVolume);
    Future<ActionReturnValue> future = CommandCoordinatorUtil.executeAsyncCommand(ActionType.RemoveCinderDiskVolume, removeDiskVolumeParam, null);
    try {
        future.get();
    } catch (InterruptedException | ExecutionException e) {
        log.error("Fail to revert snapshot id '{}' for disk id '{}'. Exception: {}", diskVolumeVolume.getImageId(), diskVolumeVolume.getId(), e);
    }
}
#end_block

#method_before
@Override
protected void revertTasks() {
    Guid destImageId = getDestinationDiskImage().getImageId();
    RemoveImageParameters p = new RemoveImageParameters(destImageId);
    p.setEntityInfo(new EntityInfo(VdcObjectType.Disk, destImageId));
    p.setParentParameters(p);
    p.setParentCommand(ActionType.RemoveImage);
    VdcReturnValueBase returnValue = checkAndPerformRollbackUsingCommand(ActionType.RemoveImage, p, null);
    if (returnValue.getSucceeded()) {
        startPollingAsyncTasks(returnValue.getInternalVdsmTaskIdList());
    }
}
#method_after
@Override
protected void revertTasks() {
    Guid destImageId = getDestinationDiskImage().getImageId();
    RemoveImageParameters p = new RemoveImageParameters(destImageId);
    p.setEntityInfo(new EntityInfo(VdcObjectType.Disk, destImageId));
    p.setParentParameters(p);
    p.setParentCommand(ActionType.RemoveImage);
    ActionReturnValue returnValue = checkAndPerformRollbackUsingCommand(ActionType.RemoveImage, p, null);
    if (returnValue.getSucceeded()) {
        startPollingAsyncTasks(returnValue.getInternalVdsmTaskIdList());
    }
}
#end_block

#method_before
private Guid createDisk(DiskImage image, boolean isBoot) {
    image.setDiskAlias(renameDiskAlias(getVm().getOrigin(), image.getDiskAlias()));
    AddDiskParameters diskParameters = new AddDiskParameters(new DiskVmElement(null, getVmId()), image);
    diskParameters.setStorageDomainId(getStorageDomainId());
    diskParameters.setParentCommand(getActionType());
    diskParameters.setParentParameters(getParameters());
    diskParameters.setShouldRemainIllegalOnFailedExecution(true);
    diskParameters.setStorageDomainId(getParameters().getDestDomainId());
    DiskVmElement dve = new DiskVmElement(image.getId(), getVmId());
    dve.setDiskInterface(DiskInterface.VirtIO);
    dve.setBoot(isBoot);
    diskParameters.setDiskVmElement(dve);
    VdcReturnValueBase vdcReturnValueBase = runInternalActionWithTasksContext(ActionType.AddDisk, diskParameters);
    if (!vdcReturnValueBase.getSucceeded()) {
        throw new EngineException(vdcReturnValueBase.getFault().getError(), "Failed to create disk!");
    }
    getTaskIdList().addAll(vdcReturnValueBase.getInternalVdsmTaskIdList());
    return vdcReturnValueBase.getActionReturnValue();
}
#method_after
private Guid createDisk(DiskImage image, boolean isBoot) {
    image.setDiskAlias(renameDiskAlias(getVm().getOrigin(), image.getDiskAlias()));
    AddDiskParameters diskParameters = new AddDiskParameters(new DiskVmElement(null, getVmId()), image);
    diskParameters.setStorageDomainId(getStorageDomainId());
    diskParameters.setParentCommand(getActionType());
    diskParameters.setParentParameters(getParameters());
    diskParameters.setShouldRemainIllegalOnFailedExecution(true);
    diskParameters.setStorageDomainId(getParameters().getDestDomainId());
    DiskVmElement dve = new DiskVmElement(image.getId(), getVmId());
    dve.setDiskInterface(DiskInterface.VirtIO);
    dve.setBoot(isBoot);
    diskParameters.setDiskVmElement(dve);
    ActionReturnValue actionReturnValue = runInternalActionWithTasksContext(ActionType.AddDisk, diskParameters);
    if (!actionReturnValue.getSucceeded()) {
        throw new EngineException(actionReturnValue.getFault().getError(), "Failed to create disk!");
    }
    getTaskIdList().addAll(actionReturnValue.getInternalVdsmTaskIdList());
    return actionReturnValue.getActionReturnValue();
}
#end_block

#method_before
private DiskImage getDisk(Guid diskId) {
    return runInternalQuery(VdcQueryType.GetDiskByDiskId, new IdQueryParameters(diskId)).getReturnValue();
}
#method_after
private DiskImage getDisk(Guid diskId) {
    return runInternalQuery(QueryType.GetDiskByDiskId, new IdQueryParameters(diskId)).getReturnValue();
}
#end_block

#method_before
@Override
protected void moveOrCopyAllImageGroups(final Guid containerID, final Iterable<DiskImage> disks) {
    TransactionSupport.executeInNewTransaction(() -> {
        for (DiskImage disk : disks) {
            // we force export template image to COW+Sparse but we don't update
            // the ovf so the import
            // will set the original format
            MoveOrCopyImageGroupParameters p = new MoveOrCopyImageGroupParameters(containerID, disk.getId(), disk.getImageId(), getParameters().getStorageDomainId(), ImageOperation.Copy);
            p.setParentCommand(getActionType());
            p.setParentParameters(getParameters());
            p.setEntityInfo(getParameters().getEntityInfo());
            p.setUseCopyCollapse(true);
            p.setCopyVolumeType(CopyVolumeType.SharedVol);
            p.setVolumeFormat(disk.getVolumeFormat());
            p.setVolumeType(disk.getVolumeType());
            p.setForceOverride(getParameters().getForceOverride());
            p.setRevertDbOperationScope(ImageDbOperationScope.NONE);
            p.setShouldLockImageOnRevert(false);
            p.setSourceDomainId(imageFromSourceDomainMap.get(disk.getId()).getStorageIds().get(0));
            VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, p);
            if (!vdcRetValue.getSucceeded()) {
                throw new EngineException(vdcRetValue.getFault().getError(), vdcRetValue.getFault().getMessage());
            }
            getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        }
        return null;
    });
}
#method_after
@Override
protected void moveOrCopyAllImageGroups(final Guid containerID, final Iterable<DiskImage> disks) {
    TransactionSupport.executeInNewTransaction(() -> {
        for (DiskImage disk : disks) {
            // we force export template image to COW+Sparse but we don't update
            // the ovf so the import
            // will set the original format
            MoveOrCopyImageGroupParameters p = new MoveOrCopyImageGroupParameters(containerID, disk.getId(), disk.getImageId(), getParameters().getStorageDomainId(), ImageOperation.Copy);
            p.setParentCommand(getActionType());
            p.setParentParameters(getParameters());
            p.setEntityInfo(getParameters().getEntityInfo());
            p.setUseCopyCollapse(true);
            p.setCopyVolumeType(CopyVolumeType.SharedVol);
            p.setVolumeFormat(disk.getVolumeFormat());
            p.setVolumeType(disk.getVolumeType());
            p.setForceOverride(getParameters().getForceOverride());
            p.setRevertDbOperationScope(ImageDbOperationScope.NONE);
            p.setShouldLockImageOnRevert(false);
            p.setSourceDomainId(imageFromSourceDomainMap.get(disk.getId()).getStorageIds().get(0));
            ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, p);
            if (!vdcRetValue.getSucceeded()) {
                throw new EngineException(vdcRetValue.getFault().getError(), vdcRetValue.getFault().getMessage());
            }
            getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        }
        return null;
    });
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (isUnregisteredDiskExistsForCopyTemplate()) {
        addDiskMapping();
        return;
    }
    MoveOrCopyImageGroupParameters p = prepareChildParameters();
    VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(getImagesActionType(), p);
    if (!vdcRetValue.getSucceeded()) {
        setSucceeded(false);
        getReturnValue().setFault(vdcRetValue.getFault());
    } else {
        setSucceeded(true);
        if (isCopyOperation() && !isTemplate()) {
            imagesHandler.addDiskImageWithNoVmDevice(getImage());
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    if (isUnregisteredDiskExistsForCopyTemplate()) {
        addDiskMapping();
        return;
    }
    MoveOrCopyImageGroupParameters p = prepareChildParameters();
    ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(getImagesActionType(), p);
    if (!vdcRetValue.getSucceeded()) {
        setSucceeded(false);
        getReturnValue().setFault(vdcRetValue.getFault());
    } else {
        setSucceeded(true);
        if (isCopyOperation() && !isTemplate()) {
            imagesHandler.addDiskImageWithNoVmDevice(getImage());
        }
    }
}
#end_block

#method_before
protected Future<VdcReturnValueBase> getFutureRemoveCinderDiskVolume(Guid storageId, int removedChildCommandParametersIndex) {
    return CommandCoordinatorUtil.executeAsyncCommand(ActionType.RemoveCinderDiskVolume, getParameters().getChildCommandsParameters().get(removedChildCommandParametersIndex), cloneContextAndDetachFromParent());
}
#method_after
protected Future<ActionReturnValue> getFutureRemoveCinderDiskVolume(Guid storageId, int removedChildCommandParametersIndex) {
    return CommandCoordinatorUtil.executeAsyncCommand(ActionType.RemoveCinderDiskVolume, getParameters().getChildCommandsParameters().get(removedChildCommandParametersIndex), cloneContextAndDetachFromParent());
}
#end_block

#method_before
public boolean removeCinderVolume(int removedVolumeIndex, Guid storageId) {
    RemoveCinderDiskVolumeParameters param = getParameters().getChildCommandsParameters().get(removedVolumeIndex);
    try {
        VdcReturnValueBase vdcReturnValueBase = getFutureRemoveCinderDiskVolume(storageId, removedVolumeIndex).get();
        if (vdcReturnValueBase == null || !vdcReturnValueBase.getSucceeded()) {
            handleExecutionFailure(param.getRemovedVolume(), vdcReturnValueBase);
            return false;
        }
    } catch (InterruptedException | ExecutionException e) {
        log.error("Error removing Cinder disk volume. Exception: {}", e);
        return false;
    }
    return true;
}
#method_after
public boolean removeCinderVolume(int removedVolumeIndex, Guid storageId) {
    RemoveCinderDiskVolumeParameters param = getParameters().getChildCommandsParameters().get(removedVolumeIndex);
    try {
        ActionReturnValue actionReturnValue = getFutureRemoveCinderDiskVolume(storageId, removedVolumeIndex).get();
        if (actionReturnValue == null || !actionReturnValue.getSucceeded()) {
            handleExecutionFailure(param.getRemovedVolume(), actionReturnValue);
            return false;
        }
    } catch (InterruptedException | ExecutionException e) {
        log.error("Error removing Cinder disk volume. Exception: {}", e);
        return false;
    }
    return true;
}
#end_block

#method_before
protected void handleExecutionFailure(CinderDisk disk, VdcReturnValueBase vdcReturnValueBase) {
    log.error("Failed to remove cider volume id '{}' for disk id '{}'.", disk.getImageId(), disk.getId());
    EngineFault fault = vdcReturnValueBase == null ? new EngineFault() : vdcReturnValueBase.getFault();
    getReturnValue().setFault(fault);
}
#method_after
protected void handleExecutionFailure(CinderDisk disk, ActionReturnValue actionReturnValue) {
    log.error("Failed to remove cider volume id '{}' for disk id '{}'.", disk.getImageId(), disk.getId());
    EngineFault fault = actionReturnValue == null ? new EngineFault() : actionReturnValue.getFault();
    getReturnValue().setFault(fault);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
protected List<VM> getVmsFromExportDomain() {
    VdcQueryReturnValue qRetVal = runInternalQuery(VdcQueryType.GetVmsFromExportDomain, new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId()));
    return (List<VM>) (qRetVal.getSucceeded() ? qRetVal.getReturnValue() : Collections.emptyList());
}
#method_after
@SuppressWarnings("unchecked")
protected List<VM> getVmsFromExportDomain() {
    QueryReturnValue qRetVal = runInternalQuery(QueryType.GetVmsFromExportDomain, new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId()));
    return (List<VM>) (qRetVal.getSucceeded() ? qRetVal.getReturnValue() : Collections.emptyList());
}
#end_block

#method_before
private boolean isTemplateExistsOnExportDomain() {
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getParameters().getVm().getVmtGuid())) {
        return true;
    }
    VdcQueryReturnValue qRetVal = runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId()));
    if (qRetVal.getSucceeded()) {
        Map<VmTemplate, ?> templates = qRetVal.getReturnValue();
        for (VmTemplate template : templates.keySet()) {
            if (getParameters().getVm().getVmtGuid().equals(template.getId())) {
                return true;
            }
        }
    }
    return false;
}
#method_after
private boolean isTemplateExistsOnExportDomain() {
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getParameters().getVm().getVmtGuid())) {
        return true;
    }
    QueryReturnValue qRetVal = runInternalQuery(QueryType.GetTemplatesFromExportDomain, new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId()));
    if (qRetVal.getSucceeded()) {
        Map<VmTemplate, ?> templates = qRetVal.getReturnValue();
        for (VmTemplate template : templates.keySet()) {
            if (getParameters().getVm().getVmtGuid().equals(template.getId())) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = validate(getImportValidator().verifyDisks(imageList, imageToDestinationDomainMap));
    if (retValue && !VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && !getParameters().getCopyCollapse()) {
        List<StorageDomain> domains = runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new IdQueryParameters(getVm().getVmtGuid())).getReturnValue();
        Set<Guid> domainsId = domains.stream().map(StorageDomain::getId).collect(Collectors.toSet());
        if (!domainsId.isEmpty() && Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#method_after
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = validate(getImportValidator().verifyDisks(imageList, imageToDestinationDomainMap));
    if (retValue && !VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && !getParameters().getCopyCollapse()) {
        List<StorageDomain> domains = runInternalQuery(QueryType.GetStorageDomainsByVmTemplateId, new IdQueryParameters(getVm().getVmtGuid())).getReturnValue();
        Set<Guid> domainsId = domains.stream().map(StorageDomain::getId).collect(Collectors.toSet());
        if (!domainsId.isEmpty() && Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#end_block

#method_before
private void copyAllMemoryImages(Guid containerId) {
    for (String memoryVolumes : MemoryUtils.getMemoryVolumesFromSnapshots(getVm().getSnapshots())) {
        List<Guid> guids = GuidUtils.getGuidListFromString(memoryVolumes);
        // copy the memory dump image
        VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryDumpImage(containerId, guids.get(0), guids.get(2), guids.get(3)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed to copy memory image");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        // copy the memory configuration (of the VM) image
        vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryConfImage(containerId, guids.get(0), guids.get(4), guids.get(5)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed to copy metadata image");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#method_after
private void copyAllMemoryImages(Guid containerId) {
    for (String memoryVolumes : MemoryUtils.getMemoryVolumesFromSnapshots(getVm().getSnapshots())) {
        List<Guid> guids = GuidUtils.getGuidListFromString(memoryVolumes);
        // copy the memory dump image
        ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryDumpImage(containerId, guids.get(0), guids.get(2), guids.get(3)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed to copy memory image");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        // copy the memory configuration (of the VM) image
        vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryConfImage(containerId, guids.get(0), guids.get(4), guids.get(5)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed to copy metadata image");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#end_block

#method_before
protected void moveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForDisk(disk, containerID));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed to copy disk!");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#method_after
protected void moveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForDisk(disk, containerID));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed to copy disk!");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#end_block

#method_before
private void removeMemoryVolumes(String memoryVolume, Guid vmId) {
    VdcReturnValueBase retVal = runInternalAction(ActionType.RemoveMemoryVolumes, new RemoveMemoryVolumesParameters(memoryVolume, vmId), cloneContextAndDetachFromParent());
    if (!retVal.getSucceeded()) {
        log.error("Failed to remove memory volumes '{}'", memoryVolume);
    }
}
#method_after
private void removeMemoryVolumes(String memoryVolume, Guid vmId) {
    ActionReturnValue retVal = runInternalAction(ActionType.RemoveMemoryVolumes, new RemoveMemoryVolumesParameters(memoryVolume, vmId), cloneContextAndDetachFromParent());
    if (!retVal.getSucceeded()) {
        log.error("Failed to remove memory volumes '{}'", memoryVolume);
    }
}
#end_block

#method_before
protected List<VdcReturnValueBase> endActionOnDisks() {
    List<VdcReturnValueBase> returnValues = new ArrayList<>();
    for (ActionParametersBase p : getParametersForChildCommand()) {
        if (overrideChildCommandSuccess()) {
            p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        }
        VdcReturnValueBase returnValue = getBackend().endAction(p.getCommandType() == ActionType.Unknown ? getChildActionType() : p.getCommandType(), p, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
        returnValues.add(returnValue);
    }
    return returnValues;
}
#method_after
protected List<ActionReturnValue> endActionOnDisks() {
    List<ActionReturnValue> returnValues = new ArrayList<>();
    for (ActionParametersBase p : getParametersForChildCommand()) {
        if (overrideChildCommandSuccess()) {
            p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        }
        ActionReturnValue returnValue = getBackend().endAction(p.getCommandType() == ActionType.Unknown ? getChildActionType() : p.getCommandType(), p, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
        returnValues.add(returnValue);
    }
    return returnValues;
}
#end_block

#method_before
protected boolean removeMemoryDisks(String memory) {
    List<Guid> guids = GuidUtils.getGuidListFromString(memory);
    RemoveDiskParameters removeMemoryDumpDiskParameters = new RemoveDiskParameters(guids.get(2));
    removeMemoryDumpDiskParameters.setShouldBeLogged(false);
    removeMemoryDumpDiskParameters.setSuppressContentTypeCheck(true);
    VdcReturnValueBase retVal = runInternalAction(ActionType.RemoveDisk, removeMemoryDumpDiskParameters);
    if (!retVal.getSucceeded()) {
        return false;
    }
    RemoveDiskParameters removeMemoryMetadataDiskParameters = new RemoveDiskParameters(guids.get(4));
    removeMemoryMetadataDiskParameters.setShouldBeLogged(false);
    removeMemoryMetadataDiskParameters.setSuppressContentTypeCheck(true);
    retVal = runInternalAction(ActionType.RemoveDisk, removeMemoryMetadataDiskParameters);
    if (!retVal.getSucceeded()) {
        return false;
    }
    return true;
}
#method_after
protected boolean removeMemoryDisks(String memory) {
    List<Guid> guids = GuidUtils.getGuidListFromString(memory);
    RemoveDiskParameters removeMemoryDumpDiskParameters = new RemoveDiskParameters(guids.get(2));
    removeMemoryDumpDiskParameters.setShouldBeLogged(false);
    removeMemoryDumpDiskParameters.setSuppressContentTypeCheck(true);
    ActionReturnValue retVal = runInternalAction(ActionType.RemoveDisk, removeMemoryDumpDiskParameters);
    if (!retVal.getSucceeded()) {
        return false;
    }
    RemoveDiskParameters removeMemoryMetadataDiskParameters = new RemoveDiskParameters(guids.get(4));
    removeMemoryMetadataDiskParameters.setShouldBeLogged(false);
    removeMemoryMetadataDiskParameters.setSuppressContentTypeCheck(true);
    retVal = runInternalAction(ActionType.RemoveDisk, removeMemoryMetadataDiskParameters);
    if (!retVal.getSucceeded()) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected void copyDiskImage(DiskImage diskImage, Guid srcStorageDomainId, Guid destStorageDomainId, Guid diskProfileId, ActionType parentCommandType) {
    DiskImage newDiskImage = imagesHandler.cloneDiskImage(destStorageDomainId, Guid.newGuid(), Guid.newGuid(), diskImage, diskProfileId, getVmSnapshotId(), diskInfoDestinationMap != null ? diskInfoDestinationMap.get(diskImage.getId()) : null);
    ImagesHandler.setDiskAlias(newDiskImage, getVm());
    MoveOrCopyImageGroupParameters parameters = createCopyParameters(newDiskImage, srcStorageDomainId, diskImage.getId(), diskImage.getImageId(), parentCommandType);
    parameters.setRevertDbOperationScope(ImageDbOperationScope.IMAGE);
    VdcReturnValueBase result = executeChildCopyingCommand(parameters);
    handleCopyResult(diskImage, newDiskImage, result);
}
#method_after
protected void copyDiskImage(DiskImage diskImage, Guid srcStorageDomainId, Guid destStorageDomainId, Guid diskProfileId, ActionType parentCommandType) {
    DiskImage newDiskImage = imagesHandler.cloneDiskImage(destStorageDomainId, Guid.newGuid(), Guid.newGuid(), diskImage, diskProfileId, getVmSnapshotId(), diskInfoDestinationMap != null ? diskInfoDestinationMap.get(diskImage.getId()) : null);
    ImagesHandler.setDiskAlias(newDiskImage, getVm());
    MoveOrCopyImageGroupParameters parameters = createCopyParameters(newDiskImage, srcStorageDomainId, diskImage.getId(), diskImage.getImageId(), parentCommandType);
    parameters.setRevertDbOperationScope(ImageDbOperationScope.IMAGE);
    ActionReturnValue result = executeChildCopyingCommand(parameters);
    handleCopyResult(diskImage, newDiskImage, result);
}
#end_block

#method_before
private void handleCopyResult(DiskImage srcDiskImage, DiskImage copiedDiskImage, VdcReturnValueBase result) {
    // If a copy cannot be made, abort
    if (!result.getSucceeded()) {
        throw new EngineException(EngineError.VolumeCreationError);
    } else {
        imagesHandler.addDiskImageWithNoVmDevice(copiedDiskImage);
        getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
        getSrcDiskIdToTargetDiskIdMapping().put(srcDiskImage.getId(), copiedDiskImage.getId());
    }
}
#method_after
private void handleCopyResult(DiskImage srcDiskImage, DiskImage copiedDiskImage, ActionReturnValue result) {
    // If a copy cannot be made, abort
    if (!result.getSucceeded()) {
        throw new EngineException(EngineError.VolumeCreationError);
    } else {
        imagesHandler.addDiskImageWithNoVmDevice(copiedDiskImage);
        getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
        getSrcDiskIdToTargetDiskIdMapping().put(srcDiskImage.getId(), copiedDiskImage.getId());
    }
}
#end_block

#method_before
protected VdcReturnValueBase executeChildCopyingCommand(ActionParametersBase parameters) {
    return runInternalActionWithTasksContext(getChildActionType(), parameters);
}
#method_after
protected ActionReturnValue executeChildCopyingCommand(ActionParametersBase parameters) {
    return runInternalActionWithTasksContext(getChildActionType(), parameters);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    imagesHandler.updateAllDiskImagesSnapshotsStatusInTransactionWithCompensation(getMovedDiskIds(), ImageStatus.LOCKED, ImageStatus.OK, getCompensationContext());
    VdcReturnValueBase vdcReturnValue = runInternalAction(ActionType.CreateAllSnapshotsFromVm, getCreateSnapshotParameters(), ExecutionHandler.createInternalJobContext(getContext()));
    getParameters().setAutoGeneratedSnapshotId(vdcReturnValue.getActionReturnValue());
    persistCommand(getParameters().getParentCommand(), getCallback() != null);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    imagesHandler.updateAllDiskImagesSnapshotsStatusInTransactionWithCompensation(getMovedDiskIds(), ImageStatus.LOCKED, ImageStatus.OK, getCompensationContext());
    ActionReturnValue actionReturnValueurnValue = runInternalAction(ActionType.CreateAllSnapshotsFromVm, getCreateSnapshotParameters(), ExecutionHandler.createInternalJobContext(getContext()));
    getParameters().setAutoGeneratedSnapshotId(actionReturnValueurnValue.getActionReturnValue());
    persistCommand(getParameters().getParentCommand(), getCallback() != null);
    setSucceeded(true);
}
#end_block

#method_before
@Override
public boolean performNextOperation(int completedChildCount) {
    if (getParameters().getStage() == LiveMigrateStage.CREATE_SNAPSHOT) {
        updateStage(LiveMigrateStage.LIVE_MIGRATE_DISK_EXEC_START);
        for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
            parameters.setSessionId(getParameters().getSessionId());
            parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
            parameters.setParentCommand(getActionType());
            parameters.setParentParameters(getParameters());
            parameters.setDestinationImageId(((DiskImage) getDiskImageByDiskId(parameters.getImageGroupID())).getImageId());
            VdcReturnValueBase vdcReturnValue = runInternalAction(ActionType.LiveMigrateDisk, parameters, ExecutionHandler.createInternalJobContext());
            if (!vdcReturnValue.getSucceeded()) {
                imageDao.updateStatusOfImagesByImageGroupId(parameters.getImageGroupID(), ImageStatus.OK);
            }
        }
        updateStage(LiveMigrateStage.LIVE_MIGRATE_DISK_EXEC_COMPLETED);
        return true;
    }
    if (isRemoveAutoGeneratedSnapshotRequired()) {
        updateStage(LiveMigrateStage.AUTO_GENERATED_SNAPSHOT_REMOVE_START);
        removeAutogeneratedSnapshot();
        updateStage(LiveMigrateStage.AUTO_GENERATED_SNAPSHOT_REMOVE_END);
        return true;
    }
    return false;
}
#method_after
@Override
public boolean performNextOperation(int completedChildCount) {
    if (getParameters().getStage() == LiveMigrateStage.CREATE_SNAPSHOT) {
        updateStage(LiveMigrateStage.LIVE_MIGRATE_DISK_EXEC_START);
        for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
            parameters.setSessionId(getParameters().getSessionId());
            parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
            parameters.setParentCommand(getActionType());
            parameters.setParentParameters(getParameters());
            parameters.setDestinationImageId(((DiskImage) getDiskImageByDiskId(parameters.getImageGroupID())).getImageId());
            ActionReturnValue actionReturnValue = runInternalAction(ActionType.LiveMigrateDisk, parameters, ExecutionHandler.createInternalJobContext());
            if (!actionReturnValue.getSucceeded()) {
                imageDao.updateStatusOfImagesByImageGroupId(parameters.getImageGroupID(), ImageStatus.OK);
            }
        }
        updateStage(LiveMigrateStage.LIVE_MIGRATE_DISK_EXEC_COMPLETED);
        return true;
    }
    if (isRemoveAutoGeneratedSnapshotRequired()) {
        updateStage(LiveMigrateStage.AUTO_GENERATED_SNAPSHOT_REMOVE_START);
        removeAutogeneratedSnapshot();
        updateStage(LiveMigrateStage.AUTO_GENERATED_SNAPSHOT_REMOVE_END);
        return true;
    }
    return false;
}
#end_block

#method_before
protected boolean validateCreateAllSnapshotsFromVmCommand() {
    VdcReturnValueBase returnValue = CommandHelper.validate(ActionType.CreateAllSnapshotsFromVm, getCreateSnapshotParameters(), getContext().clone());
    if (!returnValue.isValid()) {
        getReturnValue().setValidationMessages(returnValue.getValidationMessages());
        return false;
    }
    return true;
}
#method_after
protected boolean validateCreateAllSnapshotsFromVmCommand() {
    ActionReturnValue returnValue = CommandHelper.validate(ActionType.CreateAllSnapshotsFromVm, getCreateSnapshotParameters(), getContext().clone());
    if (!returnValue.isValid()) {
        getReturnValue().setValidationMessages(returnValue.getValidationMessages());
        return false;
    }
    return true;
}
#end_block

#method_before
public Snapshot addActiveSnapshot(Guid snapshotId, VM vm, final CompensationContext compensationContext) {
    return addActiveSnapshot(snapshotId, vm, SnapshotStatus.OK, "", null, compensationContext);
}
#method_after
public Snapshot addActiveSnapshot(Guid snapshotId, VM vm, final CompensationContext compensationContext) {
    return addActiveSnapshot(snapshotId, vm, SnapshotStatus.OK, "", null, null, compensationContext);
}
#end_block

#method_before
public Snapshot addActiveSnapshot(Guid snapshotId, VM vm, SnapshotStatus snapshotStatus, final CompensationContext compensationContext) {
    return addActiveSnapshot(snapshotId, vm, snapshotStatus, "", null, compensationContext);
}
#method_after
public Snapshot addActiveSnapshot(Guid snapshotId, VM vm, SnapshotStatus snapshotStatus, final CompensationContext compensationContext) {
    return addActiveSnapshot(snapshotId, vm, snapshotStatus, "", null, null, compensationContext);
}
#end_block

#method_before
public Snapshot addActiveSnapshot(Guid snapshotId, VM vm, String memoryVolume, final CompensationContext compensationContext) {
    return addActiveSnapshot(snapshotId, vm, SnapshotStatus.OK, memoryVolume, null, compensationContext);
}
#method_after
public Snapshot addActiveSnapshot(Guid snapshotId, VM vm, String memoryVolume, final CompensationContext compensationContext) {
    return addActiveSnapshot(snapshotId, vm, SnapshotStatus.OK, memoryVolume, null, null, compensationContext);
}
#end_block

#method_before
public Snapshot addActiveSnapshot(Guid snapshotId, VM vm, SnapshotStatus snapshotStatus, String memoryVolume, List<DiskImage> disks, final CompensationContext compensationContext) {
    return addSnapshot(snapshotId, "Active VM", snapshotStatus, SnapshotType.ACTIVE, vm, false, memoryVolume, disks, compensationContext);
}
#method_after
public Snapshot addActiveSnapshot(Guid snapshotId, VM vm, String memoryVolume, Date creationDate, List<DiskImage> disks, final CompensationContext compensationContext) {
    return addActiveSnapshot(snapshotId, vm, SnapshotStatus.OK, memoryVolume, creationDate, disks, compensationContext);
}
#end_block

#method_before
public Snapshot addActiveSnapshot(Guid snapshotId, VM vm, SnapshotStatus snapshotStatus, String memoryVolume, final CompensationContext compensationContext) {
    return addActiveSnapshot(snapshotId, vm, snapshotStatus, memoryVolume, null, compensationContext);
}
#method_after
public Snapshot addActiveSnapshot(Guid snapshotId, VM vm, SnapshotStatus snapshotStatus, String memoryVolume, final CompensationContext compensationContext) {
    return addActiveSnapshot(snapshotId, vm, snapshotStatus, memoryVolume, null, null, compensationContext);
}
#end_block

#method_before
public Snapshot addSnapshot(Guid snapshotId, String description, SnapshotType snapshotType, VM vm, String memoryVolume, final CompensationContext compensationContext) {
    return addSnapshot(snapshotId, description, SnapshotStatus.LOCKED, snapshotType, vm, true, memoryVolume, null, compensationContext);
}
#method_after
public Snapshot addSnapshot(Guid snapshotId, String description, SnapshotType snapshotType, VM vm, String memoryVolume, final CompensationContext compensationContext) {
    return addSnapshot(snapshotId, description, SnapshotStatus.LOCKED, snapshotType, vm, true, memoryVolume, null, null, compensationContext);
}
#end_block

#method_before
public Snapshot addSnapshot(Guid snapshotId, String description, SnapshotStatus snapshotStatus, SnapshotType snapshotType, VM vm, boolean saveVmConfiguration, String memoryVolume, List<DiskImage> disks, Map<Guid, VmDevice> vmDevices, final CompensationContext compensationContext) {
    final Snapshot snapshot = new Snapshot(snapshotId, snapshotStatus, vm.getId(), saveVmConfiguration ? generateVmConfiguration(vm, disks, vmDevices) : null, snapshotType, description, new Date(), vm.getAppList(), memoryVolume, MemoryUtils.getMemoryDiskId(memoryVolume), MemoryUtils.getMetadataDiskId(memoryVolume));
    snapshotDao.save(snapshot);
    compensationContext.snapshotNewEntity(snapshot);
    return snapshot;
}
#method_after
public Snapshot addSnapshot(Guid snapshotId, String description, SnapshotStatus snapshotStatus, SnapshotType snapshotType, VM vm, boolean saveVmConfiguration, String memoryVolume, Date creationDate, List<DiskImage> disks, final CompensationContext compensationContext) {
    return addSnapshot(snapshotId, description, snapshotStatus, snapshotType, vm, saveVmConfiguration, memoryVolume, creationDate, disks, null, compensationContext);
}
#end_block

#method_before
public boolean updateVmFromConfiguration(VM vm, String configuration) {
    try {
        VmStatic oldVmStatic = vm.getStaticData();
        VM tempVM = new VM();
        ArrayList<DiskImage> images = new ArrayList<>();
        ArrayList<VmNetworkInterface> interfaces = new ArrayList<>();
        ovfManager.importVm(configuration, tempVM, images, interfaces);
        for (DiskImage diskImage : images) {
            DiskImage dbImage = diskImageDao.getSnapshotById(diskImage.getImageId());
            if (dbImage != null) {
                diskImage.setStorageIds(dbImage.getStorageIds());
            }
        }
        new VMStaticOvfLogHandler(tempVM.getStaticData()).resetDefaults(oldVmStatic);
        vm.setStaticData(tempVM.getStaticData());
        IconUtils.preserveIcons(vm.getStaticData(), oldVmStatic);
        vm.setImages(images);
        vm.setInterfaces(interfaces);
        // These fields are not saved in the OVF, so get them from the current VM.
        vm.setIsoPath(oldVmStatic.getIsoPath());
        vm.setCpuProfileId(oldVmStatic.getCpuProfileId());
        vm.setClusterId(oldVmStatic.getClusterId());
        // The VM configuration does not hold the vds group Id.
        // It is necessary to fetch the vm static from the Db, in order to get this information
        VmStatic vmStaticFromDb = vmStaticDao.get(vm.getId());
        if (vmStaticFromDb != null) {
            Cluster cluster = clusterDao.get(vmStaticFromDb.getClusterId());
            if (cluster != null) {
                vm.setStoragePoolId(cluster.getStoragePoolId());
                vm.setClusterCompatibilityVersion(cluster.getCompatibilityVersion());
                vm.setClusterName(cluster.getName());
                vm.setClusterCpuName(cluster.getCpuName());
            }
        }
        // if the required dedicated host is invalid -> use current VM dedicated host
        if (!vmHandler.validateDedicatedVdsExistOnSameCluster(vm.getStaticData(), null)) {
            vm.setDedicatedVmForVdsList(oldVmStatic.getDedicatedVmForVdsList());
        }
        VmHandler.updateMaxMemorySize(vm.getStaticData(), vm.getCompatibilityVersion());
        validateQuota(vm);
        return true;
    } catch (OvfReaderException e) {
        log.error("Failed to update VM from the configuration '{}': {}", configuration, e.getMessage());
        log.debug("Exception", e);
        return false;
    }
}
#method_after
public boolean updateVmFromConfiguration(VM vm, String configuration) {
    try {
        VmStatic oldVmStatic = vm.getStaticData();
        VM tempVM = new VM();
        if (vm.getDynamicData() != null) {
            tempVM.setDynamicData(vm.getDynamicData());
        }
        ArrayList<DiskImage> images = new ArrayList<>();
        ArrayList<VmNetworkInterface> interfaces = new ArrayList<>();
        ovfManager.importVm(configuration, tempVM, images, interfaces);
        for (DiskImage diskImage : images) {
            DiskImage dbImage = diskImageDao.getSnapshotById(diskImage.getImageId());
            if (dbImage != null) {
                diskImage.setStorageIds(dbImage.getStorageIds());
            }
        }
        new VMStaticOvfLogHandler(tempVM.getStaticData()).resetDefaults(oldVmStatic);
        vm.setStaticData(tempVM.getStaticData());
        IconUtils.preserveIcons(vm.getStaticData(), oldVmStatic);
        vm.setImages(images);
        vm.setInterfaces(interfaces);
        // These fields are not saved in the OVF, so get them from the current VM.
        vm.setIsoPath(oldVmStatic.getIsoPath());
        vm.setCpuProfileId(oldVmStatic.getCpuProfileId());
        vm.setClusterId(oldVmStatic.getClusterId());
        // The VM configuration does not hold the vds group Id.
        // It is necessary to fetch the vm static from the Db, in order to get this information
        VmStatic vmStaticFromDb = vmStaticDao.get(vm.getId());
        if (vmStaticFromDb != null) {
            Cluster cluster = clusterDao.get(vmStaticFromDb.getClusterId());
            if (cluster != null) {
                vm.setStoragePoolId(cluster.getStoragePoolId());
                vm.setClusterCompatibilityVersion(cluster.getCompatibilityVersion());
                vm.setClusterName(cluster.getName());
                vm.setClusterCpuName(cluster.getCpuName());
            }
        }
        // if the required dedicated host is invalid -> use current VM dedicated host
        if (!vmHandler.validateDedicatedVdsExistOnSameCluster(vm.getStaticData(), null)) {
            vm.setDedicatedVmForVdsList(oldVmStatic.getDedicatedVmForVdsList());
        }
        VmHandler.updateMaxMemorySize(vm.getStaticData(), vm.getCompatibilityVersion());
        validateQuota(vm);
        return true;
    } catch (OvfReaderException e) {
        log.error("Failed to update VM from the configuration '{}': {}", configuration, e.getMessage());
        log.debug("Exception", e);
        return false;
    }
}
#end_block

#method_before
private void copyAllMemoryImages(Guid containerID) {
    for (Snapshot snapshot : snapshotsWithMemory) {
        List<Guid> guids = GuidUtils.getGuidListFromString(snapshot.getMemoryVolume());
        // copy the memory dump image
        VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryDumpImage(containerID, guids.get(0), guids.get(2), guids.get(3)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        // copy the memory configuration (of the VM) image
        vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryConfImage(containerID, guids.get(0), guids.get(4), guids.get(5)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#method_after
private void copyAllMemoryImages(Guid containerID) {
    for (Snapshot snapshot : snapshotsWithMemory) {
        List<Guid> guids = GuidUtils.getGuidListFromString(snapshot.getMemoryVolume());
        // copy the memory dump image
        ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryDumpImage(containerID, guids.get(0), guids.get(2), guids.get(3)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        // copy the memory configuration (of the VM) image
        vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryConfImage(containerID, guids.get(0), guids.get(4), guids.get(5)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#end_block

#method_before
@Override
protected void moveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForDisk(containerID, disk));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#method_after
@Override
protected void moveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForDisk(containerID, disk));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#end_block

#method_before
protected boolean checkVmInStorageDomain() {
    boolean retVal = true;
    GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getVm().getStoragePoolId(), getParameters().getStorageDomainId());
    VdcQueryReturnValue qretVal = runInternalQuery(VdcQueryType.GetVmsFromExportDomain, tempVar);
    if (qretVal.getSucceeded()) {
        ArrayList<VM> vms = qretVal.getReturnValue();
        for (VM vm : vms) {
            if (vm.getId().equals(getVm().getId())) {
                if (!getParameters().getForceOverride()) {
                    addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_GUID_ALREADY_EXIST);
                    retVal = false;
                    break;
                }
            } else if (vm.getName().equals(getVm().getName())) {
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                retVal = false;
                break;
            }
        }
    }
    return retVal;
}
#method_after
protected boolean checkVmInStorageDomain() {
    boolean retVal = true;
    GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getVm().getStoragePoolId(), getParameters().getStorageDomainId());
    QueryReturnValue qretVal = runInternalQuery(QueryType.GetVmsFromExportDomain, tempVar);
    if (qretVal.getSucceeded()) {
        ArrayList<VM> vms = qretVal.getReturnValue();
        for (VM vm : vms) {
            if (vm.getId().equals(getVm().getId())) {
                if (!getParameters().getForceOverride()) {
                    addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_GUID_ALREADY_EXIST);
                    retVal = false;
                    break;
                }
            } else if (vm.getName().equals(getVm().getName())) {
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                retVal = false;
                break;
            }
        }
    }
    return retVal;
}
#end_block

#method_before
public static boolean checkTemplateInStorageDomain(Guid storagePoolId, Guid storageDomainId, final Guid tmplId, EngineContext engineContext) {
    boolean retVal = false;
    GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    VdcQueryReturnValue qretVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar, engineContext);
    if (qretVal.getSucceeded()) {
        if (!VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(tmplId)) {
            Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
            retVal = templates.keySet().stream().anyMatch(vmTemplate -> vmTemplate.getId().equals(tmplId));
        } else {
            retVal = true;
        }
    }
    return retVal;
}
#method_after
public static boolean checkTemplateInStorageDomain(Guid storagePoolId, Guid storageDomainId, final Guid tmplId, EngineContext engineContext) {
    boolean retVal = false;
    GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    QueryReturnValue qretVal = Backend.getInstance().runInternalQuery(QueryType.GetTemplatesFromExportDomain, tempVar, engineContext);
    if (qretVal.getSucceeded()) {
        if (!VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(tmplId)) {
            Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
            retVal = templates.keySet().stream().anyMatch(vmTemplate -> vmTemplate.getId().equals(tmplId));
        } else {
            retVal = true;
        }
    }
    return retVal;
}
#end_block

#method_before
private Guid createTemplate() {
    VmTemplate blankTemplate = vmTemplateDao.get(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    VmStatic masterVm = new VmStatic(blankTemplate);
    OsRepository osRepository = SimpleDependencyInjector.getInstance().get(OsRepository.class);
    DiskImage templateDiskImage = getParameters().getDiskImage();
    String vmTemplateName = getParameters().getTemplateName();
    AddVmTemplateParameters parameters = new AddVmTemplateParameters(masterVm, vmTemplateName, templateDiskImage.getDiskDescription());
    // Setting the user from the parent command, as the session might already be invalid
    parameters.setParametersCurrentUser(getParameters().getParametersCurrentUser());
    // Setting the cluster ID, and other related properties derived from it
    if (getParameters().getClusterId() != null) {
        masterVm.setClusterId(getParameters().getClusterId());
        Cluster vdsGroup = getCluster(masterVm.getClusterId());
        masterVm.setOsId(osRepository.getDefaultOSes().get(vdsGroup.getArchitecture()));
        DisplayType defaultDisplayType = osRepository.getGraphicsAndDisplays(masterVm.getOsId(), vdsGroup.getCompatibilityVersion()).get(0).getSecond();
        masterVm.setDefaultDisplayType(defaultDisplayType);
    }
    parameters.setBalloonEnabled(true);
    VdcReturnValueBase addVmTemplateReturnValue = Backend.getInstance().runInternalAction(ActionType.AddVmTemplate, parameters, ExecutionHandler.createDefaultContextForTasks(getContext()));
    // No reason for this to return null, but checking just to make sure, and returning the created template, or null if failed
    return addVmTemplateReturnValue.getActionReturnValue() != null ? (Guid) addVmTemplateReturnValue.getActionReturnValue() : null;
}
#method_after
private Guid createTemplate() {
    VmTemplate blankTemplate = vmTemplateDao.get(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    VmStatic masterVm = new VmStatic(blankTemplate);
    OsRepository osRepository = SimpleDependencyInjector.getInstance().get(OsRepository.class);
    DiskImage templateDiskImage = getParameters().getDiskImage();
    String vmTemplateName = getParameters().getTemplateName();
    AddVmTemplateParameters parameters = new AddVmTemplateParameters(masterVm, vmTemplateName, templateDiskImage.getDiskDescription());
    // Setting the user from the parent command, as the session might already be invalid
    parameters.setParametersCurrentUser(getParameters().getParametersCurrentUser());
    // Setting the cluster ID, and other related properties derived from it
    if (getParameters().getClusterId() != null) {
        masterVm.setClusterId(getParameters().getClusterId());
        Cluster vdsGroup = getCluster(masterVm.getClusterId());
        masterVm.setOsId(osRepository.getDefaultOSes().get(vdsGroup.getArchitecture()));
        DisplayType defaultDisplayType = osRepository.getGraphicsAndDisplays(masterVm.getOsId(), vdsGroup.getCompatibilityVersion()).get(0).getSecond();
        masterVm.setDefaultDisplayType(defaultDisplayType);
    }
    parameters.setBalloonEnabled(true);
    ActionReturnValue addVmTemplateReturnValue = Backend.getInstance().runInternalAction(ActionType.AddVmTemplate, parameters, ExecutionHandler.createDefaultContextForTasks(getContext()));
    // No reason for this to return null, but checking just to make sure, and returning the created template, or null if failed
    return addVmTemplateReturnValue.getActionReturnValue() != null ? (Guid) addVmTemplateReturnValue.getActionReturnValue() : null;
}
#end_block

#method_before
private void removeMemory(final Snapshot snapshot, boolean useTaskManager) {
    RemoveMemoryVolumesParameters parameters = new RemoveMemoryVolumesParameters(snapshot.getMemoryVolume(), getVmId());
    if (useTaskManager) {
        CommandCoordinatorUtil.executeAsyncCommand(ActionType.RemoveMemoryVolumes, parameters, cloneContextAndDetachFromParent());
    } else {
        VdcReturnValueBase ret = runInternalAction(ActionType.RemoveMemoryVolumes, parameters);
        if (!ret.getSucceeded()) {
            log.error("Cannot remove memory volumes for snapshot '{}'", snapshot.getId());
        }
    }
}
#method_after
private void removeMemory(final Snapshot snapshot, boolean useTaskManager) {
    RemoveMemoryVolumesParameters parameters = new RemoveMemoryVolumesParameters(snapshot.getMemoryVolume(), getVmId());
    if (useTaskManager) {
        CommandCoordinatorUtil.executeAsyncCommand(ActionType.RemoveMemoryVolumes, parameters, cloneContextAndDetachFromParent());
    } else {
        ActionReturnValue ret = runInternalAction(ActionType.RemoveMemoryVolumes, parameters);
        if (!ret.getSucceeded()) {
            log.error("Cannot remove memory volumes for snapshot '{}'", snapshot.getId());
        }
    }
}
#end_block

#method_before
private void removeImages() {
    List<CinderDisk> cinderDisks = new ArrayList<>();
    for (final DiskImage source : getSourceImages()) {
        if (source.getDiskStorageType() == DiskStorageType.CINDER) {
            cinderDisks.add((CinderDisk) source);
            continue;
        }
        // The following is ok because we have tested in the validate that the vm
        // is not a template and the vm is not in preview mode and that
        // this is not the active snapshot.
        List<DiskImage> images = diskImageDao.getAllSnapshotsForParent(source.getImageId());
        DiskImage dest = null;
        if (!images.isEmpty()) {
            dest = images.get(0);
        }
        if (getSnapshotActionType() == ActionType.RemoveSnapshotSingleDiskLive) {
            CommandCoordinatorUtil.executeAsyncCommand(getSnapshotActionType(), buildRemoveSnapshotSingleDiskParameters(source, dest, getSnapshotActionType()), cloneContextAndDetachFromParent());
        } else {
            RemoveSnapshotSingleDiskParameters parameters = buildRemoveSnapshotSingleDiskParameters(source, dest, getSnapshotActionType());
            VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(getSnapshotActionType(), parameters);
            getTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
        }
        List<Guid> quotasToRemoveFromCache = new ArrayList<>();
        quotasToRemoveFromCache.add(source.getQuotaId());
        if (dest != null) {
            quotasToRemoveFromCache.add(dest.getQuotaId());
        }
        getQuotaManager().removeQuotaFromCache(getStoragePoolId(), quotasToRemoveFromCache);
    }
    if (!cinderDisks.isEmpty()) {
        handleCinderSnapshotDisks(cinderDisks);
    }
}
#method_after
private void removeImages() {
    List<CinderDisk> cinderDisks = new ArrayList<>();
    for (final DiskImage source : getSourceImages()) {
        if (source.getDiskStorageType() == DiskStorageType.CINDER) {
            cinderDisks.add((CinderDisk) source);
            continue;
        }
        // The following is ok because we have tested in the validate that the vm
        // is not a template and the vm is not in preview mode and that
        // this is not the active snapshot.
        List<DiskImage> images = diskImageDao.getAllSnapshotsForParent(source.getImageId());
        DiskImage dest = null;
        if (!images.isEmpty()) {
            dest = images.get(0);
        }
        if (getSnapshotActionType() == ActionType.RemoveSnapshotSingleDiskLive) {
            CommandCoordinatorUtil.executeAsyncCommand(getSnapshotActionType(), buildRemoveSnapshotSingleDiskParameters(source, dest, getSnapshotActionType()), cloneContextAndDetachFromParent());
        } else {
            RemoveSnapshotSingleDiskParameters parameters = buildRemoveSnapshotSingleDiskParameters(source, dest, getSnapshotActionType());
            ActionReturnValue actionReturnValueturnValue = runInternalActionWithTasksContext(getSnapshotActionType(), parameters);
            getTaskIdList().addAll(actionReturnValueturnValue.getInternalVdsmTaskIdList());
        }
        List<Guid> quotasToRemoveFromCache = new ArrayList<>();
        quotasToRemoveFromCache.add(source.getQuotaId());
        if (dest != null) {
            quotasToRemoveFromCache.add(dest.getQuotaId());
        }
        getQuotaManager().removeQuotaFromCache(getStoragePoolId(), quotasToRemoveFromCache);
    }
    if (!cinderDisks.isEmpty()) {
        handleCinderSnapshotDisks(cinderDisks);
    }
}
#end_block

#method_before
private void handleCinderSnapshotDisks(List<CinderDisk> cinderDisks) {
    for (CinderDisk cinderDisk : cinderDisks) {
        VdcReturnValueBase vdcReturnValueBase = runInternalAction(ActionType.RemoveCinderSnapshotDisk, buildRemoveCinderSnapshotDiskParameters(cinderDisk), cloneContextAndDetachFromParent());
        if (!vdcReturnValueBase.getSucceeded()) {
            log.error("Error removing snapshots for Cinder disk");
        }
    }
}
#method_after
private void handleCinderSnapshotDisks(List<CinderDisk> cinderDisks) {
    for (CinderDisk cinderDisk : cinderDisks) {
        ActionReturnValue actionReturnValue = runInternalAction(ActionType.RemoveCinderSnapshotDisk, buildRemoveCinderSnapshotDiskParameters(cinderDisk), cloneContextAndDetachFromParent());
        if (!actionReturnValue.getSucceeded()) {
            log.error("Error removing snapshots for Cinder disk");
        }
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    initializeObjectState();
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    VmValidator vmValidator = createVmValidator(getVm());
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp()) || !validateVmNotDuringSnapshot() || !validateVmNotInPreview() || !validateSnapshotExists() || !validateSnapshotType() || !validate(vmValidator.vmQualifiedForSnapshotMerge()) || !validate(vmValidator.vmNotHavingDeviceSnapshotsAttachedToOtherVms(false))) {
        return false;
    }
    if (hasImages()) {
        // Check the VM's images
        if (!validateImages()) {
            return false;
        }
        // check that we are not deleting the template
        if (!validateImageNotInTemplate()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_IMAGE_TEMPLATE);
        }
        if (!validateStorageDomains()) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    initializeObjectState();
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    VmValidator vmValidator = createVmValidator(getVm());
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp()) || !validateVmSnapshotDisksNotDuringMerge() || !validateVmNotInPreview() || !validateSnapshotExists() || !validateSnapshotType() || !validate(vmValidator.vmQualifiedForSnapshotMerge()) || !validate(vmValidator.vmNotHavingDeviceSnapshotsAttachedToOtherVms(false))) {
        return false;
    }
    if (hasImages()) {
        // Check the VM's images
        if (!validateImages()) {
            return false;
        }
        // check that we are not deleting the template
        if (!validateImageNotInTemplate()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_IMAGE_TEMPLATE);
        }
        if (!validateStorageDomains()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public boolean validatePMAgentPort() {
    // check if port was set directly
    String portStr = null;
    if (getParameters().getAgent().getPort() == null) {
        // check if port was set using the fence agent options
        if (getParameters().getAgent().getOptionsMap().containsKey(PORT)) {
            portStr = getParameters().getAgent().getOptionsMap().get(PORT);
        } else {
            return true;
        }
    }
    portStr = portStr == null ? getParameters().getAgent().getPort().toString() : portStr;
    return portStr.equals("") || portStr.matches("\\d+");
}
#method_after
protected boolean validatePMAgentPort() {
    Integer port = getParameters().getAgent().getPort();
    // check if port was set directly
    if (port == null) {
        // check if port was set using the fence agent options
        if (getParameters().getAgent().getOptionsMap().containsKey(PORT)) {
            String portStr = getParameters().getAgent().getOptionsMap().get(PORT);
            if (StringUtils.isNumeric(portStr)) {
                port = Integer.valueOf(portStr);
            } else {
                return false;
            }
        } else {
            return true;
        }
    }
    return port == null || ValidationUtils.validatePort(port);
}
#end_block

#method_before
@Test
public void isValid() {
    assertTrue(new NfsMountPointConstraint().isValid("192.168.0.1:/tmp/kakukk", null));
    assertTrue(new NfsMountPointConstraint().isValid("192.168.0.1:/tmp/kakukk/", null));
    assertTrue(new NfsMountPointConstraint().isValid("[1:2:3:4:5:6:7:8]:/tmp/kakukk", null));
    assertTrue(new NfsMountPointConstraint().isValid("[1::2]:/tmp/kakukk", null));
    assertTrue(new NfsMountPointConstraint().isValid("foo.example.com:/tmp/kakukk", null));
    assertTrue(new NfsMountPointConstraint().isValid("f0o.example.com:/tmp/kakukk", null));
    assertTrue(new NfsMountPointConstraint().isValid("storageserver:/tmp/kakukk", null));
    assertTrue(new NfsMountPointConstraint().isValid("st0rageserver:/tmp/kakukk", null));
    assertTrue(new NfsMountPointConstraint().isValid("s:/tmp/kakukk", null));
    assertTrue(new NfsMountPointConstraint().isValid("s.foobar:/tmp/kakukk", null));
    assertTrue(new NfsMountPointConstraint().isValid("0s:/tmp/kakukk", null));
    assertTrue(new NfsMountPointConstraint().isValid("f0o.example.f4:/tmp/kakukk", null));
    assertTrue(new NfsMountPointConstraint().isValid("192.168.0.1:/", null));
    assertFalse(new NfsMountPointConstraint().isValid("", null));
    assertFalse(new NfsMountPointConstraint().isValid("/tmp/kakukk", null));
    assertFalse(new NfsMountPointConstraint().isValid(":/tmp/kakukk", null));
    assertFalse(new NfsMountPointConstraint().isValid(".:/tmp/kakukk", null));
    assertFalse(new NfsMountPointConstraint().isValid(".example.com:/tmp/kakukk", null));
    assertFalse(new NfsMountPointConstraint().isValid("-example.com:/tmp/kakukk", null));
    assertFalse(new NfsMountPointConstraint().isValid("192.168.1.1:/h ome", null));
    assertFalse(new NfsMountPointConstraint().isValid("192.168.1.1:/home ", null));
    assertFalse(new NfsMountPointConstraint().isValid(" 192.168.1.1:/home", null));
}
#method_after
@Test
public void isValid() {
    assertTrue(new NfsMountPointConstraint().isValid("192.168.0.1:/tmp/kakukk", null));
    assertTrue(new NfsMountPointConstraint().isValid("192.168.0.1:/tmp/kakukk/", null));
    assertTrue(new NfsMountPointConstraint().isValid("192.168.0.1:/", null));
    assertTrue(new NfsMountPointConstraint().isValid("[1:2:3:4:5:6:7:8]:/tmp/kakukk", null));
    assertTrue(new NfsMountPointConstraint().isValid("[1::2]:/tmp/kakukk", null));
    assertTrue(new NfsMountPointConstraint().isValid("foo.example.com:/tmp/kakukk", null));
    assertTrue(new NfsMountPointConstraint().isValid("f0o.example.com:/tmp/kakukk", null));
    assertTrue(new NfsMountPointConstraint().isValid("storageserver:/tmp/kakukk", null));
    assertTrue(new NfsMountPointConstraint().isValid("st0rageserver:/tmp/kakukk", null));
    assertTrue(new NfsMountPointConstraint().isValid("s:/tmp/kakukk", null));
    assertTrue(new NfsMountPointConstraint().isValid("s.foobar:/tmp/kakukk", null));
    assertTrue(new NfsMountPointConstraint().isValid("0s:/tmp/kakukk", null));
    assertTrue(new NfsMountPointConstraint().isValid("f0o.example.f4:/tmp/kakukk", null));
    assertTrue(new NfsMountPointConstraint().isValid("f0o.example.f4:/tmp/kakukk", null));
    assertTrue(new NfsMountPointConstraint().isValid("f0o.example.f4:/", null));
    assertFalse(new NfsMountPointConstraint().isValid("", null));
    assertFalse(new NfsMountPointConstraint().isValid("/tmp/kakukk", null));
    assertFalse(new NfsMountPointConstraint().isValid(":/tmp/kakukk", null));
    assertFalse(new NfsMountPointConstraint().isValid(".:/tmp/kakukk", null));
    assertFalse(new NfsMountPointConstraint().isValid(".example.com:/tmp/kakukk", null));
    assertFalse(new NfsMountPointConstraint().isValid("-example.com:/tmp/kakukk", null));
    assertFalse(new NfsMountPointConstraint().isValid("192.168.1.1:/h ome", null));
    assertFalse(new NfsMountPointConstraint().isValid("192.168.1.1:/home ", null));
    assertFalse(new NfsMountPointConstraint().isValid(" 192.168.1.1:/home", null));
}
#end_block

#method_before
private void convertCustomPropertiesStrToMaps(Version version, String propertiesValue, Map<String, String> predefinedPropertiesMap, Map<String, String> userDefinedPropertiesMap) {
    Map<String, String> propertiesMap = convertProperties(propertiesValue, allVmProperties.get(version));
    Set<Entry<String, String>> propertiesEntries = propertiesMap.entrySet();
    // Go over all the properties - if the key of the property exists in the
    // predefined key set -
    // add it to the predefined map, otherwise - add it to the user defined
    // map
    Set<String> predefinedPropertiesKeys = predefinedProperties.get(version).keySet();
    Set<String> userdefinedPropertiesKeys = userdefinedProperties.get(version).keySet();
    for (Entry<String, String> propertiesEntry : propertiesEntries) {
        String propertyKey = propertiesEntry.getKey();
        String propertyValue = Optional.ofNullable(propertiesEntry.getValue()).orElse("");
        if (predefinedPropertiesKeys.contains(propertyKey)) {
            predefinedPropertiesMap.put(propertyKey, propertyValue);
        }
        if (userdefinedPropertiesKeys.contains(propertyKey)) {
            userDefinedPropertiesMap.put(propertyKey, propertyValue);
        }
    }
}
#method_after
private void convertCustomPropertiesStrToMaps(Version version, String propertiesValue, Map<String, String> predefinedPropertiesMap, Map<String, String> userDefinedPropertiesMap) {
    Map<String, String> propertiesMap = convertProperties(propertiesValue, allVmProperties.get(version));
    Set<Entry<String, String>> propertiesEntries = propertiesMap.entrySet();
    // Go over all the properties - if the key of the property exists in the
    // predefined key set -
    // add it to the predefined map, otherwise - add it to the user defined
    // map
    Set<String> predefinedPropertiesKeys = predefinedProperties.get(version).keySet();
    Set<String> userdefinedPropertiesKeys = userdefinedProperties.get(version).keySet();
    for (Entry<String, String> propertiesEntry : propertiesEntries) {
        String propertyKey = propertiesEntry.getKey();
        String propertyValue = Objects.toString(propertiesEntry.getValue(), "");
        if (predefinedPropertiesKeys.contains(propertyKey)) {
            predefinedPropertiesMap.put(propertyKey, propertyValue);
        }
        if (userdefinedPropertiesKeys.contains(propertyKey)) {
            userDefinedPropertiesMap.put(propertyKey, propertyValue);
        }
    }
}
#end_block

#method_before
public boolean syntaxErrorInProperties(Map<String, String> properties) {
    boolean error = false;
    if (properties != null && !properties.isEmpty()) {
        for (Map.Entry<String, String> e : properties.entrySet()) {
            String key = e.getKey();
            if (key == null || !key.matches(KEY_REGEX)) {
                // syntax error in property name
                error = true;
                break;
            }
            if (!Optional.ofNullable(e.getValue()).orElse("").matches(VALUE_REGEX)) {
                // syntax error in property value
                error = true;
                break;
            }
        }
    }
    return error;
}
#method_after
public boolean syntaxErrorInProperties(Map<String, String> properties) {
    boolean error = false;
    if (properties != null && !properties.isEmpty()) {
        for (Map.Entry<String, String> e : properties.entrySet()) {
            String key = e.getKey();
            if (key == null || !key.matches(KEY_REGEX)) {
                // syntax error in property name
                error = true;
                break;
            }
            if (!Objects.toString(e.getValue(), "").matches(VALUE_REGEX)) {
                // syntax error in property value
                error = true;
                break;
            }
        }
    }
    return error;
}
#end_block

#method_before
public String convertProperties(Map<String, String> properties) {
    StringBuilder sb = new StringBuilder();
    if (properties != null && !properties.isEmpty()) {
        for (Map.Entry<String, String> e : properties.entrySet()) {
            sb.append(e.getKey());
            sb.append(KEY_VALUE_DELIMETER);
            sb.append(Optional.ofNullable(e.getValue()).orElse(""));
            sb.append(PROPERTIES_DELIMETER);
        }
        // remove last PROPERTIES_DELIMETER
        sb.deleteCharAt(sb.length() - 1);
    }
    return sb.toString();
}
#method_after
public String convertProperties(Map<String, String> properties) {
    StringBuilder sb = new StringBuilder();
    if (properties != null && !properties.isEmpty()) {
        for (Map.Entry<String, String> e : properties.entrySet()) {
            sb.append(e.getKey());
            sb.append(KEY_VALUE_DELIMETER);
            sb.append(Objects.toString(e.getValue(), ""));
            sb.append(PROPERTIES_DELIMETER);
        }
        // remove last PROPERTIES_DELIMETER
        sb.deleteCharAt(sb.length() - 1);
    }
    return sb.toString();
}
#end_block

#method_before
private static boolean isRestApiScope(HttpServletRequest request) {
    boolean isRestApiScope;
    try {
        isRestApiScope = SsoUtils.getSsoSession(request).isRestApiScope();
    } catch (OAuthException ex) {
        isRestApiScope = false;
    }
    return isRestApiScope || isRestApiScope(SsoUtils.scopeAsList(SsoUtils.getScopeRequestParameter(request, "")));
}
#method_after
private static boolean isRestApiScope(HttpServletRequest request) {
    boolean restApiScope;
    try {
        restApiScope = SsoUtils.getSsoSession(request).isRestApiScope();
    } catch (OAuthException ex) {
        restApiScope = false;
    }
    return restApiScope || isRestApiScope(SsoUtils.scopeAsList(SsoUtils.getScopeRequestParameter(request, "")));
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate() || !initializeVds() || !checkStorageDomainNameLengthValid()) {
        return false;
    }
    if (isStorageWithSameNameExists()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NAME_ALREADY_EXIST);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ISO && !getStorageDomain().getStorageType().isFileDomain()) {
        addValidationMessageVariable("domainType", StorageConstants.ISO);
        addValidationMessageVariable("storageTypes", StorageConstants.FILE);
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DOMAIN_TYPE_CAN_BE_CREATED_ONLY_ON_SPECIFIC_STORAGE_DOMAINS);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ImportExport && getStorageDomain().getStorageType().isBlockDomain()) {
        addValidationMessageVariable("domainType", StorageConstants.EXPORT);
        addValidationMessageVariable("storageTypes", StorageConstants.FILE);
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DOMAIN_TYPE_CAN_BE_CREATED_ONLY_ON_SPECIFIC_STORAGE_DOMAINS);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    ensureStorageFormatInitialized();
    StorageDomainToPoolRelationValidator storageDomainToPoolRelationValidator = getAttachDomainValidator();
    StorageDomainValidator sdValidator = getStorageDomainValidator();
    if (!validate(storageDomainToPoolRelationValidator.isStorageDomainFormatCorrectForDC()) || !validate(sdValidator.isStorageFormatCompatibleWithDomain())) {
        return false;
    }
    initStorageDomainDiscardAfterDeleteIfNeeded();
    if (!validateDiscardAfterDeleteLegal(sdValidator)) {
        return false;
    }
    return canAddDomain();
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate() || !initializeVds() || !checkStorageDomainNameLengthValid()) {
        return false;
    }
    if (isStorageWithSameNameExists()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NAME_ALREADY_EXIST);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ISO && !getStorageDomain().getStorageType().isFileDomain()) {
        addValidationMessageVariable("domainType", StorageConstants.ISO);
        addValidationMessageVariable("storageTypes", StorageConstants.FILE);
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DOMAIN_TYPE_CAN_BE_CREATED_ONLY_ON_SPECIFIC_STORAGE_DOMAINS);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ImportExport && getStorageDomain().getStorageType().isBlockDomain()) {
        addValidationMessageVariable("domainType", StorageConstants.EXPORT);
        addValidationMessageVariable("storageTypes", StorageConstants.FILE);
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DOMAIN_TYPE_CAN_BE_CREATED_ONLY_ON_SPECIFIC_STORAGE_DOMAINS);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    ensureStorageFormatInitialized();
    StorageDomainValidator sdValidator = getStorageDomainValidator();
    if (!validate(sdValidator.isStorageFormatCompatibleWithDomain())) {
        return false;
    }
    initStorageDomainDiscardAfterDeleteIfNeeded();
    if (!validateDiscardAfterDeleteLegal(sdValidator)) {
        return false;
    }
    return canAddDomain();
}
#end_block

#method_before
private void ensureStorageFormatInitialized() {
    StorageDomain sd = getStorageDomain();
    if (sd.getStorageFormat() == null) {
        if (sd.getStorageDomainType().isDataDomain()) {
            sd.setStorageFormat(StorageFormatType.V4);
        } else {
            sd.setStorageFormat(StorageFormatType.V1);
        }
    }
}
#method_after
private void ensureStorageFormatInitialized() {
    StorageDomain sd = getStorageDomain();
    if (sd.getStorageFormat() == null) {
        if (sd.getStorageDomainType().isDataDomain()) {
            sd.setStorageFormat(StorageFormatType.getLatest());
        } else {
            sd.setStorageFormat(StorageFormatType.V1);
        }
    }
}
#end_block

#method_before
@Override
public void edit(final UploadImageModel model) {
    driver.edit(model);
    model.setImageFileUploadElement(imageFileUpload.getElement());
    imageFileUpload.addChangeHandler(changeEvent -> model.getImagePath().setEntity(imageFileUpload.getFilename()));
    model.getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if ("Message".equals(args.propertyName)) {
            // $NON-NLS-1$
            setPanelMessage(uploadMessagePanel, model.getMessage());
        } else if ("IsValid".equals(args.propertyName)) {
            // $NON-NLS-1$
            uploadMessagePanel.clear();
            if (!model.getIsValid() && !model.getInvalidityReasons().isEmpty()) {
                setPanelMessage(uploadMessagePanel, model.getInvalidityReasons().get(0));
            }
        }
    });
    // This is called before adding the radio buttons because it updates the selected option
    handleImageUploadBrowserSupport(model);
    imageSourcePanel.addRadioButton(constants.uploadImageSourceLocal(), model.getImageSourceLocalEnabled().getEntity(), true, event -> {
        model.getImageSourceLocalEnabled().setEntity(true);
        setSourceVisibility(model);
    });
    imageSourcePanel.addRadioButton(constants.uploadImageSourceRemote(), !model.getImageSourceLocalEnabled().getEntity(), true, event -> {
        model.getImageSourceLocalEnabled().setEntity(false);
        setSourceVisibility(model);
    });
    setSourceVisibility(model);
    vmDiskPopupWidget.edit(model.getDiskModel());
    if (model.getIsResumeUpload()) {
        diskOptionsLabel.setText(constants.uploadImageDiskOptionsInfoOnlyLabel());
    }
    imageInfoForm.initialize(model.getImageInfoModel());
    model.getImageInfoModel().getEntityChangedEvent().addListener((ev, sender, args) -> model.setIsValid(model.getImageInfoModel().getIsValid()));
    model.getImageInfoModel().initialize(model.getImageFileUploadElement());
    // Add image upload click handler and label updater
    imageFileUploadButton.addClickHandler(event -> imageFileUpload.getElement().<InputElement>cast().click());
    imageFileUpload.addChangeHandler(event -> imageFileUploadLabel.setText(imageFileUpload.getFilename().replace("C:\\fakepath\\", // $NON-NLS-1$ //$NON-NLS-2$
    "")));
}
#method_after
@Override
public void edit(final UploadImageModel model) {
    driver.edit(model);
    model.setImageFileUploadElement(imageFileUpload.getElement());
    imageFileUpload.addChangeHandler(changeEvent -> model.getImagePath().setEntity(imageFileUpload.getFilename()));
    model.getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if ("Message".equals(args.propertyName)) {
            // $NON-NLS-1$
            setPanelMessage(uploadMessagePanel, model.getMessage());
        } else if ("IsValid".equals(args.propertyName)) {
            // $NON-NLS-1$
            uploadMessagePanel.clear();
            if (!model.getIsValid() && !model.getInvalidityReasons().isEmpty()) {
                setPanelMessage(uploadMessagePanel, model.getInvalidityReasons().get(0));
            }
        }
    });
    // This is called before adding the radio buttons because it updates the selected option
    handleImageUploadBrowserSupport(model);
    imageSourcePanel.addRadioButton(constants.uploadImageSourceLocal(), model.getImageSourceLocalEnabled().getEntity(), true, event -> {
        model.getImageSourceLocalEnabled().setEntity(true);
        setSourceVisibility(model);
    });
    imageSourcePanel.addRadioButton(constants.uploadImageSourceRemote(), !model.getImageSourceLocalEnabled().getEntity(), true, event -> {
        model.getImageSourceLocalEnabled().setEntity(false);
        setSourceVisibility(model);
    });
    setSourceVisibility(model);
    vmDiskPopupWidget.edit(model.getDiskModel());
    if (model.getIsResumeUpload()) {
        diskOptionsLabel.setText(constants.uploadImageDiskOptionsInfoOnlyLabel());
    }
    imageInfoForm.initialize(model.getImageInfoModel());
    model.getImageInfoModel().getEntityChangedEvent().addListener((ev, sender, args) -> model.setIsValid(model.getImageInfoModel().getIsValid()));
    model.getImageInfoModel().initialize(model.getImageFileUploadElement());
    // Add image upload click handler and label updater
    imageFileUploadButton.addClickHandler(event -> imageFileUpload.getElement().<InputElement>cast().click());
    imageFileUpload.addChangeHandler(event -> imageFileUploadLabel.setText(imageFileUpload.getFilename().replaceFirst("^C:\\\\fakepath\\\\", // $NON-NLS-1$ //$NON-NLS-2$
    "")));
}
#end_block

#method_before
@Override
protected boolean validate() {
    initializeObjectState();
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    VmValidator vmValidator = createVmValidator(getVm());
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp()) || !validateVmNotDuringSnapshot() || !validateVmNotInPreview() || !validateSnapshotExists() || !validateSnapshotType() || !validate(vmValidator.vmQualifiedForSnapshotMerge()) || !validate(vmValidator.vmNotHavingDeviceSnapshotsAttachedToOtherVms(false))) {
        return false;
    }
    if (hasImages()) {
        // Check the VM's images
        if (!validateImages()) {
            return false;
        }
        // check that we are not deleting the template
        if (!validateImageNotInTemplate()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_IMAGE_TEMPLATE);
        }
        if (!validateStorageDomains()) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    initializeObjectState();
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    VmValidator vmValidator = createVmValidator(getVm());
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp()) || !validateVmSnapshotDisksNotDuringMerge() || !validateVmNotInPreview() || !validateSnapshotExists() || !validateSnapshotType() || !validate(vmValidator.vmQualifiedForSnapshotMerge()) || !validate(vmValidator.vmNotHavingDeviceSnapshotsAttachedToOtherVms(false))) {
        return false;
    }
    if (hasImages()) {
        // Check the VM's images
        if (!validateImages()) {
            return false;
        }
        // check that we are not deleting the template
        if (!validateImageNotInTemplate()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_IMAGE_TEMPLATE);
        }
        if (!validateStorageDomains()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate() || !initializeVds() || !checkStorageDomainNameLengthValid()) {
        return false;
    }
    if (isStorageWithSameNameExists()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NAME_ALREADY_EXIST);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ISO && !getStorageDomain().getStorageType().isFileDomain()) {
        addValidationMessageVariable("domainType", StorageConstants.ISO);
        addValidationMessageVariable("storageTypes", StorageConstants.FILE);
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DOMAIN_TYPE_CAN_BE_CREATED_ONLY_ON_SPECIFIC_STORAGE_DOMAINS);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ImportExport && getStorageDomain().getStorageType().isBlockDomain()) {
        addValidationMessageVariable("domainType", StorageConstants.EXPORT);
        addValidationMessageVariable("storageTypes", StorageConstants.FILE);
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DOMAIN_TYPE_CAN_BE_CREATED_ONLY_ON_SPECIFIC_STORAGE_DOMAINS);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (!Guid.isNullOrEmpty(getParameters().getStoragePoolId()) && getTargetStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    ensureStorageFormatInitialized();
    StorageDomainToPoolRelationValidator storageDomainToPoolRelationValidator = getAttachDomainValidator();
    StorageDomainValidator sdValidator = getStorageDomainValidator();
    if (!validate(storageDomainToPoolRelationValidator.isStorageDomainFormatCorrectForDC()) || !validate(sdValidator.isStorageFormatCompatibleWithDomain())) {
        return false;
    }
    initStorageDomainDiscardAfterDelete();
    if (!validateDiscardAfterDeleteLegal(sdValidator)) {
        return false;
    }
    return canAddDomain();
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate() || !initializeVds() || !checkStorageDomainNameLengthValid()) {
        return false;
    }
    if (isStorageWithSameNameExists()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NAME_ALREADY_EXIST);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ISO && !getStorageDomain().getStorageType().isFileDomain()) {
        addValidationMessageVariable("domainType", StorageConstants.ISO);
        addValidationMessageVariable("storageTypes", StorageConstants.FILE);
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DOMAIN_TYPE_CAN_BE_CREATED_ONLY_ON_SPECIFIC_STORAGE_DOMAINS);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ImportExport && getStorageDomain().getStorageType().isBlockDomain()) {
        addValidationMessageVariable("domainType", StorageConstants.EXPORT);
        addValidationMessageVariable("storageTypes", StorageConstants.FILE);
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DOMAIN_TYPE_CAN_BE_CREATED_ONLY_ON_SPECIFIC_STORAGE_DOMAINS);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (!Guid.isNullOrEmpty(getParameters().getStoragePoolId()) && getTargetStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    ensureStorageFormatInitialized();
    StorageDomainToPoolRelationValidator storageDomainToPoolRelationValidator = getAttachDomainValidator();
    StorageDomainValidator sdValidator = getStorageDomainValidator();
    if (!validate(storageDomainToPoolRelationValidator.isStorageDomainFormatCorrectForDC()) || !validate(sdValidator.isStorageFormatCompatibleWithDomain())) {
        return false;
    }
    initStorageDomainDiscardAfterDeleteIfNeeded();
    if (!validateDiscardAfterDeleteLegal(sdValidator)) {
        return false;
    }
    return canAddDomain();
}
#end_block

#method_before
private void reset() {
    setSelectedItems(new ArrayList<TagModel>());
    if (getItems() != null) {
        for (Object item : getItems()) {
            resetInternal((TagModel) item);
        }
    }
    // Async tag search will cause tree selection to be cleared
    // Search();
    getResetRequestedEvent().raise(this, EventArgs.EMPTY);
}
#method_after
private void reset() {
    setSelectedItems(new ArrayList<TagModel>());
    if (getItems() != null) {
        for (Object item : getItems()) {
            resetInternal((TagModel) item);
        }
    }
}
#end_block

#method_before
@Override
protected void initializeModelHandlers(BookmarkListModel model) {
    super.initializeModelHandlers(model);
    // Clear tag selection when a tag is saved/edited/deleted
    model.getItemSavedEvent().addListener((ev, sender, args) -> clearSelection());
    getModel().getSelectionModel().addSelectionChangeHandler(event -> {
        BookmarkModelProvider.this.setSelectedItems(getModel().getSelectionModel().getSelectedObjects());
    });
}
#method_after
@Override
protected void initializeModelHandlers(BookmarkListModel model) {
    super.initializeModelHandlers(model);
    // Clear tag selection when a tag is saved/edited/deleted
    model.getItemSavedEvent().addListener((ev, sender, args) -> clearSelection());
    getModel().getSelectionModel().addSelectionChangeHandler(event -> {
        BookmarkModelProvider.this.getModel().setSelectedItem(getModel().getSelectionModel().getFirstSelectedObject());
    });
}
#end_block

#method_before
@Override
protected void syncSearch() {
    super.syncSearch();
    Frontend.getInstance().runQuery(VdcQueryType.GetAllBookmarks, new VdcQueryParametersBase(), new AsyncQuery<>((AsyncCallback<VdcQueryReturnValue>) returnValue -> {
        List<Bookmark> resultList = returnValue.getReturnValue();
        if (resultList != null) {
            Collections.sort(resultList, COMPARATOR);
        }
        setIsBookmarkInitiated(true);
        setItems(resultList);
        setIsBookmarkInitiated(false);
    }));
}
#method_after
@Override
protected void syncSearch() {
    super.syncSearch();
    Frontend.getInstance().runQuery(QueryType.GetAllBookmarks, new QueryParametersBase(), new AsyncQuery<>((AsyncCallback<QueryReturnValue>) returnValue -> {
        List<Bookmark> resultList = returnValue.getReturnValue();
        if (resultList != null) {
            Collections.sort(resultList, COMPARATOR);
        }
        setIsBookmarkInitiated(true);
        setItems(resultList);
        setIsBookmarkInitiated(false);
    }));
}
#end_block

#method_before
public void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeBookmarksTitle());
    model.setHelpTag(HelpTag.remove_bookmark);
    // $NON-NLS-1$
    model.setHashName("remove_bookmark");
    ArrayList<String> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        org.ovirt.engine.core.common.businessentities.Bookmark i = (org.ovirt.engine.core.common.businessentities.Bookmark) item;
        list.add(i.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#method_after
public void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeBookmarksTitle());
    model.setHelpTag(HelpTag.remove_bookmark);
    // $NON-NLS-1$
    model.setHashName("remove_bookmark");
    ArrayList<String> list = new ArrayList<>();
    list.add(((Bookmark) getSelectedItem()).getName());
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
protected void initializeModelHandlers(final TagListModel model) {
    super.initializeModelHandlers(model);
    // Add model reset handler
    model.getResetRequestedEvent().addListener((ev, sender, args) -> {
        if (model.getItems() == null) {
            return;
        }
        Iterator<TagModel> iterator = model.getItems().iterator();
        if (iterator.hasNext()) {
            TagModel root = model.cloneTagModel(iterator.next());
            updateDataProvider(Arrays.asList(root));
        }
    });
    model.getSelectedItemsChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            // The selectedItemsChangedEvent only gets fired when activating/deactiving a tag. Changing
            // the selection in the tag tree does not fire this event.
            TagActivationChangeEvent.fire(TagModelProvider.this, activeTagList(model.getRootNode()));
        }

        private List<TagModel> activeTagList(TagModel model) {
            List<TagModel> result = new ArrayList<>();
            if (model.getSelection()) {
                result.add(model);
            }
            for (TagModel child : model.getChildren()) {
                result.addAll(activeTagList(child));
            }
            return result;
        }
    });
    getModel().getSelectionModel().addSelectionChangeHandler(event -> {
        TagModelProvider.this.setSelectedItems(getModel().getSelectionModel().getSelectedObjects());
    });
}
#method_after
@Override
protected void initializeModelHandlers(final TagListModel model) {
    super.initializeModelHandlers(model);
    model.getSelectedItemsChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            // The selectedItemsChangedEvent only gets fired when activating/deactiving a tag. Changing
            // the selection in the tag tree does not fire this event.
            TagActivationChangeEvent.fire(TagModelProvider.this, activeTagList(model.getRootNode()));
        }

        private List<TagModel> activeTagList(TagModel model) {
            List<TagModel> result = new ArrayList<>();
            if (model.getSelection()) {
                result.add(model);
            }
            for (TagModel child : model.getChildren()) {
                result.addAll(activeTagList(child));
            }
            return result;
        }
    });
    getModel().getSelectionModel().addSelectionChangeHandler(event -> {
        TagModelProvider.this.setSelectedItems(getModel().getSelectionModel().getSelectedObjects());
    });
}
#end_block

#method_before
void initTable() {
    // Set up table data provider
    getDataProvider().addDataDisplay(table);
    // Set up sort handler
    initSortHandler();
    // Set up table selection model
    table.setSelectionModel(selectionModel);
    // Enable keyboard selection
    table.setKeyboardSelectionPolicy(KeyboardSelectionPolicy.ENABLED);
    // Add arrow key handler
    table.addDomHandler(event -> {
        boolean shiftPageDown = event.isShiftKeyDown() && KeyCodes.KEY_PAGEDOWN == event.getNativeKeyCode();
        boolean shiftPageUp = event.isShiftKeyDown() && KeyCodes.KEY_PAGEUP == event.getNativeKeyCode();
        boolean ctrlA = event.isControlKeyDown() && ('a' == event.getNativeKeyCode() || 'A' == event.getNativeKeyCode());
        boolean arrow = KeyDownEvent.isArrow(event.getNativeKeyCode());
        if (shiftPageUp || shiftPageDown || ctrlA || arrow) {
            event.preventDefault();
            event.stopPropagation();
        } else {
            return;
        }
        if (shiftPageDown) {
            selectionModel.selectAllNext();
        } else if (shiftPageUp) {
            selectionModel.selectAllPrev();
        } else if (ctrlA) {
            selectionModel.selectAll();
        } else if (arrow) {
            selectionModel.setMultiSelectEnabled(event.isControlKeyDown() && !multiSelectionDisabled);
            selectionModel.setMultiRangeSelectEnabled(event.isShiftKeyDown() && !multiSelectionDisabled);
            if (event.isDownArrow()) {
                selectionModel.selectNext();
            } else if (event.isUpArrow()) {
                selectionModel.selectPrev();
            }
        }
    }, KeyDownEvent.getType());
    // Add context menu handler for table widget
    addContextMenuHandler(tableContainer);
    // Use fixed table layout
    // $NON-NLS-1$
    setWidth("100%", true);
    // Attach table widget to the corresponding panel
    tableContainer.add(table);
    tableHeaderContainer.setWidget(tableHeader);
    tableHeaderContainer.setVisible(isTableHeaderVisible());
    // $NON-NLS-1$
    table.getElement().addClassName("aat-table");
    // $NON-NLS-1$
    tableHeader.getElement().addClassName("aat-header");
    // Use relative positioning for tableHeader, in order to align it with main table
    tableHeader.getElement().getStyle().setPosition(Position.RELATIVE);
    // Attach scroll event handler to main table container, so that the tableHeader widget
    // can have its position aligned with main table container's current scroll position
    tableContainer.addDomHandler(event -> {
        tableContainerHorizontalScrollPosition = tableContainer.getElement().getScrollLeft();
        updateTableHeaderPosition();
    }, ScrollEvent.getType());
    // Reset main table container's scroll position
    enforceScrollPosition();
}
#method_after
void initTable() {
    // Set up table data provider
    getDataProvider().addDataDisplay(table);
    // Set up sort handler
    initSortHandler();
    // Set up table selection model
    table.setSelectionModel(selectionModel);
    // Enable keyboard selection
    table.setKeyboardSelectionPolicy(KeyboardSelectionPolicy.ENABLED);
    // Add arrow key handler
    table.addDomHandler(event -> {
        boolean shiftPageDown = event.isShiftKeyDown() && KeyCodes.KEY_PAGEDOWN == event.getNativeKeyCode();
        boolean shiftPageUp = event.isShiftKeyDown() && KeyCodes.KEY_PAGEUP == event.getNativeKeyCode();
        boolean ctrlA = event.isControlKeyDown() && ('a' == event.getNativeKeyCode() || 'A' == event.getNativeKeyCode());
        boolean arrow = KeyDownEvent.isArrow(event.getNativeKeyCode());
        if (shiftPageUp || shiftPageDown || ctrlA || arrow) {
            event.preventDefault();
            event.stopPropagation();
        } else {
            return;
        }
        if (shiftPageDown) {
            selectionModel.selectAllNext();
        } else if (shiftPageUp) {
            selectionModel.selectAllPrev();
        } else if (ctrlA) {
            selectionModel.selectAll();
        } else if (arrow) {
            selectionModel.setMultiSelectEnabled(event.isControlKeyDown() && !multiSelectionDisabled);
            selectionModel.setMultiRangeSelectEnabled(event.isShiftKeyDown() && !multiSelectionDisabled);
            if (event.isDownArrow()) {
                selectionModel.selectNext();
            } else if (event.isUpArrow()) {
                selectionModel.selectPrev();
            }
        }
    }, KeyDownEvent.getType());
    // Use fixed table layout
    // $NON-NLS-1$
    setWidth("100%", true);
    // Attach table widget to the corresponding panel
    tableContainer.add(table);
    tableHeaderContainer.setWidget(tableHeader);
    tableHeaderContainer.setVisible(isTableHeaderVisible());
    // $NON-NLS-1$
    table.getElement().addClassName("aat-table");
    // $NON-NLS-1$
    tableHeader.getElement().addClassName("aat-header");
    // Use relative positioning for tableHeader, in order to align it with main table
    tableHeader.getElement().getStyle().setPosition(Position.RELATIVE);
    // Attach scroll event handler to main table container, so that the tableHeader widget
    // can have its position aligned with main table container's current scroll position
    tableContainer.addDomHandler(event -> {
        tableContainerHorizontalScrollPosition = tableContainer.getElement().getScrollLeft();
        updateTableHeaderPosition();
    }, ScrollEvent.getType());
    // Reset main table container's scroll position
    enforceScrollPosition();
}
#end_block

#method_before
protected boolean isSingleSelectionOnly() {
    return false;
}
#method_after
protected boolean isSingleSelectionOnly() {
    // Most standard list models will have a single selection.
    return true;
}
#end_block

#method_before
protected List<LUNs> getLogicalUnits() {
    boolean reportStatus = ParametersHelper.getBooleanParameter(httpHeaders, uriInfo, REPORT_STATUS, true, true);
    GetDeviceListQueryParameters params = new GetDeviceListQueryParameters(asGuid(hostId), StorageType.UNKNOWN, reportStatus, null);
    params.setValidateHostStatus(true);
    return getBackendCollection(VdcQueryType.GetDeviceList, params);
}
#method_after
protected List<LUNs> getLogicalUnits() {
    boolean reportStatus = ParametersHelper.getBooleanParameter(httpHeaders, uriInfo, REPORT_STATUS, true, true);
    GetDeviceListQueryParameters params = new GetDeviceListQueryParameters(asGuid(hostId), StorageType.UNKNOWN, reportStatus, null, true);
    return getBackendCollection(VdcQueryType.GetDeviceList, params);
}
#end_block

#method_before
public List<String> getLunIds() {
    return lunIds;
}
#method_after
public Set<String> getLunIds() {
    return lunIds;
}
#end_block

#method_before
public void setLunIds(List<String> lunIds) {
    this.lunIds = lunIds;
}
#method_after
public void setLunIds(Set<String> lunIds) {
    this.lunIds = lunIds;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!validate(new VmValidator(getVm()).isVmExists()) || !isDiskExistAndAttachedToVm(getOldDisk()) || !validateDiskVmData()) {
        return false;
    }
    boolean isDiskImageOrCinder = DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() || DiskStorageType.CINDER == getOldDisk().getDiskStorageType();
    if (isDiskImageOrCinder) {
        ValidationResult imagesNotLocked = new DiskImagesValidator((DiskImage) getOldDisk()).diskImagesNotLocked();
        if (!imagesNotLocked.isValid()) {
            return validate(imagesNotLocked);
        }
    }
    DiskValidator oldDiskValidator = getDiskValidator(getOldDisk());
    ValidationResult isHostedEngineDisk = oldDiskValidator.validateNotHostedEngineDisk();
    if (!isHostedEngineDisk.isValid()) {
        return validate(isHostedEngineDisk);
    }
    if (!checkOperationAllowedOnDiskContentType(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    boolean isDiskInterfaceUpdated = getOldDiskVmElement().getDiskInterface() != getDiskVmElement().getDiskInterface();
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && updateParametersRequiringVmDownRequested()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDiskVmElement().isBoot() && getDiskVmElement().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(oldDiskValidator.isVmNotContainsBootDisk(getVm()))) {
            return false;
        }
        if (isDiskInterfaceUpdated && !isDiskPassPciAndIdeLimit()) {
            return false;
        }
    }
    if (isDiskImageOrCinder && !validateCanResizeDisk()) {
        return false;
    }
    if (resizeDiskImageRequested() && amendDiskRequested()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_AMEND_AND_EXTEND_IN_ONE_OPERATION);
    }
    if (isAllDiskVolumesRaw()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANT_AMEND_RAW_DISK);
    }
    DiskVmElementValidator diskVmElementValidator = getDiskVmElementValidator(getNewDisk(), getDiskVmElement());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly() && validateVmPoolProperties() && validateQuota() && validate(diskVmElementValidator.isVirtIoScsiValid(getVm())) && (!isDiskInterfaceUpdated || validate(diskVmElementValidator.isDiskInterfaceSupported(getVm()))) && setAndValidateDiskProfiles() && validatePassDiscardSupported(diskVmElementValidator);
}
#method_after
@Override
protected boolean validate() {
    if (!validate(new VmValidator(getVm()).isVmExists()) || !isDiskExistAndAttachedToVm(getOldDisk()) || !validateDiskVmData()) {
        return false;
    }
    boolean isDiskImageOrCinder = DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() || DiskStorageType.CINDER == getOldDisk().getDiskStorageType();
    if (isDiskImageOrCinder) {
        ValidationResult imagesNotLocked = new DiskImagesValidator((DiskImage) getOldDisk()).diskImagesNotLocked();
        if (!imagesNotLocked.isValid()) {
            return validate(imagesNotLocked);
        }
    }
    DiskValidator oldDiskValidator = getDiskValidator(getOldDisk());
    ValidationResult isHostedEngineDisk = oldDiskValidator.validateNotHostedEngineDisk();
    if (!isHostedEngineDisk.isValid()) {
        return validate(isHostedEngineDisk);
    }
    if (!checkOperationAllowedOnDiskContentType(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    boolean isDiskInterfaceUpdated = getOldDiskVmElement().getDiskInterface() != getDiskVmElement().getDiskInterface();
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && updateParametersRequiringVmDownRequested()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDiskVmElement().isBoot() && getDiskVmElement().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(oldDiskValidator.isVmNotContainsBootDisk(getVm()))) {
            return false;
        }
        if (isDiskInterfaceUpdated && !isDiskPassPciAndIdeLimit()) {
            return false;
        }
    }
    if (isDiskImageOrCinder && !validateCanResizeDisk()) {
        return false;
    }
    if (resizeDiskImageRequested() && amendDiskRequested()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_AMEND_AND_EXTEND_IN_ONE_OPERATION);
    }
    if (isQcowCompatChangedOnRawDisk()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANT_AMEND_RAW_DISK);
    }
    DiskVmElementValidator diskVmElementValidator = getDiskVmElementValidator(getNewDisk(), getDiskVmElement());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly() && validateVmPoolProperties() && validateQuota() && validate(diskVmElementValidator.isVirtIoScsiValid(getVm())) && (!isDiskInterfaceUpdated || validate(diskVmElementValidator.isDiskInterfaceSupported(getVm()))) && setAndValidateDiskProfiles() && validatePassDiscardSupported(diskVmElementValidator);
}
#end_block

#method_before
public static Guid getHostForExecution(Guid poolId, Collection<Guid> hostsToFilter) {
    List<Guid> hostsForExecution = getVdsDao().getAllForStoragePoolAndStatus(poolId, VDSStatus.Up).stream().filter(x -> !hostsToFilter.contains(x.getId())).map(x -> x.getId()).collect(Collectors.toList());
    if (hostsForExecution.isEmpty()) {
        return null;
    }
    return hostsForExecution.get(new Random().nextInt(hostsForExecution.size()));
}
#method_after
public static Guid getHostForExecution(Guid poolId) {
    return getHostForExecution(poolId, Collections.emptyList());
}
#end_block

#method_before
private static void updateStepMessage(CommandBase<?> cmd, Guid vdsForExecution) {
    // As an HSM job can run on any host, we want to display the host running the job when it is
    // chosen. To do so, we look for a corresponding command step with an "_ON_HOST" suffix that
    // is supposed to contain a "vds" placeholder.
    StepEnum stepEnum = null;
    try {
        stepEnum = StepEnum.valueOf(getStepWithHostname(cmd));
    } catch (IllegalArgumentException e) {
        // Ignore this exception and do nothing as no corresponding step_ON_HOST found.
        log.debug("No StepEnum found for " + getStepWithHostname(cmd));
        return;
    }
    Step step = cmd.getExecutionContext().getStep();
    Map<String, String> jobProperties = cmd.getJobMessageProperties();
    jobProperties.put(VdcObjectType.VDS.name().toLowerCase(), getVdsDao().get(vdsForExecution).getName());
    step.setDescription(ExecutionMessageDirector.resolveStepMessage(stepEnum, jobProperties));
    getStepDao().update(step);
    // Audit log a message with the host running the cold merge
    cmd.addCustomValues(jobProperties);
    new AuditLogDirector().log(cmd, AuditLogType.USER_MERGE_SNAPSHOT_ON_HOST);
}
#method_after
private static void updateStepMessage(CommandBase<?> cmd, Guid vdsForExecution) {
    // As an HSM job can run on any host, we want to display the host running the job when it is
    // chosen. To do so, we look for a corresponding command step with an "_ON_HOST" suffix that
    // is supposed to contain a "vds" placeholder.
    StepEnum stepEnum = null;
    try {
        stepEnum = StepEnum.valueOf(getStepWithHostname(cmd));
    } catch (IllegalArgumentException e) {
        // Ignore this exception and do nothing as no corresponding step_ON_HOST found.
        log.debug("No StepEnum found for " + getStepWithHostname(cmd));
        return;
    }
    Step step = cmd.getExecutionContext().getStep();
    Map<String, String> jobProperties = cmd.getJobMessageProperties();
    jobProperties.put(VdcObjectType.VDS.name().toLowerCase(), getVdsDao().get(vdsForExecution).getName());
    step.setDescription(ExecutionMessageDirector.resolveStepMessage(stepEnum, jobProperties));
    getStepDao().update(step);
    // Add an audit log entry if a corresponding AuditLogType exists. Note that we expect an AuditLogType
    // with name equals to Step_Enum to exist. If an AuditLogType exists, the arguments in the audit
    // message must match these in the StepEnum message.
    AuditLogType logType = null;
    try {
        logType = AuditLogType.valueOf(getAuditLogType(cmd));
    } catch (IllegalArgumentException e) {
        // Ignore this exception and do nothing as no corresponding AuditLogType found.
        log.debug("No AuditLogType found for " + getAuditLogType(cmd));
        return;
    }
    jobProperties.entrySet().stream().forEach(entry -> cmd.addCustomValue(entry.getKey(), entry.getValue()));
    Injector.get(AuditLogDirector.class).log(cmd, logType);
}
#end_block

#method_before
private void generateFollowMethod() {
    // javaBuffer.addImport(javaPackages.getJaxrsPackageName(), "ActionableResource");
    // TODO: not hard-coded!
    javaBuffer.addImport("org.ovirt.engine.api.model.ActionableResource");
    javaBuffer.addLine("default public void follow (ActionableResource entity) {");
    javaBuffer.addLine("}");
    javaBuffer.addLine("");
}
#method_after
private void generateFollowMethod() {
    javaBuffer.addImport(javaPackages.getXjcPackageName(), "ActionableResource");
    javaBuffer.addLine("default public void follow (ActionableResource entity) {");
    javaBuffer.addLine("}");
    javaBuffer.addLine();
}
#end_block

#method_before
private void generateGetMethod(Method method) {
    Parameter mainParameter = jaxrsGeneratorUtils.getMainUpdateParameter(method);
    if (mainParameter == null) {
        throw new IllegalStateException("Method \"" + method + "\" doesn't have any struct parameter");
    }
    // Most "Get" methods return the type that is declared in the model, but the root resource needs to return
    // "Response", because it has to be able to return the type declared in the model and also the XML schema and
    // the RSDL.
    Service service = method.getDeclaringService();
    boolean isRoot = service == service.getModel().getRoot();
    javaBuffer.addImport(GET.class);
    javaBuffer.addLine("@GET");
    if (isRoot) {
        javaBuffer.addImport(Response.class);
        addResponseReturnMethod("get()");
    } else {
        Type mainType = mainParameter.getType();
        JavaTypeReference mainTypeReference = schemaNames.getXjcTypeReference(mainType);
        javaBuffer.addImports(mainTypeReference.getImports());
        // add doGet() method with default implementation
        generateDoGetMethod(mainParameter, mainTypeReference);
        generateDoc(method);
        javaBuffer.addLine("");
        // add get() method
        addMethod(mainTypeReference.getText(), "get()");
    }
    javaBuffer.addLine();
}
#method_after
private void generateGetMethod(Method method) {
    Parameter mainParameter = jaxrsGeneratorUtils.getMainUpdateParameter(method);
    if (mainParameter == null) {
        throw new IllegalStateException("Method \"" + method + "\" doesn't have any struct parameter");
    }
    // Most "Get" methods return the type that is declared in the model, but the root resource needs to return
    // "Response", because it has to be able to return the type declared in the model and also the XML schema and
    // the RSDL.
    Service service = method.getDeclaringService();
    boolean isRoot = service == service.getModel().getRoot();
    javaBuffer.addImport(GET.class);
    javaBuffer.addLine("@GET");
    if (isRoot) {
        javaBuffer.addImport(Response.class);
        addResponseReturnMethod("get()");
    } else {
        Type mainType = mainParameter.getType();
        JavaTypeReference mainTypeReference = schemaNames.getXjcTypeReference(mainType);
        javaBuffer.addImports(mainTypeReference.getImports());
        // add doGet() method with default implementation
        generateDoGetMethod(mainParameter, mainTypeReference);
        generateDoc(method);
        javaBuffer.addLine();
        // add get() method
        addMethod(mainTypeReference.getText(), "get()");
    }
    javaBuffer.addLine();
}
#end_block

#method_before
private void generateDoGetMethod(Parameter mainParameter, JavaTypeReference mainTypeReference) {
    String parameterName = javaNames.getJavaMemberStyleName(mainParameter.getName());
    javaBuffer.addLine("default public %s doGet() {", mainTypeReference.getText());
    javaBuffer.addLine(mainTypeReference.getText() + " " + parameterName + " = get();");
    javaBuffer.addLine("follow(%s);", parameterName);
    javaBuffer.addLine("return %s;", parameterName);
    javaBuffer.addLine("}");
}
#method_after
private void generateDoGetMethod(Parameter mainParameter, JavaTypeReference mainTypeReference) {
    String parameterName = javaNames.getJavaMemberStyleName(mainParameter.getName());
    javaBuffer.addLine("default public %s doGet() {", mainTypeReference.getText());
    javaBuffer.addLine("%s %s = get();", mainTypeReference.getText(), parameterName);
    javaBuffer.addLine("follow(%s);", parameterName);
    javaBuffer.addLine("return %s;", parameterName);
    javaBuffer.addLine("}");
}
#end_block

#method_before
private void generateDoListMethod(Parameter mainParameter, JavaTypeReference mainTypeReference) {
    String parameterName = javaNames.getJavaMemberStyleName(mainParameter.getName());
    javaBuffer.addLine("default public %s doList() {", mainTypeReference.getText());
    javaBuffer.addLine(mainTypeReference.getText() + " " + parameterName + " = list();");
    javaBuffer.addLine("follow(%s);", parameterName);
    javaBuffer.addLine("return %s;", parameterName);
    javaBuffer.addLine("}");
}
#method_after
private void generateDoListMethod(Parameter mainParameter, JavaTypeReference mainTypeReference) {
    String parameterName = javaNames.getJavaMemberStyleName(mainParameter.getName());
    javaBuffer.addLine("default public %s doList() {", mainTypeReference.getText());
    javaBuffer.addLine("%s %s = list();", mainTypeReference.getText(), parameterName);
    javaBuffer.addLine("follow(%s);", parameterName);
    javaBuffer.addLine("return %s;", parameterName);
    javaBuffer.addLine("}");
}
#end_block

#method_before
void proceedVmReportedOnOtherHost() {
    switch(vdsmVm.getVmDynamic().getStatus()) {
        case MigratingTo:
            if (dbVm.getRunOnVds() == null) {
                log.info("VM '{}' is found as migrating on VDS '{}'({}) ", vdsmVm.getVmDynamic().getId(), vdsManager.getVdsId(), vdsManager.getVdsName());
                dbVm.updateRuntimeData(vdsmVm.getVmDynamic(), vdsManager.getVdsId());
                saveDynamic(dbVm);
                if (!vdsManager.isInitialized()) {
                    resourceManager.removeVmFromDownVms(vdsManager.getVdsId(), vdsmVm.getVmDynamic().getId());
                }
            } else {
                log.info("VM '{}' is migrating to VDS '{}'({}) ignoring it in the refresh until migration is done", vdsmVm.getVmDynamic().getId(), vdsManager.getVdsId(), vdsManager.getVdsName());
            }
            return;
        case MigratingFrom:
            // do nothing
            return;
        case Paused:
            if (vdsmVm.getVmDynamic().getPauseStatus() == VmPauseStatus.POSTCOPY) {
                // do nothing
                return;
            }
            // otherwise continue with default processing
            break;
        case WaitForLaunch:
            if (dbVm.getStatus() == VMStatus.Unknown) {
                // until we are sure that the VM is actually running on this host
                return;
            }
            // otherwise continue with default processing
            break;
        default:
    }
    if (isVmMigratingToThisVds() && vdsmVm.getVmDynamic().getStatus().isRunning()) {
        succeededToRun = true;
    }
    if (vdsmVm.getVmDynamic().getStatus().isUpOrPaused()) {
        succeededToRun = true;
    }
    dbVm.updateRuntimeData(vdsmVm.getVmDynamic(), vdsManager.getVdsId());
    saveDynamic(dbVm);
    updateStatistics();
    if (!vdsManager.isInitialized()) {
        resourceManager.removeVmFromDownVms(vdsManager.getVdsId(), vdsmVm.getVmDynamic().getId());
    }
}
#method_after
void proceedVmReportedOnOtherHost() {
    switch(vdsmVm.getVmDynamic().getStatus()) {
        case MigratingTo:
            if (dbVm.getRunOnVds() == null) {
                log.info("VM '{}' is found as migrating on VDS '{}'({}) ", vdsmVm.getVmDynamic().getId(), vdsManager.getVdsId(), vdsManager.getVdsName());
                dbVm.updateRuntimeData(vdsmVm.getVmDynamic(), vdsManager.getVdsId());
                saveDynamic(dbVm);
                if (!vdsManager.isInitialized()) {
                    resourceManager.removeVmFromDownVms(vdsManager.getVdsId(), vdsmVm.getVmDynamic().getId());
                }
            } else {
                log.info("VM '{}' is migrating to VDS '{}'({}) ignoring it in the refresh until migration is done", vdsmVm.getVmDynamic().getId(), vdsManager.getVdsId(), vdsManager.getVdsName());
            }
            return;
        case MigratingFrom:
            // do nothing
            return;
        case Paused:
            if (vdsmVm.getVmDynamic().getPauseStatus() == VmPauseStatus.POSTCOPY) {
                // do nothing
                return;
            }
            // otherwise continue with default processing
            break;
        case WaitForLaunch:
            if (dbVm.getStatus() == VMStatus.Unknown) {
                // until we are sure that the VM is actually running on this host
                return;
            }
            // otherwise continue with default processing
            break;
        default:
    }
    if (isVmMigratingToThisVds() && vdsmVm.getVmDynamic().getStatus().isRunningOrPaused()) {
        succeededToRun = true;
    }
    if (vdsmVm.getVmDynamic().getStatus() == VMStatus.Up) {
        succeededToRun = true;
    }
    dbVm.updateRuntimeData(vdsmVm.getVmDynamic(), vdsManager.getVdsId());
    saveDynamic(dbVm);
    updateStatistics();
    if (!vdsManager.isInitialized()) {
        resourceManager.removeVmFromDownVms(vdsManager.getVdsId(), vdsmVm.getVmDynamic().getId());
    }
}
#end_block

#method_before
void proceedDownVm() {
    // destroy the VM as soon as possible
    destroyVm();
    // VM is running on another host - must be during migration
    if (!isVmRunningInDatabaseOnMonitoredHost()) {
        return;
    }
    logVmStatusTransition();
    switch(dbVm.getStatus()) {
        case SavingState:
            resourceManager.internalSetVmStatus(dbVm, VMStatus.Suspended);
            clearVm(vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
            resourceManager.removeAsyncRunningVm(dbVm.getId());
            auditVmSuspended();
            break;
        case MigratingFrom:
            switch(vdsmVm.getVmDynamic().getExitStatus()) {
                case Normal:
                    handOverVm();
                    break;
                case Error:
                    abortVmMigration();
                    if (getVmManager().isAutoStart()) {
                        setAutoRunFlag();
                        break;
                    }
            }
            break;
        default:
            switch(vdsmVm.getVmDynamic().getExitStatus()) {
                case Error:
                    auditVmOnDownError();
                    clearVm(vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
                    if (resourceManager.isVmInAsyncRunningList(vdsmVm.getVmDynamic().getId())) {
                        setRerunFlag();
                        break;
                    }
                    if (getVmManager().isAutoStart()) {
                        setAutoRunFlag();
                        break;
                    }
                    break;
                case Normal:
                    boolean powerOff = System.nanoTime() - getVmManager().getPowerOffTimeout() < 0;
                    auditVmOnDownNormal(powerOff);
                    clearVm(vdsmVm.getVmDynamic().getExitStatus(), powerOff ? getPowerOffExitMessage() : vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
                    resourceManager.removeAsyncRunningVm(vdsmVm.getVmDynamic().getId());
                    if (getVmManager().isColdReboot()) {
                        setColdRebootFlag();
                    }
            }
    }
}
#method_after
void proceedDownVm() {
    // destroy the VM as soon as possible
    destroyVm();
    // VM is running on another host - must be during migration
    if (!isVmRunningInDatabaseOnMonitoredHost()) {
        return;
    }
    logVmStatusTransition();
    switch(dbVm.getStatus()) {
        case SavingState:
            resourceManager.internalSetVmStatus(dbVm, VMStatus.Suspended);
            clearVm(vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
            resourceManager.removeAsyncRunningVm(dbVm.getId());
            auditVmSuspended();
            break;
        case MigratingFrom:
            switch(vdsmVm.getVmDynamic().getExitStatus()) {
                case Normal:
                    handOverVm();
                    break;
                case Error:
                    abortVmMigration();
                    if (getVmManager().isAutoStart()) {
                        setAutoRunFlag();
                        break;
                    }
            }
            break;
        default:
            switch(vdsmVm.getVmDynamic().getExitStatus()) {
                case Error:
                    auditVmOnDownError();
                    clearVm(vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
                    if (resourceManager.isVmInAsyncRunningList(vdsmVm.getVmDynamic().getId())) {
                        setRerunFlag();
                        break;
                    }
                    if (getVmManager().isAutoStart()) {
                        setAutoRunFlag();
                        break;
                    }
                    break;
                case Normal:
                    boolean powerOff = System.nanoTime() - getVmManager().getPowerOffTimeout() < 0;
                    auditVmOnDownNormal(powerOff);
                    clearVm(vdsmVm.getVmDynamic().getExitStatus(), powerOff ? getPowerOffExitMessage() : vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
                    resourceManager.removeAsyncRunningVm(vdsmVm.getVmDynamic().getId());
                    if (getVmManager().isColdReboot() || vdsmVm.getVmDynamic().getExitReason() == VmExitReason.DestroyedOnReboot) {
                        setColdRebootFlag();
                    }
            }
    }
}
#end_block

#method_before
private boolean isMigrationSucceeded() {
    return dbVm.getStatus() == VMStatus.MigratingTo && (vdsmVm.getVmDynamic().getStatus().isRunning() || vdsmVm.getVmDynamic().getStatus() == VMStatus.Paused);
}
#method_after
private boolean isMigrationSucceeded() {
    return dbVm.getStatus() == VMStatus.MigratingTo && vdsmVm.getVmDynamic().getStatus().isRunningOrPaused();
}
#end_block

#method_before
private void updateInterfaceStatistics() {
    List<VmNetworkInterface> ifsStats = vdsmVm.getInterfaceStatistics();
    if (ifsStats == null || ifsStats.isEmpty()) {
        return;
    }
    loadVmNetworkInterfaces();
    List<String> macs = new ArrayList<>();
    statistics.setUsageNetworkPercent(0);
    NetworkStatisticsBuilder statsBuilder = new NetworkStatisticsBuilder();
    for (VmNetworkInterface ifStats : ifsStats) {
        boolean firstTime = !macs.contains(ifStats.getMacAddress());
        VmNetworkInterface vmIface = ifaces.stream().filter(iface -> iface.getMacAddress().equals(ifStats.getMacAddress())).findFirst().orElse(null);
        if (vmIface == null) {
            continue;
        }
        // if rtl+pv it will get here 2 times (we take the max one)
        if (firstTime) {
            statsBuilder.updateExistingInterfaceStatistics(vmIface, ifStats);
        } else {
            vmIface.getStatistics().setReceiveRate(max(vmIface.getStatistics().getReceiveRate(), ifStats.getStatistics().getReceiveRate()));
            vmIface.getStatistics().setReceiveDropRate(max(vmIface.getStatistics().getReceiveDropRate(), ifStats.getStatistics().getReceiveDropRate()));
            vmIface.getStatistics().setTransmitRate(max(vmIface.getStatistics().getTransmitRate(), ifStats.getStatistics().getTransmitRate()));
            vmIface.getStatistics().setTransmitDropRate(max(vmIface.getStatistics().getTransmitDropRate(), ifStats.getStatistics().getTransmitDropRate()));
        }
        vmIface.setVmId(dbVm.getId());
        if (ifStats.getSpeed() != null && vmIface.getStatistics().getReceiveRate() != null && vmIface.getStatistics().getReceiveRate() > 0) {
            double rx_percent = vmIface.getStatistics().getReceiveRate();
            double tx_percent = vmIface.getStatistics().getTransmitRate();
            statistics.setUsageNetworkPercent(max(statistics.getUsageNetworkPercent(), (int) max(rx_percent, tx_percent)));
        }
        if (firstTime) {
            macs.add(ifStats.getMacAddress());
        }
    }
    statistics.setUsageNetworkPercent(min(statistics.getUsageNetworkPercent(), 100));
    Integer usageHistoryLimit = Config.getValue(ConfigValues.UsageHistoryLimit);
    statistics.addNetworkUsageHistory(statistics.getUsageNetworkPercent(), usageHistoryLimit);
}
#method_after
private void updateInterfaceStatistics() {
    List<VmNetworkInterface> ifsStats = vdsmVm.getInterfaceStatistics();
    if (ifsStats == null || ifsStats.isEmpty()) {
        return;
    }
    loadVmNetworkInterfaces();
    List<String> macs = new ArrayList<>();
    statistics.setUsageNetworkPercent(0);
    NetworkStatisticsBuilder statsBuilder = new NetworkStatisticsBuilder();
    for (VmNetworkInterface ifStats : ifsStats) {
        boolean firstTime = !macs.contains(ifStats.getMacAddress());
        VmNetworkInterface vmIface = ifaces.stream().filter(iface -> iface.getMacAddress().equals(ifStats.getMacAddress())).findFirst().orElse(null);
        if (vmIface == null) {
            continue;
        }
        // VDSM is going to stop reporting the speed, so we override it with the value from the database
        // TODO: the speed should not be part of the statistics at all, needs to move it elsewhere
        ifStats.setSpeed(vmIface.getSpeed());
        // if rtl+pv it will get here 2 times (we take the max one)
        if (firstTime) {
            statsBuilder.updateExistingInterfaceStatistics(vmIface, ifStats);
        } else {
            vmIface.getStatistics().setReceiveRate(max(vmIface.getStatistics().getReceiveRate(), ifStats.getStatistics().getReceiveRate()));
            vmIface.getStatistics().setReceiveDropRate(max(vmIface.getStatistics().getReceiveDropRate(), ifStats.getStatistics().getReceiveDropRate()));
            vmIface.getStatistics().setTransmitRate(max(vmIface.getStatistics().getTransmitRate(), ifStats.getStatistics().getTransmitRate()));
            vmIface.getStatistics().setTransmitDropRate(max(vmIface.getStatistics().getTransmitDropRate(), ifStats.getStatistics().getTransmitDropRate()));
        }
        vmIface.setVmId(dbVm.getId());
        if (ifStats.getSpeed() != null && vmIface.getStatistics().getReceiveRate() != null && vmIface.getStatistics().getReceiveRate() > 0) {
            double rx_percent = vmIface.getStatistics().getReceiveRate();
            double tx_percent = vmIface.getStatistics().getTransmitRate();
            statistics.setUsageNetworkPercent(max(statistics.getUsageNetworkPercent(), (int) max(rx_percent, tx_percent)));
        }
        if (firstTime) {
            macs.add(ifStats.getMacAddress());
        }
    }
    statistics.setUsageNetworkPercent(min(statistics.getUsageNetworkPercent(), 100));
    Integer usageHistoryLimit = Config.getValue(ConfigValues.UsageHistoryLimit);
    statistics.addNetworkUsageHistory(statistics.getUsageNetworkPercent(), usageHistoryLimit);
}
#end_block

#method_before
private void saveSanStorage() {
    StorageModel storageModel = (StorageModel) getWindow();
    final SanStorageModelBase sanStorageModelBase = (SanStorageModelBase) storageModel.getCurrentStorageItem();
    Guid hostId = sanStorageModelBase.getContainer().getHost().getSelectedItem().getId();
    if (sanStorageModelBase.getAddedLuns().isEmpty()) {
        onSaveSanStorage();
        return;
    }
    List<String> unkownStatusLuns = new ArrayList<>();
    for (LunModel lunModel : sanStorageModelBase.getAddedLuns()) {
        unkownStatusLuns.add(lunModel.getLunId());
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetDeviceList, new GetDeviceListQueryParameters(hostId, sanStorageModelBase.getType(), true, unkownStatusLuns), new AsyncQuery<VdcQueryReturnValue>(response -> {
        if (response.getSucceeded()) {
            List<LUNs> checkedLuns = (ArrayList<LUNs>) response.getReturnValue();
            postGetLunsMessages(sanStorageModelBase.getUsedLunsMessages(checkedLuns));
        } else {
            sanStorageModelBase.setGetLUNsFailure(ConstantsManager.getInstance().getConstants().couldNotRetrieveLUNsLunsFailure());
        }
    }, true));
}
#method_after
private void saveSanStorage() {
    StorageModel storageModel = (StorageModel) getWindow();
    final SanStorageModelBase sanStorageModelBase = (SanStorageModelBase) storageModel.getCurrentStorageItem();
    Guid hostId = sanStorageModelBase.getContainer().getHost().getSelectedItem().getId();
    if (sanStorageModelBase.getAddedLuns().isEmpty()) {
        onSaveSanStorage();
        return;
    }
    Set<String> unkownStatusLuns = new HashSet<>();
    for (LunModel lunModel : sanStorageModelBase.getAddedLuns()) {
        unkownStatusLuns.add(lunModel.getLunId());
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetDeviceList, new GetDeviceListQueryParameters(hostId, sanStorageModelBase.getType(), true, unkownStatusLuns), new AsyncQuery<VdcQueryReturnValue>(response -> {
        if (response.getSucceeded()) {
            List<LUNs> checkedLuns = (ArrayList<LUNs>) response.getReturnValue();
            postGetLunsMessages(sanStorageModelBase.getUsedLunsMessages(checkedLuns));
        } else {
            sanStorageModelBase.setGetLUNsFailure(ConstantsManager.getInstance().getConstants().couldNotRetrieveLUNsLunsFailure());
        }
    }, true));
}
#end_block

#method_before
public void saveNewSanStorage() {
    StorageModel model = (StorageModel) getWindow();
    SanStorageModelBase sanModel = (SanStorageModelBase) model.getCurrentStorageItem();
    VDS host = model.getHost().getSelectedItem();
    boolean force = sanModel.isForce();
    HashSet<String> lunIds = new HashSet<>();
    for (LunModel lun : sanModel.getAddedLuns()) {
        lunIds.add(lun.getLunId());
    }
    AddSANStorageDomainParameters params = new AddSANStorageDomainParameters(storageDomain);
    params.setVdsId(host.getId());
    params.setLunIds(new ArrayList<>(lunIds));
    params.setForce(force);
    Frontend.getInstance().runAction(ActionType.AddSANStorageDomain, params, result -> {
        StorageListModel storageListModel = (StorageListModel) result.getState();
        StorageModel storageModel = (StorageModel) storageListModel.getWindow();
        storageListModel.storageModel = storageModel.getCurrentStorageItem();
        if (!result.getReturnValue().getSucceeded()) {
            storageListModel.onFinish(storageListModel.context, false, storageListModel.storageModel);
            return;
        }
        StoragePool dataCenter = storageModel.getDataCenter().getSelectedItem();
        if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            Guid storageId = returnValue.getActionReturnValue();
            storageListModel.attachStorageToDataCenter(storageId, dataCenter.getId(), storageModel.getActivateDomain().getEntity());
        }
        storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
    }, this);
}
#method_after
public void saveNewSanStorage() {
    StorageModel model = (StorageModel) getWindow();
    SanStorageModelBase sanModel = (SanStorageModelBase) model.getCurrentStorageItem();
    VDS host = model.getHost().getSelectedItem();
    boolean force = sanModel.isForce();
    HashSet<String> lunIds = new HashSet<>();
    for (LunModel lun : sanModel.getAddedLuns()) {
        lunIds.add(lun.getLunId());
    }
    AddSANStorageDomainParameters params = new AddSANStorageDomainParameters(storageDomain);
    params.setVdsId(host.getId());
    params.setLunIds(lunIds);
    params.setForce(force);
    Frontend.getInstance().runAction(ActionType.AddSANStorageDomain, params, result -> {
        StorageListModel storageListModel = (StorageListModel) result.getState();
        StorageModel storageModel = (StorageModel) storageListModel.getWindow();
        storageListModel.storageModel = storageModel.getCurrentStorageItem();
        if (!result.getReturnValue().getSucceeded()) {
            storageListModel.onFinish(storageListModel.context, false, storageListModel.storageModel);
            return;
        }
        StoragePool dataCenter = storageModel.getDataCenter().getSelectedItem();
        if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            Guid storageId = returnValue.getActionReturnValue();
            storageListModel.attachStorageToDataCenter(storageId, dataCenter.getId(), storageModel.getActivateDomain().getEntity());
        }
        storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
    }, this);
}
#end_block

#method_before
private void saveSanStorage(TaskContext context) {
    this.context = context;
    StorageModel model = (StorageModel) getWindow();
    SanStorageModelBase sanModel = (SanStorageModelBase) model.getCurrentStorageItem();
    StorageDomain storage = getSelectedItem();
    boolean isNew = model.getStorage() == null;
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(storage.getStorageStaticData());
    storageDomain.setStorageType(isNew ? sanModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? sanModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageFormat(isNew ? sanModel.getContainer().getFormat().getSelectedItem() : storageDomain.getStorageFormat());
    storageDomain.setDescription(model.getDescription().getEntity());
    storageDomain.setComment(model.getComment().getEntity());
    saveCommonStorageProperties(model);
    if (isNew) {
        saveNewSanStorage();
    } else {
        Frontend.getInstance().runAction(ActionType.UpdateStorageDomain, new StorageDomainManagementParameter(storageDomain), new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                StorageListModel storageListModel = (StorageListModel) result.getState();
                StorageModel storageModel = (StorageModel) getWindow();
                SanStorageModelBase sanStorageModelBase = (SanStorageModelBase) storageModel.getCurrentStorageItem();
                boolean force = sanStorageModelBase.isForce();
                StorageDomain storageDomain1 = storageListModel.getSelectedItem();
                HashSet<String> lunIds = new HashSet<>();
                for (LunModel lun : sanStorageModelBase.getAddedLuns()) {
                    lunIds.add(lun.getLunId());
                }
                if (lunIds.size() > 0) {
                    Frontend.getInstance().runAction(ActionType.ExtendSANStorageDomain, new ExtendSANStorageDomainParameters(storageDomain1.getId(), new ArrayList<>(lunIds), force), null, this);
                }
                ArrayList<String> lunToRefreshIds = new ArrayList<>();
                for (LunModel lun : sanStorageModelBase.getLunsToRefresh()) {
                    lunToRefreshIds.add(lun.getLunId());
                }
                if (lunToRefreshIds.size() > 0) {
                    Frontend.getInstance().runAction(ActionType.RefreshLunsSize, new ExtendSANStorageDomainParameters(storageDomain1.getId(), lunToRefreshIds, false), null, this);
                }
                storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
            }
        }, this);
    }
}
#method_after
private void saveSanStorage(TaskContext context) {
    this.context = context;
    StorageModel model = (StorageModel) getWindow();
    SanStorageModelBase sanModel = (SanStorageModelBase) model.getCurrentStorageItem();
    StorageDomain storage = getSelectedItem();
    boolean isNew = model.getStorage() == null;
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(storage.getStorageStaticData());
    storageDomain.setStorageType(isNew ? sanModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? sanModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageFormat(isNew ? sanModel.getContainer().getFormat().getSelectedItem() : storageDomain.getStorageFormat());
    storageDomain.setDescription(model.getDescription().getEntity());
    storageDomain.setComment(model.getComment().getEntity());
    saveCommonStorageProperties(model);
    if (isNew) {
        saveNewSanStorage();
    } else {
        Frontend.getInstance().runAction(ActionType.UpdateStorageDomain, new StorageDomainManagementParameter(storageDomain), new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                StorageListModel storageListModel = (StorageListModel) result.getState();
                StorageModel storageModel = (StorageModel) getWindow();
                SanStorageModelBase sanStorageModelBase = (SanStorageModelBase) storageModel.getCurrentStorageItem();
                boolean force = sanStorageModelBase.isForce();
                StorageDomain storageDomain1 = storageListModel.getSelectedItem();
                HashSet<String> lunIds = new HashSet<>();
                for (LunModel lun : sanStorageModelBase.getAddedLuns()) {
                    lunIds.add(lun.getLunId());
                }
                if (lunIds.size() > 0) {
                    Frontend.getInstance().runAction(ActionType.ExtendSANStorageDomain, new ExtendSANStorageDomainParameters(storageDomain1.getId(), new HashSet<>(lunIds), force), null, this);
                }
                Set<String> lunToRefreshIds = new HashSet<>();
                for (LunModel lun : sanStorageModelBase.getLunsToRefresh()) {
                    lunToRefreshIds.add(lun.getLunId());
                }
                if (lunToRefreshIds.size() > 0) {
                    Frontend.getInstance().runAction(ActionType.RefreshLunsSize, new ExtendSANStorageDomainParameters(storageDomain1.getId(), lunToRefreshIds, false), null, this);
                }
                storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
            }
        }, this);
    }
}
#end_block

#method_before
@Override
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    try {
        log.debug("Entered AuthorizeServlet QueryString: {}, Parameters : {}", request.getQueryString(), SsoUtils.getRequestParameters(request));
        String responseType = SsoUtils.getRequestParameter(request, SsoConstants.JSON_RESPONSE_TYPE);
        if (!responseType.equals("code")) {
            throw new OAuthException(SsoConstants.ERR_CODE_INVALID_REQUEST, String.format(ssoContext.getLocalizationUtils().localize(SsoConstants.APP_ERROR_UNSUPPORTED_PARAMETER_IN_REQUEST, (Locale) request.getAttribute(SsoConstants.LOCALE)), responseType, SsoConstants.JSON_RESPONSE_TYPE));
        }
        login(request, response, buildSsoSession(request));
    } catch (Exception ex) {
        SsoSession ssoSession = SsoUtils.getSsoSession(request, true);
        if (ssoSession.isOpenIdScope() || SsoUtils.scopeAsList(SsoUtils.getScopeRequestParameter(request, "")).contains(SsoConstants.OPENID_SCOPE)) {
            ssoSession.setRedirectUri(request.getParameter(SsoConstants.HTTP_PARAM_REDIRECT_URI));
        }
        SsoUtils.redirectToErrorPage(request, response, ex);
    }
}
#method_after
@Override
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    try {
        log.debug("Entered AuthorizeServlet QueryString: {}, Parameters : {}", request.getQueryString(), SsoUtils.getRequestParameters(request));
        String responseType = SsoUtils.getRequestParameter(request, SsoConstants.JSON_RESPONSE_TYPE);
        if (!responseType.equals("code")) {
            throw new OAuthException(SsoConstants.ERR_CODE_INVALID_REQUEST, String.format(ssoContext.getLocalizationUtils().localize(SsoConstants.APP_ERROR_UNSUPPORTED_PARAMETER_IN_REQUEST, (Locale) request.getAttribute(SsoConstants.LOCALE)), responseType, SsoConstants.JSON_RESPONSE_TYPE));
        }
        login(request, response, buildSsoSession(request));
    } catch (Exception ex) {
        SsoSession ssoSession = SsoUtils.getSsoSession(request, true);
        String scope = SsoUtils.getScopeRequestParameter(request, "");
        if (ssoSession.isOpenIdScope() || SsoUtils.scopeAsList(scope).contains(SsoConstants.OPENID_SCOPE)) {
            ssoSession.setRedirectUri(request.getParameter(SsoConstants.HTTP_PARAM_REDIRECT_URI));
        }
        SsoUtils.redirectToErrorPage(request, response, ex);
    }
}
#end_block

#method_before
@Override
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    try {
        log.debug("Entered OpenIdUserInfoServlet Query String: {}, Parameters : {}", request.getQueryString(), SsoUtils.getRequestParameters(request));
        String token = request.getParameter(SsoConstants.HTTP_REQ_ATTR_ACCESS_TOKEN);
        if (token == null) {
            token = getTokenFromHeader(request);
        }
        if (token == null) {
            throw new OAuthException(SsoConstants.ERROR_CODE, SsoConstants.ERR_CODE_INVALID_REQUEST);
        }
        SsoSession ssoSession = SsoUtils.getSsoSessionFromRequest(request, token);
        sendJsonData(response, buildResponse(request, ssoSession));
    } catch (OAuthException ex) {
        SsoUtils.sendJsonDataWithMessage(response, ex);
    } catch (AuthenticationException ex) {
        SsoUtils.sendJsonDataWithMessage(response, SsoConstants.ERR_CODE_ACCESS_DENIED, ex);
    } catch (Exception ex) {
        SsoUtils.sendJsonDataWithMessage(response, SsoConstants.ERR_CODE_SERVER_ERROR, ex);
    }
}
#method_after
@Override
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    try {
        log.debug("Entered OpenIdUserInfoServlet Query String: {}, Parameters : {}", request.getQueryString(), SsoUtils.getRequestParameters(request));
        String token = request.getParameter(SsoConstants.HTTP_REQ_ATTR_ACCESS_TOKEN);
        if (token == null) {
            token = getTokenFromHeader(request);
        }
        if (token == null) {
            throw new OAuthException(SsoConstants.ERROR_CODE, SsoConstants.ERR_CODE_INVALID_REQUEST);
        }
        SsoSession ssoSession = SsoUtils.getSsoSessionFromRequest(request, token);
        SsoUtils.sendJsonData(response, buildResponse(request, ssoSession), "application/jwt");
    } catch (OAuthException ex) {
        SsoUtils.sendJsonDataWithMessage(response, ex);
    } catch (AuthenticationException ex) {
        SsoUtils.sendJsonDataWithMessage(response, SsoConstants.ERR_CODE_ACCESS_DENIED, ex);
    } catch (Exception ex) {
        SsoUtils.sendJsonDataWithMessage(response, SsoConstants.ERR_CODE_SERVER_ERROR, ex);
    }
}
#end_block

#method_before
private String getTokenFromHeader(HttpServletRequest request) {
    String token = null;
    String headerValue = request.getHeader(SsoConstants.HEADER_AUTHORIZATION);
    if (headerValue != null && headerValue.startsWith(BEARER)) {
        token = headerValue.substring("Bearer".length()).trim();
    }
    return token;
}
#method_after
private String getTokenFromHeader(HttpServletRequest request) {
    String token = null;
    String headerValue = request.getHeader(SsoConstants.HEADER_AUTHORIZATION);
    if (headerValue != null && headerValue.startsWith(BEARER)) {
        token = headerValue.substring(BEARER.length()).trim();
    }
    return token;
}
#end_block

#method_before
private String buildResponse(HttpServletRequest request, SsoSession ssoSession) throws Exception {
    return SsoUtils.createJWT(request, ssoSession, ssoSession.getClientId()).toString();
}
#method_after
private String buildResponse(HttpServletRequest request, SsoSession ssoSession) throws Exception {
    return OpenIdUtils.createJWT(request, ssoSession, ssoSession.getClientId()).toString();
}
#end_block

#method_before
public static void persistUserPassword(HttpServletRequest request, SsoSession ssoSession, String password) {
    try {
        if (ssoSession.getScopeAsList().contains("ovirt-ext=token:password-access") && password != null && StringUtils.isNotEmpty(ssoSession.getClientId())) {
            ssoSession.setPassword(encrypt(request.getServletContext(), ssoSession.getClientId(), password));
        }
    } catch (Exception ex) {
        log.error("Unable to encrypt password: {}", ex.getMessage());
        log.debug("Exception", ex);
    }
}
#method_after
public static void persistUserPassword(HttpServletRequest request, SsoSession ssoSession, String password) {
    try {
        if (ssoSession.getScopeAsList().contains("ovirt-ext=token:password-access") && password != null) {
            ssoSession.setPassword(encrypt(request.getServletContext(), password));
        }
    } catch (Exception ex) {
        log.error("Unable to encrypt password: {}", ex.getMessage());
        log.debug("Exception", ex);
    }
}
#end_block

#method_before
public static void sendJsonData(HttpServletResponse response, String jsonPayload) throws IOException {
    try (OutputStream os = response.getOutputStream()) {
        response.setContentType("application/json");
        byte[] jsonPayloadBytes = jsonPayload.getBytes(StandardCharsets.UTF_8.name());
        response.setContentLength(jsonPayloadBytes.length);
        os.write(jsonPayloadBytes);
        log.trace("Sending json data {}", jsonPayload);
    }
}
#method_after
public static void sendJsonData(HttpServletResponse response, String jsonPayload) throws IOException {
    sendJsonData(response, jsonPayload, "application/json");
}
#end_block

#method_before
public static void sendJsonData(HttpServletResponse response, String jsonPayload) throws IOException {
    try (OutputStream os = response.getOutputStream()) {
        response.setContentType("application/json");
        byte[] jsonPayloadBytes = jsonPayload.getBytes(StandardCharsets.UTF_8.name());
        response.setContentLength(jsonPayloadBytes.length);
        os.write(jsonPayloadBytes);
        log.trace("Sending json data {}", jsonPayload);
    }
}
#method_after
public static void sendJsonData(HttpServletResponse response, String jsonPayload, String contentType) throws IOException {
    try (OutputStream os = response.getOutputStream()) {
        response.setContentType(contentType);
        byte[] jsonPayloadBytes = jsonPayload.getBytes(StandardCharsets.UTF_8.name());
        response.setContentLength(jsonPayloadBytes.length);
        os.write(jsonPayloadBytes);
        log.trace("Sending json data {}", jsonPayload);
    }
}
#end_block

#method_before
public static String encrypt(ServletContext ctx, String clientId, String rawText) throws Exception {
    ClientInfo clientInfo = getSsoContext(ctx).getClienInfo(clientId);
    try (InputStream in = new FileInputStream(clientInfo.getCertificateLocation())) {
        return EnvelopeEncryptDecrypt.encrypt("AES/OFB/PKCS5Padding", 256, CertificateFactory.getInstance("X.509").generateCertificate(in), 100, rawText.getBytes(StandardCharsets.UTF_8));
    }
}
#method_after
public static String encrypt(ServletContext ctx, String rawText) throws Exception {
    return EnvelopeEncryptDecrypt.encrypt("AES/OFB/PKCS5Padding", 256, getSsoContext(ctx).getEngineCertificate(), 100, rawText.getBytes(StandardCharsets.UTF_8));
}
#end_block

#method_before
private Map<String, Object> buildResponse(HttpServletRequest request, SsoSession ssoSession, String clientId, String clientSecret) throws Exception {
    Map<String, Object> payload = buildResponse(ssoSession);
    if (SsoUtils.scopeAsList(ssoSession.getScope()).contains(SsoConstants.OPENID_SCOPE)) {
        payload.put("id_token", SsoUtils.createJWT(request, ssoSession, clientId, clientSecret));
    }
    return payload;
}
#method_after
private Map<String, Object> buildResponse(HttpServletRequest request, SsoSession ssoSession, String clientId, String clientSecret) throws Exception {
    Map<String, Object> payload = buildResponse(ssoSession);
    if (SsoUtils.scopeAsList(ssoSession.getScope()).contains(SsoConstants.OPENID_SCOPE)) {
        payload.put("id_token", OpenIdUtils.createJWT(request, ssoSession, clientId, clientSecret));
    }
    return payload;
}
#end_block

#method_before
private void syncStorageDomainsLuns(List<LUNs> deviceList) {
    SyncLunsParameters parameters = new SyncLunsParameters(getParameters().getStoragePoolId(), deviceList);
    runInternalAction(VdcActionType.SyncStorageDomainsLuns, parameters);
}
#method_after
private void syncStorageDomainsLuns(List<LUNs> deviceList) {
    SyncLunsParameters parameters = new SyncLunsParameters(getParameters().getStoragePoolId(), deviceList);
    runInternalAction(ActionType.SyncStorageDomainsLuns, parameters);
}
#end_block

#method_before
private void syncDirectLunsAttachedToVmsInPool(List<LUNs> deviceList) {
    SyncDirectLunsParameters parameters = new SyncDirectLunsParameters(getParameters().getStoragePoolId());
    parameters.setDeviceList(deviceList);
    runInternalAction(VdcActionType.SyncDirectLuns, parameters);
}
#method_after
private void syncDirectLunsAttachedToVmsInPool(List<LUNs> deviceList) {
    SyncDirectLunsParameters parameters = new SyncDirectLunsParameters(getParameters().getStoragePoolId());
    parameters.setDeviceList(deviceList);
    runInternalAction(ActionType.SyncDirectLuns, parameters);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private List<LUNs> getVgInfo() {
    if (getParameters().getVgInfo() != null) {
        log.debug("Using the virtual group's information from the command's parameters rather " + "than calling getVgInfo and getting the information directly from vdsm.");
        return getParameters().getVgInfo();
    }
    GetVGInfoVDSCommandParameters params = new GetVGInfoVDSCommandParameters(getParameters().getVdsId(), getStorageDomain().getStorage());
    if (getParameters().getVdsId() == null) {
        return (List<LUNs>) VdsCommandsHelper.runVdsCommandWithoutFailover(VDSCommandType.GetVGInfo, params, getStoragePoolId(), null).getReturnValue();
    }
    return (List<LUNs>) runVdsCommand(VDSCommandType.GetVGInfo, params).getReturnValue();
}
#method_after
@SuppressWarnings("unchecked")
private List<LUNs> getVgInfo() {
    if (getParameters().getVgInfo() != null) {
        log.debug("Using the virtual group's information from the command's parameters rather " + "than calling getVgInfo and getting the information directly from vdsm.");
        return getParameters().getVgInfo();
    }
    GetVGInfoVDSCommandParameters params = new GetVGInfoVDSCommandParameters(getParameters().getVdsId(), getStorageDomain().getStorage());
    return (List<LUNs>) runVdsCommand(VDSCommandType.GetVGInfo, params).getReturnValue();
}
#end_block

#method_before
private void refreshMetadataDevicesInfoIfNeeded() {
    // When a domain is created it has a vg metadata device and a metadata lv which may be created on multiple
    // devices. On a regular basis, those devices should be never changing.
    // However, in some user environments in case of disaster the block sd may be restored manually in a way that
    // will change its metadata devices - therefore when syncing the luns info we refresh the metadata devices
    // information as well.
    String oldVgMetadataDevice = getStorageDomain().getVgMetadataDevice();
    String oldFirstMetadataDevice = getStorageDomain().getFirstMetadataDevice();
    blockStorageDomainHelper.fillMetadataDevicesInfo(getStorageDomain().getStorageStaticData(), getStoragePoolId());
    if (!Objects.equals(oldVgMetadataDevice, getStorageDomain().getVgMetadataDevice()) || !Objects.equals(oldFirstMetadataDevice, getStorageDomain().getFirstMetadataDevice())) {
        storageDomainStaticDao.update(getStorageDomain().getStorageStaticData());
    }
    blockStorageDomainHelper.checkDomainMetadataDevices(getStorageDomain());
}
#method_after
private void refreshMetadataDevicesInfoIfNeeded() {
    // When a domain is created it has a vg metadata device and a metadata lv which may be created on multiple
    // devices. On a regular basis, those devices should be never changing.
    // However, in some user environments in case of disaster the block sd may be restored manually in a way that
    // will change its metadata devices - therefore when syncing the luns info we refresh the metadata devices
    // information as well.
    String oldVgMetadataDevice = getStorageDomain().getVgMetadataDevice();
    String oldFirstMetadataDevice = getStorageDomain().getFirstMetadataDevice();
    blockStorageDomainHelper.fillMetadataDevicesInfo(getStorageDomain().getStorageStaticData(), getParameters().getVdsId());
    if (!Objects.equals(oldVgMetadataDevice, getStorageDomain().getVgMetadataDevice()) || !Objects.equals(oldFirstMetadataDevice, getStorageDomain().getFirstMetadataDevice())) {
        storageDomainStaticDao.update(getStorageDomain().getStorageStaticData());
    }
    blockStorageDomainHelper.checkDomainMetadataDevices(getStorageDomain());
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getParameters().getDirectLunId() == null) {
        return canSyncAllDirectLunsAttachedToVmsInPool();
    }
    return canSyncDirectLun();
}
#method_after
@Override
protected boolean validate() {
    if (getParameters().getDirectLunId() == null) {
        // the storage pool, a valid and active storage pool is required.
        return validateStoragePool();
    }
    return canSyncDirectLun();
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    Set<Guid> directLunsToLock = getIdsOfDirectLunsToSync();
    return directLunsToLock.stream().collect(Collectors.toMap(Guid::toString, diskId -> LockMessagesMatchUtil.makeLockingPair(LockingGroup.DISK, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED)));
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    return getIdsOfDirectLunsToSync().collect(Collectors.toMap(Guid::toString, diskId -> LockMessagesMatchUtil.makeLockingPair(LockingGroup.DISK, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED)));
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return getIdsOfDirectLunsToSync().stream().map(id -> new PermissionSubject(id, VdcObjectType.Disk, getActionType().getActionGroup())).collect(Collectors.toList());
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return getIdsOfDirectLunsToSync().map(id -> new PermissionSubject(id, VdcObjectType.Disk, getActionType().getActionGroup())).collect(Collectors.toList());
}
#end_block

#method_before
private Set<Guid> getIdsOfDirectLunsToSync() {
    return Optional.ofNullable(getParameters().getDirectLunId()).map(Collections::singleton).orElse(new HashSet<>(getLunToDiskIdsOfDirectLunsAttachedToVmsInPool().values()));
}
#method_after
private Stream<Guid> getIdsOfDirectLunsToSync() {
    return Optional.ofNullable(getParameters().getDirectLunId()).map(Stream::of).orElse(getLunToDiskIdsOfDirectLunsAttachedToVmsInPool().values().stream());
}
#end_block

#method_before
@Override
public Response export(Action action) {
    validateParameters(action, "storageDomain.id|name");
    return doAction(VdcActionType.ExportRepoImage, new ExportRepoImageParameters(guid, getStorageDomainId(action)), action);
}
#method_after
@Override
public Response export(Action action) {
    validateParameters(action, "storageDomain.id|name");
    return doAction(ActionType.ExportRepoImage, new ExportRepoImageParameters(guid, getStorageDomainId(action)), action);
}
#end_block

#method_before
@Override
public Disk update(Disk incoming) {
    // If the QCOW version is specified, then perform the update:
    if (incoming.isSetQcowVersion()) {
        return performUpdate(incoming, new QueryIdResolver<>(VdcQueryType.GetDiskByDiskId, IdQueryParameters.class), VdcActionType.AmendImageGroupVolumes, new UpdateParametersProvider());
    }
    // If the QCOW version isn't specified, then just retrieve the disk:
    return get();
}
#method_after
@Override
public Disk update(Disk incoming) {
    // If the QCOW version is specified, then perform the update:
    if (incoming.isSetQcowVersion()) {
        return performUpdate(incoming, new QueryIdResolver<>(VdcQueryType.GetDiskByDiskId, IdQueryParameters.class), ActionType.AmendImageGroupVolumes, new UpdateParametersProvider());
    }
    // If the QCOW version isn't specified, then just retrieve the disk:
    return get();
}
#end_block

#method_before
public VdcActionParametersBase getParameters(Disk incoming, org.ovirt.engine.core.common.businessentities.storage.Disk entity) {
    QcowCompat qcowCompat = DiskMapper.mapQcowVersion(incoming.getQcowVersion());
    return new AmendImageGroupVolumesCommandParameters(guid, qcowCompat);
}
#method_after
public ActionParametersBase getParameters(Disk incoming, org.ovirt.engine.core.common.businessentities.storage.Disk entity) {
    QcowCompat qcowCompat = DiskMapper.mapQcowVersion(incoming.getQcowVersion());
    return new AmendImageGroupVolumesCommandParameters(guid, qcowCompat);
}
#end_block

#method_before
@Override
public Response move(Action action) {
    validateParameters(action, "storageDomain.id|name");
    Guid storageDomainId = getStorageDomainId(action);
    Disk disk = get();
    Guid imageId = getDiskImageId(disk.getImageId());
    Guid sourceStorageDomainId = getSourceStorageDomainId(disk);
    MoveDiskParameters innerParams = new MoveDiskParameters(imageId, sourceStorageDomainId, storageDomainId);
    innerParams.setImageGroupID(asGuid(disk.getId()));
    MoveDisksParameters params = new MoveDisksParameters(Collections.singletonList(innerParams));
    return doAction(VdcActionType.MoveDisks, params, action);
}
#method_after
@Override
public Response move(Action action) {
    validateParameters(action, "storageDomain.id|name");
    Guid storageDomainId = getStorageDomainId(action);
    Disk disk = get();
    Guid imageId = getDiskImageId(disk.getImageId());
    Guid sourceStorageDomainId = getSourceStorageDomainId(disk);
    MoveDiskParameters innerParams = new MoveDiskParameters(imageId, sourceStorageDomainId, storageDomainId);
    innerParams.setImageGroupID(asGuid(disk.getId()));
    MoveDisksParameters params = new MoveDisksParameters(Collections.singletonList(innerParams));
    return doAction(ActionType.MoveDisks, params, action);
}
#end_block

#method_before
@Override
public Response copy(Action action) {
    validateParameters(action, "storageDomain.id|name");
    Guid storageDomainId = getStorageDomainId(action);
    Disk disk = get();
    Guid imageId = getDiskImageId(disk.getImageId());
    Guid sourceStorageDomainId = getSourceStorageDomainId(disk);
    MoveOrCopyImageGroupParameters params = new MoveOrCopyImageGroupParameters(imageId, sourceStorageDomainId, storageDomainId, ImageOperation.Copy);
    params.setImageGroupID(asGuid(disk.getId()));
    Disk actionDisk = action.getDisk();
    if (actionDisk != null) {
        String name = actionDisk.getName();
        String alias = actionDisk.getAlias();
        if (name != null && !StringUtils.isEmpty(name)) {
            params.setNewAlias(name);
        } else if (alias != null && !StringUtils.isEmpty(alias)) {
            params.setNewAlias(alias);
        }
    }
    return doAction(VdcActionType.MoveOrCopyDisk, params, action);
}
#method_after
@Override
public Response copy(Action action) {
    validateParameters(action, "storageDomain.id|name");
    Guid storageDomainId = getStorageDomainId(action);
    Disk disk = get();
    Guid imageId = getDiskImageId(disk.getImageId());
    Guid sourceStorageDomainId = getSourceStorageDomainId(disk);
    MoveOrCopyImageGroupParameters params = new MoveOrCopyImageGroupParameters(imageId, sourceStorageDomainId, storageDomainId, ImageOperation.Copy);
    params.setImageGroupID(asGuid(disk.getId()));
    Disk actionDisk = action.getDisk();
    if (actionDisk != null) {
        String name = actionDisk.getName();
        String alias = actionDisk.getAlias();
        if (name != null && !StringUtils.isEmpty(name)) {
            params.setNewAlias(name);
        } else if (alias != null && !StringUtils.isEmpty(alias)) {
            params.setNewAlias(alias);
        }
    }
    return doAction(ActionType.MoveOrCopyDisk, params, action);
}
#end_block

#method_before
@Override
public Response remove() {
    get();
    return performAction(VdcActionType.RemoveDisk, new RemoveDiskParameters(guid));
}
#method_after
@Override
public Response remove() {
    get();
    return performAction(ActionType.RemoveDisk, new RemoveDiskParameters(guid));
}
#end_block

#method_before
@Override
public Response sparsify(Action action) {
    Disk disk = get();
    if (disk == null) {
        throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND).build());
    }
    Guid imageId = getDiskImageId(disk.getImageId());
    StorageJobCommandParameters params = new StorageJobCommandParameters(imageId);
    return doAction(VdcActionType.SparsifyImage, params, action);
}
#method_after
@Override
public Response sparsify(Action action) {
    Disk disk = get();
    if (disk == null) {
        throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND).build());
    }
    Guid imageId = getDiskImageId(disk.getImageId());
    StorageJobCommandParameters params = new StorageJobCommandParameters(imageId);
    return doAction(ActionType.SparsifyImage, params, action);
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    newVmStatic = getParameters().getVmStaticData();
    if (isRunningConfigurationNeeded()) {
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContext());
        vmHandler.setVmDestroyOnReboot(getVm());
    } else if (!updateVmLease()) {
        return;
    }
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    vmStaticDao.incrementDbGeneration(getVm().getId());
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    newVmStatic.setQuotaId(getQuotaId());
    // Trigger OVF update for hosted engine VM only
    if (getVm().isHostedEngine()) {
        registerRollbackHandler(new TransactionCompletionListener() {

            @Override
            public void onSuccess() {
                ovfDataUpdater.triggerNow();
            }

            @Override
            public void onRollback() {
            // No notification is needed
            }
        });
    }
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!vmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    if ((getVm().isRunningOrPaused() || getVm().isPreviewSnapshot() || getVm().isSuspended()) && !getVm().isHostedEngine()) {
        if (getVm().getCustomCompatibilityVersion() == null && getParameters().getClusterLevelChangeFromVersion() != null) {
            // For backward compatibility after cluster version change
            // When running/paused: Set temporary custom compatibility version till the NextRun is applied (VM cold reboot)
            // When snapshot in preview: keep the custom compatibility version even after commit or roll back by undo
            newVmStatic.setCustomCompatibilityVersion(getParameters().getClusterLevelChangeFromVersion());
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    resourceManager.getVmManager(getVmId()).update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    vmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    liveUpdateCpuProfile();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    newVmStatic = getParameters().getVmStaticData();
    if (isRunningConfigurationNeeded()) {
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContext());
        vmHandler.setVmDestroyOnReboot(getVm());
    } else if (!updateVmLease()) {
        return;
    }
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    vmStaticDao.incrementDbGeneration(getVm().getId());
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    newVmStatic.setQuotaId(getQuotaId());
    // Trigger OVF update for hosted engine VM only
    if (getVm().isHostedEngine()) {
        registerRollbackHandler(new TransactionCompletionListener() {

            @Override
            public void onSuccess() {
                ovfDataUpdater.triggerNow();
            }

            @Override
            public void onRollback() {
            // No notification is needed
            }
        });
    }
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!vmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    if ((getVm().isRunningOrPaused() || getVm().isPreviewSnapshot() || getVm().isSuspended()) && !getVm().isHostedEngine()) {
        if (getVm().getCustomCompatibilityVersion() == null && getParameters().getClusterLevelChangeFromVersion() != null) {
            // For backward compatibility after cluster version change
            // When running/paused: Set temporary custom compatibility version till the NextRun is applied (VM cold reboot)
            // When snapshot in preview: keep the custom compatibility version even after commit or roll back by undo
            newVmStatic.setCustomCompatibilityVersion(getParameters().getClusterLevelChangeFromVersion());
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    updateAffinityLabels();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    resourceManager.getVmManager(getVmId()).update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    vmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    liveUpdateCpuProfile();
    setSucceeded(true);
}
#end_block

#method_before
private boolean updateVmLease() {
    if (Objects.equals(oldVm.getLeaseStorageDomainId(), newVmStatic.getLeaseStorageDomainId())) {
        return true;
    }
    if (!addVmLease(newVmStatic.getLeaseStorageDomainId(), newVmStatic.getId())) {
        return false;
    }
    // best effort to remove the lease from the previous storage domain
    removeVmLease(oldVm.getLeaseStorageDomainId(), oldVm.getId());
    return true;
}
#method_after
private boolean updateVmLease() {
    if (Objects.equals(oldVm.getLeaseStorageDomainId(), newVmStatic.getLeaseStorageDomainId())) {
        return true;
    }
    if (getVm().isNotRunning()) {
        if (!addVmLease(newVmStatic.getLeaseStorageDomainId(), newVmStatic.getId())) {
            return false;
        }
    } else {
        if (oldVm.getLeaseStorageDomainId() == null) {
            VmLeaseParameters params = new VmLeaseParameters(getStoragePoolId(), newVmStatic.getLeaseStorageDomainId(), newVmStatic.getId());
            params.setVdsId(getVm().getRunOnVds());
            params.setHotPlugLease(true);
            return runInternalAction(ActionType.AddVmLease, params).getSucceeded();
        }
        boolean hotUnplugSucceeded = false;
        try {
            hotUnplugSucceeded = runVdsCommand(VDSCommandType.HotUnplugLease, new LeaseVDSParameters(getVm().getRunOnVds(), oldVm.getId(), oldVm.getLeaseStorageDomainId())).getSucceeded();
        } catch (EngineException e) {
            log.error("Failure in hot unplugging a lease to VM {}, message: {}", oldVm.getId(), e.getMessage());
        }
        if (!hotUnplugSucceeded) {
            auditLog(this, AuditLogType.HOT_UNPLUG_LEASE_FAILED);
        }
    }
    // best effort to remove the lease from the previous storage domain
    removeVmLease(oldVm.getLeaseStorageDomainId(), oldVm.getId());
    return true;
}
#end_block

#method_before
private void updateVmTemplateVersion() {
    if (getVm().getStatus() == VMStatus.Down) {
        VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.UpdateVmVersion, new UpdateVmVersionParameters(getVmId(), getParameters().getVm().getVmtGuid(), getParameters().getVm().isUseLatestVersion()), getLock());
        if (result.getSucceeded()) {
            getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
        }
        setSucceeded(result.getSucceeded());
        setActionReturnValue(VdcActionType.UpdateVmVersion);
    } else {
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContext());
        setSucceeded(true);
    }
}
#method_after
private void updateVmTemplateVersion() {
    if (getVm().getStatus() == VMStatus.Down) {
        VdcReturnValueBase result = runInternalActionWithTasksContext(ActionType.UpdateVmVersion, new UpdateVmVersionParameters(getVmId(), getParameters().getVm().getVmtGuid(), getParameters().getVm().isUseLatestVersion()), getLock());
        if (result.getSucceeded()) {
            getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
        }
        setSucceeded(result.getSucceeded());
        setActionReturnValue(ActionType.UpdateVmVersion);
    } else {
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContext());
        setSucceeded(true);
    }
}
#end_block

#method_before
private void updateRngDevice() {
    if (!getParameters().isUpdateRngDevice()) {
        return;
    }
    VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(getParameters().getVmId()));
    List<VmRngDevice> rngDevs = query.getReturnValue();
    VdcReturnValueBase rngCommandResult = null;
    if (rngDevs.isEmpty()) {
        if (getParameters().getRngDevice() != null) {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            rngCommandResult = runInternalAction(VdcActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
        }
    } else {
        if (getParameters().getRngDevice() == null) {
            RngDeviceParameters params = new RngDeviceParameters(rngDevs.get(0), true);
            rngCommandResult = runInternalAction(VdcActionType.RemoveRngDevice, params, cloneContextAndDetachFromParent());
        } else {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            params.getRngDevice().setDeviceId(rngDevs.get(0).getDeviceId());
            rngCommandResult = runInternalAction(VdcActionType.UpdateRngDevice, params, cloneContextAndDetachFromParent());
        }
    }
    if (rngCommandResult != null && !rngCommandResult.getSucceeded()) {
        log.error("Updating RNG device of VM {} ({}) failed. Old RNG device = {}. New RNG device = {}.", getVm().getName(), getVm().getId(), rngDevs.isEmpty() ? null : rngDevs.get(0), getParameters().getRngDevice());
    }
}
#method_after
private void updateRngDevice() {
    if (!getParameters().isUpdateRngDevice()) {
        return;
    }
    VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(getParameters().getVmId()));
    List<VmRngDevice> rngDevs = query.getReturnValue();
    VdcReturnValueBase rngCommandResult = null;
    if (rngDevs.isEmpty()) {
        if (getParameters().getRngDevice() != null) {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            rngCommandResult = runInternalAction(ActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
        }
    } else {
        if (getParameters().getRngDevice() == null) {
            RngDeviceParameters params = new RngDeviceParameters(rngDevs.get(0), true);
            rngCommandResult = runInternalAction(ActionType.RemoveRngDevice, params, cloneContextAndDetachFromParent());
        } else {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            params.getRngDevice().setDeviceId(rngDevs.get(0).getDeviceId());
            rngCommandResult = runInternalAction(ActionType.UpdateRngDevice, params, cloneContextAndDetachFromParent());
        }
    }
    if (rngCommandResult != null && !rngCommandResult.getSucceeded()) {
        log.error("Updating RNG device of VM {} ({}) failed. Old RNG device = {}. New RNG device = {}.", getVm().getName(), getVm().getId(), rngDevs.isEmpty() ? null : rngDevs.get(0), getParameters().getRngDevice());
    }
}
#end_block

#method_before
private void hotSetCpus(VM newVm) {
    int currentSockets = getVm().getNumOfSockets();
    int newNumOfSockets = newVm.getNumOfSockets();
    // try hotplug only if topology (cpuPerSocket, threadsPerCpu) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && VmCommonUtils.isCpusToBeHotplugged(getVm(), newVm)) {
        HotSetNumberOfCpusParameters params = new HotSetNumberOfCpusParameters(newVmStatic, currentSockets < newNumOfSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        VdcReturnValueBase setNumberOfCpusResult = runInternalAction(VdcActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        // into the OVF store and automatically used during the next HE VM start
        if (!getVm().isHostedEngine()) {
            newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newNumOfSockets : currentSockets);
        }
        logHotSetActionEvent(setNumberOfCpusResult, AuditLogType.FAILED_HOT_SET_NUMBER_OF_CPUS);
    }
}
#method_after
private void hotSetCpus(VM newVm) {
    int currentSockets = getVm().getNumOfSockets();
    int newNumOfSockets = newVm.getNumOfSockets();
    // try hotplug only if topology (cpuPerSocket, threadsPerCpu) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && VmCommonUtils.isCpusToBeHotplugged(getVm(), newVm)) {
        HotSetNumberOfCpusParameters params = new HotSetNumberOfCpusParameters(newVmStatic, currentSockets < newNumOfSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        VdcReturnValueBase setNumberOfCpusResult = runInternalAction(ActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        // into the OVF store and automatically used during the next HE VM start
        if (!getVm().isHostedEngine()) {
            newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newNumOfSockets : currentSockets);
        }
        logHotSetActionEvent(setNumberOfCpusResult, AuditLogType.FAILED_HOT_SET_NUMBER_OF_CPUS);
    }
}
#end_block

#method_before
private void hotPlugMemoryDevice(int currentMemoryMb, int newAmountOfMemoryMb) {
    HotSetAmountOfMemoryParameters params = new HotSetAmountOfMemoryParameters(newVmStatic, currentMemoryMb < newAmountOfMemoryMb ? PlugAction.PLUG : PlugAction.UNPLUG, // We always use node 0, auto-numa should handle the allocation
    0, newAmountOfMemoryMb - currentMemoryMb);
    VdcReturnValueBase setAmountOfMemoryResult = runInternalAction(VdcActionType.HotSetAmountOfMemory, params, cloneContextAndDetachFromParent());
    // into the OVF store and automatically used during the next HE VM start
    if (!getVm().isHostedEngine()) {
        newVmStatic.setMemSizeMb(setAmountOfMemoryResult.getSucceeded() ? newAmountOfMemoryMb : currentMemoryMb);
    }
    logHotSetActionEvent(setAmountOfMemoryResult, AuditLogType.FAILED_HOT_SET_MEMORY);
}
#method_after
private void hotPlugMemoryDevice(int currentMemoryMb, int newAmountOfMemoryMb) {
    HotSetAmountOfMemoryParameters params = new HotSetAmountOfMemoryParameters(newVmStatic, currentMemoryMb < newAmountOfMemoryMb ? PlugAction.PLUG : PlugAction.UNPLUG, // We always use node 0, auto-numa should handle the allocation
    0, newAmountOfMemoryMb - currentMemoryMb);
    VdcReturnValueBase setAmountOfMemoryResult = runInternalAction(ActionType.HotSetAmountOfMemory, params, cloneContextAndDetachFromParent());
    // into the OVF store and automatically used during the next HE VM start
    if (!getVm().isHostedEngine()) {
        newVmStatic.setMemSizeMb(setAmountOfMemoryResult.getSucceeded() ? newAmountOfMemoryMb : currentMemoryMb);
    }
    logHotSetActionEvent(setAmountOfMemoryResult, AuditLogType.FAILED_HOT_SET_MEMORY);
}
#end_block

#method_before
private void updateWatchdog() {
    // do not update if this flag is not set
    if (getParameters().isUpdateWatchdog()) {
        VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getParameters().getVmId()));
        List<VmWatchdog> watchdogs = query.getReturnValue();
        if (watchdogs.isEmpty()) {
            if (getParameters().getWatchdog() == null) {
            // nothing to do, no watchdog and no watchdog to create
            } else {
                WatchdogParameters parameters = new WatchdogParameters();
                parameters.setId(getParameters().getVmId());
                parameters.setAction(getParameters().getWatchdog().getAction());
                parameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(VdcActionType.AddWatchdog, parameters, cloneContextAndDetachFromParent());
            }
        } else {
            WatchdogParameters watchdogParameters = new WatchdogParameters();
            watchdogParameters.setId(getParameters().getVmId());
            if (getParameters().getWatchdog() == null) {
                // there is a watchdog in the vm, there should not be any, so let's delete
                runInternalAction(VdcActionType.RemoveWatchdog, watchdogParameters, cloneContextAndDetachFromParent());
            } else {
                // there is a watchdog in the vm, we have to update.
                watchdogParameters.setAction(getParameters().getWatchdog().getAction());
                watchdogParameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(VdcActionType.UpdateWatchdog, watchdogParameters, cloneContextAndDetachFromParent());
            }
        }
    }
}
#method_after
private void updateWatchdog() {
    // do not update if this flag is not set
    if (getParameters().isUpdateWatchdog()) {
        VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getParameters().getVmId()));
        List<VmWatchdog> watchdogs = query.getReturnValue();
        if (watchdogs.isEmpty()) {
            if (getParameters().getWatchdog() == null) {
            // nothing to do, no watchdog and no watchdog to create
            } else {
                WatchdogParameters parameters = new WatchdogParameters();
                parameters.setId(getParameters().getVmId());
                parameters.setAction(getParameters().getWatchdog().getAction());
                parameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(ActionType.AddWatchdog, parameters, cloneContextAndDetachFromParent());
            }
        } else {
            WatchdogParameters watchdogParameters = new WatchdogParameters();
            watchdogParameters.setId(getParameters().getVmId());
            if (getParameters().getWatchdog() == null) {
                // there is a watchdog in the vm, there should not be any, so let's delete
                runInternalAction(ActionType.RemoveWatchdog, watchdogParameters, cloneContextAndDetachFromParent());
            } else {
                // there is a watchdog in the vm, we have to update.
                watchdogParameters.setAction(getParameters().getWatchdog().getAction());
                watchdogParameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(ActionType.UpdateWatchdog, watchdogParameters, cloneContextAndDetachFromParent());
            }
        }
    }
}
#end_block

#method_before
private void removeGraphicsDevice(GraphicsType type) {
    GraphicsDevice existingGraphicsDevice = getGraphicsDevOfType(type);
    if (existingGraphicsDevice != null) {
        getBackend().runInternalAction(VdcActionType.RemoveGraphicsDevice, new GraphicsParameters(existingGraphicsDevice));
    }
}
#method_after
private void removeGraphicsDevice(GraphicsType type) {
    GraphicsDevice existingGraphicsDevice = getGraphicsDevOfType(type);
    if (existingGraphicsDevice != null) {
        getBackend().runInternalAction(ActionType.RemoveGraphicsDevice, new GraphicsParameters(existingGraphicsDevice));
    }
}
#end_block

#method_before
private void addOrUpdateGraphicsDevice(GraphicsDevice device) {
    GraphicsDevice existingGraphicsDevice = getGraphicsDevOfType(device.getGraphicsType());
    device.setVmId(getVmId());
    getBackend().runInternalAction(existingGraphicsDevice == null ? VdcActionType.AddGraphicsDevice : VdcActionType.UpdateGraphicsDevice, new GraphicsParameters(device));
}
#method_after
private void addOrUpdateGraphicsDevice(GraphicsDevice device) {
    GraphicsDevice existingGraphicsDevice = getGraphicsDevOfType(device.getGraphicsType());
    device.setVmId(getVmId());
    getBackend().runInternalAction(existingGraphicsDevice == null ? ActionType.AddGraphicsDevice : ActionType.UpdateGraphicsDevice, new GraphicsParameters(device));
}
#end_block

#method_before
private void updateVmNumaNodes() {
    if (!getParameters().isUpdateNuma()) {
        return;
    }
    List<VmNumaNode> newList = getParameters().getVmStaticData().getvNumaNodeList();
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getParameters().getVm(), new ArrayList<>(newList));
    addLogMessages(getBackend().runInternalAction(VdcActionType.SetVmNumaNodes, params));
}
#method_after
private void updateVmNumaNodes() {
    if (!getParameters().isUpdateNuma()) {
        return;
    }
    List<VmNumaNode> newList = getParameters().getVmStaticData().getvNumaNodeList();
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getParameters().getVm(), new ArrayList<>(newList));
    addLogMessages(getBackend().runInternalAction(ActionType.SetVmNumaNodes, params));
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmHandler.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!getParameters().getVmStaticData().isAutoStartup()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED_WITH_HA_OFF);
        }
        if (!FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED);
        }
        if (!validateLeaseStorageDomain(getParameters().getVmStaticData().getLeaseStorageDomainId())) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmHandler.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!canAddLease()) {
            return false;
        }
        if (!getVm().isDown() && getParameters().getVmStaticData().getLeaseStorageDomainId() != null && getVm().getLeaseStorageDomainId() != null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOT_SWAPPING_VM_LEASES_NOT_SUPPORTED);
        }
    }
    return true;
}
#end_block

#method_before
public String build() {
    writeHeader();
    writeName();
    writeId();
    writeMemory();
    writeIoThreads();
    writeMaxMemory();
    writevCpu();
    writeMetadata();
    writeSystemInfo();
    writeClock();
    writeFeatures();
    writeCpu();
    writeNumaTune();
    writeDevices();
    // note that this must be called after writeDevices to get the serial console, if exists
    writeOs();
    return writer.getStringXML();
}
#method_after
public String build() {
    writeHeader();
    writeName();
    writeId();
    writeMemory();
    writeIoThreads();
    writeMaxMemory();
    writevCpu();
    writeMetadata();
    writeSystemInfo();
    writeClock();
    writePowerEvents();
    writeFeatures();
    writeCpu();
    writeNumaTune();
    writeDevices();
    // note that this must be called after writeDevices to get the serial console, if exists
    writeOs();
    return writer.getStringXML();
}
#end_block

#method_before
private void writeVmMetadata() {
    writer.setPrefix(OVIRT_VM_PREFIX, OVIRT_VM_URI);
    writer.writeStartElement(OVIRT_VM_URI, "vm");
    writer.writeNamespace(OVIRT_VM_PREFIX, OVIRT_VM_URI);
    if (vm.isRunOnce()) {
        writer.writeStartElement(OVIRT_VM_URI, "destroy_on_reboot");
        writer.writeAttributeString("type", "bool");
        writer.writeRaw("True");
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#method_after
private void writeVmMetadata() {
    writer.setPrefix(OVIRT_VM_PREFIX, OVIRT_VM_URI);
    writer.writeStartElement(OVIRT_VM_URI, "vm");
    writer.writeNamespace(OVIRT_VM_PREFIX, OVIRT_VM_URI);
    writer.writeEndElement();
}
#end_block

#method_before
private void updateInterfaceStatistics() {
    List<VmNetworkInterface> ifsStats = vdsmVm.getInterfaceStatistics();
    if (ifsStats == null || ifsStats.isEmpty()) {
        return;
    }
    loadVmNetworkInterfaces();
    List<String> macs = new ArrayList<>();
    statistics.setUsageNetworkPercent(0);
    NetworkStatisticsBuilder statsBuilder = new NetworkStatisticsBuilder();
    for (VmNetworkInterface ifStats : ifsStats) {
        boolean firstTime = !macs.contains(ifStats.getMacAddress());
        VmNetworkInterface vmIface = ifaces.stream().filter(iface -> iface.getMacAddress().equals(ifStats.getMacAddress())).findFirst().orElse(null);
        if (vmIface == null) {
            continue;
        }
        // if rtl+pv it will get here 2 times (we take the max one)
        if (firstTime) {
            statsBuilder.updateExistingInterfaceStatistics(vmIface, ifStats);
        } else {
            vmIface.getStatistics().setReceiveRate(max(vmIface.getStatistics().getReceiveRate(), ifStats.getStatistics().getReceiveRate()));
            vmIface.getStatistics().setReceiveDropRate(max(vmIface.getStatistics().getReceiveDropRate(), ifStats.getStatistics().getReceiveDropRate()));
            vmIface.getStatistics().setTransmitRate(max(vmIface.getStatistics().getTransmitRate(), ifStats.getStatistics().getTransmitRate()));
            vmIface.getStatistics().setTransmitDropRate(max(vmIface.getStatistics().getTransmitDropRate(), ifStats.getStatistics().getTransmitDropRate()));
        }
        vmIface.setVmId(dbVm.getId());
        if (ifStats.getSpeed() != null && vmIface.getStatistics().getReceiveRate() != null && vmIface.getStatistics().getReceiveRate() > 0) {
            double rx_percent = vmIface.getStatistics().getReceiveRate();
            double tx_percent = vmIface.getStatistics().getTransmitRate();
            statistics.setUsageNetworkPercent(max(statistics.getUsageNetworkPercent(), (int) max(rx_percent, tx_percent)));
        }
        if (firstTime) {
            macs.add(ifStats.getMacAddress());
        }
    }
    statistics.setUsageNetworkPercent(min(statistics.getUsageNetworkPercent(), 100));
    Integer usageHistoryLimit = Config.getValue(ConfigValues.UsageHistoryLimit);
    statistics.addNetworkUsageHistory(statistics.getUsageNetworkPercent(), usageHistoryLimit);
}
#method_after
private void updateInterfaceStatistics() {
    List<VmNetworkInterface> ifsStats = vdsmVm.getInterfaceStatistics();
    if (ifsStats == null || ifsStats.isEmpty()) {
        return;
    }
    loadVmNetworkInterfaces();
    List<String> macs = new ArrayList<>();
    statistics.setUsageNetworkPercent(0);
    NetworkStatisticsBuilder statsBuilder = new NetworkStatisticsBuilder();
    for (VmNetworkInterface ifStats : ifsStats) {
        boolean firstTime = !macs.contains(ifStats.getMacAddress());
        VmNetworkInterface vmIface = ifaces.stream().filter(iface -> iface.getMacAddress().equals(ifStats.getMacAddress())).findFirst().orElse(null);
        if (vmIface == null) {
            continue;
        }
        // VDSM is going to stop reporting the speed, so we override it with the value from the database
        // TODO: the speed should not be part of the statistics at all, needs to move it elsewhere
        ifStats.setSpeed(vmIface.getSpeed());
        // if rtl+pv it will get here 2 times (we take the max one)
        if (firstTime) {
            statsBuilder.updateExistingInterfaceStatistics(vmIface, ifStats);
        } else {
            vmIface.getStatistics().setReceiveRate(max(vmIface.getStatistics().getReceiveRate(), ifStats.getStatistics().getReceiveRate()));
            vmIface.getStatistics().setReceiveDropRate(max(vmIface.getStatistics().getReceiveDropRate(), ifStats.getStatistics().getReceiveDropRate()));
            vmIface.getStatistics().setTransmitRate(max(vmIface.getStatistics().getTransmitRate(), ifStats.getStatistics().getTransmitRate()));
            vmIface.getStatistics().setTransmitDropRate(max(vmIface.getStatistics().getTransmitDropRate(), ifStats.getStatistics().getTransmitDropRate()));
        }
        vmIface.setVmId(dbVm.getId());
        if (ifStats.getSpeed() != null && vmIface.getStatistics().getReceiveRate() != null && vmIface.getStatistics().getReceiveRate() > 0) {
            double rx_percent = vmIface.getStatistics().getReceiveRate();
            double tx_percent = vmIface.getStatistics().getTransmitRate();
            statistics.setUsageNetworkPercent(max(statistics.getUsageNetworkPercent(), (int) max(rx_percent, tx_percent)));
        }
        if (firstTime) {
            macs.add(ifStats.getMacAddress());
        }
    }
    statistics.setUsageNetworkPercent(min(statistics.getUsageNetworkPercent(), 100));
    Integer usageHistoryLimit = Config.getValue(ConfigValues.UsageHistoryLimit);
    statistics.addNetworkUsageHistory(statistics.getUsageNetworkPercent(), usageHistoryLimit);
}
#end_block

#method_before
public void addVmInitToDB(VmBase vm) {
    if (vm.getVmInit() != null) {
        vm.getVmInit().setId(vm.getId());
        VmInit oldVmInit = vmInitDao.get(vm.getId());
        if (oldVmInit == null) {
            vmInitDao.save(vm.getVmInit());
        } else {
            if (vm.getVmInit().isPasswordAlreadyStored()) {
                // since we are not always returning the password in
                // updateVmInitFromDB()
                // method (we don't want to display it in the UI/API) we
                // don't want to override
                // the password if the flag is on
                vm.getVmInit().setRootPassword(oldVmInit.getRootPassword());
            }
            vmInitDao.update(vm.getVmInit());
        }
    }
}
#method_after
public void addVmInitToDB(VmInit vmInit) {
    if (vmInit != null) {
        VmInit oldVmInit = vmInitDao.get(vmInit.getId());
        if (oldVmInit == null) {
            vmInitDao.save(vmInit);
        } else {
            if (vmInit.isPasswordAlreadyStored()) {
                // since we are not always returning the password in
                // updateVmInitFromDB()
                // method (we don't want to display it in the UI/API) we
                // don't want to override
                // the password if the flag is on
                vmInit.setRootPassword(oldVmInit.getRootPassword());
            }
            vmInitDao.update(vmInit);
        }
    }
}
#end_block

#method_before
public void updateVmInitToDB(VmBase vm) {
    if (vm.getVmInit() != null) {
        addVmInitToDB(vm);
    } else {
        removeVmInitFromDB(vm);
    }
}
#method_after
public void updateVmInitToDB(VmBase vm) {
    if (vm.getVmInit() != null) {
        addVmInitToDB(vm.getVmInit());
    } else {
        removeVmInitFromDB(vm);
    }
}
#end_block

#method_before
public static ValidationResult canRunActionOnNonManagedVm(VM vm, VdcActionType actionType) {
    ValidationResult validationResult = ValidationResult.VALID;
    if (!VmActionByVmOriginTypeValidator.isCommandAllowed(vm, actionType)) {
        validationResult = new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RUN_ACTION_ON_NON_MANAGED_VM);
    }
    return validationResult;
}
#method_after
public static ValidationResult canRunActionOnNonManagedVm(VM vm, ActionType actionType) {
    ValidationResult validationResult = ValidationResult.VALID;
    if (!VmActionByVmOriginTypeValidator.isCommandAllowed(vm, actionType)) {
        validationResult = new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RUN_ACTION_ON_NON_MANAGED_VM);
    }
    return validationResult;
}
#end_block

#method_before
private boolean unplugPassthroughNics() {
    if (passthroughNicsUnplugged) {
        // no need to unplug more than once
        return true;
    }
    List<ActivateDeactivateVmNicParameters> parametersList = createActivateDeactivateVmNicParameters(getAllVmPassthroughNics(), PlugAction.UNPLUG);
    log.debug("About to call {} with parameters: {}", VdcActionType.ActivateDeactivateVmNic, Arrays.toString(parametersList.toArray()));
    for (ActivateDeactivateVmNicParameters parameter : parametersList) {
        VdcReturnValueBase returnValue = runInternalAction(VdcActionType.ActivateDeactivateVmNic, parameter);
        if (!returnValue.getSucceeded()) {
            returnValue.getValidationMessages().forEach(this::addValidationMessage);
            return false;
        }
    }
    passthroughNicsUnplugged = true;
    return true;
}
#method_after
private boolean unplugPassthroughNics() {
    if (passthroughNicsUnplugged) {
        // no need to unplug more than once
        return true;
    }
    List<ActivateDeactivateVmNicParameters> parametersList = createActivateDeactivateVmNicParameters(getAllVmPassthroughNics(), PlugAction.UNPLUG);
    log.debug("About to call {} with parameters: {}", ActionType.ActivateDeactivateVmNic, Arrays.toString(parametersList.toArray()));
    for (ActivateDeactivateVmNicParameters parameter : parametersList) {
        VdcReturnValueBase returnValue = runInternalAction(ActionType.ActivateDeactivateVmNic, parameter);
        if (!returnValue.getSucceeded()) {
            returnValue.getValidationMessages().forEach(this::addValidationMessage);
            return false;
        }
    }
    passthroughNicsUnplugged = true;
    return true;
}
#end_block

#method_before
private List<VmNic> replugNics(List<ActivateDeactivateVmNicParameters> parametersList) {
    log.debug("About to call {} with parameters: {}", VdcActionType.ActivateDeactivateVmNic, Arrays.toString(parametersList.toArray()));
    List<VmNic> notRepluggedNics = new ArrayList<>();
    for (ActivateDeactivateVmNicParameters parameter : parametersList) {
        VdcReturnValueBase returnValue = runInternalAction(VdcActionType.ActivateDeactivateVmNic, parameter);
        boolean nicPlugSucceeded = returnValue.getSucceeded();
        if (!nicPlugSucceeded) {
            notRepluggedNics.add(parameter.getNic());
        }
    }
    return notRepluggedNics;
}
#method_after
private List<VmNic> replugNics(List<ActivateDeactivateVmNicParameters> parametersList) {
    log.debug("About to call {} with parameters: {}", ActionType.ActivateDeactivateVmNic, Arrays.toString(parametersList.toArray()));
    List<VmNic> notRepluggedNics = new ArrayList<>();
    for (ActivateDeactivateVmNicParameters parameter : parametersList) {
        VdcReturnValueBase returnValue = runInternalAction(ActionType.ActivateDeactivateVmNic, parameter);
        boolean nicPlugSucceeded = returnValue.getSucceeded();
        if (!nicPlugSucceeded) {
            notRepluggedNics.add(parameter.getNic());
        }
    }
    return notRepluggedNics;
}
#end_block

#method_before
private MigrateVDSCommandParameters createMigrateVDSCommandParameters() {
    String srcVdsHost = getVds().getHostName();
    String dstVdsHost = String.format("%1$s:%2$s", getDestinationVds().getHostName(), getDestinationVds().getPort());
    Map<String, Object> convergenceSchedule = null;
    Integer maxBandwidth = null;
    Boolean autoConverge = getAutoConverge();
    Boolean migrateCompressed = getMigrateCompressed();
    Boolean enableGuestEvents = null;
    Integer maxIncomingMigrations = null;
    Integer maxOutgoingMigrations = null;
    if (FeatureSupported.migrationPoliciesSupported(getVm().getCompatibilityVersion())) {
        MigrationPolicy clusterMigrationPolicy = convergenceConfigProvider.getMigrationPolicy(getCluster().getMigrationPolicyId(), getCluster().getCompatibilityVersion());
        MigrationPolicy effectiveMigrationPolicy = findEffectiveConvergenceConfig(clusterMigrationPolicy);
        ConvergenceConfig convergenceConfig = getVm().getStatus() == VMStatus.Paused ? filterPostcopyOutOfConvergenceConfig(effectiveMigrationPolicy.getConfig()) : effectiveMigrationPolicy.getConfig();
        convergenceSchedule = ConvergenceSchedule.from(convergenceConfig).asMap();
        maxBandwidth = getMaxBandwidth(clusterMigrationPolicy);
        if (!NoMigrationPolicy.ID.equals(effectiveMigrationPolicy.getId())) {
            autoConverge = effectiveMigrationPolicy.isAutoConvergence();
            migrateCompressed = effectiveMigrationPolicy.isMigrationCompression();
        }
        enableGuestEvents = effectiveMigrationPolicy.isEnableGuestEvents();
        maxIncomingMigrations = maxOutgoingMigrations = effectiveMigrationPolicy.getMaxMigrations();
    }
    return new MigrateVDSCommandParameters(getVdsId(), getVmId(), srcVdsHost, getDestinationVdsId(), dstVdsHost, MigrationMethod.ONLINE, isTunnelMigrationUsed(), getLiteralMigrationNetworkIp(), getVds().getClusterCompatibilityVersion(), getMaximumMigrationDowntime(), autoConverge, migrateCompressed, getDestinationVds().getConsoleAddress(), maxBandwidth, convergenceSchedule, enableGuestEvents, maxIncomingMigrations, maxOutgoingMigrations);
}
#method_after
private MigrateVDSCommandParameters createMigrateVDSCommandParameters() {
    String srcVdsHost = getVds().getHostName();
    String dstVdsHost = String.format("%1$s:%2$s", getDestinationVds().getHostName(), getDestinationVds().getPort());
    Map<String, Object> convergenceSchedule = null;
    Integer maxBandwidth = null;
    Boolean autoConverge = getAutoConverge();
    Boolean migrateCompressed = getMigrateCompressed();
    Boolean enableGuestEvents = null;
    Integer maxIncomingMigrations = null;
    Integer maxOutgoingMigrations = null;
    if (FeatureSupported.migrationPoliciesSupported(getVm().getCompatibilityVersion())) {
        MigrationPolicy clusterMigrationPolicy = convergenceConfigProvider.getMigrationPolicy(getCluster().getMigrationPolicyId(), getCluster().getCompatibilityVersion());
        MigrationPolicy effectiveMigrationPolicy = findEffectiveConvergenceConfig(clusterMigrationPolicy);
        ConvergenceConfig convergenceConfig = getVm().getStatus() == VMStatus.Paused ? filterOutPostcopy(effectiveMigrationPolicy.getConfig()) : effectiveMigrationPolicy.getConfig();
        convergenceSchedule = ConvergenceSchedule.from(convergenceConfig).asMap();
        maxBandwidth = getMaxBandwidth(clusterMigrationPolicy);
        if (!NoMigrationPolicy.ID.equals(effectiveMigrationPolicy.getId())) {
            autoConverge = effectiveMigrationPolicy.isAutoConvergence();
            migrateCompressed = effectiveMigrationPolicy.isMigrationCompression();
        }
        enableGuestEvents = effectiveMigrationPolicy.isEnableGuestEvents();
        maxIncomingMigrations = maxOutgoingMigrations = effectiveMigrationPolicy.getMaxMigrations();
    }
    return new MigrateVDSCommandParameters(getVdsId(), getVmId(), srcVdsHost, getDestinationVdsId(), dstVdsHost, MigrationMethod.ONLINE, isTunnelMigrationUsed(), getLiteralMigrationNetworkIp(), getVds().getClusterCompatibilityVersion(), getMaximumMigrationDowntime(), autoConverge, migrateCompressed, getDestinationVds().getConsoleAddress(), maxBandwidth, convergenceSchedule, enableGuestEvents, maxIncomingMigrations, maxOutgoingMigrations);
}
#end_block

#method_before
private void updateVmAfterMigrationToDifferentCluster() {
    if (getParameters().getTargetClusterId() == null || getVm().getClusterId().equals(getParameters().getTargetClusterId())) {
        return;
    }
    ChangeVMClusterParameters params = new ChangeVMClusterParameters(getParameters().getTargetClusterId(), getVmId(), getVm().getCustomCompatibilityVersion());
    setSucceeded(getBackend().runInternalAction(VdcActionType.ChangeVMCluster, params).getSucceeded());
}
#method_after
private void updateVmAfterMigrationToDifferentCluster() {
    if (getParameters().getTargetClusterId() == null || getVm().getClusterId().equals(getParameters().getTargetClusterId())) {
        return;
    }
    ChangeVMClusterParameters params = new ChangeVMClusterParameters(getParameters().getTargetClusterId(), getVmId(), getVm().getCustomCompatibilityVersion());
    setSucceeded(getBackend().runInternalAction(ActionType.ChangeVMCluster, params).getSucceeded());
}
#end_block

#method_before
public static String encrypt(ServletContext ctx, String rawText) throws Exception {
    SsoLocalConfig config = getSsoContext(ctx).getSsoLocalConfig();
    try (InputStream in = new FileInputStream(config.getPKIEngineCert().getAbsoluteFile())) {
        return EnvelopeEncryptDecrypt.encrypt("AES/OFB/PKCS5Padding", 256, CertificateFactory.getInstance("X.509").generateCertificate(in), 100, rawText.getBytes(StandardCharsets.UTF_8));
    }
}
#method_after
public static String encrypt(ServletContext ctx, String rawText) throws Exception {
    return EnvelopeEncryptDecrypt.encrypt("AES/OFB/PKCS5Padding", 256, getSsoContext(ctx).getEngineCertificate(), 100, rawText.getBytes(StandardCharsets.UTF_8));
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(pause());
    optional(useCloudInit());
    optional(useSysprep());
    optional(vm().customCpuModel());
    optional(vm().customEmulatedMachine());
    optional(vm().display().type());
    optional(vm().domain().name());
    optional(vm().domain().user().password());
    optional(vm().domain().user().userName());
    optional(vm().initialization().activeDirectoryOu());
    optional(vm().initialization().authorizedSshKeys());
    optional(vm().initialization().cloudInit().host().address());
    optional(vm().initialization().cloudInit().regenerateSshKeys());
    optional(vm().initialization().cloudInit().timezone());
    optional(vm().initialization().customScript());
    optional(vm().initialization().dnsSearch());
    optional(vm().initialization().dnsServers());
    optional(vm().initialization().domain());
    optional(vm().initialization().hostName());
    optional(vm().initialization().inputLocale());
    optional(vm().initialization().orgName());
    optional(vm().initialization().regenerateSshKeys());
    optional(vm().initialization().rootPassword());
    optional(vm().initialization().systemLocale());
    optional(vm().initialization().timezone());
    optional(vm().initialization().uiLanguage());
    optional(vm().initialization().userName());
    optional(vm().initialization().windowsLicenseKey());
    optional(vm().os().cmdline());
    optional(vm().os().initrd());
    optional(vm().os().kernel());
    optional(vm().placementPolicy().affinity());
    optional(vm().stateless());
    optional(authorizedKey().user().name());
    optional(vm().os().boot().devices()[COLLECTION]);
    optional(vm().initialization().cloudInit().networkConfiguration().dns().searchDomains()[COLLECTION].address());
    optional(vm().initialization().cloudInit().users()[COLLECTION].name());
    optional(vm().initialization().cloudInit().users()[COLLECTION].password());
    optional(vm().initialization().cloudInit().authorizedKeys()[COLLECTION].key());
    optional(vm().initialization().cloudInit().networkConfiguration().nics()[COLLECTION].bootProtocol());
    optional(vm().initialization().cloudInit().networkConfiguration().nics()[COLLECTION].name());
    optional(vm().initialization().cloudInit().networkConfiguration().nics()[COLLECTION].network().ip().gateway());
    optional(vm().initialization().cloudInit().networkConfiguration().nics()[COLLECTION].network().ip().netmask());
    optional(vm().initialization().cloudInit().networkConfiguration().nics()[COLLECTION].onBoot());
    optional(vm().initialization().cloudInit().networkConfiguration().dns().servers()[COLLECTION].address());
    or(optional(vm().placementPolicy().hosts()[COLLECTION].id()), optional(vm().placementPolicy().hosts()[COLLECTION].name()));
    // optional(vm().initialization().cloudInit().payloadFiles()[COLLECTION].content());
    // optional(vm().initialization().cloudInit().payloadFiles()[COLLECTION].name());
    // optional(vm().initialization().cloudInit().payloadFiles()[COLLECTION].type());
    optional(vm().initialization().nicConfigurations()[COLLECTION].bootProtocol());
    optional(vm().initialization().nicConfigurations()[COLLECTION].ip().address());
    optional(vm().initialization().nicConfigurations()[COLLECTION].ip().gateway());
    optional(vm().initialization().nicConfigurations()[COLLECTION].ip().netmask());
    optional(vm().initialization().nicConfigurations()[COLLECTION].name());
    optional(vm().initialization().nicConfigurations()[COLLECTION].onBoot());
}
#method_after
@InputDetail
default void inputDetail() {
    optional(pause());
    optional(useCloudInit());
    optional(useSysprep());
    optional(vm().customCpuModel());
    optional(vm().customEmulatedMachine());
    optional(vm().display().type());
    optional(vm().domain().name());
    optional(vm().domain().user().password());
    optional(vm().domain().user().userName());
    optional(vm().initialization().activeDirectoryOu());
    optional(vm().initialization().authorizedSshKeys());
    optional(vm().initialization().cloudInit().host().address());
    optional(vm().initialization().cloudInit().regenerateSshKeys());
    optional(vm().initialization().cloudInit().timezone());
    optional(vm().initialization().customScript());
    optional(vm().initialization().dnsSearch());
    optional(vm().initialization().dnsServers());
    optional(vm().initialization().domain());
    optional(vm().initialization().hostName());
    optional(vm().initialization().inputLocale());
    optional(vm().initialization().orgName());
    optional(vm().initialization().regenerateSshKeys());
    optional(vm().initialization().rootPassword());
    optional(vm().initialization().systemLocale());
    optional(vm().initialization().timezone());
    optional(vm().initialization().uiLanguage());
    optional(vm().initialization().userName());
    optional(vm().initialization().windowsLicenseKey());
    optional(vm().os().cmdline());
    optional(vm().os().initrd());
    optional(vm().os().kernel());
    optional(vm().placementPolicy().affinity());
    optional(vm().stateless());
    optional(authorizedKey().user().name());
    optional(vm().os().boot().devices()[COLLECTION]);
    optional(vm().initialization().cloudInit().networkConfiguration().dns().searchDomains()[COLLECTION].address());
    optional(vm().initialization().cloudInit().users()[COLLECTION].name());
    optional(vm().initialization().cloudInit().users()[COLLECTION].password());
    optional(vm().initialization().cloudInit().authorizedKeys()[COLLECTION].key());
    optional(vm().initialization().cloudInit().networkConfiguration().nics()[COLLECTION].bootProtocol());
    optional(vm().initialization().cloudInit().networkConfiguration().nics()[COLLECTION].name());
    optional(vm().initialization().cloudInit().networkConfiguration().nics()[COLLECTION].network().ip().gateway());
    optional(vm().initialization().cloudInit().networkConfiguration().nics()[COLLECTION].network().ip().netmask());
    optional(vm().initialization().cloudInit().networkConfiguration().nics()[COLLECTION].onBoot());
    optional(vm().initialization().cloudInit().networkConfiguration().dns().servers()[COLLECTION].address());
    or(optional(vm().placementPolicy().hosts()[COLLECTION].id()), optional(vm().placementPolicy().hosts()[COLLECTION].name()));
    // optional(vm().initialization().cloudInit().payloadFiles()[COLLECTION].content());
    // optional(vm().initialization().cloudInit().payloadFiles()[COLLECTION].name());
    // optional(vm().initialization().cloudInit().payloadFiles()[COLLECTION].type());
    optional(vm().initialization().nicConfigurations()[COLLECTION].bootProtocol());
    optional(vm().initialization().nicConfigurations()[COLLECTION].ip().address());
    optional(vm().initialization().nicConfigurations()[COLLECTION].ip().gateway());
    optional(vm().initialization().nicConfigurations()[COLLECTION].ip().netmask());
    optional(vm().initialization().nicConfigurations()[COLLECTION].name());
    optional(vm().initialization().nicConfigurations()[COLLECTION].onBoot());
    optional(_volatile());
}
#end_block

#method_before
public void setDetailModels(List<HasEntity<D>> value) {
    if (detailModels != value) {
        detailModels = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("DetailModels"));
    }
}
#method_after
public void setDetailModels(List<HasEntity<D>> value) {
    if (detailModels != value) {
        detailModels = value;
        onPropertyChanged(new PropertyChangedEventArgs(DETAIL_MODELS));
    }
}
#end_block

#method_before
public void setActiveDetailModel(HasEntity<D> value) {
    if (!activeDetailModels.contains(value)) {
        activeDetailModelChanging(value, true);
        activeDetailModels.clear();
        activeDetailModels.add(value);
        activeDetailModelChanged();
        onPropertyChanged(new PropertyChangedEventArgs(ACTIVE_DETAIL_MODEL));
    }
}
#method_after
public void setActiveDetailModel(HasEntity<D> value) {
    if (!activeDetailModels.contains(value)) {
        activeDetailModelChanging(value, true);
        activeDetailModels.clear();
        activeDetailModels.add(value);
        activeDetailModelChanged();
        onPropertyChanged(new PropertyChangedEventArgs(ACTIVE_DETAIL_MODELS));
    }
}
#end_block

#method_before
public void addActiveDetailModel(HasEntity<D> value) {
    if (!activeDetailModels.contains(value)) {
        activeDetailModelChanging(value, false);
        activeDetailModels.add(value);
        activeDetailModelChanged();
        onPropertyChanged(new PropertyChangedEventArgs(ACTIVE_DETAIL_MODEL));
    }
}
#method_after
public void addActiveDetailModel(HasEntity<D> value) {
    if (!activeDetailModels.contains(value)) {
        activeDetailModelChanging(value, false);
        activeDetailModels.add(value);
        activeDetailModelChanged();
        onPropertyChanged(new PropertyChangedEventArgs(ACTIVE_DETAIL_MODELS));
    }
}
#end_block

#method_before
private void activeDetailModelChanging(HasEntity<D> newValue, boolean stopRefresh) {
    for (HasEntity<D> oldValue : activeDetailModels) {
        // Make sure we had set an entity property of details model.
        if (oldValue != null && stopRefresh) {
            oldValue.setEntity(null);
            if (oldValue instanceof SearchableListModel) {
                ((SearchableListModel) oldValue).stopRefresh();
            }
        }
    }
    if (newValue != null) {
        newValue.setEntity(provideDetailModelEntity(getSelectedItem()));
    }
}
#method_after
private void activeDetailModelChanging(HasEntity<D> newValue, boolean stopRefresh) {
    if (stopRefresh) {
        for (HasEntity<D> oldValue : activeDetailModels) {
            // Make sure we had set an entity property of details model.
            if (oldValue != null) {
                oldValue.setEntity(null);
                if (oldValue instanceof SearchableListModel) {
                    ((SearchableListModel) oldValue).stopRefresh();
                }
            }
        }
    }
    if (newValue != null) {
        newValue.setEntity(provideDetailModelEntity(getSelectedItem()));
    }
}
#end_block

#method_before
protected void executeSave() {
    final QosParametersBase<T> parameters = getParameters();
    parameters.setQos(getQos());
    Frontend.getInstance().runAction(getVdcAction(), parameters, result -> {
        VdcReturnValueBase retVal = result.getReturnValue();
        boolean succeeded = false;
        if (retVal != null && retVal.getSucceeded()) {
            succeeded = true;
            getQos().setId((Guid) retVal.getActionReturnValue());
        }
        postSaveAction(succeeded);
    });
}
#method_after
protected void executeSave() {
    final QosParametersBase<T> parameters = getParameters();
    parameters.setQos(getQos());
    Frontend.getInstance().runAction(getAction(), parameters, result -> {
        VdcReturnValueBase retVal = result.getReturnValue();
        boolean succeeded = false;
        if (retVal != null && retVal.getSucceeded()) {
            succeeded = true;
            getQos().setId((Guid) retVal.getActionReturnValue());
        }
        postSaveAction(succeeded);
    });
}
#end_block

#method_before
public boolean isSingleSelectionOnly() {
    // have multi-selection models.
    return true;
}
#method_after
public boolean isSingleSelectionOnly() {
    // Most standard list models will have a single selection.
    return true;
}
#end_block

#method_before
public void activateDetailModel() {
    getMainModel().addActiveDetailModel(getModel());
}
#method_after
@Override
public void activateDetailModel() {
    getMainModel().addActiveDetailModel(getModel());
}
#end_block

#method_before
public boolean isSingleSelectionOnly() {
    // Most searchable listmodels allow multi selection.
    return false;
}
#method_after
public boolean isSingleSelectionOnly() {
    // Main list models (ones with details) will have multi-selection models.
    return false;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    if (!isDisksVolumeFormatValid()) {
        return false;
    }
    Version customCompatibilityVersionFromParams = getParameters().getVmStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // check if the OS type is supported
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!validate(VmValidator.validateCpuSockets(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && vmStaticDao.get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!getParameters().getVmStaticData().isAutoStartup()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED_WITH_HA_OFF);
        }
        if (!FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED);
        }
        if (!validateLeaseStorageDomain(getParameters().getVmStaticData().getLeaseStorageDomainId())) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    if (!isDisksVolumeFormatValid()) {
        return false;
    }
    Version customCompatibilityVersionFromParams = getParameters().getVmStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // check if the OS type is supported
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!validate(VmValidator.validateCpuSockets(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && vmStaticDao.get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData()) && !canAddLease()) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean checkTemplateImages(List<String> reasons) {
    if (getParameters().getParentCommand() == VdcActionType.AddVmPool) {
        return true;
    }
    for (StorageDomain storage : destStorages.values()) {
        if (!validate(vmTemplateHandler.isVmTemplateImagesReady(vmDisksSource, storage.getId(), false, false, true, true, storageToDisksMap.get(storage.getId())))) {
            return false;
        }
    }
    return true;
}
#method_after
protected boolean checkTemplateImages(List<String> reasons) {
    if (getParameters().getParentCommand() == ActionType.AddVmPool) {
        return true;
    }
    for (StorageDomain storage : destStorages.values()) {
        if (!validate(vmTemplateHandler.isVmTemplateImagesReady(vmDisksSource, storage.getId(), false, false, true, true, storageToDisksMap.get(storage.getId())))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    List<String> errorMessages = new ArrayList<>();
    if (!canAddVm(errorMessages, destStorages.values())) {
        log.error("Failed to add VM. The reasons are: {}", String.join(",", errorMessages));
        return;
    }
    if (!addVmLease(getParameters().getVm().getLeaseStorageDomainId(), getVmId())) {
        return;
    }
    TransactionSupport.executeInNewTransaction(() -> {
        addVmStatic();
        addVmDynamic();
        addVmNetwork();
        addVmNumaNodes();
        addVmStatistics();
        addActiveSnapshot();
        addVmPermission();
        addVmInit();
        addVmRngDevice();
        getCompensationContext().stateChanged();
        return null;
    });
    if (addVmImages()) {
        TransactionSupport.executeInNewTransaction(() -> {
            copyDiskVmElements();
            copyVmDevices();
            addDiskPermissions();
            addVmPayload();
            updateSmartCardDevices();
            addVmWatchdog();
            addGraphicsDevice();
            getVmDeviceUtils().updateVirtioScsiController(getVm().getStaticData(), getParameters().isVirtioScsiEnabled());
            setActionReturnValue(getVm().getId());
            setSucceeded(true);
            return null;
        });
    }
    if (getParameters().getPoolId() != null) {
        addVmToPool();
    }
    discardHelper.logIfDisksWithIllegalPassDiscardExist(getVmId());
}
#method_after
@Override
protected void executeVmCommand() {
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    List<String> errorMessages = new ArrayList<>();
    if (!canAddVm(errorMessages, destStorages.values())) {
        log.error("Failed to add VM. The reasons are: {}", String.join(",", errorMessages));
        return;
    }
    if (!addVmLease(getParameters().getVm().getLeaseStorageDomainId(), getVmId())) {
        return;
    }
    TransactionSupport.executeInNewTransaction(() -> {
        addVmStatic();
        addVmDynamic();
        addVmNetwork();
        addVmNumaNodes();
        addVmStatistics();
        addActiveSnapshot();
        addVmPermission();
        addVmInit();
        addVmRngDevice();
        addAffinityLabels();
        getCompensationContext().stateChanged();
        return null;
    });
    if (addVmImages()) {
        TransactionSupport.executeInNewTransaction(() -> {
            copyDiskVmElements();
            copyVmDevices();
            addDiskPermissions();
            addVmPayload();
            updateSmartCardDevices();
            addVmWatchdog();
            addGraphicsDevice();
            getVmDeviceUtils().updateVirtioScsiController(getVm().getStaticData(), getParameters().isVirtioScsiEnabled());
            setActionReturnValue(getVm().getId());
            setSucceeded(true);
            return null;
        });
    }
    if (getParameters().getPoolId() != null) {
        addVmToPool();
    }
    discardHelper.logIfDisksWithIllegalPassDiscardExist(getVmId());
}
#end_block

#method_before
private void addGraphicsDevice() {
    for (GraphicsDevice graphicsDevice : getParameters().getGraphicsDevices().values()) {
        if (graphicsDevice == null) {
            continue;
        }
        graphicsDevice.setVmId(getVmId());
        getBackend().runInternalAction(VdcActionType.AddGraphicsDevice, new GraphicsParameters(graphicsDevice));
    }
}
#method_after
private void addGraphicsDevice() {
    for (GraphicsDevice graphicsDevice : getParameters().getGraphicsDevices().values()) {
        if (graphicsDevice == null) {
            continue;
        }
        graphicsDevice.setVmId(getVmId());
        getBackend().runInternalAction(ActionType.AddGraphicsDevice, new GraphicsParameters(graphicsDevice));
    }
}
#end_block

#method_before
private void addVmWatchdog() {
    VmWatchdog vmWatchdog = getParameters().getWatchdog();
    if (vmWatchdog != null) {
        VdcActionType actionType = getVmDeviceUtils().hasWatchdog(getVmTemplateId()) ? VdcActionType.UpdateWatchdog : VdcActionType.AddWatchdog;
        runInternalAction(actionType, buildWatchdogParameters(vmWatchdog), cloneContextAndDetachFromParent());
    }
}
#method_after
private void addVmWatchdog() {
    VmWatchdog vmWatchdog = getParameters().getWatchdog();
    if (vmWatchdog != null) {
        ActionType actionType = getVmDeviceUtils().hasWatchdog(getVmTemplateId()) ? ActionType.UpdateWatchdog : ActionType.AddWatchdog;
        runInternalAction(actionType, buildWatchdogParameters(vmWatchdog), cloneContextAndDetachFromParent());
    }
}
#end_block

#method_before
private void addVmRngDevice() {
    VmRngDevice rngDev = getParameters().getRngDevice();
    if (rngDev != null) {
        rngDev.setVmId(getVmId());
        RngDeviceParameters params = new RngDeviceParameters(rngDev, true);
        VdcReturnValueBase result = runInternalAction(VdcActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            log.error("Couldn't add RNG device for new VM.");
            throw new IllegalArgumentException("Couldn't add RNG device for new VM.");
        }
    }
}
#method_after
private void addVmRngDevice() {
    VmRngDevice rngDev = getParameters().getRngDevice();
    if (rngDev != null) {
        rngDev.setVmId(getVmId());
        RngDeviceParameters params = new RngDeviceParameters(rngDev, true);
        VdcReturnValueBase result = runInternalAction(ActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            log.error("Couldn't add RNG device for new VM.");
            throw new IllegalArgumentException("Couldn't add RNG device for new VM.");
        }
    }
}
#end_block

#method_before
private void addVmNumaNodes() {
    List<VmNumaNode> numaNodes = getParameters().getVm().getvNumaNodeList();
    if (numaNodes.isEmpty()) {
        return;
    }
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getParameters().getVm(), numaNodes);
    VdcReturnValueBase returnValueBase = getBackend().runInternalAction(VdcActionType.AddVmNumaNodes, params);
    if (!returnValueBase.getSucceeded()) {
        auditLogDirector.log(this, AuditLogType.NUMA_ADD_VM_NUMA_NODE_FAILED);
    }
}
#method_after
private void addVmNumaNodes() {
    List<VmNumaNode> numaNodes = getParameters().getVm().getvNumaNodeList();
    if (numaNodes.isEmpty()) {
        return;
    }
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getParameters().getVm(), numaNodes);
    VdcReturnValueBase returnValueBase = getBackend().runInternalAction(ActionType.AddVmNumaNodes, params);
    if (!returnValueBase.getSucceeded()) {
        auditLogDirector.log(this, AuditLogType.NUMA_ADD_VM_NUMA_NODE_FAILED);
    }
}
#end_block

#method_before
protected VdcActionType getDiskCreationCommandType() {
    return VdcActionType.CreateSnapshotFromTemplate;
}
#method_after
protected ActionType getDiskCreationCommandType() {
    return ActionType.CreateSnapshotFromTemplate;
}
#end_block

#method_before
protected CreateSnapshotFromTemplateParameters buildDiskCreationParameters(DiskImage image) {
    CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(image.getImageId(), getParameters().getVmStaticData().getId());
    tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(image.getId()).getStorageIds().get(0));
    tempVar.setDiskAlias(diskInfoDestinationMap.get(image.getId()).getDiskAlias());
    tempVar.setStorageDomainId(image.getStorageIds().get(0));
    tempVar.setVmSnapshotId(getVmSnapshotId());
    tempVar.setParentCommand(VdcActionType.AddVm);
    tempVar.setEntityInfo(getParameters().getEntityInfo());
    tempVar.setParentParameters(getParameters());
    tempVar.setQuotaId(diskInfoDestinationMap.get(image.getId()).getQuotaId());
    tempVar.setDiskProfileId(diskInfoDestinationMap.get(image.getId()).getDiskProfileId());
    return tempVar;
}
#method_after
protected CreateSnapshotFromTemplateParameters buildDiskCreationParameters(DiskImage image) {
    CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(image.getImageId(), getParameters().getVmStaticData().getId());
    tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(image.getId()).getStorageIds().get(0));
    tempVar.setDiskAlias(diskInfoDestinationMap.get(image.getId()).getDiskAlias());
    tempVar.setStorageDomainId(image.getStorageIds().get(0));
    tempVar.setVmSnapshotId(getVmSnapshotId());
    tempVar.setParentCommand(ActionType.AddVm);
    tempVar.setEntityInfo(getParameters().getEntityInfo());
    tempVar.setParentParameters(getParameters());
    tempVar.setQuotaId(diskInfoDestinationMap.get(image.getId()).getQuotaId());
    tempVar.setDiskProfileId(diskInfoDestinationMap.get(image.getId()).getDiskProfileId());
    return tempVar;
}
#end_block

#method_before
protected void addVmCinderDisks(Collection<DiskImage> templateDisks) {
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(templateDisks);
    if (cinderDisks.isEmpty()) {
        return;
    }
    Map<Guid, Guid> diskImageMap = new HashMap<>();
    for (CinderDisk cinderDisk : cinderDisks) {
        ImagesContainterParametersBase params = buildCloneCinderDiskCommandParameters(cinderDisk);
        VdcReturnValueBase vdcReturnValueBase = runInternalAction(VdcActionType.CloneSingleCinderDisk, params, cloneContext().withoutExecutionContext().withoutLock());
        if (!vdcReturnValueBase.getSucceeded()) {
            log.error("Error cloning Cinder disk '{}': {}", cinderDisk.getDiskAlias());
            getReturnValue().setFault(vdcReturnValueBase.getFault());
            return;
        }
        Guid imageId = vdcReturnValueBase.getActionReturnValue();
        diskImageMap.put(cinderDisk.getId(), imageId);
    }
    srcDiskIdToTargetDiskIdMapping.putAll(diskImageMap);
}
#method_after
protected void addVmCinderDisks(Collection<DiskImage> templateDisks) {
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(templateDisks);
    if (cinderDisks.isEmpty()) {
        return;
    }
    Map<Guid, Guid> diskImageMap = new HashMap<>();
    for (CinderDisk cinderDisk : cinderDisks) {
        ImagesContainterParametersBase params = buildCloneCinderDiskCommandParameters(cinderDisk);
        VdcReturnValueBase vdcReturnValueBase = runInternalAction(ActionType.CloneSingleCinderDisk, params, cloneContext().withoutExecutionContext().withoutLock());
        if (!vdcReturnValueBase.getSucceeded()) {
            log.error("Error cloning Cinder disk '{}': {}", cinderDisk.getDiskAlias());
            getReturnValue().setFault(vdcReturnValueBase.getFault());
            return;
        }
        Guid imageId = vdcReturnValueBase.getActionReturnValue();
        diskImageMap.put(cinderDisk.getId(), imageId);
    }
    srcDiskIdToTargetDiskIdMapping.putAll(diskImageMap);
}
#end_block

#method_before
private void addVmToPool() {
    AddVmToPoolParameters parameters = new AddVmToPoolParameters(getParameters().getPoolId(), getVmId());
    parameters.setShouldBeLogged(false);
    VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.AddVmToPool, parameters);
    setSucceeded(result.getSucceeded());
    if (!result.getSucceeded()) {
        log.error("Error adding VM {} to Pool {}", getVmId(), getParameters().getPoolId());
        getReturnValue().setFault(result.getFault());
        return;
    }
    addVmPermission();
}
#method_after
private void addVmToPool() {
    AddVmToPoolParameters parameters = new AddVmToPoolParameters(getParameters().getPoolId(), getVmId());
    parameters.setShouldBeLogged(false);
    VdcReturnValueBase result = runInternalActionWithTasksContext(ActionType.AddVmToPool, parameters);
    setSucceeded(result.getSucceeded());
    if (!result.getSucceeded()) {
        log.error("Error adding VM {} to Pool {}", getVmId(), getParameters().getPoolId());
        getReturnValue().setFault(result.getFault());
        return;
    }
    addVmPermission();
}
#end_block

#method_before
@Override
protected VdcActionType getChildActionType() {
    return VdcActionType.CreateSnapshotFromTemplate;
}
#method_after
@Override
protected ActionType getChildActionType() {
    return ActionType.CreateSnapshotFromTemplate;
}
#end_block

#method_before
public static ValidationResult canRunActionOnNonManagedVm(VM vm, VdcActionType actionType) {
    ValidationResult validationResult = ValidationResult.VALID;
    if (!VmActionByVmOriginTypeValidator.isCommandAllowed(vm, actionType)) {
        validationResult = new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RUN_ACTION_ON_NON_MANAGED_VM);
    }
    return validationResult;
}
#method_after
public static ValidationResult canRunActionOnNonManagedVm(VM vm, ActionType actionType) {
    ValidationResult validationResult = ValidationResult.VALID;
    if (!VmActionByVmOriginTypeValidator.isCommandAllowed(vm, actionType)) {
        validationResult = new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RUN_ACTION_ON_NON_MANAGED_VM);
    }
    return validationResult;
}
#end_block

#method_before
@Override
protected void moveOrCopyAllImageGroups(final Guid containerID, final Iterable<DiskImage> disks) {
    TransactionSupport.executeInNewTransaction(() -> {
        for (DiskImage disk : disks) {
            Guid originalDiskId = newDiskIdForDisk.get(disk.getId()).getId();
            Guid destinationDomain = imageToDestinationDomainMap.get(originalDiskId);
            MoveOrCopyImageGroupParameters p = new MoveOrCopyImageGroupParameters(containerID, originalDiskId, newDiskIdForDisk.get(disk.getId()).getImageId(), disk.getId(), disk.getImageId(), destinationDomain, ImageOperation.Copy);
            p.setParentCommand(getActionType());
            p.setUseCopyCollapse(true);
            p.setVolumeType(disk.getVolumeType());
            p.setVolumeFormat(disk.getVolumeFormat());
            p.setCopyVolumeType(CopyVolumeType.SharedVol);
            p.setSourceDomainId(getParameters().getSourceDomainId());
            p.setForceOverride(getParameters().getForceOverride());
            p.setImportEntity(true);
            p.setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, containerID));
            p.setRevertDbOperationScope(ImageDbOperationScope.IMAGE);
            for (DiskImage diskImage : getParameters().getVmTemplate().getDiskList()) {
                if (originalDiskId.equals(diskImage.getId())) {
                    p.setQuotaId(diskImage.getQuotaId());
                    p.setDiskProfileId(diskImage.getDiskProfileId());
                    break;
                }
            }
            p.setParentParameters(getParameters());
            VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(VdcActionType.CopyImageGroup, p);
            if (!vdcRetValue.getSucceeded()) {
                throw vdcRetValue.getFault() != null ? new EngineException(vdcRetValue.getFault().getError()) : new EngineException(EngineError.ENGINE);
            }
            getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        }
        return null;
    });
}
#method_after
@Override
protected void moveOrCopyAllImageGroups(final Guid containerID, final Iterable<DiskImage> disks) {
    TransactionSupport.executeInNewTransaction(() -> {
        for (DiskImage disk : disks) {
            Guid originalDiskId = newDiskIdForDisk.get(disk.getId()).getId();
            Guid destinationDomain = imageToDestinationDomainMap.get(originalDiskId);
            MoveOrCopyImageGroupParameters p = new MoveOrCopyImageGroupParameters(containerID, originalDiskId, newDiskIdForDisk.get(disk.getId()).getImageId(), disk.getId(), disk.getImageId(), destinationDomain, ImageOperation.Copy);
            p.setParentCommand(getActionType());
            p.setUseCopyCollapse(true);
            p.setVolumeType(disk.getVolumeType());
            p.setVolumeFormat(disk.getVolumeFormat());
            p.setCopyVolumeType(CopyVolumeType.SharedVol);
            p.setSourceDomainId(getParameters().getSourceDomainId());
            p.setForceOverride(getParameters().getForceOverride());
            p.setImportEntity(true);
            p.setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, containerID));
            p.setRevertDbOperationScope(ImageDbOperationScope.IMAGE);
            for (DiskImage diskImage : getParameters().getVmTemplate().getDiskList()) {
                if (originalDiskId.equals(diskImage.getId())) {
                    p.setQuotaId(diskImage.getQuotaId());
                    p.setDiskProfileId(diskImage.getDiskProfileId());
                    break;
                }
            }
            p.setParentParameters(getParameters());
            VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, p);
            if (!vdcRetValue.getSucceeded()) {
                throw vdcRetValue.getFault() != null ? new EngineException(vdcRetValue.getFault().getError()) : new EngineException(EngineError.ENGINE);
            }
            getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        }
        return null;
    });
}
#end_block

#method_before
@Override
protected void endActionOnAllImageGroups() {
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        getBackend().endAction(VdcActionType.CopyImageGroup, p, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
    }
}
#method_after
@Override
protected void endActionOnAllImageGroups() {
    for (ActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        getBackend().endAction(ActionType.CopyImageGroup, p, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
    }
}
#end_block

#method_before
protected VdcActionType getAddAllTemplateDisksActionType() {
    return VdcActionType.CreateAllTemplateDisks;
}
#method_after
protected ActionType getAddAllTemplateDisksActionType() {
    return ActionType.CreateAllTemplateDisks;
}
#end_block

#method_before
private void addGraphicsDevice() {
    for (GraphicsDevice graphicsDevice : getParameters().getGraphicsDevices().values()) {
        if (graphicsDevice == null) {
            continue;
        }
        graphicsDevice.setVmId(getVmTemplateId());
        GraphicsParameters parameters = new GraphicsParameters(graphicsDevice).setVm(false);
        getBackend().runInternalAction(VdcActionType.AddGraphicsDevice, parameters);
    }
}
#method_after
private void addGraphicsDevice() {
    for (GraphicsDevice graphicsDevice : getParameters().getGraphicsDevices().values()) {
        if (graphicsDevice == null) {
            continue;
        }
        graphicsDevice.setVmId(getVmTemplateId());
        GraphicsParameters parameters = new GraphicsParameters(graphicsDevice).setVm(false);
        getBackend().runInternalAction(ActionType.AddGraphicsDevice, parameters);
    }
}
#end_block

#method_before
private void assignLegalAndShared(boolean legalAndShared) {
    VdcReturnValueBase returnValue = runInternalAction(VdcActionType.UpdateAllTemplateDisks, buildUpdateAllTemplateDisksParameters(legalAndShared), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
    }
}
#method_after
private void assignLegalAndShared(boolean legalAndShared) {
    VdcReturnValueBase returnValue = runInternalAction(ActionType.UpdateAllTemplateDisks, buildUpdateAllTemplateDisksParameters(legalAndShared), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
    }
}
#end_block

#method_before
private void sealVmTemplate() {
    VdcReturnValueBase returnValue = runInternalAction(VdcActionType.SealVmTemplate, buildSealVmTemplateParameters(), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
    }
}
#method_after
private void sealVmTemplate() {
    VdcReturnValueBase returnValue = runInternalAction(ActionType.SealVmTemplate, buildSealVmTemplateParameters(), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("updateVmVersion")
public void updateVmVersion() {
    for (Guid vmId : vmDao.getVmIdsForVersionUpdate(getParameters().getBaseTemplateId())) {
        // if the job was removed, stop executing, we probably have new version creation going on
        if (!updateVmsJobIdMap.containsKey(getParameters().getBaseTemplateId())) {
            break;
        }
        UpdateVmVersionParameters params = new UpdateVmVersionParameters(vmId);
        params.setSessionId(getParameters().getSessionId());
        getBackend().runInternalAction(VdcActionType.UpdateVmVersion, params, cloneContextAndDetachFromParent());
    }
    updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
}
#method_after
@OnTimerMethodAnnotation("updateVmVersion")
public void updateVmVersion() {
    for (Guid vmId : vmDao.getVmIdsForVersionUpdate(getParameters().getBaseTemplateId())) {
        // if the job was removed, stop executing, we probably have new version creation going on
        if (!updateVmsJobIdMap.containsKey(getParameters().getBaseTemplateId())) {
            break;
        }
        UpdateVmVersionParameters params = new UpdateVmVersionParameters(vmId);
        params.setSessionId(getParameters().getSessionId());
        getBackend().runInternalAction(ActionType.UpdateVmVersion, params, cloneContextAndDetachFromParent());
    }
    updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    bindPresenterWidget(AffinityLabelPopupPresenterWidget.class, AffinityLabelPopupPresenterWidget.ViewDef.class, AffinityLabelPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabEngineErrataPresenter.class, MainTabEngineErrataPresenter.ViewDef.class, MainTabEngineErrataView.class, MainTabEngineErrataPresenter.ProxyDef.class);
    bindPresenter(MainTabSessionPresenter.class, MainTabSessionPresenter.ViewDef.class, MainTabSessionView.class, MainTabSessionPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(DataCenterQosSubTabPanelPresenter.class, DataCenterQosSubTabPanelPresenter.ViewDef.class, DataCenterQosSubTabPanelView.class, DataCenterQosSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStorageQosPresenter.class, SubTabDataCenterStorageQosPresenter.ViewDef.class, SubTabDataCenterStorageQosView.class, SubTabDataCenterStorageQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterCpuQosPresenter.class, SubTabDataCenterCpuQosPresenter.ViewDef.class, SubTabDataCenterCpuQosView.class, SubTabDataCenterCpuQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterHostNetworkQosPresenter.class, SubTabDataCenterHostNetworkQosPresenter.ViewDef.class, SubTabDataCenterHostNetworkQosView.class, SubTabDataCenterHostNetworkQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskPresenter.class, SubTabStorageRegisterDiskPresenter.ViewDef.class, SubTabStorageRegisterDiskView.class, SubTabStorageRegisterDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskImagePresenter.class, SubTabStorageRegisterDiskImagePresenter.ViewDef.class, SubTabStorageRegisterDiskImageView.class, SubTabStorageRegisterDiskImagePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDRPresenter.class, SubTabStorageDRPresenter.ViewDef.class, SubTabStorageDRView.class, SubTabStorageDRPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    bindPresenterWidget(GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterClusterSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterVolumeSnapshotCreatePopupPresenterWidget.class, GlusterVolumeSnapshotCreatePopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotCreatePopupView.class);
    bindPresenter(SubTabClusterAffinityLabelPresenter.class, SubTabClusterAffinityLabelPresenter.ViewDef.class, SubTabClusterAffinityLabelView.class, SubTabClusterAffinityLabelPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(HostGeneralSubTabPanelPresenter.class, HostGeneralSubTabPanelPresenter.ViewDef.class, HostGeneralSubTabPanelView.class, HostGeneralSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralSoftwarePresenter.class, SubTabHostGeneralSoftwarePresenter.ViewDef.class, SubTabHostGeneralSoftwareView.class, SubTabHostGeneralSoftwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralInfoPresenter.class, SubTabHostGeneralInfoPresenter.ViewDef.class, SubTabHostGeneralInfoView.class, SubTabHostGeneralInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralHardwarePresenter.class, SubTabHostGeneralHardwarePresenter.ViewDef.class, SubTabHostGeneralHardwareView.class, SubTabHostGeneralHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralHostErrataPresenter.class, SubTabHostGeneralHostErrataPresenter.ViewDef.class, SubTabHostGeneralHostErrataView.class, SubTabHostGeneralHostErrataPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostDevicePresenter.class, SubTabHostDevicePresenter.ViewDef.class, SubTabHostDeviceView.class, SubTabHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterStorageDevicesPresenter.class, SubTabHostGlusterStorageDevicesPresenter.ViewDef.class, SubTabHostGlusterStorageDevicesView.class, SubTabHostGlusterStorageDevicesPresenter.ProxyDef.class);
    bindPresenter(SubTabHostAffinityLabelPresenter.class, SubTabHostAffinityLabelPresenter.ViewDef.class, SubTabHostAffinityLabelView.class, SubTabHostAffinityLabelPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestContainerPresenter.class, SubTabVirtualMachineGuestContainerPresenter.ViewDef.class, SubTabVirtualMachineGuestContainerView.class, SubTabVirtualMachineGuestContainerPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVmDevicePresenter.class, SubTabVirtualMachineVmDevicePresenter.ViewDef.class, SubTabVirtualMachineVmDevicesView.class, SubTabVirtualMachineVmDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestInfoPresenter.class, SubTabVirtualMachineGuestInfoPresenter.ViewDef.class, SubTabVirtualMachineGuestInfoView.class, SubTabVirtualMachineGuestInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineHostDevicePresenter.class, SubTabVirtualMachineHostDevicePresenter.ViewDef.class, SubTabVirtualMachineHostDeviceView.class, SubTabVirtualMachineHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineErrataPresenter.class, SubTabVirtualMachineErrataPresenter.ViewDef.class, SubTabVirtualMachineErrataView.class, SubTabVirtualMachineErrataPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityLabelPresenter.class, SubTabVirtualMachineAffinityLabelPresenter.ViewDef.class, SubTabVirtualMachineAffinityLabelView.class, SubTabVirtualMachineAffinityLabelPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderSecretPresenter.class, SubTabProviderSecretPresenter.ViewDef.class, SubTabProviderSecretView.class, SubTabProviderSecretPresenter.ProxyDef.class);
    // Errata
    bindPresenter(ErrataSubTabPanelPresenter.class, ErrataSubTabPanelPresenter.ViewDef.class, ErrataSubTabPanelView.class, ErrataSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabEngineErrataDetailsPresenter.class, SubTabEngineErrataDetailsPresenter.ViewDef.class, SubTabEngineErrataDetailsView.class, SubTabEngineErrataDetailsPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(ClusterWarningsPopupPresenterWidget.class, ClusterWarningsPopupPresenterWidget.ViewDef.class, ClusterWarningsPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.class, GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoReplicationSessionConfigPopupView.class);
    bindPresenterWidget(VolumeGeoRepSessionDetailsPopUpPresenterWidget.class, VolumeGeoRepSessionDetailsPopUpPresenterWidget.ViewDef.class, VolumeGeoRepSessionDetailsPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.class, GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoRepCreateSessionPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    bindPresenterWidget(AddDataCenterClusterPopupPresenterWidget.class, AddDataCenterClusterPopupPresenterWidget.ViewDef.class, AddDataCenterClusterPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(NetworkAttachmentPopupPresenterWidget.class, NetworkAttachmentPopupPresenterWidget.ViewDef.class, NetworkAttachmentPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(VfsConfigPopupPresenterWidget.class, VfsConfigPopupPresenterWidget.ViewDef.class, VfsConfigPopupView.class);
    bindPresenterWidget(SetupNetworksLabelPopupPresenterWidget.class, SetupNetworksLabelPopupPresenterWidget.ViewDef.class, SetupNetworksLabelPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    bindPresenterWidget(HostFenceAgentPopupPresenterWidget.class, HostFenceAgentPopupPresenterWidget.ViewDef.class, HostFenceAgentPopupView.class);
    bindPresenterWidget(HostFenceProxyPopupPresenterWidget.class, HostFenceProxyPopupPresenterWidget.ViewDef.class, HostFenceProxyPopupView.class);
    bindPresenterWidget(HostMaintenanceConfirmationPopupPresenterWidget.class, HostMaintenanceConfirmationPopupPresenterWidget.ViewDef.class, HostMaintenanceConfirmationPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportVmFromExternalProviderPopupPresenterWidget.class, ImportVmFromExternalProviderPopupPresenterWidget.ViewDef.class, ImportVmFromExternalProviderPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(VnicProfileMappingPopupPresenterWidget.class, VnicProfileMappingPopupPresenterWidget.ViewDef.class, VnicProfileMappingPopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    bindPresenterWidget(UploadImagePopupPresenterWidget.class, UploadImagePopupPresenterWidget.ViewDef.class, UploadImagePopupView.class);
    bindPresenterWidget(StorageDRPopupPresenterWidget.class, StorageDRPopupPresenterWidget.ViewDef.class, StorageDRPopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // VM Sparsify Disk
    bindPresenterWidget(VmDiskSparsifyPopupPresenterWidget.class, VmDiskSparsifyPopupPresenterWidget.ViewDef.class, VmDiskSparsifyPopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    bindPresenterWidget(StorageQosRemovePopupPresenterWidget.class, StorageQosRemovePopupPresenterWidget.ViewDef.class, StorageQosRemovePopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Host Devices
    bindPresenterWidget(AddVmHostDevicePopupPresenterWidget.class, AddVmHostDevicePopupPresenterWidget.ViewDef.class, AddVmHostDevicePopupView.class);
    bindPresenterWidget(VmRepinHostPopupPresenterWidget.class, VmRepinHostPopupPresenterWidget.ViewDef.class, VmRepinHostPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenter(SubTabGlusterVolumeSnapshotPresenter.class, SubTabGlusterVolumeSnapshotPresenter.ViewDef.class, SubTabGlusterVolumeSnapshotView.class, SubTabGlusterVolumeSnapshotPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(CreateBrickPopupPresenterWidget.class, CreateBrickPopupPresenterWidget.ViewDef.class, CreateBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    bindPresenterWidget(ProviderSecretPopupPresenterWidget.class, ProviderSecretPopupPresenterWidget.ViewDef.class, ProviderSecretPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
    // Errata details
    bindPresenterWidget(HostErrataListWithDetailsPopupPresenterWidget.class, HostErrataListWithDetailsPopupPresenterWidget.ViewDef.class, HostErrataListWithDetailsPopupView.class);
    bindPresenterWidget(VmErrataListWithDetailsPopupPresenterWidget.class, VmErrataListWithDetailsPopupPresenterWidget.ViewDef.class, VmErrataListWithDetailsPopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    bindPresenterWidget(AffinityLabelPopupPresenterWidget.class, AffinityLabelPopupPresenterWidget.ViewDef.class, AffinityLabelPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabEngineErrataPresenter.class, MainTabEngineErrataPresenter.ViewDef.class, MainTabEngineErrataView.class, MainTabEngineErrataPresenter.ProxyDef.class);
    bindPresenter(MainTabSessionPresenter.class, MainTabSessionPresenter.ViewDef.class, MainTabSessionView.class, MainTabSessionPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQosPresenter.class, SubTabDataCenterQosPresenter.ViewDef.class, SubTabDataCenterQosView.class, SubTabDataCenterQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    bind(new TypeLiteral<SearchPanelPresenterWidget<StoragePool, DataCenterListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchPanelPresenterWidget.ViewDef<DataCenterListModel>>() {
    }).to(new TypeLiteral<SearchPanelView<DataCenterListModel>>() {
    }).in(Singleton.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskPresenter.class, SubTabStorageRegisterDiskPresenter.ViewDef.class, SubTabStorageRegisterDiskView.class, SubTabStorageRegisterDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskImagePresenter.class, SubTabStorageRegisterDiskImagePresenter.ViewDef.class, SubTabStorageRegisterDiskImageView.class, SubTabStorageRegisterDiskImagePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDRPresenter.class, SubTabStorageDRPresenter.ViewDef.class, SubTabStorageDRView.class, SubTabStorageDRPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageLeasePresenter.class, SubTabStorageLeasePresenter.ViewDef.class, SubTabStorageLeaseView.class, SubTabStorageLeasePresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    bind(new TypeLiteral<SearchPanelPresenterWidget<StorageDomain, StorageListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchPanelPresenterWidget.ViewDef<StorageListModel>>() {
    }).to(new TypeLiteral<SearchPanelView<StorageListModel>>() {
    }).in(Singleton.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    bindPresenterWidget(GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterClusterSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterVolumeSnapshotCreatePopupPresenterWidget.class, GlusterVolumeSnapshotCreatePopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotCreatePopupView.class);
    bindPresenter(SubTabClusterAffinityLabelPresenter.class, SubTabClusterAffinityLabelPresenter.ViewDef.class, SubTabClusterAffinityLabelView.class, SubTabClusterAffinityLabelPresenter.ProxyDef.class);
    // TODO: make helper function that allows for TypeLiterals.
    bind(new TypeLiteral<SearchPanelPresenterWidget<Cluster, ClusterListModel<Void>>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchPanelPresenterWidget.ViewDef<ClusterListModel<Void>>>() {
    }).to(new TypeLiteral<SearchPanelView<ClusterListModel<Void>>>() {
    }).in(Singleton.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(HostGeneralSubTabPresenter.class, HostGeneralSubTabPresenter.ViewDef.class, HostGeneralSubTabView.class, HostGeneralSubTabPresenter.ProxyDef.class);
    bindPresenter(SubTabHostErrataPresenter.class, SubTabHostErrataPresenter.ViewDef.class, SubTabHostErrataView.class, SubTabHostErrataPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostDevicePresenter.class, SubTabHostDevicePresenter.ViewDef.class, SubTabHostDeviceView.class, SubTabHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterStorageDevicesPresenter.class, SubTabHostGlusterStorageDevicesPresenter.ViewDef.class, SubTabHostGlusterStorageDevicesView.class, SubTabHostGlusterStorageDevicesPresenter.ProxyDef.class);
    bind(new TypeLiteral<SearchPanelPresenterWidget<VDS, HostListModel<Void>>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchPanelPresenterWidget.ViewDef<HostListModel<Void>>>() {
    }).to(new TypeLiteral<SearchPanelView<HostListModel<Void>>>() {
    }).in(Singleton.class);
    bindPresenter(SubTabHostAffinityLabelPresenter.class, SubTabHostAffinityLabelPresenter.ViewDef.class, SubTabHostAffinityLabelView.class, SubTabHostAffinityLabelPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestContainerPresenter.class, SubTabVirtualMachineGuestContainerPresenter.ViewDef.class, SubTabVirtualMachineGuestContainerView.class, SubTabVirtualMachineGuestContainerPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVmDevicePresenter.class, SubTabVirtualMachineVmDevicePresenter.ViewDef.class, SubTabVirtualMachineVmDevicesView.class, SubTabVirtualMachineVmDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestInfoPresenter.class, SubTabVirtualMachineGuestInfoPresenter.ViewDef.class, SubTabVirtualMachineGuestInfoView.class, SubTabVirtualMachineGuestInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineHostDevicePresenter.class, SubTabVirtualMachineHostDevicePresenter.ViewDef.class, SubTabVirtualMachineHostDeviceView.class, SubTabVirtualMachineHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineErrataPresenter.class, SubTabVirtualMachineErrataPresenter.ViewDef.class, SubTabVirtualMachineErrataView.class, SubTabVirtualMachineErrataPresenter.ProxyDef.class);
    bind(new TypeLiteral<SearchPanelPresenterWidget<VM, VmListModel<Void>>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchPanelPresenterWidget.ViewDef<VmListModel<Void>>>() {
    }).to(new TypeLiteral<SearchPanelView<VmListModel<Void>>>() {
    }).in(Singleton.class);
    bindPresenter(SubTabVirtualMachineAffinityLabelPresenter.class, SubTabVirtualMachineAffinityLabelPresenter.ViewDef.class, SubTabVirtualMachineAffinityLabelView.class, SubTabVirtualMachineAffinityLabelPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    bind(new TypeLiteral<SearchPanelPresenterWidget<VmPool, PoolListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchPanelPresenterWidget.ViewDef<PoolListModel>>() {
    }).to(new TypeLiteral<SearchPanelView<PoolListModel>>() {
    }).in(Singleton.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    bind(new TypeLiteral<SearchPanelPresenterWidget<VmTemplate, TemplateListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchPanelPresenterWidget.ViewDef<TemplateListModel>>() {
    }).to(new TypeLiteral<SearchPanelView<TemplateListModel>>() {
    }).in(Singleton.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    bind(new TypeLiteral<SearchPanelPresenterWidget<DbUser, UserListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchPanelPresenterWidget.ViewDef<UserListModel>>() {
    }).to(new TypeLiteral<SearchPanelView<UserListModel>>() {
    }).in(Singleton.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    bind(new TypeLiteral<SearchPanelPresenterWidget<Quota, QuotaListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchPanelPresenterWidget.ViewDef<QuotaListModel>>() {
    }).to(new TypeLiteral<SearchPanelView<QuotaListModel>>() {
    }).in(Singleton.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    bind(new TypeLiteral<SearchPanelPresenterWidget<Disk, DiskListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchPanelPresenterWidget.ViewDef<DiskListModel>>() {
    }).to(new TypeLiteral<SearchPanelView<DiskListModel>>() {
    }).in(Singleton.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    bind(new TypeLiteral<SearchPanelPresenterWidget<NetworkView, NetworkListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchPanelPresenterWidget.ViewDef<NetworkListModel>>() {
    }).to(new TypeLiteral<SearchPanelView<NetworkListModel>>() {
    }).in(Singleton.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderSecretPresenter.class, SubTabProviderSecretPresenter.ViewDef.class, SubTabProviderSecretView.class, SubTabProviderSecretPresenter.ProxyDef.class);
    bind(new TypeLiteral<SearchPanelPresenterWidget<org.ovirt.engine.core.common.businessentities.Provider, ProviderListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchPanelPresenterWidget.ViewDef<ProviderListModel>>() {
    }).to(new TypeLiteral<SearchPanelView<ProviderListModel>>() {
    }).in(Singleton.class);
    // Errata
    bindPresenter(ErrataSubTabPanelPresenter.class, ErrataSubTabPanelPresenter.ViewDef.class, ErrataSubTabPanelView.class, ErrataSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabEngineErrataDetailsPresenter.class, SubTabEngineErrataDetailsPresenter.ViewDef.class, SubTabEngineErrataDetailsView.class, SubTabEngineErrataDetailsPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // User Sessions
    bind(new TypeLiteral<SearchPanelPresenterWidget<UserSession, SessionListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchPanelPresenterWidget.ViewDef<SessionListModel>>() {
    }).to(new TypeLiteral<SearchPanelView<SessionListModel>>() {
    }).in(Singleton.class);
    // Volume
    bind(new TypeLiteral<SearchPanelPresenterWidget<GlusterVolumeEntity, VolumeListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchPanelPresenterWidget.ViewDef<VolumeListModel>>() {
    }).to(new TypeLiteral<SearchPanelView<VolumeListModel>>() {
    }).in(Singleton.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(ClusterWarningsPopupPresenterWidget.class, ClusterWarningsPopupPresenterWidget.ViewDef.class, ClusterWarningsPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.class, GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoReplicationSessionConfigPopupView.class);
    bindPresenterWidget(VolumeGeoRepSessionDetailsPopUpPresenterWidget.class, VolumeGeoRepSessionDetailsPopUpPresenterWidget.ViewDef.class, VolumeGeoRepSessionDetailsPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.class, GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoRepCreateSessionPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    bindPresenterWidget(AddDataCenterClusterPopupPresenterWidget.class, AddDataCenterClusterPopupPresenterWidget.ViewDef.class, AddDataCenterClusterPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(NetworkAttachmentPopupPresenterWidget.class, NetworkAttachmentPopupPresenterWidget.ViewDef.class, NetworkAttachmentPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(VfsConfigPopupPresenterWidget.class, VfsConfigPopupPresenterWidget.ViewDef.class, VfsConfigPopupView.class);
    bindPresenterWidget(SetupNetworksLabelPopupPresenterWidget.class, SetupNetworksLabelPopupPresenterWidget.ViewDef.class, SetupNetworksLabelPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    bindPresenterWidget(HostFenceAgentPopupPresenterWidget.class, HostFenceAgentPopupPresenterWidget.ViewDef.class, HostFenceAgentPopupView.class);
    bindPresenterWidget(HostFenceProxyPopupPresenterWidget.class, HostFenceProxyPopupPresenterWidget.ViewDef.class, HostFenceProxyPopupView.class);
    bindPresenterWidget(HostMaintenanceConfirmationPopupPresenterWidget.class, HostMaintenanceConfirmationPopupPresenterWidget.ViewDef.class, HostMaintenanceConfirmationPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportVmFromExternalProviderPopupPresenterWidget.class, ImportVmFromExternalProviderPopupPresenterWidget.ViewDef.class, ImportVmFromExternalProviderPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(VnicProfileMappingPopupPresenterWidget.class, VnicProfileMappingPopupPresenterWidget.ViewDef.class, VnicProfileMappingPopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    bindPresenterWidget(UploadImagePopupPresenterWidget.class, UploadImagePopupPresenterWidget.ViewDef.class, UploadImagePopupView.class);
    bindPresenterWidget(StorageDRPopupPresenterWidget.class, StorageDRPopupPresenterWidget.ViewDef.class, StorageDRPopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // VM Sparsify Disk
    bindPresenterWidget(VmDiskSparsifyPopupPresenterWidget.class, VmDiskSparsifyPopupPresenterWidget.ViewDef.class, VmDiskSparsifyPopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    bindPresenterWidget(StorageQosRemovePopupPresenterWidget.class, StorageQosRemovePopupPresenterWidget.ViewDef.class, StorageQosRemovePopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Host Devices
    bindPresenterWidget(AddVmHostDevicePopupPresenterWidget.class, AddVmHostDevicePopupPresenterWidget.ViewDef.class, AddVmHostDevicePopupView.class);
    bindPresenterWidget(VmRepinHostPopupPresenterWidget.class, VmRepinHostPopupPresenterWidget.ViewDef.class, VmRepinHostPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenter(SubTabGlusterVolumeSnapshotPresenter.class, SubTabGlusterVolumeSnapshotPresenter.ViewDef.class, SubTabGlusterVolumeSnapshotView.class, SubTabGlusterVolumeSnapshotPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(CreateBrickPopupPresenterWidget.class, CreateBrickPopupPresenterWidget.ViewDef.class, CreateBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    bind(new TypeLiteral<SearchPanelPresenterWidget<AuditLog, EventListModel<Void>>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchPanelPresenterWidget.ViewDef<EventListModel<Void>>>() {
    }).to(new TypeLiteral<SearchPanelView<EventListModel<Void>>>() {
    }).in(Singleton.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    bindPresenterWidget(ProviderSecretPopupPresenterWidget.class, ProviderSecretPopupPresenterWidget.ViewDef.class, ProviderSecretPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
    // Errata details
    bindPresenterWidget(HostErrataListWithDetailsPopupPresenterWidget.class, HostErrataListWithDetailsPopupPresenterWidget.ViewDef.class, HostErrataListWithDetailsPopupView.class);
    bindPresenterWidget(VmErrataListWithDetailsPopupPresenterWidget.class, VmErrataListWithDetailsPopupPresenterWidget.ViewDef.class, VmErrataListWithDetailsPopupView.class);
    // Overlays
    // Tasks
    bindPresenter(TasksPresenter.class, TasksPresenter.ViewDef.class, TasksView.class, TasksPresenter.ProxyDef.class);
    // Bookmarks
    bindPresenter(BookmarkPresenter.class, BookmarkPresenter.ViewDef.class, BookmarkView.class, BookmarkPresenter.ProxyDef.class);
    // Tags
    bindPresenter(TagsPresenter.class, TagsPresenter.ViewDef.class, TagsView.class, TagsPresenter.ProxyDef.class);
}
#end_block

#method_before
public void onDetach() {
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    boolean latchChecked = !model.validate();
    if (model.getProgress() != null || latchChecked) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        list.add(new RemoveVmFromPoolParameters(vm.getId(), true, true));
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.RemoveVmFromPool, list, result -> {
        ConfirmationModel localModel = (ConfirmationModel) result.getState();
        localModel.stopProgress();
        cancel();
    }, model);
}
#method_after
public void onDetach() {
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    boolean latchChecked = !model.validate();
    if (model.getProgress() != null || latchChecked) {
        return;
    }
    ArrayList<ActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        list.add(new RemoveVmFromPoolParameters(vm.getId(), true, true));
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(ActionType.RemoveVmFromPool, list, result -> {
        ConfirmationModel localModel = (ConfirmationModel) result.getState();
        localModel.stopProgress();
        cancel();
    }, model);
}
#end_block

#method_before
// Main List Model
@Provides
@Singleton
public MainModelProvider<VDS, HostListModel<Void>> getHostListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<HostPopupPresenterWidget> popupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<HostMaintenanceConfirmationPopupPresenterWidget> hostMaintenanceConfirmationPopupProvider, final Provider<ManualFencePopupPresenterWidget> manualFenceConfirmPopupProvider, final Provider<AssignTagsPopupPresenterWidget> assignTagsPopupProvider, final Provider<ConfigureLocalStoragePopupPresenterWidget> configureLocalStoragePopupProvider, final Provider<HostInstallPopupPresenterWidget> installPopupProvider, final Provider<NumaSupportPopupPresenterWidget> numaSupportPopupProvider, final Provider<HostListModel<Void>> modelProvider, final Provider<CommonModel> commonModelProvider) {
    MainTabModelProvider<VDS, HostListModel<Void>> result = new MainTabModelProvider<VDS, HostListModel<Void>>(eventBus, defaultConfirmPopupProvider, commonModelProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(HostListModel<Void> source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand() || lastExecutedCommand == getModel().getEditCommand() || lastExecutedCommand == getModel().getEditWithPMemphasisCommand() || lastExecutedCommand == getModel().getApproveCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getInstallCommand() || lastExecutedCommand == getModel().getUpgradeCommand()) {
                return installPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getAssignTagsCommand()) {
                return assignTagsPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getConfigureLocalStorageCommand()) {
                return configureLocalStoragePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getNumaSupportCommand()) {
                return numaSupportPopupProvider.get();
            }
            return super.getModelPopup(source, lastExecutedCommand, windowModel);
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(HostListModel<Void> source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getMaintenanceCommand()) {
                return hostMaintenanceConfirmationPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getManualFenceCommand()) {
                return manualFenceConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setModelProvider(modelProvider);
    return result;
}
#method_after
// Main List Model
@Provides
@Singleton
public MainModelProvider<VDS, HostListModel<Void>> getHostListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<HostPopupPresenterWidget> popupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<HostMaintenanceConfirmationPopupPresenterWidget> hostMaintenanceConfirmationPopupProvider, final Provider<ManualFencePopupPresenterWidget> manualFenceConfirmPopupProvider, final Provider<AssignTagsPopupPresenterWidget> assignTagsPopupProvider, final Provider<ConfigureLocalStoragePopupPresenterWidget> configureLocalStoragePopupProvider, final Provider<HostInstallPopupPresenterWidget> installPopupProvider, final Provider<NumaSupportPopupPresenterWidget> numaSupportPopupProvider, final Provider<HostListModel<Void>> modelProvider) {
    MainTabModelProvider<VDS, HostListModel<Void>> result = new MainTabModelProvider<VDS, HostListModel<Void>>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(HostListModel<Void> source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand() || lastExecutedCommand == getModel().getEditCommand() || lastExecutedCommand == getModel().getEditWithPMemphasisCommand() || lastExecutedCommand == getModel().getApproveCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getInstallCommand() || lastExecutedCommand == getModel().getUpgradeCommand()) {
                return installPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getAssignTagsCommand()) {
                return assignTagsPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getConfigureLocalStorageCommand()) {
                return configureLocalStoragePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getNumaSupportCommand()) {
                return numaSupportPopupProvider.get();
            }
            return super.getModelPopup(source, lastExecutedCommand, windowModel);
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(HostListModel<Void> source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getMaintenanceCommand()) {
                return hostMaintenanceConfirmationPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getManualFenceCommand()) {
                return manualFenceConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Override
protected void onEntityChanged() {
    super.onEntityChanged();
    getSearchCommand().execute();
}
#method_after
@Override
protected void onEntityChanged() {
    super.onEntityChanged();
    getSearchCommand().execute();
    loadEntitiesNameMap();
}
#end_block

#method_before
private void updateActionAvailability() {
    getNewCommand().setIsExecutionAllowed(true);
    boolean hasSelectedItems = getSelectedItems() != null && getSelectedItems().size() > 0;
    getEditCommand().setIsExecutionAllowed(hasSelectedItems && getSelectedItems().size() == 1);
    getRemoveCommand().setIsExecutionAllowed(hasSelectedItems);
}
#method_after
private void updateActionAvailability() {
    boolean hasSelectedItems = getSelectedItems() != null && getSelectedItems().size() > 0;
    getEditCommand().setIsExecutionAllowed(hasSelectedItems && getSelectedItems().size() == 1);
    getRemoveCommand().setIsExecutionAllowed(hasSelectedItems);
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeAffinityLabelsTitle());
    model.setHelpTag(HelpTag.remove_affinity_groups);
    // $NON-NLS-1$
    model.setHashName("remove_affinity_labels");
    ArrayList<String> list = new ArrayList<>();
    for (Label affinityLabel : getSelectedItems()) {
        list.add(affinityLabel.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand command = UICommand.createDefaultOkUiCommand("OnRemove", this);
    model.getCommands().add(command);
    // $NON-NLS-1$
    model.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeAffinityLabelsTitle());
    model.setHelpTag(HelpTag.remove_affinity_groups);
    // $NON-NLS-1$
    model.setHashName("remove_affinity_labels");
    ArrayList<String> list = new ArrayList<>();
    for (Label affinityLabel : getSelectedItems()) {
        list.add(affinityLabel.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    model.getCommands().add(UICommand.createDefaultOkUiCommand("OnRemove", this));
    // $NON-NLS-1$
    model.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
}
#end_block

#method_before
private void onRemove() {
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    for (Label affinityLabel : getSelectedItems()) {
        parameters.add(new LabelActionParameters(affinityLabel));
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.RemoveLabel, parameters, result -> {
        ConfirmationModel localModel = (ConfirmationModel) result.getState();
        localModel.stopProgress();
        cancel();
    }, model);
}
#method_after
private void onRemove() {
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<ActionParametersBase> parameters = new ArrayList<>();
    for (Label affinityLabel : getSelectedItems()) {
        parameters.add(new LabelActionParameters(affinityLabel));
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(ActionType.RemoveLabel, parameters, result -> {
        ConfirmationModel localModel = (ConfirmationModel) result.getState();
        localModel.stopProgress();
        cancel();
    }, model);
}
#end_block

#method_before
// Main List Model
@Provides
@Singleton
public MainModelProvider<Cluster, ClusterListModel<Void>> getClusterListProvider(EventBus eventBus, final Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<ClusterPopupPresenterWidget> popupProvider, final Provider<GuidePopupPresenterWidget> guidePopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<MultipleHostsPopupPresenterWidget> addMultipleHostsPopupProvider, final Provider<SharedMacPoolPopupPresenterWidget> macPoolPopupProvider, final Provider<ClusterListModel<Void>> clusterProvider, final Provider<CommonModel> commonModelProvider, final Provider<ClusterWarningsPopupPresenterWidget> clusterWarningsPopupProvider) {
    MainTabModelProvider<Cluster, ClusterListModel<Void>> result = new MainTabModelProvider<Cluster, ClusterListModel<Void>>(eventBus, defaultConfirmPopupProvider, commonModelProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(ClusterListModel<Void> source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand() || lastExecutedCommand == getModel().getEditCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getGuideCommand()) {
                return guidePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getAddMacPoolCommand()) {
                return macPoolPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getAddMultipleHostsCommand()) {
                return addMultipleHostsPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(ClusterListModel<Void> source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getResetEmulatedMachineCommand()) {
                return defaultConfirmPopupProvider.get();
            } else if (source.getConfirmWindow() instanceof ClusterWarningsModel) {
                return clusterWarningsPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setModelProvider(clusterProvider);
    return result;
}
#method_after
// Main List Model
@Provides
@Singleton
public MainModelProvider<Cluster, ClusterListModel<Void>> getClusterListProvider(EventBus eventBus, final Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<ClusterPopupPresenterWidget> popupProvider, final Provider<GuidePopupPresenterWidget> guidePopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<MultipleHostsPopupPresenterWidget> addMultipleHostsPopupProvider, final Provider<SharedMacPoolPopupPresenterWidget> macPoolPopupProvider, final Provider<ClusterListModel<Void>> clusterProvider, final Provider<ClusterWarningsPopupPresenterWidget> clusterWarningsPopupProvider) {
    MainTabModelProvider<Cluster, ClusterListModel<Void>> result = new MainTabModelProvider<Cluster, ClusterListModel<Void>>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(ClusterListModel<Void> source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand() || lastExecutedCommand == getModel().getEditCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getGuideCommand()) {
                return guidePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getAddMacPoolCommand()) {
                return macPoolPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getAddMultipleHostsCommand()) {
                return addMultipleHostsPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(ClusterListModel<Void> source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getResetEmulatedMachineCommand()) {
                return defaultConfirmPopupProvider.get();
            } else if (source.getConfirmWindow() instanceof ClusterWarningsModel) {
                return clusterWarningsPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setModelProvider(clusterProvider);
    return result;
}
#end_block

#method_before
@Override
public AffinityLabelModel flush() {
    return driver.flush();
}
#method_after
@Override
public AffinityLabelModel flush() {
    addRemoveHostWidget.flush();
    addRemoveVmWidget.flush();
    return driver.flush();
}
#end_block

#method_before
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    Cluster cluster = getSelectedItem();
    getClusterVmListModel().setIsAvailable(cluster != null && cluster.supportsVirtService());
    getClusterServiceModel().setIsAvailable(cluster != null && cluster.supportsGlusterService());
    getClusterGlusterHookListModel().setIsAvailable(cluster != null && cluster.supportsGlusterService());
    getAffinityGroupListModel().setIsAvailable(cluster != null && cluster.supportsVirtService());
    getCpuProfileListModel().setIsAvailable(cluster != null && cluster.supportsVirtService());
    getAffinityLabelListModel().setIsAvailable(cluster != null && cluster.supportsVirtService());
}
#method_after
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    Cluster cluster = getSelectedItem();
    boolean clusterSupportsVirtService = cluster != null && cluster.supportsVirtService();
    boolean clusterSupportsGlusterService = cluster != null && cluster.supportsGlusterService();
    getClusterVmListModel().setIsAvailable(clusterSupportsVirtService);
    getClusterServiceModel().setIsAvailable(clusterSupportsGlusterService);
    getClusterGlusterHookListModel().setIsAvailable(clusterSupportsGlusterService);
    getAffinityGroupListModel().setIsAvailable(clusterSupportsVirtService);
    getCpuProfileListModel().setIsAvailable(clusterSupportsVirtService);
    getAffinityLabelListModel().setIsAvailable(clusterSupportsVirtService);
}
#end_block

#method_before
public void onResetClusterEmulatedMachine() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> prms = new ArrayList<>();
    for (Cluster cluster : getSelectedItems()) {
        ManagementNetworkOnClusterOperationParameters currentParam = new ManagementNetworkOnClusterOperationParameters(cluster);
        currentParam.setForceResetEmulatedMachine(true);
        prms.add(currentParam);
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.UpdateCluster, prms, result -> {
        model.stopProgress();
        cancel();
    });
}
#method_after
public void onResetClusterEmulatedMachine() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<ActionParametersBase> prms = new ArrayList<>();
    for (Cluster cluster : getSelectedItems()) {
        ManagementNetworkOnClusterOperationParameters currentParam = new ManagementNetworkOnClusterOperationParameters(cluster);
        currentParam.setForceResetEmulatedMachine(true);
        prms.add(currentParam);
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(ActionType.UpdateCluster, prms, result -> {
        model.stopProgress();
        cancel();
    });
}
#end_block

#method_before
public void onRemove() {
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> prms = new ArrayList<>();
    for (Object a : getSelectedItems()) {
        prms.add(new ClusterParametersBase(((Cluster) a).getId()));
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.RemoveCluster, prms, result -> {
        ConfirmationModel localModel = (ConfirmationModel) result.getState();
        localModel.stopProgress();
        cancel();
    }, model);
}
#method_after
public void onRemove() {
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<ActionParametersBase> prms = new ArrayList<>();
    for (Object a : getSelectedItems()) {
        prms.add(new ClusterParametersBase(((Cluster) a).getId()));
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(ActionType.RemoveCluster, prms, result -> {
        ConfirmationModel localModel = (ConfirmationModel) result.getState();
        localModel.stopProgress();
        cancel();
    }, model);
}
#end_block

#method_before
private void onSaveInternalWithModel(final ClusterModel model) {
    Cluster cluster = buildCluster(model);
    model.startProgress();
    final Network managementNetwork = model.getManagementNetwork().getSelectedItem();
    final ManagementNetworkOnClusterOperationParameters clusterOperationParameters = new ManagementNetworkOnClusterOperationParameters(cluster, managementNetwork.getId());
    final VdcActionType actionType = model.getIsNew() ? VdcActionType.AddCluster : VdcActionType.UpdateCluster;
    Frontend.getInstance().runAction(actionType, clusterOperationParameters, result -> {
        ClusterListModel<Void> localModel = (ClusterListModel<Void>) result.getState();
        if (model.getIsImportGlusterConfiguration().getEntity()) {
            localModel.postOnSaveInternalWithImport(result.getReturnValue());
        } else {
            localModel.postOnSaveInternal(result.getReturnValue());
        }
    }, this);
}
#method_after
private void onSaveInternalWithModel(final ClusterModel model) {
    Cluster cluster = buildCluster(model);
    model.startProgress();
    final Network managementNetwork = model.getManagementNetwork().getSelectedItem();
    final ManagementNetworkOnClusterOperationParameters clusterOperationParameters = new ManagementNetworkOnClusterOperationParameters(cluster, managementNetwork.getId());
    final ActionType actionType = model.getIsNew() ? ActionType.AddCluster : ActionType.UpdateCluster;
    Frontend.getInstance().runAction(actionType, clusterOperationParameters, result -> {
        ClusterListModel<Void> localModel = (ClusterListModel<Void>) result.getState();
        if (model.getIsImportGlusterConfiguration().getEntity()) {
            localModel.postOnSaveInternalWithImport(result.getReturnValue());
        } else {
            localModel.postOnSaveInternal(result.getReturnValue());
        }
    }, this);
}
#end_block

#method_before
private void addHosts(final MultipleHostsModel hostsModel) {
    hostsModel.startProgress();
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<>();
    for (Object object : hostsModel.getHosts().getItems()) {
        HostDetailModel hostDetailModel = (HostDetailModel) ((EntityModel) object).getEntity();
        VDS host = new VDS();
        host.setVdsName(hostDetailModel.getName());
        host.setHostName(hostDetailModel.getAddress());
        host.setSshKeyFingerprint(hostDetailModel.getFingerprint());
        host.setPort(54321);
        // TODO: get from UI, till then using defaults.
        host.setSshPort(22);
        // $NON-NLS-1$
        host.setSshUsername("root");
        host.setClusterId(hostsModel.getClusterModel().getClusterId());
        host.setPmEnabled(false);
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setPassword(hostDetailModel.getPassword());
        parameters.setOverrideFirewall(hostsModel.isConfigureFirewall());
        parametersList.add(parameters);
    }
    // Todo: calling the runMultipleAction() with isRunOnlyIfAllValidationPass=false
    // becuase this flag is now supported.
    // should check what is the required behaviour and return to true if required.
    Frontend.getInstance().runMultipleAction(VdcActionType.AddVds, parametersList, false, result -> {
        hostsModel.stopProgress();
        boolean isAllValidatePassed = true;
        for (VdcReturnValueBase returnValueBase : result.getReturnValue()) {
            isAllValidatePassed = returnValueBase.isValid();
            if (!isAllValidatePassed) {
                break;
            }
        }
        if (isAllValidatePassed) {
            cancel();
        }
    }, null);
}
#method_after
private void addHosts(final MultipleHostsModel hostsModel) {
    hostsModel.startProgress();
    ArrayList<ActionParametersBase> parametersList = new ArrayList<>();
    for (Object object : hostsModel.getHosts().getItems()) {
        HostDetailModel hostDetailModel = (HostDetailModel) ((EntityModel) object).getEntity();
        VDS host = new VDS();
        host.setVdsName(hostDetailModel.getName());
        host.setHostName(hostDetailModel.getAddress());
        host.setSshKeyFingerprint(hostDetailModel.getFingerprint());
        host.setPort(54321);
        // TODO: get from UI, till then using defaults.
        host.setSshPort(22);
        // $NON-NLS-1$
        host.setSshUsername("root");
        host.setClusterId(hostsModel.getClusterModel().getClusterId());
        host.setPmEnabled(false);
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setPassword(hostDetailModel.getPassword());
        parameters.setOverrideFirewall(hostsModel.isConfigureFirewall());
        parametersList.add(parameters);
    }
    // Todo: calling the runMultipleAction() with isRunOnlyIfAllValidationPass=false
    // becuase this flag is now supported.
    // should check what is the required behaviour and return to true if required.
    Frontend.getInstance().runMultipleAction(ActionType.AddVds, parametersList, false, result -> {
        hostsModel.stopProgress();
        boolean isAllValidatePassed = true;
        for (VdcReturnValueBase returnValueBase : result.getReturnValue()) {
            isAllValidatePassed = returnValueBase.isValid();
            if (!isAllValidatePassed) {
                break;
            }
        }
        if (isAllValidatePassed) {
            cancel();
        }
    }, null);
}
#end_block

#method_before
protected void initTable() {
    getTable().enableColumnResizing();
    // Name Column
    AbstractTextColumn<Label> nameColumn = new AbstractTextColumn<Label>() {

        @Override
        public String getValue(Label object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.affinityLabelsNameColumnLabel(), "150px");
    // VM Members Column
    AbstractTextColumn<Label> vmMembersColumn = new AbstractTextColumn<Label>() {

        @Override
        public String getValue(Label object) {
            // $NON-NLS-1$
            String join = join(getVmNames(object), ", ");
            if (join.isEmpty()) {
                return constants.affinityLabelsNoMembers();
            }
            return join;
        }
    };
    vmMembersColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(vmMembersColumn, constants.affinityLabelsVmsColumnLabel(), "500px");
    // Host Members Column
    AbstractTextColumn<Label> hostMembersColumn = new AbstractTextColumn<Label>() {

        @Override
        public String getValue(Label object) {
            // $NON-NLS-1$
            String join = join(getHostNames(object), ", ");
            if (join.isEmpty()) {
                return constants.affinityLabelsNoMembers();
            }
            return join;
        }
    };
    hostMembersColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(hostMembersColumn, constants.affinityLabelsHostsColumnLabel(), "500px");
    // Action Buttons
    getTable().addActionButton(new WebAdminButtonDefinition<Label>(constants.affinityLabelsSubTabNewButton()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Label>(constants.affinityLabelsSubTabEditButton()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Label>(constants.affinityLabelsSubTabDeleteButton()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRemoveCommand();
        }
    });
}
#method_after
protected void initTable() {
    getTable().enableColumnResizing();
    // Name Column
    AbstractTextColumn<Label> nameColumn = new AbstractTextColumn<Label>() {

        @Override
        public String getValue(Label label) {
            return label.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.affinityLabelsNameColumnLabel(), "150px");
    // VM Members Column
    AbstractTextColumn<Label> vmMembersColumn = new AbstractTextColumn<Label>() {

        @Override
        public String getValue(Label label) {
            // $NON-NLS-1$
            String vmNames = StringUtils.join(getVmNames(label), ", ");
            if (vmNames.isEmpty()) {
                return constants.affinityLabelsNoMembers();
            }
            return vmNames;
        }
    };
    vmMembersColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(vmMembersColumn, constants.affinityLabelsVmsColumnLabel(), "500px");
    // Host Members Column
    AbstractTextColumn<Label> hostMembersColumn = new AbstractTextColumn<Label>() {

        @Override
        public String getValue(Label label) {
            // $NON-NLS-1$
            String hostNames = StringUtils.join(getHostNames(label), ", ");
            if (hostNames.isEmpty()) {
                return constants.affinityLabelsNoMembers();
            }
            return hostNames;
        }
    };
    hostMembersColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(hostMembersColumn, constants.affinityLabelsHostsColumnLabel(), "500px");
    // Action Buttons
    addButtonToActionGroup(getTable().addActionButton(new WebAdminButtonDefinition<Label>(constants.affinityLabelsSubTabNewButton()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getNewCommand();
        }
    }));
    addButtonToActionGroup(getTable().addActionButton(new WebAdminButtonDefinition<Label>(constants.affinityLabelsSubTabEditButton()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getEditCommand();
        }
    }));
}
#end_block

#method_before
protected List<String> getVmNames(Label label) {
    return new ArrayList<>(label.getVmNames());
}
#method_after
protected List<String> getVmNames(Label label) {
    List<String> vmNames = new ArrayList<>();
    if (!entitiesNameMap.isEmpty() && !label.getVms().isEmpty()) {
        label.getVms().forEach(id -> {
            String vmName = entitiesNameMap.get(id);
            if (vmName != null && !vmName.isEmpty()) {
                vmNames.add(vmName);
            }
        });
        Collections.sort(vmNames);
    }
    return vmNames;
}
#end_block

#method_before
protected List<String> getHostNames(Label label) {
    return new ArrayList<>(label.getHostNames());
}
#method_after
protected List<String> getHostNames(Label label) {
    List<String> hostNames = new ArrayList<>();
    if (!entitiesNameMap.isEmpty() && !label.getHosts().isEmpty()) {
        label.getHosts().forEach(id -> {
            String hostName = entitiesNameMap.get(id);
            if (hostName != null && !hostName.isEmpty()) {
                hostNames.add(hostName);
            }
        });
        Collections.sort(hostNames);
    }
    return hostNames;
}
#end_block

#method_before
// Main List Model
@Provides
@Singleton
public MainModelProvider<VM, VmListModel<Void>> getVmListProvider(EventBus eventBus, final Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<AssignTagsPopupPresenterWidget> assignTagsPopupProvider, final Provider<VmMakeTemplatePopupPresenterWidget> makeTemplatePopupProvider, final Provider<VmRunOncePopupPresenterWidget> runOncePopupProvider, final Provider<VmChangeCDPopupPresenterWidget> changeCDPopupProvider, final Provider<VmExportPopupPresenterWidget> exportPopupProvider, final Provider<VmSnapshotCreatePopupPresenterWidget> createSnapshotPopupProvider, final Provider<VmMigratePopupPresenterWidget> migratePopupProvider, final Provider<VmPopupPresenterWidget> newVmPopupProvider, final Provider<GuidePopupPresenterWidget> guidePopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<VmRemovePopupPresenterWidget> vmRemoveConfirmPopupProvider, final Provider<ConsolePopupPresenterWidget> consolePopupProvider, final Provider<VncInfoPopupPresenterWidget> vncWindoProvider, final Provider<VmNextRunConfigurationPresenterWidget> nextRunProvider, final Provider<ImportVmsPopupPresenterWidget> importVmsProvider, final Provider<CloneVmPopupPresenterWidget> cloneVmProvider, final Provider<ImportVmFromExportDomainPopupPresenterWidget> importVmFromExportDomainPopupProvider, final Provider<ImportVmFromExternalProviderPopupPresenterWidget> importVmFromExternalProviderProvider, final Provider<VmListModel<Void>> modelProvider, final Provider<CommonModel> commonModelProvider, final Provider<VmDiskPopupPresenterWidget> newDiskPopupProvider, final Provider<SingleSelectionVmDiskAttachPopupPresenterWidget> attachDiskPopupProvider, final Provider<VmDiskRemovePopupPresenterWidget> removeDiskConfirmPopupProvider) {
    MainTabModelProvider<VM, VmListModel<Void>> result = new MainTabModelProvider<VM, VmListModel<Void>>(eventBus, defaultConfirmPopupProvider, commonModelProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VmListModel<Void> source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getAssignTagsCommand()) {
                return assignTagsPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getNewTemplateCommand()) {
                return makeTemplatePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getRunOnceCommand()) {
                return runOncePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getChangeCdCommand()) {
                return changeCDPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getExportCommand()) {
                return exportPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCreateSnapshotCommand()) {
                return createSnapshotPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getMigrateCommand()) {
                return migratePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getEditCommand() || lastExecutedCommand == getModel().getNewVmCommand() || "OnSave".equals(lastExecutedCommand.getName())) {
                // $NON-NLS-1$
                if (windowModel instanceof AttachDiskModel) {
                    return attachDiskPopupProvider.get();
                } else if ((windowModel instanceof NewDiskModel) || (windowModel instanceof EditDiskModel)) {
                    return newDiskPopupProvider.get();
                } else {
                    return newVmPopupProvider.get();
                }
            } else if (lastExecutedCommand == getModel().getGuideCommand()) {
                return guidePopupProvider.get();
            } else if (windowModel instanceof VncInfoModel) {
                return vncWindoProvider.get();
            } else if (lastExecutedCommand == getModel().getEditConsoleCommand()) {
                return consolePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCloneVmCommand()) {
                return cloneVmProvider.get();
            } else if (lastExecutedCommand == getModel().getImportVmCommand() || windowModel instanceof ImportVmsModel) {
                return importVmsProvider.get();
            } else if (windowModel instanceof ImportVmFromExportDomainModel) {
                return importVmFromExportDomainPopupProvider.get();
            } else if (windowModel instanceof ImportVmFromExternalProviderModel) {
                return importVmFromExternalProviderProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public String[] getWindowPropertyNames() {
            List<String> names = new ArrayList<>();
            names.addAll(Arrays.asList(super.getWindowPropertyNames()));
            names.add(VmBaseListModel.DISK_WINDOW);
            return names.toArray(new String[names.size()]);
        }

        @Override
        public Model getWindowModel(VmListModel<Void> source, String propertyName) {
            if (VmBaseListModel.DISK_WINDOW.equals(propertyName)) {
                return source.getDiskWindow();
            }
            return super.getWindowModel(source, propertyName);
        }

        @Override
        public void clearWindowModel(VmListModel<Void> source, String propertyName) {
            if (VmBaseListModel.DISK_WINDOW.equals(propertyName)) {
                source.setDiskWindow(null);
            } else {
                super.clearWindowModel(source, propertyName);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(VmListModel<Void> source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return vmRemoveConfirmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getStopCommand() || lastExecutedCommand == getModel().getShutdownCommand()) {
                return removeConfirmPopupProvider.get();
            } else if (source.getConfirmWindow() instanceof VmNextRunConfigurationModel) {
                return nextRunProvider.get();
            } else if ("OnSave".equals(lastExecutedCommand.getName())) {
                // $NON-NLS-1$
                return defaultConfirmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getEditCommand()) {
                return removeDiskConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setModelProvider(modelProvider);
    return result;
}
#method_after
// Main List Model
@Provides
@Singleton
public MainModelProvider<VM, VmListModel<Void>> getVmListProvider(EventBus eventBus, final Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<AssignTagsPopupPresenterWidget> assignTagsPopupProvider, final Provider<VmMakeTemplatePopupPresenterWidget> makeTemplatePopupProvider, final Provider<VmRunOncePopupPresenterWidget> runOncePopupProvider, final Provider<VmChangeCDPopupPresenterWidget> changeCDPopupProvider, final Provider<VmExportPopupPresenterWidget> exportPopupProvider, final Provider<VmSnapshotCreatePopupPresenterWidget> createSnapshotPopupProvider, final Provider<VmMigratePopupPresenterWidget> migratePopupProvider, final Provider<VmPopupPresenterWidget> newVmPopupProvider, final Provider<GuidePopupPresenterWidget> guidePopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<VmRemovePopupPresenterWidget> vmRemoveConfirmPopupProvider, final Provider<ConsolePopupPresenterWidget> consolePopupProvider, final Provider<VncInfoPopupPresenterWidget> vncWindoProvider, final Provider<VmNextRunConfigurationPresenterWidget> nextRunProvider, final Provider<ImportVmsPopupPresenterWidget> importVmsProvider, final Provider<CloneVmPopupPresenterWidget> cloneVmProvider, final Provider<ImportVmFromExportDomainPopupPresenterWidget> importVmFromExportDomainPopupProvider, final Provider<ImportVmFromExternalProviderPopupPresenterWidget> importVmFromExternalProviderProvider, final Provider<VmListModel<Void>> modelProvider, final Provider<VmDiskPopupPresenterWidget> newDiskPopupProvider, final Provider<SingleSelectionVmDiskAttachPopupPresenterWidget> attachDiskPopupProvider, final Provider<VmDiskRemovePopupPresenterWidget> removeDiskConfirmPopupProvider) {
    MainTabModelProvider<VM, VmListModel<Void>> result = new MainTabModelProvider<VM, VmListModel<Void>>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VmListModel<Void> source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getAssignTagsCommand()) {
                return assignTagsPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getNewTemplateCommand()) {
                return makeTemplatePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getRunOnceCommand()) {
                return runOncePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getChangeCdCommand()) {
                return changeCDPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getExportCommand()) {
                return exportPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCreateSnapshotCommand()) {
                return createSnapshotPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getMigrateCommand()) {
                return migratePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getEditCommand() || lastExecutedCommand == getModel().getNewVmCommand() || "OnSave".equals(lastExecutedCommand.getName())) {
                // $NON-NLS-1$
                if (windowModel instanceof AttachDiskModel) {
                    return attachDiskPopupProvider.get();
                } else if ((windowModel instanceof NewDiskModel) || (windowModel instanceof EditDiskModel)) {
                    return newDiskPopupProvider.get();
                } else {
                    return newVmPopupProvider.get();
                }
            } else if (lastExecutedCommand == getModel().getGuideCommand()) {
                return guidePopupProvider.get();
            } else if (windowModel instanceof VncInfoModel) {
                return vncWindoProvider.get();
            } else if (lastExecutedCommand == getModel().getEditConsoleCommand()) {
                return consolePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCloneVmCommand()) {
                return cloneVmProvider.get();
            } else if (lastExecutedCommand == getModel().getImportVmCommand() || windowModel instanceof ImportVmsModel) {
                return importVmsProvider.get();
            } else if (windowModel instanceof ImportVmFromExportDomainModel) {
                return importVmFromExportDomainPopupProvider.get();
            } else if (windowModel instanceof ImportVmFromExternalProviderModel) {
                return importVmFromExternalProviderProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public String[] getWindowPropertyNames() {
            List<String> names = new ArrayList<>();
            names.addAll(Arrays.asList(super.getWindowPropertyNames()));
            names.add(VmBaseListModel.DISK_WINDOW);
            return names.toArray(new String[names.size()]);
        }

        @Override
        public Model getWindowModel(VmListModel<Void> source, String propertyName) {
            if (VmBaseListModel.DISK_WINDOW.equals(propertyName)) {
                return source.getDiskWindow();
            }
            return super.getWindowModel(source, propertyName);
        }

        @Override
        public void clearWindowModel(VmListModel<Void> source, String propertyName) {
            if (VmBaseListModel.DISK_WINDOW.equals(propertyName)) {
                source.setDiskWindow(null);
            } else {
                super.clearWindowModel(source, propertyName);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(VmListModel<Void> source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return vmRemoveConfirmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getStopCommand() || lastExecutedCommand == getModel().getShutdownCommand()) {
                return removeConfirmPopupProvider.get();
            } else if (source.getConfirmWindow() instanceof VmNextRunConfigurationModel) {
                return nextRunProvider.get();
            } else if ("OnSave".equals(lastExecutedCommand.getName())) {
                // $NON-NLS-1$
                return defaultConfirmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getEditCommand()) {
                return removeDiskConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
public void init() {
    startProgress();
    AsyncDataProvider.getInstance().getVmListByClusterName(new AsyncQuery<>(vmList -> {
        Set<Guid> vmIds = getAffinityLabel().getVmIds();
        getVmsSelectionModel().init(vmList, vmIds != null ? new ArrayList<>(vmIds) : new ArrayList<>());
        stopProgress();
    }), clusterName);
    AsyncDataProvider.getInstance().getHostListByClusterId(new AsyncQuery<>(hostList -> {
        Set<Guid> hostIds = getAffinityLabel().getHostIds();
        Collections.sort(hostList, new NameableComparator());
        getHostsSelectionModel().init(hostList, hostIds != null ? new ArrayList<>(hostIds) : new ArrayList<>());
        stopProgress();
    }), clusterId);
}
#method_after
public void init() {
    startProgress();
    AsyncDataProvider.getInstance().getVmListByClusterName(new AsyncQuery<>(vmList -> {
        Set<Guid> vmIds = getAffinityLabel().getVms();
        getVmsSelectionModel().init(vmList, vmIds != null ? new ArrayList<>(vmIds) : new ArrayList<>());
        stopProgressOnVmsAndHostsInit();
    }), clusterName);
    AsyncDataProvider.getInstance().getHostListByClusterId(new AsyncQuery<>(hostList -> {
        Set<Guid> hostIds = getAffinityLabel().getHosts();
        Collections.sort(hostList, new NameableComparator());
        getHostsSelectionModel().init(hostList, hostIds != null ? new ArrayList<>(hostIds) : new ArrayList<>());
        stopProgressOnVmsAndHostsInit();
    }), clusterId);
}
#end_block

#method_before
protected void addCommands() {
    // $NON-NLS-1$
    UICommand command = UICommand.createDefaultOkUiCommand("OnSave", this);
    getCommands().add(command);
    // $NON-NLS-1$
    getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
}
#method_after
protected void addCommands() {
    // $NON-NLS-1$
    getCommands().add(UICommand.createDefaultOkUiCommand("OnSave", this));
    // $NON-NLS-1$
    getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
}
#end_block

#method_before
void onSave() {
    if (!validate() || (getProgress() != null)) {
        return;
    }
    Label label = getAffinityLabel();
    label.setName(getName().getEntity());
    label.setVms(new HashSet<>(getVmsSelectionModel().getSelectedVms()));
    label.setHosts(new HashSet<>(getHostsSelectionModel().getSelectedHosts()));
    startProgress();
    Frontend.getInstance().runAction(saveActionType, new LabelActionParameters(label), result -> {
        stopProgress();
        if (result != null && result.getReturnValue() != null && result.getReturnValue().getSucceeded()) {
            cancel();
        }
    }, this);
}
#method_after
void onSave() {
    if (!validate() || (getProgress() != null)) {
        return;
    }
    Label label = getAffinityLabel();
    label.setName(getName().getEntity());
    label.setVms(new HashSet<>(getVmsSelectionModel().getSelectedVmIds()));
    label.setHosts(new HashSet<>(getHostsSelectionModel().getSelectedHostIds()));
    startProgress();
    Frontend.getInstance().runAction(saveActionType, new LabelActionParameters(label), result -> {
        stopProgress();
        if (result != null && result.getReturnValue() != null && result.getReturnValue().getSucceeded()) {
            cancel();
        }
    }, this);
}
#end_block

#method_before
@Override
public void postOnAssignTags(Map<Guid, Boolean> attachedTags) {
    TagListModel model = (TagListModel) getWindow();
    ArrayList<Guid> vmIds = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        vmIds.add(vm.getId());
    }
    // prepare attach/detach lists
    ArrayList<Guid> tagsToAttach = new ArrayList<>();
    ArrayList<Guid> tagsToDetach = new ArrayList<>();
    if (model.getItems() != null && model.getItems().size() > 0) {
        ArrayList<TagModel> tags = (ArrayList<TagModel>) model.getItems();
        TagModel rootTag = tags.get(0);
        TagModel.recursiveEditAttachDetachLists(rootTag, attachedTags, tagsToAttach, tagsToDetach);
    }
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    for (Guid a : tagsToAttach) {
        parameters.add(new AttachEntityToTagParameters(a, vmIds));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.AttachVmsToTag, parameters);
    parameters = new ArrayList<>();
    for (Guid a : tagsToDetach) {
        parameters.add(new AttachEntityToTagParameters(a, vmIds));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.DetachVmFromTag, parameters);
    cancel();
}
#method_after
@Override
public void postOnAssignTags(Map<Guid, Boolean> attachedTags) {
    TagListModel model = (TagListModel) getWindow();
    ArrayList<Guid> vmIds = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        vmIds.add(vm.getId());
    }
    // prepare attach/detach lists
    ArrayList<Guid> tagsToAttach = new ArrayList<>();
    ArrayList<Guid> tagsToDetach = new ArrayList<>();
    if (model.getItems() != null && model.getItems().size() > 0) {
        ArrayList<TagModel> tags = (ArrayList<TagModel>) model.getItems();
        TagModel rootTag = tags.get(0);
        TagModel.recursiveEditAttachDetachLists(rootTag, attachedTags, tagsToAttach, tagsToDetach);
    }
    ArrayList<ActionParametersBase> parameters = new ArrayList<>();
    for (Guid a : tagsToAttach) {
        parameters.add(new AttachEntityToTagParameters(a, vmIds));
    }
    Frontend.getInstance().runMultipleAction(ActionType.AttachVmsToTag, parameters);
    parameters = new ArrayList<>();
    for (Guid a : tagsToDetach) {
        parameters.add(new AttachEntityToTagParameters(a, vmIds));
    }
    Frontend.getInstance().runMultipleAction(ActionType.DetachVmFromTag, parameters);
    cancel();
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel window = new ConfirmationModel();
    setWindow(window);
    window.setTitle(ConstantsManager.getInstance().getConstants().removeVirtualMachinesTitle());
    window.setHelpTag(HelpTag.remove_virtual_machine);
    // $NON-NLS-1$
    window.setHashName("remove_virtual_machine");
    vmsRemoveMap = new HashMap<>();
    for (Object selectedItem : getSelectedItems()) {
        VM vm = (VM) selectedItem;
        if (VdcActionUtils.canExecute(Arrays.asList(vm), VM.class, VdcActionType.RemoveVm)) {
            EntityModel removeDisksCheckbox = new EntityModel(true);
            removeDisksCheckbox.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
            removeDisksCheckbox.setMessage(vm.getName());
            if (!Guid.Empty.equals(vm.getVmtGuid())) {
                updateRemoveDisksCheckBox(removeDisksCheckbox, true, false, ConstantsManager.getInstance().getConstants().removeVmDisksTemplateMsg());
            }
            vmsRemoveMap.put(vm.getId(), removeDisksCheckbox);
        }
    }
    window.setItems(vmsRemoveMap.entrySet());
    initRemoveDisksCheckboxes(vmsRemoveMap);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
    window.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    window.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel window = new ConfirmationModel();
    setWindow(window);
    window.setTitle(ConstantsManager.getInstance().getConstants().removeVirtualMachinesTitle());
    window.setHelpTag(HelpTag.remove_virtual_machine);
    // $NON-NLS-1$
    window.setHashName("remove_virtual_machine");
    vmsRemoveMap = new HashMap<>();
    for (Object selectedItem : getSelectedItems()) {
        VM vm = (VM) selectedItem;
        if (ActionUtils.canExecute(Arrays.asList(vm), VM.class, ActionType.RemoveVm)) {
            EntityModel removeDisksCheckbox = new EntityModel(true);
            removeDisksCheckbox.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
            removeDisksCheckbox.setMessage(vm.getName());
            if (!Guid.Empty.equals(vm.getVmtGuid())) {
                updateRemoveDisksCheckBox(removeDisksCheckbox, true, false, ConstantsManager.getInstance().getConstants().removeVmDisksTemplateMsg());
            }
            vmsRemoveMap.put(vm.getId(), removeDisksCheckbox);
        }
    }
    window.setItems(vmsRemoveMap.entrySet());
    initRemoveDisksCheckboxes(vmsRemoveMap);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
    window.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    window.getCommands().add(tempVar2);
}
#end_block

#method_before
private void postExportGetMissingTemplates(ArrayList<String> missingTemplatesFromVms) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    model.stopProgress();
    for (Object a : getSelectedItems()) {
        VM vm = (VM) a;
        MoveOrCopyParameters parameter = new MoveOrCopyParameters(vm.getId(), storageDomainId);
        parameter.setForceOverride(model.getForceOverride().getEntity());
        parameter.setCopyCollapse(model.getCollapseSnapshots().getEntity());
        parameter.setTemplateMustExists(true);
        parameters.add(parameter);
    }
    if (!model.getCollapseSnapshots().getEntity()) {
        if (missingTemplatesFromVms == null || missingTemplatesFromVms.size() > 0) {
            ConfirmationModel confirmModel = new ConfirmationModel();
            setConfirmWindow(confirmModel);
            confirmModel.setTitle(ConstantsManager.getInstance().getConstants().templatesNotFoundOnExportDomainTitle());
            confirmModel.setHelpTag(HelpTag.template_not_found_on_export_domain);
            // $NON-NLS-1$
            confirmModel.setHashName("template_not_found_on_export_domain");
            confirmModel.setMessage(missingTemplatesFromVms == null ? ConstantsManager.getInstance().getConstants().couldNotReadTemplatesFromExportDomainMsg() : ConstantsManager.getInstance().getConstants().theFollowingTemplatesAreMissingOnTargetExportDomainMsg());
            confirmModel.setItems(missingTemplatesFromVms);
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnExportNoTemplates", this);
            confirmModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("CancelConfirmation", this);
            confirmModel.getCommands().add(tempVar2);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress();
            Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, parameters, result -> {
                ExportVmModel localModel = (ExportVmModel) result.getState();
                localModel.stopProgress();
                cancel();
            }, model);
        }
    } else {
        if (model.getProgress() != null) {
            return;
        }
        for (VdcActionParametersBase item : parameters) {
            MoveOrCopyParameters parameter = (MoveOrCopyParameters) item;
            parameter.setTemplateMustExists(false);
        }
        model.startProgress();
        Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, parameters, result -> {
            ExportVmModel localModel = (ExportVmModel) result.getState();
            localModel.stopProgress();
            cancel();
        }, model);
    }
}
#method_after
private void postExportGetMissingTemplates(ArrayList<String> missingTemplatesFromVms) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    ArrayList<ActionParametersBase> parameters = new ArrayList<>();
    model.stopProgress();
    for (Object a : getSelectedItems()) {
        VM vm = (VM) a;
        MoveOrCopyParameters parameter = new MoveOrCopyParameters(vm.getId(), storageDomainId);
        parameter.setForceOverride(model.getForceOverride().getEntity());
        parameter.setCopyCollapse(model.getCollapseSnapshots().getEntity());
        parameter.setTemplateMustExists(true);
        parameters.add(parameter);
    }
    if (!model.getCollapseSnapshots().getEntity()) {
        if (missingTemplatesFromVms == null || missingTemplatesFromVms.size() > 0) {
            ConfirmationModel confirmModel = new ConfirmationModel();
            setConfirmWindow(confirmModel);
            confirmModel.setTitle(ConstantsManager.getInstance().getConstants().templatesNotFoundOnExportDomainTitle());
            confirmModel.setHelpTag(HelpTag.template_not_found_on_export_domain);
            // $NON-NLS-1$
            confirmModel.setHashName("template_not_found_on_export_domain");
            confirmModel.setMessage(missingTemplatesFromVms == null ? ConstantsManager.getInstance().getConstants().couldNotReadTemplatesFromExportDomainMsg() : ConstantsManager.getInstance().getConstants().theFollowingTemplatesAreMissingOnTargetExportDomainMsg());
            confirmModel.setItems(missingTemplatesFromVms);
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnExportNoTemplates", this);
            confirmModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("CancelConfirmation", this);
            confirmModel.getCommands().add(tempVar2);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress();
            Frontend.getInstance().runMultipleAction(ActionType.ExportVm, parameters, result -> {
                ExportVmModel localModel = (ExportVmModel) result.getState();
                localModel.stopProgress();
                cancel();
            }, model);
        }
    } else {
        if (model.getProgress() != null) {
            return;
        }
        for (ActionParametersBase item : parameters) {
            MoveOrCopyParameters parameter = (MoveOrCopyParameters) item;
            parameter.setTemplateMustExists(false);
        }
        model.startProgress();
        Frontend.getInstance().runMultipleAction(ActionType.ExportVm, parameters, result -> {
            ExportVmModel localModel = (ExportVmModel) result.getState();
            localModel.stopProgress();
            cancel();
        }, model);
    }
}
#end_block

#method_before
private void onExportNoTemplates() {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        MoveOrCopyParameters parameters = new MoveOrCopyParameters(a.getId(), storageDomainId);
        parameters.setForceOverride(model.getForceOverride().getEntity());
        parameters.setCopyCollapse(model.getCollapseSnapshots().getEntity());
        parameters.setTemplateMustExists(false);
        list.add(parameters);
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, list, result -> {
        ExportVmModel localModel = (ExportVmModel) result.getState();
        localModel.stopProgress();
        cancel();
    }, model);
}
#method_after
private void onExportNoTemplates() {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<ActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        MoveOrCopyParameters parameters = new MoveOrCopyParameters(a.getId(), storageDomainId);
        parameters.setForceOverride(model.getForceOverride().getEntity());
        parameters.setCopyCollapse(model.getCollapseSnapshots().getEntity());
        parameters.setTemplateMustExists(false);
        list.add(parameters);
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(ActionType.ExportVm, list, result -> {
        ExportVmModel localModel = (ExportVmModel) result.getState();
        localModel.stopProgress();
        cancel();
    }, model);
}
#end_block

#method_before
private void postNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = getSelectedItem();
    VM newVm = buildVmOnNewTemplate(model, vm);
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newVm, model.getName().getEntity(), model.getDescription().getEntity());
    BuilderExecutor.build(model, addVmTemplateParameters, new UnitToAddVmTemplateParametersBuilder());
    model.startProgress();
    Frontend.getInstance().runAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, result -> {
        getWindow().stopProgress();
        VdcReturnValueBase returnValueBase = result.getReturnValue();
        if (returnValueBase != null && returnValueBase.getSucceeded()) {
            cancel();
        }
    }, this);
}
#method_after
private void postNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = getSelectedItem();
    VM newVm = buildVmOnNewTemplate(model, vm);
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newVm, model.getName().getEntity(), model.getDescription().getEntity());
    BuilderExecutor.build(model, addVmTemplateParameters, new UnitToAddVmTemplateParametersBuilder());
    model.startProgress();
    Frontend.getInstance().runAction(ActionType.AddVmTemplate, addVmTemplateParameters, result -> {
        getWindow().stopProgress();
        VdcReturnValueBase returnValueBase = result.getReturnValue();
        if (returnValueBase != null && returnValueBase.getSucceeded()) {
            cancel();
        }
    }, this);
}
#end_block

#method_before
private void migrate() {
    VM vm = getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    MigrateModel model = new MigrateModel(this);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().migrateVirtualMachinesTitle());
    model.setHelpTag(HelpTag.migrate_virtual_machine);
    // $NON-NLS-1$
    model.setHashName("migrate_virtual_machine");
    model.setVmsOnSameCluster(true);
    model.setIsAutoSelect(true);
    model.setVmList(new ArrayList<>(getSelectedItems()));
    model.setVm(vm);
    model.initializeModel();
}
#method_after
private void migrate() {
    VM vm = getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    MigrateModel model = new MigrateModel(this);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().migrateVirtualMachinesTitle());
    model.setHelpTag(HelpTag.migrate_virtual_machine);
    // $NON-NLS-1$
    model.setHashName("migrate_virtual_machine");
    model.setVmsOnSameCluster(true);
    model.setIsAutoSelect(true);
    model.setVmList(new ArrayList<>(getSelectedItems()));
    model.initializeModel();
}
#end_block

#method_before
private void cancelMigration() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        list.add(new VmOperationParameterBase(a.getId()));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.CancelMigrateVm, list, result -> {
    }, null);
}
#method_after
private void cancelMigration() {
    ArrayList<ActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        list.add(new VmOperationParameterBase(a.getId()));
    }
    Frontend.getInstance().runMultipleAction(ActionType.CancelMigrateVm, list, result -> {
    }, null);
}
#end_block

#method_before
private void cancelConversion() {
    List<VdcActionParametersBase> parameters = new ArrayList<>();
    for (VM vm : getSelectedItems()) {
        parameters.add(new VmOperationParameterBase(vm.getId()));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.CancelConvertVm, parameters);
}
#method_after
private void cancelConversion() {
    List<ActionParametersBase> parameters = new ArrayList<>();
    for (VM vm : getSelectedItems()) {
        parameters.add(new VmOperationParameterBase(vm.getId()));
    }
    Frontend.getInstance().runMultipleAction(ActionType.CancelConvertVm, parameters);
}
#end_block

#method_before
private void onMigrate() {
    MigrateModel model = (MigrateModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    model.startProgress();
    Guid targetClusterId = model.getClusters().getSelectedItem() != null ? model.getClusters().getSelectedItem().getId() : null;
    if (model.getIsAutoSelect()) {
        ArrayList<VdcActionParametersBase> list = new ArrayList<>();
        for (Object item : getSelectedItems()) {
            VM a = (VM) item;
            list.add(new MigrateVmParameters(true, a.getId(), targetClusterId));
        }
        Frontend.getInstance().runMultipleAction(VdcActionType.MigrateVm, list, result -> {
            MigrateModel localModel = (MigrateModel) result.getState();
            localModel.stopProgress();
            cancel();
        }, model);
    } else {
        ArrayList<VdcActionParametersBase> list = new ArrayList<>();
        for (Object item : getSelectedItems()) {
            VM a = (VM) item;
            if (a.getRunOnVds().equals(model.getHosts().getSelectedItem().getId())) {
                continue;
            }
            list.add(new MigrateVmToServerParameters(true, a.getId(), model.getHosts().getSelectedItem().getId(), targetClusterId));
        }
        Frontend.getInstance().runMultipleAction(VdcActionType.MigrateVmToServer, list, result -> {
            MigrateModel localModel = (MigrateModel) result.getState();
            localModel.stopProgress();
            cancel();
        }, model);
    }
}
#method_after
private void onMigrate() {
    MigrateModel model = (MigrateModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    model.startProgress();
    if (model.getIsAutoSelect()) {
        ArrayList<ActionParametersBase> list = new ArrayList<>();
        for (Object item : getSelectedItems()) {
            VM vm = (VM) item;
            list.add(new MigrateVmParameters(true, vm.getId(), vm.getClusterId()));
        }
        Frontend.getInstance().runMultipleAction(ActionType.MigrateVm, list, result -> {
            MigrateModel localModel = (MigrateModel) result.getState();
            localModel.stopProgress();
            cancel();
        }, model);
    } else {
        ArrayList<ActionParametersBase> list = new ArrayList<>();
        for (Object item : getSelectedItems()) {
            VM vm = (VM) item;
            if (vm.getRunOnVds().equals(model.getHosts().getSelectedItem().getId())) {
                continue;
            }
            list.add(new MigrateVmToServerParameters(true, vm.getId(), model.getHosts().getSelectedItem().getId(), vm.getClusterId()));
        }
        Frontend.getInstance().runMultipleAction(ActionType.MigrateVmToServer, list, result -> {
            MigrateModel localModel = (MigrateModel) result.getState();
            localModel.stopProgress();
            cancel();
        }, model);
    }
}
#end_block

#method_before
private void onPowerAction(VdcActionType actionType, PowerActionParametersFactory<?> parametersFactory) {
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        list.add(parametersFactory.createActionParameters(vm));
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(actionType, list, result -> {
        ConfirmationModel localModel = (ConfirmationModel) result.getState();
        localModel.stopProgress();
        cancel();
    }, model);
}
#method_after
private void onPowerAction(ActionType actionType, PowerActionParametersFactory<?> parametersFactory) {
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<ActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        list.add(parametersFactory.createActionParameters(vm));
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(actionType, list, result -> {
        ConfirmationModel localModel = (ConfirmationModel) result.getState();
        localModel.stopProgress();
        cancel();
    }, model);
}
#end_block

#method_before
private void onShutdown() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    onPowerAction(VdcActionType.ShutdownVm, vm -> new ShutdownVmParameters(vm.getId(), true, model.getReason().getEntity()));
}
#method_after
private void onShutdown() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    onPowerAction(ActionType.ShutdownVm, vm -> new ShutdownVmParameters(vm.getId(), true, model.getReason().getEntity()));
}
#end_block

#method_before
private void onStop() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    onPowerAction(VdcActionType.StopVm, vm -> new StopVmParameters(vm.getId(), StopVmTypeEnum.NORMAL, model.getReason().getEntity()));
}
#method_after
private void onStop() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    onPowerAction(ActionType.StopVm, vm -> new StopVmParameters(vm.getId(), StopVmTypeEnum.NORMAL, model.getReason().getEntity()));
}
#end_block

#method_before
private void onReboot() {
    onPowerAction(VdcActionType.RebootVm, vm -> new VmOperationParameterBase(vm.getId()));
}
#method_after
private void onReboot() {
    onPowerAction(ActionType.RebootVm, vm -> new VmOperationParameterBase(vm.getId()));
}
#end_block

#method_before
private void pause() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        list.add(new VmOperationParameterBase(a.getId()));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.HibernateVm, list, result -> {
    }, null);
}
#method_after
private void pause() {
    ArrayList<ActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        list.add(new VmOperationParameterBase(a.getId()));
    }
    Frontend.getInstance().runMultipleAction(ActionType.HibernateVm, list, result -> {
    }, null);
}
#end_block

#method_before
private void run() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        list.add(new RunVmParams(a.getId()));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.RunVm, list, result -> {
    }, null);
}
#method_after
private void run() {
    ArrayList<ActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        list.add(new RunVmParams(a.getId()));
    }
    Frontend.getInstance().runMultipleAction(ActionType.RunVm, list, result -> {
    }, null);
}
#end_block

#method_before
private void onRemove() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    final ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    for (Entry<Guid, EntityModel> entry : vmsRemoveMap.entrySet()) {
        list.add(new RemoveVmParameters(entry.getKey(), false, (Boolean) entry.getValue().getEntity()));
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.RemoveVm, list, result -> {
        ConfirmationModel localModel = (ConfirmationModel) result.getState();
        localModel.stopProgress();
        cancel();
    }, model);
}
#method_after
private void onRemove() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    final ArrayList<ActionParametersBase> list = new ArrayList<>();
    for (Entry<Guid, EntityModel> entry : vmsRemoveMap.entrySet()) {
        list.add(new RemoveVmParameters(entry.getKey(), false, (Boolean) entry.getValue().getEntity()));
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(ActionType.RemoveVm, list, result -> {
        ConfirmationModel localModel = (ConfirmationModel) result.getState();
        localModel.stopProgress();
        cancel();
    }, model);
}
#end_block

#method_before
private void onChangeCD() {
    VM vm = getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    AttachCdModel model = (AttachCdModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (Objects.equals(model.getIsoImage().getSelectedItem(), vm.getCurrentCd())) {
        cancel();
        return;
    }
    String isoName = // $NON-NLS-1$
    Objects.equals(model.getIsoImage().getSelectedItem(), ConsoleModel.getEjectLabel()) ? // $NON-NLS-1$
    "" : model.getIsoImage().getSelectedItem();
    model.startProgress();
    Frontend.getInstance().runAction(VdcActionType.ChangeDisk, new ChangeDiskCommandParameters(vm.getId(), isoName), result -> {
        AttachCdModel attachCdModel = (AttachCdModel) result.getState();
        attachCdModel.stopProgress();
        cancel();
    }, model);
}
#method_after
private void onChangeCD() {
    VM vm = getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    AttachCdModel model = (AttachCdModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (Objects.equals(model.getIsoImage().getSelectedItem(), vm.getCurrentCd())) {
        cancel();
        return;
    }
    String isoName = // $NON-NLS-1$
    Objects.equals(model.getIsoImage().getSelectedItem(), ConsoleModel.getEjectLabel()) ? // $NON-NLS-1$
    "" : model.getIsoImage().getSelectedItem();
    model.startProgress();
    Frontend.getInstance().runAction(ActionType.ChangeDisk, new ChangeDiskCommandParameters(vm.getId(), isoName), result -> {
        AttachCdModel attachCdModel = (AttachCdModel) result.getState();
        attachCdModel.stopProgress();
        cancel();
    }, model);
}
#end_block

#method_before
@Override
protected void updateVM(final UnitVmModel model) {
    final VM selectedItem = getSelectedItem();
    // explicitly pass non-editable field from the original VM
    getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
    getcurrentVm().setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
    if (selectedItem.isRunningOrPaused() && !selectedItem.isHostedEngine()) {
        AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, getcurrentVm(), getUpdateVmParameters(false), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

            @Override
            public void onSuccess(VdcQueryReturnValue returnValue) {
                List<String> changedFields = returnValue.getReturnValue();
                final boolean cpuHotPluggable = VmCommonUtils.isCpusToBeHotplugged(selectedItem, getcurrentVm());
                final boolean isHeadlessModeChanged = isHeadlessModeChanged(editedVm, getUpdateVmParameters(false));
                final boolean memoryHotPluggable = VmCommonUtils.isMemoryToBeHotplugged(selectedItem, getcurrentVm());
                if (isHeadlessModeChanged) {
                    changedFields.add(constants.headlessMode());
                }
                // provide warnings if isVmUnpinned()
                if (!changedFields.isEmpty() || isVmUnpinned() || memoryHotPluggable || cpuHotPluggable) {
                    VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                    if (isVmUnpinned()) {
                        confirmModel.setVmUnpinned();
                    }
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                    confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                    // $NON-NLS-1$
                    confirmModel.setHashName("edit_next_run_configuration");
                    confirmModel.setChangedFields(changedFields);
                    confirmModel.setCpuPluggable(cpuHotPluggable);
                    confirmModel.setMemoryPluggable(memoryHotPluggable);
                    confirmModel.getCommands().add(// $NON-NLS-1$
                    new UICommand("updateExistingVm", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                    // $NON-NLS-1$
                    confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", VmListModel.this));
                    setConfirmWindow(confirmModel);
                } else {
                    updateExistingVm(false);
                }
            }

            private boolean isVmUnpinned() {
                if (selectedItem.isRunning()) {
                    if (selectedItem.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST && getcurrentVm().getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
                        return true;
                    }
                }
                return false;
            }
        }));
    } else {
        updateExistingVm(false);
    }
}
#method_after
@Override
protected void updateVM(final UnitVmModel model) {
    final VM selectedItem = getSelectedItem();
    // explicitly pass non-editable field from the original VM
    getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
    getcurrentVm().setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
    if (selectedItem.isRunningOrPaused() && !selectedItem.isHostedEngine()) {
        AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, getcurrentVm(), getUpdateVmParameters(false), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

            @Override
            public void onSuccess(VdcQueryReturnValue returnValue) {
                List<String> changedFields = returnValue.getReturnValue();
                final boolean cpuHotPluggable = VmCommonUtils.isCpusToBeHotplugged(selectedItem, getcurrentVm());
                final boolean isHeadlessModeChanged = isHeadlessModeChanged(editedVm, getUpdateVmParameters(false));
                final boolean memoryHotPluggable = VmCommonUtils.isMemoryToBeHotplugged(selectedItem, getcurrentVm());
                final boolean vmLeaseUpdated = !Objects.equals(selectedItem.getLeaseStorageDomainId(), getcurrentVm().getLeaseStorageDomainId());
                if (isHeadlessModeChanged) {
                    changedFields.add(constants.headlessMode());
                }
                // provide warnings if isVmUnpinned()
                if (!changedFields.isEmpty() || isVmUnpinned() || memoryHotPluggable || cpuHotPluggable || vmLeaseUpdated) {
                    VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                    if (isVmUnpinned()) {
                        confirmModel.setVmUnpinned();
                    }
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                    confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                    // $NON-NLS-1$
                    confirmModel.setHashName("edit_next_run_configuration");
                    confirmModel.setChangedFields(changedFields);
                    confirmModel.setCpuPluggable(cpuHotPluggable);
                    confirmModel.setMemoryPluggable(memoryHotPluggable);
                    confirmModel.setVmLeaseUpdated(vmLeaseUpdated);
                    confirmModel.getCommands().add(// $NON-NLS-1$
                    new UICommand("updateExistingVm", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                    // $NON-NLS-1$
                    confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", VmListModel.this));
                    setConfirmWindow(confirmModel);
                } else {
                    updateExistingVm(false);
                }
            }

            private boolean isVmUnpinned() {
                if (selectedItem.isRunning()) {
                    if (selectedItem.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST && getcurrentVm().getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
                        return true;
                    }
                }
                return false;
            }
        }));
    } else {
        updateExistingVm(false);
    }
}
#end_block

#method_before
private void updateExistingVm(final boolean applyCpuChangesLater) {
    final UnitVmModel model = (UnitVmModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    // runEditVM: should be true if Cluster hasn't changed or if
    // Cluster has changed and Editing it in the Backend has succeeded:
    VM selectedItem = getSelectedItem();
    Guid oldClusterID = selectedItem.getClusterId();
    Guid newClusterID = model.getSelectedCluster().getId();
    if (!oldClusterID.equals(newClusterID)) {
        ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId(), model.getCustomCompatibilityVersion().getSelectedItem());
        model.startProgress();
        Frontend.getInstance().runAction(VdcActionType.ChangeVMCluster, parameters, result -> {
            final VmListModel<Void> vmListModel = (VmListModel<Void>) result.getState();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                VM vm = vmListModel.getcurrentVm();
                VmManagementParametersBase updateVmParams = vmListModel.getUpdateVmParameters(applyCpuChangesLater);
                Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, vm.getId()), vmListModel);
            } else {
                vmListModel.getWindow().stopProgress();
            }
        }, this);
    } else {
        model.startProgress();
        VmManagementParametersBase updateVmParams = getUpdateVmParameters(applyCpuChangesLater);
        Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, getcurrentVm().getId()), this);
    }
}
#method_after
private void updateExistingVm(final boolean applyCpuChangesLater) {
    final UnitVmModel model = (UnitVmModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    // runEditVM: should be true if Cluster hasn't changed or if
    // Cluster has changed and Editing it in the Backend has succeeded:
    VM selectedItem = getSelectedItem();
    Guid oldClusterID = selectedItem.getClusterId();
    Guid newClusterID = model.getSelectedCluster().getId();
    if (!oldClusterID.equals(newClusterID)) {
        ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId(), model.getCustomCompatibilityVersion().getSelectedItem());
        model.startProgress();
        Frontend.getInstance().runAction(ActionType.ChangeVMCluster, parameters, result -> {
            final VmListModel<Void> vmListModel = (VmListModel<Void>) result.getState();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                VM vm = vmListModel.getcurrentVm();
                VmManagementParametersBase updateVmParams = vmListModel.getUpdateVmParameters(applyCpuChangesLater);
                Frontend.getInstance().runAction(ActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, vm.getId()), vmListModel);
            } else {
                vmListModel.getWindow().stopProgress();
            }
        }, this);
    } else {
        model.startProgress();
        VmManagementParametersBase updateVmParams = getUpdateVmParameters(applyCpuChangesLater);
        Frontend.getInstance().runAction(ActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, getcurrentVm().getId()), this);
    }
}
#end_block

#method_before
public VmManagementParametersBase getUpdateVmParameters(boolean applyCpuChangesLater) {
    UnitVmModel model = (UnitVmModel) getWindow();
    VmManagementParametersBase updateVmParams = new VmManagementParametersBase(getcurrentVm());
    setVmWatchdogToParams(model, updateVmParams);
    updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    updateVmParams.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    updateVmParams.setBalloonEnabled(balloonEnabled(model));
    updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
    updateVmParams.setApplyChangesLater(applyCpuChangesLater);
    updateVmParams.setUpdateNuma(model.isNumaChanged());
    if (model.getIsHeadlessModeEnabled().getEntity()) {
        updateVmParams.getVmStaticData().setDefaultDisplayType(DisplayType.none);
    }
    BuilderExecutor.build(new Pair<>((UnitVmModel) getWindow(), getSelectedItem()), updateVmParams, new VmIconUnitAndVmToParameterBuilder());
    setRngDeviceToParams(model, updateVmParams);
    BuilderExecutor.build(model, updateVmParams, new UnitToGraphicsDeviceParamsBuilder());
    return updateVmParams;
}
#method_after
public VmManagementParametersBase getUpdateVmParameters(boolean applyCpuChangesLater) {
    UnitVmModel model = (UnitVmModel) getWindow();
    VmManagementParametersBase updateVmParams = new VmManagementParametersBase(getcurrentVm());
    setVmWatchdogToParams(model, updateVmParams);
    updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    updateVmParams.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    updateVmParams.setBalloonEnabled(balloonEnabled(model));
    updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
    updateVmParams.setApplyChangesLater(applyCpuChangesLater);
    updateVmParams.setUpdateNuma(model.isNumaChanged());
    updateVmParams.setAffinityLabels(model.getLabelList().getSelectedItems());
    if (model.getIsHeadlessModeEnabled().getEntity()) {
        updateVmParams.getVmStaticData().setDefaultDisplayType(DisplayType.none);
    }
    BuilderExecutor.build(new Pair<>((UnitVmModel) getWindow(), getSelectedItem()), updateVmParams, new VmIconUnitAndVmToParameterBuilder());
    setRngDeviceToParams(model, updateVmParams);
    BuilderExecutor.build(model, updateVmParams, new UnitToGraphicsDeviceParamsBuilder());
    return updateVmParams;
}
#end_block

#method_before
private void changeCD(Object sender, EventArgs e) {
    ChangeCDModel model = (ChangeCDModel) sender;
    // TODO: Patch!
    String isoName = model.getTitle();
    if (Objects.equals(isoName, ConstantsManager.getInstance().getConstants().noCds())) {
        return;
    }
    Object tempVar = getSelectedItem();
    VM vm = (VM) ((tempVar instanceof VM) ? tempVar : null);
    if (vm == null) {
        return;
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.ChangeDisk, new ArrayList<>(Arrays.asList(new VdcActionParametersBase[] { new ChangeDiskCommandParameters(vm.getId(), // $NON-NLS-1$
    Objects.equals(isoName, ConsoleModel.getEjectLabel()) ? "" : isoName) })), result -> {
    }, null);
}
#method_after
private void changeCD(Object sender, EventArgs e) {
    ChangeCDModel model = (ChangeCDModel) sender;
    // TODO: Patch!
    String isoName = model.getTitle();
    if (Objects.equals(isoName, ConstantsManager.getInstance().getConstants().noCds())) {
        return;
    }
    Object tempVar = getSelectedItem();
    VM vm = (VM) ((tempVar instanceof VM) ? tempVar : null);
    if (vm == null) {
        return;
    }
    Frontend.getInstance().runMultipleAction(ActionType.ChangeDisk, new ArrayList<>(Arrays.asList(new ActionParametersBase[] { new ChangeDiskCommandParameters(vm.getId(), // $NON-NLS-1$
    Objects.equals(isoName, ConsoleModel.getEjectLabel()) ? "" : isoName) })), result -> {
    }, null);
}
#end_block

#method_before
@Override
protected void updateActionsAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItemsWithStatusForExclusiveLock() : new ArrayList();
    boolean singleVmSelected = items.size() == 1;
    boolean vmsSelected = items.size() > 0;
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, VdcActionType.RunVm));
    getCloneVmCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, VdcActionType.CloneVm));
    getPauseCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, VdcActionType.HibernateVm));
    getShutdownCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, VdcActionType.StopVm));
    getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.getInstance().isRebootCommandExecutionAllowed(items));
    getMigrateCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(singleVmSelected && !getSelectedItem().isStateless() && !getSelectedItem().isPreviewSnapshot() && VdcActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(vmsSelected);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || singleVmSelected);
    getConsoleConnectCommand().setIsExecutionAllowed(isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(singleVmSelected && isConsoleEditEnabled());
    getCancelConvertCommand().setIsExecutionAllowed(isSelectedVmBeingConverted());
}
#method_after
@Override
protected void updateActionsAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItemsWithStatusForExclusiveLock() : new ArrayList();
    boolean singleVmSelected = items.size() == 1;
    boolean vmsSelected = items.size() > 0;
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(vmsSelected && ActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, ActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(vmsSelected && ActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, ActionType.RunVm));
    getCloneVmCommand().setIsExecutionAllowed(singleVmSelected && ActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, ActionType.CloneVm));
    getPauseCommand().setIsExecutionAllowed(vmsSelected && ActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, ActionType.HibernateVm));
    getShutdownCommand().setIsExecutionAllowed(vmsSelected && ActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, ActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(vmsSelected && ActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, ActionType.StopVm));
    getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.getInstance().isRebootCommandExecutionAllowed(items));
    getMigrateCommand().setIsExecutionAllowed(vmsSelected && ActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, ActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(vmsSelected && ActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, ActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(singleVmSelected && ActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, ActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(singleVmSelected && ActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, ActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(vmsSelected && ActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, ActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(singleVmSelected && !getSelectedItem().isStateless() && !getSelectedItem().isPreviewSnapshot() && ActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, ActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(singleVmSelected && ActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, ActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(singleVmSelected && ActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, ActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(vmsSelected);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || singleVmSelected);
    getConsoleConnectCommand().setIsExecutionAllowed(isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(singleVmSelected && isConsoleEditEnabled());
    getCancelConvertCommand().setIsExecutionAllowed(isSelectedVmBeingConverted());
}
#end_block

#method_before
private boolean updateVmLease() {
    if (Objects.equals(oldVm.getLeaseStorageDomainId(), newVmStatic.getLeaseStorageDomainId())) {
        return true;
    }
    if (!addVmLease(newVmStatic.getLeaseStorageDomainId(), newVmStatic.getId())) {
        return false;
    }
    // best effort to remove the lease from the previous storage domain
    removeVmLease(oldVm.getLeaseStorageDomainId(), oldVm.getId());
    return true;
}
#method_after
private boolean updateVmLease() {
    if (Objects.equals(oldVm.getLeaseStorageDomainId(), newVmStatic.getLeaseStorageDomainId())) {
        return true;
    }
    if (getVm().isNotRunning()) {
        if (!addVmLease(newVmStatic.getLeaseStorageDomainId(), newVmStatic.getId())) {
            return false;
        }
    } else {
        if (oldVm.getLeaseStorageDomainId() == null) {
            VmLeaseParameters params = new VmLeaseParameters(getStoragePoolId(), newVmStatic.getLeaseStorageDomainId(), newVmStatic.getId());
            params.setVdsId(getVm().getRunOnVds());
            params.setHotPlugLease(true);
            return runInternalAction(ActionType.AddVmLease, params).getSucceeded();
        }
        boolean hotUnplugSucceeded = false;
        try {
            hotUnplugSucceeded = runVdsCommand(VDSCommandType.HotUnplugLease, new LeaseVDSParameters(getVm().getRunOnVds(), oldVm.getId(), oldVm.getLeaseStorageDomainId())).getSucceeded();
        } catch (EngineException e) {
            log.error("Failure in hot unplugging a lease to VM {}, message: {}", oldVm.getId(), e.getMessage());
        }
        if (!hotUnplugSucceeded) {
            auditLog(this, AuditLogType.HOT_UNPLUG_LEASE_FAILED);
        }
    }
    // best effort to remove the lease from the previous storage domain
    removeVmLease(oldVm.getLeaseStorageDomainId(), oldVm.getId());
    return true;
}
#end_block

#method_before
private void updateVmTemplateVersion() {
    if (getVm().getStatus() == VMStatus.Down) {
        VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.UpdateVmVersion, new UpdateVmVersionParameters(getVmId(), getParameters().getVm().getVmtGuid(), getParameters().getVm().isUseLatestVersion()), getLock());
        if (result.getSucceeded()) {
            getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
        }
        setSucceeded(result.getSucceeded());
        setActionReturnValue(VdcActionType.UpdateVmVersion);
    } else {
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContext());
        setSucceeded(true);
    }
}
#method_after
private void updateVmTemplateVersion() {
    if (getVm().getStatus() == VMStatus.Down) {
        VdcReturnValueBase result = runInternalActionWithTasksContext(ActionType.UpdateVmVersion, new UpdateVmVersionParameters(getVmId(), getParameters().getVm().getVmtGuid(), getParameters().getVm().isUseLatestVersion()), getLock());
        if (result.getSucceeded()) {
            getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
        }
        setSucceeded(result.getSucceeded());
        setActionReturnValue(ActionType.UpdateVmVersion);
    } else {
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContext());
        setSucceeded(true);
    }
}
#end_block

#method_before
private void updateRngDevice() {
    if (!getParameters().isUpdateRngDevice()) {
        return;
    }
    VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(getParameters().getVmId()));
    List<VmRngDevice> rngDevs = query.getReturnValue();
    VdcReturnValueBase rngCommandResult = null;
    if (rngDevs.isEmpty()) {
        if (getParameters().getRngDevice() != null) {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            rngCommandResult = runInternalAction(VdcActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
        }
    } else {
        if (getParameters().getRngDevice() == null) {
            RngDeviceParameters params = new RngDeviceParameters(rngDevs.get(0), true);
            rngCommandResult = runInternalAction(VdcActionType.RemoveRngDevice, params, cloneContextAndDetachFromParent());
        } else {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            params.getRngDevice().setDeviceId(rngDevs.get(0).getDeviceId());
            rngCommandResult = runInternalAction(VdcActionType.UpdateRngDevice, params, cloneContextAndDetachFromParent());
        }
    }
    if (rngCommandResult != null && !rngCommandResult.getSucceeded()) {
        log.error("Updating RNG device of VM {} ({}) failed. Old RNG device = {}. New RNG device = {}.", getVm().getName(), getVm().getId(), rngDevs.isEmpty() ? null : rngDevs.get(0), getParameters().getRngDevice());
    }
}
#method_after
private void updateRngDevice() {
    if (!getParameters().isUpdateRngDevice()) {
        return;
    }
    VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(getParameters().getVmId()));
    List<VmRngDevice> rngDevs = query.getReturnValue();
    VdcReturnValueBase rngCommandResult = null;
    if (rngDevs.isEmpty()) {
        if (getParameters().getRngDevice() != null) {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            rngCommandResult = runInternalAction(ActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
        }
    } else {
        if (getParameters().getRngDevice() == null) {
            RngDeviceParameters params = new RngDeviceParameters(rngDevs.get(0), true);
            rngCommandResult = runInternalAction(ActionType.RemoveRngDevice, params, cloneContextAndDetachFromParent());
        } else {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            params.getRngDevice().setDeviceId(rngDevs.get(0).getDeviceId());
            rngCommandResult = runInternalAction(ActionType.UpdateRngDevice, params, cloneContextAndDetachFromParent());
        }
    }
    if (rngCommandResult != null && !rngCommandResult.getSucceeded()) {
        log.error("Updating RNG device of VM {} ({}) failed. Old RNG device = {}. New RNG device = {}.", getVm().getName(), getVm().getId(), rngDevs.isEmpty() ? null : rngDevs.get(0), getParameters().getRngDevice());
    }
}
#end_block

#method_before
private void hotSetCpus(VM newVm) {
    int currentSockets = getVm().getNumOfSockets();
    int newNumOfSockets = newVm.getNumOfSockets();
    // try hotplug only if topology (cpuPerSocket, threadsPerCpu) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && VmCommonUtils.isCpusToBeHotplugged(getVm(), newVm)) {
        HotSetNumberOfCpusParameters params = new HotSetNumberOfCpusParameters(newVmStatic, currentSockets < newNumOfSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        setNumberOfCpusResult = runInternalAction(VdcActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        // into the OVF store and automatically used during the next HE VM start
        if (!getVm().isHostedEngine()) {
            newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newNumOfSockets : currentSockets);
        }
        hotSetCpusLog(params);
    }
}
#method_after
private void hotSetCpus(VM newVm) {
    int currentSockets = getVm().getNumOfSockets();
    int newNumOfSockets = newVm.getNumOfSockets();
    // try hotplug only if topology (cpuPerSocket, threadsPerCpu) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && VmCommonUtils.isCpusToBeHotplugged(getVm(), newVm)) {
        HotSetNumberOfCpusParameters params = new HotSetNumberOfCpusParameters(newVmStatic, currentSockets < newNumOfSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        VdcReturnValueBase setNumberOfCpusResult = runInternalAction(ActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        // into the OVF store and automatically used during the next HE VM start
        if (!getVm().isHostedEngine()) {
            newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newNumOfSockets : currentSockets);
        }
        logHotSetActionEvent(setNumberOfCpusResult, AuditLogType.FAILED_HOT_SET_NUMBER_OF_CPUS);
    }
}
#end_block

#method_before
private void updateCurrentMemory(VM newVm) {
    int currentMemory = getVm().getMemSizeMb();
    int newAmountOfMemory = newVm.getMemSizeMb();
    if (getVm().getStatus().isNotRunning()) {
        newVmStatic.setMemSizeMb(newAmountOfMemory);
        return;
    }
    if (getVm().getStatus() != VMStatus.Up) {
        newVmStatic.setMemSizeMb(currentMemory);
        log.warn("Memory update {}MB -> {}MB of VM {} ({}) left out. Memory can't be updated in current VM state ({}).", currentMemory, newAmountOfMemory, getVm().getName(), getVm().getId(), getVm().getStatus());
        return;
    }
    if (VmCommonUtils.isMemoryToBeHotplugged(getVm(), newVm)) {
        hotSetMemory(currentMemory, newAmountOfMemory);
    }
}
#method_after
private void updateCurrentMemory(VM newVm) {
    int currentMemory = getVm().getMemSizeMb();
    int newAmountOfMemory = newVm.getMemSizeMb();
    if (getVm().getStatus().isNotRunning()) {
        newVmStatic.setMemSizeMb(newAmountOfMemory);
        return;
    }
    if (getVm().getStatus() != VMStatus.Up) {
        newVmStatic.setMemSizeMb(currentMemory);
        log.warn("Memory update {}MB -> {}MB of VM {} ({}) left out. Memory can't be updated in current VM state ({}).", currentMemory, newAmountOfMemory, getVm().getName(), getVm().getId(), getVm().getStatus());
        return;
    }
    if (!VmCommonUtils.isMemoryToBeHotplugged(getVm(), newVm)) {
        return;
    }
    final int memoryAddedMb = newAmountOfMemory - currentMemory;
    final int factor = Config.<Integer>getValue(ConfigValues.HotPlugMemoryBlockSizeMb);
    final boolean memoryDividable = memoryAddedMb % factor == 0;
    if (!memoryDividable) {
        addCustomValue("memoryAdded", String.valueOf(memoryAddedMb));
        addCustomValue("requiredFactor", String.valueOf(factor));
        auditLogDirector.log(this, AuditLogType.FAILED_HOT_SET_MEMORY_NOT_DIVIDABLE);
        newVmStatic.setMemSizeMb(currentMemory);
        return;
    }
    hotSetMemory(currentMemory, newAmountOfMemory);
}
#end_block

#method_before
private void hotSetMemory(int currentMemory, int newAmountOfMemory) {
    HotSetAmountOfMemoryParameters params = new HotSetAmountOfMemoryParameters(newVmStatic, currentMemory < newAmountOfMemory ? PlugAction.PLUG : PlugAction.UNPLUG, // We always use node 0, auto-numa should handle the allocation
    0);
    VdcReturnValueBase setAmountOfMemoryResult = runInternalAction(VdcActionType.HotSetAmountOfMemory, params, cloneContextAndDetachFromParent());
    // into the OVF store and automatically used during the next HE VM start
    if (!getVm().isHostedEngine()) {
        newVmStatic.setMemSizeMb(setAmountOfMemoryResult.getSucceeded() ? newAmountOfMemory : currentMemory);
    }
    hotSetMemlog(params, setAmountOfMemoryResult);
}
#method_after
private void hotSetMemory(int currentMemoryMb, int newAmountOfMemoryMb) {
    final int minimalHotPlugDeviceSizeMb = getVm().getClusterArch().getHotplugMemorySizeFactorMb();
    final List<VmDevice> memoryDevices = getVmDeviceUtils().getMemoryDevices(getVmId());
    final boolean minimalMemoryDevicePresent = memoryDevices.stream().anyMatch(device -> VmDeviceCommonUtils.getSizeOfMemoryDeviceMb(device).map(size -> size == minimalHotPlugDeviceSizeMb).orElse(false));
    final int secondPartSizeMb = (newAmountOfMemoryMb - currentMemoryMb) - minimalHotPlugDeviceSizeMb;
    if (minimalMemoryDevicePresent || secondPartSizeMb == 0) {
        hotPlugMemoryDevice(currentMemoryMb, newAmountOfMemoryMb);
        return;
    }
    hotPlugMemoryDevice(currentMemoryMb, currentMemoryMb + minimalHotPlugDeviceSizeMb);
    hotPlugMemoryDevice(currentMemoryMb + minimalHotPlugDeviceSizeMb, newAmountOfMemoryMb);
}
#end_block

#method_before
private void updateWatchdog() {
    // do not update if this flag is not set
    if (getParameters().isUpdateWatchdog()) {
        VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getParameters().getVmId()));
        List<VmWatchdog> watchdogs = query.getReturnValue();
        if (watchdogs.isEmpty()) {
            if (getParameters().getWatchdog() == null) {
            // nothing to do, no watchdog and no watchdog to create
            } else {
                WatchdogParameters parameters = new WatchdogParameters();
                parameters.setId(getParameters().getVmId());
                parameters.setAction(getParameters().getWatchdog().getAction());
                parameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(VdcActionType.AddWatchdog, parameters, cloneContextAndDetachFromParent());
            }
        } else {
            WatchdogParameters watchdogParameters = new WatchdogParameters();
            watchdogParameters.setId(getParameters().getVmId());
            if (getParameters().getWatchdog() == null) {
                // there is a watchdog in the vm, there should not be any, so let's delete
                runInternalAction(VdcActionType.RemoveWatchdog, watchdogParameters, cloneContextAndDetachFromParent());
            } else {
                // there is a watchdog in the vm, we have to update.
                watchdogParameters.setAction(getParameters().getWatchdog().getAction());
                watchdogParameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(VdcActionType.UpdateWatchdog, watchdogParameters, cloneContextAndDetachFromParent());
            }
        }
    }
}
#method_after
private void updateWatchdog() {
    // do not update if this flag is not set
    if (getParameters().isUpdateWatchdog()) {
        VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getParameters().getVmId()));
        List<VmWatchdog> watchdogs = query.getReturnValue();
        if (watchdogs.isEmpty()) {
            if (getParameters().getWatchdog() == null) {
            // nothing to do, no watchdog and no watchdog to create
            } else {
                WatchdogParameters parameters = new WatchdogParameters();
                parameters.setId(getParameters().getVmId());
                parameters.setAction(getParameters().getWatchdog().getAction());
                parameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(ActionType.AddWatchdog, parameters, cloneContextAndDetachFromParent());
            }
        } else {
            WatchdogParameters watchdogParameters = new WatchdogParameters();
            watchdogParameters.setId(getParameters().getVmId());
            if (getParameters().getWatchdog() == null) {
                // there is a watchdog in the vm, there should not be any, so let's delete
                runInternalAction(ActionType.RemoveWatchdog, watchdogParameters, cloneContextAndDetachFromParent());
            } else {
                // there is a watchdog in the vm, we have to update.
                watchdogParameters.setAction(getParameters().getWatchdog().getAction());
                watchdogParameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(ActionType.UpdateWatchdog, watchdogParameters, cloneContextAndDetachFromParent());
            }
        }
    }
}
#end_block

#method_before
private void removeGraphicsDevice(GraphicsType type) {
    GraphicsDevice existingGraphicsDevice = getGraphicsDevOfType(type);
    if (existingGraphicsDevice != null) {
        getBackend().runInternalAction(VdcActionType.RemoveGraphicsDevice, new GraphicsParameters(existingGraphicsDevice));
    }
}
#method_after
private void removeGraphicsDevice(GraphicsType type) {
    GraphicsDevice existingGraphicsDevice = getGraphicsDevOfType(type);
    if (existingGraphicsDevice != null) {
        getBackend().runInternalAction(ActionType.RemoveGraphicsDevice, new GraphicsParameters(existingGraphicsDevice));
    }
}
#end_block

#method_before
private void addOrUpdateGraphicsDevice(GraphicsDevice device) {
    GraphicsDevice existingGraphicsDevice = getGraphicsDevOfType(device.getGraphicsType());
    device.setVmId(getVmId());
    getBackend().runInternalAction(existingGraphicsDevice == null ? VdcActionType.AddGraphicsDevice : VdcActionType.UpdateGraphicsDevice, new GraphicsParameters(device));
}
#method_after
private void addOrUpdateGraphicsDevice(GraphicsDevice device) {
    GraphicsDevice existingGraphicsDevice = getGraphicsDevOfType(device.getGraphicsType());
    device.setVmId(getVmId());
    getBackend().runInternalAction(existingGraphicsDevice == null ? ActionType.AddGraphicsDevice : ActionType.UpdateGraphicsDevice, new GraphicsParameters(device));
}
#end_block

#method_before
private void updateVmNumaNodes() {
    if (!getParameters().isUpdateNuma()) {
        return;
    }
    List<VmNumaNode> newList = getParameters().getVmStaticData().getvNumaNodeList();
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getParameters().getVm(), new ArrayList<>(newList));
    addLogMessages(getBackend().runInternalAction(VdcActionType.SetVmNumaNodes, params));
}
#method_after
private void updateVmNumaNodes() {
    if (!getParameters().isUpdateNuma()) {
        return;
    }
    List<VmNumaNode> newList = getParameters().getVmStaticData().getvNumaNodeList();
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getParameters().getVm(), new ArrayList<>(newList));
    addLogMessages(getBackend().runInternalAction(ActionType.SetVmNumaNodes, params));
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmHandler.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!getParameters().getVmStaticData().isAutoStartup()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED_WITH_HA_OFF);
        }
        if (!FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED);
        }
        if (!validateLeaseStorageDomain(getParameters().getVmStaticData().getLeaseStorageDomainId())) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmHandler.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!canAddLease()) {
            return false;
        }
        if (!getVm().isDown() && getParameters().getVmStaticData().getLeaseStorageDomainId() != null && getVm().getLeaseStorageDomainId() != null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOT_SWAPPING_VM_LEASES_NOT_SUPPORTED);
        }
    }
    return true;
}
#end_block

#method_before
@Override
public void setEntityId(AuditLogableBase logable) {
    logable.setVmId(oldVm.getId());
}
#method_after
@Override
public void setEntityId(AuditLogable logable) {
    logable.setVmId(oldVm.getId());
}
#end_block

#method_before
private void updateAffinityLabels() {
    List<Label> selectedLabels = getParameters().getAffinityLabels();
    List<Label> previouslySelectedLabels = labelDao.getAllByEntityIds(Collections.singletonList(getVmId()));
    // Add VM to newly selected labels
    Set<Label> labelsToAdd = new HashSet<>(selectedLabels);
    labelsToAdd.removeAll(previouslySelectedLabels);
    for (Label label : labelsToAdd) {
        label.addVm(getVm());
        labelDao.update(label);
    }
    // Remove VM from deselected labels
    Set<Label> labelsToRemove = new HashSet<>(previouslySelectedLabels);
    labelsToRemove.removeAll(selectedLabels);
    for (Label label : labelsToRemove) {
        label.removeVm(getVm());
        labelDao.update(label);
    }
}
#method_after
private void updateAffinityLabels() {
    List<Label> affinityLabels = getParameters().getAffinityLabels();
    List<Guid> labelIds = affinityLabels.stream().map(Label::getId).collect(Collectors.toList());
    labelDao.updateLabelsForVm(getVmId(), labelIds);
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    if (!isDisksVolumeFormatValid()) {
        return false;
    }
    Version customCompatibilityVersionFromParams = getParameters().getVmStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // check if the OS type is supported
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!validate(VmValidator.validateCpuSockets(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && vmStaticDao.get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!getParameters().getVmStaticData().isAutoStartup()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED_WITH_HA_OFF);
        }
        if (!FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED);
        }
        if (!validateLeaseStorageDomain(getParameters().getVmStaticData().getLeaseStorageDomainId())) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    if (!isDisksVolumeFormatValid()) {
        return false;
    }
    Version customCompatibilityVersionFromParams = getParameters().getVmStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // check if the OS type is supported
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!validate(VmValidator.validateCpuSockets(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && vmStaticDao.get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData()) && !canAddLease()) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean checkTemplateImages(List<String> reasons) {
    if (getParameters().getParentCommand() == VdcActionType.AddVmPool) {
        return true;
    }
    for (StorageDomain storage : destStorages.values()) {
        if (!validate(vmTemplateHandler.isVmTemplateImagesReady(vmDisksSource, storage.getId(), false, false, true, true, storageToDisksMap.get(storage.getId())))) {
            return false;
        }
    }
    return true;
}
#method_after
protected boolean checkTemplateImages(List<String> reasons) {
    if (getParameters().getParentCommand() == ActionType.AddVmPool) {
        return true;
    }
    for (StorageDomain storage : destStorages.values()) {
        if (!validate(vmTemplateHandler.isVmTemplateImagesReady(vmDisksSource, storage.getId(), false, false, true, true, storageToDisksMap.get(storage.getId())))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private DiskImage makeNewImage(Guid storageId, DiskImage image) {
    DiskImage newImage = new DiskImage();
    newImage.setImageId(image.getImageId());
    newImage.setDiskAlias(image.getDiskAlias());
    newImage.setVolumeFormat(image.getVolumeFormat());
    newImage.setVolumeType(image.getVolumeType());
    ArrayList<Guid> storageIds = new ArrayList<>();
    storageIds.add(storageId);
    newImage.setStorageIds(storageIds);
    newImage.setQuotaId(image.getQuotaId());
    newImage.setDiskProfileId(image.getDiskProfileId());
    return newImage;
}
#method_after
private DiskImage makeNewImage(Guid storageId, DiskImage image) {
    DiskImage newImage = new DiskImage();
    newImage.setImageId(image.getImageId());
    newImage.setDiskAlias(image.getDiskAlias());
    newImage.setVolumeFormat(image.getVolumeFormat());
    newImage.setVolumeType(image.getVolumeType());
    ArrayList<Guid> storageIds = new ArrayList<>();
    storageIds.add(storageId);
    newImage.setStorageIds(storageIds);
    newImage.setQuotaId(image.getQuotaId());
    // Find out the correct disk profile for storage domain
    newImage.setDiskProfileId(diskProfileDao.getAllForStorageDomain(storageId).stream().filter(p -> image.getDiskProfileIds().contains(p.getId())).findFirst().map(p -> p.getId()).orElse(null));
    return newImage;
}
#end_block

#method_before
private void addGraphicsDevice() {
    for (GraphicsDevice graphicsDevice : getParameters().getGraphicsDevices().values()) {
        if (graphicsDevice == null) {
            continue;
        }
        graphicsDevice.setVmId(getVmId());
        getBackend().runInternalAction(VdcActionType.AddGraphicsDevice, new GraphicsParameters(graphicsDevice));
    }
}
#method_after
private void addGraphicsDevice() {
    for (GraphicsDevice graphicsDevice : getParameters().getGraphicsDevices().values()) {
        if (graphicsDevice == null) {
            continue;
        }
        graphicsDevice.setVmId(getVmId());
        getBackend().runInternalAction(ActionType.AddGraphicsDevice, new GraphicsParameters(graphicsDevice));
    }
}
#end_block

#method_before
private void addVmWatchdog() {
    VmWatchdog vmWatchdog = getParameters().getWatchdog();
    if (vmWatchdog != null) {
        VdcActionType actionType = getVmDeviceUtils().hasWatchdog(getVmTemplateId()) ? VdcActionType.UpdateWatchdog : VdcActionType.AddWatchdog;
        runInternalAction(actionType, buildWatchdogParameters(vmWatchdog), cloneContextAndDetachFromParent());
    }
}
#method_after
private void addVmWatchdog() {
    VmWatchdog vmWatchdog = getParameters().getWatchdog();
    if (vmWatchdog != null) {
        ActionType actionType = getVmDeviceUtils().hasWatchdog(getVmTemplateId()) ? ActionType.UpdateWatchdog : ActionType.AddWatchdog;
        runInternalAction(actionType, buildWatchdogParameters(vmWatchdog), cloneContextAndDetachFromParent());
    }
}
#end_block

#method_before
private void addVmRngDevice() {
    VmRngDevice rngDev = getParameters().getRngDevice();
    if (rngDev != null) {
        rngDev.setVmId(getVmId());
        RngDeviceParameters params = new RngDeviceParameters(rngDev, true);
        VdcReturnValueBase result = runInternalAction(VdcActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            log.error("Couldn't add RNG device for new VM.");
            throw new IllegalArgumentException("Couldn't add RNG device for new VM.");
        }
    }
}
#method_after
private void addVmRngDevice() {
    VmRngDevice rngDev = getParameters().getRngDevice();
    if (rngDev != null) {
        rngDev.setVmId(getVmId());
        RngDeviceParameters params = new RngDeviceParameters(rngDev, true);
        VdcReturnValueBase result = runInternalAction(ActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            log.error("Couldn't add RNG device for new VM.");
            throw new IllegalArgumentException("Couldn't add RNG device for new VM.");
        }
    }
}
#end_block

#method_before
private void copyDiskDevicesFromTemplate() {
    List<VmDevice> disks = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmDisksSource.getId(), VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName());
    getVmDeviceUtils().copyDiskDevices(getVmId(), disks, getSrcDeviceIdToTargetDeviceIdMapping());
}
#method_after
private void copyDiskDevicesFromTemplate() {
    List<VmDevice> disks = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmDisksSource.getId(), VmDeviceGeneralType.DISK, VmDeviceType.DISK);
    getVmDeviceUtils().copyDiskDevices(getVmId(), disks, getSrcDeviceIdToTargetDeviceIdMapping());
}
#end_block

#method_before
private void addVmNumaNodes() {
    List<VmNumaNode> numaNodes = getParameters().getVm().getvNumaNodeList();
    if (numaNodes.isEmpty()) {
        return;
    }
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getParameters().getVm(), numaNodes);
    VdcReturnValueBase returnValueBase = getBackend().runInternalAction(VdcActionType.AddVmNumaNodes, params);
    if (!returnValueBase.getSucceeded()) {
        auditLogDirector.log(this, AuditLogType.NUMA_ADD_VM_NUMA_NODE_FAILED);
    }
}
#method_after
private void addVmNumaNodes() {
    List<VmNumaNode> numaNodes = getParameters().getVm().getvNumaNodeList();
    if (numaNodes.isEmpty()) {
        return;
    }
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getParameters().getVm(), numaNodes);
    VdcReturnValueBase returnValueBase = getBackend().runInternalAction(ActionType.AddVmNumaNodes, params);
    if (!returnValueBase.getSucceeded()) {
        auditLogDirector.log(this, AuditLogType.NUMA_ADD_VM_NUMA_NODE_FAILED);
    }
}
#end_block

#method_before
private void addVmInit() {
    vmHandler.addVmInitToDB(getParameters().getVmStaticData());
}
#method_after
private void addVmInit() {
    final VmInit vmInit = getParameters().getVmStaticData().getVmInit();
    if (vmInit == null) {
        return;
    }
    if (vmInit.isPasswordAlreadyStored()) {
        final VmInit templateVmInit = vmInitDao.get(getVmTemplateId());
        vmInit.setPasswordAlreadyStored(false);
        vmInit.setRootPassword(templateVmInit.getRootPassword());
    }
    vmHandler.addVmInitToDB(getParameters().getVmStaticData());
}
#end_block

#method_before
protected VdcActionType getDiskCreationCommandType() {
    return VdcActionType.CreateSnapshotFromTemplate;
}
#method_after
protected ActionType getDiskCreationCommandType() {
    return ActionType.CreateSnapshotFromTemplate;
}
#end_block

#method_before
protected CreateSnapshotFromTemplateParameters buildDiskCreationParameters(DiskImage image) {
    CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(image.getImageId(), getParameters().getVmStaticData().getId());
    tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(image.getId()).getStorageIds().get(0));
    tempVar.setDiskAlias(diskInfoDestinationMap.get(image.getId()).getDiskAlias());
    tempVar.setStorageDomainId(image.getStorageIds().get(0));
    tempVar.setVmSnapshotId(getVmSnapshotId());
    tempVar.setParentCommand(VdcActionType.AddVm);
    tempVar.setEntityInfo(getParameters().getEntityInfo());
    tempVar.setParentParameters(getParameters());
    tempVar.setQuotaId(diskInfoDestinationMap.get(image.getId()).getQuotaId());
    tempVar.setDiskProfileId(diskInfoDestinationMap.get(image.getId()).getDiskProfileId());
    return tempVar;
}
#method_after
protected CreateSnapshotFromTemplateParameters buildDiskCreationParameters(DiskImage image) {
    CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(image.getImageId(), getParameters().getVmStaticData().getId());
    tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(image.getId()).getStorageIds().get(0));
    tempVar.setDiskAlias(diskInfoDestinationMap.get(image.getId()).getDiskAlias());
    tempVar.setStorageDomainId(image.getStorageIds().get(0));
    tempVar.setVmSnapshotId(getVmSnapshotId());
    tempVar.setParentCommand(ActionType.AddVm);
    tempVar.setEntityInfo(getParameters().getEntityInfo());
    tempVar.setParentParameters(getParameters());
    tempVar.setQuotaId(diskInfoDestinationMap.get(image.getId()).getQuotaId());
    tempVar.setDiskProfileId(diskInfoDestinationMap.get(image.getId()).getDiskProfileId());
    return tempVar;
}
#end_block

#method_before
protected void addVmCinderDisks(Collection<DiskImage> templateDisks) {
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(templateDisks);
    if (cinderDisks.isEmpty()) {
        return;
    }
    Map<Guid, Guid> diskImageMap = new HashMap<>();
    for (CinderDisk cinderDisk : cinderDisks) {
        ImagesContainterParametersBase params = buildCloneCinderDiskCommandParameters(cinderDisk);
        VdcReturnValueBase vdcReturnValueBase = runInternalAction(VdcActionType.CloneSingleCinderDisk, params, cloneContext().withoutExecutionContext().withoutLock());
        if (!vdcReturnValueBase.getSucceeded()) {
            log.error("Error cloning Cinder disk '{}': {}", cinderDisk.getDiskAlias());
            getReturnValue().setFault(vdcReturnValueBase.getFault());
            return;
        }
        Guid imageId = vdcReturnValueBase.getActionReturnValue();
        diskImageMap.put(cinderDisk.getId(), imageId);
    }
    srcDiskIdToTargetDiskIdMapping.putAll(diskImageMap);
}
#method_after
protected void addVmCinderDisks(Collection<DiskImage> templateDisks) {
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(templateDisks);
    if (cinderDisks.isEmpty()) {
        return;
    }
    Map<Guid, Guid> diskImageMap = new HashMap<>();
    for (CinderDisk cinderDisk : cinderDisks) {
        ImagesContainterParametersBase params = buildCloneCinderDiskCommandParameters(cinderDisk);
        VdcReturnValueBase vdcReturnValueBase = runInternalAction(ActionType.CloneSingleCinderDisk, params, cloneContext().withoutExecutionContext().withoutLock());
        if (!vdcReturnValueBase.getSucceeded()) {
            log.error("Error cloning Cinder disk '{}': {}", cinderDisk.getDiskAlias());
            getReturnValue().setFault(vdcReturnValueBase.getFault());
            return;
        }
        Guid imageId = vdcReturnValueBase.getActionReturnValue();
        diskImageMap.put(cinderDisk.getId(), imageId);
    }
    srcDiskIdToTargetDiskIdMapping.putAll(diskImageMap);
}
#end_block

#method_before
private void addVmToPool() {
    AddVmToPoolParameters parameters = new AddVmToPoolParameters(getParameters().getPoolId(), getVmId());
    parameters.setShouldBeLogged(false);
    VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.AddVmToPool, parameters);
    setSucceeded(result.getSucceeded());
    if (!result.getSucceeded()) {
        log.error("Error adding VM {} to Pool {}", getVmId(), getParameters().getPoolId());
        getReturnValue().setFault(result.getFault());
        return;
    }
    addVmPermission();
}
#method_after
private void addVmToPool() {
    AddVmToPoolParameters parameters = new AddVmToPoolParameters(getParameters().getPoolId(), getVmId());
    parameters.setShouldBeLogged(false);
    VdcReturnValueBase result = runInternalActionWithTasksContext(ActionType.AddVmToPool, parameters);
    setSucceeded(result.getSucceeded());
    if (!result.getSucceeded()) {
        log.error("Error adding VM {} to Pool {}", getVmId(), getParameters().getPoolId());
        getReturnValue().setFault(result.getFault());
        return;
    }
    addVmPermission();
}
#end_block

#method_before
@Override
protected VdcActionType getChildActionType() {
    return VdcActionType.CreateSnapshotFromTemplate;
}
#method_after
@Override
protected ActionType getChildActionType() {
    return ActionType.CreateSnapshotFromTemplate;
}
#end_block

#method_before
private void addAffinityLabels() {
    List<Label> affinityLabels = getParameters().getAffinityLabels();
    for (Label label : affinityLabels) {
        label.addVm(getVm());
        labelDao.update(label);
    }
}
#method_after
private void addAffinityLabels() {
    List<Label> affinityLabels = getParameters().getAffinityLabels();
    List<Guid> labelIds = affinityLabels.stream().map(Label::getId).collect(Collectors.toList());
    labelDao.addVmToLabels(getVmId(), labelIds);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.error("Failed to remove duplicated oVirt entry with id '{}'. Abort adding oVirt Host type", oVirtId);
            throw new EngineException(EngineError.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(() -> {
        addVdsStaticToDb();
        addVdsDynamicToDb();
        addVdsStatisticsToDb();
        addAffinityLabelsToDb();
        getCompensationContext().stateChanged();
        return null;
    });
    if (getParameters().isProvisioned()) {
        HostProviderProxy proxy = ProviderProxyFactory.getInstance().create(getHostProvider());
        proxy.provisionHost(getParameters().getvds(), getParameters().getHostGroup(), getParameters().getComputeResource(), getParameters().getHostMac(), getParameters().getDiscoverName(), getParameters().getPassword(), getParameters().getDiscoverIp());
        addCustomValue("HostGroupName", getParameters().getHostGroup().getName());
        auditLogDirector.log(this, AuditLogType.VDS_PROVISION);
    }
    // set vds spm id
    if (getCluster().getStoragePoolId() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, tempVar, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(() -> {
        initializeVds(true);
        alertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
        testVdsPowerManagementStatus(getParameters().getVdsStaticData());
        setSucceeded(true);
        setActionReturnValue(getVdsIdRef());
        // If the installation failed, we don't want to compensate for the failure since it will remove the
        // host, but instead the host should be left in an "install failed" status.
        getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
        return null;
    });
    // clients). they are installed as part of the approve process or automatically after provision
    if (Config.<Boolean>getValue(ConfigValues.InstallVds) && !getParameters().isPending() && !getParameters().isProvisioned()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        installVdsParameters.setAuthMethod(getParameters().getAuthMethod());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setActivateHost(getParameters().getActivateHost());
        installVdsParameters.setNetworkProviderId(getParameters().getVdsStaticData().getOpenstackNetworkProviderId());
        installVdsParameters.setNetworkMappings(getParameters().getNetworkMappings());
        installVdsParameters.setEnableSerialConsole(getParameters().getEnableSerialConsole());
        if (getParameters().getHostedEngineDeployConfiguration() != null) {
            Map<String, String> vdsDeployParams = hostedEngineHelper.createVdsDeployParams(getVdsId(), getParameters().getHostedEngineDeployConfiguration().getDeployAction());
            installVdsParameters.setHostedEngineConfiguration(vdsDeployParams);
        }
        Map<String, String> values = new HashMap<>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getName());
        Step installStep = executionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(() -> runInternalAction(VdcActionType.InstallVdsInternal, installVdsParameters, cloneContextAndDetachFromParent().withExecutionContext(installCtx)));
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#method_after
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.error("Failed to remove duplicated oVirt entry with id '{}'. Abort adding oVirt Host type", oVirtId);
            throw new EngineException(EngineError.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(() -> {
        addVdsStaticToDb();
        addVdsDynamicToDb();
        addVdsStatisticsToDb();
        addAffinityLabels();
        getCompensationContext().stateChanged();
        return null;
    });
    if (getParameters().isProvisioned()) {
        HostProviderProxy proxy = providerProxyFactory.create(getHostProvider());
        proxy.provisionHost(getParameters().getvds(), getParameters().getHostGroup(), getParameters().getComputeResource(), getParameters().getHostMac(), getParameters().getDiscoverName(), getParameters().getPassword(), getParameters().getDiscoverIp());
        addCustomValue("HostGroupName", getParameters().getHostGroup().getName());
        auditLogDirector.log(this, AuditLogType.VDS_PROVISION);
    }
    // set vds spm id
    if (getCluster().getStoragePoolId() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(ActionType.AddVdsSpmId, tempVar, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(() -> {
        initializeVds(true);
        alertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
        testVdsPowerManagementStatus(getParameters().getVdsStaticData());
        setSucceeded(true);
        setActionReturnValue(getVdsIdRef());
        // If the installation failed, we don't want to compensate for the failure since it will remove the
        // host, but instead the host should be left in an "install failed" status.
        getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
        return null;
    });
    // clients). they are installed as part of the approve process or automatically after provision
    if (Config.<Boolean>getValue(ConfigValues.InstallVds) && !getParameters().isPending() && !getParameters().isProvisioned()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        installVdsParameters.setAuthMethod(getParameters().getAuthMethod());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setActivateHost(getParameters().getActivateHost());
        installVdsParameters.setNetworkProviderId(getParameters().getVdsStaticData().getOpenstackNetworkProviderId());
        installVdsParameters.setNetworkMappings(getParameters().getNetworkMappings());
        installVdsParameters.setEnableSerialConsole(getParameters().getEnableSerialConsole());
        if (getParameters().getHostedEngineDeployConfiguration() != null) {
            Map<String, String> vdsDeployParams = hostedEngineHelper.createVdsDeployParams(getVdsId(), getParameters().getHostedEngineDeployConfiguration().getDeployAction());
            installVdsParameters.setHostedEngineConfiguration(vdsDeployParams);
        }
        Map<String, String> values = new HashMap<>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getName());
        Step installStep = executionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(() -> runInternalAction(ActionType.InstallVdsInternal, installVdsParameters, cloneContextAndDetachFromParent().withExecutionContext(installCtx)));
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#end_block

#method_before
private boolean removeDeprecatedOvirtEntry(final Guid oVirtId) {
    final VDS vds = vdsDao.get(oVirtId);
    if (vds == null || !VdsHandler.isPendingOvirt(vds)) {
        return false;
    }
    String vdsName = getParameters().getVdsStaticData().getName();
    log.info("Host '{}', id '{}' of type '{}' is being re-registered as Host '{}'", vds.getName(), vds.getId(), vds.getVdsType().name(), vdsName);
    VdcReturnValueBase result = TransactionSupport.executeInNewTransaction(() -> runInternalAction(VdcActionType.RemoveVds, new RemoveVdsParameters(oVirtId)));
    if (!result.getSucceeded()) {
        String errors = result.isValid() ? result.getFault().getError().name() : StringUtils.join(result.getValidationMessages(), ",");
        log.warn("Failed to remove Host '{}', id '{}', re-registering it as Host '{}' fails with errors {}", vds.getName(), vds.getId(), vdsName, errors);
    } else {
        log.info("Host '{}' is now known as Host '{}'", vds.getName(), vdsName);
    }
    return result.getSucceeded();
}
#method_after
private boolean removeDeprecatedOvirtEntry(final Guid oVirtId) {
    final VDS vds = vdsDao.get(oVirtId);
    if (vds == null || !VdsHandler.isPendingOvirt(vds)) {
        return false;
    }
    String vdsName = getParameters().getVdsStaticData().getName();
    log.info("Host '{}', id '{}' of type '{}' is being re-registered as Host '{}'", vds.getName(), vds.getId(), vds.getVdsType().name(), vdsName);
    VdcReturnValueBase result = TransactionSupport.executeInNewTransaction(() -> runInternalAction(ActionType.RemoveVds, new RemoveVdsParameters(oVirtId)));
    if (!result.getSucceeded()) {
        String errors = result.isValid() ? result.getFault().getError().name() : StringUtils.join(result.getValidationMessages(), ",");
        log.warn("Failed to remove Host '{}', id '{}', re-registering it as Host '{}' fails with errors {}", vds.getName(), vds.getId(), vdsName, errors);
    } else {
        log.info("Host '{}' is now known as Host '{}'", vds.getName(), vdsName);
    }
    return result.getSucceeded();
}
#end_block

#method_before
@Override
protected boolean validate() {
    T params = getParameters();
    setClusterId(params.getVdsStaticData().getClusterId());
    params.setVdsForUniqueId(null);
    // Check if this is a valid cluster
    boolean returnValue = validateCluster();
    if (returnValue) {
        HostValidator validator = getHostValidator();
        returnValue = validate(validator.nameNotEmpty()) && validate(validator.nameLengthIsLegal()) && validate(validator.hostNameIsValid()) && validate(validator.nameNotUsed()) && validate(validator.hostNameNotUsed()) && validate(validator.portIsValid()) && validate(validator.sshUserNameNotEmpty()) && validate(validator.validateSingleHostAttachedToLocalStorage()) && validate(validator.securityKeysExists()) && validate(validator.provisioningComputeResourceValid(params.isProvisioned(), params.getComputeResource())) && validate(validator.provisioningHostGroupValid(params.isProvisioned(), params.getHostGroup())) && validate(validator.passwordNotEmpty(params.isPending(), params.getAuthMethod(), params.getPassword())) && validate(validator.supportsDeployingHostedEngine(params.getHostedEngineDeployConfiguration()));
    }
    if (!(returnValue && isPowerManagementLegal(params.getVdsStaticData().isPmEnabled(), params.getFenceAgents(), getCluster().getCompatibilityVersion().toString()) && canConnect(params.getvds()))) {
        return false;
    }
    if (params.getVdsStaticData().getOpenstackNetworkProviderId() != null && !validateNetworkProviderProperties(params.getVdsStaticData().getOpenstackNetworkProviderId(), params.getNetworkMappings())) {
        return false;
    }
    if (isGlusterSupportEnabled() && clusterHasNonInitializingServers()) {
        // allow simultaneous installation of hosts, but if a host has completed install, only
        // allow addition of another host if it can be peer probed to cluster.
        VDS upServer = glusterUtil.getUpServer(getClusterId());
        if (upServer == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    T params = getParameters();
    setClusterId(params.getVdsStaticData().getClusterId());
    params.setVdsForUniqueId(null);
    // Check if this is a valid cluster
    boolean returnValue = validateCluster();
    if (returnValue) {
        HostValidator validator = getHostValidator();
        returnValue = validate(validator.nameNotEmpty()) && validate(validator.nameLengthIsLegal()) && validate(validator.hostNameIsValid()) && validate(validator.nameNotUsed()) && validate(validator.hostNameNotUsed()) && validate(validator.portIsValid()) && validate(validator.sshUserNameNotEmpty()) && validate(validator.validateSingleHostAttachedToLocalStorage()) && validate(validator.securityKeysExists()) && validate(validator.provisioningComputeResourceValid(params.isProvisioned(), params.getComputeResource())) && validate(validator.provisioningHostGroupValid(params.isProvisioned(), params.getHostGroup())) && validate(validator.passwordNotEmpty(params.isPending(), params.getAuthMethod(), params.getPassword())) && validate(validator.supportsDeployingHostedEngine(params.getHostedEngineDeployConfiguration()));
    }
    if (!(returnValue && isPowerManagementLegal(params.getVdsStaticData().isPmEnabled(), params.getFenceAgents(), getCluster().getCompatibilityVersion().toString()) && canConnect(params.getvds()))) {
        return false;
    }
    if (params.getVdsStaticData().getOpenstackNetworkProviderId() != null && !validateOpenstackNetworkProviderProperties(params.getVdsStaticData().getOpenstackNetworkProviderId(), params.getNetworkMappings())) {
        return false;
    }
    if (isGlusterSupportEnabled() && clusterHasNonInitializingServers()) {
        // allow simultaneous installation of hosts, but if a host has completed install, only
        // allow addition of another host if it can be peer probed to cluster.
        VDS upServer = glusterUtil.getUpServer(getClusterId());
        if (upServer == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
        }
    }
    return true;
}
#end_block

#method_before
private boolean validateNetworkProviderConfiguration() {
    return !getParameters().isInstallHost() || getParameters().getVdsStaticData().getOpenstackNetworkProviderId() == null || validateNetworkProviderProperties(getParameters().getVdsStaticData().getOpenstackNetworkProviderId(), getParameters().getNetworkMappings());
}
#method_after
private boolean validateNetworkProviderConfiguration() {
    return !getParameters().isInstallHost() || getParameters().getVdsStaticData().getOpenstackNetworkProviderId() == null || validateOpenstackNetworkProviderProperties(getParameters().getVdsStaticData().getOpenstackNetworkProviderId(), getParameters().getNetworkMappings());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    updateVdsData();
    if (needToUpdateVdsBroker()) {
        initializeVds();
    }
    if (getParameters().isInstallHost()) {
        InstallVdsParameters tempVar = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        tempVar.setIsReinstallOrUpgrade(getParameters().isReinstallOrUpgrade());
        tempVar.setoVirtIsoFile(getParameters().getoVirtIsoFile());
        if (vdsDynamicDao.get(getVdsId()).getStatus() == VDSStatus.InstallingOS) {
            // TODO: remove hack when reinstall api will provider override-firewall parameter.
            // https://bugzilla.redhat.com/show_bug.cgi?id=1177126 - for now we override firewall
            // configurations on each deploy for provisioned host to avoid wrong deployment.
            tempVar.setOverrideFirewall(true);
        } else {
            tempVar.setOverrideFirewall(getParameters().getOverrideFirewall());
        }
        tempVar.setOverrideFirewall(getParameters().getOverrideFirewall());
        tempVar.setActivateHost(getParameters().getActivateHost());
        tempVar.setNetworkProviderId(getParameters().getVdsStaticData().getOpenstackNetworkProviderId());
        tempVar.setNetworkMappings(getParameters().getNetworkMappings());
        tempVar.setAuthMethod(getParameters().getAuthMethod());
        if (getParameters().getHostedEngineDeployConfiguration() != null) {
            tempVar.setHostedEngineConfiguration(hostedEngineHelper.createVdsDeployParams(getVdsId(), getParameters().getHostedEngineDeployConfiguration().getDeployAction()));
        }
        ArrayList<VdcReturnValueBase> resultList = runInternalMultipleActions(actionType, new ArrayList<>(Arrays.asList(tempVar)));
        // status, therefore needed to fail the command to revert the status.
        if (!resultList.isEmpty()) {
            VdcReturnValueBase vdcReturnValueBase = resultList.get(0);
            if (vdcReturnValueBase != null && !vdcReturnValueBase.isValid()) {
                ArrayList<String> validationMessages = vdcReturnValueBase.getValidationMessages();
                if (!validationMessages.isEmpty()) {
                    // add can do action messages to return value so error messages
                    // are returned back to the client
                    getReturnValue().getValidationMessages().addAll(validationMessages);
                    log.error("Installation/upgrade of Host '{}', '{}' failed: {}", getVdsId(), getVdsName(), StringUtils.join(Backend.getInstance().getErrorsTranslator().translateErrorText(validationMessages), ","));
                }
                // set can do action to false so can do action messages are
                // returned back to client
                getReturnValue().setValid(false);
                setSucceeded(false);
                // add old vds dynamic data to compensation context. This
                // way the status will revert back to what it was before
                // starting installation process
                getCompensationContext().snapshotEntityStatus(oldHost.getDynamicData());
                getCompensationContext().stateChanged();
                return;
            }
        }
    }
    // set clusters network to be operational (if needed)
    if (oldHost.getStatus() == VDSStatus.Up) {
        List<Network> networks = networkDao.getAllForCluster(oldHost.getClusterId());
        networkClusterHelper.setStatus(oldHost.getClusterId(), networks);
    }
    alertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
    testVdsPowerManagementStatus(getParameters().getVdsStaticData());
    checkKdumpIntegrationStatus();
    updateAffinityLabels();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    updateVdsData();
    if (needToUpdateVdsBroker()) {
        initializeVds();
    }
    if (getParameters().isInstallHost()) {
        InstallVdsParameters tempVar = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        tempVar.setIsReinstallOrUpgrade(getParameters().isReinstallOrUpgrade());
        tempVar.setoVirtIsoFile(getParameters().getoVirtIsoFile());
        if (vdsDynamicDao.get(getVdsId()).getStatus() == VDSStatus.InstallingOS) {
            // TODO: remove hack when reinstall api will provider override-firewall parameter.
            // https://bugzilla.redhat.com/show_bug.cgi?id=1177126 - for now we override firewall
            // configurations on each deploy for provisioned host to avoid wrong deployment.
            tempVar.setOverrideFirewall(true);
        } else {
            tempVar.setOverrideFirewall(getParameters().getOverrideFirewall());
        }
        tempVar.setOverrideFirewall(getParameters().getOverrideFirewall());
        tempVar.setActivateHost(getParameters().getActivateHost());
        tempVar.setNetworkProviderId(getParameters().getVdsStaticData().getOpenstackNetworkProviderId());
        tempVar.setNetworkMappings(getParameters().getNetworkMappings());
        tempVar.setAuthMethod(getParameters().getAuthMethod());
        if (getParameters().getHostedEngineDeployConfiguration() != null) {
            tempVar.setHostedEngineConfiguration(hostedEngineHelper.createVdsDeployParams(getVdsId(), getParameters().getHostedEngineDeployConfiguration().getDeployAction()));
        }
        List<VdcReturnValueBase> resultList = runInternalMultipleActions(actionType, new ArrayList<>(Arrays.asList(tempVar)));
        // status, therefore needed to fail the command to revert the status.
        if (!resultList.isEmpty()) {
            VdcReturnValueBase vdcReturnValueBase = resultList.get(0);
            if (vdcReturnValueBase != null && !vdcReturnValueBase.isValid()) {
                List<String> validationMessages = vdcReturnValueBase.getValidationMessages();
                if (!validationMessages.isEmpty()) {
                    // add can do action messages to return value so error messages
                    // are returned back to the client
                    getReturnValue().getValidationMessages().addAll(validationMessages);
                    log.error("Installation/upgrade of Host '{}', '{}' failed: {}", getVdsId(), getVdsName(), StringUtils.join(Backend.getInstance().getErrorsTranslator().translateErrorText(validationMessages), ","));
                }
                // set can do action to false so can do action messages are
                // returned back to client
                getReturnValue().setValid(false);
                setSucceeded(false);
                // add old vds dynamic data to compensation context. This
                // way the status will revert back to what it was before
                // starting installation process
                getCompensationContext().snapshotEntityStatus(oldHost.getDynamicData());
                getCompensationContext().stateChanged();
                return;
            }
        }
    }
    // set clusters network to be operational (if needed)
    if (oldHost.getStatus() == VDSStatus.Up) {
        List<Network> networks = networkDao.getAllForCluster(oldHost.getClusterId());
        networkClusterHelper.setStatus(oldHost.getClusterId(), networks);
    }
    alertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
    testVdsPowerManagementStatus(getParameters().getVdsStaticData());
    checkKdumpIntegrationStatus();
    updateAffinityLabels();
    setSucceeded(true);
}
#end_block

#method_before
@Override
public void setEntityId(AuditLogableBase logable) {
    logable.setVdsId(oldHost.getId());
}
#method_after
@Override
public void setEntityId(AuditLogable logable) {
    logable.setVdsId(oldHost.getId());
}
#end_block

#method_before
private void checkKdumpIntegrationStatus() {
    VdsStatic vdsSt = getParameters().getVdsStaticData();
    if (vdsSt.isPmEnabled() && vdsSt.isPmKdumpDetection()) {
        VdsDynamic vdsDyn = vdsDynamicDao.get(vdsSt.getId());
        if (vdsDyn != null && vdsDyn.getKdumpStatus() != KdumpStatus.ENABLED) {
            auditLogDirector.log(Injector.injectMembers(new AuditLogableBase(vdsSt.getId())), AuditLogType.KDUMP_DETECTION_NOT_CONFIGURED_ON_VDS);
        }
    }
}
#method_after
private void checkKdumpIntegrationStatus() {
    VdsStatic vdsSt = getParameters().getVdsStaticData();
    if (vdsSt.isPmEnabled() && vdsSt.isPmKdumpDetection()) {
        VdsDynamic vdsDyn = vdsDynamicDao.get(vdsSt.getId());
        if (vdsDyn != null && vdsDyn.getKdumpStatus() != KdumpStatus.ENABLED) {
            AuditLogable logable = new AuditLogableImpl();
            logable.setVdsId(vdsSt.getId());
            logable.setVdsName(vdsSt.getName());
            auditLogDirector.log(logable, AuditLogType.KDUMP_DETECTION_NOT_CONFIGURED_ON_VDS);
        }
    }
}
#end_block

#method_before
private void updateAffinityLabels() {
    List<Label> selectedLabels = getParameters().getAffinityLabels();
    List<Label> previouslySelectedLabels = labelDao.getAllByEntityIds(Collections.singletonList(getVdsId()));
    // Add host to newly selected labels
    Set<Label> labelsToAdd = new HashSet<>(selectedLabels);
    labelsToAdd.removeAll(previouslySelectedLabels);
    for (Label label : labelsToAdd) {
        label.addHost(getVds());
        labelDao.update(label);
    }
    // Remove host from deselected labels
    Set<Label> labelsToRemove = new HashSet<>(previouslySelectedLabels);
    labelsToRemove.removeAll(selectedLabels);
    for (Label label : labelsToRemove) {
        label.removeHost(getVds());
        labelDao.update(label);
    }
}
#method_after
private void updateAffinityLabels() {
    List<Label> affinityLabels = getParameters().getAffinityLabels();
    List<Guid> labelIds = affinityLabels.stream().map(Label::getId).collect(Collectors.toList());
    labelDao.updateLabelsForHost(getVdsId(), labelIds);
}
#end_block

#method_before
public void init(M model) {
    this.model = model;
    itemListPanel.add(itemList);
    itemList.addStyleName(Styles.LIST_INLINE);
    itemListLabel.addStyleName(Styles.FORM_GROUP);
    createItems();
}
#method_after
public void init(M model) {
    this.model = model;
    itemList.addStyleName(Styles.LIST_INLINE);
    createItems();
}
#end_block

#method_before
public void init() {
    createEditor();
    filterListEditor.hideLabel();
    initWidget(ViewUiBinder.uiBinder.createAndBindUi(this));
}
#method_after
public void init() {
    filterListEditor = createFilterListEditor();
    filterListEditor.hideLabel();
    initWidget(ViewUiBinder.uiBinder.createAndBindUi(this));
    addSelectedItemButton.addStyleName(Styles.PULL_RIGHT);
}
#end_block

#method_before
protected String typeAheadNameTemplateNullSafe(String name) {
    if (name != null && !name.trim().isEmpty()) {
        return templates.typeAheadName(name).asString();
    } else {
        return templates.typeAheadEmptyContent().asString();
    }
}
#method_after
protected String typeAheadNameTemplateNullSafe(String name) {
    if (StringUtils.isNotEmpty(name)) {
        return templates.typeAheadName(name).asString();
    } else {
        return templates.typeAheadEmptyContent().asString();
    }
}
#end_block

#method_before
private void addLabelSpan(String itemText) {
    Span labelSpan = new Span();
    labelSpan.addStyleName(Styles.LABEL);
    // $NON-NLS-1$
    labelSpan.addStyleName("label-info");
    labelSpan.setText(itemText);
    add(labelSpan);
}
#method_after
private void addLabelSpan(String itemText) {
    Span labelSpan = new Span();
    labelSpan.addStyleName(Styles.LABEL);
    labelSpan.addStyleName(PatternflyConstants.PF_LABEL_INFO);
    labelSpan.setText(itemText);
    add(labelSpan);
}
#end_block

#method_before
private void addDeactivationAnchor() {
    Span closeIconSpan = new Span();
    // $NON-NLS-1$
    closeIconSpan.addStyleName("pficon");
    // $NON-NLS-1$
    closeIconSpan.addStyleName("pficon-close");
    deactivationAnchor.add(closeIconSpan);
    add(deactivationAnchor);
}
#method_after
private void addDeactivationAnchor() {
    Span closeIconSpan = new Span();
    closeIconSpan.addStyleName(PatternflyConstants.PFICON);
    closeIconSpan.addStyleName(PatternflyConstants.PFICON_CLOSE);
    deactivationAnchor.add(closeIconSpan);
    add(deactivationAnchor);
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    if (!isDisksVolumeFormatValid()) {
        return false;
    }
    Version customCompatibilityVersionFromParams = getParameters().getVmStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // check if the OS type is supported
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!validate(VmValidator.validateCpuSockets(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && vmStaticDao.get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!getParameters().getVmStaticData().isAutoStartup()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED_WITH_HA_OFF);
        }
        if (!FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED);
        }
        if (!validateLeaseStorageDomain(getParameters().getVmStaticData().getLeaseStorageDomainId())) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    if (!isDisksVolumeFormatValid()) {
        return false;
    }
    Version customCompatibilityVersionFromParams = getParameters().getVmStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // check if the OS type is supported
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!validate(VmValidator.validateCpuSockets(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && vmStaticDao.get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData()) && !canAddLease()) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean checkTemplateImages(List<String> reasons) {
    if (getParameters().getParentCommand() == VdcActionType.AddVmPool) {
        return true;
    }
    for (StorageDomain storage : destStorages.values()) {
        if (!validate(vmTemplateHandler.isVmTemplateImagesReady(vmDisksSource, storage.getId(), false, false, true, true, storageToDisksMap.get(storage.getId())))) {
            return false;
        }
    }
    return true;
}
#method_after
protected boolean checkTemplateImages(List<String> reasons) {
    if (getParameters().getParentCommand() == ActionType.AddVmPool) {
        return true;
    }
    for (StorageDomain storage : destStorages.values()) {
        if (!validate(vmTemplateHandler.isVmTemplateImagesReady(vmDisksSource, storage.getId(), false, false, true, true, storageToDisksMap.get(storage.getId())))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void addGraphicsDevice() {
    for (GraphicsDevice graphicsDevice : getParameters().getGraphicsDevices().values()) {
        if (graphicsDevice == null) {
            continue;
        }
        graphicsDevice.setVmId(getVmId());
        getBackend().runInternalAction(VdcActionType.AddGraphicsDevice, new GraphicsParameters(graphicsDevice));
    }
}
#method_after
private void addGraphicsDevice() {
    for (GraphicsDevice graphicsDevice : getParameters().getGraphicsDevices().values()) {
        if (graphicsDevice == null) {
            continue;
        }
        graphicsDevice.setVmId(getVmId());
        getBackend().runInternalAction(ActionType.AddGraphicsDevice, new GraphicsParameters(graphicsDevice));
    }
}
#end_block

#method_before
private void addVmWatchdog() {
    VmWatchdog vmWatchdog = getParameters().getWatchdog();
    if (vmWatchdog != null) {
        VdcActionType actionType = getVmDeviceUtils().hasWatchdog(getVmTemplateId()) ? VdcActionType.UpdateWatchdog : VdcActionType.AddWatchdog;
        runInternalAction(actionType, buildWatchdogParameters(vmWatchdog), cloneContextAndDetachFromParent());
    }
}
#method_after
private void addVmWatchdog() {
    VmWatchdog vmWatchdog = getParameters().getWatchdog();
    if (vmWatchdog != null) {
        ActionType actionType = getVmDeviceUtils().hasWatchdog(getVmTemplateId()) ? ActionType.UpdateWatchdog : ActionType.AddWatchdog;
        runInternalAction(actionType, buildWatchdogParameters(vmWatchdog), cloneContextAndDetachFromParent());
    }
}
#end_block

#method_before
private void addVmRngDevice() {
    VmRngDevice rngDev = getParameters().getRngDevice();
    if (rngDev != null) {
        rngDev.setVmId(getVmId());
        RngDeviceParameters params = new RngDeviceParameters(rngDev, true);
        VdcReturnValueBase result = runInternalAction(VdcActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            log.error("Couldn't add RNG device for new VM.");
            throw new IllegalArgumentException("Couldn't add RNG device for new VM.");
        }
    }
}
#method_after
private void addVmRngDevice() {
    VmRngDevice rngDev = getParameters().getRngDevice();
    if (rngDev != null) {
        rngDev.setVmId(getVmId());
        RngDeviceParameters params = new RngDeviceParameters(rngDev, true);
        VdcReturnValueBase result = runInternalAction(ActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            log.error("Couldn't add RNG device for new VM.");
            throw new IllegalArgumentException("Couldn't add RNG device for new VM.");
        }
    }
}
#end_block

#method_before
private void addVmNumaNodes() {
    List<VmNumaNode> numaNodes = getParameters().getVm().getvNumaNodeList();
    if (numaNodes.isEmpty()) {
        return;
    }
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getParameters().getVm(), numaNodes);
    VdcReturnValueBase returnValueBase = getBackend().runInternalAction(VdcActionType.AddVmNumaNodes, params);
    if (!returnValueBase.getSucceeded()) {
        auditLogDirector.log(this, AuditLogType.NUMA_ADD_VM_NUMA_NODE_FAILED);
    }
}
#method_after
private void addVmNumaNodes() {
    List<VmNumaNode> numaNodes = getParameters().getVm().getvNumaNodeList();
    if (numaNodes.isEmpty()) {
        return;
    }
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getParameters().getVm(), numaNodes);
    VdcReturnValueBase returnValueBase = getBackend().runInternalAction(ActionType.AddVmNumaNodes, params);
    if (!returnValueBase.getSucceeded()) {
        auditLogDirector.log(this, AuditLogType.NUMA_ADD_VM_NUMA_NODE_FAILED);
    }
}
#end_block

#method_before
protected VdcActionType getDiskCreationCommandType() {
    return VdcActionType.CreateSnapshotFromTemplate;
}
#method_after
protected ActionType getDiskCreationCommandType() {
    return ActionType.CreateSnapshotFromTemplate;
}
#end_block

#method_before
protected CreateSnapshotFromTemplateParameters buildDiskCreationParameters(DiskImage image) {
    CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(image.getImageId(), getParameters().getVmStaticData().getId());
    tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(image.getId()).getStorageIds().get(0));
    tempVar.setDiskAlias(diskInfoDestinationMap.get(image.getId()).getDiskAlias());
    tempVar.setStorageDomainId(image.getStorageIds().get(0));
    tempVar.setVmSnapshotId(getVmSnapshotId());
    tempVar.setParentCommand(VdcActionType.AddVm);
    tempVar.setEntityInfo(getParameters().getEntityInfo());
    tempVar.setParentParameters(getParameters());
    tempVar.setQuotaId(diskInfoDestinationMap.get(image.getId()).getQuotaId());
    tempVar.setDiskProfileId(diskInfoDestinationMap.get(image.getId()).getDiskProfileId());
    return tempVar;
}
#method_after
protected CreateSnapshotFromTemplateParameters buildDiskCreationParameters(DiskImage image) {
    CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(image.getImageId(), getParameters().getVmStaticData().getId());
    tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(image.getId()).getStorageIds().get(0));
    tempVar.setDiskAlias(diskInfoDestinationMap.get(image.getId()).getDiskAlias());
    tempVar.setStorageDomainId(image.getStorageIds().get(0));
    tempVar.setVmSnapshotId(getVmSnapshotId());
    tempVar.setParentCommand(ActionType.AddVm);
    tempVar.setEntityInfo(getParameters().getEntityInfo());
    tempVar.setParentParameters(getParameters());
    tempVar.setQuotaId(diskInfoDestinationMap.get(image.getId()).getQuotaId());
    tempVar.setDiskProfileId(diskInfoDestinationMap.get(image.getId()).getDiskProfileId());
    return tempVar;
}
#end_block

#method_before
protected void addVmCinderDisks(Collection<DiskImage> templateDisks) {
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(templateDisks);
    if (cinderDisks.isEmpty()) {
        return;
    }
    Map<Guid, Guid> diskImageMap = new HashMap<>();
    for (CinderDisk cinderDisk : cinderDisks) {
        ImagesContainterParametersBase params = buildCloneCinderDiskCommandParameters(cinderDisk);
        VdcReturnValueBase vdcReturnValueBase = runInternalAction(VdcActionType.CloneSingleCinderDisk, params, cloneContext().withoutExecutionContext().withoutLock());
        if (!vdcReturnValueBase.getSucceeded()) {
            log.error("Error cloning Cinder disk '{}': {}", cinderDisk.getDiskAlias());
            getReturnValue().setFault(vdcReturnValueBase.getFault());
            return;
        }
        Guid imageId = vdcReturnValueBase.getActionReturnValue();
        diskImageMap.put(cinderDisk.getId(), imageId);
    }
    srcDiskIdToTargetDiskIdMapping.putAll(diskImageMap);
}
#method_after
protected void addVmCinderDisks(Collection<DiskImage> templateDisks) {
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(templateDisks);
    if (cinderDisks.isEmpty()) {
        return;
    }
    Map<Guid, Guid> diskImageMap = new HashMap<>();
    for (CinderDisk cinderDisk : cinderDisks) {
        ImagesContainterParametersBase params = buildCloneCinderDiskCommandParameters(cinderDisk);
        VdcReturnValueBase vdcReturnValueBase = runInternalAction(ActionType.CloneSingleCinderDisk, params, cloneContext().withoutExecutionContext().withoutLock());
        if (!vdcReturnValueBase.getSucceeded()) {
            log.error("Error cloning Cinder disk '{}': {}", cinderDisk.getDiskAlias());
            getReturnValue().setFault(vdcReturnValueBase.getFault());
            return;
        }
        Guid imageId = vdcReturnValueBase.getActionReturnValue();
        diskImageMap.put(cinderDisk.getId(), imageId);
    }
    srcDiskIdToTargetDiskIdMapping.putAll(diskImageMap);
}
#end_block

#method_before
private void addVmToPool() {
    AddVmToPoolParameters parameters = new AddVmToPoolParameters(getParameters().getPoolId(), getVmId());
    parameters.setShouldBeLogged(false);
    VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.AddVmToPool, parameters);
    setSucceeded(result.getSucceeded());
    if (!result.getSucceeded()) {
        log.error("Error adding VM {} to Pool {}", getVmId(), getParameters().getPoolId());
        getReturnValue().setFault(result.getFault());
        return;
    }
    addVmPermission();
}
#method_after
private void addVmToPool() {
    AddVmToPoolParameters parameters = new AddVmToPoolParameters(getParameters().getPoolId(), getVmId());
    parameters.setShouldBeLogged(false);
    VdcReturnValueBase result = runInternalActionWithTasksContext(ActionType.AddVmToPool, parameters);
    setSucceeded(result.getSucceeded());
    if (!result.getSucceeded()) {
        log.error("Error adding VM {} to Pool {}", getVmId(), getParameters().getPoolId());
        getReturnValue().setFault(result.getFault());
        return;
    }
    addVmPermission();
}
#end_block

#method_before
@Override
protected VdcActionType getChildActionType() {
    return VdcActionType.CreateSnapshotFromTemplate;
}
#method_after
@Override
protected ActionType getChildActionType() {
    return ActionType.CreateSnapshotFromTemplate;
}
#end_block

#method_before
private void updateVmTemplateVersion() {
    if (getVm().getStatus() == VMStatus.Down) {
        VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.UpdateVmVersion, new UpdateVmVersionParameters(getVmId(), getParameters().getVm().getVmtGuid(), getParameters().getVm().isUseLatestVersion()), getLock());
        if (result.getSucceeded()) {
            getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
        }
        setSucceeded(result.getSucceeded());
        setActionReturnValue(VdcActionType.UpdateVmVersion);
    } else {
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContext());
        setSucceeded(true);
    }
}
#method_after
private void updateVmTemplateVersion() {
    if (getVm().getStatus() == VMStatus.Down) {
        VdcReturnValueBase result = runInternalActionWithTasksContext(ActionType.UpdateVmVersion, new UpdateVmVersionParameters(getVmId(), getParameters().getVm().getVmtGuid(), getParameters().getVm().isUseLatestVersion()), getLock());
        if (result.getSucceeded()) {
            getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
        }
        setSucceeded(result.getSucceeded());
        setActionReturnValue(ActionType.UpdateVmVersion);
    } else {
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContext());
        setSucceeded(true);
    }
}
#end_block

#method_before
private void updateRngDevice() {
    if (!getParameters().isUpdateRngDevice()) {
        return;
    }
    VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(getParameters().getVmId()));
    List<VmRngDevice> rngDevs = query.getReturnValue();
    VdcReturnValueBase rngCommandResult = null;
    if (rngDevs.isEmpty()) {
        if (getParameters().getRngDevice() != null) {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            rngCommandResult = runInternalAction(VdcActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
        }
    } else {
        if (getParameters().getRngDevice() == null) {
            RngDeviceParameters params = new RngDeviceParameters(rngDevs.get(0), true);
            rngCommandResult = runInternalAction(VdcActionType.RemoveRngDevice, params, cloneContextAndDetachFromParent());
        } else {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            params.getRngDevice().setDeviceId(rngDevs.get(0).getDeviceId());
            rngCommandResult = runInternalAction(VdcActionType.UpdateRngDevice, params, cloneContextAndDetachFromParent());
        }
    }
    if (rngCommandResult != null && !rngCommandResult.getSucceeded()) {
        log.error("Updating RNG device of VM {} ({}) failed. Old RNG device = {}. New RNG device = {}.", getVm().getName(), getVm().getId(), rngDevs.isEmpty() ? null : rngDevs.get(0), getParameters().getRngDevice());
    }
}
#method_after
private void updateRngDevice() {
    if (!getParameters().isUpdateRngDevice()) {
        return;
    }
    VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(getParameters().getVmId()));
    List<VmRngDevice> rngDevs = query.getReturnValue();
    VdcReturnValueBase rngCommandResult = null;
    if (rngDevs.isEmpty()) {
        if (getParameters().getRngDevice() != null) {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            rngCommandResult = runInternalAction(ActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
        }
    } else {
        if (getParameters().getRngDevice() == null) {
            RngDeviceParameters params = new RngDeviceParameters(rngDevs.get(0), true);
            rngCommandResult = runInternalAction(ActionType.RemoveRngDevice, params, cloneContextAndDetachFromParent());
        } else {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            params.getRngDevice().setDeviceId(rngDevs.get(0).getDeviceId());
            rngCommandResult = runInternalAction(ActionType.UpdateRngDevice, params, cloneContextAndDetachFromParent());
        }
    }
    if (rngCommandResult != null && !rngCommandResult.getSucceeded()) {
        log.error("Updating RNG device of VM {} ({}) failed. Old RNG device = {}. New RNG device = {}.", getVm().getName(), getVm().getId(), rngDevs.isEmpty() ? null : rngDevs.get(0), getParameters().getRngDevice());
    }
}
#end_block

#method_before
private void hotSetCpus(VM newVm) {
    int currentSockets = getVm().getNumOfSockets();
    int newNumOfSockets = newVm.getNumOfSockets();
    // try hotplug only if topology (cpuPerSocket, threadsPerCpu) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && VmCommonUtils.isCpusToBeHotplugged(getVm(), newVm)) {
        HotSetNumberOfCpusParameters params = new HotSetNumberOfCpusParameters(newVmStatic, currentSockets < newNumOfSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        setNumberOfCpusResult = runInternalAction(VdcActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        // into the OVF store and automatically used during the next HE VM start
        if (!getVm().isHostedEngine()) {
            newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newNumOfSockets : currentSockets);
        }
        hotSetCpusLog(params);
    }
}
#method_after
private void hotSetCpus(VM newVm) {
    int currentSockets = getVm().getNumOfSockets();
    int newNumOfSockets = newVm.getNumOfSockets();
    // try hotplug only if topology (cpuPerSocket, threadsPerCpu) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && VmCommonUtils.isCpusToBeHotplugged(getVm(), newVm)) {
        HotSetNumberOfCpusParameters params = new HotSetNumberOfCpusParameters(newVmStatic, currentSockets < newNumOfSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        VdcReturnValueBase setNumberOfCpusResult = runInternalAction(ActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        // into the OVF store and automatically used during the next HE VM start
        if (!getVm().isHostedEngine()) {
            newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newNumOfSockets : currentSockets);
        }
        logHotSetActionEvent(setNumberOfCpusResult, AuditLogType.FAILED_HOT_SET_NUMBER_OF_CPUS);
    }
}
#end_block

#method_before
private void updateCurrentMemory(VM newVm) {
    int currentMemory = getVm().getMemSizeMb();
    int newAmountOfMemory = newVm.getMemSizeMb();
    if (getVm().getStatus().isNotRunning()) {
        newVmStatic.setMemSizeMb(newAmountOfMemory);
        return;
    }
    if (getVm().getStatus() != VMStatus.Up) {
        newVmStatic.setMemSizeMb(currentMemory);
        log.warn("Memory update {}MB -> {}MB of VM {} ({}) left out. Memory can't be updated in current VM state ({}).", currentMemory, newAmountOfMemory, getVm().getName(), getVm().getId(), getVm().getStatus());
        return;
    }
    if (!VmCommonUtils.isMemoryToBeHotplugged(getVm(), newVm)) {
        return;
    }
    final int memoryAddedMb = newAmountOfMemory - currentMemory;
    final int factor = Config.<Integer>getValue(ConfigValues.HotPlugMemoryBlockSizeMb);
    final boolean memoryDividable = memoryAddedMb % factor == 0;
    if (!memoryDividable) {
        addCustomValue("memoryAdded", String.valueOf(memoryAddedMb));
        addCustomValue("requiredFactor", String.valueOf(factor));
        auditLogDirector.log(this, AuditLogType.FAILED_HOT_SET_MEMORY_NOT_DIVIDABLE);
        return;
    }
    hotSetMemory(currentMemory, newAmountOfMemory);
}
#method_after
private void updateCurrentMemory(VM newVm) {
    int currentMemory = getVm().getMemSizeMb();
    int newAmountOfMemory = newVm.getMemSizeMb();
    if (getVm().getStatus().isNotRunning()) {
        newVmStatic.setMemSizeMb(newAmountOfMemory);
        return;
    }
    if (getVm().getStatus() != VMStatus.Up) {
        newVmStatic.setMemSizeMb(currentMemory);
        log.warn("Memory update {}MB -> {}MB of VM {} ({}) left out. Memory can't be updated in current VM state ({}).", currentMemory, newAmountOfMemory, getVm().getName(), getVm().getId(), getVm().getStatus());
        return;
    }
    if (!VmCommonUtils.isMemoryToBeHotplugged(getVm(), newVm)) {
        return;
    }
    final int memoryAddedMb = newAmountOfMemory - currentMemory;
    final int factor = Config.<Integer>getValue(ConfigValues.HotPlugMemoryBlockSizeMb);
    final boolean memoryDividable = memoryAddedMb % factor == 0;
    if (!memoryDividable) {
        addCustomValue("memoryAdded", String.valueOf(memoryAddedMb));
        addCustomValue("requiredFactor", String.valueOf(factor));
        auditLogDirector.log(this, AuditLogType.FAILED_HOT_SET_MEMORY_NOT_DIVIDABLE);
        newVmStatic.setMemSizeMb(currentMemory);
        return;
    }
    hotSetMemory(currentMemory, newAmountOfMemory);
}
#end_block

#method_before
private void hotSetMemory(int currentMemoryMb, int newAmountOfMemoryMb) {
    final int minimalHotPlugDeviceSizeMb = getVm().getClusterArch().getHotplugMemorySizeFactorMb();
    final List<VmDevice> memoryDevices = getVmDeviceUtils().getMemoryDevices(getVmId());
    final boolean minimalMemoryDevicePresent = memoryDevices.stream().anyMatch(device -> VmDeviceCommonUtils.getSizeOfMemoryDeviceMb(device) == minimalHotPlugDeviceSizeMb);
    final int secondPartSizeMb = (newAmountOfMemoryMb - currentMemoryMb) - minimalHotPlugDeviceSizeMb;
    if (minimalMemoryDevicePresent || secondPartSizeMb == 0) {
        hotPlugMemoryDevice(currentMemoryMb, newAmountOfMemoryMb);
        return;
    }
    hotPlugMemoryDevice(currentMemoryMb, currentMemoryMb + minimalHotPlugDeviceSizeMb);
    hotPlugMemoryDevice(currentMemoryMb + minimalHotPlugDeviceSizeMb, newAmountOfMemoryMb);
}
#method_after
private void hotSetMemory(int currentMemoryMb, int newAmountOfMemoryMb) {
    final int minimalHotPlugDeviceSizeMb = getVm().getClusterArch().getHotplugMemorySizeFactorMb();
    final List<VmDevice> memoryDevices = getVmDeviceUtils().getMemoryDevices(getVmId());
    final boolean minimalMemoryDevicePresent = memoryDevices.stream().anyMatch(device -> VmDeviceCommonUtils.getSizeOfMemoryDeviceMb(device).map(size -> size == minimalHotPlugDeviceSizeMb).orElse(false));
    final int secondPartSizeMb = (newAmountOfMemoryMb - currentMemoryMb) - minimalHotPlugDeviceSizeMb;
    if (minimalMemoryDevicePresent || secondPartSizeMb == 0) {
        hotPlugMemoryDevice(currentMemoryMb, newAmountOfMemoryMb);
        return;
    }
    hotPlugMemoryDevice(currentMemoryMb, currentMemoryMb + minimalHotPlugDeviceSizeMb);
    hotPlugMemoryDevice(currentMemoryMb + minimalHotPlugDeviceSizeMb, newAmountOfMemoryMb);
}
#end_block

#method_before
private void hotPlugMemoryDevice(int currentMemoryMb, int newAmountOfMemoryMb) {
    HotSetAmountOfMemoryParameters params = new HotSetAmountOfMemoryParameters(newVmStatic, currentMemoryMb < newAmountOfMemoryMb ? PlugAction.PLUG : PlugAction.UNPLUG, // We always use node 0, auto-numa should handle the allocation
    0, newAmountOfMemoryMb - currentMemoryMb);
    VdcReturnValueBase setAmountOfMemoryResult = runInternalAction(VdcActionType.HotSetAmountOfMemory, params, cloneContextAndDetachFromParent());
    // into the OVF store and automatically used during the next HE VM start
    if (!getVm().isHostedEngine()) {
        newVmStatic.setMemSizeMb(setAmountOfMemoryResult.getSucceeded() ? newAmountOfMemoryMb : currentMemoryMb);
    }
    hotSetMemlog(params, setAmountOfMemoryResult);
}
#method_after
private void hotPlugMemoryDevice(int currentMemoryMb, int newAmountOfMemoryMb) {
    HotSetAmountOfMemoryParameters params = new HotSetAmountOfMemoryParameters(newVmStatic, currentMemoryMb < newAmountOfMemoryMb ? PlugAction.PLUG : PlugAction.UNPLUG, // We always use node 0, auto-numa should handle the allocation
    0, newAmountOfMemoryMb - currentMemoryMb);
    VdcReturnValueBase setAmountOfMemoryResult = runInternalAction(ActionType.HotSetAmountOfMemory, params, cloneContextAndDetachFromParent());
    // into the OVF store and automatically used during the next HE VM start
    if (!getVm().isHostedEngine()) {
        newVmStatic.setMemSizeMb(setAmountOfMemoryResult.getSucceeded() ? newAmountOfMemoryMb : currentMemoryMb);
    }
    logHotSetActionEvent(setAmountOfMemoryResult, AuditLogType.FAILED_HOT_SET_MEMORY);
}
#end_block

#method_before
private void updateWatchdog() {
    // do not update if this flag is not set
    if (getParameters().isUpdateWatchdog()) {
        VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getParameters().getVmId()));
        List<VmWatchdog> watchdogs = query.getReturnValue();
        if (watchdogs.isEmpty()) {
            if (getParameters().getWatchdog() == null) {
            // nothing to do, no watchdog and no watchdog to create
            } else {
                WatchdogParameters parameters = new WatchdogParameters();
                parameters.setId(getParameters().getVmId());
                parameters.setAction(getParameters().getWatchdog().getAction());
                parameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(VdcActionType.AddWatchdog, parameters, cloneContextAndDetachFromParent());
            }
        } else {
            WatchdogParameters watchdogParameters = new WatchdogParameters();
            watchdogParameters.setId(getParameters().getVmId());
            if (getParameters().getWatchdog() == null) {
                // there is a watchdog in the vm, there should not be any, so let's delete
                runInternalAction(VdcActionType.RemoveWatchdog, watchdogParameters, cloneContextAndDetachFromParent());
            } else {
                // there is a watchdog in the vm, we have to update.
                watchdogParameters.setAction(getParameters().getWatchdog().getAction());
                watchdogParameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(VdcActionType.UpdateWatchdog, watchdogParameters, cloneContextAndDetachFromParent());
            }
        }
    }
}
#method_after
private void updateWatchdog() {
    // do not update if this flag is not set
    if (getParameters().isUpdateWatchdog()) {
        VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getParameters().getVmId()));
        List<VmWatchdog> watchdogs = query.getReturnValue();
        if (watchdogs.isEmpty()) {
            if (getParameters().getWatchdog() == null) {
            // nothing to do, no watchdog and no watchdog to create
            } else {
                WatchdogParameters parameters = new WatchdogParameters();
                parameters.setId(getParameters().getVmId());
                parameters.setAction(getParameters().getWatchdog().getAction());
                parameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(ActionType.AddWatchdog, parameters, cloneContextAndDetachFromParent());
            }
        } else {
            WatchdogParameters watchdogParameters = new WatchdogParameters();
            watchdogParameters.setId(getParameters().getVmId());
            if (getParameters().getWatchdog() == null) {
                // there is a watchdog in the vm, there should not be any, so let's delete
                runInternalAction(ActionType.RemoveWatchdog, watchdogParameters, cloneContextAndDetachFromParent());
            } else {
                // there is a watchdog in the vm, we have to update.
                watchdogParameters.setAction(getParameters().getWatchdog().getAction());
                watchdogParameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(ActionType.UpdateWatchdog, watchdogParameters, cloneContextAndDetachFromParent());
            }
        }
    }
}
#end_block

#method_before
private void removeGraphicsDevice(GraphicsType type) {
    GraphicsDevice existingGraphicsDevice = getGraphicsDevOfType(type);
    if (existingGraphicsDevice != null) {
        getBackend().runInternalAction(VdcActionType.RemoveGraphicsDevice, new GraphicsParameters(existingGraphicsDevice));
    }
}
#method_after
private void removeGraphicsDevice(GraphicsType type) {
    GraphicsDevice existingGraphicsDevice = getGraphicsDevOfType(type);
    if (existingGraphicsDevice != null) {
        getBackend().runInternalAction(ActionType.RemoveGraphicsDevice, new GraphicsParameters(existingGraphicsDevice));
    }
}
#end_block

#method_before
private void addOrUpdateGraphicsDevice(GraphicsDevice device) {
    GraphicsDevice existingGraphicsDevice = getGraphicsDevOfType(device.getGraphicsType());
    device.setVmId(getVmId());
    getBackend().runInternalAction(existingGraphicsDevice == null ? VdcActionType.AddGraphicsDevice : VdcActionType.UpdateGraphicsDevice, new GraphicsParameters(device));
}
#method_after
private void addOrUpdateGraphicsDevice(GraphicsDevice device) {
    GraphicsDevice existingGraphicsDevice = getGraphicsDevOfType(device.getGraphicsType());
    device.setVmId(getVmId());
    getBackend().runInternalAction(existingGraphicsDevice == null ? ActionType.AddGraphicsDevice : ActionType.UpdateGraphicsDevice, new GraphicsParameters(device));
}
#end_block

#method_before
private void updateVmNumaNodes() {
    if (!getParameters().isUpdateNuma()) {
        return;
    }
    List<VmNumaNode> newList = getParameters().getVmStaticData().getvNumaNodeList();
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getParameters().getVm(), new ArrayList<>(newList));
    addLogMessages(getBackend().runInternalAction(VdcActionType.SetVmNumaNodes, params));
}
#method_after
private void updateVmNumaNodes() {
    if (!getParameters().isUpdateNuma()) {
        return;
    }
    List<VmNumaNode> newList = getParameters().getVmStaticData().getvNumaNodeList();
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getParameters().getVm(), new ArrayList<>(newList));
    addLogMessages(getBackend().runInternalAction(ActionType.SetVmNumaNodes, params));
}
#end_block

#method_before
protected boolean canAddLease() {
    if (!getParameters().getVmStaticData().isAutoStartup()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED_WITH_HA_OFF);
    }
    if (!FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED);
    }
    return validateLeaseStorageDomain(getParameters().getVmStaticData().getLeaseStorageDomainId());
}
#method_after
protected boolean canAddLease() {
    if (!FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED);
    }
    if (!getParameters().getVmStaticData().isAutoStartup()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED_WITH_HA_OFF);
    }
    return validateLeaseStorageDomain(getParameters().getVmStaticData().getLeaseStorageDomainId());
}
#end_block

#method_before
protected boolean checkTemplateImages(List<String> reasons) {
    if (getParameters().getParentCommand() == VdcActionType.AddVmPool) {
        return true;
    }
    for (StorageDomain storage : destStorages.values()) {
        if (!validate(vmTemplateHandler.isVmTemplateImagesReady(vmDisksSource, storage.getId(), false, false, true, true, storageToDisksMap.get(storage.getId())))) {
            return false;
        }
    }
    return true;
}
#method_after
protected boolean checkTemplateImages(List<String> reasons) {
    if (getParameters().getParentCommand() == ActionType.AddVmPool) {
        return true;
    }
    for (StorageDomain storage : destStorages.values()) {
        if (!validate(vmTemplateHandler.isVmTemplateImagesReady(vmDisksSource, storage.getId(), false, false, true, true, storageToDisksMap.get(storage.getId())))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void addGraphicsDevice() {
    for (GraphicsDevice graphicsDevice : getParameters().getGraphicsDevices().values()) {
        if (graphicsDevice == null) {
            continue;
        }
        graphicsDevice.setVmId(getVmId());
        getBackend().runInternalAction(VdcActionType.AddGraphicsDevice, new GraphicsParameters(graphicsDevice));
    }
}
#method_after
private void addGraphicsDevice() {
    for (GraphicsDevice graphicsDevice : getParameters().getGraphicsDevices().values()) {
        if (graphicsDevice == null) {
            continue;
        }
        graphicsDevice.setVmId(getVmId());
        getBackend().runInternalAction(ActionType.AddGraphicsDevice, new GraphicsParameters(graphicsDevice));
    }
}
#end_block

#method_before
private void addVmWatchdog() {
    VmWatchdog vmWatchdog = getParameters().getWatchdog();
    if (vmWatchdog != null) {
        VdcActionType actionType = getVmDeviceUtils().hasWatchdog(getVmTemplateId()) ? VdcActionType.UpdateWatchdog : VdcActionType.AddWatchdog;
        runInternalAction(actionType, buildWatchdogParameters(vmWatchdog), cloneContextAndDetachFromParent());
    }
}
#method_after
private void addVmWatchdog() {
    VmWatchdog vmWatchdog = getParameters().getWatchdog();
    if (vmWatchdog != null) {
        ActionType actionType = getVmDeviceUtils().hasWatchdog(getVmTemplateId()) ? ActionType.UpdateWatchdog : ActionType.AddWatchdog;
        runInternalAction(actionType, buildWatchdogParameters(vmWatchdog), cloneContextAndDetachFromParent());
    }
}
#end_block

#method_before
private void addVmRngDevice() {
    VmRngDevice rngDev = getParameters().getRngDevice();
    if (rngDev != null) {
        rngDev.setVmId(getVmId());
        RngDeviceParameters params = new RngDeviceParameters(rngDev, true);
        VdcReturnValueBase result = runInternalAction(VdcActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            log.error("Couldn't add RNG device for new VM.");
            throw new IllegalArgumentException("Couldn't add RNG device for new VM.");
        }
    }
}
#method_after
private void addVmRngDevice() {
    VmRngDevice rngDev = getParameters().getRngDevice();
    if (rngDev != null) {
        rngDev.setVmId(getVmId());
        RngDeviceParameters params = new RngDeviceParameters(rngDev, true);
        VdcReturnValueBase result = runInternalAction(ActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            log.error("Couldn't add RNG device for new VM.");
            throw new IllegalArgumentException("Couldn't add RNG device for new VM.");
        }
    }
}
#end_block

#method_before
private void addVmNumaNodes() {
    List<VmNumaNode> numaNodes = getParameters().getVm().getvNumaNodeList();
    if (numaNodes.isEmpty()) {
        return;
    }
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getParameters().getVm(), numaNodes);
    VdcReturnValueBase returnValueBase = getBackend().runInternalAction(VdcActionType.AddVmNumaNodes, params);
    if (!returnValueBase.getSucceeded()) {
        auditLogDirector.log(this, AuditLogType.NUMA_ADD_VM_NUMA_NODE_FAILED);
    }
}
#method_after
private void addVmNumaNodes() {
    List<VmNumaNode> numaNodes = getParameters().getVm().getvNumaNodeList();
    if (numaNodes.isEmpty()) {
        return;
    }
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getParameters().getVm(), numaNodes);
    VdcReturnValueBase returnValueBase = getBackend().runInternalAction(ActionType.AddVmNumaNodes, params);
    if (!returnValueBase.getSucceeded()) {
        auditLogDirector.log(this, AuditLogType.NUMA_ADD_VM_NUMA_NODE_FAILED);
    }
}
#end_block

#method_before
protected VdcActionType getDiskCreationCommandType() {
    return VdcActionType.CreateSnapshotFromTemplate;
}
#method_after
protected ActionType getDiskCreationCommandType() {
    return ActionType.CreateSnapshotFromTemplate;
}
#end_block

#method_before
protected CreateSnapshotFromTemplateParameters buildDiskCreationParameters(DiskImage image) {
    CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(image.getImageId(), getParameters().getVmStaticData().getId());
    tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(image.getId()).getStorageIds().get(0));
    tempVar.setDiskAlias(diskInfoDestinationMap.get(image.getId()).getDiskAlias());
    tempVar.setStorageDomainId(image.getStorageIds().get(0));
    tempVar.setVmSnapshotId(getVmSnapshotId());
    tempVar.setParentCommand(VdcActionType.AddVm);
    tempVar.setEntityInfo(getParameters().getEntityInfo());
    tempVar.setParentParameters(getParameters());
    tempVar.setQuotaId(diskInfoDestinationMap.get(image.getId()).getQuotaId());
    tempVar.setDiskProfileId(diskInfoDestinationMap.get(image.getId()).getDiskProfileId());
    return tempVar;
}
#method_after
protected CreateSnapshotFromTemplateParameters buildDiskCreationParameters(DiskImage image) {
    CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(image.getImageId(), getParameters().getVmStaticData().getId());
    tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(image.getId()).getStorageIds().get(0));
    tempVar.setDiskAlias(diskInfoDestinationMap.get(image.getId()).getDiskAlias());
    tempVar.setStorageDomainId(image.getStorageIds().get(0));
    tempVar.setVmSnapshotId(getVmSnapshotId());
    tempVar.setParentCommand(ActionType.AddVm);
    tempVar.setEntityInfo(getParameters().getEntityInfo());
    tempVar.setParentParameters(getParameters());
    tempVar.setQuotaId(diskInfoDestinationMap.get(image.getId()).getQuotaId());
    tempVar.setDiskProfileId(diskInfoDestinationMap.get(image.getId()).getDiskProfileId());
    return tempVar;
}
#end_block

#method_before
protected void addVmCinderDisks(Collection<DiskImage> templateDisks) {
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(templateDisks);
    if (cinderDisks.isEmpty()) {
        return;
    }
    Map<Guid, Guid> diskImageMap = new HashMap<>();
    for (CinderDisk cinderDisk : cinderDisks) {
        ImagesContainterParametersBase params = buildCloneCinderDiskCommandParameters(cinderDisk);
        VdcReturnValueBase vdcReturnValueBase = runInternalAction(VdcActionType.CloneSingleCinderDisk, params, cloneContext().withoutExecutionContext().withoutLock());
        if (!vdcReturnValueBase.getSucceeded()) {
            log.error("Error cloning Cinder disk '{}': {}", cinderDisk.getDiskAlias());
            getReturnValue().setFault(vdcReturnValueBase.getFault());
            return;
        }
        Guid imageId = vdcReturnValueBase.getActionReturnValue();
        diskImageMap.put(cinderDisk.getId(), imageId);
    }
    srcDiskIdToTargetDiskIdMapping.putAll(diskImageMap);
}
#method_after
protected void addVmCinderDisks(Collection<DiskImage> templateDisks) {
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(templateDisks);
    if (cinderDisks.isEmpty()) {
        return;
    }
    Map<Guid, Guid> diskImageMap = new HashMap<>();
    for (CinderDisk cinderDisk : cinderDisks) {
        ImagesContainterParametersBase params = buildCloneCinderDiskCommandParameters(cinderDisk);
        VdcReturnValueBase vdcReturnValueBase = runInternalAction(ActionType.CloneSingleCinderDisk, params, cloneContext().withoutExecutionContext().withoutLock());
        if (!vdcReturnValueBase.getSucceeded()) {
            log.error("Error cloning Cinder disk '{}': {}", cinderDisk.getDiskAlias());
            getReturnValue().setFault(vdcReturnValueBase.getFault());
            return;
        }
        Guid imageId = vdcReturnValueBase.getActionReturnValue();
        diskImageMap.put(cinderDisk.getId(), imageId);
    }
    srcDiskIdToTargetDiskIdMapping.putAll(diskImageMap);
}
#end_block

#method_before
private void addVmToPool() {
    AddVmToPoolParameters parameters = new AddVmToPoolParameters(getParameters().getPoolId(), getVmId());
    parameters.setShouldBeLogged(false);
    VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.AddVmToPool, parameters);
    setSucceeded(result.getSucceeded());
    if (!result.getSucceeded()) {
        log.error("Error adding VM {} to Pool {}", getVmId(), getParameters().getPoolId());
        getReturnValue().setFault(result.getFault());
        return;
    }
    addVmPermission();
}
#method_after
private void addVmToPool() {
    AddVmToPoolParameters parameters = new AddVmToPoolParameters(getParameters().getPoolId(), getVmId());
    parameters.setShouldBeLogged(false);
    VdcReturnValueBase result = runInternalActionWithTasksContext(ActionType.AddVmToPool, parameters);
    setSucceeded(result.getSucceeded());
    if (!result.getSucceeded()) {
        log.error("Error adding VM {} to Pool {}", getVmId(), getParameters().getPoolId());
        getReturnValue().setFault(result.getFault());
        return;
    }
    addVmPermission();
}
#end_block

#method_before
@Override
protected VdcActionType getChildActionType() {
    return VdcActionType.CreateSnapshotFromTemplate;
}
#method_after
@Override
protected ActionType getChildActionType() {
    return ActionType.CreateSnapshotFromTemplate;
}
#end_block

#method_before
private boolean updateVmLease() {
    if (Objects.equals(oldVm.getLeaseStorageDomainId(), newVmStatic.getLeaseStorageDomainId())) {
        return true;
    }
    if (getVm().isDown()) {
        if (!addVmLease(newVmStatic.getLeaseStorageDomainId(), newVmStatic.getId())) {
            return false;
        }
        // best effort to remove the lease from the previous storage domain
        removeVmLease(oldVm.getLeaseStorageDomainId(), oldVm.getId());
    } else {
        if (oldVm.getLeaseStorageDomainId() != null) {
            runVdsCommand(VDSCommandType.HotUnplugLease, new LeaseVDSParameters(getVm().getRunOnVds(), oldVm.getId(), oldVm.getLeaseStorageDomainId()));
            removeVmLease(oldVm.getLeaseStorageDomainId(), oldVm.getId());
        } else {
            VmLeaseParameters params = new VmLeaseParameters(getStoragePoolId(), newVmStatic.getLeaseStorageDomainId(), newVmStatic.getId());
            params.setVdsId(getVm().getRunOnVds());
            return runInternalAction(VdcActionType.HotPlugLease, params).getSucceeded();
        }
    }
    return true;
}
#method_after
private boolean updateVmLease() {
    if (Objects.equals(oldVm.getLeaseStorageDomainId(), newVmStatic.getLeaseStorageDomainId())) {
        return true;
    }
    if (getVm().isNotRunning()) {
        if (!addVmLease(newVmStatic.getLeaseStorageDomainId(), newVmStatic.getId())) {
            return false;
        }
    } else {
        if (oldVm.getLeaseStorageDomainId() == null) {
            VmLeaseParameters params = new VmLeaseParameters(getStoragePoolId(), newVmStatic.getLeaseStorageDomainId(), newVmStatic.getId());
            params.setVdsId(getVm().getRunOnVds());
            params.setHotPlugLease(true);
            return runInternalAction(ActionType.AddVmLease, params).getSucceeded();
        }
        boolean hotUnplugSucceeded = false;
        try {
            hotUnplugSucceeded = runVdsCommand(VDSCommandType.HotUnplugLease, new LeaseVDSParameters(getVm().getRunOnVds(), oldVm.getId(), oldVm.getLeaseStorageDomainId())).getSucceeded();
        } catch (EngineException e) {
            log.error("Failure in hot unplugging a lease to VM {}, message: {}", oldVm.getId(), e.getMessage());
        }
        if (!hotUnplugSucceeded) {
            auditLog(this, AuditLogType.HOT_UNPLUG_LEASE_FAILED);
        }
    }
    // best effort to remove the lease from the previous storage domain
    removeVmLease(oldVm.getLeaseStorageDomainId(), oldVm.getId());
    return true;
}
#end_block

#method_before
private void updateVmTemplateVersion() {
    if (getVm().getStatus() == VMStatus.Down) {
        VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.UpdateVmVersion, new UpdateVmVersionParameters(getVmId(), getParameters().getVm().getVmtGuid(), getParameters().getVm().isUseLatestVersion()), getLock());
        if (result.getSucceeded()) {
            getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
        }
        setSucceeded(result.getSucceeded());
        setActionReturnValue(VdcActionType.UpdateVmVersion);
    } else {
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContext());
        setSucceeded(true);
    }
}
#method_after
private void updateVmTemplateVersion() {
    if (getVm().getStatus() == VMStatus.Down) {
        VdcReturnValueBase result = runInternalActionWithTasksContext(ActionType.UpdateVmVersion, new UpdateVmVersionParameters(getVmId(), getParameters().getVm().getVmtGuid(), getParameters().getVm().isUseLatestVersion()), getLock());
        if (result.getSucceeded()) {
            getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
        }
        setSucceeded(result.getSucceeded());
        setActionReturnValue(ActionType.UpdateVmVersion);
    } else {
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContext());
        setSucceeded(true);
    }
}
#end_block

#method_before
private void updateRngDevice() {
    if (!getParameters().isUpdateRngDevice()) {
        return;
    }
    VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(getParameters().getVmId()));
    List<VmRngDevice> rngDevs = query.getReturnValue();
    VdcReturnValueBase rngCommandResult = null;
    if (rngDevs.isEmpty()) {
        if (getParameters().getRngDevice() != null) {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            rngCommandResult = runInternalAction(VdcActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
        }
    } else {
        if (getParameters().getRngDevice() == null) {
            RngDeviceParameters params = new RngDeviceParameters(rngDevs.get(0), true);
            rngCommandResult = runInternalAction(VdcActionType.RemoveRngDevice, params, cloneContextAndDetachFromParent());
        } else {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            params.getRngDevice().setDeviceId(rngDevs.get(0).getDeviceId());
            rngCommandResult = runInternalAction(VdcActionType.UpdateRngDevice, params, cloneContextAndDetachFromParent());
        }
    }
    if (rngCommandResult != null && !rngCommandResult.getSucceeded()) {
        log.error("Updating RNG device of VM {} ({}) failed. Old RNG device = {}. New RNG device = {}.", getVm().getName(), getVm().getId(), rngDevs.isEmpty() ? null : rngDevs.get(0), getParameters().getRngDevice());
    }
}
#method_after
private void updateRngDevice() {
    if (!getParameters().isUpdateRngDevice()) {
        return;
    }
    VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(getParameters().getVmId()));
    List<VmRngDevice> rngDevs = query.getReturnValue();
    VdcReturnValueBase rngCommandResult = null;
    if (rngDevs.isEmpty()) {
        if (getParameters().getRngDevice() != null) {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            rngCommandResult = runInternalAction(ActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
        }
    } else {
        if (getParameters().getRngDevice() == null) {
            RngDeviceParameters params = new RngDeviceParameters(rngDevs.get(0), true);
            rngCommandResult = runInternalAction(ActionType.RemoveRngDevice, params, cloneContextAndDetachFromParent());
        } else {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            params.getRngDevice().setDeviceId(rngDevs.get(0).getDeviceId());
            rngCommandResult = runInternalAction(ActionType.UpdateRngDevice, params, cloneContextAndDetachFromParent());
        }
    }
    if (rngCommandResult != null && !rngCommandResult.getSucceeded()) {
        log.error("Updating RNG device of VM {} ({}) failed. Old RNG device = {}. New RNG device = {}.", getVm().getName(), getVm().getId(), rngDevs.isEmpty() ? null : rngDevs.get(0), getParameters().getRngDevice());
    }
}
#end_block

#method_before
private void hotSetCpus(VM newVm) {
    int currentSockets = getVm().getNumOfSockets();
    int newNumOfSockets = newVm.getNumOfSockets();
    // try hotplug only if topology (cpuPerSocket, threadsPerCpu) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && VmCommonUtils.isCpusToBeHotplugged(getVm(), newVm)) {
        HotSetNumberOfCpusParameters params = new HotSetNumberOfCpusParameters(newVmStatic, currentSockets < newNumOfSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        VdcReturnValueBase setNumberOfCpusResult = runInternalAction(VdcActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        // into the OVF store and automatically used during the next HE VM start
        if (!getVm().isHostedEngine()) {
            newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newNumOfSockets : currentSockets);
        }
        logHotSetActionEvent(setNumberOfCpusResult, AuditLogType.FAILED_HOT_SET_NUMBER_OF_CPUS);
    }
}
#method_after
private void hotSetCpus(VM newVm) {
    int currentSockets = getVm().getNumOfSockets();
    int newNumOfSockets = newVm.getNumOfSockets();
    // try hotplug only if topology (cpuPerSocket, threadsPerCpu) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && VmCommonUtils.isCpusToBeHotplugged(getVm(), newVm)) {
        HotSetNumberOfCpusParameters params = new HotSetNumberOfCpusParameters(newVmStatic, currentSockets < newNumOfSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        VdcReturnValueBase setNumberOfCpusResult = runInternalAction(ActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        // into the OVF store and automatically used during the next HE VM start
        if (!getVm().isHostedEngine()) {
            newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newNumOfSockets : currentSockets);
        }
        logHotSetActionEvent(setNumberOfCpusResult, AuditLogType.FAILED_HOT_SET_NUMBER_OF_CPUS);
    }
}
#end_block

#method_before
private void hotPlugMemoryDevice(int currentMemoryMb, int newAmountOfMemoryMb) {
    HotSetAmountOfMemoryParameters params = new HotSetAmountOfMemoryParameters(newVmStatic, currentMemoryMb < newAmountOfMemoryMb ? PlugAction.PLUG : PlugAction.UNPLUG, // We always use node 0, auto-numa should handle the allocation
    0, newAmountOfMemoryMb - currentMemoryMb);
    VdcReturnValueBase setAmountOfMemoryResult = runInternalAction(VdcActionType.HotSetAmountOfMemory, params, cloneContextAndDetachFromParent());
    // into the OVF store and automatically used during the next HE VM start
    if (!getVm().isHostedEngine()) {
        newVmStatic.setMemSizeMb(setAmountOfMemoryResult.getSucceeded() ? newAmountOfMemoryMb : currentMemoryMb);
    }
    logHotSetActionEvent(setAmountOfMemoryResult, AuditLogType.FAILED_HOT_SET_MEMORY);
}
#method_after
private void hotPlugMemoryDevice(int currentMemoryMb, int newAmountOfMemoryMb) {
    HotSetAmountOfMemoryParameters params = new HotSetAmountOfMemoryParameters(newVmStatic, currentMemoryMb < newAmountOfMemoryMb ? PlugAction.PLUG : PlugAction.UNPLUG, // We always use node 0, auto-numa should handle the allocation
    0, newAmountOfMemoryMb - currentMemoryMb);
    VdcReturnValueBase setAmountOfMemoryResult = runInternalAction(ActionType.HotSetAmountOfMemory, params, cloneContextAndDetachFromParent());
    // into the OVF store and automatically used during the next HE VM start
    if (!getVm().isHostedEngine()) {
        newVmStatic.setMemSizeMb(setAmountOfMemoryResult.getSucceeded() ? newAmountOfMemoryMb : currentMemoryMb);
    }
    logHotSetActionEvent(setAmountOfMemoryResult, AuditLogType.FAILED_HOT_SET_MEMORY);
}
#end_block

#method_before
private void updateWatchdog() {
    // do not update if this flag is not set
    if (getParameters().isUpdateWatchdog()) {
        VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getParameters().getVmId()));
        List<VmWatchdog> watchdogs = query.getReturnValue();
        if (watchdogs.isEmpty()) {
            if (getParameters().getWatchdog() == null) {
            // nothing to do, no watchdog and no watchdog to create
            } else {
                WatchdogParameters parameters = new WatchdogParameters();
                parameters.setId(getParameters().getVmId());
                parameters.setAction(getParameters().getWatchdog().getAction());
                parameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(VdcActionType.AddWatchdog, parameters, cloneContextAndDetachFromParent());
            }
        } else {
            WatchdogParameters watchdogParameters = new WatchdogParameters();
            watchdogParameters.setId(getParameters().getVmId());
            if (getParameters().getWatchdog() == null) {
                // there is a watchdog in the vm, there should not be any, so let's delete
                runInternalAction(VdcActionType.RemoveWatchdog, watchdogParameters, cloneContextAndDetachFromParent());
            } else {
                // there is a watchdog in the vm, we have to update.
                watchdogParameters.setAction(getParameters().getWatchdog().getAction());
                watchdogParameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(VdcActionType.UpdateWatchdog, watchdogParameters, cloneContextAndDetachFromParent());
            }
        }
    }
}
#method_after
private void updateWatchdog() {
    // do not update if this flag is not set
    if (getParameters().isUpdateWatchdog()) {
        VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getParameters().getVmId()));
        List<VmWatchdog> watchdogs = query.getReturnValue();
        if (watchdogs.isEmpty()) {
            if (getParameters().getWatchdog() == null) {
            // nothing to do, no watchdog and no watchdog to create
            } else {
                WatchdogParameters parameters = new WatchdogParameters();
                parameters.setId(getParameters().getVmId());
                parameters.setAction(getParameters().getWatchdog().getAction());
                parameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(ActionType.AddWatchdog, parameters, cloneContextAndDetachFromParent());
            }
        } else {
            WatchdogParameters watchdogParameters = new WatchdogParameters();
            watchdogParameters.setId(getParameters().getVmId());
            if (getParameters().getWatchdog() == null) {
                // there is a watchdog in the vm, there should not be any, so let's delete
                runInternalAction(ActionType.RemoveWatchdog, watchdogParameters, cloneContextAndDetachFromParent());
            } else {
                // there is a watchdog in the vm, we have to update.
                watchdogParameters.setAction(getParameters().getWatchdog().getAction());
                watchdogParameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(ActionType.UpdateWatchdog, watchdogParameters, cloneContextAndDetachFromParent());
            }
        }
    }
}
#end_block

#method_before
private void removeGraphicsDevice(GraphicsType type) {
    GraphicsDevice existingGraphicsDevice = getGraphicsDevOfType(type);
    if (existingGraphicsDevice != null) {
        getBackend().runInternalAction(VdcActionType.RemoveGraphicsDevice, new GraphicsParameters(existingGraphicsDevice));
    }
}
#method_after
private void removeGraphicsDevice(GraphicsType type) {
    GraphicsDevice existingGraphicsDevice = getGraphicsDevOfType(type);
    if (existingGraphicsDevice != null) {
        getBackend().runInternalAction(ActionType.RemoveGraphicsDevice, new GraphicsParameters(existingGraphicsDevice));
    }
}
#end_block

#method_before
private void addOrUpdateGraphicsDevice(GraphicsDevice device) {
    GraphicsDevice existingGraphicsDevice = getGraphicsDevOfType(device.getGraphicsType());
    device.setVmId(getVmId());
    getBackend().runInternalAction(existingGraphicsDevice == null ? VdcActionType.AddGraphicsDevice : VdcActionType.UpdateGraphicsDevice, new GraphicsParameters(device));
}
#method_after
private void addOrUpdateGraphicsDevice(GraphicsDevice device) {
    GraphicsDevice existingGraphicsDevice = getGraphicsDevOfType(device.getGraphicsType());
    device.setVmId(getVmId());
    getBackend().runInternalAction(existingGraphicsDevice == null ? ActionType.AddGraphicsDevice : ActionType.UpdateGraphicsDevice, new GraphicsParameters(device));
}
#end_block

#method_before
private void updateVmNumaNodes() {
    if (!getParameters().isUpdateNuma()) {
        return;
    }
    List<VmNumaNode> newList = getParameters().getVmStaticData().getvNumaNodeList();
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getParameters().getVm(), new ArrayList<>(newList));
    addLogMessages(getBackend().runInternalAction(VdcActionType.SetVmNumaNodes, params));
}
#method_after
private void updateVmNumaNodes() {
    if (!getParameters().isUpdateNuma()) {
        return;
    }
    List<VmNumaNode> newList = getParameters().getVmStaticData().getvNumaNodeList();
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getParameters().getVm(), new ArrayList<>(newList));
    addLogMessages(getBackend().runInternalAction(ActionType.SetVmNumaNodes, params));
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmHandler.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!canAddLease()) {
            return false;
        }
        if (!getVm().isDown()) {
            if (getParameters().getVmStaticData().getLeaseStorageDomainId() != null && getVm().getLeaseStorageDomainId() != null) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOT_SWAPPING_VM_LEASES_NOT_SUPPORTED);
            }
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmHandler.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!canAddLease()) {
            return false;
        }
        if (!getVm().isDown() && getParameters().getVmStaticData().getLeaseStorageDomainId() != null && getVm().getLeaseStorageDomainId() != null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOT_SWAPPING_VM_LEASES_NOT_SUPPORTED);
        }
    }
    return true;
}
#end_block

#method_before
@Override
public void postOnAssignTags(Map<Guid, Boolean> attachedTags) {
    TagListModel model = (TagListModel) getWindow();
    ArrayList<Guid> vmIds = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        vmIds.add(vm.getId());
    }
    // prepare attach/detach lists
    ArrayList<Guid> tagsToAttach = new ArrayList<>();
    ArrayList<Guid> tagsToDetach = new ArrayList<>();
    if (model.getItems() != null && model.getItems().size() > 0) {
        ArrayList<TagModel> tags = (ArrayList<TagModel>) model.getItems();
        TagModel rootTag = tags.get(0);
        TagModel.recursiveEditAttachDetachLists(rootTag, attachedTags, tagsToAttach, tagsToDetach);
    }
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    for (Guid a : tagsToAttach) {
        parameters.add(new AttachEntityToTagParameters(a, vmIds));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.AttachVmsToTag, parameters);
    parameters = new ArrayList<>();
    for (Guid a : tagsToDetach) {
        parameters.add(new AttachEntityToTagParameters(a, vmIds));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.DetachVmFromTag, parameters);
    cancel();
}
#method_after
@Override
public void postOnAssignTags(Map<Guid, Boolean> attachedTags) {
    TagListModel model = (TagListModel) getWindow();
    ArrayList<Guid> vmIds = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        vmIds.add(vm.getId());
    }
    // prepare attach/detach lists
    ArrayList<Guid> tagsToAttach = new ArrayList<>();
    ArrayList<Guid> tagsToDetach = new ArrayList<>();
    if (model.getItems() != null && model.getItems().size() > 0) {
        ArrayList<TagModel> tags = (ArrayList<TagModel>) model.getItems();
        TagModel rootTag = tags.get(0);
        TagModel.recursiveEditAttachDetachLists(rootTag, attachedTags, tagsToAttach, tagsToDetach);
    }
    ArrayList<ActionParametersBase> parameters = new ArrayList<>();
    for (Guid a : tagsToAttach) {
        parameters.add(new AttachEntityToTagParameters(a, vmIds));
    }
    Frontend.getInstance().runMultipleAction(ActionType.AttachVmsToTag, parameters);
    parameters = new ArrayList<>();
    for (Guid a : tagsToDetach) {
        parameters.add(new AttachEntityToTagParameters(a, vmIds));
    }
    Frontend.getInstance().runMultipleAction(ActionType.DetachVmFromTag, parameters);
    cancel();
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel window = new ConfirmationModel();
    setWindow(window);
    window.setTitle(ConstantsManager.getInstance().getConstants().removeVirtualMachinesTitle());
    window.setHelpTag(HelpTag.remove_virtual_machine);
    // $NON-NLS-1$
    window.setHashName("remove_virtual_machine");
    vmsRemoveMap = new HashMap<>();
    for (Object selectedItem : getSelectedItems()) {
        VM vm = (VM) selectedItem;
        if (VdcActionUtils.canExecute(Arrays.asList(vm), VM.class, VdcActionType.RemoveVm)) {
            EntityModel removeDisksCheckbox = new EntityModel(true);
            removeDisksCheckbox.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
            removeDisksCheckbox.setMessage(vm.getName());
            if (!Guid.Empty.equals(vm.getVmtGuid())) {
                updateRemoveDisksCheckBox(removeDisksCheckbox, true, false, ConstantsManager.getInstance().getConstants().removeVmDisksTemplateMsg());
            }
            vmsRemoveMap.put(vm.getId(), removeDisksCheckbox);
        }
    }
    window.setItems(vmsRemoveMap.entrySet());
    initRemoveDisksCheckboxes(vmsRemoveMap);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
    window.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    window.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel window = new ConfirmationModel();
    setWindow(window);
    window.setTitle(ConstantsManager.getInstance().getConstants().removeVirtualMachinesTitle());
    window.setHelpTag(HelpTag.remove_virtual_machine);
    // $NON-NLS-1$
    window.setHashName("remove_virtual_machine");
    vmsRemoveMap = new HashMap<>();
    for (Object selectedItem : getSelectedItems()) {
        VM vm = (VM) selectedItem;
        if (ActionUtils.canExecute(Arrays.asList(vm), VM.class, ActionType.RemoveVm)) {
            EntityModel removeDisksCheckbox = new EntityModel(true);
            removeDisksCheckbox.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
            removeDisksCheckbox.setMessage(vm.getName());
            if (!Guid.Empty.equals(vm.getVmtGuid())) {
                updateRemoveDisksCheckBox(removeDisksCheckbox, true, false, ConstantsManager.getInstance().getConstants().removeVmDisksTemplateMsg());
            }
            vmsRemoveMap.put(vm.getId(), removeDisksCheckbox);
        }
    }
    window.setItems(vmsRemoveMap.entrySet());
    initRemoveDisksCheckboxes(vmsRemoveMap);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
    window.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    window.getCommands().add(tempVar2);
}
#end_block

#method_before
private void postExportGetMissingTemplates(ArrayList<String> missingTemplatesFromVms) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    model.stopProgress();
    for (Object a : getSelectedItems()) {
        VM vm = (VM) a;
        MoveOrCopyParameters parameter = new MoveOrCopyParameters(vm.getId(), storageDomainId);
        parameter.setForceOverride(model.getForceOverride().getEntity());
        parameter.setCopyCollapse(model.getCollapseSnapshots().getEntity());
        parameter.setTemplateMustExists(true);
        parameters.add(parameter);
    }
    if (!model.getCollapseSnapshots().getEntity()) {
        if (missingTemplatesFromVms == null || missingTemplatesFromVms.size() > 0) {
            ConfirmationModel confirmModel = new ConfirmationModel();
            setConfirmWindow(confirmModel);
            confirmModel.setTitle(ConstantsManager.getInstance().getConstants().templatesNotFoundOnExportDomainTitle());
            confirmModel.setHelpTag(HelpTag.template_not_found_on_export_domain);
            // $NON-NLS-1$
            confirmModel.setHashName("template_not_found_on_export_domain");
            confirmModel.setMessage(missingTemplatesFromVms == null ? ConstantsManager.getInstance().getConstants().couldNotReadTemplatesFromExportDomainMsg() : ConstantsManager.getInstance().getConstants().theFollowingTemplatesAreMissingOnTargetExportDomainMsg());
            confirmModel.setItems(missingTemplatesFromVms);
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnExportNoTemplates", this);
            confirmModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("CancelConfirmation", this);
            confirmModel.getCommands().add(tempVar2);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress();
            Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, parameters, result -> {
                ExportVmModel localModel = (ExportVmModel) result.getState();
                localModel.stopProgress();
                cancel();
            }, model);
        }
    } else {
        if (model.getProgress() != null) {
            return;
        }
        for (VdcActionParametersBase item : parameters) {
            MoveOrCopyParameters parameter = (MoveOrCopyParameters) item;
            parameter.setTemplateMustExists(false);
        }
        model.startProgress();
        Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, parameters, result -> {
            ExportVmModel localModel = (ExportVmModel) result.getState();
            localModel.stopProgress();
            cancel();
        }, model);
    }
}
#method_after
private void postExportGetMissingTemplates(ArrayList<String> missingTemplatesFromVms) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    ArrayList<ActionParametersBase> parameters = new ArrayList<>();
    model.stopProgress();
    for (Object a : getSelectedItems()) {
        VM vm = (VM) a;
        MoveOrCopyParameters parameter = new MoveOrCopyParameters(vm.getId(), storageDomainId);
        parameter.setForceOverride(model.getForceOverride().getEntity());
        parameter.setCopyCollapse(model.getCollapseSnapshots().getEntity());
        parameter.setTemplateMustExists(true);
        parameters.add(parameter);
    }
    if (!model.getCollapseSnapshots().getEntity()) {
        if (missingTemplatesFromVms == null || missingTemplatesFromVms.size() > 0) {
            ConfirmationModel confirmModel = new ConfirmationModel();
            setConfirmWindow(confirmModel);
            confirmModel.setTitle(ConstantsManager.getInstance().getConstants().templatesNotFoundOnExportDomainTitle());
            confirmModel.setHelpTag(HelpTag.template_not_found_on_export_domain);
            // $NON-NLS-1$
            confirmModel.setHashName("template_not_found_on_export_domain");
            confirmModel.setMessage(missingTemplatesFromVms == null ? ConstantsManager.getInstance().getConstants().couldNotReadTemplatesFromExportDomainMsg() : ConstantsManager.getInstance().getConstants().theFollowingTemplatesAreMissingOnTargetExportDomainMsg());
            confirmModel.setItems(missingTemplatesFromVms);
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnExportNoTemplates", this);
            confirmModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("CancelConfirmation", this);
            confirmModel.getCommands().add(tempVar2);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress();
            Frontend.getInstance().runMultipleAction(ActionType.ExportVm, parameters, result -> {
                ExportVmModel localModel = (ExportVmModel) result.getState();
                localModel.stopProgress();
                cancel();
            }, model);
        }
    } else {
        if (model.getProgress() != null) {
            return;
        }
        for (ActionParametersBase item : parameters) {
            MoveOrCopyParameters parameter = (MoveOrCopyParameters) item;
            parameter.setTemplateMustExists(false);
        }
        model.startProgress();
        Frontend.getInstance().runMultipleAction(ActionType.ExportVm, parameters, result -> {
            ExportVmModel localModel = (ExportVmModel) result.getState();
            localModel.stopProgress();
            cancel();
        }, model);
    }
}
#end_block

#method_before
private void onExportNoTemplates() {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        MoveOrCopyParameters parameters = new MoveOrCopyParameters(a.getId(), storageDomainId);
        parameters.setForceOverride(model.getForceOverride().getEntity());
        parameters.setCopyCollapse(model.getCollapseSnapshots().getEntity());
        parameters.setTemplateMustExists(false);
        list.add(parameters);
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, list, result -> {
        ExportVmModel localModel = (ExportVmModel) result.getState();
        localModel.stopProgress();
        cancel();
    }, model);
}
#method_after
private void onExportNoTemplates() {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<ActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        MoveOrCopyParameters parameters = new MoveOrCopyParameters(a.getId(), storageDomainId);
        parameters.setForceOverride(model.getForceOverride().getEntity());
        parameters.setCopyCollapse(model.getCollapseSnapshots().getEntity());
        parameters.setTemplateMustExists(false);
        list.add(parameters);
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(ActionType.ExportVm, list, result -> {
        ExportVmModel localModel = (ExportVmModel) result.getState();
        localModel.stopProgress();
        cancel();
    }, model);
}
#end_block

#method_before
private void postNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = getSelectedItem();
    VM newVm = buildVmOnNewTemplate(model, vm);
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newVm, model.getName().getEntity(), model.getDescription().getEntity());
    BuilderExecutor.build(model, addVmTemplateParameters, new UnitToAddVmTemplateParametersBuilder());
    model.startProgress();
    Frontend.getInstance().runAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, result -> {
        getWindow().stopProgress();
        VdcReturnValueBase returnValueBase = result.getReturnValue();
        if (returnValueBase != null && returnValueBase.getSucceeded()) {
            cancel();
        }
    }, this);
}
#method_after
private void postNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = getSelectedItem();
    VM newVm = buildVmOnNewTemplate(model, vm);
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newVm, model.getName().getEntity(), model.getDescription().getEntity());
    BuilderExecutor.build(model, addVmTemplateParameters, new UnitToAddVmTemplateParametersBuilder());
    model.startProgress();
    Frontend.getInstance().runAction(ActionType.AddVmTemplate, addVmTemplateParameters, result -> {
        getWindow().stopProgress();
        VdcReturnValueBase returnValueBase = result.getReturnValue();
        if (returnValueBase != null && returnValueBase.getSucceeded()) {
            cancel();
        }
    }, this);
}
#end_block

#method_before
private void cancelMigration() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        list.add(new VmOperationParameterBase(a.getId()));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.CancelMigrateVm, list, result -> {
    }, null);
}
#method_after
private void cancelMigration() {
    ArrayList<ActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        list.add(new VmOperationParameterBase(a.getId()));
    }
    Frontend.getInstance().runMultipleAction(ActionType.CancelMigrateVm, list, result -> {
    }, null);
}
#end_block

#method_before
private void cancelConversion() {
    List<VdcActionParametersBase> parameters = new ArrayList<>();
    for (VM vm : getSelectedItems()) {
        parameters.add(new VmOperationParameterBase(vm.getId()));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.CancelConvertVm, parameters);
}
#method_after
private void cancelConversion() {
    List<ActionParametersBase> parameters = new ArrayList<>();
    for (VM vm : getSelectedItems()) {
        parameters.add(new VmOperationParameterBase(vm.getId()));
    }
    Frontend.getInstance().runMultipleAction(ActionType.CancelConvertVm, parameters);
}
#end_block

#method_before
private void onMigrate() {
    MigrateModel model = (MigrateModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    model.startProgress();
    if (model.getIsAutoSelect()) {
        ArrayList<VdcActionParametersBase> list = new ArrayList<>();
        for (Object item : getSelectedItems()) {
            VM vm = (VM) item;
            list.add(new MigrateVmParameters(true, vm.getId(), vm.getClusterId()));
        }
        Frontend.getInstance().runMultipleAction(VdcActionType.MigrateVm, list, result -> {
            MigrateModel localModel = (MigrateModel) result.getState();
            localModel.stopProgress();
            cancel();
        }, model);
    } else {
        ArrayList<VdcActionParametersBase> list = new ArrayList<>();
        for (Object item : getSelectedItems()) {
            VM vm = (VM) item;
            if (vm.getRunOnVds().equals(model.getHosts().getSelectedItem().getId())) {
                continue;
            }
            list.add(new MigrateVmToServerParameters(true, vm.getId(), model.getHosts().getSelectedItem().getId(), vm.getClusterId()));
        }
        Frontend.getInstance().runMultipleAction(VdcActionType.MigrateVmToServer, list, result -> {
            MigrateModel localModel = (MigrateModel) result.getState();
            localModel.stopProgress();
            cancel();
        }, model);
    }
}
#method_after
private void onMigrate() {
    MigrateModel model = (MigrateModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    model.startProgress();
    if (model.getIsAutoSelect()) {
        ArrayList<ActionParametersBase> list = new ArrayList<>();
        for (Object item : getSelectedItems()) {
            VM vm = (VM) item;
            list.add(new MigrateVmParameters(true, vm.getId(), vm.getClusterId()));
        }
        Frontend.getInstance().runMultipleAction(ActionType.MigrateVm, list, result -> {
            MigrateModel localModel = (MigrateModel) result.getState();
            localModel.stopProgress();
            cancel();
        }, model);
    } else {
        ArrayList<ActionParametersBase> list = new ArrayList<>();
        for (Object item : getSelectedItems()) {
            VM vm = (VM) item;
            if (vm.getRunOnVds().equals(model.getHosts().getSelectedItem().getId())) {
                continue;
            }
            list.add(new MigrateVmToServerParameters(true, vm.getId(), model.getHosts().getSelectedItem().getId(), vm.getClusterId()));
        }
        Frontend.getInstance().runMultipleAction(ActionType.MigrateVmToServer, list, result -> {
            MigrateModel localModel = (MigrateModel) result.getState();
            localModel.stopProgress();
            cancel();
        }, model);
    }
}
#end_block

#method_before
private void onPowerAction(VdcActionType actionType, PowerActionParametersFactory<?> parametersFactory) {
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        list.add(parametersFactory.createActionParameters(vm));
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(actionType, list, result -> {
        ConfirmationModel localModel = (ConfirmationModel) result.getState();
        localModel.stopProgress();
        cancel();
    }, model);
}
#method_after
private void onPowerAction(ActionType actionType, PowerActionParametersFactory<?> parametersFactory) {
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<ActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        list.add(parametersFactory.createActionParameters(vm));
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(actionType, list, result -> {
        ConfirmationModel localModel = (ConfirmationModel) result.getState();
        localModel.stopProgress();
        cancel();
    }, model);
}
#end_block

#method_before
private void onShutdown() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    onPowerAction(VdcActionType.ShutdownVm, vm -> new ShutdownVmParameters(vm.getId(), true, model.getReason().getEntity()));
}
#method_after
private void onShutdown() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    onPowerAction(ActionType.ShutdownVm, vm -> new ShutdownVmParameters(vm.getId(), true, model.getReason().getEntity()));
}
#end_block

#method_before
private void onStop() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    onPowerAction(VdcActionType.StopVm, vm -> new StopVmParameters(vm.getId(), StopVmTypeEnum.NORMAL, model.getReason().getEntity()));
}
#method_after
private void onStop() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    onPowerAction(ActionType.StopVm, vm -> new StopVmParameters(vm.getId(), StopVmTypeEnum.NORMAL, model.getReason().getEntity()));
}
#end_block

#method_before
private void onReboot() {
    onPowerAction(VdcActionType.RebootVm, vm -> new VmOperationParameterBase(vm.getId()));
}
#method_after
private void onReboot() {
    onPowerAction(ActionType.RebootVm, vm -> new VmOperationParameterBase(vm.getId()));
}
#end_block

#method_before
private void pause() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        list.add(new VmOperationParameterBase(a.getId()));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.HibernateVm, list, result -> {
    }, null);
}
#method_after
private void pause() {
    ArrayList<ActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        list.add(new VmOperationParameterBase(a.getId()));
    }
    Frontend.getInstance().runMultipleAction(ActionType.HibernateVm, list, result -> {
    }, null);
}
#end_block

#method_before
private void run() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        list.add(new RunVmParams(a.getId()));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.RunVm, list, result -> {
    }, null);
}
#method_after
private void run() {
    ArrayList<ActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        list.add(new RunVmParams(a.getId()));
    }
    Frontend.getInstance().runMultipleAction(ActionType.RunVm, list, result -> {
    }, null);
}
#end_block

#method_before
private void onRemove() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    final ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    for (Entry<Guid, EntityModel> entry : vmsRemoveMap.entrySet()) {
        list.add(new RemoveVmParameters(entry.getKey(), false, (Boolean) entry.getValue().getEntity()));
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.RemoveVm, list, result -> {
        ConfirmationModel localModel = (ConfirmationModel) result.getState();
        localModel.stopProgress();
        cancel();
    }, model);
}
#method_after
private void onRemove() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    final ArrayList<ActionParametersBase> list = new ArrayList<>();
    for (Entry<Guid, EntityModel> entry : vmsRemoveMap.entrySet()) {
        list.add(new RemoveVmParameters(entry.getKey(), false, (Boolean) entry.getValue().getEntity()));
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(ActionType.RemoveVm, list, result -> {
        ConfirmationModel localModel = (ConfirmationModel) result.getState();
        localModel.stopProgress();
        cancel();
    }, model);
}
#end_block

#method_before
private void onChangeCD() {
    VM vm = getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    AttachCdModel model = (AttachCdModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (Objects.equals(model.getIsoImage().getSelectedItem(), vm.getCurrentCd())) {
        cancel();
        return;
    }
    String isoName = // $NON-NLS-1$
    Objects.equals(model.getIsoImage().getSelectedItem(), ConsoleModel.getEjectLabel()) ? // $NON-NLS-1$
    "" : model.getIsoImage().getSelectedItem();
    model.startProgress();
    Frontend.getInstance().runAction(VdcActionType.ChangeDisk, new ChangeDiskCommandParameters(vm.getId(), isoName), result -> {
        AttachCdModel attachCdModel = (AttachCdModel) result.getState();
        attachCdModel.stopProgress();
        cancel();
    }, model);
}
#method_after
private void onChangeCD() {
    VM vm = getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    AttachCdModel model = (AttachCdModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (Objects.equals(model.getIsoImage().getSelectedItem(), vm.getCurrentCd())) {
        cancel();
        return;
    }
    String isoName = // $NON-NLS-1$
    Objects.equals(model.getIsoImage().getSelectedItem(), ConsoleModel.getEjectLabel()) ? // $NON-NLS-1$
    "" : model.getIsoImage().getSelectedItem();
    model.startProgress();
    Frontend.getInstance().runAction(ActionType.ChangeDisk, new ChangeDiskCommandParameters(vm.getId(), isoName), result -> {
        AttachCdModel attachCdModel = (AttachCdModel) result.getState();
        attachCdModel.stopProgress();
        cancel();
    }, model);
}
#end_block

#method_before
private void updateExistingVm(final boolean applyCpuChangesLater) {
    final UnitVmModel model = (UnitVmModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    // runEditVM: should be true if Cluster hasn't changed or if
    // Cluster has changed and Editing it in the Backend has succeeded:
    VM selectedItem = getSelectedItem();
    Guid oldClusterID = selectedItem.getClusterId();
    Guid newClusterID = model.getSelectedCluster().getId();
    if (!oldClusterID.equals(newClusterID)) {
        ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId(), model.getCustomCompatibilityVersion().getSelectedItem());
        model.startProgress();
        Frontend.getInstance().runAction(VdcActionType.ChangeVMCluster, parameters, result -> {
            final VmListModel<Void> vmListModel = (VmListModel<Void>) result.getState();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                VM vm = vmListModel.getcurrentVm();
                VmManagementParametersBase updateVmParams = vmListModel.getUpdateVmParameters(applyCpuChangesLater);
                Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, vm.getId()), vmListModel);
            } else {
                vmListModel.getWindow().stopProgress();
            }
        }, this);
    } else {
        model.startProgress();
        VmManagementParametersBase updateVmParams = getUpdateVmParameters(applyCpuChangesLater);
        Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, getcurrentVm().getId()), this);
    }
}
#method_after
private void updateExistingVm(final boolean applyCpuChangesLater) {
    final UnitVmModel model = (UnitVmModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    // runEditVM: should be true if Cluster hasn't changed or if
    // Cluster has changed and Editing it in the Backend has succeeded:
    VM selectedItem = getSelectedItem();
    Guid oldClusterID = selectedItem.getClusterId();
    Guid newClusterID = model.getSelectedCluster().getId();
    if (!oldClusterID.equals(newClusterID)) {
        ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId(), model.getCustomCompatibilityVersion().getSelectedItem());
        model.startProgress();
        Frontend.getInstance().runAction(ActionType.ChangeVMCluster, parameters, result -> {
            final VmListModel<Void> vmListModel = (VmListModel<Void>) result.getState();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                VM vm = vmListModel.getcurrentVm();
                VmManagementParametersBase updateVmParams = vmListModel.getUpdateVmParameters(applyCpuChangesLater);
                Frontend.getInstance().runAction(ActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, vm.getId()), vmListModel);
            } else {
                vmListModel.getWindow().stopProgress();
            }
        }, this);
    } else {
        model.startProgress();
        VmManagementParametersBase updateVmParams = getUpdateVmParameters(applyCpuChangesLater);
        Frontend.getInstance().runAction(ActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, getcurrentVm().getId()), this);
    }
}
#end_block

#method_before
private void changeCD(Object sender, EventArgs e) {
    ChangeCDModel model = (ChangeCDModel) sender;
    // TODO: Patch!
    String isoName = model.getTitle();
    if (Objects.equals(isoName, ConstantsManager.getInstance().getConstants().noCds())) {
        return;
    }
    Object tempVar = getSelectedItem();
    VM vm = (VM) ((tempVar instanceof VM) ? tempVar : null);
    if (vm == null) {
        return;
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.ChangeDisk, new ArrayList<>(Arrays.asList(new VdcActionParametersBase[] { new ChangeDiskCommandParameters(vm.getId(), // $NON-NLS-1$
    Objects.equals(isoName, ConsoleModel.getEjectLabel()) ? "" : isoName) })), result -> {
    }, null);
}
#method_after
private void changeCD(Object sender, EventArgs e) {
    ChangeCDModel model = (ChangeCDModel) sender;
    // TODO: Patch!
    String isoName = model.getTitle();
    if (Objects.equals(isoName, ConstantsManager.getInstance().getConstants().noCds())) {
        return;
    }
    Object tempVar = getSelectedItem();
    VM vm = (VM) ((tempVar instanceof VM) ? tempVar : null);
    if (vm == null) {
        return;
    }
    Frontend.getInstance().runMultipleAction(ActionType.ChangeDisk, new ArrayList<>(Arrays.asList(new ActionParametersBase[] { new ChangeDiskCommandParameters(vm.getId(), // $NON-NLS-1$
    Objects.equals(isoName, ConsoleModel.getEjectLabel()) ? "" : isoName) })), result -> {
    }, null);
}
#end_block

#method_before
@Override
protected void updateActionsAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItemsWithStatusForExclusiveLock() : new ArrayList();
    boolean singleVmSelected = items.size() == 1;
    boolean vmsSelected = items.size() > 0;
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, VdcActionType.RunVm));
    getCloneVmCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, VdcActionType.CloneVm));
    getPauseCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, VdcActionType.HibernateVm));
    getShutdownCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, VdcActionType.StopVm));
    getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.getInstance().isRebootCommandExecutionAllowed(items));
    getMigrateCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(singleVmSelected && !getSelectedItem().isStateless() && !getSelectedItem().isPreviewSnapshot() && VdcActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(vmsSelected);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || singleVmSelected);
    getConsoleConnectCommand().setIsExecutionAllowed(isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(singleVmSelected && isConsoleEditEnabled());
    getCancelConvertCommand().setIsExecutionAllowed(isSelectedVmBeingConverted());
}
#method_after
@Override
protected void updateActionsAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItemsWithStatusForExclusiveLock() : new ArrayList();
    boolean singleVmSelected = items.size() == 1;
    boolean vmsSelected = items.size() > 0;
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(vmsSelected && ActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, ActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(vmsSelected && ActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, ActionType.RunVm));
    getCloneVmCommand().setIsExecutionAllowed(singleVmSelected && ActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, ActionType.CloneVm));
    getPauseCommand().setIsExecutionAllowed(vmsSelected && ActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, ActionType.HibernateVm));
    getShutdownCommand().setIsExecutionAllowed(vmsSelected && ActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, ActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(vmsSelected && ActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, ActionType.StopVm));
    getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.getInstance().isRebootCommandExecutionAllowed(items));
    getMigrateCommand().setIsExecutionAllowed(vmsSelected && ActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, ActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(vmsSelected && ActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, ActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(singleVmSelected && ActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, ActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(singleVmSelected && ActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, ActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(vmsSelected && ActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, ActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(singleVmSelected && !getSelectedItem().isStateless() && !getSelectedItem().isPreviewSnapshot() && ActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, ActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(singleVmSelected && ActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, ActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(singleVmSelected && ActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, ActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(vmsSelected);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || singleVmSelected);
    getConsoleConnectCommand().setIsExecutionAllowed(isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(singleVmSelected && isConsoleEditEnabled());
    getCancelConvertCommand().setIsExecutionAllowed(isSelectedVmBeingConverted());
}
#end_block

#method_before
@Test
public void testAuditLogTypeValueUniqueness() {
    BitSet bitset = new BitSet(bitSetSize);
    Set<Integer> nonUniqueValues = new TreeSet<>();
    for (ActionType vat : ActionType.values()) {
        if (bitset.get(vat.getValue())) {
            nonUniqueValues.add(vat.getValue());
        } else {
            bitset.set(vat.getValue());
        }
    }
    assertTrue("ActionType contains the following non unique values: " + nonUniqueValues, nonUniqueValues.isEmpty());
}
#method_after
@Test
public void testAuditLogTypeValueUniqueness() {
    BitSet bitset = new BitSet(bitSetSize);
    Set<Integer> nonUniqueValues = new TreeSet<>();
    for (ActionType at : ActionType.values()) {
        if (bitset.get(at.getValue())) {
            nonUniqueValues.add(at.getValue());
        } else {
            bitset.set(at.getValue());
        }
    }
    assertTrue("ActionType contains the following non unique values: " + nonUniqueValues, nonUniqueValues.isEmpty());
}
#end_block

#method_before
@Test
public void testCommandClassExistence() {
    CommandEnumTestUtils.testCommandsExist(ActionType.class, vat -> CommandsFactory.getCommandClass(vat.name()));
}
#method_after
@Test
public void testCommandClassExistence() {
    CommandEnumTestUtils.testCommandsExist(ActionType.class, at -> CommandsFactory.getCommandClass(at.name()));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
protected Map<String, Object>[] getVmsInfo() {
    List<String> vmsToUpdate = getParameters().getVmIds().stream().map(Guid::toString).collect(Collectors.toList());
    Map<String, Object>[] result = new Map[0];
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.FullList, new FullListVDSCommandParameters(getVdsId(), vmsToUpdate));
    if (vdsReturnValue.getSucceeded()) {
        result = (Map<String, Object>[]) vdsReturnValue.getReturnValue();
    }
    return result;
}
#method_after
@SuppressWarnings("unchecked")
protected Map<String, Object>[] getVmsInfo() {
    Map<String, Object>[] result = new Map[0];
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.FullList, new FullListVDSCommandParameters(getVdsId(), getParameters().getVmIds()));
    if (vdsReturnValue.getSucceeded()) {
        result = (Map<String, Object>[]) vdsReturnValue.getReturnValue();
    }
    return result;
}
#end_block

#method_before
@Override
protected void onBind() {
    super.onBind();
    registerHandler(getTable().getSelectionModel().addSelectionChangeHandler(event -> {
        // Update main model selection
        modelProvider.setSelectedItems(getSelectedItems());
        // Let others know that the table selection has changed
        fireTableSelectionChangeEvent();
        if (!isVisible()) {
            handlePlaceTransition();
        }
    }));
    registerHandler(getEventBus().addHandler(ApplySearchStringEvent.getType(), event -> {
        applySearchString(event.getSearchString());
    }));
    getView().setDetailPlaceTransitionHandler(this);
    this.breadCrumbs.setSelectionModel(getTable().getSelectionModel());
    searchStringCollector.markActivePrefix(modelProvider.getModel().getDefaultSearchString());
    String searchString = searchStringCollector.getSearchString(modelProvider.getModel().getSearchString());
    if (searchString != null) {
        // Someone set search string before we were instantiated, update the search string.
        applySearchString(searchString);
    }
}
#method_after
@Override
protected void onBind() {
    super.onBind();
    registerHandler(getTable().getSelectionModel().addSelectionChangeHandler(event -> {
        // Update main model selection
        modelProvider.setSelectedItems(getSelectedItems());
        // Let others know that the table selection has changed
        fireTableSelectionChangeEvent();
        if (!isVisible()) {
            handlePlaceTransition();
        }
    }));
    registerHandler(getEventBus().addHandler(ApplySearchStringEvent.getType(), event -> {
        applySearchString(event.getSearchString());
    }));
    getView().setDetailPlaceTransitionHandler(this);
    String searchString = searchStringCollector.getSearchStringPrefix(modelProvider.getModel().getSearchString());
    if (searchString != null) {
        // Someone set search string before we were instantiated, update the search string.
        applySearchString(searchString);
    }
}
#end_block

#method_before
@Override
protected void onReveal() {
    super.onReveal();
    setSubTabPanelVisible(false);
    getBreadCrumbs().clearActiveSubTab();
    getTable().resetScrollPosition();
    getView().setBreadCrumbs(getBreadCrumbs());
    if (getSearchPanelPresenterWidget() != null) {
        getView().setSearchPanel(getSearchPanelPresenterWidget().getView());
    }
}
#method_after
@Override
protected void onReveal() {
    super.onReveal();
    setSubTabPanelVisible(false);
    getBreadCrumbs().clearActiveSubTab();
    getTable().resetScrollPosition();
    getView().setBreadCrumbs(getBreadCrumbs());
    if (hasSearchPanelPresenterWidget()) {
        setInSlot(TYPE_SetSearchPanel, searchPanelPresenterWidget);
    }
}
#end_block

#method_before
protected void setTags(List<TagModel> tags) {
    if (searchPanelPresenterWidget != null) {
        searchPanelPresenterWidget.setTags(tags);
    }
}
#method_after
protected void setTags(List<TagModel> tags) {
    if (hasSearchPanelPresenterWidget()) {
        searchPanelPresenterWidget.setTags(tags);
    }
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    VmStatusColumn<VM> statusIconColumn = new VmStatusColumn<>();
    statusIconColumn.setContextMenuTitle(constants.statusIconVm());
    statusIconColumn.makeSortable(VmConditionFieldAutoCompleter.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(statusIconColumn, constants.empty(), "35px");
    VmTypeColumn typeColumn = new VmTypeColumn();
    typeColumn.setContextMenuTitle(constants.typeVm());
    typeColumn.makeSortable(VmConditionFieldAutoCompleter.TYPE);
    // $NON-NLS-1$
    getTable().addColumn(typeColumn, constants.empty(), "60px");
    AbstractTextColumn<VM> nameColumn = new AbstractLinkColumn<VM>(new FieldUpdater<VM, String>() {

        @Override
        public void update(int index, VM vm, String value) {
            // The link was clicked, now fire an event to switch to details.
            transitionHandler.handlePlaceTransition();
        }
    }) {

        @Override
        public String getValue(VM object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(VmConditionFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVm(), "120px");
    CommentColumn<VM> commentColumn = new CommentColumn<>();
    getTable().addColumnWithHtmlHeader(commentColumn, SafeHtmlUtils.fromSafeConstant(constants.commentLabel()), // $NON-NLS-1$
    "75px");
    AbstractTextColumn<VM> hostColumn = new AbstractLinkColumn<VM>(new FieldUpdater<VM, String>() {

        @Override
        public void update(int index, VM vm, String value) {
            // The link was clicked, now find cluster and switch to it.
            // $NON-NLS-1$ $NON-NLS-2$
            getModelProvider().getModel().setSearchString("vms: host = " + value + " and status=up");
            getModelProvider().getModel().search();
        }
    }) {

        @Override
        public String getValue(VM object) {
            return object.getRunOnVdsName();
        }
    };
    hostColumn.makeSortable(VmConditionFieldAutoCompleter.HOST);
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.hostVm(), "120px");
    AbstractTextColumn<VM> ipColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getIp();
        }
    };
    ipColumn.makeSortable(VmConditionFieldAutoCompleter.IP);
    // $NON-NLS-1$
    getTable().addColumn(ipColumn, constants.ipVm(), "120px");
    AbstractTextColumn<VM> fqdnColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getFqdn();
        }
    };
    fqdnColumn.makeSortable(VmConditionFieldAutoCompleter.FQDN);
    // $NON-NLS-1$
    getTable().addColumn(fqdnColumn, constants.fqdn(), "120px");
    AbstractTextColumn<VM> clusterColumn = new AbstractLinkColumn<VM>(new FieldUpdater<VM, String>() {

        @Override
        public void update(int index, VM vm, String value) {
            // The link was clicked, now find cluster and switch to it.
            // $NON-NLS-1$
            getModelProvider().getModel().setSearchString("vms: cluster = " + value);
        }
    }) {

        @Override
        public String getValue(VM object) {
            return object.getClusterName();
        }
    };
    clusterColumn.makeSortable(VmConditionFieldAutoCompleter.CLUSTER);
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVm(), "120px");
    AbstractTextColumn<VM> dcColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getStoragePoolName();
        }
    };
    dcColumn.makeSortable(VmConditionFieldAutoCompleter.DATACENTER);
    // $NON-NLS-1$
    getTable().addColumn(dcColumn, constants.dcVm(), "120px");
    getTable().addColumn(new ColumnResizeTableLineChartProgressBar<VM>(getTable(), VmConditionFieldAutoCompleter.MEM_USAGE) {

        @Override
        protected List<Integer> getProgressValues(VM object) {
            return object.getMemoryUsageHistory();
        }
    }, constants.memoryVm(), // $NON-NLS-1$
    "80px");
    getTable().addColumn(new ColumnResizeTableLineChartProgressBar<VM>(getTable(), VmConditionFieldAutoCompleter.CPU_USAGE) {

        @Override
        protected List<Integer> getProgressValues(VM object) {
            return object.getCpuUsageHistory();
        }
    }, constants.cpuVm(), // $NON-NLS-1$
    "80px");
    getTable().addColumn(new ColumnResizeTableLineChartProgressBar<VM>(getTable(), VmConditionFieldAutoCompleter.NETWORK_USAGE) {

        @Override
        protected List<Integer> getProgressValues(VM object) {
            return object.getNetworkUsageHistory();
        }
    }, constants.networkVm(), // $NON-NLS-1$
    "80px");
    AbstractTextColumn<VM> graphicsColumn = new AbstractEnumColumn<VM, UnitVmModel.GraphicsTypes>() {

        @Override
        protected UnitVmModel.GraphicsTypes getRawValue(VM vm) {
            if ((vm.getStatus() == VMStatus.Down) || (vm.getStatus() == VMStatus.ImageLocked)) {
                return UnitVmModel.GraphicsTypes.NONE;
            }
            Map<GraphicsType, GraphicsInfo> graphicsInfos = vm.getGraphicsInfos();
            return UnitVmModel.GraphicsTypes.fromGraphicsTypes(graphicsInfos.keySet());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(graphicsColumn, constants.graphicsVm(), "70px");
    AbstractTextColumn<VM> statusColumn = new AbstractEnumColumn<VM, VMStatus>() {

        @Override
        public VMStatus getRawValue(VM object) {
            return object.getStatus();
        }

        @Override
        public String getValue(VM vm) {
            if (vm.getStatus() == VMStatus.MigratingFrom) {
                // will be rendered by progress column
                return null;
            }
            if (vm.getBackgroundOperationDescription() != null) {
                // will be rendered by progress column
                return null;
            }
            return super.getValue(vm);
        }
    };
    MigrationProgressColumn migrationProgressColumn = new MigrationProgressColumn();
    ImportProgressColumn importProgressColumn = new ImportProgressColumn();
    ReasonColumn<VM> reasonColumn = new ReasonColumn<VM>() {

        @Override
        protected String getReason(VM value) {
            return value.getStopReason();
        }
    };
    List<HasCell<VM, ?>> list = new ArrayList<>();
    list.add(statusColumn);
    list.add(reasonColumn);
    list.add(migrationProgressColumn);
    list.add(importProgressColumn);
    Cell<VM> compositeCell = new StatusCompositeCell<>(list);
    AbstractColumn<VM, VM> statusTextColumn = new AbstractColumn<VM, VM>(compositeCell) {

        @Override
        public VM getValue(VM object) {
            return object;
        }

        @Override
        public SafeHtml getTooltip(VM value) {
            String stopReason = value.getStopReason();
            if (stopReason != null && !stopReason.trim().isEmpty()) {
                return SafeHtmlUtils.fromString(stopReason);
            }
            return null;
        }
    };
    statusTextColumn.makeSortable(VmConditionFieldAutoCompleter.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(statusTextColumn, constants.statusVm(), "120px");
    AbstractTextColumn<VM> uptimeColumn = new AbstractUptimeColumn<VM>() {

        @Override
        public Double getRawValue(VM object) {
            return object.getRoundedElapsedTime();
        }
    };
    uptimeColumn.makeSortable(VmConditionFieldAutoCompleter.UPTIME);
    // $NON-NLS-1$
    getTable().addColumn(uptimeColumn, constants.uptimeVm(), "100px");
    AbstractTextColumn<VM> descriptionColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getDescription();
        }
    };
    descriptionColumn.makeSortable(VmConditionFieldAutoCompleter.DESCRIPTION);
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.description(), "150px");
    // 
    // Buttons/menu items
    // 
    addButtonToActionGroup(getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.newVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVmCommand();
        }
    }));
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VM>(constants.restoreVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getImportVmCommand();
        }
    }));
    addButtonToActionGroup(getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.editVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    }));
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VM>(constants.removeVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    }));
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VM>(constants.cloneVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCloneVmCommand();
        }
    }));
    addDividerToKebab();
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VM>(constants.runOnceVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunOnceCommand();
        }
    }));
    addButtonToActionGroup(getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.runVm(), IconType.PLAY) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunCommand();
        }
    }));
    addButtonToActionGroup(getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.suspendVm(), IconType.MOON_O) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getPauseCommand();
        }
    }));
    addButtonToActionGroup(getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.shutDownVm(), IconType.STOP) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getShutdownCommand();
        }
    }));
    addButtonToActionGroup(getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.powerOffVm(), IconType.POWER_OFF) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    }));
    addButtonToActionGroup(getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.rebootVm(), IconType.REPEAT) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRebootCommand();
        }
    }));
    List<ActionButtonDefinition<VM>> consoleOptionsSubActions = new LinkedList<>();
    consoleOptionsSubActions.add(new UiCommandButtonDefinition<VM>(eventBus, constants.consoleOptions()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditConsoleCommand();
        }
    });
    // TODO: separator
    addButtonToActionGroup(getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.consoleVm(), IconType.DESKTOP) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConsoleConnectCommand();
        }
    }, new DropdownActionButton<>(consoleOptionsSubActions, new DropdownActionButton.SelectedItemsProvider<VM>() {

        @Override
        public List<VM> getSelectedItems() {
            return getMainModel().getSelectedItems();
        }
    }, true, IconType.DESKTOP)));
    addDividerToKebab();
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VM>(constants.consoleOptions(), // $NON-NLS-1$
    CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditConsoleCommand();
        }
    }));
    addDividerToKebab();
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VM>(constants.migrateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMigrateCommand();
        }
    }));
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VM>(constants.cancelMigrationVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCancelMigrateCommand();
        }
    }));
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VM>(constants.cancelConvertVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCancelConvertCommand();
        }
    }));
    addDividerToKebab();
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VM>(constants.makeTemplateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewTemplateCommand();
        }
    }));
    addDividerToKebab();
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VM>(constants.exportVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getExportCommand();
        }
    }));
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VM>(constants.createSnapshotVM()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCreateSnapshotCommand();
        }
    }));
    addButtonToActionGroup(getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.changeCdVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getChangeCdCommand();
        }
    }));
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VM>(constants.assignTagsVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    }));
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminImageButtonDefinition<VM>(constants.guideMeVm(), IconType.SUPPORT, true) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getGuideCommand();
        }
    }));
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    VmStatusColumn<VM> statusIconColumn = new VmStatusColumn<>();
    statusIconColumn.setContextMenuTitle(constants.statusIconVm());
    statusIconColumn.makeSortable(VmConditionFieldAutoCompleter.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(statusIconColumn, constants.empty(), "35px");
    VmTypeColumn typeColumn = new VmTypeColumn();
    typeColumn.setContextMenuTitle(constants.typeVm());
    typeColumn.makeSortable(VmConditionFieldAutoCompleter.TYPE);
    // $NON-NLS-1$
    getTable().addColumn(typeColumn, constants.empty(), "60px");
    AbstractTextColumn<VM> nameColumn = new AbstractLinkColumn<VM>(new FieldUpdater<VM, String>() {

        @Override
        public void update(int index, VM vm, String value) {
            // The link was clicked, now fire an event to switch to details.
            transitionHandler.handlePlaceTransition();
        }
    }) {

        @Override
        public String getValue(VM object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(VmConditionFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVm(), "120px");
    CommentColumn<VM> commentColumn = new CommentColumn<>();
    getTable().addColumnWithHtmlHeader(commentColumn, SafeHtmlUtils.fromSafeConstant(constants.commentLabel()), // $NON-NLS-1$
    "75px");
    AbstractTextColumn<VM> hostColumn = new AbstractLinkColumn<VM>(new FieldUpdater<VM, String>() {

        @Override
        public void update(int index, VM vm, String value) {
            // The link was clicked, now find cluster and switch to it.
            // $NON-NLS-1$ $NON-NLS-2$
            getModelProvider().getModel().setSearchString("vms: host = " + value + " and status=up");
            getModelProvider().getModel().search();
        }
    }) {

        @Override
        public String getValue(VM object) {
            return object.getRunOnVdsName();
        }
    };
    hostColumn.makeSortable(VmConditionFieldAutoCompleter.HOST);
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.hostVm(), "120px");
    AbstractTextColumn<VM> ipColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getIp();
        }
    };
    ipColumn.makeSortable(VmConditionFieldAutoCompleter.IP);
    // $NON-NLS-1$
    getTable().addColumn(ipColumn, constants.ipVm(), "120px");
    AbstractTextColumn<VM> fqdnColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getFqdn();
        }
    };
    fqdnColumn.makeSortable(VmConditionFieldAutoCompleter.FQDN);
    // $NON-NLS-1$
    getTable().addColumn(fqdnColumn, constants.fqdn(), "120px");
    AbstractTextColumn<VM> clusterColumn = new AbstractLinkColumn<VM>(new FieldUpdater<VM, String>() {

        @Override
        public void update(int index, VM vm, String value) {
            // The link was clicked, now find cluster and switch to it.
            // $NON-NLS-1$
            getModelProvider().getModel().setSearchString("vms: cluster = " + value);
        }
    }) {

        @Override
        public String getValue(VM object) {
            return object.getClusterName();
        }
    };
    clusterColumn.makeSortable(VmConditionFieldAutoCompleter.CLUSTER);
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVm(), "120px");
    AbstractTextColumn<VM> dcColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getStoragePoolName();
        }
    };
    dcColumn.makeSortable(VmConditionFieldAutoCompleter.DATACENTER);
    // $NON-NLS-1$
    getTable().addColumn(dcColumn, constants.dcVm(), "120px");
    getTable().addColumn(new ColumnResizeTableLineChartProgressBar<VM>(getTable(), VmConditionFieldAutoCompleter.MEM_USAGE) {

        @Override
        protected List<Integer> getProgressValues(VM object) {
            return object.getMemoryUsageHistory();
        }
    }, constants.memoryVm(), // $NON-NLS-1$
    "80px");
    getTable().addColumn(new ColumnResizeTableLineChartProgressBar<VM>(getTable(), VmConditionFieldAutoCompleter.CPU_USAGE) {

        @Override
        protected List<Integer> getProgressValues(VM object) {
            return object.getCpuUsageHistory();
        }
    }, constants.cpuVm(), // $NON-NLS-1$
    "80px");
    getTable().addColumn(new ColumnResizeTableLineChartProgressBar<VM>(getTable(), VmConditionFieldAutoCompleter.NETWORK_USAGE) {

        @Override
        protected List<Integer> getProgressValues(VM object) {
            return object.getNetworkUsageHistory();
        }
    }, constants.networkVm(), // $NON-NLS-1$
    "80px");
    AbstractTextColumn<VM> graphicsColumn = new AbstractEnumColumn<VM, UnitVmModel.GraphicsTypes>() {

        @Override
        protected UnitVmModel.GraphicsTypes getRawValue(VM vm) {
            if ((vm.getStatus() == VMStatus.Down) || (vm.getStatus() == VMStatus.ImageLocked)) {
                return UnitVmModel.GraphicsTypes.NONE;
            }
            Map<GraphicsType, GraphicsInfo> graphicsInfos = vm.getGraphicsInfos();
            return UnitVmModel.GraphicsTypes.fromGraphicsTypes(graphicsInfos.keySet());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(graphicsColumn, constants.graphicsVm(), "70px");
    AbstractTextColumn<VM> statusColumn = new AbstractEnumColumn<VM, VMStatus>() {

        @Override
        public VMStatus getRawValue(VM object) {
            return object.getStatus();
        }

        @Override
        public String getValue(VM vm) {
            if (vm.getStatus() == VMStatus.MigratingFrom) {
                // will be rendered by progress column
                return null;
            }
            if (vm.getBackgroundOperationDescription() != null) {
                // will be rendered by progress column
                return null;
            }
            return super.getValue(vm);
        }
    };
    MigrationProgressColumn migrationProgressColumn = new MigrationProgressColumn();
    ImportProgressColumn importProgressColumn = new ImportProgressColumn();
    ReasonColumn<VM> reasonColumn = new ReasonColumn<VM>() {

        @Override
        protected String getReason(VM value) {
            return value.getStopReason();
        }
    };
    List<HasCell<VM, ?>> list = new ArrayList<>();
    list.add(statusColumn);
    list.add(reasonColumn);
    list.add(migrationProgressColumn);
    list.add(importProgressColumn);
    Cell<VM> compositeCell = new StatusCompositeCell<>(list);
    AbstractColumn<VM, VM> statusTextColumn = new AbstractColumn<VM, VM>(compositeCell) {

        @Override
        public VM getValue(VM object) {
            return object;
        }

        @Override
        public SafeHtml getTooltip(VM value) {
            String stopReason = value.getStopReason();
            if (stopReason != null && !stopReason.trim().isEmpty()) {
                return SafeHtmlUtils.fromString(stopReason);
            }
            return null;
        }
    };
    statusTextColumn.makeSortable(VmConditionFieldAutoCompleter.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(statusTextColumn, constants.statusVm(), "120px");
    AbstractTextColumn<VM> uptimeColumn = new AbstractUptimeColumn<VM>() {

        @Override
        public Double getRawValue(VM object) {
            return object.getElapsedTime();
        }
    };
    uptimeColumn.makeSortable(VmConditionFieldAutoCompleter.UPTIME);
    // $NON-NLS-1$
    getTable().addColumn(uptimeColumn, constants.uptimeVm(), "100px");
    AbstractTextColumn<VM> descriptionColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getDescription();
        }
    };
    descriptionColumn.makeSortable(VmConditionFieldAutoCompleter.DESCRIPTION);
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.description(), "150px");
    // 
    // Buttons/menu items
    // 
    addButtonToActionGroup(getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.newVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVmCommand();
        }
    }));
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VM>(constants.restoreVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getImportVmCommand();
        }
    }));
    addButtonToActionGroup(getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.editVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    }));
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VM>(constants.removeVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    }));
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VM>(constants.cloneVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCloneVmCommand();
        }
    }));
    addDividerToKebab();
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VM>(constants.runOnceVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunOnceCommand();
        }
    }));
    addButtonToActionGroup(getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.runVm(), IconType.PLAY) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunCommand();
        }
    }));
    addButtonToActionGroup(getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.suspendVm(), IconType.MOON_O) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getPauseCommand();
        }
    }));
    addButtonToActionGroup(getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.shutDownVm(), IconType.STOP) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getShutdownCommand();
        }
    }));
    addButtonToActionGroup(getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.powerOffVm(), IconType.POWER_OFF) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    }));
    addButtonToActionGroup(getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.rebootVm(), IconType.REPEAT) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRebootCommand();
        }
    }));
    List<ActionButtonDefinition<VM>> consoleOptionsSubActions = new LinkedList<>();
    consoleOptionsSubActions.add(new UiCommandButtonDefinition<VM>(eventBus, constants.consoleOptions()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditConsoleCommand();
        }
    });
    // TODO: separator
    addButtonToActionGroup(getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.consoleVm(), IconType.DESKTOP) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConsoleConnectCommand();
        }
    }, new DropdownActionButton<>(consoleOptionsSubActions, new DropdownActionButton.SelectedItemsProvider<VM>() {

        @Override
        public List<VM> getSelectedItems() {
            return getMainModel().getSelectedItems();
        }
    }, true, IconType.DESKTOP)));
    addDividerToKebab();
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VM>(constants.consoleOptions(), // $NON-NLS-1$
    CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditConsoleCommand();
        }
    }));
    addDividerToKebab();
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VM>(constants.migrateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMigrateCommand();
        }
    }));
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VM>(constants.cancelMigrationVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCancelMigrateCommand();
        }
    }));
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VM>(constants.cancelConvertVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCancelConvertCommand();
        }
    }));
    addDividerToKebab();
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VM>(constants.makeTemplateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewTemplateCommand();
        }
    }));
    addDividerToKebab();
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VM>(constants.exportVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getExportCommand();
        }
    }));
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VM>(constants.createSnapshotVM()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCreateSnapshotCommand();
        }
    }));
    addButtonToActionGroup(getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.changeCdVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getChangeCdCommand();
        }
    }));
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminButtonDefinition<VM>(constants.assignTagsVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    }));
    addMenuItemToKebab(getTable().addMenuListItem(new WebAdminImageButtonDefinition<VM>(constants.guideMeVm(), IconType.SUPPORT, true) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getGuideCommand();
        }
    }));
}
#end_block

#method_before
public void updateSelectedRows() {
    if (updateToFirstRow) {
        updateToFirstRow = false;
        Collection<T> items = listModelProvider.getModel().getItems();
        if (items instanceof List) {
            final List<T> itemsAsList = (List<T>) items;
            if (!itemsAsList.isEmpty()) {
                Scheduler.get().scheduleDeferred(() -> {
                    T firstItem = itemsAsList.get(0);
                    selectionModel.setSelected(firstItem, true);
                    listModelProvider.getModel().setSelectedItem(firstItem);
                    currentSelectedItemWidget = createSelectionDropDown(getName(firstItem));
                });
            }
        }
    } else if (updateToLastRow) {
        updateToLastRow = false;
        Collection<T> items = listModelProvider.getModel().getItems();
        if (items instanceof List) {
            final List<T> itemsAsList = (List<T>) items;
            if (!itemsAsList.isEmpty()) {
                Scheduler.get().scheduleDeferred(() -> {
                    T lastItem = itemsAsList.get(itemsAsList.size() - 1);
                    selectionModel.setSelected(lastItem, true);
                    listModelProvider.getModel().setSelectedItem(lastItem);
                    currentSelectedItemWidget = createSelectionDropDown(getName(lastItem));
                });
            }
        }
    }
    buildCrumbs();
}
#method_after
public void updateSelectedRows() {
    if (updateToFirstRow) {
        updateToFirstRow = false;
        Collection<T> items = listModelProvider.getModel().getItems();
        if (items instanceof List) {
            final List<T> itemsAsList = (List<T>) items;
            if (!itemsAsList.isEmpty()) {
                Scheduler.get().scheduleDeferred(() -> {
                    T firstItem = itemsAsList.get(0);
                    selectionModel.setSelected(firstItem, true);
                    listModelProvider.getModel().setSelectedItem(firstItem);
                    currentSelectedItemWidget = createSelectionDropDown(getName(firstItem));
                });
            }
        }
    } else if (updateToLastRow) {
        updateToLastRow = false;
        Collection<T> items = listModelProvider.getModel().getItems();
        if (items instanceof List) {
            final List<T> itemsAsList = (List<T>) items;
            if (!itemsAsList.isEmpty()) {
                Scheduler.get().scheduleDeferred(() -> {
                    T lastItem = itemsAsList.get(itemsAsList.size() - 1);
                    selectionModel.setSelected(lastItem, true);
                    listModelProvider.getModel().setSelectedItem(lastItem);
                    currentSelectedItemWidget = createSelectionDropDown(getName(lastItem));
                });
            }
        }
    }
    if (listModelProvider.getModel().getSelectedItem() != null && detailTabsShowing) {
        currentSelectedItemWidget = createSelectionDropDown(getName((T) listModelProvider.getModel().getSelectedItem()));
    }
    buildCrumbs();
}
#end_block

#method_before
public void clearActiveSubTab() {
    currentSelectedItemWidget = null;
    buildCrumbs();
}
#method_after
public void clearActiveSubTab() {
    currentSelectedItemWidget = null;
    detailTabsShowing = false;
    buildCrumbs();
}
#end_block

#method_before
public void setActiveSubTab(String title) {
    currentSelectedItemWidget = createSelectionDropDown(getName((T) listModelProvider.getModel().getSelectedItem()));
    buildCrumbs();
}
#method_after
public void setActiveSubTab(String title) {
    detailTabsShowing = true;
    currentSelectedItemWidget = createSelectionDropDown(getName((T) listModelProvider.getModel().getSelectedItem()));
    buildCrumbs();
}
#end_block

#method_before
protected void preSearchCalled(VM vm) {
    // $NON-NLS-1$ $NON-NLS-2$
    setSearchString("events: vm.name=" + vm.getName() + " and vm.name != \"\"");
}
#method_after
protected void preSearchCalled(VM vm) {
    // TODO: Find out why events: vm.name=XX is returning events without vm.name
    // $NON-NLS-1$ $NON-NLS-2$
    setSearchString("events: vm.name=" + vm.getName() + " and vm.name != \"\"");
}
#end_block

#method_before
private VmPropertiesUtils mockVmPropertiesUtils() throws InitializationException {
    VmPropertiesUtils utils = spy(new VmPropertiesUtils());
    doReturn("sap_agent=^(true|false)$;sndbuf=^[0-9]+$;" + "vhost=^(([a-zA-Z0-9_]*):(true|false))(,(([a-zA-Z0-9_]*):(true|false)))*$;" + "viodiskcache=^(none|writeback|writethrough)$;" + "mdev_type=^.*$;hugepages=^(true|false)|([0-9]+)$;hugepagesz=^[0-9]+$").when(utils).getPredefinedVMProperties(any(Version.class));
    doReturn("").when(utils).getUserdefinedVMProperties(any(Version.class));
    doReturn(new HashSet<>(Arrays.asList(Version.v3_6, Version.v4_0))).when(utils).getSupportedClusterLevels();
    doReturn(utils).when(runVmValidator).getVmPropertiesUtils();
    utils.init();
    return utils;
}
#method_after
private VmPropertiesUtils mockVmPropertiesUtils() throws InitializationException {
    VmPropertiesUtils utils = spy(new VmPropertiesUtils());
    doReturn("sap_agent=^(true|false)$;sndbuf=^[0-9]+$;" + "vhost=^(([a-zA-Z0-9_]*):(true|false))(,(([a-zA-Z0-9_]*):(true|false)))*$;" + "viodiskcache=^(none|writeback|writethrough)$;" + "mdev_type=^.*$;hugepages=^[0-9]+$").when(utils).getPredefinedVMProperties(any(Version.class));
    doReturn("").when(utils).getUserdefinedVMProperties(any(Version.class));
    doReturn(new HashSet<>(Arrays.asList(Version.v3_6, Version.v4_0))).when(utils).getSupportedClusterLevels();
    doReturn(utils).when(runVmValidator).getVmPropertiesUtils();
    utils.init();
    return utils;
}
#end_block

#method_before
@Override
public List<T> getSelectedItems() {
    if (getDataProvider().getModel().isSingleSelectionOnly()) {
        return (List<T>) Collections.singletonList(((SingleSelectionModel<T>) getDataProvider().getModel().getSelectionModel()).getSelectedObject());
    } else {
        return ((OrderedMultiSelectionModel<T>) getDataProvider().getModel().getSelectionModel()).getSelectedList();
    }
}
#method_after
@Override
public List<T> getSelectedItems() {
    return getDataProvider().getModel().getSelectedObjects();
}
#end_block

#method_before
private VmPropertiesUtils mockVmPropertiesUtils() throws InitializationException {
    VmPropertiesUtils utils = spy(new VmPropertiesUtils());
    doReturn("sap_agent=^(true|false)$;sndbuf=^[0-9]+$;" + "vhost=^(([a-zA-Z0-9_]*):(true|false))(,(([a-zA-Z0-9_]*):(true|false)))*$;" + "viodiskcache=^(none|writeback|writethrough)$" + "mdev_type=^.*$").when(utils).getPredefinedVMProperties(any(Version.class));
    doReturn("").when(utils).getUserdefinedVMProperties(any(Version.class));
    doReturn(new HashSet<>(Arrays.asList(Version.v3_6, Version.v4_0))).when(utils).getSupportedClusterLevels();
    doReturn(utils).when(runVmValidator).getVmPropertiesUtils();
    utils.init();
    return utils;
}
#method_after
private VmPropertiesUtils mockVmPropertiesUtils() throws InitializationException {
    VmPropertiesUtils utils = spy(new VmPropertiesUtils());
    doReturn("sap_agent=^(true|false)$;sndbuf=^[0-9]+$;" + "vhost=^(([a-zA-Z0-9_]*):(true|false))(,(([a-zA-Z0-9_]*):(true|false)))*$;" + "viodiskcache=^(none|writeback|writethrough)$;" + "mdev_type=^.*$").when(utils).getPredefinedVMProperties(any(Version.class));
    doReturn("").when(utils).getUserdefinedVMProperties(any(Version.class));
    doReturn(new HashSet<>(Arrays.asList(Version.v3_6, Version.v4_0))).when(utils).getSupportedClusterLevels();
    doReturn(utils).when(runVmValidator).getVmPropertiesUtils();
    utils.init();
    return utils;
}
#end_block

#method_before
protected void proceedProxyReturnValue() {
    EngineError returnStatus = getReturnValueFromStatus(getReturnStatus());
    VDSExceptionBase outEx;
    switch(returnStatus) {
        case Done:
            return;
        case recovery:
            outEx = new VDSRecoveringException(returnStatus, getReturnStatus().message);
            break;
        case SpmStatusError:
            outEx = new IRSNonOperationalException(getReturnStatus().message);
            break;
        case StoragePoolMasterNotFound:
        case StoragePoolTooManyMasters:
        case StoragePoolWrongMaster:
        case StoragePoolHasPotentialMaster:
        case StorageDomainMasterError:
            outEx = new IRSNoMasterDomainException(getReturnStatus().message);
            break;
        case UnicodeArgumentException:
            outEx = new IRSUnicodeArgumentException(getReturnStatus().message);
            break;
        case TooManyDomainsInStoragePoolError:
        case StorageDomainAlreadyAttached:
        case StorageDomainDescriptionTooLongError:
        case TooManyPVsInVG:
        case createIllegalVolumeSnapshotError:
        case prepareIllegalVolumeError:
        case createVolumeRollbackError:
        case InvalidParameterException:
        case InvalidDefaultExceptionException:
        case NotImplementedException:
        case OperationInProgress:
        case MiscDirCleanupFailure:
        case createVolumeSizeError:
        case IncorrectFormat:
        case VolumeIsBusy:
        case VolumeImageHasChildren:
        case VolumeUnlinkError:
        case OrphanVolumeError:
        case VolumeAlreadyExists:
        case VolumeNonWritable:
        case VolumeNonShareable:
        case VolumeCannotGetParent:
        case SharedVolumeNonWritable:
        case InternalVolumeNonWritable:
        case CannotDeleteSharedVolume:
        case NonLeafVolumeNotWritable:
        case ImagesActionError:
        case ImageValidationError:
        case ImageDeleteError:
        case ImageIsNotEmpty:
        case ImageIsNotLegalChain:
        case OverwriteImageError:
        case MoveTemplateImageError:
        case StoragePoolDisconnectionError:
        case StoragePoolAlreadyExists:
        case IsoCannotBeMasterDomain:
        case CannotConnectMultiplePools:
        case BackupCannotBeMasterDomain:
        case StoragePoolConnected:
        case StoragePoolDescriptionTooLongError:
        case StorageDomainNotInPool:
        case StorageDomainNotEmpty:
        case StorageDomainMetadataCreationError:
        case StorageDomainMetadataFileMissing:
        case StorageDomainMetadataNotFound:
        case StorageDomainAlreadyExists:
        case StorageDomainMasterUnmountError:
        case BlockStorageDomainMasterFSCKError:
        case StorageDomainLayoutError:
        case StorageDomainTypeError:
        case StorageDomainNotMemberOfPool:
        case StorageDomainStatusError:
        case StorageDomainCheckError:
        case StorageDomainTypeNotBackup:
        case StorageDomainStateTransitionIllegal:
        case StorageDomainActive:
        case CannotDetachMasterStorageDomain:
        case StorageDomainInsufficientPermissions:
        case StorageDomainClassError:
        case StorageDomainIsMadeFromTooManyPVs:
        case InvalidTask:
        case UnknownTask:
        case TaskClearError:
        case TaskNotFinished:
        case InvalidTaskType:
        case AddTaskError:
        case TaskInProgress:
        case TaskStateError:
        case TaskAborted:
        case TaskPersistError:
        case InvalidJob:
        case InvalidRecovery:
        case InvalidTaskMng:
        case TaskStateTransitionError:
        case TaskHasRefs:
        case VolumeGroupSizeError:
        case VolumeGroupAlreadyExistsError:
        case VolumeGroupUninitialized:
        case VolumeGroupHasDomainTag:
        case CannotRemoveLogicalVolume:
        case CannotDeactivateLogicalVolume:
        case CannotActivateLogicalVolume:
        case LogicalVolumePermissionsError:
        case LogicalVolumeAlreadyExists:
        case PartitionedPhysDev:
        case DomainAlreadyLocked:
        case DomainLockDoesNotExist:
        case MetaDataKeyError:
        case MetaDataSealIsBroken:
        case MetaDataValidationError:
        case MetaDataMappingError:
        case MetaDataParamError:
        case MetadataOverflowError:
        case ImportUnknownType:
        case ExportError:
        case MergeVolumeRollbackError:
        case ActionStopped:
        case FAILED_CHANGE_CD_IS_MOUNTED:
        case UnsupportedDomainVersion:
        case CurrentVersionTooAdvancedError:
        case iSCSILogoutError:
        case iSCSIDiscoveryError:
        case ISCSI_LOGIN_AUTH_ERROR:
        case PoolUpgradeInProgress:
        case MixedSDVersionError:
        case NoSpaceLeftOnDomain:
        case ImageDoesNotExistInDomainError:
        case NO_IMPLEMENTATION:
        case VOLUME_WAS_NOT_PREPARED_BEFORE_TEARDOWN:
        case IMAGES_NOT_SUPPORTED_ERROR:
        case GET_FILE_LIST_ERROR:
        case STORAGE_DOMAIN_REFRESH_ERROR:
        case VOLUME_GROUP_BLOCK_SIZE_ERROR:
        case MIGRATION_DEST_INVALID_HOSTNAME:
        case ResourceTimeout:
        case HOT_PLUG_UNPLUG_CPU_ERROR:
        case DEVICE_BLOCK_SIZE_NOT_SUPPORTED:
        case V2V_JOB_DOESNT_EXIST:
        case V2V_NO_SUCH_OVF:
        case V2V_JOB_NOT_DONE:
        case V2V_JOB_ALREADY_EXIST:
        case UnsupportedGlusterVolumeReplicaCountError:
            if (this instanceof IrsBrokerCommand || this instanceof StorageJobVDSCommand) {
                outEx = new IrsOperationFailedNoFailoverException(getReturnStatus().message);
            } else {
                outEx = new VDSErrorException(String.format("Failed in vdscommand to %1$s, error = %2$s", getCommandName(), getReturnStatus().message));
            }
            break;
        case TooManyTasksInPool:
        case VDS_NETWORK_ERROR:
        case ERR_BAD_ADDR:
            outEx = new VDSNetworkException(getReturnStatus().message);
            break;
        default:
            log.error("Failed in '{}' method", getCommandName());
            outEx = createException();
            break;
    }
    VDSError tempVar = new VDSError();
    tempVar.setCode(returnStatus);
    tempVar.setMessage(getReturnStatus().message);
    outEx.setVdsError(tempVar);
    logToAuditIfNeeded();
    throw outEx;
}
#method_after
protected void proceedProxyReturnValue() {
    EngineError returnStatus = getReturnValueFromStatus(getReturnStatus());
    VDSExceptionBase outEx;
    switch(returnStatus) {
        case Done:
            return;
        case recovery:
            outEx = new VDSRecoveringException(returnStatus, getReturnStatus().message);
            break;
        case SpmStatusError:
            outEx = new IRSNonOperationalException(getReturnStatus().message);
            break;
        case StoragePoolMasterNotFound:
        case StoragePoolTooManyMasters:
        case StoragePoolWrongMaster:
        case StoragePoolHasPotentialMaster:
        case StorageDomainMasterError:
            outEx = new IRSNoMasterDomainException(getReturnStatus().message);
            break;
        case UnicodeArgumentException:
            outEx = new IRSUnicodeArgumentException(getReturnStatus().message);
            break;
        case TooManyDomainsInStoragePoolError:
        case StorageDomainAlreadyAttached:
        case StorageDomainDescriptionTooLongError:
        case TooManyPVsInVG:
        case createIllegalVolumeSnapshotError:
        case prepareIllegalVolumeError:
        case createVolumeRollbackError:
        case InvalidParameterException:
        case InvalidDefaultExceptionException:
        case NotImplementedException:
        case OperationInProgress:
        case MiscDirCleanupFailure:
        case createVolumeSizeError:
        case IncorrectFormat:
        case VolumeIsBusy:
        case VolumeImageHasChildren:
        case VolumeUnlinkError:
        case OrphanVolumeError:
        case VolumeAlreadyExists:
        case VolumeNonWritable:
        case VolumeNonShareable:
        case VolumeCannotGetParent:
        case SharedVolumeNonWritable:
        case InternalVolumeNonWritable:
        case CannotDeleteSharedVolume:
        case NonLeafVolumeNotWritable:
        case ImagesActionError:
        case ImageValidationError:
        case ImageDeleteError:
        case ImageIsNotEmpty:
        case ImageIsNotLegalChain:
        case OverwriteImageError:
        case MoveTemplateImageError:
        case StoragePoolDisconnectionError:
        case StoragePoolAlreadyExists:
        case IsoCannotBeMasterDomain:
        case CannotConnectMultiplePools:
        case BackupCannotBeMasterDomain:
        case StoragePoolConnected:
        case StoragePoolDescriptionTooLongError:
        case StorageDomainNotInPool:
        case StorageDomainNotEmpty:
        case StorageDomainMetadataCreationError:
        case StorageDomainMetadataFileMissing:
        case StorageDomainMetadataNotFound:
        case StorageDomainAlreadyExists:
        case StorageDomainMasterUnmountError:
        case BlockStorageDomainMasterFSCKError:
        case StorageDomainLayoutError:
        case StorageDomainTypeError:
        case StorageDomainNotMemberOfPool:
        case StorageDomainStatusError:
        case StorageDomainCheckError:
        case StorageDomainTypeNotBackup:
        case StorageDomainStateTransitionIllegal:
        case StorageDomainActive:
        case CannotDetachMasterStorageDomain:
        case StorageDomainInsufficientPermissions:
        case StorageDomainClassError:
        case StorageDomainIsMadeFromTooManyPVs:
        case InvalidTask:
        case UnknownTask:
        case TaskClearError:
        case TaskNotFinished:
        case InvalidTaskType:
        case AddTaskError:
        case TaskInProgress:
        case TaskStateError:
        case TaskAborted:
        case TaskPersistError:
        case InvalidJob:
        case InvalidRecovery:
        case InvalidTaskMng:
        case TaskStateTransitionError:
        case TaskHasRefs:
        case VolumeGroupSizeError:
        case VolumeGroupAlreadyExistsError:
        case VolumeGroupUninitialized:
        case VolumeGroupHasDomainTag:
        case CannotRemoveLogicalVolume:
        case CannotDeactivateLogicalVolume:
        case CannotActivateLogicalVolume:
        case LogicalVolumePermissionsError:
        case LogicalVolumeAlreadyExists:
        case PartitionedPhysDev:
        case DomainAlreadyLocked:
        case DomainLockDoesNotExist:
        case MetaDataKeyError:
        case MetaDataSealIsBroken:
        case MetaDataValidationError:
        case MetaDataMappingError:
        case MetaDataParamError:
        case MetadataOverflowError:
        case ImportUnknownType:
        case ExportError:
        case MergeVolumeRollbackError:
        case ActionStopped:
        case FAILED_CHANGE_CD_IS_MOUNTED:
        case UnsupportedDomainVersion:
        case CurrentVersionTooAdvancedError:
        case iSCSILogoutError:
        case iSCSIDiscoveryError:
        case ISCSI_LOGIN_AUTH_ERROR:
        case PoolUpgradeInProgress:
        case MixedSDVersionError:
        case NoSpaceLeftOnDomain:
        case ImageDoesNotExistInDomainError:
        case NO_IMPLEMENTATION:
        case VOLUME_WAS_NOT_PREPARED_BEFORE_TEARDOWN:
        case IMAGES_NOT_SUPPORTED_ERROR:
        case GET_FILE_LIST_ERROR:
        case STORAGE_DOMAIN_REFRESH_ERROR:
        case VOLUME_GROUP_BLOCK_SIZE_ERROR:
        case MIGRATION_DEST_INVALID_HOSTNAME:
        case ResourceTimeout:
        case HOT_PLUG_UNPLUG_CPU_ERROR:
        case DEVICE_BLOCK_SIZE_NOT_SUPPORTED:
        case V2V_JOB_DOESNT_EXIST:
        case V2V_NO_SUCH_OVF:
        case V2V_JOB_NOT_DONE:
        case V2V_JOB_ALREADY_EXIST:
        case UnsupportedGlusterVolumeReplicaCountError:
            if (this instanceof IrsBrokerCommand || this instanceof StorageJobVDSCommand) {
                outEx = new IrsOperationFailedNoFailoverException(getReturnStatus().message);
            } else {
                outEx = new VDSErrorException(String.format("Failed in vdscommand to %1$s, error = %2$s", getCommandName(), getReturnStatus().message));
            }
            break;
        case ResourceExhausted:
        case VDS_NETWORK_ERROR:
        case ERR_BAD_ADDR:
            outEx = new VDSNetworkException(getReturnStatus().message);
            break;
        default:
            log.error("Failed in '{}' method", getCommandName());
            outEx = createException();
            break;
    }
    VDSError tempVar = new VDSError();
    tempVar.setCode(returnStatus);
    tempVar.setMessage(getReturnStatus().message);
    outEx.setVdsError(tempVar);
    logToAuditIfNeeded();
    throw outEx;
}
#end_block

#method_before
public void addImportedDevices(VmBase vmBase, boolean isImportAsNewEntity) {
    if (isImportAsNewEntity) {
        setNewIdInImportedCollections(vmBase);
    }
    List<VmDevice> vmDevicesToAdd = new ArrayList<>();
    List<VmDevice> vmDevicesToUpdate = new ArrayList<>();
    addImportedDiskDevices(vmBase, vmDevicesToUpdate);
    addImportedInterfaces(vmBase, vmDevicesToUpdate);
    addImportedOtherDevices(vmBase, vmDevicesToAdd);
    vmDeviceDao.saveAll(vmDevicesToAdd);
    vmDeviceDao.updateAll(vmDevicesToUpdate);
}
#method_after
public void addImportedDevices(VmBase vmBase, boolean isImportAsNewEntity, boolean withMemory) {
    if (isImportAsNewEntity) {
        setNewIdInImportedCollections(vmBase);
    }
    List<VmDevice> vmDevicesToAdd = new ArrayList<>();
    List<VmDevice> vmDevicesToUpdate = new ArrayList<>();
    addImportedDiskDevices(vmBase, vmDevicesToUpdate);
    addImportedInterfaces(vmBase, vmDevicesToUpdate);
    addImportedOtherDevices(vmBase, vmDevicesToAdd, withMemory);
    vmDeviceDao.saveAll(vmDevicesToAdd);
    vmDeviceDao.updateAll(vmDevicesToUpdate);
}
#end_block

#method_before
private void addImportedOtherDevices(VmBase vmBase, List<VmDevice> vmDeviceToAdd) {
    boolean hasCd = false;
    for (VmDevice vmDevice : vmBase.getManagedDeviceMap().values()) {
        switch(vmDevice.getType()) {
            case DISK:
                if (VmDeviceType.CDROM.getName().equals(vmDevice.getDevice())) {
                    hasCd = true;
                } else {
                    // disks are added separately
                    continue;
                }
                break;
            case INTERFACE:
                // network interfaces are added separately
                continue;
            case VIDEO:
                vmDevice.setSpecParams(getVideoDeviceSpecParams(vmBase));
                break;
            case HOSTDEV:
                // it is currently unsafe to import host devices, due to possibility of invalid dedicatedVmForVds
                continue;
        }
        vmDevice.setManaged(true);
        vmDeviceToAdd.add(vmDevice);
    }
    if (!hasCd) {
        // add an empty CD
        addCdDevice(vmBase.getId());
    }
    // add unmanaged devices
    vmDeviceToAdd.addAll(vmBase.getUnmanagedDeviceList());
}
#method_after
private void addImportedOtherDevices(VmBase vmBase, List<VmDevice> vmDeviceToAdd, boolean withMemory) {
    boolean hasCd = false;
    for (VmDevice vmDevice : vmBase.getManagedDeviceMap().values()) {
        switch(vmDevice.getType()) {
            case DISK:
                if (VmDeviceType.CDROM.getName().equals(vmDevice.getDevice())) {
                    hasCd = true;
                } else {
                    // disks are added separately
                    continue;
                }
                break;
            case INTERFACE:
                // network interfaces are added separately
                continue;
            case VIDEO:
                vmDevice.setSpecParams(getVideoDeviceSpecParams(vmBase));
                break;
            case HOSTDEV:
                // it is currently unsafe to import host devices, due to possibility of invalid dedicatedVmForVds
                continue;
        }
        vmDevice.setManaged(true);
        vmDeviceToAdd.add(vmDevice);
    }
    if (!hasCd) {
        // add an empty CD
        addCdDevice(vmBase.getId());
    }
    // add unmanaged devices
    final List<VmDevice> unmanagedDevicesToAdd = vmBase.getUnmanagedDeviceList().stream().filter(device -> !VmDeviceCommonUtils.isMemory(device) || withMemory).collect(Collectors.toList());
    vmDeviceToAdd.addAll(unmanagedDevicesToAdd);
}
#end_block

#method_before
protected void initParametersForExternalNetworks() {
    if (getVm().getInterfaces().isEmpty()) {
        return;
    }
    Map<VmDeviceId, VmDevice> nicDevices = Entities.businessEntitiesById(vmDeviceDao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.INTERFACE));
    for (VmNic iface : getVm().getInterfaces()) {
        VnicProfile vnicProfile = vnicProfileDao.get(iface.getVnicProfileId());
        Network network = NetworkHelper.getNetworkByVnicProfile(vnicProfile);
        VmDevice vmDevice = nicDevices.get(new VmDeviceId(iface.getId(), getVmId()));
        if (network != null && network.isExternal() && vmDevice.isPlugged()) {
            Provider<?> provider = providerDao.get(network.getProvidedBy().getProviderId());
            NetworkProviderProxy providerProxy = ProviderProxyFactory.getInstance().create(provider);
            Map<String, String> deviceProperties = providerProxy.allocate(network, vnicProfile, iface, getVds());
            getVm().getRuntimeDeviceCustomProperties().put(vmDevice.getId(), deviceProperties);
        }
    }
}
#method_after
protected void initParametersForExternalNetworks() {
    if (getVm().getInterfaces().isEmpty()) {
        return;
    }
    Map<VmDeviceId, VmDevice> nicDevices = Entities.businessEntitiesById(vmDeviceDao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.INTERFACE));
    for (VmNic iface : getVm().getInterfaces()) {
        VnicProfile vnicProfile = vnicProfileDao.get(iface.getVnicProfileId());
        Network network = NetworkHelper.getNetworkByVnicProfile(vnicProfile);
        VmDevice vmDevice = nicDevices.get(new VmDeviceId(iface.getId(), getVmId()));
        if (network != null && network.isExternal() && vmDevice.isPlugged()) {
            Provider<?> provider = providerDao.get(network.getProvidedBy().getProviderId());
            NetworkProviderProxy providerProxy = providerProxyFactory.create(provider);
            Map<String, String> deviceProperties = providerProxy.allocate(network, vnicProfile, iface, getVds());
            getVm().getRuntimeDeviceCustomProperties().put(vmDevice.getId(), deviceProperties);
        }
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    if (!FeatureSupported.hotUnplugMemory(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_UNPLUG_NOT_SUPPORTED_FOR_COMPAT_VERSION_AND_ARCH, ReplacementUtils.createSetVariableString("compatibilityVersion", getVm().getCompatibilityVersion()), ReplacementUtils.createSetVariableString("architecture", getVm().getClusterArch()));
    }
    if (getVm().getStatus() != VMStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_UP);
    }
    if (getDeviceToHotUnplug() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_MEMORY_DEVICE_DOESNT_EXIST, ReplacementUtils.createSetVariableString("deviceId", getParameters().getDeviceId()));
    }
    if (!VmDeviceCommonUtils.getSpecParamsIntValue(getDeviceToHotUnplug(), VmDeviceCommonUtils.SPEC_PARAM_SIZE).isPresent()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_REQUIRED_SPEC_PARAM_IS_MISSING, ReplacementUtils.createSetVariableString("deviceId", getDeviceToHotUnplug().getId()), ReplacementUtils.createSetVariableString("specParamName", VmDeviceCommonUtils.SPEC_PARAM_SIZE));
    }
    if (!VmDeviceCommonUtils.getSpecParamsIntValue(getDeviceToHotUnplug(), VmDeviceCommonUtils.SPEC_PARAM_NODE).isPresent()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_REQUIRED_SPEC_PARAM_IS_MISSING, ReplacementUtils.createSetVariableString("deviceId", getDeviceToHotUnplug().getId()), ReplacementUtils.createSetVariableString("specParamName", VmDeviceCommonUtils.SPEC_PARAM_NODE));
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    if (!FeatureSupported.hotUnplugMemory(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_UNPLUG_NOT_SUPPORTED_FOR_COMPAT_VERSION_AND_ARCH, ReplacementUtils.createSetVariableString("compatibilityVersion", getVm().getCompatibilityVersion()), ReplacementUtils.createSetVariableString("architecture", getVm().getClusterArch()));
    }
    if (getVm().getStatus() != VMStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_UP);
    }
    if (getDeviceToHotUnplug() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_MEMORY_DEVICE_DOESNT_EXIST, ReplacementUtils.createSetVariableString("deviceId", getParameters().getDeviceId()));
    }
    if (!VmDeviceCommonUtils.getSpecParamsIntValue(getDeviceToHotUnplug(), SPEC_PARAM_SIZE).isPresent()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_REQUIRED_SPEC_PARAM_IS_MISSING, ReplacementUtils.createSetVariableString("deviceId", getDeviceToHotUnplug().getId()), ReplacementUtils.createSetVariableString("specParamName", SPEC_PARAM_SIZE));
    }
    if (!VmDeviceCommonUtils.getSpecParamsIntValue(getDeviceToHotUnplug(), SPEC_PARAM_NODE).isPresent()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_REQUIRED_SPEC_PARAM_IS_MISSING, ReplacementUtils.createSetVariableString("deviceId", getDeviceToHotUnplug().getId()), ReplacementUtils.createSetVariableString("specParamName", SPEC_PARAM_NODE));
    }
    return true;
}
#end_block

#method_before
public List<VmDevice> getCdDevices(Guid vmId) {
    return vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName());
}
#method_after
public List<VmDevice> getCdDevices(Guid vmId) {
    return vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.DISK, VmDeviceType.CDROM);
}
#end_block

#method_before
public List<VmDevice> getSmartcardDevices(Guid vmId) {
    return vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.SMARTCARD, VmDeviceType.SMARTCARD.getName());
}
#method_after
public List<VmDevice> getSmartcardDevices(Guid vmId) {
    return vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.SMARTCARD, VmDeviceType.SMARTCARD);
}
#end_block

#method_before
public List<VmDevice> getConsoleDevices(Guid vmId) {
    return vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.CONSOLE, VmDeviceType.CONSOLE.getName());
}
#method_after
public List<VmDevice> getConsoleDevices(Guid vmId) {
    return vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.CONSOLE, VmDeviceType.CONSOLE);
}
#end_block

#method_before
public List<VmDevice> getUsbControllers(Guid vmId) {
    return vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.CONTROLLER, VmDeviceType.USB.getName());
}
#method_after
public List<VmDevice> getUsbControllers(Guid vmId) {
    return vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.CONTROLLER, VmDeviceType.USB);
}
#end_block

#method_before
private void updateSpiceUsb(Guid vmId, int oldNumberOfSlots, int newNumberOfUsbSlots) {
    if (oldNumberOfSlots > newNumberOfUsbSlots) {
        // Remove slots and controllers
        removeUsbSlots(vmId, oldNumberOfSlots - newNumberOfUsbSlots);
        if (newNumberOfUsbSlots == 0) {
            removeUsbControllers(vmId);
        }
        return;
    }
    if (oldNumberOfSlots < newNumberOfUsbSlots) {
        // Add slots and controllers
        if (oldNumberOfSlots == 0) {
            addSpiceUsbControllers(vmId, getNeededNumberOfUsbControllers(newNumberOfUsbSlots));
        }
        addUsbSlots(vmId, newNumberOfUsbSlots - oldNumberOfSlots);
        return;
    }
}
#method_after
private void updateSpiceUsb(Guid vmId, int oldNumberOfSlots, int newNumberOfUsbSlots) {
    if (oldNumberOfSlots > newNumberOfUsbSlots) {
        // Remove slots and controllers
        removeUsbSlots(vmId, oldNumberOfSlots - newNumberOfUsbSlots);
        if (newNumberOfUsbSlots == 0) {
            removeUsbControllers(vmId);
        }
        return;
    }
    if (oldNumberOfSlots < newNumberOfUsbSlots) {
        // Add slots and controllers
        if (oldNumberOfSlots == 0) {
            // there may be remaining of unmanaged controllers from previous versions
            removeUsbControllers(vmId);
            addSpiceUsbControllers(vmId, getNeededNumberOfUsbControllers(newNumberOfUsbSlots));
        }
        addUsbSlots(vmId, newNumberOfUsbSlots - oldNumberOfSlots);
        return;
    }
}
#end_block

#method_before
private void acquireUnmanagedUsbController(VmBase vmBase, List<VmDevice> managedUsbControllers, List<VmDevice> unmanagedControllers) {
    if (unmanagedControllers.size() > 1) {
        throw new IllegalStateException(format("At most one unmanaged USB controller expected for VM=%s(%s), found=%s", vmBase.getName(), vmBase.getId(), unmanagedControllers));
    }
    final UsbControllerModel controllerModel = getUsbControllerModel(vmBase);
    if (unmanagedControllers.isEmpty()) {
        return;
    }
    // should not be here but due to https://bugzilla.redhat.com/1438188 can appear one
    // remove it
    removeVmDevices(managedUsbControllers);
    // has been created on pre 4.0 engine by VDSM, adopt it as ours
    VmDevice device = unmanagedControllers.iterator().next();
    device.setManaged(true);
    device.setPlugged(true);
    device.setReadOnly(false);
    device.setSpecParams(createUsbControllerSpecParams(controllerModel.libvirtName, 0));
    vmDeviceDao.update(device);
}
#method_after
private void acquireUnmanagedUsbController(VmBase vmBase, List<VmDevice> managedUsbControllers, List<VmDevice> unmanagedControllers) {
    if (unmanagedControllers.size() > 1) {
        throw new IllegalStateException(format("At most one unmanaged USB controller expected for VM=%s(%s), found=%s", vmBase.getName(), vmBase.getId(), unmanagedControllers));
    }
    if (unmanagedControllers.isEmpty()) {
        return;
    }
    UsbControllerModel controllerModel = getUsbControllerModel(vmBase);
    // should not be here but due to https://bugzilla.redhat.com/1438188 can appear one
    // remove it
    removeVmDevices(managedUsbControllers);
    // has been created on pre 4.0 engine by VDSM, adopt it as ours
    VmDevice device = unmanagedControllers.iterator().next();
    device.setManaged(true);
    device.setPlugged(true);
    device.setReadOnly(false);
    device.setSpecParams(createUsbControllerSpecParams(controllerModel.libvirtName, 0));
    vmDeviceDao.update(device);
}
#end_block

#method_before
public List<VmDevice> getUsbSlots(Guid vmId) {
    return vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.REDIR, VmDeviceType.SPICEVMC.getName());
}
#method_after
public List<VmDevice> getUsbSlots(Guid vmId) {
    return vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.REDIR, VmDeviceType.SPICEVMC);
}
#end_block

#method_before
public List<VmDevice> getUsbChannels(Guid vmId) {
    return vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.REDIRDEV, VmDeviceType.SPICEVMC.getName());
}
#method_after
public List<VmDevice> getUsbChannels(Guid vmId) {
    return vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.REDIRDEV, VmDeviceType.SPICEVMC);
}
#end_block

#method_before
public void removeLeftOverDevices(VmBase vmBase) {
    if (!hasGraphicsDevice(vmBase.getId(), GraphicsType.SPICE)) {
        // remove spice channel if we are no longer using spice
        List<VmDevice> spiceChannels = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmBase.getId(), VmDeviceGeneralType.CHANNEL, VmDeviceType.SPICEVMC.getName());
        removeVmDevices(spiceChannels);
    }
}
#method_after
public void removeLeftOverDevices(VmBase vmBase) {
    if (!hasGraphicsDevice(vmBase.getId(), GraphicsType.SPICE)) {
        // remove spice channel if we are no longer using spice
        List<VmDevice> spiceChannels = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmBase.getId(), VmDeviceGeneralType.CHANNEL, VmDeviceType.SPICEVMC);
        removeVmDevices(spiceChannels);
    }
}
#end_block

#method_before
/*
     * Watchdog
     */
public List<VmDevice> getWatchdogs(Guid vmId) {
    return vmDeviceDao.getVmDeviceByVmIdAndType(vmId, VmDeviceGeneralType.WATCHDOG);
}
#method_after
public List<VmDevice> getWatchdogs(Guid vmId) {
    return vmDeviceDao.getVmDeviceByVmIdAndType(vmId, VmDeviceGeneralType.WATCHDOG);
}
#end_block

#method_before
public void updateVmDevicesOnRun(VmBase vmBase) {
    if (vmBase != null) {
        updateUsbSlots(vmBase, vmBase);
        removeLeftOverDevices(vmBase);
    }
}
#method_after
public void updateVmDevicesOnRun(VM vm) {
    if (vm != null) {
        updateUsbSlots(vm.getStaticData(), vm.getStaticData());
        removeLeftOverDevices(vm.getStaticData());
        updateRngDevice(vm);
    }
}
#end_block

#method_before
public void addImportedDevices(VmBase vmBase, boolean isImportAsNewEntity) {
    if (isImportAsNewEntity) {
        setNewIdInImportedCollections(vmBase);
    }
    List<VmDevice> vmDevicesToAdd = new ArrayList<>();
    List<VmDevice> vmDevicesToUpdate = new ArrayList<>();
    addImportedDiskDevices(vmBase, vmDevicesToUpdate);
    addImportedInterfaces(vmBase, vmDevicesToUpdate);
    addImportedOtherDevices(vmBase, vmDevicesToAdd);
    vmDeviceDao.saveAll(vmDevicesToAdd);
    vmDeviceDao.updateAll(vmDevicesToUpdate);
}
#method_after
public void addImportedDevices(VmBase vmBase, boolean isImportAsNewEntity, boolean withMemory) {
    if (isImportAsNewEntity) {
        setNewIdInImportedCollections(vmBase);
    }
    List<VmDevice> vmDevicesToAdd = new ArrayList<>();
    List<VmDevice> vmDevicesToUpdate = new ArrayList<>();
    addImportedDiskDevices(vmBase, vmDevicesToUpdate);
    addImportedInterfaces(vmBase, vmDevicesToUpdate);
    addImportedOtherDevices(vmBase, vmDevicesToAdd, withMemory);
    vmDeviceDao.saveAll(vmDevicesToAdd);
    vmDeviceDao.updateAll(vmDevicesToUpdate);
}
#end_block

#method_before
private void addImportedOtherDevices(VmBase vmBase, List<VmDevice> vmDeviceToAdd) {
    boolean hasCd = false;
    for (VmDevice vmDevice : vmBase.getManagedDeviceMap().values()) {
        switch(vmDevice.getType()) {
            case DISK:
                if (VmDeviceType.CDROM.getName().equals(vmDevice.getDevice())) {
                    hasCd = true;
                } else {
                    // disks are added separately
                    continue;
                }
                break;
            case INTERFACE:
                // network interfaces are added separately
                continue;
            case VIDEO:
                vmDevice.setSpecParams(getVideoDeviceSpecParams(vmBase));
                break;
            case HOSTDEV:
                // it is currently unsafe to import host devices, due to possibility of invalid dedicatedVmForVds
                continue;
        }
        vmDevice.setManaged(true);
        vmDeviceToAdd.add(vmDevice);
    }
    if (!hasCd) {
        // add an empty CD
        addCdDevice(vmBase.getId());
    }
    // add unmanaged devices
    final List<VmDevice> unmanagedDevicesToAdd = vmBase.getUnmanagedDeviceList().stream().filter(VmDeviceUtils::removeMalformedMemoryDevices).collect(Collectors.toList());
    vmDeviceToAdd.addAll(unmanagedDevicesToAdd);
}
#method_after
private void addImportedOtherDevices(VmBase vmBase, List<VmDevice> vmDeviceToAdd, boolean withMemory) {
    boolean hasCd = false;
    for (VmDevice vmDevice : vmBase.getManagedDeviceMap().values()) {
        switch(vmDevice.getType()) {
            case DISK:
                if (VmDeviceType.CDROM.getName().equals(vmDevice.getDevice())) {
                    hasCd = true;
                } else {
                    // disks are added separately
                    continue;
                }
                break;
            case INTERFACE:
                // network interfaces are added separately
                continue;
            case VIDEO:
                vmDevice.setSpecParams(getVideoDeviceSpecParams(vmBase));
                break;
            case HOSTDEV:
                // it is currently unsafe to import host devices, due to possibility of invalid dedicatedVmForVds
                continue;
        }
        vmDevice.setManaged(true);
        vmDeviceToAdd.add(vmDevice);
    }
    if (!hasCd) {
        // add an empty CD
        addCdDevice(vmBase.getId());
    }
    // add unmanaged devices
    final List<VmDevice> unmanagedDevicesToAdd = vmBase.getUnmanagedDeviceList().stream().filter(device -> !VmDeviceCommonUtils.isMemory(device) || withMemory).collect(Collectors.toList());
    vmDeviceToAdd.addAll(unmanagedDevicesToAdd);
}
#end_block

#method_before
public static int getSizeOfMemoryDeviceMb(VmDevice memoryDevice) {
    if (memoryDevice.getType() != VmDeviceGeneralType.MEMORY) {
        throw new RuntimeException("Memory device expected but device " + memoryDevice + " passed of type " + memoryDevice.getType());
    }
    final String sizeText = (String) memoryDevice.getSpecParams().get(SPEC_PARAM_SIZE);
    return Integer.parseInt(sizeText);
}
#method_after
public static Optional<Integer> getSizeOfMemoryDeviceMb(VmDevice memoryDevice) {
    if (!isMemory(memoryDevice)) {
        throw new RuntimeException("Memory device expected but device " + memoryDevice + " passed of type " + memoryDevice.getType());
    }
    return getSpecParamsIntValue(memoryDevice, SPEC_PARAM_SIZE);
}
#end_block

#method_before
protected boolean validateAttachedDirectLuns() {
    if (getParameters().getAttachedDirectLunsIds() == null) {
        return true;
    }
    Set<String> idsOfDirectLunsAttachedToVmsInPool = getIdsOfDirectLunsAttachedToVmsInPool();
    Collection<String> directLunsNotAttachedToVmInPool = getParameters().getAttachedDirectLunsIds().stream().filter(lunId -> !idsOfDirectLunsAttachedToVmsInPool.contains(lunId)).collect(Collectors.toList());
    return directLunsNotAttachedToVmInPool.isEmpty() || failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_SYNC_DIRECT_LUNS_NOT_ATTACHED_TO_VM_IN_POOL, String.format("$lunIds %s", directLunsNotAttachedToVmInPool.stream().sorted().collect(Collectors.joining(","))), String.format("$storagePoolId %s", getParameters().getStoragePoolId()));
}
#method_after
protected boolean validateAttachedDirectLuns() {
    if (getParameters().getAttachedDirectLunDisksIds() == null) {
        log.debug("Synchronizing all the direct LUNs that are attached to VMs in data center '{}', id '{}'.", getStoragePoolName(), getStoragePoolId());
        return true;
    }
    Map<Guid, String> diskToLunIds = getDiskToLunIdsOfDirectLunsAttachedToVmsInPool();
    Collection<String> directLunsNotAttachedToVmsInPool = getParameters().getAttachedDirectLunDisksIds().stream().filter(diskId -> !diskToLunIds.containsKey(diskId)).map(Guid::toString).collect(Collectors.toList());
    return directLunsNotAttachedToVmsInPool.isEmpty() || failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_SYNC_DIRECT_LUN_DISKS_NOT_ATTACHED_TO_VM_IN_POOL, String.format("$diskIds %s", directLunsNotAttachedToVmsInPool.stream().sorted().collect(Collectors.joining(", "))), String.format("$storagePoolId %s", getParameters().getStoragePoolId()));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    lunDao.updateAll(getLunsToUpdateInDb());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    Collection<LUNs> lunsToUpdateInDb = getLunsToUpdateInDb();
    lunDao.updateAllInBatch(lunsToUpdateInDb);
    log.info(lunsToUpdateInDb.stream().map(LUNs::getLUNId).collect(Collectors.joining(", ", "LUNs with IDs: [", "] were updated in the DB.")));
    setSucceeded(true);
}
#end_block

#method_before
protected Collection<LUNs> getLunsToUpdateInDb() {
    Set<String> idsOfDirectLunsAttachedToVmsInPool = getIdsOfDirectLunsAttachedToVmsInPool();
    List<String> lunsIds = Optional.ofNullable(getParameters().getAttachedDirectLunsIds()).map(ArrayList::new).orElse(null);
    return getDeviceList(lunsIds).stream().filter(lun -> idsOfDirectLunsAttachedToVmsInPool.contains(lun.getId())).peek(lun -> lun.setVolumeGroupId("")).collect(Collectors.toList());
}
#method_after
protected Collection<LUNs> getLunsToUpdateInDb() {
    Map<Guid, String> diskToLunIds = getDiskToLunIdsOfDirectLunsAttachedToVmsInPool();
    Map<String, Guid> lunToDiskIds = diskToLunIds.entrySet().stream().collect(Collectors.toMap(Map.Entry::getValue, Map.Entry::getKey));
    List<String> lunsIds = Optional.ofNullable(getParameters().getAttachedDirectLunDisksIds()).map(set -> set.stream().map(diskToLunIds::get).collect(Collectors.toList())).orElse(null);
    return getDeviceList(lunsIds).stream().filter(lun -> lunToDiskIds.containsKey(lun.getLUNId())).peek(lun -> lun.setVolumeGroupId("")).peek(lun -> lun.setDiskId(lunToDiskIds.get(lun.getLUNId()))).collect(Collectors.toList());
}
#end_block

#method_before
@Before
public void setUp() {
    lun1 = new LUNs();
    lun1.setId("lun1");
    lun2 = new LUNs();
    lun2.setId("lun2");
    lun3 = new LUNs();
    lun3.setId("lun3");
}
#method_after
@Before
public void setUp() {
    lun1 = new LUNs();
    lun1.setLUNId("lun1");
    lun1.setDiskId(Guid.newGuid());
    lun2 = new LUNs();
    lun2.setLUNId("lun2");
    lun2.setDiskId(Guid.newGuid());
    lun3 = new LUNs();
    lun3.setLUNId("lun3");
    lun3.setDiskId(Guid.newGuid());
}
#end_block

#method_before
@Test
public void testGetLunsToUpdateInDb() {
    command.getParameters().setDeviceList(Arrays.asList(lun1, lun2, lun3));
    mockDirectLunsAttachedToVmsInPool("lun1", "lun2");
    assertEquals(Arrays.asList(lun1, lun2), command.getLunsToUpdateInDb());
}
#method_after
@Test
public void testGetLunsToUpdateInDb() {
    command.getParameters().setDeviceList(Arrays.asList(lun1, lun2, lun3));
    mockDiskToLunIdsOfDirectLunsAttachedToVmsInPool(lun1, lun2);
    assertEquals(Arrays.asList(lun1, lun2), command.getLunsToUpdateInDb());
}
#end_block

#method_before
@Test
public void validateAttachedDirectLunsWithLunsThatAreNotAttachedToVmInPool() {
    command.getParameters().setAttachedDirectLunsIds(Arrays.asList("lun1", "lun3"));
    mockDirectLunsAttachedToVmsInPool("lun2", "lun3");
    assertFalse(command.validateAttachedDirectLuns());
    ValidateTestUtils.assertValidationMessages("lun2 is not attached to a vm in the datacenter.", command, EngineMessage.ACTION_TYPE_FAILED_CANNOT_SYNC_DIRECT_LUNS_NOT_ATTACHED_TO_VM_IN_POOL);
}
#method_after
@Test
public void validateAttachedDirectLunsWithLunsThatAreNotAttachedToVmInPool() {
    command.getParameters().setAttachedDirectLunDisksIds(new HashSet<>(Arrays.asList(lun1.getDiskId(), lun3.getDiskId())));
    mockDiskToLunIdsOfDirectLunsAttachedToVmsInPool(lun2, lun3);
    assertFalse(command.validateAttachedDirectLuns());
    ValidateTestUtils.assertValidationMessages("lun2 is not attached to a vm in the datacenter.", command, EngineMessage.ACTION_TYPE_FAILED_CANNOT_SYNC_DIRECT_LUN_DISKS_NOT_ATTACHED_TO_VM_IN_POOL);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final List<LUNs> lunsFromVgInfo = getLunsFromVgInfo();
    final List<LUNs> lunsFromDb = lunDao.getAllForVolumeGroup(getStorageDomain().getStorage());
    Map<LunHandler, List<LUNs>> lunsToUpdateInDb = getLunsToUpdateInDb(lunsFromVgInfo, lunsFromDb);
    boolean dbShouldBeUpdated = lunsToUpdateInDb.keySet().stream().anyMatch(LunHandler::requiresDbUpdate);
    if (dbShouldBeUpdated) {
        TransactionSupport.executeInNewTransaction(() -> {
            updateLunsInDb(lunsToUpdateInDb);
            refreshLunsConnections(lunsFromVgInfo);
            return null;
        });
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    final List<LUNs> lunsFromVgInfo = getVgInfo();
    final List<LUNs> lunsFromDb = lunDao.getAllForVolumeGroup(getStorageDomain().getStorage());
    Map<LunHandler, List<LUNs>> lunsToUpdateInDb = getLunsToUpdateInDb(lunsFromVgInfo, lunsFromDb);
    boolean dbShouldBeUpdated = lunsToUpdateInDb.keySet().stream().anyMatch(LunHandler::requiresDbUpdate);
    if (dbShouldBeUpdated) {
        TransactionSupport.executeInNewTransaction(() -> {
            updateLunsInDb(lunsToUpdateInDb);
            refreshLunsConnections(lunsFromVgInfo);
            return null;
        });
    }
    refreshMetadataDevicesInfoIfNeeded();
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    return Collections.singletonMap(getParameters().getStorageDomainId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.SYNC_LUNS, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    return Collections.singletonMap(getParameters().getStorageDomainId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.STORAGE, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getParameters().getStoragePoolId() == null) {
        return failValidation(EngineMessage.VALIDATION_STORAGE_POOL_ID_NOT_NULL);
    }
    return super.validate();
}
#method_after
@Override
protected boolean validate() {
    if (!checkStoragePool()) {
        return false;
    }
    return super.validate();
}
#end_block

#method_before
@SuppressWarnings("unchecked")
protected List<LUNs> runGetDeviceList(List<String> lunsIds) {
    GetDeviceListVDSCommandParameters parameters = new GetDeviceListVDSCommandParameters(getParameters().getVdsId(), null, false, lunsIds);
    return (List<LUNs>) VdsCommandsHelper.runVdsCommandWithoutFailover(VDSCommandType.GetDeviceList, parameters, getParameters().getStoragePoolId(), null).getReturnValue();
}
#method_after
@SuppressWarnings("unchecked")
protected List<LUNs> runGetDeviceList(List<String> lunsIds) {
    GetDeviceListVDSCommandParameters parameters = new GetDeviceListVDSCommandParameters(getParameters().getVdsId(), StorageType.UNKNOWN, false, lunsIds);
    return (List<LUNs>) VdsCommandsHelper.runVdsCommandWithoutFailover(VDSCommandType.GetDeviceList, parameters, getParameters().getStoragePoolId(), null).getReturnValue();
}
#end_block

#method_before
protected List<Guid> syncStorageDomains() {
    return getLunsGroupedByStorageDomainId().entrySet().stream().filter(lunsByStorageDomainId -> !runSyncLunsInfoForBlockStorageDomain(lunsByStorageDomainId.getKey(), lunsByStorageDomainId.getValue())).map(Map.Entry::getKey).sorted().collect(Collectors.toList());
}
#method_after
protected List<Guid> syncStorageDomains() {
    return getLunsGroupedByStorageDomainId().entrySet().stream().filter(sdLuns -> !runSyncLunsInfoForBlockStorageDomain(sdLuns.getKey(), sdLuns.getValue())).map(Map.Entry::getKey).sorted().collect(Collectors.toList());
}
#end_block

#method_before
@Override
public void init() {
    super.init();
    updateStorageDomainDiscardAfterDelete(getTargetStoragePool().getCompatibilityVersion());
}
#method_after
@Override
public void init() {
    super.init();
    initStorageDomainDiscardAfterDelete(getTargetStoragePool().getCompatibilityVersion());
}
#end_block

#method_before
public ValidationResult isStorageFormatCompatibleWithDomain() {
    StorageFormatType storageFormat = storageDomain.getStorageFormat();
    StorageType storageType = storageDomain.getStorageType();
    StorageDomainType storageDomainFunction = storageDomain.getStorageDomainType();
    boolean validationSucceeded = true;
    // V2 is applicable only for block data storage domains
    if (storageFormat == StorageFormatType.V2) {
        if (!(storageDomainFunction.isDataDomain() && storageType.isBlockDomain())) {
            validationSucceeded = false;
        }
    }
    // Above V3 is applicable only for data storage domains
    if (storageFormat.compareTo(StorageFormatType.V3) >= 0) {
        if (!storageDomainFunction.isDataDomain()) {
            validationSucceeded = false;
        }
    }
    return validationSucceeded ? ValidationResult.VALID : new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_FORMAT_ILLEGAL_HOST, String.format("$storageFormat %1$s", storageDomain.getStorageFormat()));
}
#method_after
public ValidationResult isStorageFormatCompatibleWithDomain() {
    StorageFormatType storageFormat = storageDomain.getStorageFormat();
    StorageType storageType = storageDomain.getStorageType();
    StorageDomainType storageDomainFunction = storageDomain.getStorageDomainType();
    boolean validationSucceeded = true;
    if (storageFormat == null) {
        validationSucceeded = false;
    }
    // V2 is applicable only for block data storage domains
    if (validationSucceeded && storageFormat == StorageFormatType.V2) {
        if (!(storageDomainFunction.isDataDomain() && storageType.isBlockDomain())) {
            validationSucceeded = false;
        }
    }
    if (validationSucceeded && storageFormat.compareTo(StorageFormatType.V3) >= 0) {
        // Above V3 is applicable only for data storage domains
        if (!storageDomainFunction.isDataDomain()) {
            validationSucceeded = false;
        }
    }
    return validationSucceeded ? ValidationResult.VALID : new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_FORMAT_ILLEGAL_HOST, String.format("$storageFormat %1$s", storageDomain.getStorageFormat()));
}
#end_block

#method_before
public void deallocateIfExternal() {
    if (getNetwork() != null && getNetwork().isExternal()) {
        Provider<?> provider = getProviderDao().get(getNetwork().getProvidedBy().getProviderId());
        NetworkProviderProxy providerProxy = providerProxyFactory.create(provider);
        try {
            providerProxy.deallocate(nic);
        } catch (EngineException e) {
            AuditLogableBase removePortFailureEvent = new AuditLogableBase();
            removePortFailureEvent.addCustomValue("NicName", nic.getName());
            removePortFailureEvent.addCustomValue("NicId", nic.getId().toString());
            removePortFailureEvent.addCustomValue("ProviderName", provider.getName());
            getAuditLogDirector().log(removePortFailureEvent, AuditLogType.REMOVE_PORT_FROM_EXTERNAL_PROVIDER_FAILED);
        }
    }
}
#method_after
public void deallocateIfExternal() {
    if (getNetwork() != null && getNetwork().isExternal()) {
        Provider<?> provider = getProviderDao().get(getNetwork().getProvidedBy().getProviderId());
        NetworkProviderProxy providerProxy = getProviderProxyFactory().create(provider);
        try {
            providerProxy.deallocate(nic);
        } catch (EngineException e) {
            AuditLogable removePortFailureEvent = new AuditLogableImpl();
            removePortFailureEvent.addCustomValue("NicName", nic.getName());
            removePortFailureEvent.addCustomValue("NicId", nic.getId().toString());
            removePortFailureEvent.addCustomValue("ProviderName", provider.getName());
            getAuditLogDirector().log(removePortFailureEvent, AuditLogType.REMOVE_PORT_FROM_EXTERNAL_PROVIDER_FAILED);
        }
    }
}
#end_block

#method_before
public static OpenStackVolumeProviderProxy getFromStorageDomainId(Guid storageDomainId, Guid userID, boolean isFiltered) {
    StorageDomain storageDomain = getDbFacade().getStorageDomainDao().get(storageDomainId, userID, isFiltered);
    if (storageDomain != null) {
        Provider provider = getDbFacade().getProviderDao().get(new Guid(storageDomain.getStorage()));
        return providerProxyFactory.create(provider);
    }
    return null;
}
#method_after
public static OpenStackVolumeProviderProxy getFromStorageDomainId(Guid storageDomainId, ProviderProxyFactory providerProxyFactory) {
    StorageDomainStatic storageDomainStatic = getDbFacade().getStorageDomainStaticDao().get(storageDomainId);
    if (storageDomainStatic != null) {
        return getProviderFromStorageDomainStatic(storageDomainStatic, providerProxyFactory);
    }
    return null;
}
#end_block

#method_before
private static OpenStackVolumeProviderProxy getProviderFromStorageDomainStatic(StorageDomainStatic storageDomainStatic) {
    Provider provider = getDbFacade().getProviderDao().get(new Guid(storageDomainStatic.getStorage()));
    return providerProxyFactory.create(provider);
}
#method_after
private static OpenStackVolumeProviderProxy getProviderFromStorageDomainStatic(StorageDomainStatic storageDomainStatic, ProviderProxyFactory providerProxyFactory) {
    Provider provider = getDbFacade().getProviderDao().get(new Guid(storageDomainStatic.getStorage()));
    return providerProxyFactory.create(provider);
}
#end_block

#method_before
protected OpenStackImageProviderProxy getProviderProxy() {
    if (providerProxy == null) {
        providerProxy = OpenStackImageProviderProxy.getFromStorageDomainId(getParameters().getDestinationDomainId());
    }
    return providerProxy;
}
#method_after
protected OpenStackImageProviderProxy getProviderProxy() {
    if (providerProxy == null) {
        providerProxy = OpenStackImageProviderProxy.getFromStorageDomainId(getParameters().getDestinationDomainId(), providerProxyFactory);
    }
    return providerProxy;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (getFlow() == RunVmFlow.REMOVE_STATELESS_IMAGES) {
                return AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT;
            }
            if (getFlow() == RunVmFlow.RESUME_PAUSE) {
                return getSucceeded() ? AuditLogType.USER_RESUME_VM : AuditLogType.USER_FAILED_RESUME_VM;
            } else if (isInternalExecution()) {
                if (getSucceeded()) {
                    boolean isStateless = isStatelessSnapshotExistsForVm();
                    if (isStateless) {
                        return AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS;
                    } else if (getFlow() == RunVmFlow.CREATE_STATELESS_IMAGES) {
                        return AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING;
                    } else {
                        return AuditLogType.VDS_INITIATED_RUN_VM;
                    }
                }
                return AuditLogType.VDS_INITIATED_RUN_VM_FAILED;
            } else {
                return getSucceeded() ? getActionReturnValue() == VMStatus.Up ? isVmRunningOnNonDefaultVds() ? AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS : isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS : AuditLogType.USER_RUN_VM : _isRerun ? AuditLogType.VDS_INITIATED_RUN_VM : getVm().isRunAndPause() ? AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE : getTaskIdList().isEmpty() ? AuditLogType.USER_STARTED_VM : AuditLogType.USER_INITIATED_RUN_VM : _isRerun ? AuditLogType.USER_INITIATED_RUN_VM_FAILED : AuditLogType.USER_FAILED_RUN_VM;
            }
        case END_SUCCESS:
            // command should be with 'CommandShouldBeLogged = false':
            return isStatelessSnapshotExistsForVm() && !getSucceeded() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        case END_FAILURE:
            // be with 'CommandShouldBeLogged = false':
            return isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        default:
            // false':
            return AuditLogType.UNASSIGNED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (getFlow() == RunVmFlow.REMOVE_STATELESS_IMAGES) {
                return AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT;
            }
            if (getFlow() == RunVmFlow.RESUME_PAUSE) {
                return getSucceeded() ? AuditLogType.USER_RESUME_VM : AuditLogType.USER_FAILED_RESUME_VM;
            } else if (isInternalExecution()) {
                if (getSucceeded()) {
                    boolean isStateless = isStatelessSnapshotExistsForVm();
                    if (isStateless) {
                        return AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS;
                    } else if (getFlow() == RunVmFlow.CREATE_STATELESS_IMAGES) {
                        return AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING;
                    } else {
                        return AuditLogType.VDS_INITIATED_RUN_VM;
                    }
                }
                return AuditLogType.VDS_INITIATED_RUN_VM_FAILED;
            } else {
                return getSucceeded() ? getActionReturnValue() == VMStatus.Up ? isVmRunningOnNonDefaultVds() ? AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS : isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS : AuditLogType.USER_RUN_VM : _isRerun ? AuditLogType.VDS_INITIATED_RUN_VM : getVm().isRunAndPause() ? AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE : getFlow() == RunVmFlow.CREATE_STATELESS_IMAGES ? AuditLogType.USER_INITIATED_RUN_VM : AuditLogType.USER_STARTED_VM : _isRerun ? AuditLogType.USER_INITIATED_RUN_VM_FAILED : AuditLogType.USER_FAILED_RUN_VM;
            }
        case END_SUCCESS:
            // command should be with 'CommandShouldBeLogged = false':
            return isStatelessSnapshotExistsForVm() && !getSucceeded() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        case END_FAILURE:
            // be with 'CommandShouldBeLogged = false':
            return isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        default:
            // false':
            return AuditLogType.UNASSIGNED;
    }
}
#end_block

#method_before
protected void updateVmDevicesOnRun() {
    // Before running the VM we update its devices, as they may
    // need to be changed due to configuration option change
    getVmDeviceUtils().updateVmDevicesOnRun(getVm().getStaticData());
}
#method_after
protected void updateVmDevicesOnRun() {
    // Before running the VM we update its devices, as they may
    // need to be changed due to configuration option change
    getVmDeviceUtils().updateVmDevicesOnRun(getVm());
}
#end_block

#method_before
protected boolean getVdsToRunOn() {
    Optional<Guid> vdsToRunOn = schedulingManager.schedule(getCluster(), getVm(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdListToRunOn(), new ArrayList<>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setVdsId(vdsToRunOn.orElse(null));
    if (vdsToRunOn.isPresent()) {
        getRunVdssList().add(vdsToRunOn.get());
    }
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.error("Can't find VDS to run the VM '{}' on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        EngineException outEx = new EngineException(EngineError.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error("VmHandler::{}: {}", getClass().getName(), outEx.getMessage());
        return false;
    }
    return true;
}
#method_after
protected boolean getVdsToRunOn() {
    Optional<Guid> vdsToRunOn = schedulingManager.schedule(getCluster(), getVm(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdListToRunOn(), new ArrayList<>(), this, getCorrelationId());
    setVdsId(vdsToRunOn.orElse(null));
    if (vdsToRunOn.isPresent()) {
        getRunVdssList().add(vdsToRunOn.get());
    }
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.error("Can't find VDS to run the VM '{}' on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        EngineException outEx = new EngineException(EngineError.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error("VmHandler::{}: {}", getClass().getName(), outEx.getMessage());
        return false;
    }
    return true;
}
#end_block

#method_before
boolean checkRngDeviceClusterCompatibility() {
    List<VmDevice> rngDevs = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(getVmId(), VmDeviceGeneralType.RNG, VmDeviceType.VIRTIO.getName());
    if (rngDevs.isEmpty()) {
        return true;
    }
    VmRngDevice rngDevice = new VmRngDevice(rngDevs.get(0));
    final RngUtils.RngValidationResult rngValidationResult = RngUtils.validate(getCluster(), rngDevice, getVm().getCompatibilityVersion());
    switch(rngValidationResult) {
        case VALID:
            return true;
        case UNSUPPORTED_URANDOM_OR_RANDOM:
            log.warn("Running VM {}({}) with rng source {} that is not supported in cluster {}.", getVm().getName(), getVm().getId(), rngDevice.getSource(), getCluster().getName());
            return true;
        case INVALID:
            return false;
        default:
            throw new RuntimeException("Unknown enum constant " + rngValidationResult);
    }
}
#method_after
boolean checkRngDeviceClusterCompatibility() {
    List<VmDevice> rngDevs = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(getVmId(), VmDeviceGeneralType.RNG, VmDeviceType.VIRTIO);
    if (rngDevs.isEmpty()) {
        return true;
    }
    VmRngDevice rngDevice = new VmRngDevice(rngDevs.get(0));
    final RngUtils.RngValidationResult rngValidationResult = RngUtils.validate(getCluster(), rngDevice, getVm().getCompatibilityVersion());
    switch(rngValidationResult) {
        case VALID:
            return true;
        case UNSUPPORTED_URANDOM_OR_RANDOM:
            log.warn("Running VM {}({}) with rng source {} that is not supported in cluster {}.", getVm().getName(), getVm().getId(), rngDevice.getSource(), getCluster().getName());
            return true;
        case INVALID:
            return false;
        default:
            throw new RuntimeException("Unknown enum constant " + rngValidationResult);
    }
}
#end_block

#method_before
public static OpenStackImageProviderProxy getFromStorageDomainId(Guid storageDomainId) {
    StorageDomainStatic storageDomainStatic = getDbFacade().getStorageDomainStaticDao().get(storageDomainId);
    if (storageDomainStatic != null) {
        Provider<?> provider = getDbFacade().getProviderDao().get(new Guid(storageDomainStatic.getStorage()));
        return providerProxyFactory.create(provider);
    }
    return null;
}
#method_after
public static OpenStackImageProviderProxy getFromStorageDomainId(Guid storageDomainId, ProviderProxyFactory providerProxyFactory) {
    StorageDomainStatic storageDomainStatic = getDbFacade().getStorageDomainStaticDao().get(storageDomainId);
    if (storageDomainStatic != null) {
        Provider<?> provider = getDbFacade().getProviderDao().get(new Guid(storageDomainStatic.getStorage()));
        return providerProxyFactory.create(provider);
    }
    return null;
}
#end_block

#method_before
public DiskImage getImageAsDiskImage(String id) {
    DiskImage diskImage = new DiskImage();
    Image glanceImage = getClient().images().show(id).execute();
    validateContainerFormat(glanceImage);
    String shortHash = glanceImage.getId().substring(0, 7);
    if (glanceImage.getName() != null) {
        diskImage.setDiskDescription(glanceImage.getName() + " (" + shortHash + ")");
    } else {
        diskImage.setDiskDescription("Glance disk: " + shortHash);
    }
    diskImage.setSize(getImageVirtualSize(glanceImage));
    diskImage.setActualSizeInBytes(glanceImage.getSize());
    if (glanceImage.getDiskFormat().equals(GlanceImageFormat.RAW.getValue())) {
        diskImage.setVolumeFormat(VolumeFormat.RAW);
    } else if (glanceImage.getDiskFormat().equals(GlanceImageFormat.COW.getValue())) {
        diskImage.setVolumeFormat(VolumeFormat.COW);
    } else {
        throw new OpenStackImageException(OpenStackImageException.ErrorType.UNSUPPORTED_DISK_FORMAT, "Unknown disk format: " + glanceImage.getDiskFormat());
    }
    return diskImage;
}
#method_after
public DiskImage getImageAsDiskImage(String id) {
    DiskImage diskImage = new DiskImage();
    Image glanceImage = getClient().images().show(id).execute();
    validateContainerFormat(glanceImage);
    String shortHash = glanceImage.getId().substring(0, 7);
    if (glanceImage.getName() != null) {
        diskImage.setDiskDescription(glanceImage.getName() + " (" + shortHash + ")");
    } else {
        diskImage.setDiskDescription("Glance disk: " + shortHash);
    }
    setDiskAttributes(diskImage, glanceImage);
    if (glanceImage.getDiskFormat().equals(GlanceImageFormat.RAW.getValue())) {
        diskImage.setVolumeFormat(VolumeFormat.RAW);
    } else if (glanceImage.getDiskFormat().equals(GlanceImageFormat.COW.getValue())) {
        diskImage.setVolumeFormat(VolumeFormat.COW);
    } else {
        throw new OpenStackImageException(OpenStackImageException.ErrorType.UNSUPPORTED_DISK_FORMAT, "Unknown disk format: " + glanceImage.getDiskFormat());
    }
    return diskImage;
}
#end_block

#method_before
public void log(AuditLogable auditLogable, AuditLogType logType, String message) {
    if (!logType.shouldBeLogged()) {
        return;
    }
    EventFloodRegulator eventFloodRegulator = new EventFloodRegulator(auditLogable, logType);
    if (eventFloodRegulator.isLegal()) {
        AuditLog[] savedAuditLog = { null };
        TransactionSupport.executeInNewTransaction(() -> {
            savedAuditLog[0] = saveToDb(auditLogable, logType, message);
            return null;
        });
        if (savedAuditLog == null) {
            log.warn("Unable to create AuditLog");
        } else {
            logMessage(savedAuditLog[0]);
        }
    }
}
#method_after
public void log(AuditLogable auditLogable, AuditLogType logType, String message) {
    if (!logType.shouldBeLogged()) {
        return;
    }
    EventFloodRegulator eventFloodRegulator = new EventFloodRegulator(auditLogable, logType);
    if (eventFloodRegulator.isLegal()) {
        AuditLog savedAuditLog = saveToDb(auditLogable, logType, message);
        if (savedAuditLog == null) {
            log.warn("Unable to create AuditLog");
        } else {
            logMessage(savedAuditLog);
        }
    }
}
#end_block

#method_before
private AuditLog saveToDb(AuditLogable auditLogable, AuditLogType logType, String loggerString) {
    AuditLog auditLog = create(auditLogable, logType, loggerString);
    if (auditLog == null) {
        return null;
    }
    auditLogable.setPropertiesForAuditLog(auditLog);
    // truncate user name
    auditLog.setUserName(StringUtils.abbreviate(auditLog.getUserName(), USERNAME_LENGTH));
    getDbFacadeInstance().getAuditLogDao().save(auditLog);
    return auditLog;
}
#method_after
private AuditLog saveToDb(AuditLogable auditLogable, AuditLogType logType, String loggerString) {
    AuditLog auditLog = create(auditLogable, logType, loggerString);
    if (auditLog == null) {
        return null;
    }
    auditLogable.setPropertiesForAuditLog(auditLog);
    // truncate user name
    auditLog.setUserName(StringUtils.abbreviate(auditLog.getUserName(), USERNAME_LENGTH));
    TransactionSupport.executeInNewTransaction(() -> {
        getDbFacadeInstance().getAuditLogDao().save(auditLog);
        return null;
    });
    return auditLog;
}
#end_block

#method_before
private void setCowVirtualSizeAndQcowCompat(DiskImage diskImage, Image glanceImage) {
    // For the qcow2 format we need to download the image header and read the virtual size from there
    byte[] imgContent = new byte[72];
    ImageDownload downloadImage = getClient().images().download(glanceImage.getId()).execute();
    try (InputStream inputStream = downloadImage.getInputStream()) {
        int bytesRead = inputStream.read(imgContent, 0, imgContent.length);
        if (bytesRead != imgContent.length) {
            throw new OpenStackImageException(OpenStackImageException.ErrorType.UNABLE_TO_DOWNLOAD_IMAGE, "Unable to read image header: " + bytesRead);
        }
    } catch (IOException e) {
        throw new OpenStackImageException(OpenStackImageException.ErrorType.UNABLE_TO_DOWNLOAD_IMAGE, "Unable to download image");
    }
    ByteBuffer b = ByteBuffer.wrap(imgContent);
    int qcow2Signature = b.getInt();
    int qcow2Version = b.getInt();
    if (qcow2Signature == QCOW2_SIGNATURE && QCOW2_VERSIONS.contains(qcow2Version)) {
        b.position(QCOW2_SIZE_OFFSET);
        diskImage.setSize(b.getLong());
        if (qcow2Version == 2) {
            diskImage.setQcowCompat(QcowCompat.QCOW2_V2);
        } else {
            diskImage.setQcowCompat(QcowCompat.QCOW2_V3);
        }
    } else {
        throw new OpenStackImageException(OpenStackImageException.ErrorType.UNRECOGNIZED_IMAGE_FORMAT, "Unable to recognize QCOW2 format");
    }
}
#method_after
private void setCowVirtualSizeAndQcowCompat(DiskImage diskImage, Image glanceImage) {
    // For the qcow2 format we need to download the image header and read the virtual size from there
    byte[] imgContent = new byte[72];
    ImageDownload downloadImage = getClient().images().download(glanceImage.getId()).execute();
    try (InputStream inputStream = downloadImage.getInputStream()) {
        int bytesRead = inputStream.read(imgContent, 0, imgContent.length);
        if (bytesRead != imgContent.length) {
            throw new OpenStackImageException(OpenStackImageException.ErrorType.UNABLE_TO_DOWNLOAD_IMAGE, "Unable to read image header: " + bytesRead);
        }
    } catch (IOException e) {
        throw new OpenStackImageException(OpenStackImageException.ErrorType.UNABLE_TO_DOWNLOAD_IMAGE, "Unable to download image");
    }
    ByteBuffer b = ByteBuffer.wrap(imgContent);
    int qcow2Signature = b.getInt();
    int qcow2Version = b.getInt();
    QcowCompat qcowCompat = QcowCompat.forQcowHeaderVersion(qcow2Version);
    if (qcow2Signature == QCOW2_SIGNATURE && qcowCompat != null && qcowCompat != QcowCompat.Undefined) {
        b.position(QCOW2_SIZE_OFFSET);
        diskImage.setSize(b.getLong());
        diskImage.setQcowCompat(qcowCompat);
    } else {
        throw new OpenStackImageException(OpenStackImageException.ErrorType.UNRECOGNIZED_IMAGE_FORMAT, "Unable to recognize QCOW2 format");
    }
}
#end_block

#method_before
@Override
public void endSuccessfully() {
    setQcowCompatForQcowImage();
    if (getParameters().getImportAsTemplate()) {
        Guid newTemplateId = createTemplate();
        // No reason for this to happen, but checking just to make sure
        if (newTemplateId != null) {
            attachDiskToTemplate(newTemplateId);
        }
    }
    updateDiskStatus(ImageStatus.OK);
    setSucceeded(true);
}
#method_after
@Override
public void endSuccessfully() {
    super.endSuccessfully();
    setQcowCompatForQcowImage();
    if (getParameters().getImportAsTemplate()) {
        Guid newTemplateId = createTemplate();
        // No reason for this to happen, but checking just to make sure
        if (newTemplateId != null) {
            attachDiskToTemplate(newTemplateId);
        }
    }
    updateDiskStatus(ImageStatus.OK);
    setSucceeded(true);
}
#end_block

#method_before
private void setQcowCompatForQcowImage() {
    Image image = imageDao.get(getDiskImage().getImageId());
    if (getDiskImage().getDiskStorageType() == DiskStorageType.IMAGE && getDiskImage().getVolumeFormat().equals(VolumeFormat.COW)) {
        setQcowCompat(image, getDiskImage().getStoragePoolId(), getDiskImage().getId(), getDiskImage().getImageId(), getStorageDomainId(), null);
        imageDao.update(image);
    }
}
#method_after
private void setQcowCompatForQcowImage() {
    Image image = imageDao.get(getDiskImage().getImageId());
    if (getDiskImage().getDiskStorageType() == DiskStorageType.IMAGE && getDiskImage().getVolumeFormat() == VolumeFormat.COW) {
        image.setQcowCompat(getDiskImage().getQcowCompat());
        imageDao.update(image);
    }
}
#end_block

#method_before
@Before
public void setUp() {
    disk1 = createDisk();
    disk1.setDiskAlias("disk1");
    disk2 = createDisk();
    disk2.setDiskAlias("disk2");
    validator = spy(new DiskImagesValidator(Arrays.asList(disk1, disk2)));
    doReturn(vmDao).when(validator).getVmDao();
    doReturn(vmDeviceDao).when(validator).getVmDeviceDao();
    doReturn(snapshotDao).when(validator).getSnapshotDao();
    doReturn(diskImageDao).when(validator).getDiskImageDao();
}
#method_after
@Before
public void setUp() {
    disk1 = createDisk();
    disk1.setDiskAlias("disk1");
    disk1.setStoragePoolId(Guid.newGuid());
    disk2 = createDisk();
    disk2.setDiskAlias("disk2");
    disk2.setStoragePoolId(Guid.newGuid());
    validator = spy(new DiskImagesValidator(Arrays.asList(disk1, disk2)));
    doReturn(vmDao).when(validator).getVmDao();
    doReturn(vmDeviceDao).when(validator).getVmDeviceDao();
    doReturn(snapshotDao).when(validator).getSnapshotDao();
    doReturn(diskImageDao).when(validator).getDiskImageDao();
    doReturn(storagePoolDao).when(validator).getStoragePoolDao();
}
#end_block

#method_before
@Test
public void testIsQcowV3SupportedForDcVersionV4() {
    disk1.setVolumeFormat(VolumeFormat.COW);
    disk1.setQcowCompat(QcowCompat.QCOW2_V3);
    assertThat(validator.isQcowVersionSupportedForDcVersion(StorageFormatType.V4), isValid());
}
#method_after
@Test
public void testIsQcowV3SupportedForDcVersionV4() {
    disk1.setVolumeFormat(VolumeFormat.COW);
    disk1.setQcowCompat(QcowCompat.QCOW2_V3);
    StoragePool sp = new StoragePool();
    sp.setStoragePoolFormatType(StorageFormatType.V4);
    when(storagePoolDao.get(any(Guid.class))).thenReturn(sp);
    assertThat(validator.isQcowVersionSupportedForDcVersion(), isValid());
}
#end_block

#method_before
@Test
public void testIsQcowV2SupportedForDcVersionV4() {
    disk1.setVolumeFormat(VolumeFormat.COW);
    disk1.setQcowCompat(QcowCompat.QCOW2_V2);
    assertThat(validator.isQcowVersionSupportedForDcVersion(StorageFormatType.V4), isValid());
}
#method_after
@Test
public void testIsQcowV2SupportedForDcVersionV4() {
    disk1.setVolumeFormat(VolumeFormat.COW);
    disk1.setQcowCompat(QcowCompat.QCOW2_V2);
    StoragePool sp = new StoragePool();
    sp.setStoragePoolFormatType(StorageFormatType.V4);
    when(storagePoolDao.get(any(Guid.class))).thenReturn(sp);
    assertThat(validator.isQcowVersionSupportedForDcVersion(), isValid());
}
#end_block

#method_before
@Test
public void testIsQcowV3SupportedForDcVersionV3() {
    disk1.setVolumeFormat(VolumeFormat.COW);
    disk1.setQcowCompat(QcowCompat.QCOW2_V3);
    assertThat(validator.isQcowVersionSupportedForDcVersion(StorageFormatType.V3), failsWith(EngineMessage.ACTION_TYPE_FAILED_QCOW_COMPAT_DOES_NOT_MATCH_DC_VERSION));
}
#method_after
@Test
public void testIsQcowV3SupportedForDcVersionV3() {
    disk1.setVolumeFormat(VolumeFormat.COW);
    disk1.setQcowCompat(QcowCompat.QCOW2_V3);
    StoragePool sp = new StoragePool();
    sp.setStoragePoolFormatType(StorageFormatType.V3);
    when(storagePoolDao.get(any(Guid.class))).thenReturn(sp);
    assertThat(validator.isQcowVersionSupportedForDcVersion(), failsWith(EngineMessage.ACTION_TYPE_FAILED_QCOW_COMPAT_DOES_NOT_MATCH_DC_VERSION));
}
#end_block

#method_before
@Test
public void testIsQcowV2SupportedForDcVersionV3() {
    disk1.setVolumeFormat(VolumeFormat.COW);
    disk1.setQcowCompat(QcowCompat.QCOW2_V2);
    assertThat(validator.isQcowVersionSupportedForDcVersion(StorageFormatType.V3), isValid());
}
#method_after
@Test
public void testIsQcowV2SupportedForDcVersionV3() {
    disk1.setVolumeFormat(VolumeFormat.COW);
    disk1.setQcowCompat(QcowCompat.QCOW2_V2);
    StoragePool sp = new StoragePool();
    sp.setStoragePoolFormatType(StorageFormatType.V3);
    when(storagePoolDao.get(any(Guid.class))).thenReturn(sp);
    assertThat(validator.isQcowVersionSupportedForDcVersion(), isValid());
}
#end_block

#method_before
@Override
@Before
public void setUp() {
    super.setUp();
    when(storagePoolDao.get(storagePoolId)).thenReturn(storagePool);
    when(providerProxy.getImageAsDiskImage(repoImageId)).thenReturn(diskImage);
    cmd.getParameters().setSourceRepoImageId(repoImageId);
    cmd.getParameters().setSourceStorageDomainId(repoStorageDomainId);
    cmd.getParameters().setStoragePoolId(storagePoolId);
    cmd.getParameters().setStorageDomainId(storageDomainId);
    doReturn(true).when(cmd).validateSpaceRequirements(any(DiskImage.class));
}
#method_after
@Override
@Before
public void setUp() {
    super.setUp();
    when(storagePoolDao.get(storagePoolId)).thenReturn(storagePool);
    when(providerProxy.getImageAsDiskImage(repoImageId)).thenReturn(diskImage);
    cmd.getParameters().setSourceRepoImageId(repoImageId);
    cmd.getParameters().setSourceStorageDomainId(repoStorageDomainId);
    cmd.getParameters().setStoragePoolId(storagePoolId);
    cmd.getParameters().setStorageDomainId(storageDomainId);
    doReturn(true).when(cmd).validateSpaceRequirements(any(DiskImage.class));
    doReturn(diskImagesValidator).when(cmd).createDiskImagesValidator(any(DiskImage.class));
}
#end_block

#method_before
@Test
public void testValidateSuccess() {
    DiskImagesValidator diskValidator = spyDiskImagesValidator();
    storagePool.setStoragePoolFormatType(StorageFormatType.V4);
    doReturn(ValidationResult.VALID).when(diskValidator).isQcowVersionSupportedForDcVersion(any(StorageFormatType.class));
    ValidateTestUtils.runAndAssertValidateSuccess(cmd);
}
#method_after
@Test
public void testValidateSuccess() {
    doReturn(ValidationResult.VALID).when(diskImagesValidator).isQcowVersionSupportedForDcVersion();
    ValidateTestUtils.runAndAssertValidateSuccess(cmd);
}
#end_block

#method_before
@Test
public void testValidateImageQcowVersionNotMatchingDcVersion() {
    DiskImagesValidator diskValidator = spyDiskImagesValidator();
    storagePool.setStoragePoolFormatType(StorageFormatType.V4);
    doReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_QCOW_COMPAT_DOES_NOT_MATCH_DC_VERSION)).when(diskValidator).isQcowVersionSupportedForDcVersion(any(StorageFormatType.class));
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_QCOW_COMPAT_DOES_NOT_MATCH_DC_VERSION);
}
#method_after
@Test
public void testValidateImageQcowVersionNotMatchingDcVersion() {
    doReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_QCOW_COMPAT_DOES_NOT_MATCH_DC_VERSION)).when(diskImagesValidator).isQcowVersionSupportedForDcVersion();
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_QCOW_COMPAT_DOES_NOT_MATCH_DC_VERSION);
}
#end_block

#method_before
public ValidationResult isQcowVersionSupportedForDcVersion(StorageFormatType storagePoolFormatType) {
    // then the engine should fail the operation.
    for (DiskImage diskImage : diskImages) {
        if (storagePoolFormatType == null || (StorageFormatType.V4.compareTo(storagePoolFormatType) > 0 && diskImage.getQcowCompat() == QcowCompat.QCOW2_V3)) {
            return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_QCOW_COMPAT_DOES_NOT_MATCH_DC_VERSION);
        }
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult isQcowVersionSupportedForDcVersion() {
    // then the engine should fail the operation.
    for (DiskImage diskImage : diskImages) {
        StorageFormatType storagePoolFormatType = getStoragePoolDao().get(diskImage.getStoragePoolId()).getStoragePoolFormatType();
        if (storagePoolFormatType.compareTo(StorageFormatType.V4) < 0 && diskImage.getQcowCompat() == QcowCompat.QCOW2_V3) {
            return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_QCOW_COMPAT_DOES_NOT_MATCH_DC_VERSION);
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
protected AddDiskParameters createAddDiskParameters() {
    DiskImage diskImage = getParameters().getDiskImage();
    ArrayList<Guid> storageIds = new ArrayList<>();
    storageIds.add(getParameters().getStorageDomainId());
    diskImage.setDiskAlias(getParameters().getDiskAlias());
    diskImage.setStorageIds(storageIds);
    diskImage.setStoragePoolId(getParameters().getStoragePoolId());
    diskImage.setId(getParameters().getImageGroupID());
    diskImage.setDiskProfileId(getParameters().getDiskProfileId());
    diskImage.setImageId(getParameters().getDestinationImageId());
    diskImage.setQuotaId(getParameters().getQuotaId());
    AddDiskParameters parameters = new AddDiskParameters(diskImage);
    parameters.setStorageDomainId(getParameters().getStorageDomainId());
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setShouldRemainIllegalOnFailedExecution(true);
    parameters.setShouldRemainLockedOnSuccesfulExecution(true);
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    parameters.setUsePassedDiskId(true);
    parameters.setUsePassedImageId(true);
    parameters.setVmSnapshotId(getParameters().getVmSnapshotId());
    return parameters;
}
#method_after
protected AddDiskParameters createAddDiskParameters() {
    DiskImage diskImage = getParameters().getDiskImage();
    ArrayList<Guid> storageIds = new ArrayList<>();
    storageIds.add(getParameters().getStorageDomainId());
    diskImage.setDiskAlias(getParameters().getDiskAlias());
    diskImage.setStorageIds(storageIds);
    diskImage.setId(getParameters().getImageGroupID());
    diskImage.setDiskProfileId(getParameters().getDiskProfileId());
    diskImage.setImageId(getParameters().getDestinationImageId());
    diskImage.setQuotaId(getParameters().getQuotaId());
    AddDiskParameters parameters = new AddDiskParameters(diskImage);
    parameters.setStorageDomainId(getParameters().getStorageDomainId());
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setShouldRemainIllegalOnFailedExecution(true);
    parameters.setShouldRemainLockedOnSuccesfulExecution(true);
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    parameters.setUsePassedDiskId(true);
    parameters.setUsePassedImageId(true);
    parameters.setVmSnapshotId(getParameters().getVmSnapshotId());
    return parameters;
}
#end_block

#method_before
private void setQcowCompatForQcowImage() {
    Image image = imageDao.get(getDiskImage().getImageId());
    if (getDiskImage().getDiskStorageType() == DiskStorageType.IMAGE && getDiskImage().getVolumeFormat().equals(VolumeFormat.COW)) {
        image.setQcowCompat(getDiskImage().getQcowCompat());
        imageDao.update(image);
    }
}
#method_after
private void setQcowCompatForQcowImage() {
    Image image = imageDao.get(getDiskImage().getImageId());
    if (getDiskImage().getDiskStorageType() == DiskStorageType.IMAGE && getDiskImage().getVolumeFormat() == VolumeFormat.COW) {
        image.setQcowCompat(getDiskImage().getQcowCompat());
        imageDao.update(image);
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    StoragePoolValidator spValidator = new StoragePoolValidator(getStoragePool());
    if (!validate(spValidator.isUp())) {
        return false;
    }
    if (getParameters().getImportAsTemplate()) {
        if (getParameters().getClusterId() == null) {
            addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
            return false;
        }
        setClusterId(getParameters().getClusterId());
        if (getCluster() == null) {
            addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
            return false;
        }
        // A Template cannot be added in a cluster without a defined architecture
        if (getCluster().getArchitecture() == ArchitectureType.undefined) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
        }
        setStoragePoolId(getParameters().getStoragePoolId());
    }
    DiskImage diskImage = null;
    try {
        diskImage = getDiskImage();
    } catch (OpenStackImageException e) {
        log.error("Unable to get the disk image from the provider proxy: ({}) {}", e.getErrorType(), e.getMessage());
        switch(e.getErrorType()) {
            case UNSUPPORTED_CONTAINER_FORMAT:
            case UNSUPPORTED_DISK_FORMAT:
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_NOT_SUPPORTED);
            case UNABLE_TO_DOWNLOAD_IMAGE:
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_DOWNLOAD_ERROR);
            case UNRECOGNIZED_IMAGE_FORMAT:
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_UNRECOGNIZED);
        }
    }
    if (diskImage == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
    }
    if (!validate(createDiskImagesValidator(diskImage).isQcowVersionSupportedForDcVersion(getStoragePool().getStoragePoolFormatType()))) {
        return false;
    }
    return validateSpaceRequirements(diskImage);
}
#method_after
@Override
protected boolean validate() {
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    if (getParameters().getImportAsTemplate()) {
        if (getParameters().getClusterId() == null) {
            addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
            return false;
        }
        setClusterId(getParameters().getClusterId());
        if (getCluster() == null) {
            addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
            return false;
        }
        // A Template cannot be added in a cluster without a defined architecture
        if (getCluster().getArchitecture() == ArchitectureType.undefined) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
        }
        setStoragePoolId(getParameters().getStoragePoolId());
    }
    DiskImage diskImage = null;
    try {
        diskImage = getDiskImage();
    } catch (OpenStackImageException e) {
        log.error("Unable to get the disk image from the provider proxy: ({}) {}", e.getErrorType(), e.getMessage());
        switch(e.getErrorType()) {
            case UNSUPPORTED_CONTAINER_FORMAT:
            case UNSUPPORTED_DISK_FORMAT:
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_NOT_SUPPORTED);
            case UNABLE_TO_DOWNLOAD_IMAGE:
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_DOWNLOAD_ERROR);
            case UNRECOGNIZED_IMAGE_FORMAT:
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_UNRECOGNIZED);
        }
    }
    if (diskImage == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
    }
    diskImage.setStoragePoolId(getStoragePoolId());
    if (!validate(createDiskImagesValidator(diskImage).isQcowVersionSupportedForDcVersion())) {
        return false;
    }
    return validateSpaceRequirements(diskImage);
}
#end_block

#method_before
@Test
public void testIsExternalVM() throws IOException {
    try {
        XmlDocument xmlDocument = new XmlDocument(getXmlOvfData());
        assertFalse("VM should not be external VM", OvfUtils.isExternalVM(xmlDocument));
    } catch (Exception e) {
        e.printStackTrace();
    }
}
#method_after
@Test
public void testIsExternalVM() throws Exception {
    XmlDocument xmlDocument = new XmlDocument(getXmlOvfData());
    assertFalse("VM should not be external VM", OvfUtils.isExternalVM(xmlDocument));
}
#end_block

#method_before
@Test
public void testUpdateUnregisteredDisksWithVMsWithInitializedUnregDisks() throws IOException {
    try {
        XmlDocument xmlDocument = new XmlDocument(getXmlOvfData());
        List<UnregisteredDisk> unregDisks = new ArrayList<>();
        UnregisteredDisk unregDisk = new UnregisteredDisk();
        unregDisk.getDiskImage().setId(Guid.createGuidFromString("f934b12c-1e22-4ad8-bbce-ec0b2a5defa4"));
        unregDisk.getDiskImage().setStorageIds(new ArrayList<>(Collections.singletonList(Guid.createGuidFromString("7e2a7eac-3b76-4d45-a7dd-caae8fe0f588"))));
        unregDisks.add(unregDisk);
        OvfUtils.updateUnregisteredDisksWithVMs(unregDisks, Guid.newGuid(), "TestVM", xmlDocument);
        assertTrue("The list of disks should not be empty", !unregDisks.isEmpty());
        assertTrue("The VMs id is set in the unregisteterd disks", !unregDisks.get(0).getVms().isEmpty());
    } catch (Exception e) {
        e.printStackTrace();
    }
}
#method_after
@Test
public void testUpdateUnregisteredDisksWithVMsWithInitializedUnregDisks() throws IOException {
    try {
        XmlDocument xmlDocument = new XmlDocument(getXmlOvfData());
        List<UnregisteredDisk> unregDisks = new ArrayList<>();
        UnregisteredDisk unregDisk = new UnregisteredDisk();
        unregDisk.getDiskImage().setId(Guid.createGuidFromString("8c634412-1e8b-4ef3-bc40-b67a456e9d2f"));
        unregDisk.getDiskImage().setStorageIds(new ArrayList<>(Collections.singletonList(Guid.createGuidFromString("7e2a7eac-3b76-4d45-a7dd-caae8fe0f588"))));
        unregDisks.add(unregDisk);
        OvfUtils.updateUnregisteredDisksWithVMs(unregDisks, Guid.newGuid(), "TestVM", xmlDocument);
        assertTrue("The list of disks should not be empty", !unregDisks.isEmpty());
        assertTrue("The VMs id is set in the unregisteterd disks", !unregDisks.get(0).getVms().isEmpty());
    } catch (Exception e) {
        e.printStackTrace();
    }
}
#end_block

#method_before
public static boolean isExternalVM(XmlDocument xmlDocument) {
    XmlNode content = xmlDocument.selectSingleNode("//*/Content");
    NodeList nodeList = content.getChildNodes();
    for (int i = 0; i < nodeList.getLength(); i++) {
        Node node = nodeList.item(i);
        if (node.getNodeName().equals(VM_ORIGIN) && node.getChildNodes().item(0) != null) {
            Integer originType = new Integer(node.getChildNodes().item(0).getNodeValue());
            return OriginType.EXTERNAL == OriginType.forValue(originType);
        }
    }
    return false;
}
#method_after
public static boolean isExternalVM(XmlDocument xmlDocument) {
    XmlNode content = xmlDocument.selectSingleNode("//*/Content");
    NodeList nodeList = content.getChildNodes();
    for (int i = 0; i < nodeList.getLength(); i++) {
        Node node = nodeList.item(i);
        if (node.getNodeName().equals(VM_ORIGIN) && node.getChildNodes().item(0) != null) {
            Integer originType = Integer.valueOf(node.getChildNodes().item(0).getNodeValue());
            return OriginType.EXTERNAL == OriginType.forValue(originType);
        }
    }
    return false;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (isVmInDb) {
                if (pendingAsyncTasks) {
                    return getSucceeded() ? AuditLogType.USER_ADD_VM_TEMPLATE : AuditLogType.USER_FAILED_ADD_VM_TEMPLATE;
                } else {
                    return getSucceeded() ? AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS : getAuditLogFailureType();
                }
            } else {
                return getSucceeded() ? AuditLogType.USER_ADD_VM_TEMPLATE_SUCCESS : AuditLogType.USER_ADD_VM_TEMPLATE_FAILURE;
            }
        case END_SUCCESS:
            if (isVmInDb) {
                return getSucceeded() ? AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS : getAuditLogFailureType();
            }
            return AuditLogType.UNASSIGNED;
        default:
            return getAuditLogFailureType();
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (isVmInDb) {
                if (pendingAsyncTasks) {
                    return getSucceeded() ? AuditLogType.USER_ADD_VM_TEMPLATE : AuditLogType.USER_FAILED_ADD_VM_TEMPLATE;
                } else {
                    return getSucceeded() ? AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS : getAuditLogFailureType();
                }
            } else {
                return getSucceeded() ? AuditLogType.USER_ADD_VM_TEMPLATE_SUCCESS : AuditLogType.USER_ADD_VM_TEMPLATE_FAILURE;
            }
        case END_SUCCESS:
            if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
                return getSucceeded() ? AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS : getAuditLogFailureType();
            }
            return AuditLogType.UNASSIGNED;
        default:
            return getAuditLogFailureType();
    }
}
#end_block

#method_before
public static void fillImagesMapBasedOnTemplate(VmTemplate template, List<StorageDomain> domains, Map<Guid, DiskImage> diskInfoDestinationMap, Map<Guid, StorageDomain> destStorages) {
    Map<Guid, StorageDomain> storageDomainsMap = new HashMap<>();
    for (StorageDomain storageDomain : domains) {
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (validator.isDomainExistAndActive().isValid() && validator.domainIsValidDestination().isValid()) {
            storageDomainsMap.put(storageDomain.getId(), storageDomain);
        }
    }
    for (DiskImage image : template.getDiskTemplateMap().values()) {
        for (Guid storageId : image.getStorageIds()) {
            if (storageDomainsMap.containsKey(storageId)) {
                ArrayList<Guid> storageIds = new ArrayList<>();
                storageIds.add(storageId);
                image.setStorageIds(storageIds);
                diskInfoDestinationMap.put(image.getId(), image);
                break;
            }
        }
    }
    if (destStorages != null) {
        destStorages.putAll(diskInfoDestinationMap.values().stream().collect(Collectors.toMap(d -> d.getStorageIds().get(0), d -> storageDomainsMap.get(d.getStorageIds().get(0)))));
    }
}
#method_after
public static void fillImagesMapBasedOnTemplate(VmTemplate template, List<StorageDomain> domains, Map<Guid, DiskImage> diskInfoDestinationMap, Map<Guid, StorageDomain> destStorages) {
    Map<Guid, StorageDomain> storageDomainsMap = domains.stream().filter(ImagesHandler::isDomainValidDestination).collect(Collectors.toMap(StorageDomain::getId, Function.identity()));
    for (DiskImage image : template.getDiskTemplateMap().values()) {
        for (Guid storageId : image.getStorageIds()) {
            if (storageDomainsMap.containsKey(storageId)) {
                ArrayList<Guid> storageIds = new ArrayList<>();
                storageIds.add(storageId);
                image.setStorageIds(storageIds);
                diskInfoDestinationMap.put(image.getId(), image);
                break;
            }
        }
    }
    if (destStorages != null) {
        destStorages.putAll(diskInfoDestinationMap.values().stream().collect(Collectors.toMap(d -> d.getStorageIds().get(0), d -> storageDomainsMap.get(d.getStorageIds().get(0)))));
    }
}
#end_block

#method_before
public static boolean checkImagesConfiguration(Guid storageDomainId, Collection<? extends Disk> disksConfigList, List<String> messages) {
    StorageDomainStatic storageDomain = DbFacade.getInstance().getStorageDomainStaticDao().get(storageDomainId);
    return !disksConfigList.stream().filter(disk -> DiskStorageType.IMAGE == disk.getDiskStorageType()).anyMatch(disk -> !checkImageConfiguration(storageDomain, (DiskImage) disk, messages));
}
#method_after
public static boolean checkImagesConfiguration(Guid storageDomainId, Collection<? extends Disk> disksConfigList, List<String> messages) {
    StorageDomainStatic storageDomain = DbFacade.getInstance().getStorageDomainStaticDao().get(storageDomainId);
    return !disksConfigList.stream().filter(DisksFilter.ONLY_IMAGES).anyMatch(disk -> !checkImageConfiguration(storageDomain, (DiskImage) disk, messages));
}
#end_block

#method_before
public static Map<Guid, List<DiskImage>> getImagesLeaf(List<DiskImage> images) {
    Map<Guid, List<DiskImage>> retVal = new HashMap<>();
    images.stream().forEach(image -> MultiValueMapUtils.addToMap(image.getId(), image, retVal));
    retVal.values().forEach(ImagesHandler::sortImageList);
    return retVal;
}
#method_after
public static Map<Guid, List<DiskImage>> getImagesLeaf(List<DiskImage> images) {
    Map<Guid, List<DiskImage>> retVal = new HashMap<>();
    images.forEach(image -> MultiValueMapUtils.addToMap(image.getId(), image, retVal));
    retVal.values().forEach(ImagesHandler::sortImageList);
    return retVal;
}
#end_block

#method_before
public static void sortImageList(List<DiskImage> images) {
    List<DiskImage> hold = new ArrayList<>();
    DiskImage curr = null;
    // find the first image
    for (int i = 0; i < images.size(); i++) {
        int pos = getFirstImage(images, images.get(i));
        if (pos == -1) {
            curr = images.get(i);
            hold.add(images.get(i));
            images.remove(images.get(i));
            break;
        }
    }
    while (images.size() > 0) {
        int pos = getNextImage(images, curr);
        if (pos == -1) {
            log.error("Image list error in SortImageList");
            break;
        }
        curr = images.get(pos);
        hold.add(images.get(pos));
        images.remove(images.get(pos));
    }
    images.addAll(hold);
}
#method_after
public static void sortImageList(List<DiskImage> images) {
    List<DiskImage> hold = new ArrayList<>();
    DiskImage curr = null;
    // find the first image
    for (int i = 0; i < images.size(); i++) {
        int pos = getFirstImage(images, images.get(i));
        if (pos == -1) {
            curr = images.get(i);
            hold.add(images.get(i));
            images.remove(images.get(i));
            break;
        }
    }
    while (images.size() > 0) {
        int pos = getNextImage(images, curr);
        if (pos == -1) {
            log.error("Image list error in SortImageList");
            break;
        }
        curr = images.get(pos);
        hold.add(images.get(pos));
        images.remove(images.get(pos));
    }
    for (DiskImage image : hold) {
        images.add(image);
    }
}
#end_block

#method_before
public static void updateAllDiskImagesSnapshotsStatusInTransactionWithCompensation(final Collection<Guid> diskIds, final ImageStatus status, ImageStatus statusForCompensation, final CompensationContext compensationContext) {
    if (compensationContext != null) {
        diskIds.stream().flatMap(diskId -> DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForImageGroup(diskId).stream()).forEach(diskSnapshot -> {
            diskSnapshot.setImageStatus(statusForCompensation);
            compensationContext.snapshotEntityStatus(diskSnapshot.getImage());
        });
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            diskIds.stream().forEach(diskId -> DbFacade.getInstance().getImageDao().updateStatusOfImagesByImageGroupId(diskId, status));
            compensationContext.stateChanged();
            return null;
        });
    } else {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            diskIds.stream().forEach(diskId -> DbFacade.getInstance().getImageDao().updateStatusOfImagesByImageGroupId(diskId, status));
            return null;
        });
    }
}
#method_after
public static void updateAllDiskImagesSnapshotsStatusInTransactionWithCompensation(final Collection<Guid> diskIds, final ImageStatus status, ImageStatus statusForCompensation, final CompensationContext compensationContext) {
    if (compensationContext != null) {
        diskIds.stream().flatMap(diskId -> DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForImageGroup(diskId).stream()).forEach(diskSnapshot -> {
            diskSnapshot.setImageStatus(statusForCompensation);
            compensationContext.snapshotEntityStatus(diskSnapshot.getImage());
        });
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            diskIds.forEach(diskId -> DbFacade.getInstance().getImageDao().updateStatusOfImagesByImageGroupId(diskId, status));
            compensationContext.stateChanged();
            return null;
        });
    } else {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            diskIds.forEach(diskId -> DbFacade.getInstance().getImageDao().updateStatusOfImagesByImageGroupId(diskId, status));
            return null;
        });
    }
}
#end_block

#method_before
private static DiskImage getDiskImageById(Guid id, List<DiskImage> diskImages) {
    return diskImages.stream().filter(disk -> disk.getId().equals(id)).findFirst().orElse(null);
}
#method_after
private static DiskImage getDiskImageById(Guid id, Collection<DiskImage> diskImages) {
    return diskImages.stream().filter(disk -> disk.getId().equals(id)).findFirst().orElse(null);
}
#end_block

#method_before
public static List<DiskImage> imagesSubtract(List<DiskImage> images, List<DiskImage> imagesToSubtract) {
    return images.stream().filter(image -> getDiskImageById(image.getId(), imagesToSubtract) == null).collect(Collectors.toList());
}
#method_after
public static List<DiskImage> imagesSubtract(Collection<DiskImage> images, Collection<DiskImage> imagesToSubtract) {
    return images.stream().filter(image -> getDiskImageById(image.getId(), imagesToSubtract) == null).collect(Collectors.toList());
}
#end_block

#method_before
public static List<DiskImage> imagesIntersection(List<DiskImage> images1, List<DiskImage> images2) {
    return images1.stream().filter(image -> getDiskImageById(image.getId(), images2) != null).collect(Collectors.toList());
}
#method_after
public static List<DiskImage> imagesIntersection(Collection<DiskImage> images1, Collection<DiskImage> images2) {
    return images1.stream().filter(image -> getDiskImageById(image.getId(), images2) != null).collect(Collectors.toList());
}
#end_block

#method_before
@Test
public void validateDiskIsOvfStore() {
    initializeCommand(new DiskImage());
    initVmDiskImage(false);
    command.getImage().setContentType(DiskContentType.OVF_STORE);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_DISK_CONTENT_TYPE_NOT_SUPPORTED_FOR_OPERATION);
}
#method_after
@Test
public void validateDiskIsOvfStore() {
    testMoveOrCopyForContentTypeFails(DiskContentType.OVF_STORE);
}
#end_block

#method_before
@Test
public void testMoveOrCopyMemoryDiskFails() {
    initializeCommand(new DiskImage());
    initVmDiskImage(false);
    command.getImage().setContentType(DiskContentType.MEMORY_DUMP_VOLUME);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_DISK_CONTENT_TYPE_NOT_SUPPORTED_FOR_OPERATION);
}
#method_after
@Test
public void testMoveOrCopyMemoryDiskFails() {
    testMoveOrCopyForContentTypeFails(DiskContentType.MEMORY_DUMP_VOLUME);
}
#end_block

#method_before
public List<VmDevice> getCdDevices(Guid vmId) {
    return vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName());
}
#method_after
public List<VmDevice> getCdDevices(Guid vmId) {
    return vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.DISK, VmDeviceType.CDROM);
}
#end_block

#method_before
public List<VmDevice> getSmartcardDevices(Guid vmId) {
    return vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.SMARTCARD, VmDeviceType.SMARTCARD.getName());
}
#method_after
public List<VmDevice> getSmartcardDevices(Guid vmId) {
    return vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.SMARTCARD, VmDeviceType.SMARTCARD);
}
#end_block

#method_before
public List<VmDevice> getConsoleDevices(Guid vmId) {
    return vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.CONSOLE, VmDeviceType.CONSOLE.getName());
}
#method_after
public List<VmDevice> getConsoleDevices(Guid vmId) {
    return vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.CONSOLE, VmDeviceType.CONSOLE);
}
#end_block

#method_before
public List<VmDevice> getUsbControllers(Guid vmId) {
    return vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.CONTROLLER, VmDeviceType.USB.getName());
}
#method_after
public List<VmDevice> getUsbControllers(Guid vmId) {
    return vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.CONTROLLER, VmDeviceType.USB);
}
#end_block

#method_before
public List<VmDevice> getUsbSlots(Guid vmId) {
    return vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.REDIR, VmDeviceType.SPICEVMC.getName());
}
#method_after
public List<VmDevice> getUsbSlots(Guid vmId) {
    return vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.REDIR, VmDeviceType.SPICEVMC);
}
#end_block

#method_before
public List<VmDevice> getUsbChannels(Guid vmId) {
    return vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.REDIRDEV, VmDeviceType.SPICEVMC.getName());
}
#method_after
public List<VmDevice> getUsbChannels(Guid vmId) {
    return vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.REDIRDEV, VmDeviceType.SPICEVMC);
}
#end_block

#method_before
public void removeLeftOverDevices(VmBase vmBase) {
    if (!hasGraphicsDevice(vmBase.getId(), GraphicsType.SPICE)) {
        // remove spice channel if we are no longer using spice
        List<VmDevice> spiceChannels = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmBase.getId(), VmDeviceGeneralType.CHANNEL, VmDeviceType.SPICEVMC.getName());
        removeVmDevices(spiceChannels);
    }
}
#method_after
public void removeLeftOverDevices(VmBase vmBase) {
    if (!hasGraphicsDevice(vmBase.getId(), GraphicsType.SPICE)) {
        // remove spice channel if we are no longer using spice
        List<VmDevice> spiceChannels = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmBase.getId(), VmDeviceGeneralType.CHANNEL, VmDeviceType.SPICEVMC);
        removeVmDevices(spiceChannels);
    }
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (getFlow() == RunVmFlow.REMOVE_STATELESS_IMAGES) {
                return AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT;
            }
            if (getFlow() == RunVmFlow.RESUME_PAUSE) {
                return getSucceeded() ? AuditLogType.USER_RESUME_VM : AuditLogType.USER_FAILED_RESUME_VM;
            } else if (isInternalExecution()) {
                if (getSucceeded()) {
                    boolean isStateless = isStatelessSnapshotExistsForVm();
                    if (isStateless) {
                        return _isRerun ? AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS : AuditLogType.USER_RUN_VM_AS_STATELESS;
                    } else if (getFlow() == RunVmFlow.CREATE_STATELESS_IMAGES) {
                        return AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING;
                    } else {
                        return AuditLogType.VDS_INITIATED_RUN_VM;
                    }
                }
                return AuditLogType.VDS_INITIATED_RUN_VM_FAILED;
            } else {
                return getSucceeded() ? getActionReturnValue() == VMStatus.Up ? isVmRunningOnNonDefaultVds() ? AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS : isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS : AuditLogType.USER_RUN_VM : _isRerun ? AuditLogType.VDS_INITIATED_RUN_VM : getVm().isRunAndPause() ? AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE : getTaskIdList().isEmpty() && getFlow() != RunVmFlow.CREATE_STATELESS_IMAGES ? AuditLogType.USER_STARTED_VM : AuditLogType.USER_INITIATED_RUN_VM : _isRerun ? AuditLogType.USER_INITIATED_RUN_VM_FAILED : AuditLogType.USER_FAILED_RUN_VM;
            }
        case END_SUCCESS:
            // command should be with 'CommandShouldBeLogged = false':
            return isStatelessSnapshotExistsForVm() && !getSucceeded() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        case END_FAILURE:
            // be with 'CommandShouldBeLogged = false':
            return isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        default:
            // false':
            return AuditLogType.UNASSIGNED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (getFlow() == RunVmFlow.REMOVE_STATELESS_IMAGES) {
                return AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT;
            }
            if (getFlow() == RunVmFlow.RESUME_PAUSE) {
                return getSucceeded() ? AuditLogType.USER_RESUME_VM : AuditLogType.USER_FAILED_RESUME_VM;
            } else if (isInternalExecution()) {
                if (getSucceeded()) {
                    boolean isStateless = isStatelessSnapshotExistsForVm();
                    if (isStateless) {
                        return AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS;
                    } else if (getFlow() == RunVmFlow.CREATE_STATELESS_IMAGES) {
                        return AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING;
                    } else {
                        return AuditLogType.VDS_INITIATED_RUN_VM;
                    }
                }
                return AuditLogType.VDS_INITIATED_RUN_VM_FAILED;
            } else {
                return getSucceeded() ? getActionReturnValue() == VMStatus.Up ? isVmRunningOnNonDefaultVds() ? AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS : isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS : AuditLogType.USER_RUN_VM : _isRerun ? AuditLogType.VDS_INITIATED_RUN_VM : getVm().isRunAndPause() ? AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE : getFlow() == RunVmFlow.CREATE_STATELESS_IMAGES ? AuditLogType.USER_INITIATED_RUN_VM : AuditLogType.USER_STARTED_VM : _isRerun ? AuditLogType.USER_INITIATED_RUN_VM_FAILED : AuditLogType.USER_FAILED_RUN_VM;
            }
        case END_SUCCESS:
            // command should be with 'CommandShouldBeLogged = false':
            return isStatelessSnapshotExistsForVm() && !getSucceeded() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        case END_FAILURE:
            // be with 'CommandShouldBeLogged = false':
            return isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        default:
            // false':
            return AuditLogType.UNASSIGNED;
    }
}
#end_block

#method_before
boolean checkRngDeviceClusterCompatibility() {
    List<VmDevice> rngDevs = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(getVmId(), VmDeviceGeneralType.RNG, VmDeviceType.VIRTIO.getName());
    if (rngDevs.isEmpty()) {
        return true;
    }
    VmRngDevice rngDevice = new VmRngDevice(rngDevs.get(0));
    final RngUtils.RngValidationResult rngValidationResult = RngUtils.validate(getCluster(), rngDevice, getVm().getCompatibilityVersion());
    switch(rngValidationResult) {
        case VALID:
            return true;
        case UNSUPPORTED_URANDOM_OR_RANDOM:
            log.warn("Running VM {}({}) with rng source {} that is not supported in cluster {}.", getVm().getName(), getVm().getId(), rngDevice.getSource(), getCluster().getName());
            return true;
        case INVALID:
            return false;
        default:
            throw new RuntimeException("Unknown enum constant " + rngValidationResult);
    }
}
#method_after
boolean checkRngDeviceClusterCompatibility() {
    List<VmDevice> rngDevs = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(getVmId(), VmDeviceGeneralType.RNG, VmDeviceType.VIRTIO);
    if (rngDevs.isEmpty()) {
        return true;
    }
    VmRngDevice rngDevice = new VmRngDevice(rngDevs.get(0));
    final RngUtils.RngValidationResult rngValidationResult = RngUtils.validate(getCluster(), rngDevice, getVm().getCompatibilityVersion());
    switch(rngValidationResult) {
        case VALID:
            return true;
        case UNSUPPORTED_URANDOM_OR_RANDOM:
            log.warn("Running VM {}({}) with rng source {} that is not supported in cluster {}.", getVm().getName(), getVm().getId(), rngDevice.getSource(), getCluster().getName());
            return true;
        case INVALID:
            return false;
        default:
            throw new RuntimeException("Unknown enum constant " + rngValidationResult);
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVm() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!isSpecifiedDisksExist(getParameters().getDiskIds())) {
        return false;
    }
    if (getParameters().getDiskIds() != null) {
        String notAllowSnapshot = diskDao.getAllForVm(getVm().getId()).stream().filter(disk -> getParameters().getDiskIds().contains(disk.getId())).filter(disk -> !disk.isAllowSnapshot()).map(disk -> disk.getId().toString()).collect(Collectors.joining(","));
        if (!notAllowSnapshot.isEmpty()) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_SNAPSHOT_DISKS);
            addValidationMessageVariable("diskIds", notAllowSnapshot);
            return false;
        }
    }
    // Initialize validators.
    VmValidator vmValidator = createVmValidator();
    StoragePoolValidator spValidator = createStoragePoolValidator();
    DiskImagesValidator diskImagesValidatorForChain = createDiskImageValidator(DisksFilter.filterImageDisks(getDisksList(), ONLY_NOT_SHAREABLE, ONLY_SNAPABLE, ONLY_ACTIVE));
    if (!(validateVM(vmValidator) && validate(spValidator.isUp()) && validate(vmValidator.vmNotIlegal()) && validate(vmValidator.vmNotLocked()) && validate(snapshotsValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotsValidator.vmNotInPreview(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()) && validate(diskImagesValidatorForChain.diskImagesHaveNotExceededMaxNumberOfVolumesInImageChain()) && (!getParameters().isSaveMemory() || validate(vmValidator.vmNotHavingPciPassthroughDevices())))) {
        return false;
    }
    List<DiskImage> disksList = getDisksListForChecks();
    if (disksList.size() > 0) {
        DiskImagesValidator diskImagesValidator = createDiskImageValidator(disksList);
        if (!(validate(diskImagesValidator.diskImagesNotLocked()) && validate(diskImagesValidator.diskImagesNotIllegal()))) {
            return false;
        }
    }
    return validateStorage();
}
#method_after
@Override
protected boolean validate() {
    if (getVm() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    Set<Guid> specifiedDiskIds = getParameters().getDiskIds();
    if (specifiedDiskIds != null && !specifiedDiskIds.isEmpty()) {
        if (!isSpecifiedDisksExist(specifiedDiskIds)) {
            return false;
        }
        String notAllowSnapshot = diskDao.getAllForVm(getVm().getId()).stream().filter(disk -> specifiedDiskIds.contains(disk.getId())).filter(disk -> !disk.isAllowSnapshot()).map(BaseDisk::getDiskAlias).collect(Collectors.joining(", "));
        if (!notAllowSnapshot.isEmpty()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_SNAPSHOT_NOT_SUPPORTED, String.format("$diskAliases %s", notAllowSnapshot));
        }
    }
    // Initialize validators.
    VmValidator vmValidator = createVmValidator();
    StoragePoolValidator spValidator = createStoragePoolValidator();
    DiskImagesValidator diskImagesValidatorForChain = createDiskImageValidator(DisksFilter.filterImageDisks(getDisksList(), ONLY_NOT_SHAREABLE, ONLY_SNAPABLE, ONLY_ACTIVE));
    if (!(validateVM(vmValidator) && validate(spValidator.isUp()) && validate(vmValidator.vmNotIlegal()) && validate(vmValidator.vmNotLocked()) && validate(snapshotsValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotsValidator.vmNotInPreview(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()) && validate(diskImagesValidatorForChain.diskImagesHaveNotExceededMaxNumberOfVolumesInImageChain()) && (!getParameters().isSaveMemory() || validate(vmValidator.vmNotHavingPciPassthroughDevices())))) {
        return false;
    }
    List<DiskImage> disksList = getDisksListForChecks();
    if (disksList.size() > 0) {
        DiskImagesValidator diskImagesValidator = createDiskImageValidator(disksList);
        if (!(validate(diskImagesValidator.diskImagesNotLocked()) && validate(diskImagesValidator.diskImagesNotIllegal()))) {
            return false;
        }
    }
    return validateStorage();
}
#end_block

#method_before
private boolean isSpecifiedDisksExist(Set<Guid> disks) {
    if (disks == null || disks.isEmpty()) {
        return true;
    }
    DiskExistenceValidator diskExistenceValidator = createDiskExistenceValidator(disks);
    if (!validate(diskExistenceValidator.diskImagesNotExist())) {
        return false;
    }
    return true;
}
#method_after
private boolean isSpecifiedDisksExist(Set<Guid> disks) {
    DiskExistenceValidator diskExistenceValidator = createDiskExistenceValidator(disks);
    if (!validate(diskExistenceValidator.diskImagesNotExist())) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public int setTabIndexes(int nextTabIndex) {
    nextTabIndex = super.setTabIndexes(nextTabIndex);
    nextTabIndex = createSubnetEditor.setTabIndexes(nextTabIndex);
    nextTabIndex = this.subnetWidget.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    nextTabIndex = createSubnetEditor.setTabIndexes(nextTabIndex);
    nextTabIndex = this.subnetWidget.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#end_block

#method_before
protected void commonInitialize() {
    priorityUtil = new PriorityUtil(getModel());
    virtioScsiUtil = new VirtioScsiUtil(getModel());
    getModel().getVmId().setIsAvailable(false);
    getModel().getLease().setIsChangeable(false);
    getModel().getIsHighlyAvailable().getEntityChangedEvent().addListener((ev, sender, args) -> {
        boolean ha = getModel().getIsHighlyAvailable().getEntity();
        getModel().getLease().setIsChangeable(ha);
        if (!ha) {
            getModel().getLease().setSelectedItem(null);
        }
    });
    getModel().getMigrationPolicies().setItems(AsyncDataProvider.getInstance().getMigrationPolicies(Version.getLast()));
}
#method_after
protected void commonInitialize() {
    priorityUtil = new PriorityUtil(getModel());
    virtioScsiUtil = new VirtioScsiUtil(getModel());
    getModel().getVmId().setIsAvailable(false);
    getModel().getLease().setIsChangeable(false);
    getModel().getIsHighlyAvailable().getEntityChangedEvent().addListener((ev, sender, args) -> {
        boolean ha = getModel().getIsHighlyAvailable().getEntity();
        setVmLeasesAvailability();
        if (!ha) {
            getModel().getLease().setSelectedItem(null);
        }
    });
    getModel().getMigrationPolicies().setItems(AsyncDataProvider.getInstance().getMigrationPolicies(Version.getLast()));
}
#end_block

#method_before
private void setVmLeasesAvailability() {
    TModel model = getModel();
    Version compVer = model.getSelectedCluster().getCompatibilityVersion();
    if (model.getCustomCompatibilityVersion().getSelectedItem() != null) {
        compVer = model.getCustomCompatibilityVersion().getSelectedItem();
    }
    model.getLease().setIsChangeable(AsyncDataProvider.getInstance().isVmLeasesFeatureSupported(compVer), constants.vmLeasesSupported());
}
#method_after
private void setVmLeasesAvailability() {
    TModel model = getModel();
    if (model.getSelectedCluster() == null) {
        return;
    }
    Version compVer = model.getSelectedCluster().getCompatibilityVersion();
    if (model.getCustomCompatibilityVersion().getSelectedItem() != null) {
        compVer = model.getCustomCompatibilityVersion().getSelectedItem();
    }
    boolean vmLeasesSupported = AsyncDataProvider.getInstance().isVmLeasesFeatureSupported(compVer);
    if (!vmLeasesSupported) {
        model.getLease().setIsChangeable(false, constants.vmLeasesSupported());
    } else {
        model.getLease().setIsChangeable(model.getIsHighlyAvailable().getEntity());
        if (!model.getIsHighlyAvailable().getEntity()) {
            model.getLease().setChangeProhibitionReason(constants.vmLeasesNotSupportedWithoutHA());
        }
    }
}
#end_block

#method_before
private void setRngAvailability() {
    TModel model = getModel();
    Set<VmRngDevice.Source> requiredRngSources = model.getSelectedCluster().getRequiredRngSources();
    boolean requiredRngSourcesEmpty = requiredRngSources.isEmpty();
    boolean urandomSourceAvailable = requiredRngSources.contains(VmRngDevice.Source.URANDOM) || requiredRngSources.contains(VmRngDevice.Source.RANDOM);
    boolean hwrngSourceAvailable = requiredRngSources.contains(VmRngDevice.Source.HWRNG);
    model.getIsRngEnabled().setIsChangeable(!requiredRngSourcesEmpty);
    model.getRngPeriod().setIsChangeable(!requiredRngSourcesEmpty);
    model.getRngBytes().setIsChangeable(!requiredRngSourcesEmpty);
    if (requiredRngSourcesEmpty) {
        model.getIsRngEnabled().setChangeProhibitionReason(constants.rngNotSupportedByCluster());
        model.getRngPeriod().setChangeProhibitionReason(constants.rngNotSupportedByCluster());
        model.getRngBytes().setChangeProhibitionReason(constants.rngNotSupportedByCluster());
    }
    model.getRngSourceUrandom().setIsChangeable(urandomSourceAvailable);
    if (!urandomSourceAvailable) {
        model.getRngSourceUrandom().setChangeProhibitionReason(messages.rngSourceNotSupportedByCluster(VmRngDevice.Source.getUrandomOrRandomFor(getModel().getSelectedCluster().getCompatibilityVersion()).toString().toLowerCase()));
    }
    model.getRngSourceHwrng().setIsChangeable(hwrngSourceAvailable);
    if (!hwrngSourceAvailable) {
        model.getRngSourceHwrng().setChangeProhibitionReason(messages.rngSourceNotSupportedByCluster(VmRngDevice.Source.HWRNG.toString().toLowerCase()));
    }
}
#method_after
private void setRngAvailability() {
    TModel model = getModel();
    Set<VmRngDevice.Source> requiredRngSources = model.getSelectedCluster().getRequiredRngSources();
    boolean urandomSourceAvailable = requiredRngSources.contains(VmRngDevice.Source.URANDOM) || requiredRngSources.contains(VmRngDevice.Source.RANDOM);
    boolean hwrngSourceAvailable = requiredRngSources.contains(VmRngDevice.Source.HWRNG);
    model.getRngSourceUrandom().setIsChangeable(urandomSourceAvailable);
    if (!urandomSourceAvailable) {
        model.getRngSourceUrandom().setChangeProhibitionReason(messages.rngSourceNotSupportedByCluster(VmRngDevice.Source.getUrandomOrRandomFor(getModel().getSelectedCluster().getCompatibilityVersion()).toString().toLowerCase()));
    }
    model.getRngSourceHwrng().setIsChangeable(hwrngSourceAvailable);
    if (!hwrngSourceAvailable) {
        model.getRngSourceHwrng().setChangeProhibitionReason(messages.rngSourceNotSupportedByCluster(VmRngDevice.Source.HWRNG.toString().toLowerCase()));
    }
}
#end_block

#method_before
protected void updateLeaseStorageDomains(final Guid selectedStorageDomainId) {
    setVmLeasesAvailability();
    AsyncDataProvider.getInstance().getStorageDomainList(new AsyncQuery<>(returnValue -> {
        List<StorageDomain> domains = new ArrayList<>();
        domains.add(null);
        for (StorageDomain domain : returnValue) {
            if (domain.getStorageDomainType().isDataDomain() && domain.getStatus() == StorageDomainStatus.Active) {
                domains.add(domain);
            }
        }
        getModel().getLease().setItems(domains);
        if (!getModel().getLease().getIsChangable() || selectedStorageDomainId == null) {
            getModel().getLease().setSelectedItem(null);
        } else {
            for (StorageDomain domain : domains) {
                if (domain != null && selectedStorageDomainId.equals(domain.getId())) {
                    getModel().getLease().setSelectedItem(domain);
                    break;
                }
            }
        }
    }), getModel().getSelectedDataCenter().getId());
}
#method_after
protected void updateLeaseStorageDomains(final Guid selectedStorageDomainId) {
    setVmLeasesAvailability();
    AsyncDataProvider.getInstance().getStorageDomainList(new AsyncQuery<>(returnValue -> {
        List<StorageDomain> domains = new ArrayList<>();
        domains.add(null);
        for (StorageDomain domain : returnValue) {
            if (domain.getStorageDomainType().isDataDomain() && domain.getStatus() == StorageDomainStatus.Active) {
                domains.add(domain);
            }
        }
        getModel().getLease().setItems(domains);
        if (selectedStorageDomainId != null) {
            domains.stream().filter(d -> d != null && selectedStorageDomainId.equals(d.getId())).findFirst().ifPresent(d -> getModel().getLease().setSelectedItem(d));
        }
    }), getModel().getSelectedDataCenter().getId());
}
#end_block

#method_before
protected void updateRngDevice(Guid templateId) {
    if (!getModel().getIsRngEnabled().getIsChangable()) {
        return;
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(templateId), new AsyncQuery<VdcQueryReturnValue>(returnValue -> {
        List<VmRngDevice> devs = returnValue.getReturnValue();
        getModel().getIsRngEnabled().setEntity(!devs.isEmpty());
        final VmRngDevice rngDevice = devs.isEmpty() ? new VmRngDevice() : devs.get(0);
        rngDevice.updateSourceByVersion(getModel().getCompatibilityVersion());
        getModel().setRngDevice(rngDevice);
    }));
}
#method_after
protected void updateRngDevice(Guid templateId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(templateId), new AsyncQuery<VdcQueryReturnValue>(returnValue -> {
        List<VmRngDevice> devs = returnValue.getReturnValue();
        getModel().getIsRngEnabled().setEntity(!devs.isEmpty());
        final VmRngDevice rngDevice = devs.isEmpty() ? new VmRngDevice() : devs.get(0);
        rngDevice.updateSourceByVersion(getModel().getCompatibilityVersion());
        getModel().setRngDevice(rngDevice);
    }));
}
#end_block

#method_before
void logRenamedEntity() {
    if (this instanceof RenamedEntityInfoProvider) {
        RenamedEntityInfoProvider renameable = (RenamedEntityInfoProvider) this;
        String oldEntityName = renameable.getEntityOldName();
        String newEntityName = renameable.getEntityNewName();
        if (!StringUtils.equals(oldEntityName, newEntityName)) {
            // log entity rename details
            AuditLogableBase logable = new AuditLogableBase();
            String entityType = renameable.getEntityType();
            logable.addCustomValue("EntityType", entityType);
            logable.addCustomValue("OldEntityName", oldEntityName);
            logable.addCustomValue("NewEntityName", newEntityName);
            logable.addCustomValue("UserName", getCurrentUser().getLoginName());
            renameable.setEntityId(logable);
            auditLog(logable, AuditLogType.ENTITY_RENAMED);
        }
    }
}
#method_after
void logRenamedEntity() {
    if (this instanceof RenamedEntityInfoProvider) {
        RenamedEntityInfoProvider renameable = (RenamedEntityInfoProvider) this;
        String oldEntityName = renameable.getEntityOldName();
        String newEntityName = renameable.getEntityNewName();
        if (!StringUtils.equals(oldEntityName, newEntityName)) {
            // log entity rename details
            AuditLogable logable = new AuditLogableImpl();
            String entityType = renameable.getEntityType();
            logable.addCustomValue("EntityType", entityType);
            logable.addCustomValue("OldEntityName", oldEntityName);
            logable.addCustomValue("NewEntityName", newEntityName);
            logable.addCustomValue("UserName", getCurrentUser().getLoginName());
            renameable.setEntityId(logable);
            auditLog(logable, AuditLogType.ENTITY_RENAMED);
        }
    }
}
#end_block

#method_before
protected void auditLog(AuditLogableBase logable, AuditLogType logType) {
    auditLogDirector.log(logable, logType);
}
#method_after
protected void auditLog(AuditLogable logable, AuditLogType logType) {
    auditLogDirector.log(logable, logType);
}
#end_block

#method_before
protected final boolean failValidation(EngineMessage message, String... variableReplacements) {
    return failValidation(Collections.singletonList(message), variableReplacements);
}
#method_after
protected final boolean failValidation(EngineMessage message, String... variableReplacements) {
    return failValidation(message, Arrays.asList(variableReplacements));
}
#end_block

#method_before
protected final boolean failValidation(List<EngineMessage> messages, String... variableReplacements) {
    addValidationMessages(messages);
    for (String variableReplacement : variableReplacements) {
        addValidationMessage(variableReplacement);
    }
    return false;
}
#method_after
protected final boolean failValidation(EngineMessage message, Collection<String> variableReplacements) {
    return failValidation(Collections.singletonList(message), variableReplacements);
}
#end_block

#method_before
protected final boolean failValidation(List<EngineMessage> messages, String... variableReplacements) {
    addValidationMessages(messages);
    for (String variableReplacement : variableReplacements) {
        addValidationMessage(variableReplacement);
    }
    return false;
}
#method_after
protected final boolean failValidation(List<EngineMessage> messages, String... variableReplacements) {
    return failValidation(messages, Arrays.asList(variableReplacements));
}
#end_block

#method_before
protected ArrayList<VdcReturnValueBase> runInternalMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, ExecutionContext executionContext) {
    return getBackend().runInternalMultipleActions(actionType, parameters, context.clone().withExecutionContext(executionContext));
}
#method_after
protected List<VdcReturnValueBase> runInternalMultipleActions(VdcActionType actionType, List<VdcActionParametersBase> parameters) {
    return getBackend().runInternalMultipleActions(actionType, parameters, context.clone());
}
#end_block

#method_before
@Test
public void testGetPendingHostResources() {
    PendingResourceManager manager = new PendingResourceManager();
    VDS host1 = new VDS();
    host1.setId(Guid.newGuid());
    VDS host2 = new VDS();
    host2.setId(Guid.newGuid());
    VM vm1 = new VM();
    vm1.setId(Guid.newGuid());
    VM vm2 = new VM();
    vm2.setId(Guid.newGuid());
    VM vm3 = new VM();
    vm3.setId(Guid.newGuid());
    manager.addPending(new PendingVM(host1, vm1));
    manager.addPending(new PendingMemory(host1, vm1, 768));
    manager.addPending(new PendingCpuCores(host1, vm1, 1));
    manager.addPending(new PendingVM(host2, vm2));
    manager.addPending(new PendingMemory(host2, vm2, 1024));
    manager.addPending(new PendingCpuCores(host2, vm2, 10));
    manager.addPending(new PendingVM(host1, vm3));
    manager.addPending(new PendingMemory(host1, vm3, 1024));
    manager.addPending(new PendingCpuCores(host1, vm3, 10));
    List<PendingVM> vms = Lists.newArrayList(manager.pendingHostResources(host1.getId(), PendingVM.class));
    assertThat(vms).hasSize(2).extracting(PendingResource::getVm).containsOnly(vm1.getId(), vm3.getId());
}
#method_after
@Test
public void testGetPendingHostResources() {
    PendingResourceManager manager = new PendingResourceManager();
    VDS host1 = new VDS();
    host1.setId(Guid.newGuid());
    VDS host2 = new VDS();
    host2.setId(Guid.newGuid());
    VM vm1 = new VM();
    vm1.setId(Guid.newGuid());
    VM vm2 = new VM();
    vm2.setId(Guid.newGuid());
    VM vm3 = new VM();
    vm3.setId(Guid.newGuid());
    manager.addPending(new PendingVM(host1, vm1));
    manager.addPending(new PendingMemory(host1, vm1, 768));
    manager.addPending(new PendingCpuCores(host1, vm1, 1));
    manager.addPending(new PendingVM(host2, vm2));
    manager.addPending(new PendingMemory(host2, vm2, 1024));
    manager.addPending(new PendingCpuCores(host2, vm2, 10));
    manager.addPending(new PendingVM(host1, vm3));
    manager.addPending(new PendingMemory(host1, vm3, 1024));
    manager.addPending(new PendingCpuCores(host1, vm3, 10));
    List<PendingVM> vms = manager.pendingHostResources(host1.getId(), PendingVM.class);
    assertThat(vms).hasSize(2).extracting(PendingResource::getVm).containsOnly(vm1.getId(), vm3.getId());
}
#end_block

#method_before
@Test
public void testGetPendingVmResources() {
    PendingResourceManager manager = new PendingResourceManager();
    VDS host1 = new VDS();
    host1.setId(Guid.newGuid());
    VDS host2 = new VDS();
    host2.setId(Guid.newGuid());
    VM vm1 = new VM();
    vm1.setId(Guid.newGuid());
    VM vm2 = new VM();
    vm2.setId(Guid.newGuid());
    manager.addPending(new PendingVM(host1, vm1));
    manager.addPending(new PendingMemory(host1, vm1, 768));
    manager.addPending(new PendingCpuCores(host1, vm1, 1));
    manager.addPending(new PendingVM(host2, vm2));
    manager.addPending(new PendingMemory(host2, vm2, 1024));
    manager.addPending(new PendingCpuCores(host2, vm2, 10));
    List<PendingMemory> memories = Lists.newArrayList(manager.pendingVmResources(vm1.getId(), PendingMemory.class));
    assertThat(memories).hasSize(1).extracting(PendingMemory::getSizeInMb).containsOnly(768L);
}
#method_after
@Test
public void testGetPendingVmResources() {
    PendingResourceManager manager = new PendingResourceManager();
    VDS host1 = new VDS();
    host1.setId(Guid.newGuid());
    VDS host2 = new VDS();
    host2.setId(Guid.newGuid());
    VM vm1 = new VM();
    vm1.setId(Guid.newGuid());
    VM vm2 = new VM();
    vm2.setId(Guid.newGuid());
    manager.addPending(new PendingVM(host1, vm1));
    manager.addPending(new PendingMemory(host1, vm1, 768));
    manager.addPending(new PendingCpuCores(host1, vm1, 1));
    manager.addPending(new PendingVM(host2, vm2));
    manager.addPending(new PendingMemory(host2, vm2, 1024));
    manager.addPending(new PendingCpuCores(host2, vm2, 10));
    List<PendingMemory> memories = manager.pendingVmResources(vm1.getId(), PendingMemory.class);
    assertThat(memories).hasSize(1).extracting(PendingMemory::getSizeInMb).containsOnly(768L);
}
#end_block

#method_before
public void clearVm(VmStatic vm) {
    Set<Guid> modifiedHosts;
    synchronized (this) {
        if (!resourcesByVm.containsKey(vm.getId())) {
            return;
        }
        log.debug("Clearing pending resources for VM {}", vm.getId());
        modifiedHosts = new HashSet<>();
        /* Remove all resources associated with the VM from the global set
             * and from the byHost index
             */
        resourcesByVm.compute(vm.getId(), (vmId, resources) -> {
            for (PendingResource resource : resources) {
                resourcesByHost.computeIfPresent(resource.getHost(), (hostId, hostResources) -> {
                    modifiedHosts.add(hostId);
                    hostResources.remove(resource);
                    return hostResources;
                });
                pendingResources.remove(resource);
            }
            resources.clear();
            return resources;
        });
    }
    for (Guid hostId : modifiedHosts) {
        notifyHostManagers(hostId);
    }
}
#method_after
public void clearVm(VmStatic vm) {
    Set<Guid> modifiedHosts;
    synchronized (this) {
        if (!resourcesByVm.containsKey(vm.getId())) {
            return;
        }
        log.debug("Clearing pending resources for VM {}", vm.getId());
        modifiedHosts = new HashSet<>();
        /* Remove all resources associated with the VM from the global set
             * and from the byHost index
             */
        resourcesByVm.compute(vm.getId(), (vmId, resources) -> {
            resources.stream().peek(pendingResources::remove).filter(r -> removeFromSetMap(resourcesByHost, r.getHost(), r)).map(PendingResource::getHost).forEach(modifiedHosts::add);
            resources.clear();
            return resources;
        });
    }
    for (Guid hostId : modifiedHosts) {
        notifyHostManagers(hostId);
    }
}
#end_block

#method_before
public void clearHost(VDS host) {
    synchronized (this) {
        if (!resourcesByHost.containsKey(host.getId())) {
            return;
        }
        log.debug("Clearing pending resources for host {}", host.getId());
        /* Remove all resources associated with the host from the global set
             *  and from the byVm index
             */
        resourcesByHost.compute(host.getId(), (hostId, resources) -> {
            for (PendingResource resource : resources) {
                resourcesByVm.computeIfPresent(resource.getVm(), (vmId, vmResources) -> {
                    vmResources.remove(resource);
                    return vmResources;
                });
                pendingResources.remove(resource);
            }
            resources.clear();
            return resources;
        });
    }
    notifyHostManagers(host.getId());
}
#method_after
public void clearHost(VDS host) {
    synchronized (this) {
        if (!resourcesByHost.containsKey(host.getId())) {
            return;
        }
        log.debug("Clearing pending resources for host {}", host.getId());
        /* Remove all resources associated with the host from the global set
             *  and from the byVm index
             */
        resourcesByHost.compute(host.getId(), (hostId, resources) -> {
            resources.stream().peek(pendingResources::remove).forEach(r -> removeFromSetMap(resourcesByVm, r.getVm(), r));
            resources.clear();
            return resources;
        });
    }
    notifyHostManagers(host.getId());
}
#end_block

#method_before
public void addPending(PendingResource resource) {
    synchronized (this) {
        /* Clear VM and Host indexes when the resource is added again.
             *  This should not happen in theory, but lets anticipate future bugs :)
             */
        if (pendingResources.containsKey(resource)) {
            PendingResource old = pendingResources.get(resource);
            log.warn("Clearing stale pending resource {} (host: {}, vm: {})", old, old.getHost(), old.getVm());
            resourcesByVm.compute(old.getVm(), (vmId, vmResources) -> {
                vmResources.remove(old);
                return vmResources;
            });
            resourcesByHost.compute(old.getHost(), (hostId, hostResources) -> {
                hostResources.remove(old);
                return hostResources;
            });
        }
        log.debug("Adding pending resource {} (host: {}, vm: {})", resource, resource.getHost(), resource.getVm());
        /* Make sure the index lists exist */
        if (!resourcesByVm.containsKey(resource.getVm())) {
            resourcesByVm.put(resource.getVm(), new HashSet<>());
        }
        if (!resourcesByHost.containsKey(resource.getHost())) {
            resourcesByHost.put(resource.getHost(), new HashSet<>());
        }
        /* Update indexes */
        resourcesByVm.compute(resource.getVm(), (vmId, vmResources) -> {
            vmResources.add(resource);
            return vmResources;
        });
        resourcesByHost.compute(resource.getHost(), (vmId, hostResources) -> {
            hostResources.add(resource);
            return hostResources;
        });
        pendingResources.put(resource, resource);
    }
}
#method_after
public void addPending(PendingResource resource) {
    synchronized (this) {
        /* Clear VM and Host indexes when the resource is added again.
             *  This should not happen in theory, but lets anticipate future bugs :)
             */
        if (pendingResources.containsKey(resource)) {
            PendingResource old = pendingResources.get(resource);
            log.warn("Clearing stale pending resource {} (host: {}, vm: {})", old, old.getHost(), old.getVm());
            removeFromSetMap(resourcesByVm, old.getVm(), old);
            removeFromSetMap(resourcesByHost, old.getHost(), old);
        }
        log.debug("Adding pending resource {} (host: {}, vm: {})", resource, resource.getHost(), resource.getVm());
        /* Update indexes */
        addToSetMap(resourcesByVm, resource.getVm(), resource);
        addToSetMap(resourcesByHost, resource.getHost(), resource);
        pendingResources.put(resource, resource);
    }
}
#end_block

#method_before
public <T extends PendingResource> Iterable<T> pendingHostResources(Guid host, Class<T> type) {
    if (!resourcesByHost.containsKey(host)) {
        return Collections.emptyList();
    }
    List<T> list = new ArrayList<>();
    resourcesByHost.compute(host, (hostId, resources) -> {
        for (PendingResource resource : resources) {
            if (resource.getClass().equals(type)) {
                list.add((T) resource);
            }
        }
        return resources;
    });
    return list;
}
#method_after
public <T extends PendingResource> List<T> pendingHostResources(Guid host, Class<T> type) {
    return collectResources(resourcesByHost, host, res -> res.getClass().equals(type)).stream().map(r -> (T) r).collect(Collectors.toList());
}
#end_block

#method_before
public <T extends PendingResource> Iterable<T> pendingVmResources(Guid vm, Class<T> type) {
    if (!resourcesByVm.containsKey(vm)) {
        return Collections.emptyList();
    }
    List<T> list = new ArrayList<>();
    resourcesByVm.compute(vm, (vmId, resources) -> {
        for (PendingResource resource : resources) {
            if (resource.getClass().equals(type)) {
                list.add((T) resource);
            }
        }
        return resources;
    });
    return list;
}
#method_after
public <T extends PendingResource> List<T> pendingVmResources(Guid vm, Class<T> type) {
    return collectResources(resourcesByVm, vm, res -> res.getClass().equals(type)).stream().map(r -> (T) r).collect(Collectors.toList());
}
#end_block

#method_before
private void auditLogFailedToConnect() {
    AuditLogable loggable = new AuditLogableImpl();
    Injector.get(AuditLogDirector.class).log(loggable, AuditLogType.FAILED_TO_CONNECT_TO_SCHEDULER_PROXY);
}
#method_after
private void auditLogFailedToConnect() {
    AuditLogable loggable = new AuditLogableImpl();
    auditLogDirector.log(loggable, AuditLogType.FAILED_TO_CONNECT_TO_SCHEDULER_PROXY);
}
#end_block

#method_before
private void updateAuditLog(ExtendCinderDiskCommand command, AuditLogType auditLogType, Long imageSizeInGigabytes) {
    command.addCustomValue("DiskAlias", getDisk(command).getDiskAlias());
    command.addCustomValue("NewSize", String.valueOf(imageSizeInGigabytes));
    Injector.get(AuditLogDirector.class).log(command, auditLogType);
}
#method_after
private void updateAuditLog(ExtendCinderDiskCommand command, AuditLogType auditLogType, Long imageSizeInGigabytes) {
    command.addCustomValue("DiskAlias", getDisk(command).getDiskAlias());
    command.addCustomValue("NewSize", String.valueOf(imageSizeInGigabytes));
    auditLogDirector.log(command, auditLogType);
}
#end_block

#method_before
public boolean discover() {
    boolean dbUpdated;
    Optional<ExternalSchedulerDiscoveryResult> discoveryResult = broker.runDiscover();
    if (discoveryResult.isPresent()) {
        updateDB(discoveryResult.get());
        log.debug("PolicyUnits updated for external broker.");
        dbUpdated = true;
    } else {
        AuditLogable loggable = new AuditLogableImpl();
        Injector.get(AuditLogDirector.class).log(loggable, AuditLogType.FAILED_TO_CONNECT_TO_SCHEDULER_PROXY);
        log.warn("Discovery returned empty result when talking to broker. Disabling external units");
        List<PolicyUnit> failingPolicyUnits = policyUnitDao.getAll().stream().collect(Collectors.toList());
        markExternalPoliciesAsDisabled(failingPolicyUnits);
        dbUpdated = true;
    }
    return dbUpdated;
}
#method_after
public boolean discover() {
    boolean dbUpdated;
    Optional<ExternalSchedulerDiscoveryResult> discoveryResult = broker.runDiscover();
    if (discoveryResult.isPresent()) {
        updateDB(discoveryResult.get());
        log.debug("PolicyUnits updated for external broker.");
        dbUpdated = true;
    } else {
        AuditLogable loggable = new AuditLogableImpl();
        auditLogDirector.log(loggable, AuditLogType.FAILED_TO_CONNECT_TO_SCHEDULER_PROXY);
        log.warn("Discovery returned empty result when talking to broker. Disabling external units");
        List<PolicyUnit> failingPolicyUnits = policyUnitDao.getAll().stream().collect(Collectors.toList());
        markExternalPoliciesAsDisabled(failingPolicyUnits);
        dbUpdated = true;
    }
    return dbUpdated;
}
#end_block

#method_before
private void setRngAvailability() {
    TModel model = getModel();
    Set<VmRngDevice.Source> requiredRngSources = model.getSelectedCluster().getRequiredRngSources();
    boolean requiredRngSourcesEmpty = isRequiredRngSourcesEmpty();
    boolean urandomSourceAvailable = requiredRngSources.contains(VmRngDevice.Source.URANDOM) || requiredRngSources.contains(VmRngDevice.Source.RANDOM);
    boolean hwrngSourceAvailable = requiredRngSources.contains(VmRngDevice.Source.HWRNG);
    model.getIsRngEnabled().setIsChangeable(!requiredRngSourcesEmpty);
    model.getRngPeriod().setIsChangeable(!requiredRngSourcesEmpty);
    model.getRngBytes().setIsChangeable(!requiredRngSourcesEmpty);
    if (requiredRngSourcesEmpty) {
        model.getIsRngEnabled().setChangeProhibitionReason(constants.rngNotSupportedByCluster());
        model.getRngPeriod().setChangeProhibitionReason(constants.rngNotSupportedByCluster());
        model.getRngBytes().setChangeProhibitionReason(constants.rngNotSupportedByCluster());
    }
    model.getRngSourceUrandom().setIsChangeable(urandomSourceAvailable);
    if (!urandomSourceAvailable) {
        model.getRngSourceUrandom().setChangeProhibitionReason(messages.rngSourceNotSupportedByCluster(VmRngDevice.Source.getUrandomOrRandomFor(getModel().getSelectedCluster().getCompatibilityVersion()).toString().toLowerCase()));
    }
    model.getRngSourceHwrng().setIsChangeable(hwrngSourceAvailable);
    if (!hwrngSourceAvailable) {
        model.getRngSourceHwrng().setChangeProhibitionReason(messages.rngSourceNotSupportedByCluster(VmRngDevice.Source.HWRNG.toString().toLowerCase()));
    }
}
#method_after
private void setRngAvailability() {
    TModel model = getModel();
    Set<VmRngDevice.Source> requiredRngSources = model.getSelectedCluster().getRequiredRngSources();
    boolean urandomSourceAvailable = requiredRngSources.contains(VmRngDevice.Source.URANDOM) || requiredRngSources.contains(VmRngDevice.Source.RANDOM);
    boolean hwrngSourceAvailable = requiredRngSources.contains(VmRngDevice.Source.HWRNG);
    model.getRngSourceUrandom().setIsChangeable(urandomSourceAvailable);
    if (!urandomSourceAvailable) {
        model.getRngSourceUrandom().setChangeProhibitionReason(messages.rngSourceNotSupportedByCluster(VmRngDevice.Source.getUrandomOrRandomFor(getModel().getSelectedCluster().getCompatibilityVersion()).toString().toLowerCase()));
    }
    model.getRngSourceHwrng().setIsChangeable(hwrngSourceAvailable);
    if (!hwrngSourceAvailable) {
        model.getRngSourceHwrng().setChangeProhibitionReason(messages.rngSourceNotSupportedByCluster(VmRngDevice.Source.HWRNG.toString().toLowerCase()));
    }
}
#end_block

#method_before
protected void updateRngDevice(Guid templateId) {
    if (isRequiredRngSourcesEmpty()) {
        return;
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(templateId), new AsyncQuery<VdcQueryReturnValue>(returnValue -> {
        List<VmRngDevice> devs = returnValue.getReturnValue();
        getModel().getIsRngEnabled().setEntity(!devs.isEmpty());
        final VmRngDevice rngDevice = devs.isEmpty() ? new VmRngDevice() : devs.get(0);
        rngDevice.updateSourceByVersion(getModel().getCompatibilityVersion());
        getModel().setRngDevice(rngDevice);
    }));
}
#method_after
protected void updateRngDevice(Guid templateId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(templateId), new AsyncQuery<VdcQueryReturnValue>(returnValue -> {
        List<VmRngDevice> devs = returnValue.getReturnValue();
        getModel().getIsRngEnabled().setEntity(!devs.isEmpty());
        final VmRngDevice rngDevice = devs.isEmpty() ? new VmRngDevice() : devs.get(0);
        rngDevice.updateSourceByVersion(getModel().getCompatibilityVersion());
        getModel().setRngDevice(rngDevice);
    }));
}
#end_block

#method_before
@Test
public void testNoAffinityGroups() {
    List<VDS> hosts = Arrays.asList(host1, host2);
    Map<Guid, Integer> scores = collectScores(policyUnit.score(cluster, hosts, newVm, null));
    assertEquals((Integer) 1, scores.get(host1.getId()));
    assertEquals((Integer) 1, scores.get(host2.getId()));
}
#method_after
@Test
public void testNoAffinityGroups() {
    List<VDS> hosts = Arrays.asList(host1, host2);
    Map<Guid, Integer> scores = collectScores(policyUnit.score(cluster, hosts, newVm, null));
    assertEquals(scores.get(host1.getId()), scores.get(host2.getId()));
}
#end_block

#method_before
@Test
public void testFirstVm() {
    List<VDS> hosts = Arrays.asList(host1, host2);
    VM vm1 = createVMDown(cluster);
    VM vm2 = createVMDown(cluster);
    affinityGroups.add(createAffinityGroup(cluster, EntityAffinityRule.POSITIVE, true, vm1, vm2, newVm));
    Map<Guid, Integer> scores = collectScores(policyUnit.score(cluster, hosts, newVm, null));
    assertEquals((Integer) 1, scores.get(host1.getId()));
    assertEquals((Integer) 1, scores.get(host2.getId()));
    affinityGroups.clear();
    affinityGroups.add(createAffinityGroup(cluster, EntityAffinityRule.POSITIVE, false, vm1, vm2, newVm));
    scores = collectScores(policyUnit.score(cluster, hosts, newVm, null));
    assertEquals((Integer) 1, scores.get(host1.getId()));
    assertEquals((Integer) 1, scores.get(host2.getId()));
}
#method_after
@Test
public void testFirstVm() {
    List<VDS> hosts = Arrays.asList(host1, host2);
    VM vm1 = createVMDown(cluster);
    VM vm2 = createVMDown(cluster);
    affinityGroups.add(createAffinityGroup(cluster, EntityAffinityRule.POSITIVE, true, vm1, vm2, newVm));
    Map<Guid, Integer> scores = collectScores(policyUnit.score(cluster, hosts, newVm, null));
    assertEquals(scores.get(host1.getId()), scores.get(host2.getId()));
    affinityGroups.clear();
    affinityGroups.add(createAffinityGroup(cluster, EntityAffinityRule.POSITIVE, false, vm1, vm2, newVm));
    scores = collectScores(policyUnit.score(cluster, hosts, newVm, null));
    assertEquals(scores.get(host1.getId()), scores.get(host2.getId()));
}
#end_block

#method_before
@Test
public void testPositiveAffinity() {
    List<VDS> hosts = Arrays.asList(host1, host2);
    VM vm1 = createVmRunning(host2);
    VM vm2 = createVmRunning(host2);
    affinityGroups.add(createAffinityGroup(cluster, EntityAffinityRule.POSITIVE, true, vm1, vm2, newVm));
    Map<Guid, Integer> scores = collectScores(policyUnit.score(cluster, hosts, newVm, null));
    assertEquals((Integer) 1000, scores.get(host1.getId()));
    assertEquals((Integer) 1, scores.get(host2.getId()));
    affinityGroups.clear();
    affinityGroups.add(createAffinityGroup(cluster, EntityAffinityRule.POSITIVE, false, vm1, vm2, newVm));
    scores = collectScores(policyUnit.score(cluster, hosts, newVm, null));
    assertEquals((Integer) 1000, scores.get(host1.getId()));
    assertEquals((Integer) 1, scores.get(host2.getId()));
}
#method_after
@Test
public void testPositiveAffinity() {
    List<VDS> hosts = Arrays.asList(host1, host2, host3);
    VM vm1 = createVmRunning(host2);
    VM vm2 = createVmRunning(host2);
    affinityGroups.add(createAffinityGroup(cluster, EntityAffinityRule.POSITIVE, true, vm1, vm2, newVm));
    Map<Guid, Integer> scores = collectScores(policyUnit.score(cluster, hosts, newVm, null));
    assertEquals(scores.get(host1.getId()), scores.get(host3.getId()));
    assertThat(scores.get(host1.getId())).isGreaterThan(scores.get(host2.getId()));
    affinityGroups.clear();
    affinityGroups.add(createAffinityGroup(cluster, EntityAffinityRule.POSITIVE, false, vm1, vm2, newVm));
    scores = collectScores(policyUnit.score(cluster, hosts, newVm, null));
    assertEquals(scores.get(host1.getId()), scores.get(host3.getId()));
    assertThat(scores.get(host1.getId())).isGreaterThan(scores.get(host2.getId()));
}
#end_block

#method_before
@Test
public void testPositiveAffinityWithPinnedOrHE() {
    List<VDS> hosts = Arrays.asList(host1, host2, host3);
    VM vm1 = createVmRunning(host2);
    VM vm2 = createVmRunning(host3);
    vm1.setMigrationSupport(MigrationSupport.PINNED_TO_HOST);
    affinityGroups.add(createAffinityGroup(cluster, EntityAffinityRule.POSITIVE, true, vm1, vm2, newVm));
    Map<Guid, Integer> scores = collectScores(policyUnit.score(cluster, hosts, newVm, null));
    assertEquals((Integer) 1000, scores.get(host1.getId()));
    assertEquals((Integer) 1, scores.get(host2.getId()));
    assertEquals((Integer) 2, scores.get(host3.getId()));
    vm1.setMigrationSupport(MigrationSupport.MIGRATABLE);
    vm1.setOrigin(OriginType.HOSTED_ENGINE);
    scores = collectScores(policyUnit.score(cluster, hosts, newVm, null));
    assertEquals((Integer) 1000, scores.get(host1.getId()));
    assertEquals((Integer) 1, scores.get(host2.getId()));
    assertEquals((Integer) 2, scores.get(host3.getId()));
    vm1.setMigrationSupport(MigrationSupport.PINNED_TO_HOST);
    vm1.setOrigin(OriginType.RHEV);
    affinityGroups.clear();
    affinityGroups.add(createAffinityGroup(cluster, EntityAffinityRule.POSITIVE, false, vm1, vm2, newVm));
    scores = collectScores(policyUnit.score(cluster, hosts, newVm, null));
    assertEquals((Integer) 1000, scores.get(host1.getId()));
    assertEquals((Integer) 1, scores.get(host2.getId()));
    assertEquals((Integer) 2, scores.get(host3.getId()));
    vm1.setMigrationSupport(MigrationSupport.MIGRATABLE);
    vm1.setOrigin(OriginType.HOSTED_ENGINE);
    scores = collectScores(policyUnit.score(cluster, hosts, newVm, null));
    assertEquals((Integer) 1000, scores.get(host1.getId()));
    assertEquals((Integer) 1, scores.get(host2.getId()));
    assertEquals((Integer) 2, scores.get(host3.getId()));
}
#method_after
@Test
public void testPositiveAffinityWithPinnedOrHE() {
    List<VDS> hosts = Arrays.asList(host1, host2, host3);
    VM vm1 = createVmRunning(host2);
    VM vm2 = createVmRunning(host3);
    vm1.setMigrationSupport(MigrationSupport.PINNED_TO_HOST);
    affinityGroups.add(createAffinityGroup(cluster, EntityAffinityRule.POSITIVE, true, vm1, vm2, newVm));
    Map<Guid, Integer> scores = collectScores(policyUnit.score(cluster, hosts, newVm, null));
    assertThat(scores.get(host2.getId())).isLessThan(scores.get(host3.getId()));
    assertThat(scores.get(host3.getId())).isLessThan(scores.get(host1.getId()));
    vm1.setMigrationSupport(MigrationSupport.MIGRATABLE);
    vm1.setOrigin(OriginType.HOSTED_ENGINE);
    scores = collectScores(policyUnit.score(cluster, hosts, newVm, null));
    assertThat(scores.get(host2.getId())).isLessThan(scores.get(host3.getId()));
    assertThat(scores.get(host3.getId())).isLessThan(scores.get(host1.getId()));
    vm1.setMigrationSupport(MigrationSupport.PINNED_TO_HOST);
    vm1.setOrigin(OriginType.RHEV);
    affinityGroups.clear();
    affinityGroups.add(createAffinityGroup(cluster, EntityAffinityRule.POSITIVE, false, vm1, vm2, newVm));
    scores = collectScores(policyUnit.score(cluster, hosts, newVm, null));
    assertThat(scores.get(host2.getId())).isLessThan(scores.get(host3.getId()));
    assertThat(scores.get(host3.getId())).isLessThan(scores.get(host1.getId()));
    vm1.setMigrationSupport(MigrationSupport.MIGRATABLE);
    vm1.setOrigin(OriginType.HOSTED_ENGINE);
    scores = collectScores(policyUnit.score(cluster, hosts, newVm, null));
    assertThat(scores.get(host2.getId())).isLessThan(scores.get(host3.getId()));
    assertThat(scores.get(host3.getId())).isLessThan(scores.get(host1.getId()));
}
#end_block

#method_before
@Test
public void testNegativeAffinity() {
    List<VDS> hosts = Arrays.asList(host1, host2, host3);
    VM vm1 = createVmRunning(host1);
    VM vm2 = createVmRunning(host3);
    affinityGroups.add(createAffinityGroup(cluster, EntityAffinityRule.NEGATIVE, true, vm1, vm2, newVm));
    Map<Guid, Integer> scores = collectScores(policyUnit.score(cluster, hosts, newVm, null));
    assertEquals((Integer) 1000, scores.get(host1.getId()));
    assertEquals((Integer) 1, scores.get(host2.getId()));
    assertEquals((Integer) 1000, scores.get(host3.getId()));
    affinityGroups.clear();
    affinityGroups.add(createAffinityGroup(cluster, EntityAffinityRule.NEGATIVE, false, vm1, vm2, newVm));
    scores = collectScores(policyUnit.score(cluster, hosts, newVm, null));
    assertEquals((Integer) 1000, scores.get(host1.getId()));
    assertEquals((Integer) 1, scores.get(host2.getId()));
    assertEquals((Integer) 1000, scores.get(host3.getId()));
}
#method_after
@Test
public void testNegativeAffinity() {
    List<VDS> hosts = Arrays.asList(host1, host2, host3);
    VM vm1 = createVmRunning(host1);
    VM vm2 = createVmRunning(host3);
    affinityGroups.add(createAffinityGroup(cluster, EntityAffinityRule.NEGATIVE, true, vm1, vm2, newVm));
    Map<Guid, Integer> scores = collectScores(policyUnit.score(cluster, hosts, newVm, null));
    assertEquals(scores.get(host1.getId()), scores.get(host3.getId()));
    assertThat(scores.get(host1.getId())).isGreaterThan(scores.get(host2.getId()));
    affinityGroups.clear();
    affinityGroups.add(createAffinityGroup(cluster, EntityAffinityRule.NEGATIVE, false, vm1, vm2, newVm));
    scores = collectScores(policyUnit.score(cluster, hosts, newVm, null));
    assertEquals(scores.get(host1.getId()), scores.get(host3.getId()));
    assertThat(scores.get(host1.getId())).isGreaterThan(scores.get(host2.getId()));
}
#end_block

#method_before
private boolean isVmMigratable(VM vm) {
    return (vm.getMigrationSupport() == MigrationSupport.MIGRATABLE) && !vm.isHostedEngine();
}
#method_after
private static boolean isVmMigratable(VM vm) {
    return (vm.getMigrationSupport() == MigrationSupport.MIGRATABLE) && !vm.isHostedEngine();
}
#end_block

#method_before
public Optional<Guid> schedule(Cluster cluster, VM vm, List<Guid> hostBlackList, List<Guid> hostWhiteList, List<Guid> destHostIdList, List<String> messages, VdsFreeMemoryChecker memoryChecker, String correlationId) {
    prepareClusterLock(cluster.getId());
    try {
        log.debug("Scheduling started, correlation Id: {}", correlationId);
        checkAllowOverbooking(cluster);
        lockCluster(cluster.getId());
        List<VDS> vdsList = getVdsDao().getAllForClusterWithStatus(cluster.getId(), VDSStatus.Up);
        vdsList = removeBlacklistedHosts(vdsList, hostBlackList);
        vdsList = keepOnlyWhitelistedHosts(vdsList, hostWhiteList);
        refreshCachedPendingValues(vdsList);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), cluster, vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker, true, correlationId);
        if (vdsList.isEmpty()) {
            return Optional.empty();
        }
        Optional<Guid> bestHost = selectBestHost(cluster, vm, destHostIdList, vdsList, policy, parameters);
        if (bestHost.isPresent() && !bestHost.get().equals(vm.getRunOnVds())) {
            Guid bestHostId = bestHost.get();
            getPendingResourceManager().addPending(new PendingCpuCores(bestHostId, vm, vm.getNumOfCpus()));
            VDS bestHostEntity = vdsList.stream().filter(vds -> vds.getId().equals(bestHostId)).findFirst().get();
            getPendingResourceManager().addPending(new PendingMemory(bestHostId, vm, bestHostEntity.getGuestOverhead()));
            getPendingResourceManager().addPending(new PendingOvercommitMemory(bestHostId, vm, vm.getMemSizeMb()));
            getPendingResourceManager().addPending(new PendingVM(bestHostId, vm));
            getPendingResourceManager().notifyHostManagers(bestHostId);
            markVfsAsUsedByVm(vm, bestHostId);
        }
        return bestHost;
    } catch (InterruptedException e) {
        log.error("scheduling interrupted, correlation Id: {}: {}", correlationId, e.getMessage());
        log.debug("Exception: ", e);
        return Optional.empty();
    } finally {
        releaseCluster(cluster.getId());
        log.debug("Scheduling ended, correlation Id: {}", correlationId);
    }
}
#method_after
public Optional<Guid> schedule(Cluster cluster, VM vm, List<Guid> hostBlackList, List<Guid> hostWhiteList, List<Guid> destHostIdList, List<String> messages, RunVmDelayer runVmDelayer, String correlationId) {
    prepareClusterLock(cluster.getId());
    try {
        log.debug("Scheduling started, correlation Id: {}", correlationId);
        checkAllowOverbooking(cluster);
        lockCluster(cluster.getId());
        List<VDS> vdsList = getVdsDao().getAllForClusterWithStatus(cluster.getId(), VDSStatus.Up);
        vdsList = removeBlacklistedHosts(vdsList, hostBlackList);
        vdsList = keepOnlyWhitelistedHosts(vdsList, hostWhiteList);
        refreshCachedPendingValues(vdsList);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), cluster, vdsList, vm, parameters, policy.getFilterPositionMap(), messages, runVmDelayer, true, correlationId);
        if (vdsList.isEmpty()) {
            return Optional.empty();
        }
        Optional<Guid> bestHost = selectBestHost(cluster, vm, destHostIdList, vdsList, policy, parameters);
        if (bestHost.isPresent() && !bestHost.get().equals(vm.getRunOnVds())) {
            Guid bestHostId = bestHost.get();
            getPendingResourceManager().addPending(new PendingCpuCores(bestHostId, vm, vm.getNumOfCpus()));
            VDS bestHostEntity = vdsList.stream().filter(vds -> vds.getId().equals(bestHostId)).findFirst().get();
            getPendingResourceManager().addPending(new PendingMemory(bestHostId, vm, bestHostEntity.getGuestOverhead()));
            getPendingResourceManager().addPending(new PendingOvercommitMemory(bestHostId, vm, vm.getMemSizeMb()));
            getPendingResourceManager().addPending(new PendingVM(bestHostId, vm));
            getPendingResourceManager().notifyHostManagers(bestHostId);
            markVfsAsUsedByVm(vm, bestHostId);
        }
        return bestHost;
    } catch (InterruptedException e) {
        log.error("scheduling interrupted, correlation Id: {}: {}", correlationId, e.getMessage());
        log.debug("Exception: ", e);
        return Optional.empty();
    } finally {
        releaseCluster(cluster.getId());
        log.debug("Scheduling ended, correlation Id: {}", correlationId);
    }
}
#end_block

#method_before
public boolean canSchedule(Cluster cluster, VM vm, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, List<String> messages) {
    List<VDS> vdsList = getVdsDao().getAllForClusterWithStatus(cluster.getId(), VDSStatus.Up);
    vdsList = removeBlacklistedHosts(vdsList, vdsBlackList);
    vdsList = keepOnlyWhitelistedHosts(vdsList, vdsWhiteList);
    refreshCachedPendingValues(vdsList);
    ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
    Map<String, String> parameters = createClusterPolicyParameters(cluster);
    vdsList = runFilters(policy.getFilters(), cluster, vdsList, vm, parameters, policy.getFilterPositionMap(), messages, noWaitingMemoryChecker, false, null);
    return vdsList != null && !vdsList.isEmpty();
}
#method_after
public boolean canSchedule(Cluster cluster, VM vm, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, List<String> messages) {
    List<VDS> vdsList = getVdsDao().getAllForClusterWithStatus(cluster.getId(), VDSStatus.Up);
    vdsList = removeBlacklistedHosts(vdsList, vdsBlackList);
    vdsList = keepOnlyWhitelistedHosts(vdsList, vdsWhiteList);
    refreshCachedPendingValues(vdsList);
    ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
    Map<String, String> parameters = createClusterPolicyParameters(cluster);
    vdsList = runFilters(policy.getFilters(), cluster, vdsList, vm, parameters, policy.getFilterPositionMap(), messages, noWaitingVmDelayer, false, null);
    return vdsList != null && !vdsList.isEmpty();
}
#end_block

#method_before
private List<VDS> runFilters(ArrayList<Guid> filters, Cluster cluster, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, List<String> messages, VdsFreeMemoryChecker memoryChecker, boolean shouldRunExternalFilters, String correlationId) {
    SchedulingResult result = new SchedulingResult();
    ArrayList<PolicyUnitImpl> internalFilters = new ArrayList<>();
    ArrayList<PolicyUnitImpl> externalFilters = new ArrayList<>();
    // Create a local copy so we can manipulate it
    filters = new ArrayList<>(filters);
    sortFilters(filters, filterPositionMap);
    for (Guid filter : filters) {
        PolicyUnitImpl filterPolicyUnit = policyUnits.get(filter);
        if (filterPolicyUnit.getPolicyUnit().isInternal()) {
            internalFilters.add(filterPolicyUnit);
        } else {
            if (filterPolicyUnit.getPolicyUnit().isEnabled()) {
                externalFilters.add(filterPolicyUnit);
            }
        }
    }
    /* Short circuit filters if there are no hosts at all */
    if (hostList.isEmpty()) {
        messages.add(EngineMessage.SCHEDULING_NO_HOSTS.name());
        messages.addAll(result.getReasonMessages());
        return hostList;
    }
    hostList = runInternalFilters(internalFilters, cluster, hostList, vm, parameters, filterPositionMap, memoryChecker, correlationId, result);
    if (shouldRunExternalFilters && Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled) && !externalFilters.isEmpty() && !hostList.isEmpty()) {
        hostList = runExternalFilters(externalFilters, hostList, vm, parameters, messages, correlationId, result);
    }
    if (hostList.isEmpty()) {
        messages.add(EngineMessage.SCHEDULING_ALL_HOSTS_FILTERED_OUT.name());
        messages.addAll(result.getReasonMessages());
    }
    return hostList;
}
#method_after
private List<VDS> runFilters(ArrayList<Guid> filters, Cluster cluster, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, List<String> messages, RunVmDelayer runVmDelayer, boolean shouldRunExternalFilters, String correlationId) {
    SchedulingResult result = new SchedulingResult();
    ArrayList<PolicyUnitImpl> internalFilters = new ArrayList<>();
    ArrayList<PolicyUnitImpl> externalFilters = new ArrayList<>();
    // Create a local copy so we can manipulate it
    filters = new ArrayList<>(filters);
    sortFilters(filters, filterPositionMap);
    for (Guid filter : filters) {
        PolicyUnitImpl filterPolicyUnit = policyUnits.get(filter);
        if (filterPolicyUnit.getPolicyUnit().isInternal()) {
            internalFilters.add(filterPolicyUnit);
        } else {
            if (filterPolicyUnit.getPolicyUnit().isEnabled()) {
                externalFilters.add(filterPolicyUnit);
            }
        }
    }
    /* Short circuit filters if there are no hosts at all */
    if (hostList.isEmpty()) {
        messages.add(EngineMessage.SCHEDULING_NO_HOSTS.name());
        messages.addAll(result.getReasonMessages());
        return hostList;
    }
    hostList = runInternalFilters(internalFilters, cluster, hostList, vm, parameters, filterPositionMap, runVmDelayer, correlationId, result);
    if (shouldRunExternalFilters && Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled) && !externalFilters.isEmpty() && !hostList.isEmpty()) {
        hostList = runExternalFilters(externalFilters, hostList, vm, parameters, messages, correlationId, result);
    }
    if (hostList.isEmpty()) {
        messages.add(EngineMessage.SCHEDULING_ALL_HOSTS_FILTERED_OUT.name());
        messages.addAll(result.getReasonMessages());
    }
    return hostList;
}
#end_block

#method_before
private List<VDS> runInternalFilters(ArrayList<PolicyUnitImpl> filters, Cluster cluster, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, VdsFreeMemoryChecker memoryChecker, String correlationId, SchedulingResult result) {
    for (PolicyUnitImpl filterPolicyUnit : filters) {
        if (hostList.isEmpty()) {
            break;
        }
        filterPolicyUnit.setMemoryChecker(memoryChecker);
        List<VDS> currentHostList = new ArrayList<>(hostList);
        hostList = filterPolicyUnit.filter(cluster, hostList, vm, parameters, result.getDetails());
        logFilterActions(currentHostList, toIdSet(hostList), EngineMessage.VAR__FILTERTYPE__INTERNAL, filterPolicyUnit.getPolicyUnit().getName(), result, correlationId);
    }
    return hostList;
}
#method_after
private List<VDS> runInternalFilters(ArrayList<PolicyUnitImpl> filters, Cluster cluster, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, RunVmDelayer runVmDelayer, String correlationId, SchedulingResult result) {
    for (PolicyUnitImpl filterPolicyUnit : filters) {
        if (hostList.isEmpty()) {
            break;
        }
        filterPolicyUnit.setRunVmDelayer(runVmDelayer);
        List<VDS> currentHostList = new ArrayList<>(hostList);
        hostList = filterPolicyUnit.filter(cluster, hostList, vm, parameters, result.getDetails());
        logFilterActions(currentHostList, toIdSet(hostList), EngineMessage.VAR__FILTERTYPE__INTERNAL, filterPolicyUnit.getPolicyUnit().getName(), result, correlationId);
    }
    return hostList;
}
#end_block

#method_before
private void sortFilters(ArrayList<Guid> filters, final Map<Guid, Integer> filterPositionMap) {
    Collections.sort(filters, new Comparator<Guid>() {

        @Override
        public int compare(Guid filter1, Guid filter2) {
            Integer position1 = getPosition(filterPositionMap.get(filter1));
            Integer position2 = getPosition(filterPositionMap.get(filter2));
            return position1 - position2;
        }

        private Integer getPosition(Integer position) {
            if (position == null) {
                position = 0;
            }
            return position;
        }
    });
}
#method_after
private void sortFilters(ArrayList<Guid> filters, final Map<Guid, Integer> filterPositionMap) {
    Collections.sort(filters, Comparator.comparingInt(f -> filterPositionMap.getOrDefault(f, 0)));
}
#end_block

#method_before
@OnTimerMethodAnnotation("performHaResevationCheck")
public void performHaResevationCheck() {
    log.debug("HA Reservation check timer entered.");
    List<Cluster> clusters = getClusterDao().getAll();
    if (clusters != null) {
        HaReservationHandling haReservationHandling = new HaReservationHandling(getPendingResourceManager());
        for (Cluster cluster : clusters) {
            if (cluster.supportsHaReservation()) {
                List<VDS> returnedFailedHosts = new ArrayList<>();
                boolean clusterHaStatus = haReservationHandling.checkHaReservationStatusForCluster(cluster, returnedFailedHosts);
                if (!clusterHaStatus) {
                    // create Alert using returnedFailedHosts
                    AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase());
                    logable.setClusterId(cluster.getId());
                    logable.addCustomValue("ClusterName", cluster.getName());
                    String failedHostsStr = returnedFailedHosts.stream().map(VDS::getName).collect(Collectors.joining(", "));
                    logable.addCustomValue("Hosts", failedHostsStr);
                    AlertDirector.alert(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION, auditLogDirector);
                    log.info("Cluster '{}' fail to pass HA reservation check.", cluster.getName());
                }
                boolean clusterHaStatusFromPreviousCycle = clusterId2isHaReservationSafe.containsKey(cluster.getId()) ? clusterId2isHaReservationSafe.get(cluster.getId()) : true;
                // Update the status map with the new status
                clusterId2isHaReservationSafe.put(cluster.getId(), clusterHaStatus);
                // Create Alert if the status was changed from false to true
                if (!clusterHaStatusFromPreviousCycle && clusterHaStatus) {
                    AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase());
                    logable.setClusterId(cluster.getId());
                    logable.addCustomValue("ClusterName", cluster.getName());
                    AlertDirector.alert(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION_DOWN, auditLogDirector);
                }
            }
        }
    }
    log.debug("HA Reservation check timer finished.");
}
#method_after
@OnTimerMethodAnnotation("performHaResevationCheck")
public void performHaResevationCheck() {
    log.debug("HA Reservation check timer entered.");
    List<Cluster> clusters = getClusterDao().getAll();
    if (clusters != null) {
        HaReservationHandling haReservationHandling = new HaReservationHandling(getPendingResourceManager());
        for (Cluster cluster : clusters) {
            if (cluster.supportsHaReservation()) {
                List<VDS> returnedFailedHosts = new ArrayList<>();
                boolean clusterHaStatus = haReservationHandling.checkHaReservationStatusForCluster(cluster, returnedFailedHosts);
                if (!clusterHaStatus) {
                    // create Alert using returnedFailedHosts
                    AuditLogable logable = createEventForCluster(cluster);
                    String failedHostsStr = returnedFailedHosts.stream().map(VDS::getName).collect(Collectors.joining(", "));
                    logable.addCustomValue("Hosts", failedHostsStr);
                    auditLogDirector.log(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION);
                    log.info("Cluster '{}' fail to pass HA reservation check.", cluster.getName());
                }
                boolean clusterHaStatusFromPreviousCycle = clusterId2isHaReservationSafe.containsKey(cluster.getId()) ? clusterId2isHaReservationSafe.get(cluster.getId()) : true;
                // Update the status map with the new status
                clusterId2isHaReservationSafe.put(cluster.getId(), clusterHaStatus);
                // Create Alert if the status was changed from false to true
                if (!clusterHaStatusFromPreviousCycle && clusterHaStatus) {
                    AuditLogable logable = createEventForCluster(cluster);
                    auditLogDirector.log(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION_DOWN);
                }
            }
        }
    }
    log.debug("HA Reservation check timer finished.");
}
#end_block

#method_before
@Test
public void testDefaultRouteWhenOutOfSync() {
    iface.setIpv4DefaultRoute(false);
    network.setDnsResolverConfiguration(sampleDnsResolverConfiguration);
    assertThat(createTestedInstance(true, sampleDnsResolverConfiguration).isNetworkInSync(), is(true));
}
#method_after
@Test
public void testDefaultRouteWhenOutOfSync() {
    iface.setIpv4DefaultRoute(false);
    network.setDnsResolverConfiguration(sampleDnsResolverConfiguration);
    assertThat(createTestedInstance(true, sampleDnsResolverConfiguration).isNetworkInSync(), is(false));
}
#end_block

#method_before
private void addDnsConfiguration(ReportedConfigurations result) {
    boolean dnsResolverConfigurationSupported = FeatureSupported.supportedInConfig(ConfigValues.DnsResolverConfigurationSupported, this.cluster.getCompatibilityVersion());
    // DNS configuration is reported only on network having default_route role
    if (!isDefaultRouteNetwork || !dnsResolverConfigurationSupported) {
        return;
    }
    List<NameServer> nameServersOfNetworkAttachment = getNameServers(networkAttachment.getDnsResolverConfiguration());
    List<NameServer> nameServersOfNetwork = getNameServers(network.getDnsResolverConfiguration());
    List<NameServer> nameServersOfHost = getNameServers(reportedDnsResolverConfiguration);
    boolean shouldSetDefaultRoute = new ShouldSetDefaultRouteFlagAndDnsData().test(true, networkAttachment);
    boolean engineDefineDnsConfiguration = shouldSetDefaultRoute && (nameServersOfNetworkAttachment != null || nameServersOfNetwork != null);
    List<NameServer> expectedNameServers = nameServersOfNetworkAttachment != null ? nameServersOfNetworkAttachment : nameServersOfNetwork;
    result.add(DNS_CONFIGURATION, addressesAsString(nameServersOfHost), engineDefineDnsConfiguration ? addressesAsString(expectedNameServers) : "", !(engineDefineDnsConfiguration && !Objects.equals(nameServersOfHost, expectedNameServers)));
    result.add(DEFAULT_ROUTE, iface.isIpv4DefaultRoute(), isDefaultRouteNetwork, !(shouldSetDefaultRoute && !Objects.equals(iface.isIpv4DefaultRoute(), isDefaultRouteNetwork)));
}
#method_after
private void addDnsConfiguration(ReportedConfigurations result) {
    boolean dnsResolverConfigurationSupported = FeatureSupported.supportedInConfig(ConfigValues.DnsResolverConfigurationSupported, this.cluster.getCompatibilityVersion());
    // DNS configuration is reported only on network having default_route role
    if (!isDefaultRouteNetwork || !dnsResolverConfigurationSupported) {
        return;
    }
    List<NameServer> nameServersOfNetworkAttachment = getNameServers(networkAttachment.getDnsResolverConfiguration());
    List<NameServer> nameServersOfNetwork = getNameServers(network.getDnsResolverConfiguration());
    List<NameServer> nameServersOfHost = getNameServers(reportedDnsResolverConfiguration);
    boolean engineDefineDnsConfiguration = nameServersOfNetworkAttachment != null || nameServersOfNetwork != null;
    List<NameServer> expectedNameServers = nameServersOfNetworkAttachment != null ? nameServersOfNetworkAttachment : nameServersOfNetwork;
    result.add(DNS_CONFIGURATION, addressesAsString(nameServersOfHost), engineDefineDnsConfiguration ? addressesAsString(expectedNameServers) : "", !(engineDefineDnsConfiguration && !Objects.equals(nameServersOfHost, expectedNameServers)));
    result.add(DEFAULT_ROUTE, iface.isIpv4DefaultRoute(), isDefaultRouteNetwork);
}
#end_block

#method_before
@Override
public void edit(FenceProxyModel object) {
    if (!object.getAvailableProxies().getItems().isEmpty()) {
        pmProxyType.setVisible(true);
        noItemsAvailableLabel.setVisible(false);
        driver.edit(object);
        doFlush = true;
    } else {
        // No available items to select, show message, hide dropdown.
        pmProxyType.setVisible(false);
        noItemsAvailableLabel.setVisible(true);
        doFlush = false;
    }
}
#method_after
@Override
public void edit(FenceProxyModel object) {
    if (!object.getAvailableProxies().getItems().isEmpty()) {
        pmProxyTypeRow.setVisible(true);
        noItemsAvailableLabelRow.setVisible(false);
        driver.edit(object);
        doFlush = true;
    } else {
        // No available items to select, show message, hide dropdown.
        pmProxyTypeRow.setVisible(false);
        noItemsAvailableLabelRow.setVisible(true);
        doFlush = false;
    }
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    getQueryReturnValue().setReturnValue(imageTransferDao.filteredGet(getParameters().getId(), getUserID(), getParameters().isFiltered()));
}
#method_after
@Override
protected void executeQueryCommand() {
    getQueryReturnValue().setReturnValue(imageTransferDao.get(getParameters().getId(), getUserID(), getParameters().isFiltered()));
}
#end_block

#method_before
@Override
public ImageTransfer get(Guid id) {
    return filteredGet(id, null, false);
}
#method_after
@Override
public ImageTransfer get(Guid id, Guid userId, boolean isFiltered) {
    MapSqlParameterSource sqlParams = createIdParameterMapper(id);
    sqlParams.addValue("user_id", userId);
    sqlParams.addValue("is_filtered", isFiltered);
    return getCallsHandler().executeRead("GetImageUploadsByCommandId", createEntityRowMapper(), sqlParams);
}
#end_block

#method_before
@Override
public ImageTransfer get(Guid id) {
    return filteredGet(id, null, false);
}
#method_after
@Override
public ImageTransfer get(Guid id) {
    return get(id, null, false);
}
#end_block

#method_before
@Mapping(from = NetworkAttachment.class, to = org.ovirt.engine.core.common.businessentities.network.NetworkAttachment.class)
public static org.ovirt.engine.core.common.businessentities.network.NetworkAttachment map(NetworkAttachment model, org.ovirt.engine.core.common.businessentities.network.NetworkAttachment template) {
    org.ovirt.engine.core.common.businessentities.network.NetworkAttachment entity = template == null ? new org.ovirt.engine.core.common.businessentities.network.NetworkAttachment() : template;
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetNetwork()) {
        Network networkModel = model.getNetwork();
        if (networkModel.isSetId()) {
            entity.setNetworkId(GuidUtils.asGuid(networkModel.getId()));
        }
        if (networkModel.isSetName()) {
            entity.setNetworkName(networkModel.getName());
        }
    }
    if (model.isSetHostNic()) {
        HostNic hostNic = model.getHostNic();
        if (hostNic.isSetId()) {
            entity.setNicId(GuidUtils.asGuid(hostNic.getId()));
        } else {
            entity.setNicId(null);
        }
        if (hostNic.isSetName()) {
            entity.setNicName(hostNic.getName());
        } else {
            entity.setNicName(null);
        }
    }
    if (model.isSetProperties()) {
        entity.setProperties(CustomPropertiesParser.toMap(model.getProperties()));
    }
    if (model.isSetIpAddressAssignments()) {
        entity.setIpConfiguration(new org.ovirt.engine.core.common.businessentities.network.IpConfiguration());
        IpAddressAssignments ipAddressAssignments = model.getIpAddressAssignments();
        entity.getIpConfiguration().setIPv4Addresses(new ArrayList<>());
        entity.getIpConfiguration().setIpV6Addresses(new ArrayList<>());
        for (IpAddressAssignment ipAddressAssignment : ipAddressAssignments.getIpAddressAssignments()) {
            if (IpVersion.V6 == getIpVersion(ipAddressAssignment)) {
                entity.getIpConfiguration().getIpV6Addresses().add(mapIpv6AddressAssignment(ipAddressAssignment));
            } else {
                entity.getIpConfiguration().getIPv4Addresses().add(mapIpv4AddressAssignment(ipAddressAssignment));
            }
        }
    }
    if (model.isSetDnsResolverConfiguration()) {
        entity.setDnsResolverConfiguration(DnsResolverConfigurationMapper.map(model.getDnsResolverConfiguration(), null));
    }
    if (model.isSetQos()) {
        HostNetworkQos hostNetworkQos = (HostNetworkQos) QosMapper.map(model.getQos(), null);
        entity.setHostNetworkQos(AnonymousHostNetworkQos.fromHostNetworkQos(hostNetworkQos));
    }
    return entity;
}
#method_after
@Mapping(from = NetworkAttachment.class, to = org.ovirt.engine.core.common.businessentities.network.NetworkAttachment.class)
public static org.ovirt.engine.core.common.businessentities.network.NetworkAttachment map(NetworkAttachment model, org.ovirt.engine.core.common.businessentities.network.NetworkAttachment template) {
    org.ovirt.engine.core.common.businessentities.network.NetworkAttachment entity = template == null ? new org.ovirt.engine.core.common.businessentities.network.NetworkAttachment() : template;
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetNetwork()) {
        Network networkModel = model.getNetwork();
        if (networkModel.isSetId()) {
            entity.setNetworkId(GuidUtils.asGuid(networkModel.getId()));
        }
        if (networkModel.isSetName()) {
            entity.setNetworkName(networkModel.getName());
        }
    }
    if (model.isSetHostNic()) {
        HostNic hostNic = model.getHostNic();
        if (hostNic.isSetId()) {
            entity.setNicId(GuidUtils.asGuid(hostNic.getId()));
        } else {
            entity.setNicId(null);
        }
        if (hostNic.isSetName()) {
            entity.setNicName(hostNic.getName());
        } else {
            entity.setNicName(null);
        }
    }
    if (model.isSetProperties()) {
        entity.setProperties(CustomPropertiesParser.toMap(model.getProperties()));
    }
    if (model.isSetIpAddressAssignments()) {
        entity.setIpConfiguration(new org.ovirt.engine.core.common.businessentities.network.IpConfiguration());
        IpAddressAssignments ipAddressAssignments = model.getIpAddressAssignments();
        entity.getIpConfiguration().setIPv4Addresses(new ArrayList<>());
        entity.getIpConfiguration().setIpV6Addresses(new ArrayList<>());
        for (IpAddressAssignment ipAddressAssignment : ipAddressAssignments.getIpAddressAssignments()) {
            if (IpVersion.V6 == getIpVersion(ipAddressAssignment)) {
                entity.getIpConfiguration().getIpV6Addresses().add(mapIpv6AddressAssignment(ipAddressAssignment));
            } else {
                entity.getIpConfiguration().getIPv4Addresses().add(mapIpv4AddressAssignment(ipAddressAssignment));
            }
        }
    }
    if (model.isSetDnsResolverConfiguration()) {
        entity.setDnsResolverConfiguration(DnsResolverConfigurationMapper.map(model.getDnsResolverConfiguration()));
    }
    if (model.isSetQos()) {
        HostNetworkQos hostNetworkQos = (HostNetworkQos) QosMapper.map(model.getQos(), null);
        entity.setHostNetworkQos(AnonymousHostNetworkQos.fromHostNetworkQos(hostNetworkQos));
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.network.NetworkAttachment.class, to = NetworkAttachment.class)
public static NetworkAttachment map(org.ovirt.engine.core.common.businessentities.network.NetworkAttachment entity, NetworkAttachment template) {
    NetworkAttachment model = template == null ? new NetworkAttachment() : template;
    if (entity.getId() != null) {
        model.setId(entity.getId().toString());
    }
    if (entity.getNetworkId() != null) {
        getModelNetwork(model).setId(entity.getNetworkId().toString());
    }
    if (entity.getNicId() != null) {
        getModelHostNic(model).setId(entity.getNicId().toString());
    }
    if (entity.hasProperties()) {
        model.setProperties(CustomPropertiesParser.fromMap(entity.getProperties()));
    }
    org.ovirt.engine.core.common.businessentities.network.IpConfiguration entityIpConfiguration = entity.getIpConfiguration();
    if (entityIpConfiguration != null) {
        model.setIpAddressAssignments(new IpAddressAssignments());
        if (!entityIpConfiguration.getIPv4Addresses().isEmpty()) {
            entityIpConfiguration.getIPv4Addresses().stream().map(NetworkAttachmentMapper::mapIpv4Address).forEach(model.getIpAddressAssignments().getIpAddressAssignments()::add);
        }
        if (!entityIpConfiguration.getIpV6Addresses().isEmpty()) {
            entityIpConfiguration.getIpV6Addresses().stream().map(NetworkAttachmentMapper::mapIpv6AddressAssignment).forEach(model.getIpAddressAssignments().getIpAddressAssignments()::add);
        }
    }
    if (entity.getDnsResolverConfiguration() != null) {
        model.setDnsResolverConfiguration(DnsResolverConfigurationMapper.map(entity.getDnsResolverConfiguration(), null));
    }
    if (entity.getReportedConfigurations() != null) {
        model.setInSync(entity.getReportedConfigurations().isNetworkInSync());
        model.setReportedConfigurations(ReportedConfigurationsMapper.map(entity.getReportedConfigurations(), null));
    }
    AnonymousHostNetworkQos hostNetworkQos = entity.getHostNetworkQos();
    if (hostNetworkQos != null) {
        model.setQos(QosMapper.map(HostNetworkQos.fromAnonymousHostNetworkQos(hostNetworkQos), null));
    }
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.network.NetworkAttachment.class, to = NetworkAttachment.class)
public static NetworkAttachment map(org.ovirt.engine.core.common.businessentities.network.NetworkAttachment entity, NetworkAttachment template) {
    NetworkAttachment model = template == null ? new NetworkAttachment() : template;
    if (entity.getId() != null) {
        model.setId(entity.getId().toString());
    }
    if (entity.getNetworkId() != null) {
        getModelNetwork(model).setId(entity.getNetworkId().toString());
    }
    if (entity.getNicId() != null) {
        getModelHostNic(model).setId(entity.getNicId().toString());
    }
    if (entity.hasProperties()) {
        model.setProperties(CustomPropertiesParser.fromMap(entity.getProperties()));
    }
    org.ovirt.engine.core.common.businessentities.network.IpConfiguration entityIpConfiguration = entity.getIpConfiguration();
    if (entityIpConfiguration != null) {
        model.setIpAddressAssignments(new IpAddressAssignments());
        if (!entityIpConfiguration.getIPv4Addresses().isEmpty()) {
            entityIpConfiguration.getIPv4Addresses().stream().map(NetworkAttachmentMapper::mapIpv4Address).forEach(model.getIpAddressAssignments().getIpAddressAssignments()::add);
        }
        if (!entityIpConfiguration.getIpV6Addresses().isEmpty()) {
            entityIpConfiguration.getIpV6Addresses().stream().map(NetworkAttachmentMapper::mapIpv6AddressAssignment).forEach(model.getIpAddressAssignments().getIpAddressAssignments()::add);
        }
    }
    if (entity.getDnsResolverConfiguration() != null) {
        model.setDnsResolverConfiguration(DnsResolverConfigurationMapper.map(entity.getDnsResolverConfiguration()));
    }
    if (entity.getReportedConfigurations() != null) {
        model.setInSync(entity.getReportedConfigurations().isNetworkInSync());
        model.setReportedConfigurations(ReportedConfigurationsMapper.map(entity.getReportedConfigurations(), null));
    }
    AnonymousHostNetworkQos hostNetworkQos = entity.getHostNetworkQos();
    if (hostNetworkQos != null) {
        model.setQos(QosMapper.map(HostNetworkQos.fromAnonymousHostNetworkQos(hostNetworkQos), null));
    }
    return model;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.network.DnsResolverConfiguration.class, to = DnsResolverConfiguration.class)
public static DnsResolverConfiguration map(org.ovirt.engine.core.common.businessentities.network.DnsResolverConfiguration entity, DnsResolverConfiguration template) {
    if (entity == null) {
        return null;
    }
    List<NameServer> nameServers = entity.getNameServers();
    if (nameServers == null) {
        return null;
    }
    List<String> nameServerList = nameServers.stream().map(NameServer::getAddress).collect(toList());
    DnsResolverConfiguration.NameServersList nameServersList = new DnsResolverConfiguration.NameServersList();
    nameServersList.getNameServers().addAll(nameServerList);
    DnsResolverConfiguration dnsResolverConfiguration = new DnsResolverConfiguration();
    dnsResolverConfiguration.setNameServers(nameServersList);
    return dnsResolverConfiguration;
}
#method_after
public static org.ovirt.engine.core.common.businessentities.network.DnsResolverConfiguration map(DnsResolverConfiguration model) {
    org.ovirt.engine.core.common.businessentities.network.DnsResolverConfiguration result = new org.ovirt.engine.core.common.businessentities.network.DnsResolverConfiguration();
    if (model.isSetNameServers()) {
        DnsResolverConfiguration.NameServersList nameServersList = model.getNameServers();
        if (nameServersList.isSetNameServers()) {
            List<String> nameServers = nameServersList.getNameServers();
            result.setNameServers(mapNameServers(nameServers));
            return result;
        }
    }
    result.setNameServers(Collections.emptyList());
    return result;
}
#end_block

#method_before
@Mapping(from = Network.class, to = org.ovirt.engine.core.common.businessentities.network.Network.class)
public static org.ovirt.engine.core.common.businessentities.network.Network map(Network model, org.ovirt.engine.core.common.businessentities.network.Network template) {
    org.ovirt.engine.core.common.businessentities.network.Network entity = template != null ? template : new org.ovirt.engine.core.common.businessentities.network.Network();
    entity.setCluster(template != null && template.getCluster() != null ? template.getCluster() : new NetworkCluster());
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetDataCenter() && model.getDataCenter().isSetId()) {
        entity.setDataCenterId(GuidUtils.asGuid(model.getDataCenter().getId()));
    }
    if (model.isSetIp()) {
        if (model.getIp().isSetAddress()) {
            entity.setAddr(model.getIp().getAddress());
        }
        if (model.getIp().isSetNetmask()) {
            entity.setSubnet(model.getIp().getNetmask());
        }
        if (model.getIp().isSetGateway()) {
            entity.setGateway(model.getIp().getGateway());
        }
    }
    if (model.isSetVlan()) {
        entity.setVlanId(model.getVlan().getId());
    }
    if (model.isSetStp()) {
        entity.setStp(model.isStp());
    }
    if (model.isSetDisplay()) {
        // for backward compatibility use display tag or usage tag
        entity.getCluster().setDisplay(model.isDisplay());
    }
    if (model.isSetUsages()) {
        List<NetworkUsage> networkUsages = new ArrayList<>();
        for (NetworkUsage usage : model.getUsages().getUsages()) {
            networkUsages.add(usage);
        }
        entity.getCluster().setDisplay(networkUsages.contains(NetworkUsage.DISPLAY));
        entity.getCluster().setMigration(networkUsages.contains(NetworkUsage.MIGRATION));
        entity.getCluster().setManagement(networkUsages.contains(NetworkUsage.MANAGEMENT));
        entity.getCluster().setGluster(networkUsages.contains(NetworkUsage.GLUSTER));
        entity.setVmNetwork(networkUsages.contains(NetworkUsage.VM));
    }
    if (model.isSetMtu()) {
        entity.setMtu(model.getMtu());
    }
    if (model.isSetRequired()) {
        entity.getCluster().setRequired(model.isRequired());
    }
    if (model.isSetQos()) {
        entity.setQosId(Guid.createGuidFromString(model.getQos().getId()));
    }
    if (model.isSetDnsResolverConfiguration()) {
        entity.setDnsResolverConfiguration(DnsResolverConfigurationMapper.map(model.getDnsResolverConfiguration(), null));
    }
    return entity;
}
#method_after
@Mapping(from = Network.class, to = org.ovirt.engine.core.common.businessentities.network.Network.class)
public static org.ovirt.engine.core.common.businessentities.network.Network map(Network model, org.ovirt.engine.core.common.businessentities.network.Network template) {
    org.ovirt.engine.core.common.businessentities.network.Network entity = template != null ? template : new org.ovirt.engine.core.common.businessentities.network.Network();
    entity.setCluster(template != null && template.getCluster() != null ? template.getCluster() : new NetworkCluster());
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetDataCenter() && model.getDataCenter().isSetId()) {
        entity.setDataCenterId(GuidUtils.asGuid(model.getDataCenter().getId()));
    }
    if (model.isSetIp()) {
        if (model.getIp().isSetAddress()) {
            entity.setAddr(model.getIp().getAddress());
        }
        if (model.getIp().isSetNetmask()) {
            entity.setSubnet(model.getIp().getNetmask());
        }
        if (model.getIp().isSetGateway()) {
            entity.setGateway(model.getIp().getGateway());
        }
    }
    if (model.isSetVlan()) {
        entity.setVlanId(model.getVlan().getId());
    }
    if (model.isSetStp()) {
        entity.setStp(model.isStp());
    }
    if (model.isSetDisplay()) {
        // for backward compatibility use display tag or usage tag
        entity.getCluster().setDisplay(model.isDisplay());
    }
    if (model.isSetUsages()) {
        List<NetworkUsage> networkUsages = new ArrayList<>();
        for (NetworkUsage usage : model.getUsages().getUsages()) {
            networkUsages.add(usage);
        }
        entity.getCluster().setDisplay(networkUsages.contains(NetworkUsage.DISPLAY));
        entity.getCluster().setMigration(networkUsages.contains(NetworkUsage.MIGRATION));
        entity.getCluster().setManagement(networkUsages.contains(NetworkUsage.MANAGEMENT));
        entity.getCluster().setGluster(networkUsages.contains(NetworkUsage.GLUSTER));
        entity.getCluster().setDefaultRoute(networkUsages.contains(NetworkUsage.DEFAULT_ROUTE));
        entity.setVmNetwork(networkUsages.contains(NetworkUsage.VM));
    }
    if (model.isSetMtu()) {
        entity.setMtu(model.getMtu());
    }
    if (model.isSetRequired()) {
        entity.getCluster().setRequired(model.isRequired());
    }
    if (model.isSetQos()) {
        entity.setQosId(Guid.createGuidFromString(model.getQos().getId()));
    }
    if (model.isSetDnsResolverConfiguration()) {
        entity.setDnsResolverConfiguration(DnsResolverConfigurationMapper.map(model.getDnsResolverConfiguration()));
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.network.Network.class, to = Network.class)
public static Network map(org.ovirt.engine.core.common.businessentities.network.Network entity, Network template) {
    Network model = template != null ? template : new Network();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getDescription());
    model.setComment(entity.getComment());
    if (entity.getDataCenterId() != null) {
        DataCenter dataCenter = new DataCenter();
        dataCenter.setId(entity.getDataCenterId().toString());
        model.setDataCenter(dataCenter);
    }
    if (entity.getAddr() != null || entity.getSubnet() != null || entity.getGateway() != null) {
        model.setIp(new Ip());
        model.getIp().setAddress(entity.getAddr());
        model.getIp().setNetmask(entity.getSubnet());
        model.getIp().setGateway(entity.getGateway());
    }
    if (entity.getVlanId() != null) {
        model.setVlan(new Vlan());
        model.getVlan().setId(entity.getVlanId());
    }
    model.setStp(entity.getStp());
    model.setMtu(entity.getMtu());
    model.setUsages(new Network.UsagesList());
    if (entity.isVmNetwork()) {
        model.getUsages().getUsages().add(NetworkUsage.VM);
    }
    if (entity.getCluster() != null) {
        if (entity.getCluster().isDisplay()) {
            model.getUsages().getUsages().add(NetworkUsage.DISPLAY);
        }
        if (entity.getCluster().isMigration()) {
            model.getUsages().getUsages().add(NetworkUsage.MIGRATION);
        }
        if (entity.getCluster().isManagement()) {
            model.getUsages().getUsages().add(NetworkUsage.MANAGEMENT);
        }
        if (entity.getCluster().isGluster()) {
            model.getUsages().getUsages().add(NetworkUsage.GLUSTER);
        }
        if (entity.getCluster().getStatus() != null) {
            model.setStatus(mapNetworkStatus(entity.getCluster().getStatus()));
        }
        model.setDisplay(entity.getCluster().isDisplay());
        model.setRequired(entity.getCluster().isRequired());
    }
    Guid entityQosId = entity.getQosId();
    if (entityQosId != null) {
        Qos qos = new Qos();
        qos.setId(entityQosId.toString());
        model.setQos(qos);
    }
    if (entity.getDnsResolverConfiguration() != null) {
        model.setDnsResolverConfiguration(DnsResolverConfigurationMapper.map(entity.getDnsResolverConfiguration(), null));
    }
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.network.Network.class, to = Network.class)
public static Network map(org.ovirt.engine.core.common.businessentities.network.Network entity, Network template) {
    Network model = template != null ? template : new Network();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getDescription());
    model.setComment(entity.getComment());
    if (entity.getDataCenterId() != null) {
        DataCenter dataCenter = new DataCenter();
        dataCenter.setId(entity.getDataCenterId().toString());
        model.setDataCenter(dataCenter);
    }
    if (entity.getAddr() != null || entity.getSubnet() != null || entity.getGateway() != null) {
        model.setIp(new Ip());
        model.getIp().setAddress(entity.getAddr());
        model.getIp().setNetmask(entity.getSubnet());
        model.getIp().setGateway(entity.getGateway());
    }
    if (entity.getVlanId() != null) {
        model.setVlan(new Vlan());
        model.getVlan().setId(entity.getVlanId());
    }
    model.setStp(entity.getStp());
    model.setMtu(entity.getMtu());
    model.setUsages(new Network.UsagesList());
    if (entity.isVmNetwork()) {
        model.getUsages().getUsages().add(NetworkUsage.VM);
    }
    if (entity.getCluster() != null) {
        if (entity.getCluster().isDisplay()) {
            model.getUsages().getUsages().add(NetworkUsage.DISPLAY);
        }
        if (entity.getCluster().isMigration()) {
            model.getUsages().getUsages().add(NetworkUsage.MIGRATION);
        }
        if (entity.getCluster().isManagement()) {
            model.getUsages().getUsages().add(NetworkUsage.MANAGEMENT);
        }
        if (entity.getCluster().isDefaultRoute()) {
            model.getUsages().getUsages().add(NetworkUsage.DEFAULT_ROUTE);
        }
        if (entity.getCluster().isGluster()) {
            model.getUsages().getUsages().add(NetworkUsage.GLUSTER);
        }
        if (entity.getCluster().getStatus() != null) {
            model.setStatus(mapNetworkStatus(entity.getCluster().getStatus()));
        }
        model.setDisplay(entity.getCluster().isDisplay());
        model.setRequired(entity.getCluster().isRequired());
    }
    Guid entityQosId = entity.getQosId();
    if (entityQosId != null) {
        Qos qos = new Qos();
        qos.setId(entityQosId.toString());
        model.setQos(qos);
    }
    if (entity.getDnsResolverConfiguration() != null) {
        model.setDnsResolverConfiguration(DnsResolverConfigurationMapper.map(entity.getDnsResolverConfiguration()));
    }
    return model;
}
#end_block

#method_before
@Override
public final String buildFreeTextConditionSql(String tableName, String relations, String value, boolean caseSensitive) {
    StringBuilder sb = new StringBuilder(" ( ");
    String val;
    if (!StringHelper.isNullOrEmpty(value) && !"''".equals(value)) {
        val = StringFormat.format(getI18NPrefix() + "'%%%1$s%%'", StringHelper.trim(value, '\''));
    } else {
        val = value;
    }
    String rel;
    switch(relations) {
        case "d":
            rel = getLikeSyntax(caseSensitive);
            break;
        case "!=":
            rel = "NOT " + getLikeSyntax(caseSensitive);
            break;
        default:
            rel = relations;
    }
    sb.append(columnNameDict.entrySet().stream().sorted(Map.Entry.comparingByValue()).filter(e -> typeDict.get(e.getKey()) == String.class && !notFreeTextSearchableFieldsList.contains(e.getKey())).map(e -> StringFormat.format(" %1$s.%2$s %3$s %4$s", tableName, e.getValue(), rel, val)).distinct().collect(Collectors.joining(" OR ")));
    sb.append(" ) ");
    return sb.toString();
}
#method_after
@Override
public final String buildFreeTextConditionSql(String tableName, String relations, String value, boolean caseSensitive) {
    String val;
    if (!StringHelper.isNullOrEmpty(value) && !"''".equals(value)) {
        val = StringFormat.format(getI18NPrefix() + "'%%%1$s%%'", StringHelper.trim(value, '\''));
    } else {
        val = value;
    }
    String rel;
    switch(relations) {
        case "d":
            rel = getLikeSyntax(caseSensitive);
            break;
        case "!=":
            rel = "NOT " + getLikeSyntax(caseSensitive);
            break;
        default:
            rel = relations;
    }
    return columnNameDict.entrySet().stream().sorted(Map.Entry.comparingByValue()).filter(e -> typeDict.get(e.getKey()) == String.class && !notFreeTextSearchableFieldsList.contains(e.getKey())).map(e -> StringFormat.format(" %1$s.%2$s %3$s %4$s", tableName, e.getValue(), rel, val)).distinct().collect(Collectors.joining(" OR ", " ( ", " ) "));
}
#end_block

#method_before
void logRenamedEntity() {
    if (this instanceof RenamedEntityInfoProvider) {
        RenamedEntityInfoProvider renameable = (RenamedEntityInfoProvider) this;
        String oldEntityName = renameable.getEntityOldName();
        String newEntityName = renameable.getEntityNewName();
        if (!StringUtils.equals(oldEntityName, newEntityName)) {
            // log entity rename details
            AuditLogableBase logable = new AuditLogableBase();
            String entityType = renameable.getEntityType();
            logable.addCustomValue("EntityType", entityType);
            logable.addCustomValue("OldEntityName", oldEntityName);
            logable.addCustomValue("NewEntityName", newEntityName);
            logable.addCustomValue("UserName", getCurrentUser().getLoginName());
            renameable.setEntityId(logable);
            auditLog(logable, AuditLogType.ENTITY_RENAMED);
        }
    }
}
#method_after
void logRenamedEntity() {
    if (this instanceof RenamedEntityInfoProvider) {
        RenamedEntityInfoProvider renameable = (RenamedEntityInfoProvider) this;
        String oldEntityName = renameable.getEntityOldName();
        String newEntityName = renameable.getEntityNewName();
        if (!StringUtils.equals(oldEntityName, newEntityName)) {
            // log entity rename details
            AuditLogable logable = new AuditLogableImpl();
            String entityType = renameable.getEntityType();
            logable.addCustomValue("EntityType", entityType);
            logable.addCustomValue("OldEntityName", oldEntityName);
            logable.addCustomValue("NewEntityName", newEntityName);
            logable.addCustomValue("UserName", getCurrentUser().getLoginName());
            renameable.setEntityId(logable);
            auditLog(logable, AuditLogType.ENTITY_RENAMED);
        }
    }
}
#end_block

#method_before
protected ArrayList<VdcReturnValueBase> runInternalMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, ExecutionContext executionContext) {
    return getBackend().runInternalMultipleActions(actionType, parameters, context.clone().withExecutionContext(executionContext));
}
#method_after
protected List<VdcReturnValueBase> runInternalMultipleActions(VdcActionType actionType, List<VdcActionParametersBase> parameters) {
    return getBackend().runInternalMultipleActions(actionType, parameters, context.clone());
}
#end_block

#method_before
public boolean checkDomainMetadataDevices(StorageDomain domain) {
    if (domain.getVgMetadataDevice() == null || domain.getFirstMetadataDevice() == null) {
        AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase());
        logable.setStorageDomain(domain);
        auditLogDirector.log(logable, AuditLogType.FAILED_DETERMINE_STORAGE_DOMAIN_METADATA_DEVICES);
        return false;
    }
    return true;
}
#method_after
public boolean checkDomainMetadataDevices(StorageDomain domain) {
    if (domain.getVgMetadataDevice() == null || domain.getFirstMetadataDevice() == null) {
        AuditLogable logable = new AuditLogableImpl();
        logable.setStorageDomainName(domain.getName());
        logable.setStorageDomainId(domain.getId());
        auditLogDirector.log(logable, AuditLogType.FAILED_DETERMINE_STORAGE_DOMAIN_METADATA_DEVICES);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final List<LUNs> lunsFromVgInfo = getLunsFromVgInfo();
    final List<LUNs> lunsFromDb = lunDao.getAllForVolumeGroup(getStorageDomain().getStorage());
    Map<Consumer<List<LUNs>>, List<LUNs>> lunsToUpdateInDb = getLunsToUpdateInDb(lunsFromVgInfo, lunsFromDb);
    boolean dbShouldBeUpdated = // There are existing luns that should be updated.
    lunsToUpdateInDb.containsKey(updateExistingLuns) || // There are new luns that should be saved.
    lunsToUpdateInDb.containsKey(saveNewLuns);
    if (dbShouldBeUpdated) {
        TransactionSupport.executeInNewTransaction(() -> {
            updateLunsInDb(lunsToUpdateInDb);
            refreshLunsConnections(lunsFromVgInfo);
            cleanupLunsFromDb(lunsFromVgInfo, lunsFromDb);
            return null;
        });
    }
    // When a domain is created it has a vg metadata device and a metadata lv which may be created on multiple
    // devices. On a regular basis, those devices should be never changing.
    // However, in some user environments in case of disaster the block sd may be restored manually in a way that
    // will change its metadata devices - therefore when syncing the luns info we refresh the metadata devices
    // information as well.
    refreshMetadataDevicesInfo();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    final List<LUNs> lunsFromVgInfo = getLunsFromVgInfo();
    final List<LUNs> lunsFromDb = lunDao.getAllForVolumeGroup(getStorageDomain().getStorage());
    Map<LunHandler, List<LUNs>> lunsToUpdateInDb = getLunsToUpdateInDb(lunsFromVgInfo, lunsFromDb);
    boolean dbShouldBeUpdated = lunsToUpdateInDb.keySet().stream().anyMatch(LunHandler::requiresDbUpdate);
    if (dbShouldBeUpdated) {
        TransactionSupport.executeInNewTransaction(() -> {
            updateLunsInDb(lunsToUpdateInDb);
            refreshLunsConnections(lunsFromVgInfo);
            return null;
        });
    }
    // When a domain is created it has a vg metadata device and a metadata lv which may be created on multiple
    // devices. On a regular basis, those devices should be never changing.
    // However, in some user environments in case of disaster the block sd may be restored manually in a way that
    // will change its metadata devices - therefore when syncing the luns info we refresh the metadata devices
    // information as well.
    refreshMetadataDevicesInfo();
    setSucceeded(true);
}
#end_block

#method_before
protected Map<Consumer<List<LUNs>>, List<LUNs>> getLunsToUpdateInDb(List<LUNs> lunsFromVgInfo, List<LUNs> lunsFromDb) {
    Map<String, LUNs> lunsFromDbMap = lunsFromDb.stream().collect(Collectors.toMap(LUNs::getLUNId, Function.identity()));
    return lunsFromVgInfo.stream().collect(Collectors.groupingBy(lunFromVgInfo -> {
        LUNs lunFromDb = lunsFromDbMap.get(lunFromVgInfo.getLUNId());
        if (lunFromDb == null) {
            // 2. lunFromDb has the same pv id and a different lun id -> using storage from backup.
            return saveNewLuns;
        }
        boolean lunFromDbHasSamePvId = Objects.equals(lunFromDb.getPhysicalVolumeId(), lunFromVgInfo.getPhysicalVolumeId());
        if (lunFromDbHasSamePvId) {
            // Existing lun, check if it should be updated.
            if (lunFromDb.getDeviceSize() != lunFromVgInfo.getDeviceSize() || !Objects.equals(lunFromDb.getDiscardMaxSize(), lunFromVgInfo.getDiscardMaxSize()) || !Objects.equals(lunFromDb.getDiscardZeroesData(), lunFromVgInfo.getDiscardZeroesData())) {
                return updateExistingLuns;
            }
            // Existing lun is up to date.
            return noOp;
        }
        // lunFromDb has the same lun id and a different pv id -> old pv id.
        return updateExistingLuns;
    }));
}
#method_after
protected Map<LunHandler, List<LUNs>> getLunsToUpdateInDb(List<LUNs> lunsFromVgInfo, List<LUNs> lunsFromDb) {
    Map<String, LUNs> lunsFromDbMap = lunsFromDb.stream().collect(Collectors.toMap(LUNs::getLUNId, Function.identity()));
    Map<LunHandler, List<LUNs>> lunsToUpdateInDb = lunsFromVgInfo.stream().collect(Collectors.groupingBy(lunFromVgInfo -> {
        LUNs lunFromDb = lunsFromDbMap.get(lunFromVgInfo.getLUNId());
        if (lunFromDb == null) {
            // 2. lunFromDb has the same pv id and a different lun id -> using storage from backup.
            return saveLunsHandler;
        }
        boolean lunFromDbHasSamePvId = Objects.equals(lunFromDb.getPhysicalVolumeId(), lunFromVgInfo.getPhysicalVolumeId());
        if (lunFromDbHasSamePvId) {
            // Existing lun, check if it should be updated.
            if (lunFromDb.getDeviceSize() != lunFromVgInfo.getDeviceSize() || !Objects.equals(lunFromDb.getDiscardMaxSize(), lunFromVgInfo.getDiscardMaxSize()) || !Objects.equals(lunFromDb.getDiscardZeroesData(), lunFromVgInfo.getDiscardZeroesData())) {
                return updateLunsHandler;
            }
            // Existing lun is up to date.
            return noOp;
        }
        // lunFromDb has the same lun id and a different pv id -> old pv id.
        return updateLunsHandler;
    }));
    lunsToUpdateInDb.put(removeLunsHandler, getLunsToRemoveFromDb(lunsFromVgInfo, lunsFromDb));
    return lunsToUpdateInDb;
}
#end_block

#method_before
protected void updateLunsInDb(Map<Consumer<List<LUNs>>, List<LUNs>> lunsToUpdateInDbMap) {
    lunsToUpdateInDbMap.entrySet().forEach(entry -> entry.getKey().accept(entry.getValue()));
    if (lunsToUpdateInDbMap.containsKey(saveNewLuns) || lunsToUpdateInDbMap.containsKey(updateExistingLuns)) {
        Collection<LUNs> lunsToUpdateInDb = lunsToUpdateInDbMap.entrySet().stream().filter(entry -> entry.getKey().equals(saveNewLuns) || entry.getKey().equals(updateExistingLuns)).map(Map.Entry::getValue).flatMap(List::stream).collect(Collectors.toList());
        discardHelper.logIfLunsBreakStorageDomainDiscardFunctionality(lunsToUpdateInDb, getStorageDomainId());
    }
}
#method_after
private void updateLunsInDb(Map<LunHandler, List<LUNs>> lunsToUpdateInDbMap) {
    lunsToUpdateInDbMap.entrySet().forEach(entry -> entry.getKey().accept(entry.getValue()));
    if (lunsToUpdateInDbMap.keySet().stream().anyMatch(LunHandler::affectsDiscardFunctionality)) {
        Collection<LUNs> lunsToUpdateInDb = lunsToUpdateInDbMap.entrySet().stream().filter(entry -> entry.getKey().affectsDiscardFunctionality()).map(Map.Entry::getValue).flatMap(List::stream).collect(Collectors.toList());
        discardHelper.logIfLunsBreakStorageDomainDiscardFunctionality(lunsToUpdateInDb, getStorageDomainId());
    }
}
#end_block

#method_before
public void edit(ListModel<FenceProxyModel> currentProxies) {
    if (getWindow() != null) {
        return;
    }
    FenceProxyModel newModel = new FenceProxyModel();
    newModel.setCurrentProxies(currentProxies);
    setWindow(newModel);
    newModel.setTitle(constants.selectFenceProxy());
    if (!newModel.getAvailableProxies().getItems().isEmpty()) {
        newModel.getCommands().add(UICommand.createDefaultOkUiCommand(OK, this));
    }
    newModel.getCommands().add(UICommand.createDefaultCancelUiCommand(CANCEL, this));
}
#method_after
public void edit(ListModel<FenceProxyModel> currentProxies) {
    if (getWindow() != null) {
        return;
    }
    FenceProxyModel newModel = new FenceProxyModel();
    newModel.setCurrentProxies(deepCopy(currentProxies));
    setWindow(newModel);
    newModel.setTitle(constants.selectFenceProxy());
    if (!newModel.getAvailableProxies().getItems().isEmpty()) {
        newModel.getCommands().add(UICommand.createDefaultOkUiCommand(OK, this));
    }
    newModel.getCommands().add(UICommand.createDefaultCancelUiCommand(CANCEL, this));
}
#end_block

#method_before
private void setCurrentProxies(ListModel<FenceProxyModel> currentProxies) {
    this.currentProxies = currentProxies;
    // Determine the already selected proxy types.
    List<FenceProxySourceType> currentSourceTypes = new ArrayList<>();
    for (FenceProxyModel currentProxyModel : currentProxies.getItems()) {
        if (currentProxyModel.getEntity() != null) {
            currentSourceTypes.add(currentProxyModel.getEntity());
        }
    }
    availableProxies.setItems(null);
    // Determine the available proxy types.
    List<FenceProxyModel> availableProxiesList = new ArrayList<>();
    for (FenceProxySourceType type : FenceProxySourceType.values()) {
        if (!currentSourceTypes.contains(type)) {
            FenceProxyModel newModel = new FenceProxyModel();
            newModel.setEntity(type);
            availableProxiesList.add(newModel);
        }
    }
    this.availableProxies.setItems(availableProxiesList);
}
#method_after
private void setCurrentProxies(ListModel<FenceProxyModel> currentProxies) {
    this.currentProxies = currentProxies;
    // Determine the already selected proxy types.
    List<FenceProxySourceType> currentSourceTypes = new ArrayList<>();
    for (FenceProxyModel currentProxyModel : currentProxies.getItems()) {
        if (currentProxyModel.getEntity() != null) {
            currentSourceTypes.add(currentProxyModel.getEntity());
        }
    }
    this.availableProxies.setItems(null);
    // Determine the available proxy types.
    List<FenceProxyModel> availableProxiesList = new ArrayList<>();
    for (FenceProxySourceType type : FenceProxySourceType.values()) {
        if (!currentSourceTypes.contains(type)) {
            FenceProxyModel newModel = new FenceProxyModel();
            newModel.setEntity(type);
            availableProxiesList.add(newModel);
        }
    }
    this.availableProxies.setItems(availableProxiesList);
}
#end_block

#method_before
private void onOk() {
    FenceProxyModel windowModel = (FenceProxyModel) getWindow();
    setWindow(null);
    ListModel<FenceProxyModel> currentModels = windowModel.getCurrentProxies();
    FenceProxyModel selectedModel = windowModel.getAvailableProxies().getSelectedItem();
    setEntity(selectedModel.getEntity());
    Collection<FenceProxyModel> items = currentModels.getItems();
    currentModels.setItems(null);
    currentModels.setItems(items);
}
#method_after
private void onOk() {
    FenceProxyModel windowModel = (FenceProxyModel) getWindow();
    ListModel<FenceProxyModel> currentModels = windowModel.getCurrentProxies();
    FenceProxyModel selectedModel = windowModel.getAvailableProxies().getSelectedItem();
    setEntity(selectedModel.getEntity());
    Collection<FenceProxyModel> items = currentModels.getItems();
    currentModels.setItems(null);
    currentModels.setItems(items);
    setWindow(null);
}
#end_block

#method_before
private void cancel() {
    FenceProxyModel windowModel = (FenceProxyModel) getWindow();
    setWindow(null);
    ListModel<FenceProxyModel> currentModels = windowModel.getCurrentProxies();
    Collection<FenceProxyModel> items = currentModels.getItems();
    items.remove(this);
    // Set to null to force events to fire.
    currentModels.setItems(null);
    currentModels.setItems(items);
}
#method_after
private void cancel() {
    FenceProxyModel windowModel = (FenceProxyModel) getWindow();
    ListModel<FenceProxyModel> currentModels = windowModel.getCurrentProxies();
    // Set to null to force events to fire.
    Collection<FenceProxyModel> items = currentModels.getItems();
    currentModels.setItems(null);
    items.remove(this);
    currentModels.setItems(items);
    setWindow(null);
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    HostStatusColumn<VDS> statusIconColumn = new HostStatusColumn<>();
    statusIconColumn.setContextMenuTitle(constants.statusIconHost());
    // $NON-NLS-1$
    getTable().addColumn(statusIconColumn, constants.empty(), "30px");
    HostAdditionalStatusColumn additionalStatusColumn = new HostAdditionalStatusColumn();
    additionalStatusColumn.setContextMenuTitle(constants.additionalStatusHost());
    // $NON-NLS-1$
    getTable().addColumn(additionalStatusColumn, constants.empty(), "60px");
    AbstractTextColumn<VDS> nameColumn = new AbstractTextColumn<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(VdsConditionFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameHost(), "150px");
    CommentColumn<VDS> commentColumn = new CommentColumn<>();
    getTable().addColumnWithHtmlHeader(commentColumn, SafeHtmlUtils.fromSafeConstant(constants.commentLabel()), // $NON-NLS-1$
    "75px");
    AbstractTextColumn<VDS> hostColumn = new AbstractTextColumn<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getHostName();
        }
    };
    hostColumn.makeSortable(VdsConditionFieldAutoCompleter.ADDRESS);
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.ipHost(), "150px");
    AbstractTextColumn<VDS> clusterColumn = new AbstractTextColumn<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getClusterName();
        }
    };
    clusterColumn.makeSortable(VdsConditionFieldAutoCompleter.CLUSTER);
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterHost(), "150px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        AbstractTextColumn<VDS> dcColumn = new AbstractTextColumn<VDS>() {

            @Override
            public String getValue(VDS object) {
                return object.getStoragePoolName();
            }
        };
        dcColumn.makeSortable(VdsConditionFieldAutoCompleter.DATACENTER);
        // $NON-NLS-1$
        getTable().addColumn(dcColumn, constants.dcHost(), "150px");
    }
    AbstractTextColumn<VDS> statusColumn = new AbstractEnumColumn<VDS, VDSStatus>() {

        @Override
        public VDSStatus getRawValue(VDS object) {
            return object.getStatus();
        }
    };
    ReasonColumn<VDS> reasonColumn = new ReasonColumn<VDS>() {

        @Override
        protected String getReason(VDS value) {
            return value.getMaintenanceReason();
        }
    };
    List<HasCell<VDS, ?>> list = new ArrayList<>();
    list.add(statusColumn);
    list.add(reasonColumn);
    Cell<VDS> compositeCell = new StatusCompositeCell<>(list);
    AbstractColumn<VDS, VDS> statusTextColumn = new AbstractColumn<VDS, VDS>(compositeCell) {

        @Override
        public VDS getValue(VDS object) {
            return object;
        }

        @Override
        public SafeHtml getTooltip(VDS value) {
            String maintenanceReason = value.getMaintenanceReason();
            if (maintenanceReason != null && !maintenanceReason.trim().isEmpty()) {
                return SafeHtmlUtils.fromString(maintenanceReason);
            }
            return null;
        }
    };
    statusTextColumn.makeSortable(VdsConditionFieldAutoCompleter.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(statusTextColumn, constants.statusHost(), "100px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        VmCountColumn vmCountColumn = new VmCountColumn();
        vmCountColumn.setHorizontalAlignment(HasHorizontalAlignment.ALIGN_CENTER);
        vmCountColumn.makeSortable(VdsConditionFieldAutoCompleter.ACTIVE_VMS);
        // $NON-NLS-1$
        getTable().addColumn(vmCountColumn, constants.vmsCount(), "110px");
    }
    AbstractPercentColumn<VDS> memColumn = new AbstractPercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getUsageMemPercent();
        }
    };
    memColumn.makeSortable(VdsConditionFieldAutoCompleter.MEM_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(memColumn, constants.memoryHost(), "60px");
    AbstractPercentColumn<VDS> cpuColumn = new AbstractPercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getUsageCpuPercent();
        }
    };
    cpuColumn.makeSortable(VdsConditionFieldAutoCompleter.CPU_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuHost(), "60px");
    AbstractPercentColumn<VDS> netColumn = new AbstractPercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getUsageNetworkPercent();
        }
    };
    netColumn.makeSortable(VdsConditionFieldAutoCompleter.NETWORK_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(netColumn, constants.networkHost(), "60px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        AbstractTextColumn<VDS> spmColumn = new AbstractTextColumn<VDS>() {

            @Override
            public String getValue(VDS object) {
                int value = object.getVdsSpmPriority();
                int lowValue = defaultSpmPriority / 2;
                int highValue = defaultSpmPriority + (maxSpmPriority - defaultSpmPriority) / 2;
                if (object.getSpmStatus() != VdsSpmStatus.None) {
                    return object.getSpmStatus().name();
                }
                if (value == -1) {
                    return constants.spmNeverText();
                } else if (value == lowValue) {
                    return constants.spmLowText();
                } else if (value == defaultSpmPriority) {
                    return constants.spmNormalText();
                } else if (value == highValue) {
                    return constants.spmHighText();
                }
                return constants.spmCustomText();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(spmColumn, constants.spmPriorityHost(), "100px");
    }
    // Create/Edit/Remove Host operations
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.newHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.editHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.removeHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    // Management operations drop down
    List<ActionButtonDefinition<VDS>> managementSubActions = new LinkedList<>();
    // Maintenance button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.maintenanceHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMaintenanceCommand();
        }
    });
    // Activate button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.activateHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getActivateCommand();
        }
    });
    // Refresh capabilities button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.refreshHostCapabilities()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRefreshCapabilitiesCommand();
        }
    });
    // Confirm rebooted host
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.confirmRebootedHost(), CommandLocation.ContextAndToolBar) {

            @Override
            protected UICommand resolveCommand() {
                return getMainModel().getManualFenceCommand();
            }
        });
    }
    // Power management drop down
    List<ActionButtonDefinition<VDS>> pmSubActions = new LinkedList<>();
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.restartHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRestartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.startHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.stopHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    // Remote management via SSH drop down
    List<ActionButtonDefinition<VDS>> sshSubActions = new LinkedList<>();
    sshSubActions.add(new WebAdminButtonDefinition<VDS>(constants.restartHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getSshRestartCommand();
        }
    });
    sshSubActions.add(new WebAdminButtonDefinition<VDS>(constants.stopHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getSshStopCommand();
        }
    });
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        managementSubActions.add(new WebAdminMenuBarButtonDefinition<>(constants.pmHost(), pmSubActions));
        managementSubActions.add(new WebAdminMenuBarButtonDefinition<>(constants.sshManagement(), sshSubActions));
    }
    // Select as SPM button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.selectHostAsSPM()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getSelectAsSpmCommand();
        }
    });
    // Configure local storage button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.configureLocalStorageHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConfigureLocalStorageCommand();
        }
    });
    // Add management menu bar
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<>(constants.management(), managementSubActions));
    // Installation operations drop down
    List<ActionButtonDefinition<VDS>> moreSubActions = new LinkedList<>();
    // Reinstall button
    moreSubActions.add(new WebAdminButtonDefinition<VDS>(constants.reinstallHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getInstallCommand();
        }
    });
    // Enroll certificate button
    moreSubActions.add(new WebAdminButtonDefinition<VDS>(constants.enrollCertificate()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEnrollCertificateCommand();
        }
    });
    // Check for upgrade button
    moreSubActions.add(new WebAdminButtonDefinition<VDS>(constants.checkForHostUpgrade()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCheckForUpgradeCommand();
        }
    });
    // Upgrade button
    moreSubActions.add(new WebAdminButtonDefinition<VDS>(constants.upgradeHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getUpgradeCommand();
        }
    });
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<>(constants.installation(), moreSubActions));
    // Assign tags
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.assignTagsHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    // NUMA support
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.numaSupport()) {

            @Override
            protected UICommand resolveCommand() {
                return getMainModel().getNumaSupportCommand();
            }
        });
    }
    // Approve
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.approveHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getApproveCommand();
        }
    });
    // HA global maintenance
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.enableGlobalHaMaintenanceVm(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEnableGlobalHaMaintenanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.disableGlobalHaMaintenanceVm(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getDisableGlobalHaMaintenanceCommand();
        }
    });
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    HostStatusColumn<VDS> statusIconColumn = new HostStatusColumn<>();
    statusIconColumn.setContextMenuTitle(constants.statusIconHost());
    // $NON-NLS-1$
    getTable().addColumn(statusIconColumn, constants.empty(), "30px");
    HostAdditionalStatusColumn additionalStatusColumn = new HostAdditionalStatusColumn();
    additionalStatusColumn.setContextMenuTitle(constants.additionalStatusHost());
    // $NON-NLS-1$
    getTable().addColumn(additionalStatusColumn, constants.empty(), "60px");
    AbstractTextColumn<VDS> nameColumn = new AbstractTextColumn<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(VdsConditionFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameHost(), "150px");
    CommentColumn<VDS> commentColumn = new CommentColumn<>();
    getTable().addColumnWithHtmlHeader(commentColumn, SafeHtmlUtils.fromSafeConstant(constants.commentLabel()), // $NON-NLS-1$
    "75px");
    AbstractTextColumn<VDS> hostColumn = new AbstractTextColumn<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getHostName();
        }
    };
    hostColumn.makeSortable(VdsConditionFieldAutoCompleter.ADDRESS);
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.ipHost(), "150px");
    AbstractTextColumn<VDS> clusterColumn = new AbstractTextColumn<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getClusterName();
        }
    };
    clusterColumn.makeSortable(VdsConditionFieldAutoCompleter.CLUSTER);
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterHost(), "150px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        AbstractTextColumn<VDS> dcColumn = new AbstractTextColumn<VDS>() {

            @Override
            public String getValue(VDS object) {
                return object.getStoragePoolName();
            }
        };
        dcColumn.makeSortable(VdsConditionFieldAutoCompleter.DATACENTER);
        // $NON-NLS-1$
        getTable().addColumn(dcColumn, constants.dcHost(), "150px");
    }
    AbstractTextColumn<VDS> statusColumn = new AbstractEnumColumn<VDS, VDSStatus>() {

        @Override
        public VDSStatus getRawValue(VDS object) {
            return object.getStatus();
        }
    };
    ReasonColumn<VDS> reasonColumn = new ReasonColumn<VDS>() {

        @Override
        protected String getReason(VDS value) {
            return value.getMaintenanceReason();
        }
    };
    List<HasCell<VDS, ?>> list = new ArrayList<>();
    list.add(statusColumn);
    list.add(reasonColumn);
    Cell<VDS> compositeCell = new StatusCompositeCell<>(list);
    AbstractColumn<VDS, VDS> statusTextColumn = new AbstractColumn<VDS, VDS>(compositeCell) {

        @Override
        public VDS getValue(VDS object) {
            return object;
        }

        @Override
        public SafeHtml getTooltip(VDS value) {
            String maintenanceReason = value.getMaintenanceReason();
            if (maintenanceReason != null && !maintenanceReason.trim().isEmpty()) {
                return SafeHtmlUtils.fromString(maintenanceReason);
            }
            return null;
        }
    };
    statusTextColumn.makeSortable(VdsConditionFieldAutoCompleter.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(statusTextColumn, constants.statusHost(), "100px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        VmCountColumn vmCountColumn = new VmCountColumn();
        vmCountColumn.setHorizontalAlignment(HasHorizontalAlignment.ALIGN_CENTER);
        vmCountColumn.makeSortable(VdsConditionFieldAutoCompleter.ACTIVE_VMS);
        // $NON-NLS-1$
        getTable().addColumn(vmCountColumn, constants.vmsCount(), "110px");
    }
    AbstractPercentColumn<VDS> memColumn = new AbstractPercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getUsageMemPercent();
        }
    };
    memColumn.makeSortable(VdsConditionFieldAutoCompleter.MEM_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(memColumn, constants.memoryHost(), "60px");
    AbstractPercentColumn<VDS> cpuColumn = new AbstractPercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getUsageCpuPercent();
        }
    };
    cpuColumn.makeSortable(VdsConditionFieldAutoCompleter.CPU_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuHost(), "60px");
    AbstractPercentColumn<VDS> netColumn = new AbstractPercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getUsageNetworkPercent();
        }
    };
    netColumn.makeSortable(VdsConditionFieldAutoCompleter.NETWORK_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(netColumn, constants.networkHost(), "60px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        AbstractTextColumn<VDS> spmColumn = new AbstractTextColumn<VDS>() {

            @Override
            public String getValue(VDS object) {
                int value = object.getVdsSpmPriority();
                int lowValue = defaultSpmPriority / 2;
                int highValue = defaultSpmPriority + (maxSpmPriority - defaultSpmPriority) / 2;
                if (object.getSpmStatus() != VdsSpmStatus.None) {
                    return object.getSpmStatus().name();
                }
                if (value == -1) {
                    return constants.spmNeverText();
                } else if (value == lowValue) {
                    return constants.spmLowText();
                } else if (value == defaultSpmPriority) {
                    return constants.spmNormalText();
                } else if (value == highValue) {
                    return constants.spmHighText();
                }
                return constants.spmCustomText();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(spmColumn, constants.spmPriorityHost(), "100px");
    }
    // Create/Edit/Remove Host operations
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.newHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.editHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.removeHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    // Web Console link (Cockpit)
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.webConsole()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getWebConsoleCommand();
        }
    });
    // Management operations drop down
    List<ActionButtonDefinition<VDS>> managementSubActions = new LinkedList<>();
    // Maintenance button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.maintenanceHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMaintenanceCommand();
        }
    });
    // Activate button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.activateHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getActivateCommand();
        }
    });
    // Refresh capabilities button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.refreshHostCapabilities()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRefreshCapabilitiesCommand();
        }
    });
    // Confirm Host Rebooted button
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.confirmRebootedHost()) {

            @Override
            protected UICommand resolveCommand() {
                return getMainModel().getManualFenceCommand();
            }
        });
    }
    // Power management drop down
    List<ActionButtonDefinition<VDS>> pmSubActions = new LinkedList<>();
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.restartHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRestartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.startHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.stopHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    // Remote management via SSH drop down
    List<ActionButtonDefinition<VDS>> sshSubActions = new LinkedList<>();
    sshSubActions.add(new WebAdminButtonDefinition<VDS>(constants.restartHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getSshRestartCommand();
        }
    });
    sshSubActions.add(new WebAdminButtonDefinition<VDS>(constants.stopHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getSshStopCommand();
        }
    });
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        managementSubActions.add(new WebAdminMenuBarButtonDefinition<>(constants.pmHost(), pmSubActions));
        managementSubActions.add(new WebAdminMenuBarButtonDefinition<>(constants.sshManagement(), sshSubActions));
    }
    // Select as SPM button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.selectHostAsSPM()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getSelectAsSpmCommand();
        }
    });
    // Configure local storage button
    managementSubActions.add(new WebAdminButtonDefinition<VDS>(constants.configureLocalStorageHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConfigureLocalStorageCommand();
        }
    });
    // Add management menu bar
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<>(constants.management(), managementSubActions));
    // Installation operations drop down
    List<ActionButtonDefinition<VDS>> moreSubActions = new LinkedList<>();
    // Reinstall button
    moreSubActions.add(new WebAdminButtonDefinition<VDS>(constants.reinstallHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getInstallCommand();
        }
    });
    // Enroll certificate button
    moreSubActions.add(new WebAdminButtonDefinition<VDS>(constants.enrollCertificate()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEnrollCertificateCommand();
        }
    });
    // Check for upgrade button
    moreSubActions.add(new WebAdminButtonDefinition<VDS>(constants.checkForHostUpgrade()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCheckForUpgradeCommand();
        }
    });
    // Upgrade button
    moreSubActions.add(new WebAdminButtonDefinition<VDS>(constants.upgradeHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getUpgradeCommand();
        }
    });
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<>(constants.installation(), moreSubActions));
    // Assign tags
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.assignTagsHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    // NUMA support
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.numaSupport()) {

            @Override
            protected UICommand resolveCommand() {
                return getMainModel().getNumaSupportCommand();
            }
        });
    }
    // Approve
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.approveHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getApproveCommand();
        }
    });
    // HA global maintenance
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.enableGlobalHaMaintenanceVm(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEnableGlobalHaMaintenanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.disableGlobalHaMaintenanceVm(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getDisableGlobalHaMaintenanceCommand();
        }
    });
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final List<LUNs> lunsFromVgInfo = getLunsFromVgInfo();
    final List<LUNs> lunsFromDb = lunDao.getAllForVolumeGroup(getStorageDomain().getStorage());
    Map<LunUpdateHandler, List<LUNs>> lunsToUpdateInDb = getLunsToUpdateInDb(lunsFromVgInfo, lunsFromDb);
    boolean dbShouldBeUpdated = lunsToUpdateInDb.keySet().stream().anyMatch(LunUpdateHandler::requiresDbUpdate);
    if (dbShouldBeUpdated) {
        TransactionSupport.executeInNewTransaction(() -> {
            updateLunsInDb(lunsToUpdateInDb);
            refreshLunsConnections(lunsFromVgInfo);
            return null;
        });
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    final List<LUNs> lunsFromVgInfo = getLunsFromVgInfo();
    final List<LUNs> lunsFromDb = lunDao.getAllForVolumeGroup(getStorageDomain().getStorage());
    Map<LunHandler, List<LUNs>> lunsToUpdateInDb = getLunsToUpdateInDb(lunsFromVgInfo, lunsFromDb);
    boolean dbShouldBeUpdated = lunsToUpdateInDb.keySet().stream().anyMatch(LunHandler::requiresDbUpdate);
    if (dbShouldBeUpdated) {
        TransactionSupport.executeInNewTransaction(() -> {
            updateLunsInDb(lunsToUpdateInDb);
            refreshLunsConnections(lunsFromVgInfo);
            return null;
        });
    }
    setSucceeded(true);
}
#end_block

#method_before
protected Map<LunUpdateHandler, List<LUNs>> getLunsToUpdateInDb(List<LUNs> lunsFromVgInfo, List<LUNs> lunsFromDb) {
    Map<String, LUNs> lunsFromDbMap = lunsFromDb.stream().collect(Collectors.toMap(LUNs::getLUNId, Function.identity()));
    Map<LunUpdateHandler, List<LUNs>> lunsToUpdateInDb = lunsFromVgInfo.stream().collect(Collectors.groupingBy(lunFromVgInfo -> {
        LUNs lunFromDb = lunsFromDbMap.get(lunFromVgInfo.getLUNId());
        if (lunFromDb == null) {
            // 2. lunFromDb has the same pv id and a different lun id -> using storage from backup.
            return saveNewLuns;
        }
        boolean lunFromDbHasSamePvId = Objects.equals(lunFromDb.getPhysicalVolumeId(), lunFromVgInfo.getPhysicalVolumeId());
        if (lunFromDbHasSamePvId) {
            // Existing lun, check if it should be updated.
            if (lunFromDb.getDeviceSize() != lunFromVgInfo.getDeviceSize() || !Objects.equals(lunFromDb.getDiscardMaxSize(), lunFromVgInfo.getDiscardMaxSize()) || !Objects.equals(lunFromDb.getDiscardZeroesData(), lunFromVgInfo.getDiscardZeroesData())) {
                return updateExistingLuns;
            }
            // Existing lun is up to date.
            return noOp;
        }
        // lunFromDb has the same lun id and a different pv id -> old pv id.
        return updateExistingLuns;
    }));
    lunsToUpdateInDb.put(removeLuns, getLunsToRemoveFromDb(lunsFromVgInfo, lunsFromDb));
    return lunsToUpdateInDb;
}
#method_after
protected Map<LunHandler, List<LUNs>> getLunsToUpdateInDb(List<LUNs> lunsFromVgInfo, List<LUNs> lunsFromDb) {
    Map<String, LUNs> lunsFromDbMap = lunsFromDb.stream().collect(Collectors.toMap(LUNs::getLUNId, Function.identity()));
    Map<LunHandler, List<LUNs>> lunsToUpdateInDb = lunsFromVgInfo.stream().collect(Collectors.groupingBy(lunFromVgInfo -> {
        LUNs lunFromDb = lunsFromDbMap.get(lunFromVgInfo.getLUNId());
        if (lunFromDb == null) {
            // 2. lunFromDb has the same pv id and a different lun id -> using storage from backup.
            return saveLunsHandler;
        }
        boolean lunFromDbHasSamePvId = Objects.equals(lunFromDb.getPhysicalVolumeId(), lunFromVgInfo.getPhysicalVolumeId());
        if (lunFromDbHasSamePvId) {
            // Existing lun, check if it should be updated.
            if (lunFromDb.getDeviceSize() != lunFromVgInfo.getDeviceSize() || !Objects.equals(lunFromDb.getDiscardMaxSize(), lunFromVgInfo.getDiscardMaxSize()) || !Objects.equals(lunFromDb.getDiscardZeroesData(), lunFromVgInfo.getDiscardZeroesData())) {
                return updateLunsHandler;
            }
            // Existing lun is up to date.
            return noOp;
        }
        // lunFromDb has the same lun id and a different pv id -> old pv id.
        return updateLunsHandler;
    }));
    lunsToUpdateInDb.put(removeLunsHandler, getLunsToRemoveFromDb(lunsFromVgInfo, lunsFromDb));
    return lunsToUpdateInDb;
}
#end_block

#method_before
protected void updateLunsInDb(Map<LunUpdateHandler, List<LUNs>> lunsToUpdateInDbMap) {
    lunsToUpdateInDbMap.entrySet().forEach(entry -> entry.getKey().accept(entry.getValue()));
    if (lunsToUpdateInDbMap.keySet().stream().anyMatch(LunUpdateHandler::affectsDiscardFunctionality)) {
        Collection<LUNs> lunsToUpdateInDb = lunsToUpdateInDbMap.entrySet().stream().filter(entry -> entry.getKey().affectsDiscardFunctionality()).map(Map.Entry::getValue).flatMap(List::stream).collect(Collectors.toList());
        discardHelper.logIfLunsBreakStorageDomainDiscardFunctionality(lunsToUpdateInDb, getStorageDomainId());
    }
}
#method_after
protected void updateLunsInDb(Map<LunHandler, List<LUNs>> lunsToUpdateInDbMap) {
    lunsToUpdateInDbMap.entrySet().forEach(entry -> entry.getKey().accept(entry.getValue()));
    if (lunsToUpdateInDbMap.keySet().stream().anyMatch(LunHandler::affectsDiscardFunctionality)) {
        Collection<LUNs> lunsToUpdateInDb = lunsToUpdateInDbMap.entrySet().stream().filter(entry -> entry.getKey().affectsDiscardFunctionality()).map(Map.Entry::getValue).flatMap(List::stream).collect(Collectors.toList());
        discardHelper.logIfLunsBreakStorageDomainDiscardFunctionality(lunsToUpdateInDb, getStorageDomainId());
    }
}
#end_block

#method_before
@Test
public void testGetLunsToUpdateInDbDiffLunIdDiffPvId() {
    Guid lunFromVgLunId = Guid.newGuid();
    List<LUNs> newLunsToSaveInDb = getLunsToUpdateInDb(lunFromVgLunId, Guid.newGuid(), Guid.newGuid(), Guid.newGuid()).get(command.saveNewLuns);
    assertLunIdInList(newLunsToSaveInDb, lunFromVgLunId);
}
#method_after
@Test
public void testGetLunsToUpdateInDbDiffLunIdDiffPvId() {
    Guid lunFromVgLunId = Guid.newGuid();
    List<LUNs> newLunsToSaveInDb = getLunsToUpdateInDb(lunFromVgLunId, Guid.newGuid(), Guid.newGuid(), Guid.newGuid()).get(command.saveLunsHandler);
    assertLunIdInList(newLunsToSaveInDb, lunFromVgLunId);
}
#end_block

#method_before
@Test
public void testGetLunsToUpdateInDbSameLunIdDiffPvId() {
    Guid lunId = Guid.newGuid();
    List<LUNs> existingLunsToUpdateInDb = getLunsToUpdateInDb(lunId, lunId, Guid.newGuid(), Guid.newGuid()).get(command.updateExistingLuns);
    assertLunIdInList(existingLunsToUpdateInDb, lunId);
}
#method_after
@Test
public void testGetLunsToUpdateInDbSameLunIdDiffPvId() {
    Guid lunId = Guid.newGuid();
    List<LUNs> existingLunsToUpdateInDb = getLunsToUpdateInDb(lunId, lunId, Guid.newGuid(), Guid.newGuid()).get(command.updateLunsHandler);
    assertLunIdInList(existingLunsToUpdateInDb, lunId);
}
#end_block

#method_before
@Test
public void testGetLunsToUpdateInDbDiffLunIdSamePvId() {
    Guid pvID = Guid.newGuid();
    Guid lunFromVgLunId = Guid.newGuid();
    List<LUNs> newLunsToSaveInDb = getLunsToUpdateInDb(lunFromVgLunId, Guid.newGuid(), pvID, pvID).get(command.saveNewLuns);
    assertLunIdInList(newLunsToSaveInDb, lunFromVgLunId);
}
#method_after
@Test
public void testGetLunsToUpdateInDbDiffLunIdSamePvId() {
    Guid pvID = Guid.newGuid();
    Guid lunFromVgLunId = Guid.newGuid();
    List<LUNs> newLunsToSaveInDb = getLunsToUpdateInDb(lunFromVgLunId, Guid.newGuid(), pvID, pvID).get(command.saveLunsHandler);
    assertLunIdInList(newLunsToSaveInDb, lunFromVgLunId);
}
#end_block

#method_before
private Map<LunUpdateHandler, List<LUNs>> getLunsToUpdateInDb(Guid lunFromVgLunId, Guid lunFromDbLunId, Guid lunFromVgPvId, Guid lunFromDbPvId) {
    setLunsIds(lunFromVgLunId, lunFromDbLunId, lunFromVgPvId, lunFromDbPvId);
    return getLunsToUpdateInDb();
}
#method_after
private Map<LunHandler, List<LUNs>> getLunsToUpdateInDb(Guid lunFromVgLunId, Guid lunFromDbLunId, Guid lunFromVgPvId, Guid lunFromDbPvId) {
    setLunsIds(lunFromVgLunId, lunFromDbLunId, lunFromVgPvId, lunFromDbPvId);
    return getLunsToUpdateInDb();
}
#end_block

#method_before
@Test
public void testGetLunsToUpdateInDbLunExistsInDbButNotInVgInfo() {
    Guid lunFromDbId = Guid.newGuid();
    List<LUNs> lunsToRemoveFromDb = getLunsToUpdateInDb(Guid.newGuid(), lunFromDbId, Guid.newGuid(), Guid.newGuid()).get(command.removeLuns);
    assertLunIdInList(lunsToRemoveFromDb, lunFromDbId);
}
#method_after
@Test
public void testGetLunsToUpdateInDbLunExistsInDbButNotInVgInfo() {
    Guid lunFromDbId = Guid.newGuid();
    List<LUNs> lunsToRemoveFromDb = getLunsToUpdateInDb(Guid.newGuid(), lunFromDbId, Guid.newGuid(), Guid.newGuid()).get(command.removeLunsHandler);
    assertLunIdInList(lunsToRemoveFromDb, lunFromDbId);
}
#end_block

#method_before
@Test
public void testGetLunsToRemoveFromDb() {
    lunFromVg.setLUNId(Guid.newGuid().toString());
    lunFromDb.setLUNId(Guid.newGuid().toString());
    LUNs dummyLun = new LUNs();
    dummyLun.setId(BusinessEntitiesDefinitions.DUMMY_LUN_ID_PREFIX + Guid.newGuid().toString());
    List<LUNs> lunsFromVgInfo = Collections.singletonList(lunFromVg);
    List<LUNs> lunsFromDb = Arrays.asList(lunFromDb, dummyLun);
    assertTrue(isEqualCollection(command.getLunsToRemoveFromDb(lunsFromVgInfo, lunsFromDb), Collections.singletonList(lunFromDb)));
}
#method_after
@Test
public void testGetLunsToRemoveFromDb() {
    lunFromVg.setLUNId(Guid.newGuid().toString());
    lunFromDb.setLUNId(Guid.newGuid().toString());
    LUNs dummyLun = new LUNs();
    dummyLun.setId(BusinessEntitiesDefinitions.DUMMY_LUN_ID_PREFIX + Guid.newGuid().toString());
    List<LUNs> lunsFromVgInfo = Collections.singletonList(lunFromVg);
    List<LUNs> lunsFromDb = Arrays.asList(lunFromDb, dummyLun);
    assertEquals(command.getLunsToRemoveFromDb(lunsFromVgInfo, lunsFromDb), Collections.singletonList(lunFromDb));
}
#end_block

#method_before
private void assertLunShouldBeUpdatedDueToFieldChange() {
    setLunsSameLunAndPvIds();
    List<LUNs> existingLunsToUpdateInDb = getLunsToUpdateInDb().get(command.updateExistingLuns);
    assertLunIdInList(existingLunsToUpdateInDb, lunFromVg.getLUNId());
}
#method_after
private void assertLunShouldBeUpdatedDueToFieldChange() {
    setLunsSameLunAndPvIds();
    List<LUNs> existingLunsToUpdateInDb = getLunsToUpdateInDb().get(command.updateLunsHandler);
    assertLunIdInList(existingLunsToUpdateInDb, lunFromVg.getLUNId());
}
#end_block

#method_before
private Map<LunUpdateHandler, List<LUNs>> getLunsToUpdateInDb() {
    List<LUNs> lunsFromVgInfo = Collections.singletonList(lunFromVg);
    List<LUNs> lunsFromDb = Collections.singletonList(lunFromDb);
    return command.getLunsToUpdateInDb(lunsFromVgInfo, lunsFromDb);
}
#method_after
private Map<LunHandler, List<LUNs>> getLunsToUpdateInDb() {
    List<LUNs> lunsFromVgInfo = Collections.singletonList(lunFromVg);
    List<LUNs> lunsFromDb = Collections.singletonList(lunFromDb);
    return command.getLunsToUpdateInDb(lunsFromVgInfo, lunsFromDb);
}
#end_block

#method_before
@Test
public void testGetLunsToUpdateInDbDiffLunIdDiffPvId() {
    Guid lunFromVgLunId = Guid.newGuid();
    List<LUNs> newLunsToSaveInDb = getLunsToUpdateInDb(lunFromVgLunId, Guid.newGuid(), Guid.newGuid(), Guid.newGuid()).get(command.saveNewLuns);
    assertLunIdInList(newLunsToSaveInDb, lunFromVgLunId);
}
#method_after
@Test
public void testGetLunsToUpdateInDbDiffLunIdDiffPvId() {
    Guid lunFromVgLunId = Guid.newGuid();
    List<LUNs> newLunsToSaveInDb = getLunsToUpdateInDb(lunFromVgLunId, Guid.newGuid(), Guid.newGuid(), Guid.newGuid()).get(command.saveLunsHandler);
    assertLunIdInList(newLunsToSaveInDb, lunFromVgLunId);
}
#end_block

#method_before
@Test
public void testGetLunsToUpdateInDbSameLunIdDiffPvId() {
    Guid lunId = Guid.newGuid();
    List<LUNs> existingLunsToUpdateInDb = getLunsToUpdateInDb(lunId, lunId, Guid.newGuid(), Guid.newGuid()).get(command.updateExistingLuns);
    assertLunIdInList(existingLunsToUpdateInDb, lunId);
}
#method_after
@Test
public void testGetLunsToUpdateInDbSameLunIdDiffPvId() {
    Guid lunId = Guid.newGuid();
    List<LUNs> existingLunsToUpdateInDb = getLunsToUpdateInDb(lunId, lunId, Guid.newGuid(), Guid.newGuid()).get(command.updateLunsHandler);
    assertLunIdInList(existingLunsToUpdateInDb, lunId);
}
#end_block

#method_before
@Test
public void testGetLunsToUpdateInDbDiffLunIdSamePvId() {
    Guid pvID = Guid.newGuid();
    Guid lunFromVgLunId = Guid.newGuid();
    List<LUNs> newLunsToSaveInDb = getLunsToUpdateInDb(lunFromVgLunId, Guid.newGuid(), pvID, pvID).get(command.saveNewLuns);
    assertLunIdInList(newLunsToSaveInDb, lunFromVgLunId);
}
#method_after
@Test
public void testGetLunsToUpdateInDbDiffLunIdSamePvId() {
    Guid pvID = Guid.newGuid();
    Guid lunFromVgLunId = Guid.newGuid();
    List<LUNs> newLunsToSaveInDb = getLunsToUpdateInDb(lunFromVgLunId, Guid.newGuid(), pvID, pvID).get(command.saveLunsHandler);
    assertLunIdInList(newLunsToSaveInDb, lunFromVgLunId);
}
#end_block

#method_before
private Map<LunUpdateHandler, List<LUNs>> getLunsToUpdateInDb(Guid lunFromVgLunId, Guid lunFromDbLunId, Guid lunFromVgPvId, Guid lunFromDbPvId) {
    setLunsIds(lunFromVgLunId, lunFromDbLunId, lunFromVgPvId, lunFromDbPvId);
    return getLunsToUpdateInDb();
}
#method_after
private Map<LunHandler, List<LUNs>> getLunsToUpdateInDb(Guid lunFromVgLunId, Guid lunFromDbLunId, Guid lunFromVgPvId, Guid lunFromDbPvId) {
    setLunsIds(lunFromVgLunId, lunFromDbLunId, lunFromVgPvId, lunFromDbPvId);
    return getLunsToUpdateInDb();
}
#end_block

#method_before
private void assertLunShouldBeUpdatedDueToFieldChange() {
    setLunsSameLunAndPvIds();
    List<LUNs> existingLunsToUpdateInDb = getLunsToUpdateInDb().get(command.updateExistingLuns);
    assertLunIdInList(existingLunsToUpdateInDb, lunFromVg.getLUNId());
}
#method_after
private void assertLunShouldBeUpdatedDueToFieldChange() {
    setLunsSameLunAndPvIds();
    List<LUNs> existingLunsToUpdateInDb = getLunsToUpdateInDb().get(command.updateLunsHandler);
    assertLunIdInList(existingLunsToUpdateInDb, lunFromVg.getLUNId());
}
#end_block

#method_before
private Map<LunUpdateHandler, List<LUNs>> getLunsToUpdateInDb() {
    List<LUNs> lunsFromVgInfo = Collections.singletonList(lunFromVg);
    List<LUNs> lunsFromDb = Collections.singletonList(lunFromDb);
    return command.getLunsToUpdateInDb(lunsFromVgInfo, lunsFromDb);
}
#method_after
private Map<LunHandler, List<LUNs>> getLunsToUpdateInDb() {
    List<LUNs> lunsFromVgInfo = Collections.singletonList(lunFromVg);
    List<LUNs> lunsFromDb = Collections.singletonList(lunFromDb);
    return command.getLunsToUpdateInDb(lunsFromVgInfo, lunsFromDb);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final List<LUNs> lunsFromVgInfo = getLunsFromVgInfo();
    final List<LUNs> lunsFromDb = lunDao.getAllForVolumeGroup(getStorageDomain().getStorage());
    Map<LunUpdateHandler, List<LUNs>> lunsToUpdateInDb = getLunsToUpdateInDb(lunsFromVgInfo, lunsFromDb);
    boolean dbShouldBeUpdated = lunsToUpdateInDb.keySet().stream().anyMatch(LunUpdateHandler::requiresDbUpdate);
    if (dbShouldBeUpdated) {
        TransactionSupport.executeInNewTransaction(() -> {
            updateLunsInDb(lunsToUpdateInDb);
            refreshLunsConnections(lunsFromVgInfo);
            cleanupLunsFromDb(lunsFromVgInfo, lunsFromDb);
            return null;
        });
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    final List<LUNs> lunsFromVgInfo = getLunsFromVgInfo();
    final List<LUNs> lunsFromDb = lunDao.getAllForVolumeGroup(getStorageDomain().getStorage());
    Map<LunHandler, List<LUNs>> lunsToUpdateInDb = getLunsToUpdateInDb(lunsFromVgInfo, lunsFromDb);
    boolean dbShouldBeUpdated = lunsToUpdateInDb.keySet().stream().anyMatch(LunHandler::requiresDbUpdate);
    if (dbShouldBeUpdated) {
        TransactionSupport.executeInNewTransaction(() -> {
            updateLunsInDb(lunsToUpdateInDb);
            refreshLunsConnections(lunsFromVgInfo);
            cleanupLunsFromDb(lunsFromVgInfo, lunsFromDb);
            return null;
        });
    }
    setSucceeded(true);
}
#end_block

#method_before
protected Map<LunUpdateHandler, List<LUNs>> getLunsToUpdateInDb(List<LUNs> lunsFromVgInfo, List<LUNs> lunsFromDb) {
    Map<String, LUNs> lunsFromDbMap = lunsFromDb.stream().collect(Collectors.toMap(LUNs::getLUNId, Function.identity()));
    return lunsFromVgInfo.stream().collect(Collectors.groupingBy(lunFromVgInfo -> {
        LUNs lunFromDb = lunsFromDbMap.get(lunFromVgInfo.getLUNId());
        if (lunFromDb == null) {
            // 2. lunFromDb has the same pv id and a different lun id -> using storage from backup.
            return saveNewLuns;
        }
        boolean lunFromDbHasSamePvId = Objects.equals(lunFromDb.getPhysicalVolumeId(), lunFromVgInfo.getPhysicalVolumeId());
        if (lunFromDbHasSamePvId) {
            // Existing lun, check if it should be updated.
            if (lunFromDb.getDeviceSize() != lunFromVgInfo.getDeviceSize() || !Objects.equals(lunFromDb.getDiscardMaxSize(), lunFromVgInfo.getDiscardMaxSize()) || !Objects.equals(lunFromDb.getDiscardZeroesData(), lunFromVgInfo.getDiscardZeroesData())) {
                return updateExistingLuns;
            }
            // Existing lun is up to date.
            return noOp;
        }
        // lunFromDb has the same lun id and a different pv id -> old pv id.
        return updateExistingLuns;
    }));
}
#method_after
protected Map<LunHandler, List<LUNs>> getLunsToUpdateInDb(List<LUNs> lunsFromVgInfo, List<LUNs> lunsFromDb) {
    Map<String, LUNs> lunsFromDbMap = lunsFromDb.stream().collect(Collectors.toMap(LUNs::getLUNId, Function.identity()));
    return lunsFromVgInfo.stream().collect(Collectors.groupingBy(lunFromVgInfo -> {
        LUNs lunFromDb = lunsFromDbMap.get(lunFromVgInfo.getLUNId());
        if (lunFromDb == null) {
            // 2. lunFromDb has the same pv id and a different lun id -> using storage from backup.
            return saveLunsHandler;
        }
        boolean lunFromDbHasSamePvId = Objects.equals(lunFromDb.getPhysicalVolumeId(), lunFromVgInfo.getPhysicalVolumeId());
        if (lunFromDbHasSamePvId) {
            // Existing lun, check if it should be updated.
            if (lunFromDb.getDeviceSize() != lunFromVgInfo.getDeviceSize() || !Objects.equals(lunFromDb.getDiscardMaxSize(), lunFromVgInfo.getDiscardMaxSize()) || !Objects.equals(lunFromDb.getDiscardZeroesData(), lunFromVgInfo.getDiscardZeroesData())) {
                return updateLunsHandler;
            }
            // Existing lun is up to date.
            return noOp;
        }
        // lunFromDb has the same lun id and a different pv id -> old pv id.
        return updateLunsHandler;
    }));
}
#end_block

#method_before
protected void updateLunsInDb(Map<LunUpdateHandler, List<LUNs>> lunsToUpdateInDbMap) {
    lunsToUpdateInDbMap.entrySet().forEach(entry -> entry.getKey().accept(entry.getValue()));
    if (lunsToUpdateInDbMap.keySet().stream().anyMatch(LunUpdateHandler::affectsDiscardFunctionality)) {
        Collection<LUNs> lunsToUpdateInDb = lunsToUpdateInDbMap.entrySet().stream().filter(entry -> entry.getKey().affectsDiscardFunctionality()).map(Map.Entry::getValue).flatMap(List::stream).collect(Collectors.toList());
        discardHelper.logIfLunsBreakStorageDomainDiscardFunctionality(lunsToUpdateInDb, getStorageDomainId());
    }
}
#method_after
protected void updateLunsInDb(Map<LunHandler, List<LUNs>> lunsToUpdateInDbMap) {
    lunsToUpdateInDbMap.entrySet().forEach(entry -> entry.getKey().accept(entry.getValue()));
    if (lunsToUpdateInDbMap.keySet().stream().anyMatch(LunHandler::affectsDiscardFunctionality)) {
        Collection<LUNs> lunsToUpdateInDb = lunsToUpdateInDbMap.entrySet().stream().filter(entry -> entry.getKey().affectsDiscardFunctionality()).map(Map.Entry::getValue).flatMap(List::stream).collect(Collectors.toList());
        discardHelper.logIfLunsBreakStorageDomainDiscardFunctionality(lunsToUpdateInDb, getStorageDomainId());
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    DiskValidator diskValidator = new DiskValidator(getDiskImage());
    if (!validate(diskValidator.isDiskExists()) || !validate(diskValidator.isDiskPluggedToVmsThatAreNotDown(false, vmsForDisk))) {
        return false;
    }
    setStoragePoolId(getDiskImage().getStoragePoolId());
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    if (!FeatureSupported.qcowCompatSupported(getStoragePool().getCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_AMEND_NOT_SUPPORTED_BY_DC_VERSION, String.format("$dataCenterVersion %s", getStoragePool().getCompatibilityVersion().toString()));
    }
    if (getDiskImage().getVmEntityType().isTemplateType()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANT_AMEND_TEMPLATE_DISK);
    }
    setStorageDomainId(getDiskImage().getStorageIds().get(0));
    StorageDomainValidator storageDomainValidator = new StorageDomainValidator(getStorageDomain());
    if (!validate(storageDomainValidator.isDomainExistAndActive())) {
        return false;
    }
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(Collections.singletonList(getDiskImage()));
    return validate(diskImagesValidator.diskImagesNotIllegal()) && validate(diskImagesValidator.diskImagesNotLocked());
}
#method_after
@Override
protected boolean validate() {
    DiskValidator diskValidator = new DiskValidator(getDiskImage());
    if (!validate(diskValidator.isDiskExists())) {
        return false;
    }
    List<Pair<VM, VmDevice>> vmsForDisk = vmDao.getVmsWithPlugInfo(getDiskImage().getId());
    if (!validate(diskValidator.isDiskPluggedToVmsThatAreNotDown(false, vmsForDisk))) {
        return false;
    }
    setStoragePoolId(getDiskImage().getStoragePoolId());
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    if (!FeatureSupported.qcowCompatSupported(getStoragePool().getCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_AMEND_NOT_SUPPORTED_BY_DC_VERSION, String.format("$dataCenterVersion %s", getStoragePool().getCompatibilityVersion().toString()));
    }
    if (getDiskImage().getVmEntityType().isTemplateType()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANT_AMEND_TEMPLATE_DISK);
    }
    setStorageDomainId(getDiskImage().getStorageIds().get(0));
    StorageDomainValidator storageDomainValidator = new StorageDomainValidator(getStorageDomain());
    if (!validate(storageDomainValidator.isDomainExistAndActive())) {
        return false;
    }
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(Collections.singletonList(getDiskImage()));
    return validate(diskImagesValidator.diskImagesNotIllegal()) && validate(diskImagesValidator.diskImagesNotLocked());
}
#end_block

#method_before
private Map<String, Pair<String, String>> getSharedLocksForVmDisk() {
    Map<String, Pair<String, String>> lockMap = new HashMap<>();
    if (getDiskImage() != null) {
        vmsForDisk = vmDao.getVmsWithPlugInfo(getDiskImage().getId());
        if (!vmsForDisk.isEmpty()) {
            for (Pair<VM, VmDevice> pair : vmsForDisk) {
                lockMap.put(pair.getFirst().getId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, EngineMessage.ACTION_TYPE_FAILED_VM_IS_LOCKED));
            }
        }
    }
    return lockMap;
}
#method_after
private Map<String, Pair<String, String>> getSharedLocksForVmDisk() {
    Map<String, Pair<String, String>> lockMap = new HashMap<>();
    if (getDiskImage() != null) {
        List<Pair<VM, VmDevice>> vmsForDisk = vmDao.getVmsWithPlugInfo(getDiskImage().getId());
        if (!vmsForDisk.isEmpty()) {
            for (Pair<VM, VmDevice> pair : vmsForDisk) {
                lockMap.put(pair.getFirst().getId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, EngineMessage.ACTION_TYPE_FAILED_VM_IS_LOCKED));
            }
        }
    }
    return lockMap;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Before
public void setUp() {
    doReturn(true).when(vm).isManagedVm();
    doReturn(DisplayType.vga).when(vmStatic).getDefaultDisplayType();
    doReturn(vmStatic).when(vm).getStaticData();
    doReturn(vm).when(cmd).getVm();
    doReturn(vmValidator).when(cmd).createVmValidator();
    doReturn(storagePoolValidator).when(cmd).createStoragePoolValidator();
    doReturn(diskImagesValidator).when(cmd).createDiskImageValidator(anyList());
    doReturn(multipleStorageDomainsValidator).when(cmd).createMultipleStorageDomainsValidator(anyList());
    doReturn(memoryImageBuilder).when(cmd).getMemoryImageBuilder();
    doReturn(true).when(cmd).validateCinder();
    doReturn(Guid.newGuid()).when(cmd).getStorageDomainIdForVmMemory(anyList());
    doReturn(getEmptyDiskList()).when(cmd).getDisksListForChecks();
    doReturn(getEmptyDiskList()).when(cmd).getDiskImagesForVm();
}
#method_after
@SuppressWarnings("unchecked")
@Before
public void setUp() {
    doReturn(true).when(vm).isManagedVm();
    doReturn(DisplayType.vga).when(vmStatic).getDefaultDisplayType();
    doReturn(vmStatic).when(vm).getStaticData();
    doReturn(vm).when(cmd).getVm();
    doReturn(vmValidator).when(cmd).createVmValidator();
    doReturn(storagePoolValidator).when(cmd).createStoragePoolValidator();
    doReturn(diskImagesValidator).when(cmd).createDiskImageValidator(anyList());
    doReturn(diskExistenceValidator).when(cmd).createDiskExistenceValidator(anySet());
    doReturn(multipleStorageDomainsValidator).when(cmd).createMultipleStorageDomainsValidator(anyList());
    doReturn(memoryImageBuilder).when(cmd).getMemoryImageBuilder();
    doReturn(true).when(cmd).validateCinder();
    doReturn(Guid.newGuid()).when(cmd).getStorageDomainIdForVmMemory(anyList());
    doReturn(getEmptyDiskList()).when(cmd).getDisksListForChecks();
    doReturn(getEmptyDiskList()).when(cmd).getDiskImagesForVm();
}
#end_block

#method_before
@Test
public void testImagesDoesNotExist() {
    DiskImage diskImage1 = getNewDiskImage();
    DiskImage diskImage2 = getNewDiskImage();
    List<DiskImage> diskImagesFromParams = new ArrayList<>();
    diskImagesFromParams.addAll(Arrays.asList(diskImage1, diskImage2));
    Set<Guid> guidsForDiskImages = diskImagesFromParams.stream().map(DiskImage::getId).collect(Collectors.toSet());
    cmd.getParameters().setDisks(guidsForDiskImages);
    doReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_DISKS_NOT_EXIST)).when(diskImagesValidator).diskImagesNotExist(guidsForDiskImages);
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_DISKS_NOT_EXIST);
}
#method_after
@Test
public void testImagesDoesNotExist() {
    Set<Guid> guidsForDiskImages = new HashSet<>(Arrays.asList(Guid.newGuid(), Guid.newGuid()));
    cmd.getParameters().setDiskIds(guidsForDiskImages);
    doReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_DISKS_NOT_EXIST)).when(diskExistenceValidator).diskImagesNotExist();
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_DISKS_NOT_EXIST);
}
#end_block

#method_before
protected Response doAdd(Snapshot snapshot, boolean block) {
    validateParameters(snapshot, "description");
    CreateAllSnapshotsFromVmParameters snapshotParams = new CreateAllSnapshotsFromVmParameters(parentId, snapshot.getDescription());
    if (snapshot.isSetPersistMemorystate()) {
        snapshotParams.setSaveMemory(snapshot.isPersistMemorystate());
    }
    if (snapshot.isSetDiskAttachments()) {
        snapshotParams.setDisks(mapDisks(snapshot.getDiskAttachments()));
    }
    return performCreate(VdcActionType.CreateAllSnapshotsFromVm, snapshotParams, new SnapshotIdResolver(), block);
}
#method_after
protected Response doAdd(Snapshot snapshot, boolean block) {
    validateParameters(snapshot, "description");
    CreateAllSnapshotsFromVmParameters snapshotParams = new CreateAllSnapshotsFromVmParameters(parentId, snapshot.getDescription());
    if (snapshot.isSetPersistMemorystate()) {
        snapshotParams.setSaveMemory(snapshot.isPersistMemorystate());
    }
    if (snapshot.isSetDiskAttachments()) {
        snapshotParams.setDiskIds(mapDisks(snapshot.getDiskAttachments()));
    }
    return performCreate(VdcActionType.CreateAllSnapshotsFromVm, snapshotParams, new SnapshotIdResolver(), block);
}
#end_block

#method_before
protected List<DiskImage> getDisksList() {
    if (cachedSelectedActiveDisks == null) {
        List<DiskImage> imagesAndCinderForVm = getDiskImagesForVm();
        // Get disks from the specified parameters or according to the VM
        if (getParameters().getDisks() == null) {
            cachedSelectedActiveDisks = imagesAndCinderForVm;
        } else {
            // Get selected images from 'DiskImagesForVm' to ensure disks entities integrity
            // (i.e. only images' IDs and Cinders' IDs are relevant).
            cachedSelectedActiveDisks = getDiskImagesForVm().stream().filter(d -> getParameters().getDisks().contains(d.getId())).collect(Collectors.toList());
        }
    }
    return cachedSelectedActiveDisks;
}
#method_after
protected List<DiskImage> getDisksList() {
    if (cachedSelectedActiveDisks == null) {
        List<DiskImage> imagesAndCinderForVm = getDiskImagesForVm();
        // Get disks from the specified parameters or according to the VM
        if (getParameters().getDiskIds() == null) {
            cachedSelectedActiveDisks = imagesAndCinderForVm;
        } else {
            // Get selected images from 'DiskImagesForVm' to ensure disks entities integrity
            // (i.e. only images' IDs and Cinders' IDs are relevant).
            cachedSelectedActiveDisks = getDiskImagesForVm().stream().filter(d -> getParameters().getDiskIds().contains(d.getId())).collect(Collectors.toList());
        }
    }
    return cachedSelectedActiveDisks;
}
#end_block

#method_before
private void fastForwardDisksToActiveSnapshot() {
    if (getParameters().getDisks() != null) {
        // Remove disks included in snapshot
        // Fast-forward non-included disks to active snapshot
        getDiskImagesForVm().stream().filter(d -> !getParameters().getDisks().contains(d.getId())).forEach(d -> imageDao.updateImageVmSnapshotId(d.getImageId(), newActiveSnapshotId));
    }
}
#method_after
private void fastForwardDisksToActiveSnapshot() {
    if (getParameters().getDiskIds() != null) {
        // Fast-forward non-included disks to active snapshot
        getDiskImagesForVm().stream().filter(d -> !getParameters().getDiskIds().contains(d.getId())).forEach(d -> imageDao.updateImageVmSnapshotId(d.getImageId(), newActiveSnapshotId));
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVm() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!isSpecifiedDisksExist(getParameters().getDisks())) {
        return false;
    }
    // Initialize validators.
    VmValidator vmValidator = createVmValidator();
    StoragePoolValidator spValidator = createStoragePoolValidator();
    DiskImagesValidator diskImagesValidatorForChain = createDiskImageValidator(DisksFilter.filterImageDisks(getDisksList(), ONLY_NOT_SHAREABLE, ONLY_SNAPABLE, ONLY_ACTIVE));
    if (!(validateVM(vmValidator) && validate(spValidator.isUp()) && validate(vmValidator.vmNotIlegal()) && validate(vmValidator.vmNotLocked()) && validate(snapshotsValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotsValidator.vmNotInPreview(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()) && validate(diskImagesValidatorForChain.diskImagesHaveNotExceededMaxNumberOfVolumesInImageChain()) && (!getParameters().isSaveMemory() || validate(vmValidator.vmNotHavingPciPassthroughDevices())))) {
        return false;
    }
    List<DiskImage> disksList = getDisksListForChecks();
    if (disksList.size() > 0) {
        DiskImagesValidator diskImagesValidator = createDiskImageValidator(disksList);
        if (!(validate(diskImagesValidator.diskImagesNotLocked()) && validate(diskImagesValidator.diskImagesNotIllegal()))) {
            return false;
        }
    }
    return validateStorage();
}
#method_after
@Override
protected boolean validate() {
    if (getVm() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!isSpecifiedDisksExist(getParameters().getDiskIds())) {
        return false;
    }
    // Initialize validators.
    VmValidator vmValidator = createVmValidator();
    StoragePoolValidator spValidator = createStoragePoolValidator();
    DiskImagesValidator diskImagesValidatorForChain = createDiskImageValidator(DisksFilter.filterImageDisks(getDisksList(), ONLY_NOT_SHAREABLE, ONLY_SNAPABLE, ONLY_ACTIVE));
    if (!(validateVM(vmValidator) && validate(spValidator.isUp()) && validate(vmValidator.vmNotIlegal()) && validate(vmValidator.vmNotLocked()) && validate(snapshotsValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotsValidator.vmNotInPreview(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()) && validate(diskImagesValidatorForChain.diskImagesHaveNotExceededMaxNumberOfVolumesInImageChain()) && (!getParameters().isSaveMemory() || validate(vmValidator.vmNotHavingPciPassthroughDevices())))) {
        return false;
    }
    List<DiskImage> disksList = getDisksListForChecks();
    if (disksList.size() > 0) {
        DiskImagesValidator diskImagesValidator = createDiskImageValidator(disksList);
        if (!(validate(diskImagesValidator.diskImagesNotLocked()) && validate(diskImagesValidator.diskImagesNotIllegal()))) {
            return false;
        }
    }
    return validateStorage();
}
#end_block

#method_before
private boolean isSpecifiedDisksExist(Set<Guid> disks) {
    if (disks == null || disks.isEmpty()) {
        return true;
    }
    DiskImagesValidator diskImagesValidator = createDiskImageValidator(new ArrayList<>());
    if (!validate(diskImagesValidator.diskImagesNotExist(disks))) {
        return false;
    }
    return true;
}
#method_after
private boolean isSpecifiedDisksExist(Set<Guid> disks) {
    if (disks == null || disks.isEmpty()) {
        return true;
    }
    DiskExistenceValidator diskExistenceValidator = createDiskExistenceValidator(disks);
    if (!validate(diskExistenceValidator.diskImagesNotExist())) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected CreateAllSnapshotsFromVmParameters getCreateSnapshotParameters(VM vm) {
    Set<Guid> diskIds = vm.getDiskList().stream().map(BaseDisk::getId).collect(Collectors.toSet());
    CreateAllSnapshotsFromVmParameters params = new CreateAllSnapshotsFromVmParameters(vm.getId(), vm.getName() + getStorageDomain().getName() + DR_SNAPSHOT_NAME_SUFFIX, false);
    params.setParentCommand(getActionType());
    params.setSnapshotType(SnapshotType.REGULAR);
    params.setParentParameters(getParameters());
    params.setDisks(diskIds);
    params.setNeedsLocking(false);
    params.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    return params;
}
#method_after
protected CreateAllSnapshotsFromVmParameters getCreateSnapshotParameters(VM vm) {
    Set<Guid> diskIds = vm.getDiskList().stream().map(BaseDisk::getId).collect(Collectors.toSet());
    CreateAllSnapshotsFromVmParameters params = new CreateAllSnapshotsFromVmParameters(vm.getId(), vm.getName() + getStorageDomain().getName() + DR_SNAPSHOT_NAME_SUFFIX, false);
    params.setParentCommand(getActionType());
    params.setSnapshotType(SnapshotType.REGULAR);
    params.setParentParameters(getParameters());
    params.setDiskIds(diskIds);
    params.setNeedsLocking(false);
    params.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    return params;
}
#end_block

#method_before
protected CreateAllSnapshotsFromVmParameters getCreateSnapshotParameters() {
    CreateAllSnapshotsFromVmParameters params = new CreateAllSnapshotsFromVmParameters(getParameters().getVmId(), StorageConstants.LSM_AUTO_GENERATED_SNAPSHOT_DESCRIPTION, false);
    params.setParentCommand(VdcActionType.LiveMigrateVmDisks);
    params.setSnapshotType(SnapshotType.REGULAR);
    params.setParentParameters(getParameters());
    params.setImagesParameters(getParameters().getImagesParameters());
    params.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
    params.setDisks(getMovedDisks());
    params.setDiskIdsToIgnoreInChecks(getMovedDiskIds());
    params.setNeedsLocking(false);
    params.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    return params;
}
#method_after
protected CreateAllSnapshotsFromVmParameters getCreateSnapshotParameters() {
    CreateAllSnapshotsFromVmParameters params = new CreateAllSnapshotsFromVmParameters(getParameters().getVmId(), StorageConstants.LSM_AUTO_GENERATED_SNAPSHOT_DESCRIPTION, false);
    params.setParentCommand(VdcActionType.LiveMigrateVmDisks);
    params.setSnapshotType(SnapshotType.REGULAR);
    params.setParentParameters(getParameters());
    params.setImagesParameters(getParameters().getImagesParameters());
    params.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
    params.setDiskIds(getMovedDiskIds());
    params.setDiskIdsToIgnoreInChecks(getMovedDiskIds());
    params.setNeedsLocking(false);
    params.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    return params;
}
#end_block

#method_before
protected AuditLogType getAuditLogForMigrationFailure() {
    if (getVds().getStatus() == VDSStatus.PreparingForMaintenance) {
        return getDestinationVds() != null ? AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE : AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE_SINCE_NO_VDS_TO_MIGRATE_TO;
    } else {
        if (getDestinationVds() == null) {
            auditLogDirector.log(this, AuditLogType.VM_MIGRATION_NO_VDS_TO_MIGRATE_TO);
        }
        return AuditLogType.VM_MIGRATION_FAILED;
    }
}
#method_after
protected AuditLogType getAuditLogForMigrationFailure() {
    if (getDestinationVds() == null) {
        auditLogDirector.log(this, AuditLogType.VM_MIGRATION_NO_VDS_TO_MIGRATE_TO);
    }
    if (getVds().getStatus() == VDSStatus.PreparingForMaintenance) {
        return getDestinationVds() != null ? AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE : AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE_NO_DESTINATION_VDS;
    }
    return AuditLogType.VM_MIGRATION_FAILED;
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    if (diskInfoDestinationMap != null && !diskInfoDestinationMap.isEmpty()) {
        Map<DiskImage, Guid> map = new HashMap<>();
        for (DiskImage diskImage : diskInfoDestinationMap.values()) {
            if (diskImage.getDiskStorageType() == DiskStorageType.IMAGE) {
                map.put(diskImage, diskImage.getStorageIds().get(0));
            }
        }
        return validate(diskProfileHelper.setAndValidateDiskProfiles(map, getCurrentUser()));
    }
    return true;
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    if (diskInfoDestinationMap != null && !diskInfoDestinationMap.isEmpty()) {
        Map<DiskImage, Guid> map = diskInfoDestinationMap.values().stream().filter(DisksFilter.ONLY_IMAGES).collect(Collectors.toMap(Function.identity(), d -> d.getStorageIds().get(0)));
        return validate(diskProfileHelper.setAndValidateDiskProfiles(map, getCurrentUser()));
    }
    return true;
}
#end_block

#method_before
private void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getParameters().getMasterVm().getMaxMemorySizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getThreadsPerCpu(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getClusterId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVdsList(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled(), getParameters().getMasterVm().getCpuProfileId(), getParameters().getMasterVm().getNumaTuneMode(), getParameters().getMasterVm().getAutoConverge(), getParameters().getMasterVm().getMigrateCompressed(), getParameters().getMasterVm().getUserDefinedProperties(), getParameters().getMasterVm().getPredefinedProperties(), getParameters().getMasterVm().getCustomProperties(), getParameters().getMasterVm().getCustomEmulatedMachine(), getParameters().getMasterVm().getCustomCpuName(), getParameters().getMasterVm().getSmallIconId(), getParameters().getMasterVm().getLargeIconId(), getParameters().getMasterVm().getNumOfIoThreads(), getParameters().getMasterVm().getConsoleDisconnectAction(), getParameters().getMasterVm().getCustomCompatibilityVersion(), getParameters().getMasterVm().getMigrationPolicyId(), null));
    updateVmIcons();
    vmTemplateDao.save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    vmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    vmHandler.addVmInitToDB(getVmTemplate());
}
#method_after
private void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getParameters().getMasterVm().getMaxMemorySizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getThreadsPerCpu(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getClusterId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVdsList(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled(), getParameters().getMasterVm().getCpuProfileId(), getParameters().getMasterVm().getNumaTuneMode(), getParameters().getMasterVm().getAutoConverge(), getParameters().getMasterVm().getMigrateCompressed(), getParameters().getMasterVm().getUserDefinedProperties(), getParameters().getMasterVm().getPredefinedProperties(), getParameters().getMasterVm().getCustomProperties(), getParameters().getMasterVm().getCustomEmulatedMachine(), getParameters().getMasterVm().getCustomCpuName(), getParameters().getMasterVm().getSmallIconId(), getParameters().getMasterVm().getLargeIconId(), getParameters().getMasterVm().getNumOfIoThreads(), getParameters().getMasterVm().getConsoleDisconnectAction(), getParameters().getMasterVm().getCustomCompatibilityVersion(), getParameters().getMasterVm().getMigrationPolicyId(), getParameters().getMasterVm().getLeaseStorageDomainId()));
    updateVmIcons();
    vmTemplateDao.save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    vmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    vmHandler.addVmInitToDB(getVmTemplate());
}
#end_block

#method_before
private void checkTrustedService() {
    if (getVm() == null || getVmTemplate() == null) {
        return;
    }
    if (getVm().isTrustedService() && !getVmTemplate().isTrustedService()) {
        auditLogDirector.log(this, AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getVm().isTrustedService() && getVmTemplate().isTrustedService()) {
        auditLogDirector.log(this, AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#method_after
private void checkTrustedService() {
    if (!isVmInDb) {
        return;
    }
    if (getVm().isTrustedService() && !getVmTemplate().isTrustedService()) {
        auditLogDirector.log(this, AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getVm().isTrustedService() && getVmTemplate().isTrustedService()) {
        auditLogDirector.log(this, AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#end_block

#method_before
protected void commonInitialize() {
    priorityUtil = new PriorityUtil(getModel());
    virtioScsiUtil = new VirtioScsiUtil(getModel());
    getModel().getVmId().setIsAvailable(false);
    getModel().getLease().setIsChangeable(false);
    getModel().getIsHighlyAvailable().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean ha = getModel().getIsHighlyAvailable().getEntity();
            getModel().getLease().setIsChangeable(vmLeasesSupported && ha);
            if (!ha) {
                getModel().getLease().setSelectedItem(null);
            }
        }
    });
    getModel().getMigrationPolicies().setItems(AsyncDataProvider.getInstance().getMigrationPolicies(Version.getLast()));
}
#method_after
protected void commonInitialize() {
    priorityUtil = new PriorityUtil(getModel());
    virtioScsiUtil = new VirtioScsiUtil(getModel());
    getModel().getVmId().setIsAvailable(false);
    getModel().getLease().setIsChangeable(false);
    getModel().getIsHighlyAvailable().getEntityChangedEvent().addListener((ev, sender, args) -> {
        boolean ha = getModel().getIsHighlyAvailable().getEntity();
        setVmLeasesAvailability();
        if (!ha) {
            getModel().getLease().setSelectedItem(null);
        }
    });
    getModel().getMigrationPolicies().setItems(AsyncDataProvider.getInstance().getMigrationPolicies(Version.getLast()));
}
#end_block

#method_before
private void setVmLeasesAvailability() {
    TModel model = getModel();
    Version compVer = model.getSelectedCluster().getCompatibilityVersion();
    if (model.getCustomCompatibilityVersion().getSelectedItem() != null) {
        compVer = model.getCustomCompatibilityVersion().getSelectedItem();
    }
    vmLeasesSupported = AsyncDataProvider.getInstance().isVmLeasesFeatureSupported(compVer);
    if (!vmLeasesSupported) {
        model.getLease().setIsChangeable(vmLeasesSupported, constants.vmLeasesSupported());
    } else {
        model.getLease().setIsChangeable(model.getIsHighlyAvailable().getEntity());
    }
}
#method_after
private void setVmLeasesAvailability() {
    TModel model = getModel();
    Version compVer = model.getSelectedCluster().getCompatibilityVersion();
    if (model.getCustomCompatibilityVersion().getSelectedItem() != null) {
        compVer = model.getCustomCompatibilityVersion().getSelectedItem();
    }
    boolean vmLeasesSupported = AsyncDataProvider.getInstance().isVmLeasesFeatureSupported(compVer);
    if (!vmLeasesSupported) {
        model.getLease().setIsChangeable(false, constants.vmLeasesSupported());
    } else {
        model.getLease().setIsChangeable(model.getIsHighlyAvailable().getEntity());
        if (!model.getIsHighlyAvailable().getEntity()) {
            model.getLease().setChangeProhibitionReason(constants.vmLeasesNotSupportedWithoutHA());
        }
    }
}
#end_block

#method_before
private void setRngAvailability() {
    TModel model = getModel();
    Set<VmRngDevice.Source> requiredRngSources = model.getSelectedCluster().getRequiredRngSources();
    boolean requiredRngSourcesEmpty = requiredRngSources.isEmpty();
    boolean randomSourceAvailable = requiredRngSources.contains(VmRngDevice.Source.RANDOM);
    boolean hwrngSourceAvailable = requiredRngSources.contains(VmRngDevice.Source.HWRNG);
    model.getIsRngEnabled().setIsChangeable(!requiredRngSourcesEmpty);
    model.getRngPeriod().setIsChangeable(!requiredRngSourcesEmpty);
    model.getRngBytes().setIsChangeable(!requiredRngSourcesEmpty);
    if (requiredRngSourcesEmpty) {
        model.getIsRngEnabled().setChangeProhibitionReason(constants.rngNotSupportedByCluster());
        model.getRngPeriod().setChangeProhibitionReason(constants.rngNotSupportedByCluster());
        model.getRngBytes().setChangeProhibitionReason(constants.rngNotSupportedByCluster());
    }
    model.getRngSourceUrandom().setIsChangeable(randomSourceAvailable);
    if (!randomSourceAvailable) {
        model.getRngSourceUrandom().setChangeProhibitionReason(messages.rngSourceNotSupportedByCluster(VmRngDevice.Source.getUrandomOrRandomFor(getModel().getSelectedCluster().getCompatibilityVersion()).toString().toLowerCase()));
    }
    model.getRngSourceHwrng().setIsChangeable(hwrngSourceAvailable);
    if (!hwrngSourceAvailable) {
        model.getRngSourceHwrng().setChangeProhibitionReason(messages.rngSourceNotSupportedByCluster(VmRngDevice.Source.HWRNG.toString().toLowerCase()));
    }
}
#method_after
private void setRngAvailability() {
    TModel model = getModel();
    Set<VmRngDevice.Source> requiredRngSources = model.getSelectedCluster().getRequiredRngSources();
    boolean requiredRngSourcesEmpty = requiredRngSources.isEmpty();
    boolean urandomSourceAvailable = requiredRngSources.contains(VmRngDevice.Source.URANDOM) || requiredRngSources.contains(VmRngDevice.Source.RANDOM);
    boolean hwrngSourceAvailable = requiredRngSources.contains(VmRngDevice.Source.HWRNG);
    model.getIsRngEnabled().setIsChangeable(!requiredRngSourcesEmpty);
    model.getRngPeriod().setIsChangeable(!requiredRngSourcesEmpty);
    model.getRngBytes().setIsChangeable(!requiredRngSourcesEmpty);
    if (requiredRngSourcesEmpty) {
        model.getIsRngEnabled().setChangeProhibitionReason(constants.rngNotSupportedByCluster());
        model.getRngPeriod().setChangeProhibitionReason(constants.rngNotSupportedByCluster());
        model.getRngBytes().setChangeProhibitionReason(constants.rngNotSupportedByCluster());
    }
    model.getRngSourceUrandom().setIsChangeable(urandomSourceAvailable);
    if (!urandomSourceAvailable) {
        model.getRngSourceUrandom().setChangeProhibitionReason(messages.rngSourceNotSupportedByCluster(VmRngDevice.Source.getUrandomOrRandomFor(getModel().getSelectedCluster().getCompatibilityVersion()).toString().toLowerCase()));
    }
    model.getRngSourceHwrng().setIsChangeable(hwrngSourceAvailable);
    if (!hwrngSourceAvailable) {
        model.getRngSourceHwrng().setChangeProhibitionReason(messages.rngSourceNotSupportedByCluster(VmRngDevice.Source.HWRNG.toString().toLowerCase()));
    }
}
#end_block

#method_before
protected void updateUserCdImage(Guid storagePoolId) {
    AsyncDataProvider.getInstance().getIrsImageList(new AsyncQuery<>(new AsyncCallback<List<String>>() {

        @Override
        public void onSuccess(List<String> images) {
            setImagesToModel(getModel(), images);
        }
    }), storagePoolId);
}
#method_after
protected void updateUserCdImage(Guid storagePoolId) {
    AsyncDataProvider.getInstance().getIrsImageList(new AsyncQuery<>(images -> setImagesToModel(getModel(), images)), storagePoolId);
}
#end_block

#method_before
protected void updateCdImage(boolean forceRefresh) {
    StoragePool dataCenter = getModel().getSelectedDataCenter();
    if (dataCenter == null) {
        return;
    }
    AsyncDataProvider.getInstance().getIrsImageList(asyncQuery(new AsyncCallback<List<String>>() {

        @Override
        public void onSuccess(List<String> images) {
            setImagesToModel(getModel(), images);
        }
    }), dataCenter.getId(), forceRefresh);
}
#method_after
protected void updateCdImage(boolean forceRefresh) {
    StoragePool dataCenter = getModel().getSelectedDataCenter();
    if (dataCenter == null) {
        return;
    }
    AsyncDataProvider.getInstance().getIrsImageList(asyncQuery(images -> setImagesToModel(getModel(), images)), dataCenter.getId(), forceRefresh);
}
#end_block

#method_before
protected void updateDefaultHost() {
    Cluster cluster = getModel().getSelectedCluster();
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    if (cluster == null) {
        getModel().getDefaultHost().setItems(new ArrayList<VDS>());
        getModel().getDefaultHost().setSelectedItems(new ArrayList<VDS>());
        return;
    }
    getHostListByCluster(cluster, asyncQuery(new AsyncCallback() {

        @Override
        public void onSuccess(Object returnValue) {
            List<VDS> hosts = null;
            if (returnValue instanceof List) {
                hosts = (List<VDS>) returnValue;
            } else if (returnValue instanceof VdcQueryReturnValue && ((VdcQueryReturnValue) returnValue).getReturnValue() instanceof List) {
                hosts = ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                // $NON-NLS-1$
                throw new IllegalArgumentException("The return value should be List<VDS> or VdcQueryReturnValue with return value List<VDS>");
            }
            List<VDS> oldDefaultHosts = getModel().getDefaultHost().getSelectedItems();
            if (getModel().getBehavior().getSystemTreeSelectedItem() != null && getModel().getBehavior().getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host) {
                VDS host = (VDS) getModel().getBehavior().getSystemTreeSelectedItem().getEntity();
                for (VDS vds : hosts) {
                    if (host.getId().equals(vds.getId())) {
                        getModel().getDefaultHost().setItems(new ArrayList<>(Collections.singletonList(vds)));
                        getModel().getDefaultHost().setSelectedItems(Collections.singletonList(vds));
                        getModel().getDefaultHost().setIsChangeable(false);
                        getModel().getDefaultHost().setChangeProhibitionReason(constants.cannotChangeHostInTreeContext());
                        break;
                    }
                }
            } else {
                getModel().getDefaultHost().setItems(hosts);
                // attempt to preserve selection as much as possible
                if (oldDefaultHosts != null && !oldDefaultHosts.isEmpty()) {
                    Set<VDS> oldSelectedIntersectionNewHosts = new HashSet<>(oldDefaultHosts);
                    oldSelectedIntersectionNewHosts.retainAll(hosts);
                    oldDefaultHosts = new ArrayList<>(oldSelectedIntersectionNewHosts);
                }
                List<VDS> hostsToSelect = oldDefaultHosts != null && !oldDefaultHosts.isEmpty() ? oldDefaultHosts : !hosts.isEmpty() ? Collections.singletonList(hosts.get(0)) : Collections.<VDS>emptyList();
                getModel().getDefaultHost().setSelectedItems(hostsToSelect);
            }
            changeDefaultHost();
        }
    }));
}
#method_after
protected void updateDefaultHost() {
    Cluster cluster = getModel().getSelectedCluster();
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    if (cluster == null) {
        getModel().getDefaultHost().setItems(new ArrayList<VDS>());
        getModel().getDefaultHost().setSelectedItems(new ArrayList<VDS>());
        return;
    }
    getHostListByCluster(cluster, asyncQuery(returnValue -> {
        List<VDS> hosts = null;
        if (returnValue instanceof List) {
            hosts = (List<VDS>) returnValue;
        } else if (returnValue instanceof VdcQueryReturnValue && ((VdcQueryReturnValue) returnValue).getReturnValue() instanceof List) {
            hosts = ((VdcQueryReturnValue) returnValue).getReturnValue();
        } else {
            // $NON-NLS-1$
            throw new IllegalArgumentException("The return value should be List<VDS> or VdcQueryReturnValue with return value List<VDS>");
        }
        List<VDS> oldDefaultHosts = getModel().getDefaultHost().getSelectedItems();
        if (getModel().getBehavior().getSystemTreeSelectedItem() != null && getModel().getBehavior().getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host) {
            VDS host = (VDS) getModel().getBehavior().getSystemTreeSelectedItem().getEntity();
            for (VDS vds : hosts) {
                if (host.getId().equals(vds.getId())) {
                    getModel().getDefaultHost().setItems(new ArrayList<>(Collections.singletonList(vds)));
                    getModel().getDefaultHost().setSelectedItems(Collections.singletonList(vds));
                    getModel().getDefaultHost().setIsChangeable(false);
                    getModel().getDefaultHost().setChangeProhibitionReason(constants.cannotChangeHostInTreeContext());
                    break;
                }
            }
        } else {
            getModel().getDefaultHost().setItems(hosts);
            // attempt to preserve selection as much as possible
            if (oldDefaultHosts != null && !oldDefaultHosts.isEmpty()) {
                Set<VDS> oldSelectedIntersectionNewHosts = new HashSet<>(oldDefaultHosts);
                oldSelectedIntersectionNewHosts.retainAll(hosts);
                oldDefaultHosts = new ArrayList<>(oldSelectedIntersectionNewHosts);
            }
            List<VDS> hostsToSelect = oldDefaultHosts != null && !oldDefaultHosts.isEmpty() ? oldDefaultHosts : !hosts.isEmpty() ? Collections.singletonList(hosts.get(0)) : Collections.<VDS>emptyList();
            getModel().getDefaultHost().setSelectedItems(hostsToSelect);
        }
        changeDefaultHost();
    }));
}
#end_block

#method_before
public void updataMaxVmsInPool() {
    AsyncDataProvider.getInstance().getMaxVmsInPool(asyncQuery(new AsyncCallback<Integer>() {

        @Override
        public void onSuccess(Integer returnValue) {
            setMaxVmsInPool(returnValue);
            updateMaxNumOfVmCpus();
        }
    }));
}
#method_after
public void updataMaxVmsInPool() {
    AsyncDataProvider.getInstance().getMaxVmsInPool(asyncQuery(returnValue -> {
        setMaxVmsInPool(returnValue);
        updateMaxNumOfVmCpus();
    }));
}
#end_block

#method_before
public void updateMaxNumOfVmCpus() {
    String version = getCompatibilityVersion().toString();
    AsyncDataProvider.getInstance().getMaxNumOfVmCpus(asyncQuery(new AsyncCallback<Integer>() {

        @Override
        public void onSuccess(Integer returnValue) {
            maxCpus = returnValue;
            postUpdateNumOfSockets2();
        }
    }), version);
}
#method_after
public void updateMaxNumOfVmCpus() {
    String version = getCompatibilityVersion().toString();
    AsyncDataProvider.getInstance().getMaxNumOfVmCpus(asyncQuery(returnValue -> {
        maxCpus = returnValue;
        postUpdateNumOfSockets2();
    }), version);
}
#end_block

#method_before
public void postUpdateNumOfSockets2() {
    String version = getCompatibilityVersion().toString();
    AsyncDataProvider.getInstance().getMaxNumOfCPUsPerSocket(asyncQuery(new AsyncCallback<Integer>() {

        @Override
        public void onSuccess(Integer returnValue) {
            maxCpusPerSocket = returnValue;
            postUpdateNumOfSockets3();
        }
    }), version);
}
#method_after
public void postUpdateNumOfSockets2() {
    String version = getCompatibilityVersion().toString();
    AsyncDataProvider.getInstance().getMaxNumOfCPUsPerSocket(asyncQuery(returnValue -> {
        maxCpusPerSocket = returnValue;
        postUpdateNumOfSockets3();
    }), version);
}
#end_block

#method_before
public void postUpdateNumOfSockets3() {
    String version = getCompatibilityVersion().toString();
    AsyncDataProvider.getInstance().getMaxNumOfThreadsPerCpu(asyncQuery(new AsyncCallback<Integer>() {

        @Override
        public void onSuccess(Integer returnValue) {
            maxThreadsPerCore = returnValue;
            totalCpuCoresChanged();
        }
    }), version);
}
#method_after
public void postUpdateNumOfSockets3() {
    String version = getCompatibilityVersion().toString();
    AsyncDataProvider.getInstance().getMaxNumOfThreadsPerCpu(asyncQuery(returnValue -> {
        maxThreadsPerCore = returnValue;
        totalCpuCoresChanged();
    }), version);
}
#end_block

#method_before
public void initDisks() {
    VmTemplate template = getModel().getTemplateWithVersion().getSelectedItem().getTemplateVersion();
    AsyncDataProvider.getInstance().getTemplateDiskList(asyncQuery(new AsyncCallback<List<DiskImage>>() {

        @Override
        public void onSuccess(List<DiskImage> returnValue) {
            initTemplateDisks(returnValue);
        }
    }), template.getId());
}
#method_after
public void initDisks() {
    VmTemplate template = getModel().getTemplateWithVersion().getSelectedItem().getTemplateVersion();
    AsyncDataProvider.getInstance().getTemplateDiskList(asyncQuery(returnValue -> initTemplateDisks(returnValue)), template.getId());
}
#end_block

#method_before
protected void postInitStorageDomains() {
    if (getModel().getDisks() == null) {
        return;
    }
    ActionGroup actionGroup = getModel().isCreateInstanceOnly() ? ActionGroup.CREATE_INSTANCE : ActionGroup.CREATE_VM;
    StoragePool dataCenter = getModel().getSelectedDataCenter();
    AsyncDataProvider.getInstance().getPermittedStorageDomainsByStoragePoolId(new AsyncQuery<>(new AsyncCallback<List<StorageDomain>>() {

        @Override
        public void onSuccess(List<StorageDomain> storageDomains) {
            ArrayList<StorageDomain> activeStorageDomains = filterStorageDomains(storageDomains);
            boolean provisioning = getModel().getProvisioning().getEntity();
            ArrayList<DiskModel> disks = (ArrayList<DiskModel>) getModel().getDisks();
            Collections.sort(activeStorageDomains, new NameableComparator());
            ArrayList<DiskModel> diskImages = Linq.filterDisksByType(disks, DiskStorageType.IMAGE);
            for (DiskModel diskModel : diskImages) {
                ArrayList<StorageDomain> availableDiskStorageDomains;
                diskModel.getQuota().setItems(getModel().getQuota().getItems());
                ArrayList<Guid> storageIds = ((DiskImage) diskModel.getDisk()).getStorageIds();
                // Active storage domains that the disk resides on
                ArrayList<StorageDomain> activeDiskStorageDomains = Linq.getStorageDomainsByIds(storageIds, activeStorageDomains);
                // Set target storage domains
                availableDiskStorageDomains = provisioning ? activeStorageDomains : activeDiskStorageDomains;
                Collections.sort(availableDiskStorageDomains, new NameableComparator());
                diskModel.getStorageDomain().setItems(availableDiskStorageDomains);
                diskModel.getStorageDomain().setChangeProhibitionReason(constants.noActiveTargetStorageDomainAvailableMsg());
                diskModel.getStorageDomain().setIsChangeable(!availableDiskStorageDomains.isEmpty());
            }
            ArrayList<DiskModel> cinderDisks = Linq.filterDisksByType(disks, DiskStorageType.CINDER);
            Collection<StorageDomain> cinderStorageDomains = Linq.filterStorageDomainsByStorageType(storageDomains, StorageType.CINDER);
            initStorageDomainsForCinderDisks(cinderDisks, cinderStorageDomains);
        }
    }), dataCenter.getId(), actionGroup);
}
#method_after
protected void postInitStorageDomains() {
    if (getModel().getDisks() == null) {
        return;
    }
    ActionGroup actionGroup = getModel().isCreateInstanceOnly() ? ActionGroup.CREATE_INSTANCE : ActionGroup.CREATE_VM;
    StoragePool dataCenter = getModel().getSelectedDataCenter();
    AsyncDataProvider.getInstance().getPermittedStorageDomainsByStoragePoolId(new AsyncQuery<>(storageDomains -> {
        ArrayList<StorageDomain> activeStorageDomains = filterStorageDomains(storageDomains);
        boolean provisioning = getModel().getProvisioning().getEntity();
        ArrayList<DiskModel> disks = (ArrayList<DiskModel>) getModel().getDisks();
        Collections.sort(activeStorageDomains, new NameableComparator());
        List<DiskModel> diskImages = Linq.filterDisksByType(disks, DiskStorageType.IMAGE);
        for (DiskModel diskModel : diskImages) {
            List<StorageDomain> availableDiskStorageDomains;
            diskModel.getQuota().setItems(getModel().getQuota().getItems());
            ArrayList<Guid> storageIds = ((DiskImage) diskModel.getDisk()).getStorageIds();
            // Active storage domains that the disk resides on
            List<StorageDomain> activeDiskStorageDomains = Linq.getStorageDomainsByIds(storageIds, activeStorageDomains);
            // Set target storage domains
            availableDiskStorageDomains = provisioning ? activeStorageDomains : activeDiskStorageDomains;
            Collections.sort(availableDiskStorageDomains, new NameableComparator());
            diskModel.getStorageDomain().setItems(availableDiskStorageDomains);
            diskModel.getStorageDomain().setChangeProhibitionReason(constants.noActiveTargetStorageDomainAvailableMsg());
            diskModel.getStorageDomain().setIsChangeable(!availableDiskStorageDomains.isEmpty());
        }
        List<DiskModel> cinderDisks = Linq.filterDisksByType(disks, DiskStorageType.CINDER);
        Collection<StorageDomain> cinderStorageDomains = Linq.filterStorageDomainsByStorageType(storageDomains, StorageType.CINDER);
        initStorageDomainsForCinderDisks(cinderDisks, cinderStorageDomains);
    }), dataCenter.getId(), actionGroup);
}
#end_block

#method_before
private void initStorageDomainsForCinderDisks(ArrayList<DiskModel> cinderDisks, Collection<StorageDomain> cinderStorageDomains) {
    for (DiskModel diskModel : cinderDisks) {
        CinderDisk cinderDisk = (CinderDisk) diskModel.getDisk();
        diskModel.getStorageDomain().setItems(Linq.filterStorageDomainById(cinderStorageDomains, cinderDisk.getStorageIds().get(0)));
        diskModel.getStorageDomain().setIsChangeable(false);
        diskModel.getDiskProfile().setIsChangeable(false);
        diskModel.getDiskProfile().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().notSupportedForCinderDisks());
    }
}
#method_after
private void initStorageDomainsForCinderDisks(List<DiskModel> cinderDisks, Collection<StorageDomain> cinderStorageDomains) {
    for (DiskModel diskModel : cinderDisks) {
        CinderDisk cinderDisk = (CinderDisk) diskModel.getDisk();
        diskModel.getStorageDomain().setItems(Linq.filterStorageDomainById(cinderStorageDomains, cinderDisk.getStorageIds().get(0)));
        diskModel.getStorageDomain().setIsChangeable(false);
        diskModel.getDiskProfile().setIsChangeable(false);
        diskModel.getDiskProfile().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().notSupportedForCinderDisks());
    }
}
#end_block

#method_before
protected void updateQuotaByCluster(final Guid defaultQuota, final String quotaName) {
    if (getModel().getQuota().getIsAvailable()) {
        Cluster cluster = getModel().getSelectedCluster();
        if (cluster == null) {
            return;
        }
        AsyncDataProvider.getInstance().getAllRelevantQuotasForClusterSorted(new AsyncQuery<>(new AsyncCallback<List<Quota>>() {

            @Override
            public void onSuccess(List<Quota> quotaList) {
                UnitVmModel vmModel = getModel();
                if (quotaList == null) {
                    return;
                }
                if (!quotaList.isEmpty()) {
                    vmModel.getQuota().setItems(quotaList);
                }
                if (defaultQuota != null && !Guid.Empty.equals(defaultQuota)) {
                    boolean hasQuotaInList = false;
                    if (!quotaList.isEmpty()) {
                        hasQuotaInList = defaultQuota.equals(quotaList.get(0).getId());
                    }
                    // Add the quota to the list only in edit mode
                    if (!hasQuotaInList && !getModel().getIsNew()) {
                        Quota quota = new Quota();
                        quota.setId(defaultQuota);
                        quota.setQuotaName(quotaName);
                        quotaList.add(0, quota);
                        vmModel.getQuota().setItems(quotaList);
                        vmModel.getQuota().setSelectedItem(quota);
                    }
                }
            }
        }), cluster.getId(), defaultQuota);
    }
}
#method_after
protected void updateQuotaByCluster(final Guid defaultQuota, final String quotaName) {
    if (getModel().getQuota().getIsAvailable()) {
        Cluster cluster = getModel().getSelectedCluster();
        if (cluster == null) {
            return;
        }
        AsyncDataProvider.getInstance().getAllRelevantQuotasForClusterSorted(new AsyncQuery<>(quotaList -> {
            UnitVmModel vmModel = getModel();
            if (quotaList == null) {
                return;
            }
            if (!quotaList.isEmpty()) {
                vmModel.getQuota().setItems(quotaList);
            }
            if (defaultQuota != null && !Guid.Empty.equals(defaultQuota)) {
                boolean hasQuotaInList = false;
                if (!quotaList.isEmpty()) {
                    hasQuotaInList = defaultQuota.equals(quotaList.get(0).getId());
                }
                // Add the quota to the list only in edit mode
                if (!hasQuotaInList && !getModel().getIsNew()) {
                    Quota quota = new Quota();
                    quota.setId(defaultQuota);
                    quota.setQuotaName(quotaName);
                    quotaList.add(0, quota);
                    vmModel.getQuota().setItems(quotaList);
                    vmModel.getQuota().setSelectedItem(quota);
                }
            }
        }), cluster.getId(), defaultQuota);
    }
}
#end_block

#method_before
protected void setupTemplateWithVersion(final Guid templateId, final boolean useLatest, final boolean isVersionChangeable) {
    AsyncDataProvider.getInstance().getTemplateById(new AsyncQuery<>(new AsyncCallback<VmTemplate>() {

        @Override
        public void onSuccess(VmTemplate rawTemplate) {
            if (isVersionChangeable) {
                // only used by pools therefore query is limited to admin-portal permissions.
                AsyncDataProvider.getInstance().getVmTemplatesByBaseTemplateId(new AsyncQuery<>(new AsyncCallback<List<VmTemplate>>() {

                    @Override
                    public void onSuccess(List<VmTemplate> templatesChain) {
                        initTemplateWithVersion(templatesChain, templateId, useLatest);
                    }
                }), rawTemplate.getBaseTemplateId());
            } else {
                final VmTemplate template = useLatest ? new LatestVmTemplate(rawTemplate) : rawTemplate;
                if (template.isBaseTemplate()) {
                    TemplateWithVersion templateCouple = new TemplateWithVersion(template, template);
                    setReadOnlyTemplateWithVersion(templateCouple);
                } else {
                    AsyncDataProvider.getInstance().getTemplateById(new AsyncQuery<>(new AsyncCallback<VmTemplate>() {

                        @Override
                        public void onSuccess(VmTemplate baseTemplate) {
                            TemplateWithVersion templateCouple = new TemplateWithVersion(baseTemplate, template);
                            setReadOnlyTemplateWithVersion(templateCouple);
                        }
                    }), template.getBaseTemplateId());
                }
            }
        }
    }), templateId);
}
#method_after
protected void setupTemplateWithVersion(final Guid templateId, final boolean useLatest, final boolean isVersionChangeable) {
    AsyncDataProvider.getInstance().getTemplateById(new AsyncQuery<>(rawTemplate -> {
        if (isVersionChangeable) {
            // only used by pools therefore query is limited to admin-portal permissions.
            AsyncDataProvider.getInstance().getVmTemplatesByBaseTemplateId(new AsyncQuery<>(templatesChain -> initTemplateWithVersion(templatesChain, templateId, useLatest)), rawTemplate.getBaseTemplateId());
        } else {
            final VmTemplate template = useLatest ? new LatestVmTemplate(rawTemplate) : rawTemplate;
            if (template.isBaseTemplate()) {
                TemplateWithVersion templateCouple = new TemplateWithVersion(template, template);
                setReadOnlyTemplateWithVersion(templateCouple);
            } else {
                AsyncDataProvider.getInstance().getTemplateById(new AsyncQuery<>(baseTemplate -> {
                    TemplateWithVersion templateCouple = new TemplateWithVersion(baseTemplate, template);
                    setReadOnlyTemplateWithVersion(templateCouple);
                }), template.getBaseTemplateId());
            }
        }
    }), templateId);
}
#end_block

#method_before
protected void updateNumOfSockets() {
    Version version = getCompatibilityVersion();
    if (version == null) {
        return;
    }
    AsyncDataProvider.getInstance().getMaxNumOfVmSockets(asyncQuery(new AsyncCallback<Integer>() {

        @Override
        public void onSuccess(Integer returnValue) {
            maxNumOfSockets = returnValue;
            updataMaxVmsInPool();
        }
    }), version.toString());
}
#method_after
protected void updateNumOfSockets() {
    Version version = getCompatibilityVersion();
    if (version == null) {
        return;
    }
    AsyncDataProvider.getInstance().getMaxNumOfVmSockets(asyncQuery(returnValue -> {
        maxNumOfSockets = returnValue;
        updataMaxVmsInPool();
    }), version.toString());
}
#end_block

#method_before
protected void updateLeaseStorageDomains(final Guid selectedStorageDomainId) {
    setVmLeasesAvailability();
    AsyncDataProvider.getInstance().getStorageDomainList(new AsyncQuery<>(new AsyncCallback<List<StorageDomain>>() {

        @Override
        public void onSuccess(List<StorageDomain> returnValue) {
            List<StorageDomain> domains = new ArrayList<>();
            domains.add(null);
            for (StorageDomain domain : returnValue) {
                if (domain.getStorageDomainType().isDataDomain() && domain.getStatus() == StorageDomainStatus.Active) {
                    domains.add(domain);
                }
            }
            getModel().getLease().setItems(domains);
            if (!getModel().getLease().getIsChangable() || selectedStorageDomainId == null) {
                getModel().getLease().setSelectedItem(null);
            } else {
                for (StorageDomain domain : domains) {
                    if (domain != null && selectedStorageDomainId.equals(domain.getId())) {
                        getModel().getLease().setSelectedItem(domain);
                        break;
                    }
                }
            }
        }
    }), getModel().getSelectedDataCenter().getId());
}
#method_after
protected void updateLeaseStorageDomains(final Guid selectedStorageDomainId) {
    setVmLeasesAvailability();
    AsyncDataProvider.getInstance().getStorageDomainList(new AsyncQuery<>(returnValue -> {
        List<StorageDomain> domains = new ArrayList<>();
        domains.add(null);
        for (StorageDomain domain : returnValue) {
            if (domain.getStorageDomainType().isDataDomain() && domain.getStatus() == StorageDomainStatus.Active) {
                domains.add(domain);
            }
        }
        getModel().getLease().setItems(domains);
        if (!getModel().getLease().getIsChangable() || selectedStorageDomainId == null) {
            getModel().getLease().setSelectedItem(null);
        } else {
            for (StorageDomain domain : domains) {
                if (domain != null && selectedStorageDomainId.equals(domain.getId())) {
                    getModel().getLease().setSelectedItem(domain);
                    break;
                }
            }
        }
    }), getModel().getSelectedDataCenter().getId());
}
#end_block

#method_before
protected void updateEmulatedMachines() {
    Cluster cluster = getModel().getSelectedCluster();
    if (cluster == null) {
        return;
    }
    AsyncDataProvider.getInstance().getEmulatedMachinesByClusterID(new AsyncQuery<>(new AsyncCallback<Set<String>>() {

        @Override
        public void onSuccess(Set<String> returnValue) {
            if (returnValue != null) {
                Set<String> emulatedSet = new TreeSet<>(returnValue);
                // $NON-NLS-1$
                emulatedSet.add("");
                String oldVal = getModel().getEmulatedMachine().getSelectedItem();
                getModel().getEmulatedMachine().setItems(emulatedSet);
                getModel().getEmulatedMachine().setSelectedItem(oldVal);
            }
        }
    }), cluster.getId());
}
#method_after
protected void updateEmulatedMachines() {
    Cluster cluster = getModel().getSelectedCluster();
    if (cluster == null) {
        return;
    }
    AsyncDataProvider.getInstance().getEmulatedMachinesByClusterID(new AsyncQuery<>(returnValue -> {
        if (returnValue != null) {
            Set<String> emulatedSet = new TreeSet<>(returnValue);
            // $NON-NLS-1$
            emulatedSet.add("");
            String oldVal = getModel().getEmulatedMachine().getSelectedItem();
            getModel().getEmulatedMachine().setItems(emulatedSet);
            getModel().getEmulatedMachine().setSelectedItem(oldVal);
        }
    }), cluster.getId());
}
#end_block

#method_before
/*
     * Updates the cpu model combobox after a cluster change occurs
     */
protected void updateCustomCpu() {
    Cluster cluster = getModel().getSelectedCluster();
    if (cluster == null || cluster.getCpuName() == null) {
        return;
    }
    AsyncDataProvider.getInstance().getSupportedCpuList(new AsyncQuery<>(new AsyncCallback<List<ServerCpu>>() {

        @Override
        public void onSuccess(List<ServerCpu> returnValue) {
            if (returnValue != null) {
                List<String> cpuList = new ArrayList<>();
                // $NON-NLS-1$
                cpuList.add("");
                for (ServerCpu cpu : returnValue) {
                    cpuList.add(cpu.getVdsVerbData());
                }
                String oldVal = getModel().getCustomCpu().getSelectedItem();
                getModel().getCustomCpu().setItems(cpuList);
                getModel().getCustomCpu().setSelectedItem(oldVal);
            }
        }
    }), cluster.getCpuName());
}
#method_after
/*
     * Updates the cpu model combobox after a cluster change occurs
     */
protected void updateCustomCpu() {
    Cluster cluster = getModel().getSelectedCluster();
    if (cluster == null || cluster.getCpuName() == null) {
        return;
    }
    AsyncDataProvider.getInstance().getSupportedCpuList(new AsyncQuery<>(returnValue -> {
        if (returnValue != null) {
            List<String> cpuList = new ArrayList<>();
            // $NON-NLS-1$
            cpuList.add("");
            for (ServerCpu cpu : returnValue) {
                cpuList.add(cpu.getVdsVerbData());
            }
            String oldVal = getModel().getCustomCpu().getSelectedItem();
            getModel().getCustomCpu().setItems(cpuList);
            getModel().getCustomCpu().setSelectedItem(oldVal);
        }
    }), cluster.getCpuName());
}
#end_block

#method_before
protected void updateConsoleDevice(Guid vmId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetConsoleDevices, new IdQueryParameters(vmId), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            List<String> consoleDevices = returnValue.getReturnValue();
            getModel().getIsConsoleDeviceEnabled().setEntity(!consoleDevices.isEmpty());
        }
    }));
}
#method_after
protected void updateConsoleDevice(Guid vmId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetConsoleDevices, new IdQueryParameters(vmId), new AsyncQuery<VdcQueryReturnValue>(returnValue -> {
        List<String> consoleDevices = returnValue.getReturnValue();
        getModel().getIsConsoleDeviceEnabled().setEntity(!consoleDevices.isEmpty());
    }));
}
#end_block

#method_before
protected void updateRngDevice(Guid templateId) {
    if (!getModel().getIsRngEnabled().getIsChangable()) {
        return;
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(templateId), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            List<VmRngDevice> devs = returnValue.getReturnValue();
            getModel().getIsRngEnabled().setEntity(!devs.isEmpty());
            final VmRngDevice rngDevice = devs.isEmpty() ? new VmRngDevice() : devs.get(0);
            rngDevice.updateSourceByVersion(getModel().getCompatibilityVersion());
            getModel().setRngDevice(rngDevice);
        }
    }));
}
#method_after
protected void updateRngDevice(Guid templateId) {
    if (!getModel().getIsRngEnabled().getIsChangable()) {
        return;
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(templateId), new AsyncQuery<VdcQueryReturnValue>(returnValue -> {
        List<VmRngDevice> devs = returnValue.getReturnValue();
        getModel().getIsRngEnabled().setEntity(!devs.isEmpty());
        final VmRngDevice rngDevice = devs.isEmpty() ? new VmRngDevice() : devs.get(0);
        rngDevice.updateSourceByVersion(getModel().getCompatibilityVersion());
        getModel().setRngDevice(rngDevice);
    }));
}
#end_block

#method_before
protected void updateCompatibilityVersion() {
    DataCenterWithCluster dataCenterWithCluster = getModel().getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return;
    }
    final StoragePool dataCenter = dataCenterWithCluster.getDataCenter();
    if (dataCenter == null) {
        return;
    }
    AsyncDataProvider.getInstance().getDataCenterVersions(new AsyncQuery<>(new AsyncCallback<List<Version>>() {

        @Override
        public void onSuccess(List<Version> versions) {
            versions.add(0, null);
            Version selectedVersion;
            selectedVersion = getModel().getCustomCompatibilityVersion().getSelectedItem();
            if (selectedVersion != null && versions.contains(selectedVersion)) {
                getModel().getCustomCompatibilityVersion().setItems(versions, selectedVersion);
            } else {
                getModel().getCustomCompatibilityVersion().setItems(versions);
            }
        }
    }), dataCenter.getId());
}
#method_after
protected void updateCompatibilityVersion() {
    DataCenterWithCluster dataCenterWithCluster = getModel().getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return;
    }
    final StoragePool dataCenter = dataCenterWithCluster.getDataCenter();
    if (dataCenter == null) {
        return;
    }
    AsyncDataProvider.getInstance().getDataCenterVersions(new AsyncQuery<>(versions -> {
        versions.add(0, null);
        Version selectedVersion;
        selectedVersion = getModel().getCustomCompatibilityVersion().getSelectedItem();
        if (selectedVersion != null && versions.contains(selectedVersion)) {
            getModel().getCustomCompatibilityVersion().setItems(versions, selectedVersion);
        } else {
            getModel().getCustomCompatibilityVersion().setItems(versions);
        }
    }), dataCenter.getId());
}
#end_block

#method_before
private void fetchCpuProfiles(Guid clusterId, final Guid cpuProfileId) {
    if (clusterId == null) {
        return;
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetCpuProfilesByClusterId, new IdQueryParameters(clusterId), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            List<CpuProfile> cpuProfiles = returnValue.getReturnValue();
            getModel().getCpuProfiles().setItems(cpuProfiles);
            if (cpuProfiles != null) {
                for (CpuProfile cpuProfile : cpuProfiles) {
                    if (cpuProfile.getId().equals(cpuProfileId)) {
                        getModel().getCpuProfiles().setSelectedItem(cpuProfile);
                        break;
                    }
                }
            }
        }
    }));
}
#method_after
private void fetchCpuProfiles(Guid clusterId, final Guid cpuProfileId) {
    if (clusterId == null) {
        return;
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetCpuProfilesByClusterId, new IdQueryParameters(clusterId), new AsyncQuery<VdcQueryReturnValue>(returnValue -> {
        List<CpuProfile> cpuProfiles = returnValue.getReturnValue();
        getModel().getCpuProfiles().setItems(cpuProfiles);
        if (cpuProfiles != null) {
            for (CpuProfile cpuProfile : cpuProfiles) {
                if (cpuProfile.getId().equals(cpuProfileId)) {
                    getModel().getCpuProfiles().setSelectedItem(cpuProfile);
                    break;
                }
            }
        }
    }));
}
#end_block

#method_before
protected void updateGraphics(Guid id) {
    Frontend.getInstance().runQuery(VdcQueryType.GetGraphicsDevices, new IdQueryParameters(id), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            List<VmDevice> graphicsVmDevs = returnValue.getReturnValue();
            List<GraphicsType> graphicsTypes = new ArrayList<>();
            for (VmDevice graphicsVmDev : graphicsVmDevs) {
                graphicsTypes.add(GraphicsType.fromString(graphicsVmDev.getDevice()));
            }
            boolean hasSpiceAndVnc = graphicsTypes.size() == 2 && graphicsTypes.containsAll(Arrays.asList(GraphicsType.SPICE, GraphicsType.VNC));
            boolean canBeSelected = getModel().getGraphicsType().getItems().contains(UnitVmModel.GraphicsTypes.SPICE_AND_VNC);
            if (hasSpiceAndVnc && canBeSelected) {
                getModel().getGraphicsType().setSelectedItem(UnitVmModel.GraphicsTypes.SPICE_AND_VNC);
            } else if (graphicsVmDevs.size() == 1) {
                GraphicsType type = GraphicsType.fromString(graphicsVmDevs.get(0).getDevice());
                getModel().getGraphicsType().setSelectedItem(UnitVmModel.GraphicsTypes.fromGraphicsType(type));
            }
        }
    }));
}
#method_after
protected void updateGraphics(Guid id) {
    Frontend.getInstance().runQuery(VdcQueryType.GetGraphicsDevices, new IdQueryParameters(id), new AsyncQuery<VdcQueryReturnValue>(returnValue -> {
        List<VmDevice> graphicsVmDevs = returnValue.getReturnValue();
        List<GraphicsType> graphicsTypes = new ArrayList<>();
        for (VmDevice graphicsVmDev : graphicsVmDevs) {
            graphicsTypes.add(GraphicsType.fromString(graphicsVmDev.getDevice()));
        }
        boolean hasSpiceAndVnc = graphicsTypes.size() == 2 && graphicsTypes.containsAll(Arrays.asList(GraphicsType.SPICE, GraphicsType.VNC));
        boolean canBeSelected = getModel().getGraphicsType().getItems().contains(UnitVmModel.GraphicsTypes.SPICE_AND_VNC);
        if (hasSpiceAndVnc && canBeSelected) {
            getModel().getGraphicsType().setSelectedItem(UnitVmModel.GraphicsTypes.SPICE_AND_VNC);
        } else if (graphicsVmDevs.size() == 1) {
            GraphicsType type = GraphicsType.fromString(graphicsVmDevs.get(0).getDevice());
            getModel().getGraphicsType().setSelectedItem(UnitVmModel.GraphicsTypes.fromGraphicsType(type));
        }
    }));
}
#end_block

#method_before
@Override
public SyntaxContainer analyzeSyntaxState(final String searchText, boolean final2) {
    final SyntaxContainer syntaxContainer = new SyntaxContainer(searchText);
    IConditionFieldAutoCompleter curConditionFieldAC = null;
    IAutoCompleter curConditionRelationAC = null;
    final List<String> freeTextObjSearched = new ArrayList<>();
    char[] searchCharArr = searchText.toCharArray();
    int curStartPos = 0;
    String tryNextObj = "";
    boolean keepValid;
    for (int idx = 0; idx < searchCharArr.length; idx++) {
        final SyntaxObjectType curState = syntaxContainer.getState();
        final char curChar = searchCharArr[idx];
        if (disAllowedChars.contains(curChar)) {
            syntaxContainer.setErr(SyntaxError.INVALID_CHARECTER, curStartPos, idx + 1);
            return syntaxContainer;
        }
        if ((curChar == ' ') && (curState != SyntaxObjectType.CONDITION_RELATION) && (curState != SyntaxObjectType.COLON) && (curState != SyntaxObjectType.CONDITION_VALUE) && (curState != SyntaxObjectType.OR) && (curState != SyntaxObjectType.AND)) {
            curStartPos += 1;
            continue;
        }
        String strRealObj = searchText.substring(curStartPos, idx + 1);
        String nextObject = strRealObj.toUpperCase();
        switch(curState) {
            case BEGIN:
                // we have found a search-object
                if (!searchObjectAC.validate(nextObject)) {
                    if (!searchObjectAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_SEARCH_OBJECT, curStartPos, idx - curStartPos + 1);
                        return syntaxContainer;
                    }
                } else {
                    if (searchCharArr.length >= idx + 2) {
                        // Validate that the next character is an 's'
                        if (pluralAC.validate(searchText.substring(idx + 1, idx + 1 + 1))) {
                            // Then just move things along.
                            idx++;
                            StringBuilder sb = new StringBuilder(nextObject);
                            sb.append('S');
                            nextObject = sb.toString();
                        }
                    }
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.SEARCH_OBJECT, nextObject, curStartPos, idx + 1);
                    syntaxContainer.setvalid(true);
                    curStartPos = idx + 1;
                }
                break;
            case SEARCH_OBJECT:
                if (!colonAC.validate(nextObject)) {
                    if (!colonAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.COLON_NOT_NEXT_TO_SEARCH_OBJECT, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.COLON, nextObject, idx, idx + 1);
                    curStartPos = idx + 1;
                    syntaxContainer.setvalid(true);
                }
                break;
            case CROSS_REF_OBJ:
                String curRefObj = syntaxContainer.getPreviousSyntaxObject(0, SyntaxObjectType.CROSS_REF_OBJ);
                curConditionRelationAC = searchObjectAC.getObjectRelationshipAutoCompleter();
                if (idx + 1 < searchCharArr.length) {
                    tryNextObj = searchText.substring(curStartPos, idx + 2).toUpperCase();
                }
                if (curConditionRelationAC == null) {
                    syntaxContainer.setErr(SyntaxError.CONDITION_CANT_CREATE_RRELATIONS_AC, curStartPos, idx + 1);
                    return syntaxContainer;
                }
                if (dotAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.DOT, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if (!"".equals(tryNextObj) && curConditionRelationAC.validate(tryNextObj)) {
                    // i.e. the relation object has another charecter
                    break;
                } else if (curConditionRelationAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_RELATION, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if (!curConditionRelationAC.validateCompletion(nextObject) && !dotAC.validateCompletion(nextObject)) {
                    syntaxContainer.setErr(SyntaxError.INVALID_POST_CROSS_REF_OBJ, curStartPos, idx + 1);
                    return syntaxContainer;
                }
                tryNextObj = "";
                break;
            case DOT:
                curRefObj = syntaxContainer.getPreviousSyntaxObject(1, SyntaxObjectType.CROSS_REF_OBJ);
                curConditionFieldAC = searchObjectAC.getFieldAutoCompleter(curRefObj);
                if (curConditionFieldAC == null) {
                    syntaxContainer.setErr(SyntaxError.CANT_GET_CONDITION_FIELD_AC, curStartPos, idx);
                    return syntaxContainer;
                }
                if (!curConditionFieldAC.validate(nextObject)) {
                    if (!curConditionFieldAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_CONDITION_FILED, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_FIELD, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                }
                break;
            case AND:
            case OR:
                keepValid = false;
                curConditionFieldAC = searchObjectAC.getFieldAutoCompleter(syntaxContainer.getSearchObjectStr());
                if (curConditionFieldAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_FIELD, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if (searchObjectAC.isCrossReference(nextObject, syntaxContainer.getFirst().getBody())) {
                    if (searchCharArr.length >= idx + 2) {
                        // Validate that the next character is an 's'
                        if (pluralAC.validate(searchText.substring(idx + 1, idx + 1 + 1))) {
                            // Then just move things along.
                            idx++;
                            StringBuilder sb = new StringBuilder(nextObject);
                            sb.append('S');
                            nextObject = sb.toString();
                        }
                    }
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CROSS_REF_OBJ, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else {
                    RefObject<Integer> tempRefObject = new RefObject<>(curStartPos);
                    ValueParseResult ans = handleValuePhrase(final2, searchText, idx, tempRefObject, syntaxContainer);
                    curStartPos = tempRefObject.argvalue;
                    if (ans != ValueParseResult.Err) {
                        if (ans == ValueParseResult.FreeText) {
                            curRefObj = syntaxContainer.getSearchObjectStr();
                            if (freeTextObjSearched.contains(curRefObj)) {
                                syntaxContainer.setErr(SyntaxError.FREE_TEXT_ALLOWED_ONCE_PER_OBJ, curStartPos, idx + 1);
                                return syntaxContainer;
                            }
                            freeTextObjSearched.add(curRefObj);
                            syntaxContainer.setvalid(true);
                            keepValid = true;
                        }
                    } else if (!curConditionFieldAC.validateCompletion(nextObject) && !searchObjectAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_POST_OR_AND_PHRASE, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                }
                if (!keepValid) {
                    syntaxContainer.setvalid(false);
                }
                break;
            case COLON:
                keepValid = false;
                curConditionFieldAC = searchObjectAC.getFieldAutoCompleter(syntaxContainer.getSearchObjectStr());
                if (curConditionFieldAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_FIELD, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if (sortbyAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.SORTBY, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if (pageAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.PAGE, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if (searchObjectAC.isCrossReference(nextObject, syntaxContainer.getFirst().getBody())) {
                    if (searchCharArr.length >= idx + 2) {
                        // Validate that the next character is an 's'
                        if (pluralAC.validate(searchText.substring(idx + 1, idx + 1 + 1))) {
                            // Then just move things along.
                            idx++;
                            StringBuilder sb = new StringBuilder(nextObject);
                            sb.append('S');
                            nextObject = sb.toString();
                        }
                    }
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CROSS_REF_OBJ, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else {
                    RefObject<Integer> tempRefObject2 = new RefObject<>(curStartPos);
                    ValueParseResult ans = handleValuePhrase(final2, searchText, idx, tempRefObject2, syntaxContainer);
                    curStartPos = tempRefObject2.argvalue;
                    if (ans != ValueParseResult.Err) {
                        if (ans == ValueParseResult.FreeText) {
                            freeTextObjSearched.add(syntaxContainer.getSearchObjectStr());
                        }
                        keepValid = true;
                    } else if (!curConditionFieldAC.validateCompletion(nextObject) && !sortbyAC.validateCompletion(nextObject) && !searchObjectAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_POST_COLON_PHRASE, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                }
                if (!keepValid) {
                    syntaxContainer.setvalid(false);
                }
                break;
            case CONDITION_VALUE:
                nextObject = nextObject.trim();
                if (nextObject.length() > 0) {
                    keepValid = false;
                    curRefObj = syntaxContainer.getSearchObjectStr();
                    curConditionFieldAC = searchObjectAC.getFieldAutoCompleter(curRefObj);
                    if (curConditionFieldAC.validate(nextObject)) {
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_FIELD, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (sortbyAC.validate(nextObject)) {
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.SORTBY, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (pageAC.validate(nextObject)) {
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.PAGE, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (searchObjectAC.isCrossReference(nextObject, syntaxContainer.getFirst().getBody())) {
                        if (searchCharArr.length >= idx + 2) {
                            // Validate that the next character is an 's'
                            if (pluralAC.validate(searchText.substring(idx + 1, idx + 1 + 1))) {
                                // Then just move things along.
                                idx++;
                                StringBuilder sb = new StringBuilder(nextObject);
                                sb.append('S');
                                nextObject = sb.toString();
                            }
                        }
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.CROSS_REF_OBJ, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (andAC.validate(nextObject)) {
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.AND, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (orAC.validate(nextObject)) {
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.OR, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (!curConditionFieldAC.validateCompletion(nextObject) && !sortbyAC.validateCompletion(nextObject) && !searchObjectAC.validateCompletion(nextObject) && !andAC.validateCompletion(nextObject) && !orAC.validateCompletion(nextObject)) {
                        RefObject<Integer> tempRefObject3 = new RefObject<>(curStartPos);
                        ValueParseResult ans = handleValuePhrase(final2, searchText, idx, tempRefObject3, syntaxContainer);
                        curStartPos = tempRefObject3.argvalue;
                        if (ans != ValueParseResult.Err) {
                            if (ans == ValueParseResult.FreeText) {
                                if (freeTextObjSearched.contains(curRefObj)) {
                                    syntaxContainer.setErr(SyntaxError.FREE_TEXT_ALLOWED_ONCE_PER_OBJ, curStartPos, idx + 1);
                                    return syntaxContainer;
                                }
                                freeTextObjSearched.add(curRefObj);
                                syntaxContainer.setvalid(true);
                                keepValid = true;
                            }
                        } else {
                            syntaxContainer.setErr(SyntaxError.INVALID_POST_CONDITION_VALUE_PHRASE, curStartPos, idx + 1);
                            return syntaxContainer;
                        }
                    }
                    if (!keepValid) {
                        syntaxContainer.setvalid(false);
                    }
                }
                break;
            case CONDITION_FIELD:
                curRefObj = syntaxContainer.getPreviousSyntaxObject(2, SyntaxObjectType.CROSS_REF_OBJ);
                String curConditionField = syntaxContainer.getPreviousSyntaxObject(0, SyntaxObjectType.CONDITION_FIELD);
                curConditionRelationAC = searchObjectAC.getFieldRelationshipAutoCompleter(curRefObj, curConditionField);
                if (curConditionRelationAC == null) {
                    syntaxContainer.setErr(SyntaxError.CONDITION_CANT_CREATE_RRELATIONS_AC, curStartPos, idx + 1);
                    return syntaxContainer;
                }
                if (idx + 1 < searchCharArr.length) {
                    tryNextObj = searchText.substring(curStartPos, idx + 2).toUpperCase();
                    if (curConditionRelationAC.validate(tryNextObj)) {
                        break;
                    }
                }
                if (!curConditionRelationAC.validate(nextObject)) {
                    if (!curConditionRelationAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_CONDITION_RELATION, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_RELATION, nextObject, curStartPos, idx + 1);
                }
                curStartPos = idx + 1;
                syntaxContainer.setvalid(false);
                tryNextObj = "";
                break;
            case CONDITION_RELATION:
                RefObject<Integer> tempRefObject4 = new RefObject<>(curStartPos);
                ValueParseResult ans = handleValuePhrase(final2, searchText, idx, tempRefObject4, syntaxContainer);
                curStartPos = tempRefObject4.argvalue;
                if (ans == ValueParseResult.Err) {
                    return syntaxContainer;
                }
                if (ans == ValueParseResult.FreeText) {
                    if (syntaxContainer.getPreviousSyntaxObjectType(2) == SyntaxObjectType.CROSS_REF_OBJ) {
                        curRefObj = syntaxContainer.getObjSingularName(syntaxContainer.getPreviousSyntaxObject(2, SyntaxObjectType.CROSS_REF_OBJ));
                        if (freeTextObjSearched.contains(curRefObj)) {
                            syntaxContainer.setErr(SyntaxError.FREE_TEXT_ALLOWED_ONCE_PER_OBJ, curStartPos, idx + 1);
                            return syntaxContainer;
                        }
                        freeTextObjSearched.add(curRefObj);
                    }
                }
                break;
            case SORTBY:
                curConditionFieldAC = searchObjectAC.getFieldAutoCompleter(syntaxContainer.getSearchObjectStr());
                if (!curConditionFieldAC.validate(nextObject)) {
                    if (!curConditionFieldAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_SORT_FIELD, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.SORT_FIELD, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                    syntaxContainer.setvalid(true);
                }
                break;
            case PAGE:
                Integer pageNumber = IntegerCompat.tryParse(nextObject);
                if (pageNumber == null) {
                    syntaxContainer.setErr(SyntaxError.INVALID_CHARECTER, curStartPos, idx + 1);
                    return syntaxContainer;
                } else {
                    final StringBuilder buff = new StringBuilder();
                    int pos = idx;
                    // parsing the whole page number (can be more than one char)
                    while (pos < searchText.length() - 1 && Character.isDigit(nextObject.charAt(0))) {
                        buff.append(nextObject);
                        pos++;
                        strRealObj = searchText.substring(pos, pos + 1);
                        nextObject = strRealObj.toUpperCase();
                    }
                    buff.append(nextObject);
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.PAGE_VALUE, buff.toString(), curStartPos, idx + buff.length());
                    // update index position
                    idx = pos + 1;
                    syntaxContainer.setvalid(true);
                }
                break;
            case SORT_FIELD:
                if (!sortDirectionAC.validate(nextObject)) {
                    if (!sortDirectionAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_SORT_DIRECTION, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.SORT_DIRECTION, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                    syntaxContainer.setvalid(true);
                }
                break;
            case PAGE_VALUE:
                if (curChar != ' ') {
                    syntaxContainer.setErr(SyntaxError.NOTHING_COMES_AFTER_PAGE_VALUE, curStartPos, idx + 1);
                    return syntaxContainer;
                }
                break;
            case SORT_DIRECTION:
                if (!pageAC.validate(nextObject)) {
                    if (!pageAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_PAGE_FEILD, curStartPos, idx);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.PAGE, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                    syntaxContainer.setvalid(true);
                }
                break;
            default:
                syntaxContainer.setErr(SyntaxError.UNIDENTIFIED_STATE, curStartPos, idx);
                return syntaxContainer;
        }
    }
    return syntaxContainer;
}
#method_after
@Override
public SyntaxContainer analyzeSyntaxState(final String searchText, boolean final2) {
    final SyntaxContainer syntaxContainer = new SyntaxContainer(searchText);
    IConditionFieldAutoCompleter curConditionFieldAC = null;
    IAutoCompleter curConditionRelationAC = null;
    final List<String> freeTextObjSearched = new ArrayList<>();
    char[] searchCharArr = searchText.toCharArray();
    int curStartPos = 0;
    String tryNextObj = "";
    boolean keepValid;
    for (int idx = 0; idx < searchCharArr.length; idx++) {
        final SyntaxObjectType curState = syntaxContainer.getState();
        final char curChar = searchCharArr[idx];
        if (DISALLOWED_CHARS.contains(curChar)) {
            syntaxContainer.setErr(SyntaxError.INVALID_CHARECTER, curStartPos, idx + 1);
            return syntaxContainer;
        }
        if ((curChar == ' ') && (curState != SyntaxObjectType.CONDITION_RELATION) && (curState != SyntaxObjectType.COLON) && (curState != SyntaxObjectType.CONDITION_VALUE) && (curState != SyntaxObjectType.OR) && (curState != SyntaxObjectType.AND)) {
            curStartPos += 1;
            continue;
        }
        String strRealObj = searchText.substring(curStartPos, idx + 1);
        String nextObject = strRealObj.toUpperCase();
        switch(curState) {
            case BEGIN:
                // we have found a search-object
                if (!searchObjectAC.validate(nextObject)) {
                    if (!searchObjectAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_SEARCH_OBJECT, curStartPos, idx - curStartPos + 1);
                        return syntaxContainer;
                    }
                } else {
                    if (searchCharArr.length >= idx + 2) {
                        // Validate that the next character is an 's'
                        if (pluralAC.validate(searchText.substring(idx + 1, idx + 1 + 1))) {
                            // Then just move things along.
                            idx++;
                            StringBuilder sb = new StringBuilder(nextObject);
                            sb.append('S');
                            nextObject = sb.toString();
                        }
                    }
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.SEARCH_OBJECT, nextObject, curStartPos, idx + 1);
                    syntaxContainer.setvalid(true);
                    curStartPos = idx + 1;
                }
                break;
            case SEARCH_OBJECT:
                if (!colonAC.validate(nextObject)) {
                    if (!colonAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.COLON_NOT_NEXT_TO_SEARCH_OBJECT, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.COLON, nextObject, idx, idx + 1);
                    curStartPos = idx + 1;
                    syntaxContainer.setvalid(true);
                }
                break;
            case CROSS_REF_OBJ:
                String curRefObj = syntaxContainer.getPreviousSyntaxObject(0, SyntaxObjectType.CROSS_REF_OBJ);
                curConditionRelationAC = searchObjectAC.getObjectRelationshipAutoCompleter();
                if (idx + 1 < searchCharArr.length) {
                    tryNextObj = searchText.substring(curStartPos, idx + 2).toUpperCase();
                }
                if (curConditionRelationAC == null) {
                    syntaxContainer.setErr(SyntaxError.CONDITION_CANT_CREATE_RRELATIONS_AC, curStartPos, idx + 1);
                    return syntaxContainer;
                }
                if (dotAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.DOT, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if (!"".equals(tryNextObj) && curConditionRelationAC.validate(tryNextObj)) {
                    // i.e. the relation object has another charecter
                    break;
                } else if (curConditionRelationAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_RELATION, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if (!curConditionRelationAC.validateCompletion(nextObject) && !dotAC.validateCompletion(nextObject)) {
                    syntaxContainer.setErr(SyntaxError.INVALID_POST_CROSS_REF_OBJ, curStartPos, idx + 1);
                    return syntaxContainer;
                }
                tryNextObj = "";
                break;
            case DOT:
                curRefObj = syntaxContainer.getPreviousSyntaxObject(1, SyntaxObjectType.CROSS_REF_OBJ);
                curConditionFieldAC = searchObjectAC.getFieldAutoCompleter(curRefObj);
                if (curConditionFieldAC == null) {
                    syntaxContainer.setErr(SyntaxError.CANT_GET_CONDITION_FIELD_AC, curStartPos, idx);
                    return syntaxContainer;
                }
                if (!curConditionFieldAC.validate(nextObject)) {
                    if (!curConditionFieldAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_CONDITION_FILED, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_FIELD, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                }
                break;
            case AND:
            case OR:
                keepValid = false;
                curConditionFieldAC = searchObjectAC.getFieldAutoCompleter(syntaxContainer.getSearchObjectStr());
                if (curConditionFieldAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_FIELD, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if (searchObjectAC.isCrossReference(nextObject, syntaxContainer.getFirst().getBody())) {
                    if (searchCharArr.length >= idx + 2) {
                        // Validate that the next character is an 's'
                        if (pluralAC.validate(searchText.substring(idx + 1, idx + 1 + 1))) {
                            // Then just move things along.
                            idx++;
                            StringBuilder sb = new StringBuilder(nextObject);
                            sb.append('S');
                            nextObject = sb.toString();
                        }
                    }
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CROSS_REF_OBJ, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else {
                    RefObject<Integer> tempRefObject = new RefObject<>(curStartPos);
                    ValueParseResult ans = handleValuePhrase(final2, searchText, idx, tempRefObject, syntaxContainer);
                    curStartPos = tempRefObject.argvalue;
                    if (ans != ValueParseResult.Err) {
                        if (ans == ValueParseResult.FreeText) {
                            curRefObj = syntaxContainer.getSearchObjectStr();
                            if (freeTextObjSearched.contains(curRefObj)) {
                                syntaxContainer.setErr(SyntaxError.FREE_TEXT_ALLOWED_ONCE_PER_OBJ, curStartPos, idx + 1);
                                return syntaxContainer;
                            }
                            freeTextObjSearched.add(curRefObj);
                            syntaxContainer.setvalid(true);
                            keepValid = true;
                        }
                    } else if (!curConditionFieldAC.validateCompletion(nextObject) && !searchObjectAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_POST_OR_AND_PHRASE, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                }
                if (!keepValid) {
                    syntaxContainer.setvalid(false);
                }
                break;
            case COLON:
                keepValid = false;
                curConditionFieldAC = searchObjectAC.getFieldAutoCompleter(syntaxContainer.getSearchObjectStr());
                if (curConditionFieldAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_FIELD, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if (sortbyAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.SORTBY, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if (pageAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.PAGE, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if (searchObjectAC.isCrossReference(nextObject, syntaxContainer.getFirst().getBody())) {
                    if (searchCharArr.length >= idx + 2) {
                        // Validate that the next character is an 's'
                        if (pluralAC.validate(searchText.substring(idx + 1, idx + 1 + 1))) {
                            // Then just move things along.
                            idx++;
                            StringBuilder sb = new StringBuilder(nextObject);
                            sb.append('S');
                            nextObject = sb.toString();
                        }
                    }
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CROSS_REF_OBJ, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else {
                    RefObject<Integer> tempRefObject2 = new RefObject<>(curStartPos);
                    ValueParseResult ans = handleValuePhrase(final2, searchText, idx, tempRefObject2, syntaxContainer);
                    curStartPos = tempRefObject2.argvalue;
                    if (ans != ValueParseResult.Err) {
                        if (ans == ValueParseResult.FreeText) {
                            freeTextObjSearched.add(syntaxContainer.getSearchObjectStr());
                        }
                        keepValid = true;
                    } else if (!curConditionFieldAC.validateCompletion(nextObject) && !sortbyAC.validateCompletion(nextObject) && !searchObjectAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_POST_COLON_PHRASE, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                }
                if (!keepValid) {
                    syntaxContainer.setvalid(false);
                }
                break;
            case CONDITION_VALUE:
                nextObject = nextObject.trim();
                if (nextObject.length() > 0) {
                    keepValid = false;
                    curRefObj = syntaxContainer.getSearchObjectStr();
                    curConditionFieldAC = searchObjectAC.getFieldAutoCompleter(curRefObj);
                    if (curConditionFieldAC.validate(nextObject)) {
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_FIELD, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (sortbyAC.validate(nextObject)) {
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.SORTBY, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (pageAC.validate(nextObject)) {
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.PAGE, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (searchObjectAC.isCrossReference(nextObject, syntaxContainer.getFirst().getBody())) {
                        if (searchCharArr.length >= idx + 2) {
                            // Validate that the next character is an 's'
                            if (pluralAC.validate(searchText.substring(idx + 1, idx + 1 + 1))) {
                                // Then just move things along.
                                idx++;
                                StringBuilder sb = new StringBuilder(nextObject);
                                sb.append('S');
                                nextObject = sb.toString();
                            }
                        }
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.CROSS_REF_OBJ, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (andAC.validate(nextObject)) {
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.AND, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (orAC.validate(nextObject)) {
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.OR, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (!curConditionFieldAC.validateCompletion(nextObject) && !sortbyAC.validateCompletion(nextObject) && !searchObjectAC.validateCompletion(nextObject) && !andAC.validateCompletion(nextObject) && !orAC.validateCompletion(nextObject)) {
                        RefObject<Integer> tempRefObject3 = new RefObject<>(curStartPos);
                        ValueParseResult ans = handleValuePhrase(final2, searchText, idx, tempRefObject3, syntaxContainer);
                        curStartPos = tempRefObject3.argvalue;
                        if (ans != ValueParseResult.Err) {
                            if (ans == ValueParseResult.FreeText) {
                                if (freeTextObjSearched.contains(curRefObj)) {
                                    syntaxContainer.setErr(SyntaxError.FREE_TEXT_ALLOWED_ONCE_PER_OBJ, curStartPos, idx + 1);
                                    return syntaxContainer;
                                }
                                freeTextObjSearched.add(curRefObj);
                                syntaxContainer.setvalid(true);
                                keepValid = true;
                            }
                        } else {
                            syntaxContainer.setErr(SyntaxError.INVALID_POST_CONDITION_VALUE_PHRASE, curStartPos, idx + 1);
                            return syntaxContainer;
                        }
                    }
                    if (!keepValid) {
                        syntaxContainer.setvalid(false);
                    }
                }
                break;
            case CONDITION_FIELD:
                curRefObj = syntaxContainer.getPreviousSyntaxObject(2, SyntaxObjectType.CROSS_REF_OBJ);
                String curConditionField = syntaxContainer.getPreviousSyntaxObject(0, SyntaxObjectType.CONDITION_FIELD);
                curConditionRelationAC = searchObjectAC.getFieldRelationshipAutoCompleter(curRefObj, curConditionField);
                if (curConditionRelationAC == null) {
                    syntaxContainer.setErr(SyntaxError.CONDITION_CANT_CREATE_RRELATIONS_AC, curStartPos, idx + 1);
                    return syntaxContainer;
                }
                if (idx + 1 < searchCharArr.length) {
                    tryNextObj = searchText.substring(curStartPos, idx + 2).toUpperCase();
                    if (curConditionRelationAC.validate(tryNextObj)) {
                        break;
                    }
                }
                if (!curConditionRelationAC.validate(nextObject)) {
                    if (!curConditionRelationAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_CONDITION_RELATION, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_RELATION, nextObject, curStartPos, idx + 1);
                }
                curStartPos = idx + 1;
                syntaxContainer.setvalid(false);
                tryNextObj = "";
                break;
            case CONDITION_RELATION:
                RefObject<Integer> tempRefObject4 = new RefObject<>(curStartPos);
                ValueParseResult ans = handleValuePhrase(final2, searchText, idx, tempRefObject4, syntaxContainer);
                curStartPos = tempRefObject4.argvalue;
                if (ans == ValueParseResult.Err) {
                    return syntaxContainer;
                }
                if (ans == ValueParseResult.FreeText) {
                    if (syntaxContainer.getPreviousSyntaxObjectType(2) == SyntaxObjectType.CROSS_REF_OBJ) {
                        curRefObj = syntaxContainer.getObjSingularName(syntaxContainer.getPreviousSyntaxObject(2, SyntaxObjectType.CROSS_REF_OBJ));
                        if (freeTextObjSearched.contains(curRefObj)) {
                            syntaxContainer.setErr(SyntaxError.FREE_TEXT_ALLOWED_ONCE_PER_OBJ, curStartPos, idx + 1);
                            return syntaxContainer;
                        }
                        freeTextObjSearched.add(curRefObj);
                    }
                }
                break;
            case SORTBY:
                curConditionFieldAC = searchObjectAC.getFieldAutoCompleter(syntaxContainer.getSearchObjectStr());
                if (!curConditionFieldAC.validate(nextObject)) {
                    if (!curConditionFieldAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_SORT_FIELD, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.SORT_FIELD, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                    syntaxContainer.setvalid(true);
                }
                break;
            case PAGE:
                Integer pageNumber = IntegerCompat.tryParse(nextObject);
                if (pageNumber == null) {
                    syntaxContainer.setErr(SyntaxError.INVALID_CHARECTER, curStartPos, idx + 1);
                    return syntaxContainer;
                } else {
                    final StringBuilder buff = new StringBuilder();
                    int pos = idx;
                    // parsing the whole page number (can be more than one char)
                    while (pos < searchText.length() - 1 && Character.isDigit(nextObject.charAt(0))) {
                        buff.append(nextObject);
                        pos++;
                        strRealObj = searchText.substring(pos, pos + 1);
                        nextObject = strRealObj.toUpperCase();
                    }
                    buff.append(nextObject);
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.PAGE_VALUE, buff.toString(), curStartPos, idx + buff.length());
                    // update index position
                    idx = pos + 1;
                    syntaxContainer.setvalid(true);
                }
                break;
            case SORT_FIELD:
                if (!sortDirectionAC.validate(nextObject)) {
                    if (!sortDirectionAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_SORT_DIRECTION, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.SORT_DIRECTION, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                    syntaxContainer.setvalid(true);
                }
                break;
            case PAGE_VALUE:
                if (curChar != ' ') {
                    syntaxContainer.setErr(SyntaxError.NOTHING_COMES_AFTER_PAGE_VALUE, curStartPos, idx + 1);
                    return syntaxContainer;
                }
                break;
            case SORT_DIRECTION:
                if (!pageAC.validate(nextObject)) {
                    if (!pageAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_PAGE_FEILD, curStartPos, idx);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.PAGE, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                    syntaxContainer.setvalid(true);
                }
                break;
            default:
                syntaxContainer.setErr(SyntaxError.UNIDENTIFIED_STATE, curStartPos, idx);
                return syntaxContainer;
        }
    }
    return syntaxContainer;
}
#end_block

#method_before
public void init() {
    listenToSetDnsConfigurationCheckboxChanges();
    boolean shouldSetDnsConfiguration = shouldSetDnsConfiguration();
    setDnsConfiguration.setEntity(shouldSetDnsConfiguration);
    List<NameServerModel> nameServerModels = new ArrayList<>();
    if (shouldSetDnsConfiguration) {
        for (NameServer nameServer : getEntity().getNameServers()) {
            nameServerModels.add(new NameServerModel(nameServer));
        }
    }
    nameServerModelListModel.setItems(nameServerModels);
}
#method_after
public void init() {
    boolean shouldSetDnsConfiguration = shouldSetDnsConfiguration();
    this.shouldSetDnsConfiguration.setEntity(shouldSetDnsConfiguration);
    List<NameServerModel> nameServerModels = new ArrayList<>();
    if (shouldSetDnsConfiguration) {
        for (NameServer nameServer : getEntity().getNameServers()) {
            nameServerModels.add(new NameServerModel(nameServer.getAddress()));
        }
    }
    nameServerModelListModel.setItems(nameServerModels);
}
#end_block

#method_before
private void listenToSetDnsConfigurationCheckboxChanges() {
    Event<EventArgs> entityChangedEvent = setDnsConfiguration.getEntityChangedEvent();
    // just to be sure, UI is wilderness, so we should be sure, that there's only one listener.
    entityChangedEvent.clearListeners();
    entityChangedEvent.addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            nameServerModelListModel.setIsChangeable(setDnsConfiguration.getEntity());
        }
    });
}
#method_after
private void listenToSetDnsConfigurationCheckboxChanges() {
    Event<EventArgs> entityChangedEvent = shouldSetDnsConfiguration.getEntityChangedEvent();
    entityChangedEvent.addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            nameServerModelListModel.setIsChangeable(shouldSetDnsConfiguration.getEntity());
        }
    });
}
#end_block

#method_before
public DnsResolverConfiguration flush() {
    Boolean shouldSetDnsConfiguration = this.setDnsConfiguration.getEntity();
    if (!shouldSetDnsConfiguration) {
        return null;
    }
    DnsResolverConfiguration dnsResolverConfiguration = new DnsResolverConfiguration();
    List<NameServer> nameServers = new ArrayList<>();
    dnsResolverConfiguration.setNameServers(nameServers);
    for (NameServerModel nameServerModel : this.nameServerModelListModel.getItems()) {
        nameServers.add(nameServerModel.flush());
    }
    return dnsResolverConfiguration;
}
#method_after
public DnsResolverConfiguration flush() {
    Boolean shouldSetDnsConfiguration = this.shouldSetDnsConfiguration.getEntity();
    if (!shouldSetDnsConfiguration) {
        return null;
    }
    List<NameServer> nameServers = new ArrayList<>();
    for (NameServerModel nameServerModel : this.nameServerModelListModel.getItems()) {
        nameServers.add(new NameServer(nameServerModel.flush()));
    }
    DnsResolverConfiguration result = new DnsResolverConfiguration();
    result.setNameServers(nameServers);
    if (getEntity() != null) {
        result.setId(getEntity().getId());
    }
    return result;
}
#end_block

#method_before
public boolean validate() {
    // TODO MMUCHA: limit number of generated items.
    if (!this.getSetDnsConfiguration().getEntity()) {
        setIsValid(true);
        return true;
    }
    boolean isValid = true;
    for (NameServerModel nameServerModel : this.nameServerModelListModel.getItems()) {
        if (!nameServerModel.validate()) {
            isValid = false;
        }
    }
    setIsValid(isValid);
    return isValid;
}
#method_after
public boolean validate() {
    if (!this.getShouldSetDnsConfiguration().getEntity()) {
        setIsValid(true);
        return true;
    }
    Collection<NameServerModel> items = this.nameServerModelListModel.getItems();
    boolean exceedingNumberOfAddresses = items.size() > BusinessEntitiesDefinitions.MAX_SUPPORTED_DNS_CONFIGURATIONS;
    boolean isValid = !exceedingNumberOfAddresses;
    for (NameServerModel nameServerModel : items) {
        if (!nameServerModel.validate()) {
            isValid = false;
        }
    }
    setIsValid(isValid);
    return isValid;
}
#end_block

#method_before
public void syncWith(InterfacePropertiesAccessor interfacePropertiesAccessor) {
    setIpv4BootProtocol(interfacePropertiesAccessor.getIpv4BootProtocol());
    getIpv4Address().setEntity(interfacePropertiesAccessor.getIpv4Address());
    getIpv4Subnet().setEntity(interfacePropertiesAccessor.getIpv4Netmask());
    getIpv4Gateway().setEntity(interfacePropertiesAccessor.getIpv4Gateway());
    setIpv6BootProtocol(interfacePropertiesAccessor.getIpv6BootProtocol());
    getIpv6Address().setEntity(interfacePropertiesAccessor.getIpv6Address());
    getIpv6Prefix().setEntity(interfacePropertiesAccessor.getIpv6Prefix());
    getIpv6Gateway().setEntity(interfacePropertiesAccessor.getIpv6Gateway());
    getQosModel().init(interfacePropertiesAccessor.getHostNetworkQos());
    getCustomPropertiesModel().deserialize(KeyValueModel.convertProperties(interfacePropertiesAccessor.getCustomProperties()));
}
#method_after
public void syncWith(InterfacePropertiesAccessor interfacePropertiesAccessor) {
    setIpv4BootProtocol(interfacePropertiesAccessor.getIpv4BootProtocol());
    getIpv4Address().setEntity(interfacePropertiesAccessor.getIpv4Address());
    getIpv4Subnet().setEntity(interfacePropertiesAccessor.getIpv4Netmask());
    getIpv4Gateway().setEntity(interfacePropertiesAccessor.getIpv4Gateway());
    setIpv6BootProtocol(interfacePropertiesAccessor.getIpv6BootProtocol());
    getIpv6Address().setEntity(interfacePropertiesAccessor.getIpv6Address());
    getIpv6Prefix().setEntity(interfacePropertiesAccessor.getIpv6Prefix());
    getIpv6Gateway().setEntity(interfacePropertiesAccessor.getIpv6Gateway());
    getQosModel().init(interfacePropertiesAccessor.getHostNetworkQos());
    getCustomPropertiesModel().deserialize(KeyValueModel.convertProperties(interfacePropertiesAccessor.getCustomProperties()));
    getDnsConfigurationModel().setEntity(interfacePropertiesAccessor.getDnsResolverConfiguration());
}
#end_block

#method_before
private void initValues() {
    if (networkAttachment == null) {
        return;
    }
    boolean newAttachment = networkAttachment.getId() == null;
    // If the 'ReportedConfigurations' of the attachment is 'null' it means the attachment wasn't reported from the
    // engine (all the attachments reported from the engine have
    // 'ReportedConfigurations'). So it means this network is for sure in sync, since the ui already modified it and
    // created new instance of the attachment for it (an out-of-sync network cannot be modified).
    boolean attachmentNotReportedByTheEngine = networkAttachment.getReportedConfigurations() == null;
    boolean syncedNetwork = attachmentNotReportedByTheEngine || networkAttachment.getReportedConfigurations().isNetworkInSync();
    boolean syncRequestedByUser = !syncedNetwork && Boolean.TRUE.equals(getIsToSync().getEntity());
    if (newAttachment || syncedNetwork || syncRequestedByUser) {
        syncWith(new InterfacePropertiesAccessor.FromNetworkAttachmentForModel(networkAttachment, networkQos, nic));
    } else {
        syncWith(new InterfacePropertiesAccessor.FromNic(nic));
    }
    // TODO MMUCHA: Dear code reviewer! code above is incomprehensible, no idea what is synced, why, from where and where to... Do I need to modify it there? Please advise.
    if (networkAttachment.getDnsResolverConfiguration() == null) {
        networkAttachment.setDnsResolverConfiguration(new DnsResolverConfiguration());
    }
    this.getDnsConfigurationModel().setEntity(networkAttachment.getDnsResolverConfiguration());
}
#method_after
private void initValues() {
    if (networkAttachment == null) {
        return;
    }
    boolean newAttachment = networkAttachment.getId() == null;
    // If the 'ReportedConfigurations' of the attachment is 'null' it means the attachment wasn't reported from the
    // engine (all the attachments reported from the engine have
    // 'ReportedConfigurations'). So it means this network is for sure in sync, since the ui already modified it and
    // created new instance of the attachment for it (an out-of-sync network cannot be modified).
    boolean attachmentNotReportedByTheEngine = networkAttachment.getReportedConfigurations() == null;
    boolean syncedNetwork = attachmentNotReportedByTheEngine || networkAttachment.getReportedConfigurations().isNetworkInSync();
    boolean syncRequestedByUser = !syncedNetwork && Boolean.TRUE.equals(getIsToSync().getEntity());
    if (newAttachment || syncedNetwork || syncRequestedByUser) {
        syncWith(new InterfacePropertiesAccessor.FromNetworkAttachmentForModel(networkAttachment, networkQos, nic));
    } else {
        syncWith(new InterfacePropertiesAccessor.FromNic(nic, reportedDnsResolverConfiguration));
    }
}
#end_block

#method_before
private void commitVfsConfigChanges(final HostNicVfsConfig hostNicVfsConfig, final VfsConfigModel vfsConfigModel) {
    if (hostNicVfsConfig != null) {
        // Num of vfs
        hostNicVfsConfig.setNumOfVfs(vfsConfigModel.getNumOfVfs().getEntity());
        // Networks
        hostNicVfsConfig.setAllNetworksAllowed(vfsConfigModel.getAllNetworksAllowed().getSelectedItem() == AllNetworksSelector.allNetworkAllowed);
        Set<Guid> networks = new HashSet<>();
        for (VfsConfigNetwork vfsConfigNetwork : vfsConfigModel.getNetworks().getItems()) {
            if (vfsConfigNetwork.isAttached() && vfsConfigNetwork.getLabelViaAttached() == null) {
                networks.add(vfsConfigNetwork.getEntity().getId());
            }
        }
        hostNicVfsConfig.setNetworks(networks);
        // Labels
        hostNicVfsConfig.setNetworkLabels(vfsConfigModel.getLabelsModel().computeSelecetedLabels());
    }
}
#method_after
private void commitVfsConfigChanges(final HostNicVfsConfig hostNicVfsConfig, final VfsConfigModel vfsConfigModel) {
    if (hostNicVfsConfig != null) {
        // Num of vfs
        hostNicVfsConfig.setNumOfVfs(vfsConfigModel.getNumOfVfs().getEntity());
        // Networks
        hostNicVfsConfig.setAllNetworksAllowed(vfsConfigModel.getAllNetworksAllowed().getSelectedItem() == AllNetworksSelector.allNetworkAllowed);
        Set<Guid> networks = new HashSet<>();
        for (VfsConfigNetwork vfsConfigNetwork : vfsConfigModel.getNetworks().getItems()) {
            if (vfsConfigNetwork.isAttached() && vfsConfigNetwork.getLabelViaAttached() == null) {
                networks.add(vfsConfigNetwork.getEntity().getId());
            }
        }
        hostNicVfsConfig.setNetworks(networks);
        // Labels
        hostNicVfsConfig.setNetworkLabels(vfsConfigModel.getLabelsModel().computeSelectedLabels());
    }
}
#end_block

#method_before
public void onEdit(NetworkItemModel<?> item) {
    Model editPopup = null;
    BaseCommandTarget okTarget = null;
    if (item instanceof BondNetworkInterfaceModel) {
        /**
         * **************
         *  Bond Dialog
         * ***************
         */
        boolean doesBondHaveVmNetworkAttached = doesBondHaveVmNetworkAttached((NetworkInterfaceModel) item);
        BondNetworkInterfaceModel bondModel = (BondNetworkInterfaceModel) item;
        final CreateOrUpdateBond createOrUpdateBondParameter = bondModel.getCreateOrUpdateBond();
        editPopup = new SetupNetworksEditBondModel(createOrUpdateBondParameter, doesBondHaveVmNetworkAttached);
        final SetupNetworksBondModel bondDialogModel = (SetupNetworksBondModel) editPopup;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!bondDialogModel.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                setBondOptions(createOrUpdateBondParameter, bondDialogModel);
            }
        };
    } else if (item instanceof NetworkInterfaceModel) {
        /**
         * ****************
         *  VFs Config Dialog
         * *****************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getOriginalIface();
        final HostNicVfsConfig hostNicVfsConfig = nicToVfsConfig.get(entity.getId());
        if (hostNicVfsConfig != null) {
            final VfsConfigModel vfsConfigPopupModel = new VfsConfigModel(hostNicVfsConfig, allNetworks, dcLabels);
            vfsConfigPopupModel.setTitle(ConstantsManager.getInstance().getMessages().editHostNicVfsConfigTitle(entity.getName()));
            editPopup = vfsConfigPopupModel;
            // OK Target
            okTarget = new BaseCommandTarget() {

                @Override
                public void executeCommand(UICommand uiCommand) {
                    if (!vfsConfigPopupModel.validate()) {
                        return;
                    }
                    sourceListModel.setConfirmWindow(null);
                    commitVfsConfigChanges(hostNicVfsConfig, vfsConfigPopupModel);
                }
            };
        }
    } else if (item instanceof LogicalNetworkModel) {
        /**
         * **************
         *  Network Dialog
         * ***************
         */
        final LogicalNetworkModel logicalNetworkModel = (LogicalNetworkModel) item;
        final VdsNetworkInterface nic;
        if (logicalNetworkModel.isInSync()) {
            nic = logicalNetworkModel.hasVlan() ? logicalNetworkModel.getVlanDevice() : logicalNetworkModel.getAttachedToNic().getOriginalIface();
        } else {
            nic = logicalNetworkModel.getVlanDevice() != null ? logicalNetworkModel.getVlanDevice() : logicalNetworkModel.getAttachedToNic().getOriginalIface();
        }
        final NetworkAttachmentModel networkAttachmentModel;
        String version = getEntity().getClusterCompatibilityVersion().getValue();
        final Network network = logicalNetworkModel.getNetwork();
        final String logicalNetworkModelName = network.getName();
        final NetworkAttachment networkAttachment = logicalNetworkModel.getNetworkAttachment();
        HostNetworkQos networkQos = qosById.get(network.getQosId());
        if (logicalNetworkModel.isManagement()) {
            networkAttachmentModel = new ManagementNetworkAttachmentModel(network, nic, networkAttachment, networkQos);
        } else {
            networkAttachmentModel = new NetworkAttachmentModel(network, nic, networkAttachment, networkQos);
            networkAttachmentModel.getIpv4Gateway().setIsAvailable(true);
            networkAttachmentModel.getIpv6Gateway().setIsAvailable(false);
        }
        networkAttachmentModel.getQosOverridden().setIsAvailable(true);
        networkAttachmentModel.getQosModel().setIsAvailable(true);
        KeyValueModel customPropertiesModel = networkAttachmentModel.getCustomPropertiesModel();
        customPropertiesModel.setIsAvailable(true);
        Map<String, String> validProperties = KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.PreDefinedNetworkCustomProperties, version));
        // to backend and frontend (lvernia)
        if (!network.isVmNetwork()) {
            // $NON-NLS-1$
            validProperties.remove("bridge_opts");
        }
        validProperties.putAll(KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.UserDefinedNetworkCustomProperties, version)));
        customPropertiesModel.setKeyValueMap(validProperties);
        customPropertiesModel.deserialize(KeyValueModel.convertProperties(networkAttachment.getProperties()));
        networkAttachmentModel.getIsToSync().setIsChangeable(!logicalNetworkModel.isInSync());
        networkAttachmentModel.getIsToSync().setEntity(shouldSyncNetwork(logicalNetworkModelName));
        networkAttachmentModel.getQosOverridden().setEntity(networkAttachment.isQosOverridden());
        editPopup = networkAttachmentModel;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!networkAttachmentModel.validate()) {
                    return;
                }
                final FromNetworkAttachmentModel interfacePropertiesAccessor = new FromNetworkAttachmentModel(networkAttachmentModel);
                LogicalNetworkModelParametersHelper.populateIpv4Details(interfacePropertiesAccessor, networkAttachment.getIpConfiguration().getIpv4PrimaryAddress());
                LogicalNetworkModelParametersHelper.populateIpv6Details(interfacePropertiesAccessor, networkAttachment.getIpConfiguration().getIpv6PrimaryAddress());
                if (networkAttachmentModel.getQosModel().getIsAvailable()) {
                    if (networkAttachmentModel.getQosOverridden().getEntity()) {
                        HostNetworkQos overriddenQos = new HostNetworkQos();
                        networkAttachmentModel.getQosModel().flush(overriddenQos);
                        AnonymousHostNetworkQos hostNetworkQos = fromHostNetworkQos(overriddenQos);
                        networkAttachment.setHostNetworkQos(hostNetworkQos);
                    } else {
                        networkAttachment.setHostNetworkQos(null);
                    }
                }
                if (networkAttachmentModel.getIsToSync().getEntity()) {
                    hostSetupNetworksParametersData.getNetworksToSync().add(logicalNetworkModelName);
                } else {
                    hostSetupNetworksParametersData.getNetworksToSync().remove(logicalNetworkModelName);
                }
                boolean customPropertiesAvailable = networkAttachmentModel.getCustomPropertiesModel().getIsAvailable();
                Map<String, String> customProperties = customPropertiesAvailable ? KeyValueModel.convertProperties(networkAttachmentModel.getCustomPropertiesModel().serialize()) : null;
                networkAttachment.setProperties(customProperties);
                networkAttachment.setDnsResolverConfiguration(networkAttachmentModel.getDnsConfigurationModel().flush());
                sourceListModel.setConfirmWindow(null);
            }
        };
    }
    // ok command
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("OK", okTarget);
    // cancel command
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (editPopup != null) {
        editPopup.getCommands().add(okCommand);
        editPopup.getCommands().add(cancelCommand);
    }
    sourceListModel.setConfirmWindow(editPopup);
}
#method_after
public void onEdit(NetworkItemModel<?> item) {
    Model editPopup = null;
    BaseCommandTarget okTarget = null;
    if (item instanceof BondNetworkInterfaceModel) {
        /**
         * **************
         *  Bond Dialog
         * ***************
         */
        boolean doesBondHaveVmNetworkAttached = doesBondHaveVmNetworkAttached((NetworkInterfaceModel) item);
        BondNetworkInterfaceModel bondModel = (BondNetworkInterfaceModel) item;
        final CreateOrUpdateBond createOrUpdateBondParameter = bondModel.getCreateOrUpdateBond();
        editPopup = new SetupNetworksEditBondModel(createOrUpdateBondParameter, doesBondHaveVmNetworkAttached);
        final SetupNetworksBondModel bondDialogModel = (SetupNetworksBondModel) editPopup;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!bondDialogModel.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                setBondOptions(createOrUpdateBondParameter, bondDialogModel);
            }
        };
    } else if (item instanceof NetworkInterfaceModel) {
        /**
         * ****************
         *  VFs Config Dialog
         * *****************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getOriginalIface();
        final HostNicVfsConfig hostNicVfsConfig = nicToVfsConfig.get(entity.getId());
        if (hostNicVfsConfig != null) {
            final VfsConfigModel vfsConfigPopupModel = new VfsConfigModel(hostNicVfsConfig, allNetworks, dcLabels);
            vfsConfigPopupModel.setTitle(ConstantsManager.getInstance().getMessages().editHostNicVfsConfigTitle(entity.getName()));
            editPopup = vfsConfigPopupModel;
            // OK Target
            okTarget = new BaseCommandTarget() {

                @Override
                public void executeCommand(UICommand uiCommand) {
                    if (!vfsConfigPopupModel.validate()) {
                        return;
                    }
                    sourceListModel.setConfirmWindow(null);
                    commitVfsConfigChanges(hostNicVfsConfig, vfsConfigPopupModel);
                }
            };
        }
    } else if (item instanceof LogicalNetworkModel) {
        /**
         * **************
         *  Network Dialog
         * ***************
         */
        final LogicalNetworkModel logicalNetworkModel = (LogicalNetworkModel) item;
        final VdsNetworkInterface nic;
        if (logicalNetworkModel.isInSync()) {
            nic = logicalNetworkModel.hasVlan() ? logicalNetworkModel.getVlanDevice() : logicalNetworkModel.getAttachedToNic().getOriginalIface();
        } else {
            nic = logicalNetworkModel.getVlanDevice() != null ? logicalNetworkModel.getVlanDevice() : logicalNetworkModel.getAttachedToNic().getOriginalIface();
        }
        final NetworkAttachmentModel networkAttachmentModel;
        String version = getEntity().getClusterCompatibilityVersion().getValue();
        final Network network = logicalNetworkModel.getNetwork();
        final String logicalNetworkModelName = network.getName();
        final NetworkAttachment networkAttachment = logicalNetworkModel.getNetworkAttachment();
        HostNetworkQos networkQos = qosById.get(network.getQosId());
        DnsResolverConfiguration reportedDnsResolverConfiguration = getEntity().getReportedDnsResolverConfiguration();
        if (logicalNetworkModel.isManagement()) {
            networkAttachmentModel = new ManagementNetworkAttachmentModel(network, nic, networkAttachment, networkQos, reportedDnsResolverConfiguration);
        } else {
            networkAttachmentModel = new NetworkAttachmentModel(network, nic, networkAttachment, networkQos, reportedDnsResolverConfiguration);
            networkAttachmentModel.getIpv4Gateway().setIsAvailable(true);
            networkAttachmentModel.getIpv6Gateway().setIsAvailable(false);
        }
        networkAttachmentModel.getQosOverridden().setIsAvailable(true);
        networkAttachmentModel.getQosModel().setIsAvailable(true);
        KeyValueModel customPropertiesModel = networkAttachmentModel.getCustomPropertiesModel();
        customPropertiesModel.setIsAvailable(true);
        Map<String, String> validProperties = KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.PreDefinedNetworkCustomProperties, version));
        // to backend and frontend (lvernia)
        if (!network.isVmNetwork()) {
            // $NON-NLS-1$
            validProperties.remove("bridge_opts");
        }
        validProperties.putAll(KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.UserDefinedNetworkCustomProperties, version)));
        customPropertiesModel.setKeyValueMap(validProperties);
        customPropertiesModel.deserialize(KeyValueModel.convertProperties(networkAttachment.getProperties()));
        networkAttachmentModel.getIsToSync().setIsChangeable(!logicalNetworkModel.isInSync());
        networkAttachmentModel.getIsToSync().setEntity(shouldSyncNetwork(logicalNetworkModelName));
        networkAttachmentModel.getQosOverridden().setEntity(networkAttachment.isQosOverridden());
        editPopup = networkAttachmentModel;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!networkAttachmentModel.validate()) {
                    return;
                }
                final FromNetworkAttachmentModel interfacePropertiesAccessor = new FromNetworkAttachmentModel(networkAttachmentModel);
                LogicalNetworkModelParametersHelper.populateIpv4Details(interfacePropertiesAccessor, networkAttachment.getIpConfiguration().getIpv4PrimaryAddress());
                LogicalNetworkModelParametersHelper.populateIpv6Details(interfacePropertiesAccessor, networkAttachment.getIpConfiguration().getIpv6PrimaryAddress());
                if (networkAttachmentModel.getQosModel().getIsAvailable()) {
                    if (networkAttachmentModel.getQosOverridden().getEntity()) {
                        HostNetworkQos overriddenQos = new HostNetworkQos();
                        networkAttachmentModel.getQosModel().flush(overriddenQos);
                        AnonymousHostNetworkQos hostNetworkQos = fromHostNetworkQos(overriddenQos);
                        networkAttachment.setHostNetworkQos(hostNetworkQos);
                    } else {
                        networkAttachment.setHostNetworkQos(null);
                    }
                }
                if (networkAttachmentModel.getIsToSync().getEntity()) {
                    hostSetupNetworksParametersData.getNetworksToSync().add(logicalNetworkModelName);
                } else {
                    hostSetupNetworksParametersData.getNetworksToSync().remove(logicalNetworkModelName);
                }
                boolean customPropertiesAvailable = networkAttachmentModel.getCustomPropertiesModel().getIsAvailable();
                Map<String, String> customProperties = customPropertiesAvailable ? KeyValueModel.convertProperties(networkAttachmentModel.getCustomPropertiesModel().serialize()) : null;
                networkAttachment.setProperties(customProperties);
                networkAttachment.setDnsResolverConfiguration(networkAttachmentModel.getDnsConfigurationModel().flush());
                sourceListModel.setConfirmWindow(null);
            }
        };
    }
    // ok command
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("OK", okTarget);
    // cancel command
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (editPopup != null) {
        editPopup.getCommands().add(okCommand);
        editPopup.getCommands().add(cancelCommand);
    }
    sourceListModel.setConfirmWindow(editPopup);
}
#end_block

#method_before
private void queryLabels() {
    AsyncDataProvider.getInstance().getNetworkLabelsByDataCenterId(getEntity().getStoragePoolId(), new AsyncQuery<>(new AsyncCallback<SortedSet<String>>() {

        @Override
        public void onSuccess(SortedSet<String> returnValue) {
            dcLabels = returnValue;
            initLabelModels();
            // chain the networks query
            queryNetworks();
        }
    }));
}
#method_after
private void queryLabels() {
    AsyncDataProvider.getInstance().getNetworkLabelsByDataCenterId(getEntity().getStoragePoolId(), new AsyncQuery<>(returnValue -> {
        dcLabels = returnValue;
        initLabelModels();
        // chain the networks query
        queryNetworks();
    }));
}
#end_block

#method_before
private void queryFreeBonds() {
    // query for all unused, existing bonds on the host
    VDS vds = getEntity();
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsFreeBondsByVdsId, new IdQueryParameters(vds.getId()), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            allBonds = returnValue.getReturnValue();
            initNetworkModels();
            initNicModels();
            stopProgress();
        }
    }));
}
#method_after
private void queryFreeBonds() {
    // query for all unused, existing bonds on the host
    VDS vds = getEntity();
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsFreeBondsByVdsId, new IdQueryParameters(vds.getId()), new AsyncQuery<VdcQueryReturnValue>(returnValue -> {
        allBonds = returnValue.getReturnValue();
        initNetworkModels();
        initNicModels();
        stopProgress();
    }));
}
#end_block

#method_before
private void queryVfMap() {
    VDS vds = getEntity();
    IdQueryParameters params = new IdQueryParameters(vds.getId());
    params.setRefresh(false);
    Frontend.getInstance().runQuery(VdcQueryType.GetVfToPfMapByHostId, params, new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            vfMap = returnValue.getReturnValue();
            if (vfMap == null) {
                vfMap = Collections.emptyMap();
            }
            // chain the free bonds query
            queryFreeBonds();
        }
    }));
}
#method_after
private void queryVfMap() {
    VDS vds = getEntity();
    IdQueryParameters params = new IdQueryParameters(vds.getId());
    params.setRefresh(false);
    Frontend.getInstance().runQuery(VdcQueryType.GetVfToPfMapByHostId, params, new AsyncQuery<VdcQueryReturnValue>(returnValue -> {
        vfMap = returnValue.getReturnValue();
        if (vfMap == null) {
            vfMap = Collections.emptyMap();
        }
        // chain the free bonds query
        queryFreeBonds();
    }));
}
#end_block

#method_before
private void queryInterfaces() {
    VDS vds = getEntity();
    IdQueryParameters params = new IdQueryParameters(vds.getId());
    params.setRefresh(false);
    // query for interfaces
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsInterfacesByVdsId, params, new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            allExistingNics = returnValue.getReturnValue();
            existingVlanDevicesByVlanId = mapVlanDevicesByVlanId();
            initCreateOrUpdateBondParameters();
            initNicLabelsParameters();
            // chain the network attachments query
            queryNetworkAttachments();
        }
    }));
}
#method_after
private void queryInterfaces() {
    VDS vds = getEntity();
    IdQueryParameters params = new IdQueryParameters(vds.getId());
    params.setRefresh(false);
    // query for interfaces
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsInterfacesByVdsId, params, new AsyncQuery<>((VdcQueryReturnValue returnValue) -> {
        allExistingNics = returnValue.getReturnValue();
        existingVlanDevicesByVlanId = mapVlanDevicesByVlanId();
        initCreateOrUpdateBondParameters();
        initNicLabelsParameters();
        // chain the network attachments query
        queryNetworkAttachments();
    }));
}
#end_block

#method_before
private void queryNetworkAttachments() {
    VDS vds = getEntity();
    IdQueryParameters params = new IdQueryParameters(vds.getId());
    params.setRefresh(false);
    // query for network attachments
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworkAttachmentsByHostId, params, new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            hostSetupNetworksParametersData.getNetworkAttachments().addAll((List<NetworkAttachment>) returnValue.getReturnValue());
            initNetworkIdToExistingAttachmentMap();
            // chain the vfsConfig query
            queryVfsConfig();
        }
    }));
}
#method_after
private void queryNetworkAttachments() {
    VDS vds = getEntity();
    IdQueryParameters params = new IdQueryParameters(vds.getId());
    params.setRefresh(false);
    // query for network attachments
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworkAttachmentsByHostId, params, new AsyncQuery<>((VdcQueryReturnValue returnValue) -> {
        hostSetupNetworksParametersData.getNetworkAttachments().addAll((List<NetworkAttachment>) returnValue.getReturnValue());
        initNetworkIdToExistingAttachmentMap();
        // chain the vfsConfig query
        queryVfsConfig();
    }));
}
#end_block

#method_before
private void queryVfsConfig() {
    // query for vfsConfigs
    VDS vds = getEntity();
    IdQueryParameters params = new IdQueryParameters(vds.getId());
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVfsConfigByHostId, params, new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValueObj) {
            Object returnValue = returnValueObj.getReturnValue();
            List<HostNicVfsConfig> allHostVfs = (List<HostNicVfsConfig>) returnValue;
            for (HostNicVfsConfig vfsConfig : allHostVfs) {
                originalVfsConfigs.add(vfsConfig);
                nicToVfsConfig.put(vfsConfig.getNicId(), new HostNicVfsConfig(vfsConfig));
            }
            queryVfMap();
        }
    }));
}
#method_after
private void queryVfsConfig() {
    // query for vfsConfigs
    VDS vds = getEntity();
    IdQueryParameters params = new IdQueryParameters(vds.getId());
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVfsConfigByHostId, params, new AsyncQuery<VdcQueryReturnValue>(returnValueObj -> {
        Object returnValue = returnValueObj.getReturnValue();
        List<HostNicVfsConfig> allHostVfs = (List<HostNicVfsConfig>) returnValue;
        for (HostNicVfsConfig vfsConfig : allHostVfs) {
            originalVfsConfigs.add(vfsConfig);
            nicToVfsConfig.put(vfsConfig.getNicId(), new HostNicVfsConfig(vfsConfig));
        }
        queryVfMap();
    }));
}
#end_block

#method_before
private void queryNetworks() {
    VDS vds = getEntity();
    // query for networks
    AsyncDataProvider.getInstance().getClusterNetworkList(new AsyncQuery<>(new AsyncCallback<List<Network>>() {

        @Override
        public void onSuccess(List<Network> returnValue) {
            allNetworks = returnValue;
            // chain the qoss query
            queryQoss();
        }
    }), vds.getClusterId());
}
#method_after
private void queryNetworks() {
    VDS vds = getEntity();
    // query for networks
    AsyncDataProvider.getInstance().getClusterNetworkList(new AsyncQuery<>(returnValue -> {
        allNetworks = returnValue;
        // chain the qoss query
        queryQoss();
    }), vds.getClusterId());
}
#end_block

#method_before
private void queryQoss() {
    // query for qoss
    AsyncDataProvider.getInstance().getAllHostNetworkQos(getEntity().getStoragePoolId(), new AsyncQuery<>(new AsyncCallback<List<HostNetworkQos>>() {

        @Override
        public void onSuccess(List<HostNetworkQos> qoss) {
            qosById = Entities.businessEntitiesById(qoss);
            // chain the nic query
            queryInterfaces();
        }
    }));
}
#method_after
private void queryQoss() {
    // query for qoss
    AsyncDataProvider.getInstance().getAllHostNetworkQos(getEntity().getStoragePoolId(), new AsyncQuery<>(qoss -> {
        qosById = Entities.businessEntitiesById(qoss);
        // chain the nic query
        queryInterfaces();
    }));
}
#end_block

#method_before
public void onSetupNetworks() {
    // Determines the connectivity timeout in seconds
    AsyncDataProvider.getInstance().getNetworkConnectivityCheckTimeoutInSeconds(new AsyncQuery<>(new AsyncCallback<Integer>() {

        @Override
        public void onSuccess(Integer returnValue) {
            getConnectivityTimeout().setEntity(returnValue);
            postOnSetupNetworks();
        }
    }));
}
#method_after
public void onSetupNetworks() {
    // Determines the connectivity timeout in seconds
    AsyncDataProvider.getInstance().getNetworkConnectivityCheckTimeoutInSeconds(new AsyncQuery<>(returnValue -> {
        getConnectivityTimeout().setEntity(returnValue);
        postOnSetupNetworks();
    }));
}
#end_block

#method_before
public SimpleAction getCloseAction() {
    return new SimpleAction() {

        @Override
        public void execute() {
            sourceListModel.setWindow(null);
            sourceListModel.search();
        }
    };
}
#method_after
public SimpleAction getCloseAction() {
    return () -> {
        sourceListModel.setWindow(null);
        sourceListModel.search();
    };
}
#end_block

#method_before
private void initCreateOrUpdateBondParameters() {
    NetworkCommonUtils.fillBondSlaves(allExistingNics);
    for (VdsNetworkInterface nic : allExistingNics) {
        if (nic.isBond()) {
            getHostSetupNetworksParametersData().getBonds().add(CreateOrUpdateBond.fromBond((Bond) nic));
        }
    }
}
#method_after
private void initCreateOrUpdateBondParameters() {
    NetworkCommonUtils.fillBondSlaves(allExistingNics);
    for (VdsNetworkInterface nic : allExistingNics) {
        if (nic.isBond()) {
            getHostSetupNetworksParametersData().getBonds().add(CreateOrUpdateBond.fromBond((Bond) nic));
        }
    }
    hostSetupNetworksParametersData.setOriginalBondsByName(Entities.entitiesByName(hostSetupNetworksParametersData.getBonds()));
}
#end_block

#method_before
public NameServer flush() {
    return new NameServer(this.nameServerEntity.getEntity());
}
#method_after
public String flush() {
    return getEntity();
}
#end_block

#method_before
public boolean validate() {
    nameServerEntity.validateEntity(new IValidation[] { new Ipv4OrIpv6AddressValidation() });
    setIsValid(nameServerEntity.getIsValid());
    return getIsValid();
}
#method_after
public boolean validate() {
    validateEntity(new IValidation[] { new Ipv4OrIpv6AddressValidation() });
    return getIsValid();
}
#end_block

#method_before
@Override
protected void populateTabMap() {
    getTabNameMapping().put(TabName.IPV4_TAB, this.ipv4Tab);
    getTabNameMapping().put(TabName.IPV6_TAB, this.ipv6Tab);
    getTabNameMapping().put(TabName.QOS_TAB, this.qosTab);
    getTabNameMapping().put(TabName.CUSTOM_PROPERTIES_TAB, this.customPropertiesTab);
    getTabNameMapping().put(TabName.DNS_CONFIGURATION_TAB, this.dnsConfigurationTab);
}
#method_after
@Override
protected void populateTabMap() {
    getTabNameMapping().put(TabName.IPV4_TAB, this.ipv4Tab.getTabListItem());
    getTabNameMapping().put(TabName.IPV6_TAB, this.ipv6Tab.getTabListItem());
    getTabNameMapping().put(TabName.QOS_TAB, this.qosTab.getTabListItem());
    getTabNameMapping().put(TabName.CUSTOM_PROPERTIES_TAB, this.customPropertiesTab.getTabListItem());
    getTabNameMapping().put(TabName.DNS_CONFIGURATION_TAB, this.dnsConfigurationTab.getTabListItem());
}
#end_block

#method_before
@Override
public void edit(final NetworkAttachmentModel object) {
    driver.edit(object);
    qosWidget.edit(object.getQosModel());
    enableDisableByBootProtocol(object);
    object.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            NetworkAttachmentModel model = (NetworkAttachmentModel) sender;
            String propertyName = args.propertyName;
            if ("BootProtocolsAvailable".equals(propertyName)) {
                // $NON-NLS-1$
                enableDisableByBootProtocol(model);
            }
        }
    });
    if (object.getIsToSync().getIsChangable()) {
        isToSyncInfo.setVisible(true);
    }
    customPropertiesTab.setVisible(object.getCustomPropertiesModel().getIsAvailable());
    customPropertiesWidget.edit(object.getCustomPropertiesModel());
    customPropertiesLabel.setEnabled(object.getCustomPropertiesModel().getIsChangable());
    dnsConfigurationTab.setVisible(true);
    dnsConfigurationWidget.edit(object.getDnsConfigurationModel());
}
#method_after
@Override
public void edit(final NetworkAttachmentModel object) {
    driver.edit(object);
    qosWidget.edit(object.getQosModel());
    enableDisableByBootProtocol(object);
    object.getPropertyChangedEvent().addListener((ev, sender, args) -> {
        NetworkAttachmentModel model = (NetworkAttachmentModel) sender;
        String propertyName = args.propertyName;
        if ("BootProtocolsAvailable".equals(propertyName)) {
            // $NON-NLS-1$
            enableDisableByBootProtocol(model);
        }
    });
    if (object.getIsToSync().getIsChangable()) {
        isToSyncInfo.setVisible(true);
    }
    customPropertiesTab.setVisible(object.getCustomPropertiesModel().getIsAvailable());
    customPropertiesWidget.edit(object.getCustomPropertiesModel());
    customPropertiesLabel.setEnabled(object.getCustomPropertiesModel().getIsChangable());
    dnsServersWidget.edit(object.getDnsConfigurationModel().getNameServerModelListModel());
}
#end_block

#method_before
@Override
public NetworkAttachmentModel flush() {
    qosWidget.flush();
    return driver.flush();
}
#method_after
@Override
public NetworkAttachmentModel flush() {
    qosWidget.flush();
    dnsServersWidget.flush();
    return driver.flush();
}
#end_block

#method_before
private VnicProfileModel createDefaultProfile() {
    final VnicProfileModel defaultProfile = new NewVnicProfileModel();
    // make sure default profile's name is in sync with network's name
    defaultProfile.getName().setEntity(getName().getEntity());
    final IEventListener<EventArgs> networkNameListener = new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            defaultProfile.getName().setEntity(getName().getEntity());
        }
    };
    getName().getEntityChangedEvent().addListener(networkNameListener);
    // if user overrides default name, stop tracking network's name
    defaultProfile.getName().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (!defaultProfile.getName().getEntity().equals(getName().getEntity())) {
                getName().getEntityChangedEvent().removeListener(networkNameListener);
                defaultProfile.getName().getEntityChangedEvent().removeListener(this);
            }
        }
    });
    return defaultProfile;
}
#method_after
private VnicProfileModel createDefaultProfile() {
    final VnicProfileModel defaultProfile = new NewVnicProfileModel();
    // make sure default profile's name is in sync with network's name
    defaultProfile.getName().setEntity(getName().getEntity());
    final IEventListener<EventArgs> networkNameListener = (ev, sender, args) -> defaultProfile.getName().setEntity(getName().getEntity());
    getName().getEntityChangedEvent().addListener(networkNameListener);
    // if user overrides default name, stop tracking network's name
    defaultProfile.getName().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (!defaultProfile.getName().getEntity().equals(getName().getEntity())) {
                getName().getEntityChangedEvent().removeListener(networkNameListener);
                defaultProfile.getName().getEntityChangedEvent().removeListener(this);
            }
        }
    });
    return defaultProfile;
}
#end_block

#method_before
private void initExternalProviderList() {
    AsyncQuery getProvidersQuery = new AsyncQuery<>(new AsyncCallback<List<Provider<?>>>() {

        @Override
        public void onSuccess(List<Provider<?>> result) {
            List<Provider> providers = getNonReadOnlyExternalNetworkProviders(result);
            getExternalProviders().setItems(providers);
            selectExternalProvider();
        }
    });
    AsyncDataProvider.getInstance().getAllNetworkProviders(getProvidersQuery);
}
#method_after
private void initExternalProviderList() {
    AsyncQuery<List<Provider<?>>> getProvidersQuery = new AsyncQuery<>(result -> {
        List<Provider<?>> providers = getNonReadOnlyExternalNetworkProviders(result);
        getExternalProviders().setItems(providers);
        selectExternalProvider();
    });
    AsyncDataProvider.getInstance().getAllNetworkProviders(getProvidersQuery);
}
#end_block

#method_before
private List<Provider> getNonReadOnlyExternalNetworkProviders(List<Provider<?>> result) {
    List<Provider> providers = new LinkedList<>();
    for (Provider provider : result) {
        if (isExternalNetworkProviderReadOnly(provider)) {
            continue;
        }
        providers.add(provider);
    }
    return providers;
}
#method_after
private List<Provider<?>> getNonReadOnlyExternalNetworkProviders(List<Provider<?>> result) {
    List<Provider<?>> providers = new LinkedList<>();
    for (Provider<?> provider : result) {
        if (isExternalNetworkProviderReadOnly(provider)) {
            continue;
        }
        providers.add(provider);
    }
    return providers;
}
#end_block

#method_before
private boolean isExternalNetworkProviderReadOnly(Provider provider) {
    OpenstackNetworkProviderProperties properties = (OpenstackNetworkProviderProperties) provider.getAdditionalProperties();
    if (properties.getReadOnly()) {
        return true;
    }
    return false;
}
#method_after
private boolean isExternalNetworkProviderReadOnly(Provider<?> provider) {
    OpenstackNetworkProviderProperties properties = (OpenstackNetworkProviderProperties) provider.getAdditionalProperties();
    if (properties.getReadOnly()) {
        return true;
    }
    return false;
}
#end_block

#method_before
public ListModel<Provider> getExternalProviders() {
    return externalProviders;
}
#method_after
public ListModel<Provider<?>> getExternalProviders() {
    return externalProviders;
}
#end_block

#method_before
public void setExternalProviders(ListModel<Provider> externalProviders) {
    this.externalProviders = externalProviders;
}
#method_after
public void setExternalProviders(ListModel<Provider<?>> externalProviders) {
    this.externalProviders = externalProviders;
}
#end_block

#method_before
public void syncWithBackend() {
    final StoragePool dc = getSelectedDc();
    if (dc == null) {
        return;
    }
    setSupportBridgesReportByVDSM();
    setMTUOverrideSupported();
    AsyncDataProvider.getInstance().getAllHostNetworkQos(dc.getId(), new AsyncQuery<>(new AsyncCallback<List<HostNetworkQos>>() {

        @Override
        public void onSuccess(List<HostNetworkQos> qos) {
            getQos().setItems(qos);
            getQos().setSelectedItem(Linq.findHostNetworkQosById(qos, getNetwork().getQosId()));
        }
    }));
    updateDcLabels();
    onExportChanged();
    getProfiles().updateDcId(dc.getId());
}
#method_after
public void syncWithBackend() {
    final StoragePool dc = getSelectedDc();
    if (dc == null) {
        return;
    }
    setSupportBridgesReportByVDSM();
    setMTUOverrideSupported();
    AsyncDataProvider.getInstance().getAllHostNetworkQos(dc.getId(), new AsyncQuery<>(qos -> {
        getQos().setItems(qos);
        getQos().setSelectedItem(qos.stream().filter(new Linq.IdPredicate<>(getNetwork().getQosId())).findFirst().orElse(EMPTY_HOST_NETWORK_QOS));
    }));
    updateDcLabels();
    onExportChanged();
    getProfiles().updateDcId(dc.getId());
}
#end_block

#method_before
private void updateDcLabels() {
    AsyncDataProvider.getInstance().getNetworkLabelsByDataCenterId(getSelectedDc().getId(), new AsyncQuery<>(new AsyncCallback<SortedSet<String>>() {

        @Override
        public void onSuccess(SortedSet<String> returnValue) {
            String label = getNetworkLabel().getSelectedItem();
            getNetworkLabel().setItems(returnValue);
            getNetworkLabel().setSelectedItem(label);
            onExportChanged();
        }
    }));
}
#method_after
private void updateDcLabels() {
    AsyncDataProvider.getInstance().getNetworkLabelsByDataCenterId(getSelectedDc().getId(), new AsyncQuery<>(returnValue -> {
        String label = getNetworkLabel().getSelectedItem();
        getNetworkLabel().setItems(returnValue);
        getNetworkLabel().setSelectedItem(label);
        onExportChanged();
    }));
}
#end_block

#method_before
protected void localize() {
    generalTab.setLabel(constants.generalTabNetworkPopup());
    clusterTab.setLabel(constants.clusterTabNetworkPopup());
    profilesTab.setLabel(constants.profilesTabNetworkPopup());
    subnetTab.setLabel(constants.subnetTabNetworkPopup());
    dataCenterEditor.setLabel(constants.networkPopupDataCenterLabel());
    assignLabel.setText(constants.networkPopupAssignLabel());
    nameEditor.setLabel(constants.nameLabel());
    descriptionEditor.setLabel(constants.descriptionLabel());
    exportLabel.setText(constants.exportLabel());
    exportEditor.setLabel(constants.exportCheckboxLabel());
    externalProviderEditor.setLabel(constants.externalProviderLabel());
    neutronPhysicalNetwork.setLabel(constants.neutronPhysicalNetwork());
    networkLabel.setLabel(constants.networkLabel());
    commentEditor.setLabel(constants.commentLabel());
    isVmNetworkEditor.setLabel(constants.vmNetworkLabel());
    vlanTagging.setLabel(constants.enableVlanTagLabel());
    qosEditor.setLabel(constants.hostNetworkQos());
    createSubnetEditor.setLabel(constants.createSubnetLabel());
    profilesLabel.setText(constants.profilesLabel());
    shouldSetDnsConfigurationEditor.setLabel(constants.setDnsConfigurationLabel());
}
#method_after
protected void localize() {
    generalTab.setLabel(constants.generalTabNetworkPopup());
    clusterTab.setLabel(constants.clusterTabNetworkPopup());
    profilesTab.setLabel(constants.profilesTabNetworkPopup());
    subnetTab.setLabel(constants.subnetTabNetworkPopup());
    dataCenterEditor.setLabel(constants.networkPopupDataCenterLabel());
    assignLabel.setText(constants.networkPopupAssignLabel());
    nameEditor.setLabel(constants.nameLabel());
    descriptionEditor.setLabel(constants.descriptionLabel());
    exportLabel.setText(constants.exportLabel());
    exportEditor.setLabel(constants.exportCheckboxLabel());
    externalProviderEditor.setLabel(constants.externalProviderLabel());
    neutronPhysicalNetwork.setLabel(constants.neutronPhysicalNetwork());
    networkLabel.setLabel(constants.networkLabel());
    commentEditor.setLabel(constants.commentLabel());
    isVmNetworkEditor.setLabel(constants.vmNetworkLabel());
    vlanTagging.setLabel(constants.enableVlanTagLabel());
    qosEditor.setLabel(constants.hostNetworkQos());
    createSubnetEditor.setLabel(constants.createSubnetLabel());
    profilesLabel.setText(constants.profilesLabel());
    shouldSetDnsConfigurationEditor.setLabel(constants.shouldSetDnsConfigurationLabel());
}
#end_block

#method_before
void initEntityModelCellTable() {
    AbstractCheckboxHeader assignAllHeader = new AbstractCheckboxHeader() {

        @Override
        protected void selectionChanged(Boolean value) {
            for (NetworkClusterModel networkClusterModel : getClustersTableItems()) {
                if (networkClusterModel.getIsChangable()) {
                    networkClusterModel.setAttached(value);
                }
            }
            refreshClustersTable();
        }

        @Override
        public Boolean getValue() {
            for (NetworkClusterModel networkClusterModel : getClustersTableItems()) {
                if (networkClusterModel.getIsChangable() && !networkClusterModel.isAttached()) {
                    return false;
                }
            }
            return true;
        }

        @Override
        public boolean isEnabled() {
            for (NetworkClusterModel networkClusterModel : getClustersTableItems()) {
                if (networkClusterModel.getIsChangable()) {
                    return true;
                }
            }
            return false;
        }

        @Override
        public String getLabel() {
            return constants.attachAll();
        }
    };
    AbstractCheckboxHeader requiredAllHeader = new AbstractCheckboxHeader() {

        @Override
        protected void selectionChanged(Boolean value) {
            for (NetworkClusterModel networkClusterModel : getClustersTableItems()) {
                networkClusterModel.setRequired(value);
            }
            refreshClustersTable();
        }

        @Override
        public Boolean getValue() {
            for (NetworkClusterModel networkClusterModel : getClustersTableItems()) {
                if (!networkClusterModel.isRequired()) {
                    return false;
                }
            }
            return true;
        }

        @Override
        public boolean isEnabled() {
            return isRequiredChangeable();
        }

        @Override
        public String getLabel() {
            return constants.requiredAll();
        }
    };
    clustersTable.addColumn(new AbstractTextColumn<NetworkClusterModel>() {

        @Override
        public String getValue(NetworkClusterModel model) {
            return model.getName();
        }
    }, constants.nameClusterHeader());
    clustersTable.addColumn(new AbstractCheckboxColumn<NetworkClusterModel>(new FieldUpdater<NetworkClusterModel, Boolean>() {

        @Override
        public void update(int index, NetworkClusterModel model, Boolean value) {
            model.setAttached(value);
            refreshClustersTable();
        }
    }) {

        @Override
        public Boolean getValue(NetworkClusterModel model) {
            return model.isAttached();
        }

        @Override
        protected boolean canEdit(NetworkClusterModel model) {
            return model.getIsChangable();
        }

        @Override
        public void render(Context context, NetworkClusterModel object, SafeHtmlBuilder sb) {
            super.render(context, object, sb);
            sb.append(templates.textForCheckBox(constants.attach()));
        }
    }, assignAllHeader, // $NON-NLS-1$
    "80px");
    clustersTable.addColumn(new AbstractCheckboxColumn<NetworkClusterModel>(new FieldUpdater<NetworkClusterModel, Boolean>() {

        @Override
        public void update(int index, NetworkClusterModel model, Boolean value) {
            model.setRequired(value);
            refreshClustersTable();
        }
    }) {

        @Override
        public Boolean getValue(NetworkClusterModel model) {
            return model.isRequired();
        }

        @Override
        protected boolean canEdit(NetworkClusterModel model) {
            return isRequiredChangeable();
        }

        @Override
        public void render(Context context, NetworkClusterModel object, SafeHtmlBuilder sb) {
            super.render(context, object, sb);
            sb.append(templates.textForCheckBox(constants.required()));
        }
    }, requiredAllHeader, // $NON-NLS-1$
    "80px");
}
#method_after
void initEntityModelCellTable() {
    AbstractCheckboxHeader assignAllHeader = new AbstractCheckboxHeader() {

        @Override
        protected void selectionChanged(Boolean value) {
            for (NetworkClusterModel networkClusterModel : getClustersTableItems()) {
                if (networkClusterModel.getIsChangable()) {
                    networkClusterModel.setAttached(value);
                }
            }
            refreshClustersTable();
        }

        @Override
        public Boolean getValue() {
            for (NetworkClusterModel networkClusterModel : getClustersTableItems()) {
                if (networkClusterModel.getIsChangable() && !networkClusterModel.isAttached()) {
                    return false;
                }
            }
            return true;
        }

        @Override
        public boolean isEnabled() {
            for (NetworkClusterModel networkClusterModel : getClustersTableItems()) {
                if (networkClusterModel.getIsChangable()) {
                    return true;
                }
            }
            return false;
        }

        @Override
        public String getLabel() {
            return constants.attachAll();
        }
    };
    AbstractCheckboxHeader requiredAllHeader = new AbstractCheckboxHeader() {

        @Override
        protected void selectionChanged(Boolean value) {
            for (NetworkClusterModel networkClusterModel : getClustersTableItems()) {
                networkClusterModel.setRequired(value);
            }
            refreshClustersTable();
        }

        @Override
        public Boolean getValue() {
            for (NetworkClusterModel networkClusterModel : getClustersTableItems()) {
                if (!networkClusterModel.isRequired()) {
                    return false;
                }
            }
            return true;
        }

        @Override
        public boolean isEnabled() {
            return isRequiredChangeable();
        }

        @Override
        public String getLabel() {
            return constants.requiredAll();
        }
    };
    clustersTable.addColumn(new AbstractTextColumn<NetworkClusterModel>() {

        @Override
        public String getValue(NetworkClusterModel model) {
            return model.getName();
        }
    }, constants.nameClusterHeader());
    clustersTable.addColumn(new AbstractCheckboxColumn<NetworkClusterModel>((index, model, value) -> {
        model.setAttached(value);
        refreshClustersTable();
    }) {

        @Override
        public Boolean getValue(NetworkClusterModel model) {
            return model.isAttached();
        }

        @Override
        protected boolean canEdit(NetworkClusterModel model) {
            return model.getIsChangable();
        }

        @Override
        public void render(Context context, NetworkClusterModel object, SafeHtmlBuilder sb) {
            super.render(context, object, sb);
            sb.append(templates.textForCheckBox(constants.attach()));
        }
    }, assignAllHeader, // $NON-NLS-1$
    "80px");
    clustersTable.addColumn(new AbstractCheckboxColumn<NetworkClusterModel>((index, model, value) -> {
        model.setRequired(value);
        refreshClustersTable();
    }) {

        @Override
        public Boolean getValue(NetworkClusterModel model) {
            return model.isRequired();
        }

        @Override
        protected boolean canEdit(NetworkClusterModel model) {
            return isRequiredChangeable();
        }

        @Override
        public void render(Context context, NetworkClusterModel object, SafeHtmlBuilder sb) {
            super.render(context, object, sb);
            sb.append(templates.textForCheckBox(constants.required()));
        }
    }, requiredAllHeader, // $NON-NLS-1$
    "80px");
}
#end_block

#method_before
@Override
public void edit(T model) {
    profilesEditor.edit(model.getProfiles());
    subnetWidget.edit(model.getSubnetModel());
    // this.shouldSetDnsConfigurationEditor
    nameServerWidget.edit(model.getDnsConfigurationModel().getNameServerModelListModel());
}
#method_after
@Override
public void edit(T model) {
    profilesEditor.edit(model.getProfiles());
    subnetWidget.edit(model.getSubnetModel());
    dnsServersWidget.edit(model.getDnsConfigurationModel().getNameServerModelListModel());
}
#end_block

#method_before
@Override
public T flush() {
    profilesEditor.flush();
    subnetWidget.flush();
    nameServerWidget.flush();
    return null;
}
#method_after
@Override
public T flush() {
    profilesEditor.flush();
    subnetWidget.flush();
    dnsServersWidget.flush();
    return null;
}
#end_block

#method_before
@Override
protected void populateTabMap() {
    getTabNameMapping().put(TabName.GENERAL_TAB, this.generalTab);
    getTabNameMapping().put(TabName.CLUSTERS_TAB, this.clusterTab);
    getTabNameMapping().put(TabName.PROFILES_TAB, this.profilesTab);
    getTabNameMapping().put(TabName.SUBNET_TAB, this.subnetTab);
}
#method_after
@Override
protected void populateTabMap() {
    getTabNameMapping().put(TabName.GENERAL_TAB, this.generalTab.getTabListItem());
    getTabNameMapping().put(TabName.CLUSTERS_TAB, this.clusterTab.getTabListItem());
    getTabNameMapping().put(TabName.PROFILES_TAB, this.profilesTab.getTabListItem());
    getTabNameMapping().put(TabName.SUBNET_TAB, this.subnetTab.getTabListItem());
}
#end_block

#method_before
@Before
public void setUpBefore() throws Exception {
    qosA = createAndMockQos(30, 30, 30);
    qosB = createAndMockQos(60, 60, 60);
    unlimitedHostNetworkQos = createQos(null, null, null);
    vds = new VDS();
    vds.setId(VDS_ID);
    vds.setClusterId(CLUSTER_ID);
    cluster = new Cluster();
    cluster.setId(CLUSTER_ID);
    when(vdsDaoMock.get(eq(VDS_ID))).thenReturn(vds);
    when(clusterDaoMock.get(eq(CLUSTER_ID))).thenReturn(cluster);
    EffectiveHostNetworkQos effectiveHostNetworkQos = new EffectiveHostNetworkQos(hostNetworkQosDaoMock);
    networkImplementationDetailsUtils = new NetworkImplementationDetailsUtils(effectiveHostNetworkQos, networkAttachmentDaoMock, vdsDaoMock, clusterDaoMock, calculateBaseNic, this.managementNetworkUtil);
}
#method_after
@Before
public void setUpBefore() throws Exception {
    qosA = createAndMockQos(30, 30, 30);
    qosB = createAndMockQos(60, 60, 60);
    unlimitedHostNetworkQos = createQos(null, null, null);
    VdsStatic vdsStatic = new VdsStatic();
    vdsStatic.setId(VDS_ID);
    vdsStatic.setClusterId(CLUSTER_ID);
    VdsDynamic vdsDynamic = new VdsDynamic();
    cluster = new Cluster();
    cluster.setCompatibilityVersion(Version.v4_1);
    cluster.setId(CLUSTER_ID);
    when(vdsStaticDaoMock.get(eq(VDS_ID))).thenReturn(vdsStatic);
    when(vdsDynamicDaoMock.get(eq(VDS_ID))).thenReturn(vdsDynamic);
    when(clusterDaoMock.get(eq(CLUSTER_ID))).thenReturn(cluster);
    EffectiveHostNetworkQos effectiveHostNetworkQos = new EffectiveHostNetworkQos(hostNetworkQosDaoMock);
    networkImplementationDetailsUtils = new NetworkImplementationDetailsUtils(effectiveHostNetworkQos, networkAttachmentDaoMock, vdsStaticDaoMock, vdsDynamicDaoMock, clusterDaoMock, calculateBaseNic, this.defaultRouteUtil);
}
#end_block

#method_before
private NetworkInSyncWithVdsNetworkInterface build(NetworkAttachment networkAttachment, VdsNetworkInterface vdsNetworkInterface, Network network) {
    Guid vdsId = vdsNetworkInterface.getVdsId();
    VDS vds = vdsDao.get(vdsId);
    Guid clusterId = vds.getClusterId();
    Cluster cluster = clusterDao.get(clusterId);
    HostNetworkQos hostNetworkQos = effectiveHostNetworkQos.getQos(networkAttachment, network);
    return new NetworkInSyncWithVdsNetworkInterface(vdsNetworkInterface, network, this.managementNetworkUtil.isManagementNetwork(network.getId(), cluster.getId()), hostNetworkQos, networkAttachment, vds, cluster);
}
#method_after
private NetworkInSyncWithVdsNetworkInterface build(NetworkAttachment networkAttachment, VdsNetworkInterface vdsNetworkInterface, Network network) {
    Guid vdsId = vdsNetworkInterface.getVdsId();
    Cluster cluster = getCluster(vdsId);
    HostNetworkQos hostNetworkQos = effectiveHostNetworkQos.getQos(networkAttachment, network);
    return new NetworkInSyncWithVdsNetworkInterface(vdsNetworkInterface, network, hostNetworkQos, networkAttachment, vdsDynamicDao.get(vdsId).getReportedDnsResolverConfiguration(), cluster, defaultRouteUtil.isDefaultRouteNetwork(network.getId(), cluster.getId()));
}
#end_block

#method_before
@Before
public void setUp() {
    hostId = Guid.newGuid();
    clusterId = Guid.newGuid();
    vds = new VDS();
    vds.setId(hostId);
    vds.setClusterId(clusterId);
    baseNic = createNic("eth0");
    vlanNic = createNic("eth0.1");
    vlanNic.setBaseInterface(baseNic.getName());
    baseNicNetwork = createNetwork("baseNicNetwork");
    vlanNetwork = createNetwork("vlanNicNetwork");
    vlanNetwork.setVlanId(1);
    baseNicNetworkQos = new HostNetworkQos();
    baseNicNetworkQos.setId(baseNicNetwork.getQosId());
    vlanNetworkQos = new HostNetworkQos();
    vlanNetworkQos.setId(vlanNetwork.getQosId());
    when(vdsDao.get(hostId)).thenReturn(vds);
    when(hostNetworkQosDao.get(eq(baseNicNetwork.getQosId()))).thenReturn(baseNicNetworkQos);
    when(hostNetworkQosDao.get(eq(vlanNetwork.getQosId()))).thenReturn(vlanNetworkQos);
    cluster = new Cluster();
    when(clusterDao.get(any())).thenReturn(cluster);
}
#method_after
@Before
public void setUp() {
    hostId = Guid.newGuid();
    clusterId = Guid.newGuid();
    VdsStatic vdsStatic = new VdsStatic();
    vdsStatic.setId(hostId);
    vdsStatic.setClusterId(clusterId);
    reportedDnsResolverConfiguration = new DnsResolverConfiguration();
    VdsDynamic vdsDynamic = new VdsDynamic();
    vdsDynamic.setId(hostId);
    vdsDynamic.setReportedDnsResolverConfiguration(reportedDnsResolverConfiguration);
    baseNic = createNic("eth0");
    vlanNic = createNic("eth0.1");
    vlanNic.setBaseInterface(baseNic.getName());
    baseNicNetwork = createNetwork("baseNicNetwork");
    vlanNetwork = createNetwork("vlanNicNetwork");
    vlanNetwork.setVlanId(1);
    baseNicNetworkQos = new HostNetworkQos();
    baseNicNetworkQos.setId(baseNicNetwork.getQosId());
    vlanNetworkQos = new HostNetworkQos();
    vlanNetworkQos.setId(vlanNetwork.getQosId());
    when(vdsStaticDao.get(hostId)).thenReturn(vdsStatic);
    when(vdsDynamicDao.get(hostId)).thenReturn(vdsDynamic);
    cluster = new Cluster();
    cluster.setCompatibilityVersion(Version.v4_1);
    when(clusterDao.get(any())).thenReturn(cluster);
}
#end_block

#method_before
@Test
public void testFillReportedConfigurationOnBaseNic() throws Exception {
    baseNic.setNetworkName(baseNicNetwork.getName());
    when(interfaceDao.getAllInterfacesForVds(eq(hostId))).thenReturn(Arrays.asList(baseNic, vlanNic));
    when(networkDao.getAllForCluster(eq(clusterId))).thenReturn(Collections.singletonList(baseNicNetwork));
    NetworkAttachment networkAttachment = new NetworkAttachment();
    networkAttachment.setNicId(baseNic.getId());
    networkAttachment.setNicName(baseNic.getName());
    networkAttachment.setNetworkId(baseNicNetwork.getId());
    when(effectiveHostNetworkQos.getQos(networkAttachment, baseNicNetwork)).thenReturn(baseNicNetworkQos);
    filler.fillReportedConfiguration(networkAttachment, hostId);
    verify(filler).createNetworkInSyncWithVdsNetworkInterface(networkAttachment, baseNic, baseNicNetwork, vds, cluster);
}
#method_after
@Test
public void testFillReportedConfigurationOnBaseNic() throws Exception {
    baseNic.setNetworkName(baseNicNetwork.getName());
    when(interfaceDao.getAllInterfacesForVds(eq(hostId))).thenReturn(Arrays.asList(baseNic, vlanNic));
    when(networkDao.getAllForCluster(eq(clusterId))).thenReturn(Collections.singletonList(baseNicNetwork));
    NetworkAttachment networkAttachment = new NetworkAttachment();
    networkAttachment.setNicId(baseNic.getId());
    networkAttachment.setNicName(baseNic.getName());
    networkAttachment.setNetworkId(baseNicNetwork.getId());
    when(effectiveHostNetworkQos.getQos(networkAttachment, baseNicNetwork)).thenReturn(baseNicNetworkQos);
    filler.fillReportedConfiguration(networkAttachment, hostId);
    verify(filler).createNetworkInSyncWithVdsNetworkInterface(networkAttachment, baseNic, baseNicNetwork, reportedDnsResolverConfiguration, cluster);
}
#end_block

#method_before
@Test
public void testFillReportedConfigurationOnVlanNic() throws Exception {
    vlanNic.setNetworkName(vlanNetwork.getName());
    when(interfaceDao.getAllInterfacesForVds(eq(hostId))).thenReturn(Arrays.asList(baseNic, vlanNic));
    when(networkDao.getAllForCluster(eq(clusterId))).thenReturn(Collections.singletonList(vlanNetwork));
    NetworkAttachment networkAttachment = new NetworkAttachment();
    networkAttachment.setNicId(baseNic.getId());
    networkAttachment.setNicName(baseNic.getName());
    networkAttachment.setNetworkId(vlanNetwork.getId());
    when(effectiveHostNetworkQos.getQos(networkAttachment, vlanNetwork)).thenReturn(vlanNetworkQos);
    filler.fillReportedConfiguration(networkAttachment, hostId);
    verify(filler).createNetworkInSyncWithVdsNetworkInterface(networkAttachment, vlanNic, vlanNetwork, vds, cluster);
}
#method_after
@Test
public void testFillReportedConfigurationOnVlanNic() throws Exception {
    vlanNic.setNetworkName(vlanNetwork.getName());
    when(interfaceDao.getAllInterfacesForVds(eq(hostId))).thenReturn(Arrays.asList(baseNic, vlanNic));
    when(networkDao.getAllForCluster(eq(clusterId))).thenReturn(Collections.singletonList(vlanNetwork));
    NetworkAttachment networkAttachment = new NetworkAttachment();
    networkAttachment.setNicId(baseNic.getId());
    networkAttachment.setNicName(baseNic.getName());
    networkAttachment.setNetworkId(vlanNetwork.getId());
    when(effectiveHostNetworkQos.getQos(networkAttachment, vlanNetwork)).thenReturn(vlanNetworkQos);
    filler.fillReportedConfiguration(networkAttachment, hostId);
    verify(filler).createNetworkInSyncWithVdsNetworkInterface(networkAttachment, vlanNic, vlanNetwork, reportedDnsResolverConfiguration, cluster);
}
#end_block

#method_before
private void fillReportedConfigurations(Map<String, VdsNetworkInterface> networkNameToNicMap, BusinessEntityMap<Network> networkMap, NetworkAttachment networkAttachment, VDS vds, Cluster cluster) {
    Network network = networkMap.get(networkAttachment.getNetworkId());
    VdsNetworkInterface nic = getNicToWhichIsNetworkAttached(networkNameToNicMap, networkMap, networkAttachment);
    if (nic != null) {
        NetworkInSyncWithVdsNetworkInterface isInSync = createNetworkInSyncWithVdsNetworkInterface(networkAttachment, nic, network, vds, cluster);
        ReportedConfigurations reportedConfigurations = isInSync.reportConfigurationsOnHost();
        networkAttachment.setReportedConfigurations(reportedConfigurations);
    }
}
#method_after
public void fillReportedConfigurations(List<VdsNetworkInterface> allInterfacesForHost, BusinessEntityMap<Network> networkMap, List<NetworkAttachment> networkAttachments, DnsResolverConfiguration reportedDnsResolverConfiguration, Guid clusterId) {
    Cluster cluster = clusterDao.get(clusterId);
    Map<String, VdsNetworkInterface> networkNameToNicMap = nicsByNetworkId(allInterfacesForHost);
    for (NetworkAttachment networkAttachment : networkAttachments) {
        fillReportedConfigurations(networkNameToNicMap, networkMap, networkAttachment, reportedDnsResolverConfiguration, cluster);
    }
}
#end_block

#method_before
public void fillReportedConfigurations(List<NetworkAttachment> networkAttachments, Guid hostId) {
    List<VdsNetworkInterface> allInterfacesForHost = interfaceDao.getAllInterfacesForVds(hostId);
    VDS vds = vdsDao.get(hostId);
    Guid clusterId = vds.getClusterId();
    BusinessEntityMap<Network> networkMap = new BusinessEntityMap<>(networkDao.getAllForCluster(clusterId));
    fillReportedConfigurations(allInterfacesForHost, networkMap, networkAttachments, vds, clusterId);
}
#method_after
public void fillReportedConfigurations(List<NetworkAttachment> networkAttachments, Guid hostId) {
    List<VdsNetworkInterface> allInterfacesForHost = interfaceDao.getAllInterfacesForVds(hostId);
    Guid clusterId = getClusterId(hostId);
    BusinessEntityMap<Network> networkMap = new BusinessEntityMap<>(networkDao.getAllForCluster(clusterId));
    fillReportedConfigurations(allInterfacesForHost, networkMap, networkAttachments, vdsDynamicDao.get(hostId).getReportedDnsResolverConfiguration(), clusterId);
}
#end_block

#method_before
NetworkInSyncWithVdsNetworkInterface createNetworkInSyncWithVdsNetworkInterface(NetworkAttachment networkAttachment, VdsNetworkInterface nic, Network network, VDS vds, Cluster cluster) {
    HostNetworkQos hostNetworkQos = effectiveHostNetworkQos.getQos(networkAttachment, network);
    return new NetworkInSyncWithVdsNetworkInterface(nic, network, this.managementNetworkUtil.isManagementNetwork(network.getId(), cluster.getId()), hostNetworkQos, networkAttachment, vds, cluster);
}
#method_after
NetworkInSyncWithVdsNetworkInterface createNetworkInSyncWithVdsNetworkInterface(NetworkAttachment networkAttachment, VdsNetworkInterface nic, Network network, DnsResolverConfiguration reportedDnsResolverConfiguration, Cluster cluster) {
    HostNetworkQos hostNetworkQos = effectiveHostNetworkQos.getQos(networkAttachment, network);
    return new NetworkInSyncWithVdsNetworkInterface(nic, network, hostNetworkQos, networkAttachment, reportedDnsResolverConfiguration, cluster, this.defaultRouteUtil.isDefaultRouteNetwork(network.getId(), cluster.getId()));
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    Guid hostId = getParameters().getId();
    List<NetworkAttachment> networkAttachments = networkAttachmentDao.getAllForHost(hostId);
    List<VdsNetworkInterface> allInterfacesForHost = interfaceDao.getAllInterfacesForVds(hostId);
    VDS vds = hostDao.get(hostId);
    Guid clusterId = vds.getClusterId();
    BusinessEntityMap<Network> networkMap = new BusinessEntityMap<>(networkDao.getAllForCluster(clusterId));
    reportedConfigurationsFiller.fillReportedConfigurations(allInterfacesForHost, networkMap, networkAttachments, vds, clusterId);
    completeNicNames(networkAttachments, allInterfacesForHost);
    completeNetworkNames(networkAttachments, networkMap);
    getQueryReturnValue().setReturnValue(networkAttachments);
}
#method_after
@Override
protected void executeQueryCommand() {
    Guid hostId = getParameters().getId();
    List<NetworkAttachment> networkAttachments = networkAttachmentDao.getAllForHost(hostId);
    List<VdsNetworkInterface> allInterfacesForHost = interfaceDao.getAllInterfacesForVds(hostId);
    VDS vds = hostDao.get(hostId);
    Guid clusterId = vds.getClusterId();
    BusinessEntityMap<Network> networkMap = new BusinessEntityMap<>(networkDao.getAllForCluster(clusterId));
    reportedConfigurationsFiller.fillReportedConfigurations(allInterfacesForHost, networkMap, networkAttachments, vds.getDynamicData().getReportedDnsResolverConfiguration(), clusterId);
    completeNicNames(networkAttachments, allInterfacesForHost);
    completeNetworkNames(networkAttachments, networkMap);
    getQueryReturnValue().setReturnValue(networkAttachments);
}
#end_block

#method_before
private void addDnsConfiguration(ReportedConfigurations result) {
    // DNS configuration is reported only on management network
    if (!this.isManagementNetwork) {
        return;
    }
    List<NameServer> nameServersOfNetworkAttachment = getNameServers(networkAttachment.getDnsResolverConfiguration());
    List<NameServer> nameServersOfNetwork = getNameServers(network.getDnsResolverConfiguration());
    List<NameServer> nameServersOfHost = getNameServers(vds.getDnsResolverConfiguration());
    boolean engineDoesNotContainDnsConfiguration = nameServersOfNetworkAttachment == null && nameServersOfNetwork == null;
    List<NameServer> expectedNameServers = nameServersOfNetworkAttachment != null ? nameServersOfNetworkAttachment : nameServersOfNetwork;
    boolean inSync = isDhcpUsed(networkAttachment) || engineDoesNotContainDnsConfiguration || Objects.equals(nameServersOfHost, expectedNameServers);
    result.add(DNS_CONFIGURATION, addressesAsString(nameServersOfHost), addressesAsString(expectedNameServers), inSync);
}
#method_after
private void addDnsConfiguration(ReportedConfigurations result) {
    boolean dnsResolverConfigurationSupported = FeatureSupported.supportedInConfig(ConfigValues.DnsResolverConfigurationSupported, this.cluster.getCompatibilityVersion());
    // DNS configuration is reported only on network having default_route role
    if (!isDefaultRouteNetwork || !dnsResolverConfigurationSupported) {
        return;
    }
    List<NameServer> nameServersOfNetworkAttachment = getNameServers(networkAttachment.getDnsResolverConfiguration());
    List<NameServer> nameServersOfNetwork = getNameServers(network.getDnsResolverConfiguration());
    List<NameServer> nameServersOfHost = getNameServers(reportedDnsResolverConfiguration);
    boolean shouldSetDefaultRoute = new ShouldSetDefaultRouteFlagAndDnsData().test(true, networkAttachment);
    boolean engineDefineDnsConfiguration = shouldSetDefaultRoute && (nameServersOfNetworkAttachment != null || nameServersOfNetwork != null);
    List<NameServer> expectedNameServers = nameServersOfNetworkAttachment != null ? nameServersOfNetworkAttachment : nameServersOfNetwork;
    boolean outOfSync = engineDefineDnsConfiguration && !Objects.equals(nameServersOfHost, expectedNameServers);
    result.add(DNS_CONFIGURATION, addressesAsString(nameServersOfHost), engineDefineDnsConfiguration ? addressesAsString(expectedNameServers) : "", !outOfSync);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    sampleDnsResolverConfiguration = new DnsResolverConfiguration(Arrays.asList(new NameServer("192.168.1.1"), new NameServer("2001:0db8:85a3:0000:0000:8a2e:0370:7334")));
    sampleDnsResolverConfiguration2 = new DnsResolverConfiguration(Arrays.asList(new NameServer("192.168.1.2"), new NameServer("2002:0db8:85a3:0000:0000:8a2e:0370:7334")));
    sampleDnsResolverConfigurationWithReversedNameServers = reverseNameServersOrder(sampleDnsResolverConfiguration);
    ifaceQos = new HostNetworkQos();
    networkQos = new HostNetworkQos();
    iface = new VdsNetworkInterface();
    // needed because network is vm network by default
    iface.setBridged(true);
    iface.setQos(ifaceQos);
    iface.setReportedSwitchType(SwitchType.LEGACY);
    network = new Network();
    network.setDnsResolverConfiguration(sampleDnsResolverConfiguration);
    testedNetworkAttachment = new NetworkAttachment();
    testedNetworkAttachment.setIpConfiguration(new IpConfiguration());
    vds = new VDS();
    vds.setDnsResolverConfiguration(sampleDnsResolverConfigurationWithReversedNameServers);
    cluster = new Cluster();
    cluster.setRequiredSwitchTypeForCluster(SwitchType.LEGACY);
}
#method_after
@Before
public void setUp() throws Exception {
    sampleDnsResolverConfiguration = new DnsResolverConfiguration();
    sampleDnsResolverConfiguration.setNameServers(Arrays.asList(new NameServer("192.168.1.1"), new NameServer("2001:0db8:85a3:0000:0000:8a2e:0370:7334")));
    sampleDnsResolverConfiguration2 = new DnsResolverConfiguration();
    sampleDnsResolverConfiguration2.setNameServers(Arrays.asList(new NameServer("192.168.1.2"), new NameServer("2002:0db8:85a3:0000:0000:8a2e:0370:7334")));
    sampleDnsResolverConfigurationWithReversedNameServers = reverseNameServersOrder(sampleDnsResolverConfiguration);
    ifaceQos = new HostNetworkQos();
    networkQos = new HostNetworkQos();
    iface = new VdsNetworkInterface();
    // needed because network is vm network by default
    iface.setBridged(true);
    iface.setQos(ifaceQos);
    iface.setReportedSwitchType(SwitchType.LEGACY);
    network = new Network();
    network.setDnsResolverConfiguration(sampleDnsResolverConfiguration);
    testedNetworkAttachment = new NetworkAttachment();
    testedNetworkAttachment.setIpConfiguration(new IpConfiguration());
    cluster = new Cluster();
    cluster.setCompatibilityVersion(Version.v4_1);
    cluster.setRequiredSwitchTypeForCluster(SwitchType.LEGACY);
}
#end_block

#method_before
private NetworkInSyncWithVdsNetworkInterface createTestedInstanceWithSameNonQosValues(boolean isManagementNetwork) {
    iface.setMtu(1);
    network.setMtu(1);
    iface.setVlanId(1);
    network.setVlanId(1);
    iface.setBridged(true);
    network.setVmNetwork(true);
    return createTestedInstance(isManagementNetwork);
}
#method_after
private NetworkInSyncWithVdsNetworkInterface createTestedInstanceWithSameNonQosValues(boolean isDefaultRouteNetwork) {
    iface.setMtu(1);
    network.setMtu(1);
    iface.setVlanId(1);
    network.setVlanId(1);
    iface.setBridged(true);
    network.setVmNetwork(true);
    return createTestedInstance(isDefaultRouteNetwork, sampleDnsResolverConfiguration);
}
#end_block

#method_before
private NetworkInSyncWithVdsNetworkInterface createTestedInstance() {
    return createTestedInstance(false);
}
#method_after
private NetworkInSyncWithVdsNetworkInterface createTestedInstance() {
    return createTestedInstance(false, sampleDnsResolverConfiguration);
}
#end_block

#method_before
private NetworkInSyncWithVdsNetworkInterface createTestedInstance(boolean isManagementNetwork) {
    return new NetworkInSyncWithVdsNetworkInterface(iface, network, isManagementNetwork, networkQos, testedNetworkAttachment, vds, cluster);
}
#method_after
private NetworkInSyncWithVdsNetworkInterface createTestedInstance(boolean isDefaultRouteNetwork, DnsResolverConfiguration reportedDnsResolverConfiguration) {
    return new NetworkInSyncWithVdsNetworkInterface(iface, network, networkQos, testedNetworkAttachment, reportedDnsResolverConfiguration, cluster, isDefaultRouteNetwork);
}
#end_block

#method_before
private DnsResolverConfiguration reverseNameServersOrder(DnsResolverConfiguration sampleDnsResolverConfiguration) {
    List<NameServer> reversedNameServers = sampleDnsResolverConfiguration.getNameServers();
    Collections.reverse(reversedNameServers);
    return new DnsResolverConfiguration(reversedNameServers);
}
#method_after
private DnsResolverConfiguration reverseNameServersOrder(DnsResolverConfiguration sampleDnsResolverConfiguration) {
    List<NameServer> reversedNameServers = sampleDnsResolverConfiguration.getNameServers();
    Collections.reverse(reversedNameServers);
    DnsResolverConfiguration result = new DnsResolverConfiguration();
    result.setNameServers(reversedNameServers);
    return result;
}
#end_block

#method_before
private void testDnsResolverConfiguration(DnsResolverConfiguration vdsDnsResolver, DnsResolverConfiguration networkDnsResolver, DnsResolverConfiguration attachmentDnsResolver, boolean expectedInSync) {
    vds.setDnsResolverConfiguration(vdsDnsResolver);
    network.setDnsResolverConfiguration(networkDnsResolver);
    testedNetworkAttachment.setDnsResolverConfiguration(attachmentDnsResolver);
    assertThat(createTestedInstance(true).isNetworkInSync(), is(expectedInSync));
}
#method_after
private void testDnsResolverConfiguration(DnsResolverConfiguration vdsDnsResolver, DnsResolverConfiguration networkDnsResolver, DnsResolverConfiguration attachmentDnsResolver, boolean expectedInSync) {
    // cannot use initIpv4ConfigurationBootProtocol because of 'randomized tests' technique.
    iface.setIpv4BootProtocol(Ipv4BootProtocol.DHCP);
    IPv4Address address = new IPv4Address();
    address.setBootProtocol(Ipv4BootProtocol.DHCP);
    testedNetworkAttachment.getIpConfiguration().setIPv4Addresses(Collections.singletonList(address));
    network.setDnsResolverConfiguration(networkDnsResolver);
    testedNetworkAttachment.setDnsResolverConfiguration(attachmentDnsResolver);
    assertThat(createTestedInstance(true, vdsDnsResolver).isNetworkInSync(), is(expectedInSync));
}
#end_block

#method_before
@Test
public void testDnsResolverConfigurationInSyncWithHostWhenDhcpIsUsed() {
    vds.setDnsResolverConfiguration(sampleDnsResolverConfiguration);
    network.setDnsResolverConfiguration(sampleDnsResolverConfiguration2);
    testedNetworkAttachment.setDnsResolverConfiguration(null);
    iface.setIpv4BootProtocol(Ipv4BootProtocol.DHCP);
    IPv4Address address = new IPv4Address();
    address.setBootProtocol(Ipv4BootProtocol.DHCP);
    testedNetworkAttachment.getIpConfiguration().setIPv4Addresses(Collections.singletonList(address));
    assertThat(createTestedInstance(true).isNetworkInSync(), is(true));
}
#method_after
@Test
public void testDnsResolverConfigurationInSyncWithHostWhenDhcpIsUsed() {
    network.setDnsResolverConfiguration(sampleDnsResolverConfiguration2);
    testedNetworkAttachment.setDnsResolverConfiguration(null);
    iface.setIpv4BootProtocol(Ipv4BootProtocol.DHCP);
    IPv4Address address = new IPv4Address();
    address.setBootProtocol(Ipv4BootProtocol.DHCP);
    testedNetworkAttachment.getIpConfiguration().setIPv4Addresses(Collections.singletonList(address));
    assertThat(createTestedInstance(true, sampleDnsResolverConfiguration).isNetworkInSync(), is(false));
}
#end_block

#method_before
public boolean attachmentFromRequestIsEqualToAlreadyExistingOne(NetworkAttachment networkAttachmentFromRequest, NetworkAttachment existingNetworkAttachment) {
    return existingNetworkAttachment != null && Objects.equals(networkAttachmentFromRequest.getId(), existingNetworkAttachment.getId()) && Objects.equals(networkAttachmentFromRequest.getNetworkId(), existingNetworkAttachment.getNetworkId()) && Objects.equals(networkAttachmentFromRequest.getNetworkName(), existingNetworkAttachment.getNetworkName()) && Objects.equals(networkAttachmentFromRequest.getNicId(), existingNetworkAttachment.getNicId()) && Objects.equals(networkAttachmentFromRequest.getHostNetworkQos(), existingNetworkAttachment.getHostNetworkQos()) && Objects.equals(networkAttachmentFromRequest.getNicName(), existingNetworkAttachment.getNicName()) && Objects.equals(networkAttachmentFromRequest.getIpConfiguration(), existingNetworkAttachment.getIpConfiguration()) && Objects.equals(networkAttachmentFromRequest.getProperties(), existingNetworkAttachment.getProperties()) && Objects.equals(networkAttachmentFromRequest.getDnsResolverConfiguration(), existingNetworkAttachment.getDnsResolverConfiguration());
}
#method_after
private boolean attachmentFromRequestIsEqualToAlreadyExistingOne(NetworkAttachment networkAttachmentFromRequest, NetworkAttachment existingNetworkAttachment) {
    return existingNetworkAttachment != null && Objects.equals(networkAttachmentFromRequest.getId(), existingNetworkAttachment.getId()) && Objects.equals(networkAttachmentFromRequest.getNetworkId(), existingNetworkAttachment.getNetworkId()) && Objects.equals(networkAttachmentFromRequest.getNetworkName(), existingNetworkAttachment.getNetworkName()) && Objects.equals(networkAttachmentFromRequest.getNicId(), existingNetworkAttachment.getNicId()) && Objects.equals(networkAttachmentFromRequest.getHostNetworkQos(), existingNetworkAttachment.getHostNetworkQos()) && Objects.equals(networkAttachmentFromRequest.getNicName(), existingNetworkAttachment.getNicName()) && Objects.equals(networkAttachmentFromRequest.getIpConfiguration(), existingNetworkAttachment.getIpConfiguration()) && Objects.equals(networkAttachmentFromRequest.getProperties(), existingNetworkAttachment.getProperties()) && Objects.equals(networkAttachmentFromRequest.getDnsResolverConfiguration(), existingNetworkAttachment.getDnsResolverConfiguration());
}
#end_block

#method_before
private HostSetupNetworksVdsCommandParameters createSetupNetworksParameters(int timeout) {
    SwitchType clusterSwitchType = getCluster().getRequiredSwitchTypeForCluster();
    Network managementNetworkOfThisCluster = managementNetworkUtil.getManagementNetwork(getVds().getClusterId());
    List<HostNetwork> networksToConfigure = calculateNetworksToConfigure(managementNetworkOfThisCluster);
    boolean managementNetworkChanged = isManagementNetworkChanged(managementNetworkOfThisCluster, networksToConfigure);
    final HostSetupNetworksVdsCommandParameters hostCmdParams = new HostSetupNetworksVdsCommandParameters(getVds(), networksToConfigure, getAllNetworksToRemove(), getParameters().getCreateOrUpdateBonds(), getRemovedBondNames(), clusterSwitchType);
    hostCmdParams.setRollbackOnFailure(getParameters().rollbackOnFailure());
    hostCmdParams.setConnectivityTimeout(timeout);
    hostCmdParams.setManagementNetworkChanged(managementNetworkChanged);
    return hostCmdParams;
}
#method_after
private HostSetupNetworksVdsCommandParameters createSetupNetworksParameters(int timeout) {
    SwitchType clusterSwitchType = getCluster().getRequiredSwitchTypeForCluster();
    List<HostNetwork> networksToConfigure = calculateNetworksToConfigure();
    final HostSetupNetworksVdsCommandParameters hostCmdParams = new HostSetupNetworksVdsCommandParameters(getVds(), networksToConfigure, getAllNetworksToRemove(), getParameters().getCreateOrUpdateBonds(), getRemovedBondNames(), clusterSwitchType);
    hostCmdParams.setRollbackOnFailure(getParameters().rollbackOnFailure());
    hostCmdParams.setConnectivityTimeout(timeout);
    hostCmdParams.setManagementNetworkChanged(isManagementNetworkChanged(networksToConfigure));
    return hostCmdParams;
}
#end_block

#method_before
protected Integer getSetupNetworksTimeout() {
    return getParameters().getConectivityTimeout() != null ? getParameters().getConectivityTimeout() : Config.<Integer>getValue(ConfigValues.NetworkConnectivityCheckTimeoutInSeconds);
}
#method_after
private Integer getSetupNetworksTimeout() {
    return getParameters().getConectivityTimeout() != null ? getParameters().getConectivityTimeout() : Config.<Integer>getValue(ConfigValues.NetworkConnectivityCheckTimeoutInSeconds);
}
#end_block

#method_before
private List<HostNetwork> calculateNetworksToConfigure(Network managementNetworkOfThisCluster) {
    List<HostNetwork> networksToConfigure = new ArrayList<>(getParameters().getNetworkAttachments().size());
    BusinessEntityMap<VdsNetworkInterface> nics = getExistingNicsBusinessEntityMap();
    Guid managementNetworkId = managementNetworkOfThisCluster.getId();
    for (NetworkAttachment attachment : getParameters().getNetworkAttachments()) {
        Network network = existingNetworkRelatedToAttachment(attachment);
        HostNetwork networkToConfigure = new HostNetwork(network, attachment);
        networkToConfigure.setBonding(isBonding(attachment, nics));
        boolean attachmentOfManagementNetwork = attachment.getNetworkId().equals(managementNetworkId);
        if (attachmentOfManagementNetwork) {
            DnsResolverConfiguration dnsResolverConfiguration = calculateDnsConfigurationToUse(attachment, network);
            if (dnsResolverConfiguration != null) {
                networkToConfigure.setNameServers(dnsResolverConfiguration.getNameServers());
            }
        }
        if (defaultRouteSupported() && defaultRouteRequired(network, attachment.getIpConfiguration())) {
            // TODO: YZ - should default route be set separately for IPv4 and IPv6
            networkToConfigure.setDefaultRoute(true);
        }
        if (NetworkUtils.qosConfiguredOnInterface(attachment, network)) {
            networkToConfigure.setQosConfiguredOnInterface(true);
            HostNetworkQos hostNetworkQos = effectiveHostNetworkQos.getQos(attachment, network);
            networkToConfigure.setQos(hostNetworkQos);
        }
        networksToConfigure.add(networkToConfigure);
    }
    return networksToConfigure;
}
#method_after
private List<HostNetwork> calculateNetworksToConfigure() {
    List<HostNetwork> networksToConfigure = new ArrayList<>(getParameters().getNetworkAttachments().size());
    BusinessEntityMap<VdsNetworkInterface> nics = getExistingNicsBusinessEntityMap();
    for (NetworkAttachment attachment : getParameters().getNetworkAttachments()) {
        Network network = existingNetworkRelatedToAttachment(attachment);
        NetworkCluster networkCluster = network.getCluster();
        HostNetwork networkToConfigure = new HostNetwork(network, attachment);
        networkToConfigure.setBonding(isBonding(attachment, nics));
        if (defaultRouteSupported() && new ShouldSetDefaultRouteFlagAndDnsData().test(networkCluster.isDefaultRoute(), attachment)) {
            DnsResolverConfiguration dnsResolverConfiguration = getDnsConfigurationFromNetworkOrItsAttachment(attachment, network);
            if (dnsResolverConfiguration != null) {
                networkToConfigure.setNameServers(dnsResolverConfiguration.getNameServers());
            }
            // TODO: YZ - should default route be set separately for IPv4 and IPv6
            networkToConfigure.setDefaultRoute(true);
        }
        if (NetworkUtils.qosConfiguredOnInterface(attachment, network)) {
            networkToConfigure.setQosConfiguredOnInterface(true);
            HostNetworkQos hostNetworkQos = effectiveHostNetworkQos.getQos(attachment, network);
            networkToConfigure.setQos(hostNetworkQos);
        }
        networksToConfigure.add(networkToConfigure);
    }
    return networksToConfigure;
}
#end_block

#method_before
private boolean defaultRouteSupported() {
    boolean defaultRouteSupported = false;
    Set<Version> supportedClusterVersionsSet = getVds().getSupportedClusterVersionsSet();
    if (supportedClusterVersionsSet == null || supportedClusterVersionsSet.isEmpty()) {
        log.warn("Host '{}' ('{}') doesn't contain Supported Cluster Versions, " + "therefore 'defaultRoute' will not be sent via the SetupNetworks", getVdsName(), getVdsId());
    } else {
        defaultRouteSupported = true;
    }
    return defaultRouteSupported;
}
#method_after
private boolean defaultRouteSupported() {
    Set<Version> supportedClusterVersionsSet = getVds().getSupportedClusterVersionsSet();
    if (supportedClusterVersionsSet == null || supportedClusterVersionsSet.isEmpty()) {
        log.warn("Host '{}' ('{}') doesn't contain Supported Cluster Versions, " + "therefore 'defaultRoute' will not be sent via the SetupNetworks", getVdsName(), getVdsId());
        return false;
    }
    return true;
}
#end_block

#method_before
private void persistNetworkChanges(final VDS updatedHost) {
    TransactionSupport.executeInNewTransaction(() -> {
        UserConfiguredNetworkData userConfiguredNetworkData = new UserConfiguredNetworkData(getParameters().getNetworkAttachments(), getParameters().getRemovedNetworkAttachments(), applyUserConfiguredNics());
        // save the new network topology to DB
        hostNetworkTopologyPersister.persistAndEnforceNetworkCompliance(updatedHost, false, userConfiguredNetworkData);
        vdsDynamicDao.updateNetConfigDirty(updatedHost.getId(), updatedHost.getNetConfigDirty());
        // Update cluster networks (i.e. check if need to activate each new network)
        for (Network net : getModifiedNetworks()) {
            NetworkClusterHelper.setStatus(getClusterId(), net);
        }
        return null;
    });
}
#method_after
private void persistNetworkChanges(final VDS updatedHost) {
    TransactionSupport.executeInNewTransaction(() -> {
        UserConfiguredNetworkData userConfiguredNetworkData = new UserConfiguredNetworkData(getParameters().getNetworkAttachments(), getParameters().getRemovedNetworkAttachments(), applyUserConfiguredNics());
        // save the new network topology to DB
        hostNetworkTopologyPersister.persistAndEnforceNetworkCompliance(updatedHost, false, userConfiguredNetworkData);
        vdsDynamicDao.updateNetConfigDirty(updatedHost.getId(), updatedHost.getNetConfigDirty());
        // Update cluster networks (i.e. check if need to activate each new network)
        networkClusterHelper.setStatus(getClusterId(), getModifiedNetworks());
        return null;
    });
}
#end_block

#method_before
private boolean isManagementNetworkChanged(Network managementNetwork, List<HostNetwork> networksToConfigure) {
    String mgmtNetworkName = managementNetwork.getName();
    for (HostNetwork network : networksToConfigure) {
        if (mgmtNetworkName.equals(network.getNetworkName())) {
            return true;
        }
    }
    for (CreateOrUpdateBond createOrUpdateBond : getParameters().getCreateOrUpdateBonds()) {
        // We are only interested in existing bonds, whose bonding options/slave have changed, so it
        // enough to check existing bonds. New bonds which have the management network
        // are covered by network attachments
        VdsNetworkInterface bondNic = getExistingNicsBusinessEntityMap().get(createOrUpdateBond.getId());
        if (bondNic != null && mgmtNetworkName.equals(bondNic.getNetworkName())) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean isManagementNetworkChanged(List<HostNetwork> networksToConfigure) {
    Network managementNetwork = managementNetworkUtil.getManagementNetwork(getClusterNetworks(), getClusterId());
    String managementNetworkName = managementNetwork.getName();
    for (HostNetwork network : networksToConfigure) {
        if (managementNetworkName.equals(network.getNetworkName())) {
            return true;
        }
    }
    for (CreateOrUpdateBond createOrUpdateBond : getParameters().getCreateOrUpdateBonds()) {
        // We are only interested in existing bonds, whose bonding options/slave have changed, so it
        // enough to check existing bonds. New bonds which have the management network
        // are covered by network attachments
        VdsNetworkInterface bondNic = getExistingNicsBusinessEntityMap().get(createOrUpdateBond.getId());
        if (bondNic != null && managementNetworkName.equals(bondNic.getNetworkName())) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private Map<String, Object> createNetworkAttributes(HostNetwork hostNetwork) {
    Map<String, Object> attributes = new HashMap<>();
    if (hostNetwork.isBonding()) {
        attributes.put("bonding", hostNetwork.getNicName());
    } else {
        attributes.put("nic", hostNetwork.getNicName());
    }
    if (hostNetwork.isVlan()) {
        attributes.put("vlan", hostNetwork.getVlan().toString());
    }
    if (hostNetwork.getMtu() == 0) {
        attributes.put(VdsProperties.MTU, NetworkUtils.getDefaultMtu());
    } else {
        attributes.put(VdsProperties.MTU, hostNetwork.getMtu());
    }
    attributes.put("bridged", Boolean.toString(hostNetwork.isVmNetwork()));
    if (hostNetwork.isVmNetwork()) {
        attributes.put(VdsProperties.STP, hostNetwork.isStp() ? "yes" : "no");
    }
    if (hostNetwork.getIpv4BootProtocol() != null) {
        addIpv4BootProtocol(attributes, hostNetwork);
    }
    if (hostNetwork.getIpv6BootProtocol() != null) {
        addIpv6BootProtocol(attributes, hostNetwork);
    }
    if (hostNetwork.isDefaultRoute()) {
        attributes.put(DEFAULT_ROUTE, Boolean.TRUE);
    }
    addSwitchTypeIfSpecified(attributes);
    if (hostNetwork.hasProperties()) {
        attributes.put(VdsProperties.NETWORK_CUSTOM_PROPERTIES, hostNetwork.getProperties());
    }
    if (hostNetwork.isQosConfiguredOnInterface()) {
        HostNetworkQosMapper qosMapper = new HostNetworkQosMapper(attributes);
        qosMapper.serialize(hostNetwork.getQos());
    }
    List<NameServer> nameServers = hostNetwork.getNameServers();
    List<String> nameServerIps = nameServers.stream().map(NameServer::getAddress).collect(Collectors.toList());
    attributes.put(VdsProperties.name_servers, nameServerIps);
    return attributes;
}
#method_after
private Map<String, Object> createNetworkAttributes(HostNetwork hostNetwork) {
    Map<String, Object> attributes = new HashMap<>();
    if (hostNetwork.isBonding()) {
        attributes.put("bonding", hostNetwork.getNicName());
    } else {
        attributes.put("nic", hostNetwork.getNicName());
    }
    if (hostNetwork.isVlan()) {
        attributes.put("vlan", hostNetwork.getVlan().toString());
    }
    if (hostNetwork.getMtu() == 0) {
        attributes.put(VdsProperties.MTU, NetworkUtils.getDefaultMtu());
    } else {
        attributes.put(VdsProperties.MTU, hostNetwork.getMtu());
    }
    attributes.put("bridged", Boolean.toString(hostNetwork.isVmNetwork()));
    if (hostNetwork.isVmNetwork()) {
        attributes.put(VdsProperties.STP, hostNetwork.isStp() ? "yes" : "no");
    }
    if (hostNetwork.getIpv4BootProtocol() != null) {
        addIpv4BootProtocol(attributes, hostNetwork);
    }
    if (hostNetwork.getIpv6BootProtocol() != null) {
        addIpv6BootProtocol(attributes, hostNetwork);
    }
    if (hostNetwork.isDefaultRoute()) {
        attributes.put(DEFAULT_ROUTE, Boolean.TRUE);
    }
    addSwitchTypeIfSpecified(attributes);
    if (hostNetwork.hasProperties()) {
        attributes.put(VdsProperties.NETWORK_CUSTOM_PROPERTIES, hostNetwork.getProperties());
    }
    if (hostNetwork.isQosConfiguredOnInterface()) {
        HostNetworkQosMapper qosMapper = new HostNetworkQosMapper(attributes);
        qosMapper.serialize(hostNetwork.getQos());
    }
    List<NameServer> nameServers = hostNetwork.getNameServers();
    if (nameServers != null) {
        List<String> nameServerIps = nameServers.stream().map(NameServer::getAddress).collect(Collectors.toList());
        attributes.put(VdsProperties.name_servers, nameServerIps);
    }
    return attributes;
}
#end_block

#method_before
public static VM buildVmsDataFromExternalProvider(Map<String, Object> struct) {
    VmStatic vmStatic = buildVmStaticDataFromExternalProvider(struct);
    if (vmStatic == null) {
        return null;
    }
    VmDynamic vmDynamic = buildVMDynamicDataFromList(struct);
    VM vm = new VM(vmStatic, vmDynamic, new VmStatistics());
    for (DiskImage image : vm.getImages()) {
        vm.getDiskMap().put(Guid.newGuid(), image);
    }
    try {
        vm.setClusterArch(parseArchitecture(struct));
    } catch (IllegalArgumentException ex) {
        log.warn("Illegal architecture type: %s, replacing with x86_64", struct.get(VdsProperties.vm_arch));
        vm.setClusterArch(ArchitectureType.x86_64);
    } catch (NullPointerException ex) {
        log.warn("null architecture type, replacing with x86_64, %s", vm);
        vm.setClusterArch(ArchitectureType.x86_64);
    }
    return vm;
}
#method_after
public static VM buildVmsDataFromExternalProvider(Map<String, Object> struct) {
    VmStatic vmStatic = buildVmStaticDataFromExternalProvider(struct);
    if (vmStatic == null) {
        return null;
    }
    VmDynamic vmDynamic = buildVMDynamicDataFromList(struct);
    VM vm = new VM(vmStatic, vmDynamic, new VmStatistics());
    for (DiskImage image : vm.getImages()) {
        vm.getDiskMap().put(Guid.newGuid(), image);
    }
    try {
        vm.setClusterArch(parseArchitecture(struct));
    } catch (IllegalArgumentException ex) {
        log.warn("Illegal architecture type: {}, replacing with x86_64", struct.get(VdsProperties.vm_arch));
        vm.setClusterArch(ArchitectureType.x86_64);
    } catch (NullPointerException ex) {
        log.warn("null architecture type, replacing with x86_64, {}", vm);
        vm.setClusterArch(ArchitectureType.x86_64);
    }
    return vm;
}
#end_block

#method_before
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> struct, VDS host) {
    if (struct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) struct.get(VdsProperties.vm_guid)));
    }
    if (struct.containsKey(VdsProperties.session)) {
        String session = (String) struct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.error("Illegal vm session '{}'.", session);
        }
    }
    if (struct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) struct.get(VdsProperties.acpiEnable)));
    }
    if (struct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) struct.get(VdsProperties.status)));
    }
    boolean hasGraphicsInfo = updateGraphicsInfo(vm, struct);
    if (!hasGraphicsInfo) {
        updateGraphicsInfoFromConf(vm, struct);
    }
    adjustDisplayIp(vm.getGraphicsInfos(), host);
    if (struct.containsKey(VdsProperties.utc_diff)) {
        String utc_diff = struct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.error("Illegal vm offset (utc_diff) '{}'.", utc_diff);
        }
    }
    // ------------- vm internal agent data
    if (struct.containsKey(VdsProperties.vm_host)) {
        vm.setVmHost(assignStringValue(struct, VdsProperties.vm_host));
    }
    if (struct.containsKey(VdsProperties.guest_cur_user_name)) {
        vm.setGuestCurrentUserName(assignStringValue(struct, VdsProperties.guest_cur_user_name));
    }
    initAppsList(struct, vm);
    initGuestContainers(struct, vm);
    if (struct.containsKey(VdsProperties.guest_os)) {
        vm.setGuestOs(assignStringValue(struct, VdsProperties.guest_os));
    }
    if (struct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setFqdn(assignStringValue(struct, VdsProperties.VM_FQDN));
        String fqdn = vm.getFqdn().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setFqdn(null);
        } else {
            vm.setFqdn(fqdn);
        }
    }
    if (struct.containsKey(VdsProperties.VM_IP)) {
        vm.setIp(assignStringValue(struct, VdsProperties.VM_IP));
    }
    if (vm.getIp() != null) {
        if (vm.getIp().startsWith("127.0.")) {
            vm.setIp(null);
        } else {
            vm.setIp(vm.getIp().trim());
        }
    }
    if (struct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = struct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (struct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) struct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    if (struct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = struct.get(VdsProperties.exit_reason).toString();
        vm.setExitReason(VmExitReason.forValue(Integer.parseInt(exitReasonStr)));
    }
    // if monitorResponse returns negative it means its erroneous
    if (struct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(struct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (struct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(struct.get(VdsProperties.clientIp).toString());
    }
    if (struct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) struct.get(VdsProperties.pauseCode);
        try {
            vm.setPauseStatus(VmPauseStatus.valueOf(pauseCodeStr));
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
        }
    }
    if (struct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) struct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (struct.containsKey(VdsProperties.CDRom)) {
        Path fileName = Paths.get((String) struct.get(VdsProperties.CDRom)).getFileName();
        if (fileName != null) {
            String isoName = fileName.toString();
            vm.setCurrentCd(isoName);
        }
    }
    if (struct.containsKey(VdsProperties.GUEST_CPU_COUNT)) {
        vm.setGuestCpuCount(assignIntValue(struct, VdsProperties.GUEST_CPU_COUNT));
    }
    // Guest OS Info
    if (struct.containsKey(VdsProperties.GUEST_OS_INFO)) {
        updateGuestOsInfo(vm, struct);
    }
    // Guest Timezone
    if (struct.containsKey(VdsProperties.GUEST_TIMEZONE)) {
        Map<String, Object> guestTimeZoneStruct = (Map<String, Object>) struct.get(VdsProperties.GUEST_TIMEZONE);
        vm.setGuestOsTimezoneName(assignStringValue(guestTimeZoneStruct, VdsProperties.GUEST_TIMEZONE_ZONE));
        vm.setGuestOsTimezoneOffset(assignIntValue(guestTimeZoneStruct, VdsProperties.GUEST_TIMEZONE_OFFSET));
    }
}
#method_after
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> struct, VDS host) {
    if (struct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) struct.get(VdsProperties.vm_guid)));
    }
    if (struct.containsKey(VdsProperties.session)) {
        String session = (String) struct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.error("Illegal vm session '{}'.", session);
        }
    }
    if (struct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) struct.get(VdsProperties.acpiEnable)));
    }
    if (struct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) struct.get(VdsProperties.status)));
    }
    boolean hasGraphicsInfo = updateGraphicsInfo(vm, struct);
    if (!hasGraphicsInfo) {
        updateGraphicsInfoFromConf(vm, struct);
    }
    adjustDisplayIp(vm.getGraphicsInfos(), host);
    if (struct.containsKey(VdsProperties.utc_diff)) {
        String utc_diff = struct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.error("Illegal vm offset (utc_diff) '{}'.", utc_diff);
        }
    }
    // ------------- vm internal agent data
    if (struct.containsKey(VdsProperties.vm_host)) {
        vm.setVmHost(assignStringValue(struct, VdsProperties.vm_host));
    }
    if (struct.containsKey(VdsProperties.guest_cur_user_name)) {
        vm.setGuestCurrentUserName(assignStringValue(struct, VdsProperties.guest_cur_user_name));
    }
    initAppsList(struct, vm);
    initGuestContainers(struct, vm);
    if (struct.containsKey(VdsProperties.guest_os)) {
        vm.setGuestOs(assignStringValue(struct, VdsProperties.guest_os));
    }
    if (struct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setFqdn(assignStringValue(struct, VdsProperties.VM_FQDN));
        String fqdn = vm.getFqdn().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setFqdn(null);
        } else {
            vm.setFqdn(fqdn);
        }
    }
    if (struct.containsKey(VdsProperties.VM_IP)) {
        vm.setIp(assignStringValue(struct, VdsProperties.VM_IP));
    }
    if (vm.getIp() != null) {
        if (vm.getIp().startsWith("127.0.")) {
            vm.setIp(null);
        } else {
            vm.setIp(vm.getIp().trim());
        }
    }
    if (struct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = struct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (struct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) struct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    if (struct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = struct.get(VdsProperties.exit_reason).toString();
        VmExitReason exitReason = VmExitReason.forValue(Integer.parseInt(exitReasonStr));
        if (exitReason == null) {
            log.warn("Illegal exit reason: {}, replacing with Unknown", exitReasonStr);
            exitReason = VmExitReason.Unknown;
        }
        vm.setExitReason(exitReason);
    }
    // if monitorResponse returns negative it means its erroneous
    if (struct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(struct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (struct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(struct.get(VdsProperties.clientIp).toString());
    }
    if (struct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) struct.get(VdsProperties.pauseCode);
        try {
            vm.setPauseStatus(VmPauseStatus.valueOf(pauseCodeStr));
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
        }
    }
    if (struct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) struct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (struct.containsKey(VdsProperties.CDRom)) {
        Path fileName = Paths.get((String) struct.get(VdsProperties.CDRom)).getFileName();
        if (fileName != null) {
            String isoName = fileName.toString();
            vm.setCurrentCd(isoName);
        }
    }
    if (struct.containsKey(VdsProperties.GUEST_CPU_COUNT)) {
        vm.setGuestCpuCount(assignIntValue(struct, VdsProperties.GUEST_CPU_COUNT));
    }
    // Guest OS Info
    if (struct.containsKey(VdsProperties.GUEST_OS_INFO)) {
        updateGuestOsInfo(vm, struct);
    }
    // Guest Timezone
    if (struct.containsKey(VdsProperties.GUEST_TIMEZONE)) {
        Map<String, Object> guestTimeZoneStruct = (Map<String, Object>) struct.get(VdsProperties.GUEST_TIMEZONE);
        vm.setGuestOsTimezoneName(assignStringValue(guestTimeZoneStruct, VdsProperties.GUEST_TIMEZONE_ZONE));
        vm.setGuestOsTimezoneOffset(assignIntValue(guestTimeZoneStruct, VdsProperties.GUEST_TIMEZONE_OFFSET));
    }
}
#end_block

#method_before
private static GraphicsType parseGraphicsType(Map<String, Object> struct) {
    GraphicsType result = null;
    try {
        String displayTypeStr = struct.get(VdsProperties.displayType).toString();
        switch(displayTypeStr) {
            case VdsProperties.VNC:
                result = GraphicsType.VNC;
                break;
            case VdsProperties.QXL:
                result = GraphicsType.SPICE;
                break;
        }
    } catch (Exception e) {
    }
    return result;
}
#method_after
private static GraphicsType parseGraphicsType(Map<String, Object> struct) {
    GraphicsType result = null;
    try {
        String displayTypeStr = struct.get(VdsProperties.displayType).toString();
        switch(displayTypeStr) {
            case VdsProperties.VNC:
                result = GraphicsType.VNC;
                break;
            case VdsProperties.QXL:
                result = GraphicsType.SPICE;
                break;
        }
    } catch (Exception ignore) {
    }
    return result;
}
#end_block

#method_before
public static List<VmJob> buildVmJobsData(Map<String, Object> struct) {
    if (!struct.containsKey(VdsProperties.vmJobs)) {
        return null;
    }
    Guid vmId = new Guid((String) struct.get(VdsProperties.vm_guid));
    return ((Map<String, Object>) struct.get(VdsProperties.vmJobs)).values().stream().map(jobMap -> buildVmJobData(vmId, (Map<String, Object>) jobMap)).collect(toList());
}
#method_after
public static List<VmJob> buildVmJobsData(Map<String, Object> struct) {
    if (!struct.containsKey(VdsProperties.vmJobs)) {
        return null;
    }
    Guid vmId = new Guid((String) struct.get(VdsProperties.vm_guid));
    return ((Map<String, Object>) struct.get(VdsProperties.vmJobs)).values().stream().map(jobMap -> buildVmJobData(vmId, (Map<String, Object>) jobMap)).collect(Collectors.toList());
}
#end_block

#method_before
public static void updateVDSDynamicData(VDS vds, Map<String, Object> struct) {
    vds.setSupportedClusterLevels(assignStringValueFromArray(struct, VdsProperties.supported_cluster_levels));
    List<NameServer> nameServers = Stream.of(assignStringArrayValue(struct, VdsProperties.name_servers)).map(NameServer::new).collect(toList());
    vds.setDnsResolverConfiguration(new DnsResolverConfiguration(nameServers));
    updateNetworkData(vds, struct);
    updateNumaNodesData(vds, struct);
    vds.setCpuThreads(assignIntValue(struct, VdsProperties.cpuThreads));
    vds.setCpuCores(assignIntValue(struct, VdsProperties.cpu_cores));
    vds.setCpuSockets(assignIntValue(struct, VdsProperties.cpu_sockets));
    vds.setCpuModel(assignStringValue(struct, VdsProperties.cpu_model));
    vds.setOnlineCpus(assignStringValue(struct, VdsProperties.online_cpus));
    vds.setCpuSpeedMh(assignDoubleValue(struct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(assignIntValue(struct, VdsProperties.physical_mem_mb));
    vds.setKernelArgs(assignStringValue(struct, VdsProperties.kernel_args));
    vds.setKvmEnabled(assignBoolValue(struct, VdsProperties.kvm_enabled));
    vds.setReservedMem(assignIntValue(struct, VdsProperties.reservedMem));
    Integer guestOverhead = assignIntValue(struct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(assignStringValue(struct, VdsProperties.cpu_flags));
    updatePackagesVersions(vds, struct);
    vds.setSupportedEngines(assignStringValueFromArray(struct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(assignStringValue(struct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(assignStringValueFromArray(struct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, struct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (struct.containsKey(VdsProperties.hooks)) {
        hooksStr = struct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) struct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(assignLongValue(struct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(assignIntValue(struct, VdsProperties.KDUMP_STATUS)));
    vds.setHostDevicePassthroughEnabled(assignBoolValue(struct, VdsProperties.HOST_DEVICE_PASSTHROUGH));
    Map<String, Object> selinux = (Map<String, Object>) struct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(assignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
    vds.setHostedEngineConfigured(assignBoolValue(struct, VdsProperties.hosted_engine_configured));
    updateAdditionalFeatures(vds, struct);
}
#method_after
public static void updateVDSDynamicData(VDS vds, Map<String, Object> struct) {
    vds.setSupportedClusterLevels(assignStringValueFromArray(struct, VdsProperties.supported_cluster_levels));
    setDnsResolverConfigurationData(vds, struct);
    updateNetworkData(vds, struct);
    updateNumaNodesData(vds, struct);
    vds.setCpuThreads(assignIntValue(struct, VdsProperties.cpuThreads));
    vds.setCpuCores(assignIntValue(struct, VdsProperties.cpu_cores));
    vds.setCpuSockets(assignIntValue(struct, VdsProperties.cpu_sockets));
    vds.setCpuModel(assignStringValue(struct, VdsProperties.cpu_model));
    vds.setOnlineCpus(assignStringValue(struct, VdsProperties.online_cpus));
    vds.setCpuSpeedMh(assignDoubleValue(struct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(assignIntValue(struct, VdsProperties.physical_mem_mb));
    vds.setKernelArgs(assignStringValue(struct, VdsProperties.kernel_args));
    vds.setKvmEnabled(assignBoolValue(struct, VdsProperties.kvm_enabled));
    vds.setReservedMem(assignIntValue(struct, VdsProperties.reservedMem));
    Integer guestOverhead = assignIntValue(struct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(assignStringValue(struct, VdsProperties.cpu_flags));
    updatePackagesVersions(vds, struct);
    vds.setSupportedEngines(assignStringValueFromArray(struct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(assignStringValue(struct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(assignStringValueFromArray(struct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, struct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (struct.containsKey(VdsProperties.hooks)) {
        hooksStr = struct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) struct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(assignLongValue(struct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(assignIntValue(struct, VdsProperties.KDUMP_STATUS)));
    vds.setHostDevicePassthroughEnabled(assignBoolValue(struct, VdsProperties.HOST_DEVICE_PASSTHROUGH));
    Map<String, Object> selinux = (Map<String, Object>) struct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(assignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
    vds.setHostedEngineConfigured(assignBoolValue(struct, VdsProperties.hosted_engine_configured));
    updateAdditionalFeatures(vds, struct);
}
#end_block

#method_before
public static void checkTimeDrift(VDS vds, Map<String, Object> struct) {
    Boolean isHostTimeDriftEnabled = Config.getValue(ConfigValues.EnableHostTimeDrift);
    if (isHostTimeDriftEnabled) {
        Integer maxTimeDriftAllowed = Config.getValue(ConfigValues.HostTimeDriftInSec);
        Date hostDate = assignDatetimeValue(struct, VdsProperties.hostDatetime);
        if (hostDate != null) {
            Long timeDrift = TimeUnit.MILLISECONDS.toSeconds(Math.abs(hostDate.getTime() - System.currentTimeMillis()));
            if (timeDrift > maxTimeDriftAllowed) {
                AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase(vds.getId()));
                logable.addCustomValue("Actual", timeDrift.toString());
                logable.addCustomValue("Max", maxTimeDriftAllowed.toString());
                auditLogDirector.log(logable, AuditLogType.VDS_TIME_DRIFT_ALERT);
            }
        } else {
            log.error("Time Drift validation: failed to get Host or Engine time.");
        }
    }
}
#method_after
public static void checkTimeDrift(VDS vds, Map<String, Object> struct) {
    Boolean isHostTimeDriftEnabled = Config.getValue(ConfigValues.EnableHostTimeDrift);
    if (isHostTimeDriftEnabled) {
        Integer maxTimeDriftAllowed = Config.getValue(ConfigValues.HostTimeDriftInSec);
        Date hostDate = assignDatetimeValue(struct, VdsProperties.hostDatetime);
        if (hostDate != null) {
            Long timeDrift = TimeUnit.MILLISECONDS.toSeconds(Math.abs(hostDate.getTime() - System.currentTimeMillis()));
            if (timeDrift > maxTimeDriftAllowed) {
                AuditLogable logable = createAuditLogableForHost(vds);
                logable.addCustomValue("Actual", timeDrift.toString());
                logable.addCustomValue("Max", maxTimeDriftAllowed.toString());
                auditLogDirector.log(logable, AuditLogType.VDS_TIME_DRIFT_ALERT);
            }
        } else {
            log.error("Time Drift validation: failed to get Host or Engine time.");
        }
    }
}
#end_block

#method_before
protected static void updateLocalDisksUsage(VDS vds, Map<String, Object> struct) {
    if (struct.containsKey(VdsProperties.DISK_STATS)) {
        Map<String, Object> diskStatsStruct = (Map<String, Object>) struct.get(VdsProperties.DISK_STATS);
        Map<String, Long> diskStats = new HashMap<>();
        // collect(Collectors.toMap(...)) will not work here as it uses merge() internally and
        // will fail on null values
        diskStatsStruct.entrySet().stream().forEach(e -> diskStats.put(e.getKey(), assignLongValue((Map<String, Object>) e.getValue(), VdsProperties.DISK_STATS_FREE)));
        vds.setLocalDisksUsage(diskStats);
    }
}
#method_after
protected static void updateLocalDisksUsage(VDS vds, Map<String, Object> struct) {
    if (struct.containsKey(VdsProperties.DISK_STATS)) {
        Map<String, Object> diskStatsStruct = (Map<String, Object>) struct.get(VdsProperties.DISK_STATS);
        Map<String, Long> diskStats = new HashMap<>();
        // collect(Collectors.toMap(...)) will not work here as it uses merge() internally and
        // will fail on null values
        diskStatsStruct.entrySet().forEach(e -> diskStats.put(e.getKey(), assignLongValue((Map<String, Object>) e.getValue(), VdsProperties.DISK_STATS_FREE)));
        vds.setLocalDisksUsage(diskStats);
    }
}
#end_block

#method_before
private static Integer assignIntValue(Map input, String name) {
    if (input.containsKey(name)) {
        if (input.get(name) instanceof Integer) {
            return (Integer) input.get(name);
        }
        String stringValue = (String) input.get(name);
        if (StringUtils.isNotEmpty(stringValue)) {
            // in case the input
            // is decimal and we
            // need int.
            stringValue = stringValue.split("[.]", -1)[0];
        }
        try {
            int intValue = Integer.parseInt(stringValue);
            return intValue;
        } catch (NumberFormatException nfe) {
            log.error("Failed to parse '{}' value '{}' to integer: {}", name, stringValue, nfe.getMessage());
        }
    }
    return null;
}
#method_after
private static Integer assignIntValue(Map input, String name) {
    if (input.containsKey(name)) {
        if (input.get(name) instanceof Integer) {
            return (Integer) input.get(name);
        }
        String stringValue = (String) input.get(name);
        if (StringUtils.isNotEmpty(stringValue)) {
            // in case the input
            // is decimal and we
            // need int.
            stringValue = stringValue.split("[.]", -1)[0];
            try {
                return Integer.parseInt(stringValue);
            } catch (NumberFormatException nfe) {
                log.error("Failed to parse '{}' value '{}' to integer: {}", name, stringValue, nfe.getMessage());
            }
        }
    }
    return null;
}
#end_block

#method_before
private static Long assignLongValue(Map<String, Object> input, String name) {
    if (input.containsKey(name)) {
        if (input.get(name) instanceof Long || input.get(name) instanceof Integer) {
            return Long.parseLong(input.get(name).toString());
        }
        String stringValue = (String) ((input.get(name) instanceof String) ? input.get(name) : null);
        if (!StringUtils.isEmpty(stringValue)) {
            // in case the input
            // is decimal and we
            // need int.
            stringValue = stringValue.split("[.]", -1)[0];
        }
        try {
            return Long.parseLong(stringValue);
        } catch (NumberFormatException e) {
            log.error("Failed to parse '{}' value '{}' to long: {}", name, stringValue, e.getMessage());
        }
    }
    return null;
}
#method_after
private static Long assignLongValue(Map<String, Object> input, String name) {
    if (input.containsKey(name)) {
        if (input.get(name) instanceof Long || input.get(name) instanceof Integer) {
            return Long.parseLong(input.get(name).toString());
        }
        String stringValue = (String) ((input.get(name) instanceof String) ? input.get(name) : null);
        if (!StringUtils.isEmpty(stringValue)) {
            // in case the input
            // is decimal and we
            // need int.
            stringValue = stringValue.split("[.]", -1)[0];
            try {
                return Long.parseLong(stringValue);
            } catch (NumberFormatException e) {
                log.error("Failed to parse '{}' value '{}' to long: {}", name, stringValue, e.getMessage());
            }
        }
    }
    return null;
}
#end_block

#method_before
private static void reportInvalidInterfacesForNetwork(List<VdsNetworkInterface> interfaces, String networkName, VDS vds) {
    if (interfaces.isEmpty()) {
        auditLogDirector.log(createHostNetworkAuditLog(networkName, vds), AuditLogType.NETWORK_WITHOUT_INTERFACES);
    } else if (interfaces.size() > 1) {
        AuditLogableBase logable = createHostNetworkAuditLog(networkName, vds);
        logable.addCustomValue("Interfaces", interfaces.stream().map(VdsNetworkInterface::getName).collect(Collectors.joining(",")));
        auditLogDirector.log(logable, AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES);
    }
}
#method_after
private static void reportInvalidInterfacesForNetwork(List<VdsNetworkInterface> interfaces, String networkName, VDS vds) {
    if (interfaces.isEmpty()) {
        auditLogDirector.log(createHostNetworkAuditLog(networkName, vds), AuditLogType.NETWORK_WITHOUT_INTERFACES);
    } else if (interfaces.size() > 1) {
        AuditLogable logable = createHostNetworkAuditLog(networkName, vds);
        logable.addCustomValue("Interfaces", interfaces.stream().map(VdsNetworkInterface::getName).collect(Collectors.joining(",")));
        auditLogDirector.log(logable, AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES);
    }
}
#end_block

#method_before
protected static AuditLogableBase createHostNetworkAuditLog(String networkName, VDS vds) {
    AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase(vds.getId()));
    logable.addCustomValue("NetworkName", networkName);
    return logable;
}
#method_after
protected static AuditLogable createHostNetworkAuditLog(String networkName, VDS vds) {
    AuditLogable logable = createAuditLogableForHost(vds);
    logable.addCustomValue("NetworkName", networkName);
    return logable;
}
#end_block

#method_before
private static List<VdsNetworkInterface> findBridgedNetworkInterfaces(Map<String, Object> bridge, Map<String, VdsNetworkInterface> vdsInterfaces) {
    Object[] ports = (Object[]) bridge.get("ports");
    if (ports != null) {
        return Arrays.stream(ports).filter(port -> vdsInterfaces.containsKey(port.toString())).map(port -> vdsInterfaces.get(port.toString())).collect(toList());
    }
    return new ArrayList<>();
}
#method_after
private static List<VdsNetworkInterface> findBridgedNetworkInterfaces(Map<String, Object> bridge, Map<String, VdsNetworkInterface> vdsInterfaces) {
    Object[] ports = (Object[]) bridge.get("ports");
    if (ports != null) {
        return Arrays.stream(ports).filter(port -> vdsInterfaces.containsKey(port.toString())).map(port -> vdsInterfaces.get(port.toString())).collect(Collectors.toList());
    }
    return new ArrayList<>();
}
#end_block

#method_before
private static void addHostBondDevices(VDS vds, Map<String, Object> struct) {
    Map<String, Map<String, Object>> bonds = (Map<String, Map<String, Object>>) struct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        for (Entry<String, Map<String, Object>> entry : bonds.entrySet()) {
            Bond bond = new Bond();
            updateCommonInterfaceData(bond, vds, entry);
            bond.setBonded(true);
            Map<String, Object> bondProperties = entry.getValue();
            if (bondProperties != null) {
                bond.setMacAddress((String) bondProperties.get("hwaddr"));
                if (bondProperties.get("slaves") != null) {
                    addBondDeviceToHost(vds, bond, (Object[]) bondProperties.get("slaves"));
                }
                Object bondOptions = null;
                Map<String, Object> bondOptionsMap = new HashMap<>();
                Map<String, Object> bondOpts = (Map<String, Object>) bondProperties.get("opts");
                if (bondOpts != null) {
                    bondOptionsMap.putAll(bondOpts);
                }
                String bondOptionsString = "";
                String mode = (String) bondOptionsMap.get("mode");
                String miimon = (String) bondOptionsMap.get("miimon");
                if (mode != null && miimon != null) {
                    bondOptionsString = String.format("mode=%s miimon=%s", mode, miimon);
                    bondOptionsMap.remove("mode");
                    bondOptionsMap.remove("miimon");
                }
                for (Entry<String, Object> optionEntry : bondOptionsMap.entrySet()) {
                    bondOptionsString = String.format("%s %s=%s", bondOptionsString, optionEntry.getKey(), optionEntry.getValue());
                }
                bondOptions = bondOptionsString.isEmpty() ? null : bondOptionsString;
                if (bondOptions != null) {
                    bondOptions = normalizeBondOptions(bondOptions.toString());
                    bond.setBondOptions(bondOptions.toString());
                }
                bond.setAdPartnerMac((String) bondProperties.get("ad_partner_mac"));
                bond.setActiveSlave((String) bondProperties.get("active_slave"));
            }
        }
    }
}
#method_after
private static void addHostBondDevices(VDS vds, Map<String, Object> struct) {
    Map<String, Map<String, Object>> bonds = (Map<String, Map<String, Object>>) struct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        for (Entry<String, Map<String, Object>> entry : bonds.entrySet()) {
            Bond bond = new Bond();
            updateCommonInterfaceData(bond, vds, entry);
            bond.setBonded(true);
            Map<String, Object> bondProperties = entry.getValue();
            if (bondProperties != null) {
                bond.setMacAddress((String) bondProperties.get("hwaddr"));
                if (bondProperties.get("slaves") != null) {
                    addBondDeviceToHost(vds, bond, (Object[]) bondProperties.get("slaves"));
                }
                bond.setBondOptions(parseBondOptions((Map<String, Object>) bondProperties.get("opts")));
                bond.setAdPartnerMac((String) bondProperties.get("ad_partner_mac"));
                bond.setActiveSlave((String) bondProperties.get("active_slave"));
            }
        }
    }
}
#end_block

#method_before
private static <T> List<T> extractList(Map<String, Object> struct, String propertyName, boolean returnNullOnEmpty) {
    if (struct.containsKey(propertyName)) {
        Object[] items = (Object[]) struct.get(propertyName);
        if (items.length > 0) {
            return Arrays.stream(items).map(item -> (T) item).collect(toList());
        }
    }
    return returnNullOnEmpty ? null : Collections.emptyList();
}
#method_after
private static <T> List<T> extractList(Map<String, Object> struct, String propertyName, boolean returnNullOnEmpty) {
    if (struct.containsKey(propertyName)) {
        Object[] items = (Object[]) struct.get(propertyName);
        if (items.length > 0) {
            return Arrays.stream(items).map(item -> (T) item).collect(Collectors.toList());
        }
    }
    return returnNullOnEmpty ? null : Collections.emptyList();
}
#end_block

#method_before
private static void updateV2VJobs(VDS vds, Map<String, Object> struct) {
    if (!struct.containsKey(VdsProperties.v2vJobs)) {
        return;
    }
    List<V2VJobInfo> v2vJobs = ((Map<String, Object>) struct.get(VdsProperties.v2vJobs)).entrySet().stream().map(job -> buildV2VJobData(job.getKey(), (Map<String, Object>) job.getValue())).collect(toList());
    vds.getStatisticsData().setV2VJobs(v2vJobs);
}
#method_after
private static void updateV2VJobs(VDS vds, Map<String, Object> struct) {
    if (!struct.containsKey(VdsProperties.v2vJobs)) {
        return;
    }
    List<V2VJobInfo> v2vJobs = ((Map<String, Object>) struct.get(VdsProperties.v2vJobs)).entrySet().stream().map(job -> buildV2VJobData(job.getKey(), (Map<String, Object>) job.getValue())).collect(Collectors.toList());
    vds.getStatisticsData().setV2VJobs(v2vJobs);
}
#end_block

#method_before
public VDS clone() {
    VDS vds = new VDS();
    vds.setClusterId(getClusterId());
    vds.setClusterCpuName(getClusterCpuName());
    vds.setCpuName(getCpuName());
    vds.setClusterDescription(getClusterDescription());
    vds.setId(getId());
    vds.setVdsName(getName());
    vds.setHostName(getHostName());
    vds.setComment(getComment());
    vds.setPort(getPort());
    vds.setProtocol(getProtocol());
    vds.setSshPort(getSshPort());
    vds.setSshUsername(getSshUsername());
    vds.setStatus(getStatus());
    vds.setExternalStatus(getExternalStatus());
    vds.setHardwareManufacturer(getHardwareManufacturer());
    vds.setHardwareProductName(getHardwareProductName());
    vds.setHardwareVersion(getHardwareVersion());
    vds.setHardwareSerialNumber(getHardwareSerialNumber());
    vds.setHardwareUUID(getHardwareUUID());
    vds.setHardwareFamily(getHardwareFamily());
    vds.setCpuCores(getCpuCores());
    vds.setCpuThreads(getCpuThreads());
    vds.setCpuModel(getCpuModel());
    vds.setOnlineCpus(getOnlineCpus());
    vds.setCpuSpeedMh(getCpuSpeedMh());
    vds.setIfTotalSpeed(getIfTotalSpeed());
    vds.setKvmEnabled(getKvmEnabled());
    vds.setPhysicalMemMb(getPhysicalMemMb());
    vds.setCpuIdle(getCpuIdle());
    vds.setCpuLoad(getCpuLoad());
    vds.setCpuSys(getCpuSys());
    vds.setCpuUser(getCpuUser());
    vds.setMemCommited(getMemCommited());
    vds.setVmActive(getVmActive());
    vds.setVmCount(getVmCount());
    vds.setVmMigrating(getVmMigrating());
    vds.setUsageMemPercent(getUsageMemPercent());
    vds.setUsageCpuPercent(getUsageCpuPercent());
    vds.setUsageNetworkPercent(getUsageNetworkPercent());
    vds.setReservedMem(getReservedMem());
    vds.setBootTime(getBootTime());
    vds.setGuestOverhead(getGuestOverhead());
    vds.setPreviousStatus(getPreviousStatus());
    vds.setMemAvailable(getMemAvailable());
    vds.setMemShared(getMemShared());
    vds.setSoftwareVersion(getSoftwareVersion());
    vds.setVersionName(getVersionName());
    vds.setVersion(getVersion());
    vds.setServerSslEnabled(isServerSslEnabled());
    vds.setCpuFlags(getCpuFlags());
    vds.setNetConfigDirty(getNetConfigDirty());
    vds.setPmEnabled(isPmEnabled());
    vds.setPmKdumpDetection(isPmKdumpDetection());
    vds.setConsoleAddress(getConsoleAddress());
    vds.setHBAs(getHBAs());
    vds.setVdsSpmPriority(getVdsSpmPriority());
    vds.setOtpValidity(getOtpValidity());
    vds.setKernelVersion(getKernelVersion());
    vds.setKvmVersion(getKvmVersion());
    vds.setLibvirtVersion(getLibvirtVersion());
    vds.setGlusterfsCliVersion(getGlusterfsCliVersion());
    vds.setGlusterVersion(getGlusterVersion());
    vds.setLibrbdVersion(getLibrbdVersion());
    vds.setHooksStr(getHooksStr());
    vds.setActiveNic(getActiveNic());
    vds.setPowerManagementControlledByPolicy(isPowerManagementControlledByPolicy());
    vds.setDisablePowerManagementPolicy(isDisablePowerManagementPolicy());
    vds.setHighlyAvailableScore(getHighlyAvailableScore());
    vds.setHighlyAvailableIsConfigured(getHighlyAvailableIsConfigured());
    vds.setHighlyAvailableIsActive(getHighlyAvailableIsActive());
    vds.setHighlyAvailableGlobalMaintenance(getHighlyAvailableGlobalMaintenance());
    vds.setHighlyAvailableLocalMaintenance(getHighlyAvailableLocalMaintenance());
    vds.setBalloonEnabled(isBalloonEnabled());
    vds.setNumaNodeList(getNumaNodeList());
    vds.setAutoNumaBalancing(getAutoNumaBalancing());
    vds.setFenceAgents(getFenceAgents());
    vds.setClusterCompatibilityVersion(getClusterCompatibilityVersion());
    vds.setUpdateAvailable(isUpdateAvailable());
    vds.setHostDevicePassthroughEnabled(isHostDevicePassthroughEnabled());
    vds.setHostedEngineHost(isHostedEngineHost());
    vds.setCurrentKernelCmdline(getCurrentKernelCmdline());
    vds.setLastStoredKernelCmdline(getLastStoredKernelCmdline());
    vds.setKernelCmdlineParsable(isKernelCmdlineParsable());
    vds.setKernelCmdlineIommu(isKernelCmdlineIommu());
    vds.setKernelCmdlineKvmNested(isKernelCmdlineKvmNested());
    vds.setKernelCmdlinePciRealloc(isKernelCmdlinePciRealloc());
    vds.setKernelCmdlineUnsafeInterrupts(isKernelCmdlineUnsafeInterrupts());
    vds.setGlusterPeerStatus(getGlusterPeerStatus());
    return vds;
}
#method_after
public VDS clone() {
    VDS vds = new VDS();
    vds.setClusterId(getClusterId());
    vds.setClusterCpuName(getClusterCpuName());
    vds.setCpuName(getCpuName());
    vds.setClusterDescription(getClusterDescription());
    vds.setId(getId());
    vds.setVdsName(getName());
    vds.setHostName(getHostName());
    vds.setComment(getComment());
    vds.setPort(getPort());
    vds.setSshPort(getSshPort());
    vds.setSshUsername(getSshUsername());
    vds.setStatus(getStatus());
    vds.setExternalStatus(getExternalStatus());
    vds.setHardwareManufacturer(getHardwareManufacturer());
    vds.setHardwareProductName(getHardwareProductName());
    vds.setHardwareVersion(getHardwareVersion());
    vds.setHardwareSerialNumber(getHardwareSerialNumber());
    vds.setHardwareUUID(getHardwareUUID());
    vds.setHardwareFamily(getHardwareFamily());
    vds.setCpuCores(getCpuCores());
    vds.setCpuThreads(getCpuThreads());
    vds.setCpuModel(getCpuModel());
    vds.setOnlineCpus(getOnlineCpus());
    vds.setCpuSpeedMh(getCpuSpeedMh());
    vds.setIfTotalSpeed(getIfTotalSpeed());
    vds.setKvmEnabled(getKvmEnabled());
    vds.setPhysicalMemMb(getPhysicalMemMb());
    vds.setCpuIdle(getCpuIdle());
    vds.setCpuLoad(getCpuLoad());
    vds.setCpuSys(getCpuSys());
    vds.setCpuUser(getCpuUser());
    vds.setMemCommited(getMemCommited());
    vds.setVmActive(getVmActive());
    vds.setVmCount(getVmCount());
    vds.setVmMigrating(getVmMigrating());
    vds.setUsageMemPercent(getUsageMemPercent());
    vds.setUsageCpuPercent(getUsageCpuPercent());
    vds.setUsageNetworkPercent(getUsageNetworkPercent());
    vds.setReservedMem(getReservedMem());
    vds.setBootTime(getBootTime());
    vds.setGuestOverhead(getGuestOverhead());
    vds.setPreviousStatus(getPreviousStatus());
    vds.setMemAvailable(getMemAvailable());
    vds.setMemShared(getMemShared());
    vds.setSoftwareVersion(getSoftwareVersion());
    vds.setVersionName(getVersionName());
    vds.setVersion(getVersion());
    vds.setServerSslEnabled(isServerSslEnabled());
    vds.setCpuFlags(getCpuFlags());
    vds.setNetConfigDirty(getNetConfigDirty());
    vds.setPmEnabled(isPmEnabled());
    vds.setPmKdumpDetection(isPmKdumpDetection());
    vds.setConsoleAddress(getConsoleAddress());
    vds.setHBAs(getHBAs());
    vds.setVdsSpmPriority(getVdsSpmPriority());
    vds.setOtpValidity(getOtpValidity());
    vds.setKernelVersion(getKernelVersion());
    vds.setKvmVersion(getKvmVersion());
    vds.setLibvirtVersion(getLibvirtVersion());
    vds.setGlusterfsCliVersion(getGlusterfsCliVersion());
    vds.setGlusterVersion(getGlusterVersion());
    vds.setLibrbdVersion(getLibrbdVersion());
    vds.setHooksStr(getHooksStr());
    vds.setActiveNic(getActiveNic());
    vds.setPowerManagementControlledByPolicy(isPowerManagementControlledByPolicy());
    vds.setDisablePowerManagementPolicy(isDisablePowerManagementPolicy());
    vds.setHighlyAvailableScore(getHighlyAvailableScore());
    vds.setHighlyAvailableIsConfigured(getHighlyAvailableIsConfigured());
    vds.setHighlyAvailableIsActive(getHighlyAvailableIsActive());
    vds.setHighlyAvailableGlobalMaintenance(getHighlyAvailableGlobalMaintenance());
    vds.setHighlyAvailableLocalMaintenance(getHighlyAvailableLocalMaintenance());
    vds.setBalloonEnabled(isBalloonEnabled());
    vds.setNumaNodeList(getNumaNodeList());
    vds.setAutoNumaBalancing(getAutoNumaBalancing());
    vds.setFenceAgents(getFenceAgents());
    vds.setClusterCompatibilityVersion(getClusterCompatibilityVersion());
    vds.setUpdateAvailable(isUpdateAvailable());
    vds.setHostDevicePassthroughEnabled(isHostDevicePassthroughEnabled());
    vds.setHostedEngineHost(isHostedEngineHost());
    vds.setCurrentKernelCmdline(getCurrentKernelCmdline());
    vds.setLastStoredKernelCmdline(getLastStoredKernelCmdline());
    vds.setKernelCmdlineParsable(isKernelCmdlineParsable());
    vds.setKernelCmdlineIommu(isKernelCmdlineIommu());
    vds.setKernelCmdlineKvmNested(isKernelCmdlineKvmNested());
    vds.setKernelCmdlinePciRealloc(isKernelCmdlinePciRealloc());
    vds.setKernelCmdlineUnsafeInterrupts(isKernelCmdlineUnsafeInterrupts());
    vds.setGlusterPeerStatus(getGlusterPeerStatus());
    DnsResolverConfiguration originalDnsResolverConfiguration = getReportedDnsResolverConfiguration();
    if (originalDnsResolverConfiguration != null) {
        vds.setReportedDnsResolverConfiguration(new DnsResolverConfiguration(originalDnsResolverConfiguration));
    }
    return vds;
}
#end_block

#method_before
private List<VDS> uniteAgentsPreserveSpmPrioritySorting(List<VDS> vdsList) {
    List<VDS> results = uniteAgents(vdsList);
    // insure that list is ordered according to SPM priority DESC
    Collections.sort(results, new HostSpmPriorityComparator());
    return results;
}
#method_after
private List<VDS> uniteAgentsPreserveSpmPrioritySorting(List<VDS> vdsList) {
    List<VDS> results = uniteAgents(vdsList);
    // Ensure that the list is ordered according to SPM priority DESC
    Collections.sort(results, new HostSpmPriorityComparator());
    return results;
}
#end_block

#method_before
@Override
public Network get(Guid networkId, Guid userID, boolean isFiltered) {
    return getCallsHandler().executeRead(getProcedureNameForGet(), NetworkRowMapper.instance, getCustomMapSqlParameterSource().addValue("id", networkId).addValue("user_id", userID).addValue("is_filtered", isFiltered));
}
#method_after
@Override
public Network get(Guid networkId, Guid userID, boolean isFiltered) {
    return getCallsHandler().executeRead(getProcedureNameForGet(), networkRowMapper, getCustomMapSqlParameterSource().addValue("id", networkId).addValue("user_id", userID).addValue("is_filtered", isFiltered));
}
#end_block

#method_before
@Override
public Network getByName(String name) {
    return getCallsHandler().executeRead("GetnetworkByName", NetworkRowMapper.instance, getCustomMapSqlParameterSource().addValue("networkName", name));
}
#method_after
@Override
public Network getByName(String name) {
    return getCallsHandler().executeRead("GetnetworkByName", networkRowMapper, getCustomMapSqlParameterSource().addValue("networkName", name));
}
#end_block

#method_before
@Override
public Network getByNameAndDataCenter(String name, Guid storagePoolId) {
    return getCallsHandler().executeRead("GetNetworkByNameAndDataCenter", NetworkRowMapper.instance, getCustomMapSqlParameterSource().addValue("name", name).addValue("storage_pool_id", storagePoolId));
}
#method_after
@Override
public Network getByNameAndDataCenter(String name, Guid storagePoolId) {
    return getCallsHandler().executeRead("GetNetworkByNameAndDataCenter", networkRowMapper, getCustomMapSqlParameterSource().addValue("name", name).addValue("storage_pool_id", storagePoolId));
}
#end_block

#method_before
@Override
public Network getByNameAndCluster(String name, Guid clusterId) {
    return getCallsHandler().executeRead("GetNetworkByNameAndCluster", NetworkRowMapper.instance, getCustomMapSqlParameterSource().addValue("name", name).addValue("cluster_id", clusterId));
}
#method_after
@Override
public Network getByNameAndCluster(String name, Guid clusterId) {
    return getCallsHandler().executeRead("GetNetworkByNameAndCluster", networkRowMapper, getCustomMapSqlParameterSource().addValue("name", name).addValue("cluster_id", clusterId));
}
#end_block

#method_before
@Override
public List<Network> getAll(Guid userID, boolean isFiltered) {
    return getCallsHandler().executeReadList("GetAllFromnetwork", NetworkRowMapper.instance, getCustomMapSqlParameterSource().addValue("user_id", userID).addValue("is_filtered", isFiltered));
}
#method_after
@Override
public List<Network> getAll(Guid userID, boolean isFiltered) {
    return getCallsHandler().executeReadList("GetAllFromnetwork", networkRowMapper, getCustomMapSqlParameterSource().addValue("user_id", userID).addValue("is_filtered", isFiltered));
}
#end_block

#method_before
@Override
public List<Network> getAllForDataCenter(Guid id, Guid userID, boolean isFiltered) {
    return getCallsHandler().executeReadList("GetAllNetworkByStoragePoolId", NetworkRowMapper.instance, getCustomMapSqlParameterSource().addValue("id", id).addValue("user_id", userID).addValue("is_filtered", isFiltered));
}
#method_after
@Override
public List<Network> getAllForDataCenter(Guid id, Guid userID, boolean isFiltered) {
    return getCallsHandler().executeReadList("GetAllNetworkByStoragePoolId", networkRowMapper, getCustomMapSqlParameterSource().addValue("id", id).addValue("user_id", userID).addValue("is_filtered", isFiltered));
}
#end_block

#method_before
@Override
public List<Network> getAllForCluster(Guid id, Guid userID, boolean isFiltered) {
    return getCallsHandler().executeReadList("GetAllNetworkByClusterId", NetworkClusterRowMapper.INSTANCE, getCustomMapSqlParameterSource().addValue("id", id).addValue("user_id", userID).addValue("is_filtered", isFiltered));
}
#method_after
@Override
public List<Network> getAllForCluster(Guid id, Guid userID, boolean isFiltered) {
    return getCallsHandler().executeReadList("GetAllNetworkByClusterId", networkClusterRowMapper, getCustomMapSqlParameterSource().addValue("id", id).addValue("user_id", userID).addValue("is_filtered", isFiltered));
}
#end_block

#method_before
@Override
public List<Network> getAllForQos(Guid qosId) {
    return getCallsHandler().executeReadList("GetAllNetworksByQosId", NetworkRowMapper.instance, createIdParameterMapper(qosId));
}
#method_after
@Override
public List<Network> getAllForQos(Guid qosId) {
    return getCallsHandler().executeReadList("GetAllNetworksByQosId", networkRowMapper, createIdParameterMapper(qosId));
}
#end_block

#method_before
@Override
public List<Network> getAllForProvider(Guid id) {
    return getCallsHandler().executeReadList("GetAllNetworksByNetworkProviderId", NetworkRowMapper.instance, createIdParameterMapper(id));
}
#method_after
@Override
public List<Network> getAllForProvider(Guid id) {
    return getCallsHandler().executeReadList("GetAllNetworksByNetworkProviderId", networkRowMapper, createIdParameterMapper(id));
}
#end_block

#method_before
@Override
public Network getManagementNetwork(Guid clusterId) {
    return getCallsHandler().executeRead("GetManagementNetworkByCluster", NetworkRowMapper.instance, getCustomMapSqlParameterSource().addValue("cluster_id", clusterId));
}
#method_after
@Override
public Network getManagementNetwork(Guid clusterId) {
    return getCallsHandler().executeRead("GetManagementNetworkByCluster", networkRowMapper, getCustomMapSqlParameterSource().addValue("cluster_id", clusterId));
}
#end_block

#method_before
@Override
public List<Network> getManagementNetworks(Guid dataCenterId) {
    return getCallsHandler().executeReadList("GetAllManagementNetworksByDataCenterId", NetworkRowMapper.instance, getCustomMapSqlParameterSource().addValue("data_center_id", dataCenterId));
}
#method_after
@Override
public List<Network> getManagementNetworks(Guid dataCenterId) {
    return getCallsHandler().executeReadList("GetAllManagementNetworksByDataCenterId", networkRowMapper, getCustomMapSqlParameterSource().addValue("data_center_id", dataCenterId));
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(Network network) {
    return getCustomMapSqlParameterSource().addValue("addr", network.getAddr()).addValue("description", network.getDescription()).addValue("free_text_comment", network.getComment()).addValue("id", network.getId()).addValue("name", network.getName()).addValue("subnet", network.getSubnet()).addValue("gateway", network.getGateway()).addValue("type", network.getType()).addValue("vlan_id", network.getVlanId()).addValue("stp", network.getStp()).addValue("storage_pool_id", network.getDataCenterId()).addValue("mtu", network.getMtu()).addValue("vm_network", network.isVmNetwork()).addValue("provider_network_provider_id", network.getProvidedBy() == null ? null : network.getProvidedBy().getProviderId()).addValue("provider_network_external_id", network.getProvidedBy() == null ? null : network.getProvidedBy().getExternalId()).addValue("qos_id", network.getQosId()).addValue("label", network.getLabel()).addValue("name_servers", new DnsResolverConfigurationMapper().getNameServersString(network.getDnsResolverConfiguration()));
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(Network network) {
    return getCustomMapSqlParameterSource().addValue("addr", network.getAddr()).addValue("description", network.getDescription()).addValue("free_text_comment", network.getComment()).addValue("id", network.getId()).addValue("name", network.getName()).addValue("subnet", network.getSubnet()).addValue("gateway", network.getGateway()).addValue("type", network.getType()).addValue("vlan_id", network.getVlanId()).addValue("stp", network.getStp()).addValue("storage_pool_id", network.getDataCenterId()).addValue("mtu", network.getMtu()).addValue("vm_network", network.isVmNetwork()).addValue("provider_network_provider_id", network.getProvidedBy() == null ? null : network.getProvidedBy().getProviderId()).addValue("provider_network_external_id", network.getProvidedBy() == null ? null : network.getProvidedBy().getExternalId()).addValue("qos_id", network.getQosId()).addValue("label", network.getLabel()).addValue("dns_resolver_configuration_id", getDnsResolverConfigurationId(network));
}
#end_block

#method_before
@Override
protected RowMapper<Network> createEntityRowMapper() {
    return NetworkRowMapper.instance;
}
#method_after
@Override
protected RowMapper<Network> createEntityRowMapper() {
    return networkRowMapper;
}
#end_block

#method_before
@Override
public Network mapRow(ResultSet rs, int rowNum) throws SQLException {
    Network entity = super.mapRow(rs, rowNum);
    entity.setCluster(new NetworkCluster());
    entity.getCluster().setDisplay((Boolean) rs.getObject("is_display"));
    entity.getCluster().setRequired(rs.getBoolean("required"));
    entity.getCluster().setStatus(NetworkStatus.forValue(rs.getInt("status")));
    entity.getCluster().setMigration(rs.getBoolean("migration"));
    entity.getCluster().setManagement(rs.getBoolean("management"));
    entity.getCluster().setGluster(rs.getBoolean("is_gluster"));
    return entity;
}
#method_after
@Override
public Network mapRow(ResultSet rs, int rowNum) throws SQLException {
    Network entity = super.mapRow(rs, rowNum);
    entity.setCluster(new NetworkCluster());
    entity.getCluster().setDisplay((Boolean) rs.getObject("is_display"));
    entity.getCluster().setRequired(rs.getBoolean("required"));
    entity.getCluster().setStatus(NetworkStatus.forValue(rs.getInt("status")));
    entity.getCluster().setMigration(rs.getBoolean("migration"));
    entity.getCluster().setManagement(rs.getBoolean("management"));
    entity.getCluster().setGluster(rs.getBoolean("is_gluster"));
    entity.getCluster().setDefaultRoute(rs.getBoolean("default_route"));
    return entity;
}
#end_block

#method_before
@Override
public T mapRow(ResultSet rs, int rowNum) throws SQLException {
    T entity = createNetworkEntity();
    entity.setId(getGuidDefaultEmpty(rs, "id"));
    entity.setName(rs.getString("name"));
    entity.setDescription(rs.getString("description"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setType((Integer) rs.getObject("type"));
    entity.setAddr(rs.getString("addr"));
    entity.setSubnet(rs.getString("subnet"));
    entity.setGateway(rs.getString("gateway"));
    entity.setVlanId((Integer) rs.getObject("vlan_id"));
    entity.setStp(rs.getBoolean("stp"));
    entity.setDataCenterId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setMtu(rs.getInt("mtu"));
    entity.setVmNetwork(rs.getBoolean("vm_network"));
    Guid providerId = getGuid(rs, "provider_network_provider_id");
    if (providerId != null) {
        entity.setProvidedBy(new ProviderNetwork(providerId, rs.getString("provider_network_external_id")));
    }
    entity.setQosId(getGuid(rs, "qos_id"));
    entity.setLabel(rs.getString("label"));
    entity.setDnsResolverConfiguration(new DnsResolverConfigurationMapper().parseNameServersString(rs.getString("name_servers")));
    return entity;
}
#method_after
@Override
public T mapRow(ResultSet rs, int rowNum) throws SQLException {
    T entity = createNetworkEntity();
    entity.setId(getGuidDefaultEmpty(rs, "id"));
    entity.setName(rs.getString("name"));
    entity.setDescription(rs.getString("description"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setType((Integer) rs.getObject("type"));
    entity.setAddr(rs.getString("addr"));
    entity.setSubnet(rs.getString("subnet"));
    entity.setGateway(rs.getString("gateway"));
    entity.setVlanId((Integer) rs.getObject("vlan_id"));
    entity.setStp(rs.getBoolean("stp"));
    entity.setDataCenterId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setMtu(rs.getInt("mtu"));
    entity.setVmNetwork(rs.getBoolean("vm_network"));
    Guid providerId = getGuid(rs, "provider_network_provider_id");
    if (providerId != null) {
        entity.setProvidedBy(new ProviderNetwork(providerId, rs.getString("provider_network_external_id")));
    }
    entity.setQosId(getGuid(rs, "qos_id"));
    entity.setLabel(rs.getString("label"));
    Guid dnsResolverConfigurationId = getGuid(rs, "dns_resolver_configuration_id");
    entity.setDnsResolverConfiguration(dnsResolverConfigurationDao.get(dnsResolverConfigurationId));
    return entity;
}
#end_block

#method_before
@Override
public String getComment() {
    return comment;
}
#method_after
public String getComment() {
    return comment;
}
#end_block

#method_before
@Override
public void setComment(String value) {
    comment = value;
}
#method_after
public void setComment(String value) {
    comment = value;
}
#end_block

#method_before
@Override
public String toString() {
    return ToStringBuilder.forInstance(this).append("id", getId()).append("description", getDescription()).append("comment", getComment()).append("subnet", getSubnet()).append("gateway", getGateway()).append("type", getType()).append("vlanId", getVlanId()).append("stp", getStp()).append("dataCenterId", getDataCenterId()).append("mtu", getMtu()).append("vmNetwork", isVmNetwork()).append("cluster", getCluster()).append("providedBy", getProvidedBy()).append("label", getLabel()).append("qosId", getQosId()).build();
}
#method_after
@Override
public String toString() {
    return ToStringBuilder.forInstance(this).append("id", getId()).append("description", getDescription()).append("comment", getComment()).append("subnet", getSubnet()).append("gateway", getGateway()).append("type", getType()).append("vlanId", getVlanId()).append("stp", getStp()).append("dataCenterId", getDataCenterId()).append("mtu", getMtu()).append("vmNetwork", isVmNetwork()).append("cluster", getCluster()).append("providedBy", getProvidedBy()).append("label", getLabel()).append("qosId", getQosId()).append("dnsResolverConfiguration", dnsResolverConfiguration).build();
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(addr, // cluster,
    description, gateway, id, name, dataCenterId, stp, subnet, type, vlanId, mtu, vmNetwork, providedBy, label, qosId);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(addr, // cluster,
    description, gateway, id, name, dataCenterId, stp, subnet, type, vlanId, mtu, vmNetwork, providedBy, label, qosId, dnsResolverConfiguration);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof Network)) {
        return false;
    }
    Network other = (Network) obj;
    return Objects.equals(addr, other.addr) && // && Objects.equals(cluster, other.cluster)
    Objects.equals(description, other.description) && Objects.equals(gateway, other.gateway) && Objects.equals(id, other.id) && Objects.equals(name, other.name) && Objects.equals(dataCenterId, other.dataCenterId) && stp == other.stp && Objects.equals(subnet, other.subnet) && Objects.equals(type, other.type) && Objects.equals(vlanId, other.vlanId) && mtu == other.mtu && vmNetwork == other.vmNetwork && Objects.equals(providedBy, other.providedBy) && Objects.equals(label, other.label) && Objects.equals(qosId, other.qosId);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof Network)) {
        return false;
    }
    Network other = (Network) obj;
    return Objects.equals(addr, other.addr) && // && Objects.equals(cluster, other.cluster)
    Objects.equals(description, other.description) && Objects.equals(gateway, other.gateway) && Objects.equals(id, other.id) && Objects.equals(name, other.name) && Objects.equals(dataCenterId, other.dataCenterId) && stp == other.stp && Objects.equals(subnet, other.subnet) && Objects.equals(type, other.type) && Objects.equals(vlanId, other.vlanId) && mtu == other.mtu && vmNetwork == other.vmNetwork && Objects.equals(providedBy, other.providedBy) && Objects.equals(label, other.label) && Objects.equals(qosId, other.qosId) && Objects.equals(dnsResolverConfiguration, other.dnsResolverConfiguration);
}
#end_block

#method_before
@Override
public void remove(Guid id) {
    hostNetworkQosDao.remove(id);
    super.remove(id);
}
#method_after
@Override
public void remove(Guid id) {
    hostNetworkQosDao.remove(id);
    dnsResolverConfigurationDao.removeByNetworkAttachmentId(id);
    super.remove(id);
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(NetworkAttachment networkAttachment) {
    MapSqlParameterSource mapper = createIdParameterMapper(networkAttachment.getId()).addValue("network_id", networkAttachment.getNetworkId()).addValue("nic_id", networkAttachment.getNicId()).addValue("custom_properties", SerializationFactory.getSerializer().serialize(networkAttachment.getProperties()));
    mapIpConfiguration(networkAttachment, mapper);
    mapper.addValue("name_servers", new DnsResolverConfigurationMapper().getNameServersString(networkAttachment.getDnsResolverConfiguration()));
    return mapper;
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(NetworkAttachment networkAttachment) {
    MapSqlParameterSource mapper = createIdParameterMapper(networkAttachment.getId()).addValue("network_id", networkAttachment.getNetworkId()).addValue("nic_id", networkAttachment.getNicId()).addValue("custom_properties", SerializationFactory.getSerializer().serialize(networkAttachment.getProperties()));
    mapIpConfiguration(networkAttachment, mapper);
    mapper.addValue("dns_resolver_configuration_id", getDnsResolverConfigurationId(networkAttachment));
    return mapper;
}
#end_block

#method_before
@Override
public void save(NetworkAttachment entity) {
    verifyRelationWithHostNetworkQos(entity);
    hostNetworkQosDao.persistQosChanges(entity.getId(), asHostNetworkQos(entity.getHostNetworkQos()));
    super.save(entity);
}
#method_after
@Override
public void save(NetworkAttachment entity) {
    verifyRelationWithHostNetworkQos(entity);
    hostNetworkQosDao.persistQosChanges(entity.getId(), asHostNetworkQos(entity.getHostNetworkQos()));
    DnsResolverConfiguration dnsResolverConfiguration = entity.getDnsResolverConfiguration();
    if (dnsResolverConfiguration != null) {
        dnsResolverConfigurationDao.save(dnsResolverConfiguration);
    }
    super.save(entity);
}
#end_block

#method_before
@Override
public void update(NetworkAttachment entity) {
    verifyRelationWithHostNetworkQos(entity);
    hostNetworkQosDao.persistQosChanges(entity.getId(), asHostNetworkQos(entity.getHostNetworkQos()));
    super.update(entity);
}
#method_after
@Override
public void update(NetworkAttachment entity) {
    verifyRelationWithHostNetworkQos(entity);
    hostNetworkQosDao.persistQosChanges(entity.getId(), asHostNetworkQos(entity.getHostNetworkQos()));
    DnsResolverConfiguration dnsResolverConfiguration = entity.getDnsResolverConfiguration();
    if (dnsResolverConfiguration == null) {
        dnsResolverConfigurationDao.removeByNetworkAttachmentId(entity.getId());
    } else {
        if (dnsResolverConfiguration.getId() == null) {
            dnsResolverConfigurationDao.save(dnsResolverConfiguration);
        } else {
            dnsResolverConfigurationDao.update(dnsResolverConfiguration);
        }
    }
    super.update(entity);
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (!(o instanceof DnsResolverConfiguration)) {
        return false;
    }
    DnsResolverConfiguration that = (DnsResolverConfiguration) o;
    return Objects.equals(getNameServers(), that.getNameServers());
}
#method_after
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (!(o instanceof DnsResolverConfiguration)) {
        return false;
    }
    DnsResolverConfiguration that = (DnsResolverConfiguration) o;
    return Objects.equals(getId(), that.getId()) && Objects.equals(getNameServers(), that.getNameServers());
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(getNameServers());
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(getId(), getNameServers());
}
#end_block

#method_before
public String toString() {
    return ToStringBuilder.forInstance(this).append("nameServers", getNameServers()).build();
}
#method_after
public String toString() {
    return ToStringBuilder.forInstance(this).append("id", getId()).append("nameServers", getNameServers()).build();
}
#end_block

#method_before
public static <T> List<String> validateInputs(List<Class<?>> validationGroupList, T parameters) {
    List<String> messages = Collections.emptyList();
    Set<ConstraintViolation<T>> violations = ValidationUtils.getValidator().validate(parameters, validationGroupList.toArray(new Class<?>[validationGroupList.size()]));
    if (!violations.isEmpty()) {
        messages = new ArrayList<>(violations.size());
        for (ConstraintViolation<T> constraintViolation : violations) {
            messages.add(constraintViolation.getMessage());
            ConstraintDescriptor<?> constraintDescriptor = constraintViolation.getConstraintDescriptor();
            // these values can later be used for formatting the returned messages.
            if (constraintDescriptor != null) {
                Map<String, Object> violationAttributes = constraintDescriptor.getAttributes();
                for (Map.Entry violationAttribute : violationAttributes.entrySet()) {
                    String message = String.format("$%s %s", violationAttribute.getKey(), violationAttribute.getValue());
                    messages.add(message);
                }
            }
            if (constraintViolation.getPropertyPath() != null) {
                messages.add(EngineMessage.ACTION_TYPE_FAILED_ATTRIBUTE_PATH.name());
                messages.add(String.format("$path %s", constraintViolation.getPropertyPath()));
            }
        }
    }
    return messages;
}
#method_after
public static <T> List<String> validateInputs(List<Class<?>> validationGroupList, T parameters) {
    List<String> messages = Collections.emptyList();
    Set<ConstraintViolation<T>> violations = ValidationUtils.getValidator().validate(parameters, validationGroupList.toArray(new Class<?>[validationGroupList.size()]));
    if (!violations.isEmpty()) {
        messages = new ArrayList<>(violations.size());
        for (ConstraintViolation<T> constraintViolation : violations) {
            messages.add(constraintViolation.getMessage());
            ConstraintDescriptor<?> constraintDescriptor = constraintViolation.getConstraintDescriptor();
            // these values can later be used for formatting the returned messages.
            if (constraintDescriptor != null) {
                Map<String, Object> violationAttributes = constraintDescriptor.getAttributes();
                for (Map.Entry violationAttribute : violationAttributes.entrySet()) {
                    String propertyName = violationAttribute.getKey().toString();
                    Object value = violationAttribute.getValue();
                    messages.add(createSetVariableString(propertyName, value));
                }
            }
            if (constraintViolation.getPropertyPath() != null) {
                messages.add(EngineMessage.ACTION_TYPE_FAILED_ATTRIBUTE_PATH.name());
                messages.add(createSetVariableString("path", constraintViolation.getPropertyPath()));
            }
            messages.add(createSetVariableString("validatedValue", constraintViolation.getInvalidValue()));
        }
    }
    return messages;
}
#end_block

#method_before
protected void log() {
    final Transaction transaction = TransactionSupport.suspend();
    try {
        try {
            auditLogDirector.log(this, getAuditLogTypeValue());
        } catch (final RuntimeException ex) {
            log.error("Error during log command: {}. Exception {}", getClass().getName(), ex.getMessage());
            log.debug("Exception", ex);
        }
    } finally {
        TransactionSupport.resume(transaction);
    }
}
#method_after
protected void log() {
    final Transaction transaction = TransactionSupport.suspend();
    try {
        auditLogDirector.log(this, getAuditLogTypeValue());
    } catch (final RuntimeException ex) {
        log.error("Error during log command: {}. Exception {}", getClass().getName(), ex.getMessage());
        log.debug("Exception", ex);
    } finally {
        TransactionSupport.resume(transaction);
    }
}
#end_block

#method_before
@Override
protected void init() {
    cachedParamsToDisks = getParameters().getParametersList().stream().collect(Collectors.toMap(Function.identity(), p -> diskImageDao.get(p.getImageId())));
}
#method_after
@Override
protected void init() {
    super.init();
    cachedParamsToDisks = getParameters().getParametersList().stream().collect(Collectors.toMap(Function.identity(), p -> diskImageDao.get(p.getImageId())));
}
#end_block

#method_before
public void logAuditMessage(final Guid clusterId, final GlusterVolumeEntity volume, final VDS server, final AuditLogType logType, final Map<String, String> customValues) {
    AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase());
    logable.setVds(server);
    logable.setGlusterVolume(volume);
    logable.setClusterId(clusterId);
    if (customValues != null) {
        customValues.entrySet().stream().forEach(e -> logable.addCustomValue(e.getKey(), e.getValue()));
    }
    auditLogDirector.log(logable, logType);
}
#method_after
public void logAuditMessage(final Guid clusterId, final GlusterVolumeEntity volume, final VDS server, final AuditLogType logType, final Map<String, String> customValues) {
    AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase());
    logable.setVds(server);
    logable.setGlusterVolume(volume);
    logable.setClusterId(clusterId);
    if (customValues != null) {
        customValues.entrySet().forEach(e -> logable.addCustomValue(e.getKey(), e.getValue()));
    }
    auditLogDirector.log(logable, logType);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    List<VdsSpmIdMap> vdsSpmIdMapList = vdsSpmIdMapDao.getAll(getDcId());
    if (vdsSpmIdMapList.size() >= Config.<Integer>getValue(ConfigValues.MaxNumberOfHostsInStoragePool)) {
        buildFaultResult();
        return;
    }
    insertSpmIdToDb(vdsSpmIdMapList);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    List<VdsSpmIdMap> vdsSpmIdMapList = vdsSpmIdMapDao.getAll(getVds().getStoragePoolId());
    if (vdsSpmIdMapList.size() >= Config.<Integer>getValue(ConfigValues.MaxNumberOfHostsInStoragePool)) {
        buildFaultResult();
        return;
    }
    insertSpmIdToDb(vdsSpmIdMapList);
    setSucceeded(true);
}
#end_block

#method_before
protected void insertSpmIdToDb(List<VdsSpmIdMap> vdsSpmIdMapList) {
    int selectedId = 1;
    List<Integer> list = vdsSpmIdMapList.stream().map(VdsSpmIdMap::getVdsSpmId).sorted().collect(Collectors.toList());
    for (int id : list) {
        if (selectedId == id) {
            selectedId++;
        } else {
            break;
        }
    }
    VdsSpmIdMap newMap = new VdsSpmIdMap(getDcId(), getVdsId(), selectedId);
    vdsSpmIdMapDao.save(newMap);
    if (getParameters().isCompensationEnabled()) {
        getCompensationContext().snapshotNewEntity(newMap);
        getCompensationContext().stateChanged();
    }
}
#method_after
protected void insertSpmIdToDb(List<VdsSpmIdMap> vdsSpmIdMapList) {
    int selectedId = 1;
    List<Integer> list = vdsSpmIdMapList.stream().map(VdsSpmIdMap::getVdsSpmId).sorted().collect(Collectors.toList());
    for (int id : list) {
        if (selectedId == id) {
            selectedId++;
        } else {
            break;
        }
    }
    // get the dc id from cluster if DC was removed and cluster is attached to a new DC
    Guid dcId = getVds().getStoragePoolId().equals(Guid.Empty) ? getCluster().getStoragePoolId() : getVds().getStoragePoolId();
    VdsSpmIdMap newMap = new VdsSpmIdMap(dcId, getVdsId(), selectedId);
    vdsSpmIdMapDao.save(newMap);
    if (getParameters().isCompensationEnabled()) {
        getCompensationContext().snapshotNewEntity(newMap);
        getCompensationContext().stateChanged();
    }
}
#end_block

#method_before
protected void alertIfFencingDisabled() {
    if (!getCluster().getFencingPolicy().isFencingEnabled()) {
        AuditLogableBase alb = Injector.injectMembers(new AuditLogableBase());
        alb.setClusterId(getCluster().getId());
        alb.setRepeatable(true);
        auditLogDirector.log(alb, AuditLogType.FENCE_DISABLED_IN_CLUSTER_POLICY);
    }
}
#method_after
protected void alertIfFencingDisabled() {
    if (!getCluster().getFencingPolicy().isFencingEnabled()) {
        AuditLogable alb = new AuditLogableImpl();
        alb.setClusterId(getCluster().getId());
        alb.setClusterName(getCluster().getName());
        alb.setRepeatable(true);
        auditLogDirector.log(alb, AuditLogType.FENCE_DISABLED_IN_CLUSTER_POLICY);
    }
}
#end_block

#method_before
@Override
protected boolean validateInputManagementNetwork() {
    if (!findInputManagementNetwork())
        return false;
    final NetworkClusterValidatorBase networkClusterValidator = createNetworkClusterValidator();
    return validate(networkClusterValidator.networkBelongsToClusterDataCenter(getCluster(), managementNetwork)) && validate(networkClusterValidator.managementNetworkRequired(managementNetwork)) && validate(networkClusterValidator.managementNetworkNotExternal(managementNetwork));
}
#method_after
@Override
protected boolean validateInputManagementNetwork() {
    if (!findInputManagementNetwork()) {
        return false;
    }
    final NetworkClusterValidatorBase networkClusterValidator = createNetworkClusterValidator();
    return validate(networkClusterValidator.networkBelongsToClusterDataCenter(getCluster(), managementNetwork)) && validate(networkClusterValidator.managementNetworkRequired(managementNetwork)) && validate(networkClusterValidator.managementNetworkNotExternal(managementNetwork));
}
#end_block

#method_before
private AddClusterNetworkClusterValidator createNetworkClusterValidator() {
    final NetworkCluster networkCluster = createManagementNetworkCluster();
    return new AddClusterNetworkClusterValidator(interfaceDao, networkDao, vdsDao, networkCluster);
}
#method_after
private AddClusterNetworkClusterValidator createNetworkClusterValidator() {
    final NetworkCluster networkCluster = createManagementNetworkCluster();
    return new AddClusterNetworkClusterValidator(interfaceDao, getNetworkDao(), vdsDao, networkCluster);
}
#end_block

#method_before
private void updateVmDeviceWithDataReturnedFromHost(VDSReturnValue vdsReturnValue) {
    if (vdsReturnValue.getSucceeded() && getParameters().getAction() == PlugAction.PLUG) {
        VmInfoReturn vmInfoReturn = (VmInfoReturn) vdsReturnValue.getReturnValue();
        if (vmInfoReturn.getVmInfo() != null) {
            Map<String, Object> vmInfo = (Map<String, Object>) vmInfoReturn.getVmInfo();
            for (Object o : (Object[]) vmInfo.get(VdsProperties.Devices)) {
                Map<String, Object> vdsmDevice = (Map<String, Object>) o;
                if (vmDevice.getId().getDeviceId().toString().equals((String) vdsmDevice.get(VdsProperties.DeviceId))) {
                    vmDevice.setAddress(vdsmDevice.get(VdsProperties.Address).toString());
                    vmDevice.setAlias(StringUtils.defaultString((String) vdsmDevice.get(VdsProperties.Alias)));
                }
            }
        }
    }
}
#method_after
private void updateVmDeviceWithDataReturnedFromHost(VDSReturnValue vdsReturnValue) {
    if (vdsReturnValue.getSucceeded() && getParameters().getAction() == PlugAction.PLUG) {
        VmInfoReturn vmInfoReturn = (VmInfoReturn) vdsReturnValue.getReturnValue();
        if (vmInfoReturn.getVmInfo() != null) {
            Map<String, Object> vmInfo = (Map<String, Object>) vmInfoReturn.getVmInfo();
            for (Object o : (Object[]) vmInfo.get(VdsProperties.Devices)) {
                Map<String, Object> vdsmDevice = (Map<String, Object>) o;
                if (vmDevice.getId().getDeviceId().toString().equals(vdsmDevice.get(VdsProperties.DeviceId))) {
                    vmDevice.setAddress(vdsmDevice.get(VdsProperties.Address).toString());
                    vmDevice.setAlias(StringUtils.defaultString((String) vdsmDevice.get(VdsProperties.Alias)));
                }
            }
        }
    }
}
#end_block

#method_before
private void spySdValidator() {
    Set<Guid> sdIds = new HashSet<>(Collections.singletonList(STORAGE_DOMAIN_ID));
    storageDomainsValidator = spy(new MultipleStorageDomainsValidator(STORAGE_POOL_ID, sdIds));
    doReturn(storageDomainsValidator).when(cmd).getStorageDomainsValidator(any(Guid.class), anySet());
    doReturn(sdIds).when(cmd).getStorageDomainsIds();
    doReturn(ValidationResult.VALID).when(storageDomainsValidator).allDomainsExistAndActive();
    doReturn(ValidationResult.VALID).when(storageDomainsValidator).allDomainsWithinThresholds();
    doReturn(ValidationResult.VALID).when(storageDomainsValidator).allDomainsHaveSpaceForClonedDisks(anyList());
    doReturn(ValidationResult.VALID).when(storageDomainsValidator).allDomainsHaveSpaceForMerge(anyList());
}
#method_after
private void spySdValidator() {
    Set<Guid> sdIds = new HashSet<>(Collections.singletonList(STORAGE_DOMAIN_ID));
    storageDomainsValidator = spy(new MultipleStorageDomainsValidator(STORAGE_POOL_ID, sdIds));
    doReturn(storageDomainsValidator).when(cmd).getStorageDomainsValidator(any(Guid.class), anySet());
    doReturn(sdIds).when(cmd).getStorageDomainsIds();
    doReturn(ValidationResult.VALID).when(storageDomainsValidator).allDomainsExistAndActive();
    doReturn(ValidationResult.VALID).when(storageDomainsValidator).allDomainsWithinThresholds();
    doReturn(ValidationResult.VALID).when(storageDomainsValidator).allDomainsHaveSpaceForMerge(anyList(), any());
}
#end_block

#method_before
@Test
public void testValidateEnoughSpace() {
    prepareForVmValidatorTests();
    spySdValidator();
    cmd.getVm().setStatus(VMStatus.Up);
    List<DiskImage> parentSnapshots = mockDisksList(2);
    mockSnapshotList(parentSnapshots);
    doReturn(parentSnapshots).when(cmd).getSourceImages();
    doReturn(parentSnapshots).when(cmd).getDisksListForStorageAllocations();
    ValidateTestUtils.runAndAssertValidateSuccess(cmd);
}
#method_after
@Test
public void testValidateEnoughSpace() {
    prepareForVmValidatorTests();
    spySdValidator();
    cmd.getVm().setStatus(VMStatus.Up);
    List<DiskImage> parentSnapshots = mockDisksList(2);
    doReturn(parentSnapshots).when(cmd).getSourceImages();
    ValidateTestUtils.runAndAssertValidateSuccess(cmd);
}
#end_block

#method_before
@Test
public void testValidateNotEnoughSpace() {
    prepareForVmValidatorTests();
    spySdValidator();
    cmd.getVm().setStatus(VMStatus.Up);
    List<DiskImage> parentSnapshots = mockDisksList(2);
    List<Pair<DiskImage, DiskImage>> mockSnapshotList = mockSnapshotList(parentSnapshots);
    when(storageDomainsValidator.allDomainsHaveSpaceForMerge(mockSnapshotList)).thenReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN));
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN);
}
#method_after
@Test
public void testValidateNotEnoughSpace() {
    prepareForVmValidatorTests();
    spySdValidator();
    cmd.getVm().setStatus(VMStatus.Up);
    mockDisksList(2);
    when(storageDomainsValidator.allDomainsHaveSpaceForMerge(anyList(), any())).thenReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN));
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN);
}
#end_block

#method_before
private List<DiskImage> mockDisksList(int numberOfDisks) {
    List<DiskImage> disksList = new ArrayList<>(numberOfDisks);
    for (int index = 0; index < numberOfDisks; index++) {
        DiskImage image = createDiskImage(STORAGE_DOMAIN_ID);
        disksList.add(image);
    }
    doReturn(disksList).when(cmd).getSourceImages();
    doReturn(disksList).when(cmd).getDisksListForStorageAllocations();
    return disksList;
}
#method_after
private List<DiskImage> mockDisksList(int numberOfDisks) {
    List<DiskImage> disksList = new ArrayList<>(numberOfDisks);
    for (int index = 0; index < numberOfDisks; index++) {
        DiskImage image = createDiskImage(STORAGE_DOMAIN_ID);
        disksList.add(image);
    }
    doReturn(disksList).when(cmd).getSourceImages();
    return disksList;
}
#end_block

#method_before
public ValidationResult hasSpaceForMerge(Pair<DiskImage, DiskImage> snapshots) {
    if (storageDomain.getStorageType().isCinderDomain()) {
        return ValidationResult.VALID;
    }
    Long availableSize = storageDomain.getAvailableDiskSizeInBytes();
    double totalSizeForDisks = getRequiredSizeForMerge(snapshots);
    return validateRequiredSpace(availableSize, totalSizeForDisks);
}
#method_after
public ValidationResult hasSpaceForMerge(SubchainInfo subchain, VdcActionType snapshotActionType) {
    if (storageDomain.getStorageType().isCinderDomain()) {
        return ValidationResult.VALID;
    }
    Long availableSize = storageDomain.getAvailableDiskSizeInBytes();
    double totalSizeForDisks = getRequiredSizeForMerge(subchain, snapshotActionType);
    return validateRequiredSpace(availableSize, totalSizeForDisks);
}
#end_block

#method_before
private double getRequiredSizeForMerge(Pair<DiskImage, DiskImage> snapshots) {
    DiskImage baseSnapshot = snapshots.getFirst();
    DiskImage topSnapshot = snapshots.getSecond();
    double snapshotSize = Math.min(topSnapshot.getSize() * StorageConstants.QCOW_OVERHEAD_FACTOR - baseSnapshot.getActualSizeInBytes(), topSnapshot.getActualSizeInBytes());
    if (baseSnapshot.getVolumeFormat() == VolumeFormat.RAW) {
        if (storageDomain.getStorageType().isBlockDomain()) {
            return 0;
        } else {
            return Math.min(topSnapshot.getActualSize() / StorageConstants.QCOW_OVERHEAD_FACTOR, baseSnapshot.getSize() - baseSnapshot.getActualSizeInBytes());
        }
    }
    return snapshotSize;
}
#method_after
private double getRequiredSizeForMerge(SubchainInfo subchain, VdcActionType snapshotActionType) {
    DiskImage baseSnapshot = subchain.getBaseImage();
    DiskImage topSnapshot = subchain.getTopImage();
    // We are doing a pre-4.1 cold merge, using block-rebase
    if (snapshotActionType == VdcActionType.RemoveSnapshotSingleDisk) {
        return Math.min(baseSnapshot.getActualSizeInBytes() + topSnapshot.getActualSizeInBytes(), baseSnapshot.getSize()) * StorageConstants.QCOW_OVERHEAD_FACTOR;
    }
    VolumeType volumeType = snapshotActionType == VdcActionType.ColdMergeSnapshotSingleDisk ? baseSnapshot.getVolumeType() : topSnapshot.getVolumeType();
    // The snapshot is the root snapshot
    if (Guid.isNullOrEmpty(baseSnapshot.getParentId())) {
        if (baseSnapshot.getVolumeFormat() == VolumeFormat.RAW) {
            // with existing data
            if (volumeType == VolumeType.Preallocated) {
                return 0.0;
            }
            return Math.min(topSnapshot.getActualSizeInBytes() / StorageConstants.QCOW_OVERHEAD_FACTOR, baseSnapshot.getSize() - baseSnapshot.getActualSizeInBytes());
        }
    }
    // will be overlapping, hence we extend by the lower of the two.
    return Math.min(topSnapshot.getSize() * StorageConstants.QCOW_OVERHEAD_FACTOR - baseSnapshot.getActualSizeInBytes(), topSnapshot.getActualSizeInBytes());
}
#end_block

#method_before
public ValidationResult allDomainsHaveSpaceForMerge(List<Pair<DiskImage, DiskImage>> snapshots) {
    final Map<Guid, Pair<DiskImage, DiskImage>> storageToSnapshots = getDomainsToSnapshotsMap(snapshots);
    return validOrFirstFailure(entry -> {
        Guid sdId = entry.getKey();
        Pair<DiskImage, DiskImage> pair = storageToSnapshots.get(sdId);
        return getStorageDomainValidator(entry).hasSpaceForMerge(pair);
    });
}
#method_after
public ValidationResult allDomainsHaveSpaceForMerge(List<SubchainInfo> snapshots, VdcActionType snapshotActionType) {
    final Map<Guid, SubchainInfo> storageToSnapshots = getDomainsToSnapshotsMap(snapshots);
    return validOrFirstFailure(entry -> {
        Guid sdId = entry.getKey();
        SubchainInfo subchain = storageToSnapshots.get(sdId);
        return getStorageDomainValidator(entry).hasSpaceForMerge(subchain, snapshotActionType);
    });
}
#end_block

#method_before
private Map<Guid, Pair<DiskImage, DiskImage>> getDomainsToSnapshotsMap(List<Pair<DiskImage, DiskImage>> snapshots) {
    Map<Guid, Pair<DiskImage, DiskImage>> domainsToPairMap = new HashMap<>();
    for (Pair<DiskImage, DiskImage> pair : snapshots) {
        List<Guid> storageIds = pair.getFirst().getStorageIds();
        for (Guid domainId : storageIds) {
            domainsToPairMap.put(domainId, pair);
        }
    }
    return domainsToPairMap;
}
#method_after
private Map<Guid, SubchainInfo> getDomainsToSnapshotsMap(List<SubchainInfo> snapshots) {
    return snapshots.stream().collect(Collectors.toMap(SubchainInfo::getStorageDomainId, Function.identity()));
}
#end_block

#method_before
@Override
protected void endVmCommand() {
    initializeObjectState();
    if (getParameters().getTaskGroupSuccess()) {
        snapshotDao.remove(getParameters().getSnapshotId());
    } else {
        List<String> failedToRemoveDisks = new ArrayList<>();
        Snapshot snapshot = snapshotDao.get(getParameters().getSnapshotId());
        for (VdcActionParametersBase parameters : getParameters().getImagesParameters()) {
            ImagesContainterParametersBase imagesParams = parameters instanceof ImagesContainterParametersBase ? (ImagesContainterParametersBase) parameters : null;
            if (imagesParams == null) {
                // instances of ImagesContainterParametersBase objects.
                continue;
            }
            if (imagesParams.getTaskGroupSuccess()) {
                snapshot = imagesHandler.prepareSnapshotConfigWithoutImageSingleImage(snapshot, imagesParams.getImageId(), ovfManager);
            } else {
                log.error("Could not delete image '{}' from snapshot '{}'", imagesParams.getImageId(), getParameters().getSnapshotId());
                DiskImage diskImage = diskImageDao.getSnapshotById(imagesParams.getImageId());
                failedToRemoveDisks.add(diskImage.getDiskAlias());
            }
        }
        // Remove memory volume and update the dao.
        // Note: on failure, we can treat memory volume deletion as deleting an image
        // and remove it from the snapshot entity (rollback isn't applicable).
        snapshot.setMemoryVolume("");
        snapshotDao.update(snapshot);
        if (!failedToRemoveDisks.isEmpty()) {
            addCustomValue("DiskAliases", StringUtils.join(failedToRemoveDisks, ", "));
            auditLogDirector.log(this, AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE_PARTIAL_SNAPSHOT);
        }
        snapshotDao.updateStatus(getParameters().getSnapshotId(), SnapshotStatus.OK);
    }
    super.endVmCommand();
}
#method_after
@Override
protected void endVmCommand() {
    initializeObjectState();
    if (getParameters().getTaskGroupSuccess()) {
        snapshotDao.remove(getParameters().getSnapshotId());
    } else {
        List<String> failedToRemoveDisks = new ArrayList<>();
        Snapshot snapshot = snapshotDao.get(getParameters().getSnapshotId());
        for (VdcActionParametersBase parameters : getParameters().getImagesParameters()) {
            ImagesContainterParametersBase imagesParams = parameters instanceof ImagesContainterParametersBase ? (ImagesContainterParametersBase) parameters : null;
            if (imagesParams == null) {
                // instances of ImagesContainterParametersBase objects.
                continue;
            }
            if (imagesParams.getTaskGroupSuccess()) {
                snapshot = ImagesHandler.prepareSnapshotConfigWithoutImageSingleImage(snapshot, imagesParams.getImageId(), ovfManager);
            } else {
                log.error("Could not delete image '{}' from snapshot '{}'", imagesParams.getImageId(), getParameters().getSnapshotId());
                DiskImage diskImage = diskImageDao.getSnapshotById(imagesParams.getImageId());
                failedToRemoveDisks.add(diskImage.getDiskAlias());
            }
        }
        // Remove memory volume and update the dao.
        // Note: on failure, we can treat memory volume deletion as deleting an image
        // and remove it from the snapshot entity (rollback isn't applicable).
        snapshot.setMemoryVolume("");
        snapshotDao.update(snapshot);
        if (!failedToRemoveDisks.isEmpty()) {
            addCustomValue("DiskAliases", StringUtils.join(failedToRemoveDisks, ", "));
            auditLogDirector.log(this, AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE_PARTIAL_SNAPSHOT);
        }
        snapshotDao.updateStatus(getParameters().getSnapshotId(), SnapshotStatus.OK);
    }
    super.endVmCommand();
}
#end_block

#method_before
protected boolean validateStorageDomains() {
    List<DiskImage> disksList = getDisksListForStorageAllocations();
    MultipleStorageDomainsValidator storageDomainsValidator = getStorageDomainsValidator(getStoragePoolId(), getStorageDomainsIds());
    return validate(storageDomainsValidator.allDomainsExistAndActive()) && validate(storageDomainsValidator.allDomainsWithinThresholds()) && validate(storageDomainsValidator.allDomainsHaveSpaceForMerge(getSnapshotsForFreeSpaceValidation(disksList)));
}
#method_after
protected boolean validateStorageDomains() {
    MultipleStorageDomainsValidator storageDomainsValidator = getStorageDomainsValidator(getStoragePoolId(), getStorageDomainsIds());
    return validate(storageDomainsValidator.allDomainsExistAndActive()) && validate(storageDomainsValidator.allDomainsWithinThresholds()) && validate(storageDomainsValidator.allDomainsHaveSpaceForMerge(getAllDisksSnapshot(getSourceImages()), getSnapshotActionType()));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid newMacPoolId = getNewMacPoolId();
    moveMacs.moveMacsOfUpdatedCluster(oldCluster, newMacPoolId, getContext());
    getCluster().setArchitecture(getArchitecture());
    setDefaultSwitchTypeIfNeeded();
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getParameters().getCluster().getCompatibilityVersion())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed validate.
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = getEmulatedMachineOfHostInCluster(vds);
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getCluster().setDetectEmulatedMachine(true);
        } else {
            getParameters().getCluster().setEmulatedMachine(emulatedMachine);
        }
    } else if (oldCluster.getArchitecture() != getCluster().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getCluster().setDetectEmulatedMachine(true);
        getParameters().getCluster().setEmulatedMachine(null);
    }
    if (getParameters().isForceResetEmulatedMachine()) {
        getParameters().getCluster().setDetectEmulatedMachine(true);
    }
    boolean isKsmPolicyChanged = (getCluster().isKsmMergeAcrossNumaNodes() != getPrevCluster().isKsmMergeAcrossNumaNodes()) || (getCluster().isEnableKsm() != getPrevCluster().isEnableKsm());
    clusterDao.update(getParameters().getCluster());
    addOrUpdateAddtionalClusterFeatures();
    if (!oldCluster.supportsGlusterService() && getCluster().supportsGlusterService()) {
        // update gluster parameters on all hosts
        updateGlusterHosts();
    }
    if (isAddedToStoragePool) {
        for (VDS vds : allForCluster) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, parameters, cloneContextAndDetachFromParent());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        networkClusterDao.save(managementNetworkCluster);
    }
    alertIfFencingDisabled();
    if (isKsmPolicyChanged) {
        momPolicyUpdatedEvent.fire(getCluster());
    }
    // Call UpdateVmCommand on all VMs in the cluster to update defaults (i.e. DisplayType)
    updateVms();
    updateTemplates();
    if (!failedUpgradeEntities.isEmpty()) {
        logFailedUpgrades();
        failValidation(Arrays.asList(EngineMessage.CLUSTER_CANNOT_UPDATE_CLUSTER_FAILED_TO_UPDATE_VMS), "$VmList " + StringUtils.join(failedUpgradeEntities.keySet(), ", "));
        getReturnValue().setValid(false);
        setSucceeded(false);
        return;
    }
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion())) {
        vmStaticDao.getAllByCluster(getCluster().getId()).forEach(this::updateClusterVersionInManager);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    Guid newMacPoolId = getNewMacPoolId();
    moveMacs.moveMacsOfUpdatedCluster(oldCluster, newMacPoolId, getContext());
    getCluster().setArchitecture(getArchitecture());
    setDefaultSwitchTypeIfNeeded();
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getParameters().getCluster().getCompatibilityVersion())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed validate.
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = getEmulatedMachineOfHostInCluster(vds);
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getCluster().setDetectEmulatedMachine(true);
        } else {
            getParameters().getCluster().setEmulatedMachine(emulatedMachine);
        }
    } else if (oldCluster.getArchitecture() != getCluster().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getCluster().setDetectEmulatedMachine(true);
        getParameters().getCluster().setEmulatedMachine(null);
    }
    if (getParameters().isForceResetEmulatedMachine()) {
        getParameters().getCluster().setDetectEmulatedMachine(true);
    }
    boolean isKsmPolicyChanged = (getCluster().isKsmMergeAcrossNumaNodes() != getPrevCluster().isKsmMergeAcrossNumaNodes()) || (getCluster().isEnableKsm() != getPrevCluster().isEnableKsm());
    clusterDao.update(getParameters().getCluster());
    addOrUpdateAddtionalClusterFeatures();
    if (!oldCluster.supportsGlusterService() && getCluster().supportsGlusterService()) {
        // update gluster parameters on all hosts
        updateGlusterHosts();
    }
    if (isAddedToStoragePool) {
        for (VDS vds : allForCluster) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, parameters, cloneContextAndDetachFromParent());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        final NetworkCluster managementNetworkCluster = createManagementNetworkCluster(managementNetwork);
        networkClusterDao.save(managementNetworkCluster);
    }
    alertIfFencingDisabled();
    if (isKsmPolicyChanged) {
        momPolicyUpdatedEvent.fire(getCluster());
    }
    // Call UpdateVmCommand on all VMs in the cluster to update defaults (i.e. DisplayType)
    updateVms();
    updateTemplates();
    if (!failedUpgradeEntities.isEmpty()) {
        logFailedUpgrades();
        failValidation(Arrays.asList(EngineMessage.CLUSTER_CANNOT_UPDATE_CLUSTER_FAILED_TO_UPDATE_VMS), "$VmList " + StringUtils.join(failedUpgradeEntities.keySet(), ", "));
        getReturnValue().setValid(false);
        setSucceeded(false);
        return;
    }
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion())) {
        vmStaticDao.getAllByCluster(getCluster().getId()).forEach(this::updateClusterVersionInManager);
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    if (oldCluster == null) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldCluster.getName(), getCluster().getName())) {
        if (!isClusterUnique(getCluster().getName())) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getCluster().getCompatibilityVersion())) {
        addValidationMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForCluster = vdsDao.getAllForCluster(oldCluster.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getCluster().getCompatibilityVersion().compareTo(oldCluster.getCompatibilityVersion()) < 0) {
        if (!allForCluster.isEmpty()) {
            result = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_CLUSTER_WITH_HOSTS_COMPATIBILITY_VERSION);
        }
        if (oldCluster.getStoragePoolId() != null) {
            ClusterValidator validator = new ClusterValidator(getDbFacade(), oldCluster, getCpuFlagsManagerHandler());
            if (!validate(validator.dataCenterVersionMismatch())) {
                result = false;
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldCluster.getStoragePoolId() != null && !oldCluster.getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForCluster);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getCluster().supportsVirtService() && (oldCluster.getCpuName() != null || getCluster().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addValidationMessage(EngineMessage.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldCluster.getCpuName()) && !checkIfCpusSameManufacture(oldCluster) && !allVdssInMaintenance) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = vmDao.getAllForCluster(oldCluster.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForCluster.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getCluster().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldCluster.getCpuName(), getCluster().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldCluster.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldCluster) && hasVmOrHost) {
            addValidationMessage(EngineMessage.CLUSTER_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result && !oldCluster.getCompatibilityVersion().equals(getCluster().getCompatibilityVersion())) {
        for (VM vm : vmList) {
            if (vm.isPreviewSnapshot()) {
                // can't change cluster version when a VM is in preview
                if (result) {
                    addValidationMessage(EngineMessage.CLUSTER_VERSION_CHANGE_VM_PREVIEW);
                    // and continue with adding validation messages
                    result = false;
                }
                addValidationMessage(vm.getName());
            }
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldCluster.getStoragePoolId() == null && getCluster().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetworkAttachment()) {
            return false;
        }
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getCluster().getCompatibilityVersion(), vds)) {
                result = false;
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getCluster().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
            if (!isSupportedEmulatedMachinesMatchClusterLevel(vds)) {
                return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_INCOMPATIBLE_EMULATED_MACHINE);
            }
        }
        if (result) {
            Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
            // New Features cannot be enabled if all up hosts are not supporting the selected feature
            if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(vdss, additionalClusterFeaturesAdded)) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
                result = false;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldCluster);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        addCustomValue("Cluster", getParameters().getCluster().getName());
                        auditLogDirector.log(this, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getCluster().getStoragePoolId() != null) {
        StoragePool storagePool = storagePoolDao.get(getCluster().getStoragePoolId());
        if (oldCluster.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!clusterDao.getAllForStoragePool(getCluster().getStoragePoolId()).isEmpty()) {
                getReturnValue().getValidationMessages().add(EngineMessage.CLUSTER_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultClusterID).equals(getCluster().getId())) {
                addValidationMessage(EngineMessage.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (result) {
        if (!(getCluster().supportsGlusterService() || getCluster().supportsVirtService())) {
            addValidationMessage(EngineMessage.CLUSTER_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getCluster().supportsGlusterService() && getCluster().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addValidationMessage(EngineMessage.CLUSTER_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getCluster().supportsVirtService()) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getCluster().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = glusterVolumeDao.getByClusterId(getCluster().getId());
        if (volumes != null && volumes.size() > 0) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getCluster().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getCluster().getCompatibilityVersion()) && getCluster().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failValidation(EngineMessage.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy(oldCluster);
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                addValidationMessage(EngineMessage.CLUSTER_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    ClusterValidator clusterValidator = new ClusterValidator(getDbFacade(), getCluster(), cpuFlagsManagerHandler);
    result = result && validate(clusterValidator.rngSourcesAllowed()) && validate(clusterValidator.memoryOptimizationConfiguration());
    return result;
}
#method_after
@Override
protected boolean validate() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    if (oldCluster == null) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldCluster.getName(), getCluster().getName())) {
        if (!isClusterUnique(getCluster().getName())) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getCluster().getCompatibilityVersion())) {
        addValidationMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForCluster = vdsDao.getAllForCluster(oldCluster.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getCluster().getCompatibilityVersion().compareTo(oldCluster.getCompatibilityVersion()) < 0) {
        if (!allForCluster.isEmpty()) {
            result = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_CLUSTER_WITH_HOSTS_COMPATIBILITY_VERSION);
        }
        if (oldCluster.getStoragePoolId() != null) {
            ClusterValidator validator = new ClusterValidator(getDbFacade(), oldCluster, getCpuFlagsManagerHandler());
            if (!validate(validator.dataCenterVersionMismatch())) {
                result = false;
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldCluster.getStoragePoolId() != null && !oldCluster.getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForCluster);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getCluster().supportsVirtService() && (oldCluster.getCpuName() != null || getCluster().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addValidationMessage(EngineMessage.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldCluster.getCpuName()) && !checkIfCpusSameManufacture(oldCluster) && !allVdssInMaintenance) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = vmDao.getAllForCluster(oldCluster.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForCluster.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getCluster().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldCluster.getCpuName(), getCluster().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldCluster.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldCluster) && hasVmOrHost) {
            addValidationMessage(EngineMessage.CLUSTER_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result && !oldCluster.getCompatibilityVersion().equals(getCluster().getCompatibilityVersion())) {
        for (VM vm : vmList) {
            if (vm.isPreviewSnapshot()) {
                // can't change cluster version when a VM is in preview
                if (result) {
                    addValidationMessage(EngineMessage.CLUSTER_VERSION_CHANGE_VM_PREVIEW);
                    // and continue with adding validation messages
                    result = false;
                }
                addValidationMessage(vm.getName());
            }
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldCluster.getStoragePoolId() == null && getCluster().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetwork()) {
            return false;
        }
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getCluster().getCompatibilityVersion(), vds)) {
                result = false;
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getCluster().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
            if (!isSupportedEmulatedMachinesMatchClusterLevel(vds)) {
                return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_INCOMPATIBLE_EMULATED_MACHINE);
            }
        }
        if (result) {
            Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
            // New Features cannot be enabled if all up hosts are not supporting the selected feature
            if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(vdss, additionalClusterFeaturesAdded)) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
                result = false;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldCluster);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        addCustomValue("Cluster", getParameters().getCluster().getName());
                        auditLogDirector.log(this, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getCluster().getStoragePoolId() != null) {
        StoragePool storagePool = storagePoolDao.get(getCluster().getStoragePoolId());
        if (oldCluster.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!clusterDao.getAllForStoragePool(getCluster().getStoragePoolId()).isEmpty()) {
                getReturnValue().getValidationMessages().add(EngineMessage.CLUSTER_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultClusterID).equals(getCluster().getId())) {
                addValidationMessage(EngineMessage.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (result) {
        if (!(getCluster().supportsGlusterService() || getCluster().supportsVirtService())) {
            addValidationMessage(EngineMessage.CLUSTER_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getCluster().supportsGlusterService() && getCluster().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addValidationMessage(EngineMessage.CLUSTER_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getCluster().supportsVirtService()) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getCluster().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = glusterVolumeDao.getByClusterId(getCluster().getId());
        if (volumes != null && volumes.size() > 0) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getCluster().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getCluster().getCompatibilityVersion()) && getCluster().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failValidation(EngineMessage.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy(oldCluster);
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                addValidationMessage(EngineMessage.CLUSTER_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    ClusterValidator clusterValidator = new ClusterValidator(getDbFacade(), getCluster(), cpuFlagsManagerHandler);
    result = result && validate(clusterValidator.rngSourcesAllowed()) && validate(clusterValidator.memoryOptimizationConfiguration());
    return result;
}
#end_block

#method_before
public boolean isLegal() {
    if (useTimeout) {
        String keyForCheck = "".equals(timeoutObjectId) ? logType.toString() : timeoutObjectId;
        String value = CacheManager.getTimeoutBaseCache().putIfAbsent(keyForCheck, keyForCheck, endTime, TimeUnit.MILLISECONDS);
        return value == null;
    }
    return true;
}
#method_after
public boolean isLegal() {
    if (useTimeout) {
        String key = "".equals(timeoutObjectId) ? logType.toString() : timeoutObjectId;
        String oldValue = CacheManager.getTimeoutBaseCache().putIfAbsent(key, key, endTime, TimeUnit.MILLISECONDS);
        return oldValue == null;
    }
    return true;
}
#end_block

#method_before
@Benchmark
public void getVms(BenchmarkState state) {
    state.restClient.resolveTemplate("resource", "vms").request().get(String.class);
}
#method_after
@Benchmark
public void getVms(BenchmarkState state, Blackhole blackhole) {
    blackhole.consume(state.systemService.vmsService().list().send());
}
#end_block

#method_before
@Benchmark
public void getHosts(BenchmarkState state) {
    state.restClient.resolveTemplate("resource", "hosts").request().get(String.class);
}
#method_after
@Benchmark
public void getHosts(BenchmarkState state, Blackhole blackhole) {
    blackhole.consume(state.systemService.hostsService().list().send());
}
#end_block

#method_before
@Benchmark
public void addExternalEvent(BenchmarkState state) {
    state.restClient.resolveTemplate("resource", "events").request().post(Entity.json("{\"origin\": \"" + "benchmark" + System.currentTimeMillis() + "\"" + ", \"severity\": \"normal\", \"description\":\"benchmark\", " + "\"custom_id\": \"42424242\"}"));
}
#method_after
@Benchmark
public void addExternalEvent(BenchmarkState state, Blackhole blackhole) {
    blackhole.consume(state.systemService.eventsService().add().event(new EventBuilder().origin("benchmark" + System.currentTimeMillis()).severity(LogSeverity.NORMAL).description("benchmark").customId(123456).build()).send());
}
#end_block

#method_before
@Setup
public void setup() throws IOException, GeneralSecurityException {
    String user = System.getProperty("benchmarks.api.user", "admin@internal");
    String pass = System.getProperty("benchmarks.api.pass", "123");
    String engineHost = System.getProperty("benchmarks.api.engineHost", "localhost");
    String enginePort = System.getProperty("benchmarks.api.enginePort", "8080");
    Client client = ClientBuilder.newClient();
    client.register((ClientRequestFilter) requestContext -> {
        MultivaluedMap<String, Object> headers = requestContext.getHeaders();
        String encodedAuth = Base64.getEncoder().encodeToString((user + ":" + pass).getBytes("UTF-8"));
        headers.add("Authorization", "Basic " + encodedAuth);
    });
    restClient = client.target("http://" + engineHost + ":" + enginePort + "/ovirt-engine/api/{resource}");
}
#method_after
@Setup
public void setup() throws IOException, GeneralSecurityException {
    String user = System.getProperty("benchmarks.api.user", "admin@internal");
    String pass = System.getProperty("benchmarks.api.pass", "123");
    String engineHost = System.getProperty("benchmarks.api.engineHost", "localhost");
    String enginePort = System.getProperty("benchmarks.api.enginePort", "8080");
    connection = ConnectionBuilder.connection().url("http://" + engineHost + ":" + enginePort + "/" + "ovirt-engine/api").user(user).password(pass).insecure(true).build();
    systemService = connection.systemService();
}
#end_block

#method_before
@TearDown
public void teardown() throws IOException {
}
#method_after
@TearDown
public void teardown() throws Exception {
    connection.close();
}
#end_block

#method_before
private List<Step> buildStepsTree(List<Step> steps) {
    List<Step> jobDirectSteps = new ArrayList<>();
    // a map of parent step id and a list of child-steps
    Map<Guid, List<Step>> parentStepMap = new HashMap<>();
    for (Step step : steps) {
        if (step.getParentStepId() == null) {
            jobDirectSteps.add(step);
        } else {
            MultiValueMapUtils.addToMap(step.getParentStepId(), step, parentStepMap);
        }
    }
    for (Step step : steps) {
        if (parentStepMap.get(step.getId()) != null) {
            step.setSteps(parentStepMap.get(step.getId()));
        }
    }
    return jobDirectSteps;
}
#method_after
private List<Step> buildStepsTree(List<Step> steps) {
    List<Step> jobDirectSteps = new ArrayList<>();
    // a map of parent step id and a list of child-steps
    Map<Guid, List<Step>> parentStepMap = new HashMap<>();
    for (Step step : steps) {
        if (step.getParentStepId() == null) {
            jobDirectSteps.add(step);
        } else {
            MultiValueMapUtils.addToMap(step.getParentStepId(), step, parentStepMap);
        }
    }
    for (Step step : steps) {
        if (parentStepMap.containsKey(step.getId())) {
            step.setSteps(parentStepMap.get(step.getId()));
        }
    }
    return jobDirectSteps;
}
#end_block

#method_before
private void updateCurrentMemory(VM newVm) {
    int currentMemory = getVm().getMemSizeMb();
    int newAmountOfMemory = newVm.getMemSizeMb();
    if (getVm().getStatus().isNotRunning()) {
        newVmStatic.setMemSizeMb(newAmountOfMemory);
        return;
    }
    if (getVm().getStatus() != VMStatus.Up) {
        newVmStatic.setMemSizeMb(currentMemory);
        log.warn("Memory update {}MB -> {}MB of VM {} ({}) left out. Memory can't be updated in current VM state ({}).", currentMemory, newAmountOfMemory, getVm().getName(), getVm().getId(), getVm().getStatus());
        return;
    }
    if (VmCommonUtils.isMemoryToBeHotplugged(getVm(), newVm)) {
        hotSetMemory(currentMemory, newAmountOfMemory);
    }
}
#method_after
private void updateCurrentMemory(VM newVm) {
    int currentMemory = getVm().getMemSizeMb();
    int newAmountOfMemory = newVm.getMemSizeMb();
    if (getVm().getStatus().isNotRunning()) {
        newVmStatic.setMemSizeMb(newAmountOfMemory);
        return;
    }
    if (getVm().getStatus() != VMStatus.Up) {
        newVmStatic.setMemSizeMb(currentMemory);
        log.warn("Memory update {}MB -> {}MB of VM {} ({}) left out. Memory can't be updated in current VM state ({}).", currentMemory, newAmountOfMemory, getVm().getName(), getVm().getId(), getVm().getStatus());
        return;
    }
    if (!VmCommonUtils.isMemoryToBeHotplugged(getVm(), newVm)) {
        return;
    }
    final int memoryAddedMb = newAmountOfMemory - currentMemory;
    final int factor = Config.<Integer>getValue(ConfigValues.HotPlugMemoryMultiplicationSizeMb);
    final boolean memoryDividable = memoryAddedMb % factor == 0;
    if (!memoryDividable) {
        addCustomValue("memoryAdded", String.valueOf(memoryAddedMb));
        addCustomValue("requiredFactor", String.valueOf(factor));
        auditLogDirector.log(this, AuditLogType.FAILED_HOT_SET_MEMORY_NOT_DIVIDABLE);
        return;
    }
    hotSetMemory(currentMemory, newAmountOfMemory);
}
#end_block

#method_before
private void hotSetMemory(int currentMemoryMb, int newAmountOfMemoryMb) {
    final int minimalHotPlugDeviceSizeMb = HotSetAmountOfMemoryCommand.getHotplugMemorySizeFactor(getVm().getClusterArch());
    final List<VmDevice> memoryDevices = getVmDeviceUtils().getMemoryDevices(getVmId());
    final boolean minimalMemoryDevicePresent = memoryDevices.stream().anyMatch(device -> VmDeviceCommonUtils.getSizeOfMemoryDeviceMb(device) == minimalHotPlugDeviceSizeMb);
    final int secondPartSizeMb = (newAmountOfMemoryMb - currentMemoryMb) - minimalHotPlugDeviceSizeMb;
    if (minimalMemoryDevicePresent || secondPartSizeMb == 0) {
        hotPlugMemoryDevice(currentMemoryMb, newAmountOfMemoryMb);
        return;
    }
    hotPlugMemoryDevice(currentMemoryMb, currentMemoryMb + minimalHotPlugDeviceSizeMb);
    hotPlugMemoryDevice(currentMemoryMb + minimalHotPlugDeviceSizeMb, newAmountOfMemoryMb);
}
#method_after
private void hotSetMemory(int currentMemoryMb, int newAmountOfMemoryMb) {
    final int minimalHotPlugDeviceSizeMb = getVm().getClusterArch().getHotplugMemorySizeFactorMb();
    final List<VmDevice> memoryDevices = getVmDeviceUtils().getMemoryDevices(getVmId());
    final boolean minimalMemoryDevicePresent = memoryDevices.stream().anyMatch(device -> VmDeviceCommonUtils.getSizeOfMemoryDeviceMb(device) == minimalHotPlugDeviceSizeMb);
    final int secondPartSizeMb = (newAmountOfMemoryMb - currentMemoryMb) - minimalHotPlugDeviceSizeMb;
    if (minimalMemoryDevicePresent || secondPartSizeMb == 0) {
        hotPlugMemoryDevice(currentMemoryMb, newAmountOfMemoryMb);
        return;
    }
    hotPlugMemoryDevice(currentMemoryMb, currentMemoryMb + minimalHotPlugDeviceSizeMb);
    hotPlugMemoryDevice(currentMemoryMb + minimalHotPlugDeviceSizeMb, newAmountOfMemoryMb);
}
#end_block

#method_before
private void hotPlugMemoryDevice(int currentMemoryMb, int newAmountOfMemoryMb) {
    HotSetAmountOfMemoryParameters params = new HotSetAmountOfMemoryParameters(newVmStatic, PlugAction.PLUG, // We always use node 0, auto-numa should handle the allocation
    0, newAmountOfMemoryMb - currentMemoryMb);
    VdcReturnValueBase setAmountOfMemoryResult = runInternalAction(VdcActionType.HotSetAmountOfMemory, params, cloneContextAndDetachFromParent());
    // into the OVF store and automatically used during the next HE VM start
    if (!getVm().isHostedEngine()) {
        newVmStatic.setMemSizeMb(setAmountOfMemoryResult.getSucceeded() ? newAmountOfMemoryMb : currentMemoryMb);
    }
    hotSetMemlog(params, setAmountOfMemoryResult);
}
#method_after
private void hotPlugMemoryDevice(int currentMemoryMb, int newAmountOfMemoryMb) {
    HotSetAmountOfMemoryParameters params = new HotSetAmountOfMemoryParameters(newVmStatic, currentMemoryMb < newAmountOfMemoryMb ? PlugAction.PLUG : PlugAction.UNPLUG, // We always use node 0, auto-numa should handle the allocation
    0, newAmountOfMemoryMb - currentMemoryMb);
    VdcReturnValueBase setAmountOfMemoryResult = runInternalAction(VdcActionType.HotSetAmountOfMemory, params, cloneContextAndDetachFromParent());
    // into the OVF store and automatically used during the next HE VM start
    if (!getVm().isHostedEngine()) {
        newVmStatic.setMemSizeMb(setAmountOfMemoryResult.getSucceeded() ? newAmountOfMemoryMb : currentMemoryMb);
    }
    hotSetMemlog(params, setAmountOfMemoryResult);
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmHandler.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion().toString()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isHotSetEnabled()) {
        final int memoryAddedMb = vmFromParams.getMemSizeMb() - vmFromDB.getMemSizeMb();
        if (memoryAddedMb % Config.<Integer>getValue(ConfigValues.HotPlugMemoryMultiplicationSizeMb) != 0) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_MUST_BE_MULTIPLICATION, ReplacementUtils.createSetVariableString("$multiplicationSize ", Config.<Integer>getValue(ConfigValues.HotPlugMemoryMultiplicationSizeMb)));
        }
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!getParameters().getVmStaticData().isAutoStartup()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED_WITH_HA_OFF);
        }
        if (!FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED);
        }
        if (!validateLeaseStorageDomain(getParameters().getVmStaticData().getLeaseStorageDomainId())) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmHandler.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!getParameters().getVmStaticData().isAutoStartup()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED_WITH_HA_OFF);
        }
        if (!FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED);
        }
        if (!validateLeaseStorageDomain(getParameters().getVmStaticData().getLeaseStorageDomainId())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public void addVirtioScsiController(VmBase vm, Version version) {
    boolean hasIoThreads = vm.getNumOfIoThreads() > 0 && FeatureSupported.virtioScsiIoThread(version);
    int numOfScsiControllers = hasIoThreads ? vm.getNumOfIoThreads() : 1;
    for (int i = 0; i < numOfScsiControllers; i++) {
        Map<String, Object> specParams = new HashMap<>();
        if (hasIoThreads) {
            specParams.put(VdsProperties.ioThreadId, i);
        }
        VmDevice device = addManagedDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI, specParams, true, false);
    }
}
#method_after
public void addVirtioScsiController(VmBase vm, Version version) {
    boolean hasIoThreads = vm.getNumOfIoThreads() > 0 && FeatureSupported.virtioScsiIoThread(version);
    int numOfScsiControllers = hasIoThreads ? vm.getNumOfIoThreads() : 1;
    for (int i = 0; i < numOfScsiControllers; i++) {
        Map<String, Object> specParams = new HashMap<>();
        if (hasIoThreads) {
            // i + 1 because libvirt is indexing the io threads from 1 to N, not 0 to N - 1
            specParams.put(VdsProperties.ioThreadId, i + 1);
        }
        VmDevice device = addManagedDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI, specParams, true, false);
    }
}
#end_block

#method_before
/*
     * Video device
     */
private void updateVideoDevices(VmBase oldVmBase, VmBase newVmBase) {
    boolean displayTypeChanged = oldVmBase.getDefaultDisplayType() != newVmBase.getDefaultDisplayType();
    boolean numOfMonitorsChanged = newVmBase.getDefaultDisplayType() == DisplayType.qxl && oldVmBase.getNumOfMonitors() != newVmBase.getNumOfMonitors();
    boolean singleQxlChanged = oldVmBase.getSingleQxlPci() != newVmBase.getSingleQxlPci();
    boolean guestOsChanged = oldVmBase.getOsId() != newVmBase.getOsId();
    if (displayTypeChanged || numOfMonitorsChanged || singleQxlChanged || guestOsChanged) {
        removeVideoDevices(oldVmBase.getId());
        addVideoDevices(newVmBase, getNeededNumberOfVideoDevices(newVmBase));
    }
}
#method_after
/*
     * Video device
     */
public void updateVideoDevices(VmBase oldVmBase, VmBase newVmBase) {
    boolean displayTypeChanged = oldVmBase.getDefaultDisplayType() != newVmBase.getDefaultDisplayType();
    boolean numOfMonitorsChanged = newVmBase.getDefaultDisplayType() == DisplayType.qxl && oldVmBase.getNumOfMonitors() != newVmBase.getNumOfMonitors();
    boolean singleQxlChanged = oldVmBase.getSingleQxlPci() != newVmBase.getSingleQxlPci();
    boolean guestOsChanged = oldVmBase.getOsId() != newVmBase.getOsId();
    if (displayTypeChanged || numOfMonitorsChanged || singleQxlChanged || guestOsChanged) {
        removeVideoDevices(oldVmBase.getId());
        addVideoDevices(newVmBase, getNeededNumberOfVideoDevices(newVmBase));
    } else {
        // fix vm's without video devices
        addVideoDevicesOnlyIfNoVideoDeviceExists(newVmBase);
    }
}
#end_block

#method_before
private boolean canPlugInterface(VmNic iface, VmBase vmBase) {
    ReadMacPool macPool = macPoolPerCluster.getMacPoolForCluster(vmBase.getClusterId());
    VmInterfaceManager vmIfaceManager = new VmInterfaceManager();
    if (vmIfaceManager.tooManyPluggedInterfaceWithSameMac(iface, macPool)) {
        vmIfaceManager.auditLogMacInUseUnplug(iface);
        return false;
    } else {
        return true;
    }
}
#method_after
private boolean canPlugInterface(VmNic iface, VmBase vmBase) {
    ReadMacPool macPool = macPoolPerCluster.getMacPoolForCluster(vmBase.getClusterId());
    VmInterfaceManager vmIfaceManager = new VmInterfaceManager();
    if (vmIfaceManager.tooManyPluggedInterfaceWithSameMac(iface, macPool)) {
        vmIfaceManager.auditLogMacInUseUnplug(iface, vmBase.getName());
        return false;
    } else {
        return true;
    }
}
#end_block

#method_before
/*
     * USB slot
     */
private void updateUsbSlots(VmBase oldVm, VmBase newVm) {
    UsbPolicy oldUsbPolicy = UsbPolicy.DISABLED;
    UsbPolicy newUsbPolicy = newVm.getUsbPolicy();
    int oldNumberOfSlots = 0;
    if (oldVm != null) {
        oldUsbPolicy = oldVm.getUsbPolicy();
        oldNumberOfSlots = getUsbSlots(oldVm.getId()).size();
    }
    final int newNumberOfUsbSlots = Config.<Integer>getValue(ConfigValues.NumberOfUSBSlots);
    if (UsbPolicy.DISABLED == oldUsbPolicy && UsbPolicy.ENABLED_NATIVE == newUsbPolicy) {
        disableNormalUsb(newVm.getId());
        enableSpiceUsb(newVm.getId(), newNumberOfUsbSlots);
        return;
    }
    if (UsbPolicy.ENABLED_NATIVE == oldUsbPolicy && UsbPolicy.ENABLED_NATIVE == newUsbPolicy) {
        updateSpiceUsb(newVm.getId(), oldNumberOfSlots, newNumberOfUsbSlots);
        return;
    }
    if (UsbPolicy.ENABLED_NATIVE == oldUsbPolicy && UsbPolicy.DISABLED == newUsbPolicy) {
        disableSpiceUsb(newVm.getId());
        enableNormalUsb(newVm);
        return;
    }
    if (UsbPolicy.DISABLED == oldUsbPolicy && UsbPolicy.DISABLED == newUsbPolicy) {
        updateNormalUsb(newVm);
        return;
    }
    throw new RuntimeException(format("Unexpected state: oldUsbPolicy=%s, newUsbPolicy=%s", oldUsbPolicy, newUsbPolicy));
}
#method_after
/*
     * USB slot
     */
public void updateUsbSlots(VmBase oldVm, VmBase newVm) {
    final UsbPolicy oldUsbPolicy = oldVm.getUsbPolicy();
    final UsbPolicy newUsbPolicy = newVm.getUsbPolicy();
    final int oldNumberOfSlots = getUsbSlots(oldVm.getId()).size();
    final int newNumberOfUsbSlots = Config.<Integer>getValue(ConfigValues.NumberOfUSBSlots);
    if (UsbPolicy.DISABLED == oldUsbPolicy && UsbPolicy.ENABLED_NATIVE == newUsbPolicy) {
        disableNormalUsb(newVm.getId());
        enableSpiceUsb(newVm.getId(), newNumberOfUsbSlots);
        return;
    }
    if (UsbPolicy.ENABLED_NATIVE == oldUsbPolicy && UsbPolicy.ENABLED_NATIVE == newUsbPolicy) {
        updateSpiceUsb(newVm.getId(), oldNumberOfSlots, newNumberOfUsbSlots);
        return;
    }
    if (UsbPolicy.ENABLED_NATIVE == oldUsbPolicy && UsbPolicy.DISABLED == newUsbPolicy) {
        disableSpiceUsb(newVm.getId());
        enableNormalUsb(newVm);
        return;
    }
    if (UsbPolicy.DISABLED == oldUsbPolicy && UsbPolicy.DISABLED == newUsbPolicy) {
        updateNormalUsb(newVm);
        return;
    }
    throw new RuntimeException(format("Unexpected state: oldUsbPolicy=%s, newUsbPolicy=%s", oldUsbPolicy, newUsbPolicy));
}
#end_block

#method_before
private void disableSpiceUsb(Guid vmId) {
    removeUsbControllers(vmId);
    removeUsbSlots(vmId);
}
#method_after
private void disableSpiceUsb(Guid vmId) {
    removeUsbControllers(vmId);
    removeUsbSlots(vmId);
    removeUsbChannels(vmId);
}
#end_block

#method_before
private void updateNormalUsb(VmBase vmBase) {
    final List<VmDevice> usbControllers = getUsbControllers(vmBase.getId());
    if (usbControllers.size() > 1) {
        throw new IllegalStateException(format("At most one USB controller expected for VM=%s(%s), found=%s", vmBase.getName(), vmBase.getId(), usbControllers));
    }
    final UsbControllerModel newUsbControllerModel = getUsbControllerModel(vmBase);
    if ((usbControllers.isEmpty() && newUsbControllerModel == null) || (!usbControllers.isEmpty() && newUsbControllerModel != null && newUsbControllerModel.libvirtName.equals(getUsbControllerModelName(usbControllers.get(0))))) {
        return;
    }
    disableNormalUsb(vmBase.getId());
    enableNormalUsb(vmBase);
}
#method_after
private void updateNormalUsb(VmBase vmBase) {
    final Collection<VmDevice> usbControllers = getUsbControllers(vmBase.getId());
    final List<VmDevice> unmanagedControllers = usbControllers.stream().filter(d -> !d.isManaged()).collect(Collectors.toList());
    final List<VmDevice> managedUsbControllers = usbControllers.stream().filter(VmDevice::isManaged).collect(Collectors.toList());
    if (unmanagedControllers.size() > 0) {
        acquireUnmanagedUsbController(vmBase, managedUsbControllers, unmanagedControllers);
        return;
    }
    final UsbControllerModel controllerModel = getUsbControllerModel(vmBase);
    if ((managedUsbControllers.isEmpty() && controllerModel == null) || (managedUsbControllers.size() == 1 && controllerModel != null && controllerModel.libvirtName.equals(getUsbControllerModelName(managedUsbControllers.get(0))))) {
        return;
    }
    disableNormalUsb(vmBase.getId());
    enableNormalUsb(vmBase);
}
#end_block

#method_before
public void updateVmDevicesOnRun(VmBase vmBase) {
    if (vmBase != null) {
        updateUsbSlots(vmBase, vmBase);
    }
}
#method_after
public void updateVmDevicesOnRun(VmBase vmBase) {
    if (vmBase != null) {
        updateUsbSlots(vmBase, vmBase);
        removeLeftOverDevices(vmBase);
    }
}
#end_block

#method_before
public void copyVmDevices(Guid srcId, Guid dstId, Map<Guid, Guid> srcDeviceIdToDstDeviceIdMapping, boolean isSoundEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices, Version versionToUpdateRndDeviceWith) {
    VmBase srcVmBase = getVmBase(srcId);
    VmBase dstVmBase = getVmBase(dstId);
    List<VmDevice> srcDevices = vmDeviceDao.getVmDeviceByVmId(srcId);
    copyVmDevices(srcId, dstId, dstVmBase, srcDevices, srcDeviceIdToDstDeviceIdMapping, isSoundEnabled, isConsoleEnabled, isVirtioScsiEnabled, isBalloonEnabled, graphicsToSkip, copySnapshotDevices, canCopyHostDevices(srcVmBase, dstVmBase), versionToUpdateRndDeviceWith);
}
#method_after
public void copyVmDevices(Guid srcId, Guid dstId, VmBase srcVmBase, VmBase dstVmBase, List<VmDevice> srcDevices, Map<Guid, Guid> srcDeviceIdToDstDeviceIdMapping, boolean isSoundEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices, boolean copyHostDevices, Version versionToUpdateRngDeviceWith) {
    if (graphicsToSkip == null) {
        graphicsToSkip = Collections.emptySet();
    }
    String dstCdPath = dstVmBase.getIsoPath();
    boolean dstIsVm = !(dstVmBase instanceof VmTemplate);
    boolean hasCd = hasCdDevice(dstVmBase.getId());
    boolean hasSound = false;
    boolean hasConsole = false;
    boolean hasVirtioScsi = false;
    boolean hasBalloon = false;
    boolean hasRng = hasRngDevice(dstId);
    Cluster cluster = null;
    if (dstVmBase.getClusterId() != null) {
        cluster = clusterDao.get(dstVmBase.getClusterId());
    }
    for (VmDevice device : srcDevices) {
        if (device.getSnapshotId() != null && !copySnapshotDevices) {
            continue;
        }
        Guid deviceId = Guid.newGuid();
        Map<String, Object> specParams = new HashMap<>();
        switch(device.getType()) {
            case DISK:
                if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
                    if (srcDeviceIdToDstDeviceIdMapping.containsKey(device.getDeviceId())) {
                        deviceId = srcDeviceIdToDstDeviceIdMapping.get(device.getDeviceId());
                    }
                } else if (VmDeviceType.CDROM.getName().equals(device.getDevice())) {
                    if (!hasCd) {
                        hasCd = true;
                        // check here is source VM had CD (VM from snapshot)
                        String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
                        specParams.putAll(getCdDeviceSpecParams(srcCdPath, dstCdPath));
                    } else {
                        // CD already exists
                        continue;
                    }
                }
                break;
            case INTERFACE:
                if (srcDeviceIdToDstDeviceIdMapping.containsKey(device.getDeviceId())) {
                    deviceId = srcDeviceIdToDstDeviceIdMapping.get(device.getDeviceId());
                }
                break;
            case CONTROLLER:
                if (VmDeviceType.USB.getName().equals(device.getDevice())) {
                    specParams = device.getSpecParams();
                } else if (VmDeviceType.VIRTIOSCSI.getName().equals(device.getDevice())) {
                    hasVirtioScsi = true;
                    if (Boolean.FALSE.equals(isVirtioScsiEnabled)) {
                        continue;
                    }
                }
                break;
            case VIDEO:
                if (dstIsVm) {
                    // to the new Vm params.
                    continue;
                }
                specParams.putAll(getVideoDeviceSpecParams(dstVmBase));
                break;
            case BALLOON:
                if (!isBalloonEnabled) {
                    continue;
                }
                hasBalloon = true;
                specParams.putAll(getMemoryBalloonSpecParams());
                break;
            case SMARTCARD:
                specParams.putAll(getSmartcardDeviceSpecParams());
                break;
            case WATCHDOG:
                specParams.putAll(device.getSpecParams());
                break;
            case RNG:
                if (hasRng) {
                    continue;
                }
                if (!new VirtIoRngValidator().canAddRngDevice(cluster, new VmRngDevice(device), dstVmBase.getCustomCompatibilityVersion()).isValid()) {
                    continue;
                }
                final VmRngDevice rngDevice = new VmRngDevice(device);
                if (versionToUpdateRngDeviceWith != null) {
                    rngDevice.updateSourceByVersion(versionToUpdateRngDeviceWith);
                }
                specParams.putAll(rngDevice.getSpecParams());
                break;
            case CONSOLE:
                if (!isConsoleEnabled) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                hasConsole = true;
                break;
            case SOUND:
                if (!isSoundEnabled) {
                    continue;
                }
                hasSound = true;
                break;
            case GRAPHICS:
                GraphicsType type = GraphicsType.fromVmDeviceType(VmDeviceType.getByName(device.getDevice()));
                // OR if we already have it
                if (graphicsToSkip.contains(type) || hasGraphicsDevice(dstId, GraphicsType.fromString(device.getDevice()))) {
                    continue;
                }
                break;
            case HOSTDEV:
                if (!copyHostDevices) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                break;
            default:
                break;
        }
        device.setId(new VmDeviceId(deviceId, dstId));
        device.setSpecParams(specParams);
        vmDeviceDao.save(device);
    }
    if (!hasCd) {
        addCdDevice(dstId, dstCdPath);
    }
    updateUsbSlots(srcVmBase, dstVmBase);
    if (isSoundEnabled && !hasSound) {
        if (dstIsVm) {
            addSoundDevice(dstVmBase);
        } else {
            addSoundDevice(dstVmBase.getId(), dstVmBase.getOsId(), cluster != null ? cluster.getCompatibilityVersion() : null);
        }
    }
    if (isConsoleEnabled && !hasConsole) {
        addConsoleDevice(dstId);
    }
    if (Boolean.TRUE.equals(isVirtioScsiEnabled) && !hasVirtioScsi) {
        addVirtioScsiController(dstVmBase, getVmCompatibilityVersion(dstVmBase));
    }
    if (isBalloonEnabled && !hasBalloon) {
        addMemoryBalloon(dstId);
    }
    if (dstIsVm) {
        addVideoDevices(dstVmBase, getNeededNumberOfVideoDevices(dstVmBase));
    }
}
#end_block

#method_before
public void copyVmDevices(Guid srcId, Guid dstId, Map<Guid, Guid> srcDeviceIdToDstDeviceIdMapping, boolean isSoundEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices, Version versionToUpdateRndDeviceWith) {
    VmBase srcVmBase = getVmBase(srcId);
    VmBase dstVmBase = getVmBase(dstId);
    List<VmDevice> srcDevices = vmDeviceDao.getVmDeviceByVmId(srcId);
    copyVmDevices(srcId, dstId, dstVmBase, srcDevices, srcDeviceIdToDstDeviceIdMapping, isSoundEnabled, isConsoleEnabled, isVirtioScsiEnabled, isBalloonEnabled, graphicsToSkip, copySnapshotDevices, canCopyHostDevices(srcVmBase, dstVmBase), versionToUpdateRndDeviceWith);
}
#method_after
public void copyVmDevices(Guid srcId, Guid dstId, Map<Guid, Guid> srcDeviceIdToDstDeviceIdMapping, boolean isSoundEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices, Version versionToUpdateRndDeviceWith) {
    VmBase srcVmBase = getVmBase(srcId);
    VmBase dstVmBase = getVmBase(dstId);
    List<VmDevice> srcDevices = vmDeviceDao.getVmDeviceByVmId(srcId);
    copyVmDevices(srcId, dstId, srcVmBase, dstVmBase, srcDevices, srcDeviceIdToDstDeviceIdMapping, isSoundEnabled, isConsoleEnabled, isVirtioScsiEnabled, isBalloonEnabled, graphicsToSkip, copySnapshotDevices, canCopyHostDevices(srcVmBase, dstVmBase), versionToUpdateRndDeviceWith);
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (getVm().getStatus() != VMStatus.Up) {
        return failVmStatusIllegal();
    }
    if (getParameters().getPlugAction() == PlugAction.PLUG) {
        if (!FeatureSupported.hotPlugMemory(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
            return failValidation(EngineMessage.HOT_PLUG_MEMORY_IS_NOT_SUPPORTED);
        }
        // check max slots
        List<VmDevice> memDevices = vmDeviceDao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.MEMORY);
        if (memDevices.size() == Config.<Integer>getValue(ConfigValues.MaxMemorySlots)) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NO_MORE_MEMORY_SLOTS, "$maxMemSlots " + Config.getValue(ConfigValues.MaxMemorySlots).toString());
        }
        final int hotplugMemorySizeFactor = getHotplugMemorySizeFactor(getVm().getClusterArch());
        if (getParameters().getMemoryDeviceSizeMb() % hotplugMemorySizeFactor != 0) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NOT_PLUGGED_MEMORY_ON_ARCH_MUST_BE_DIVIDABLE_BY, ReplacementUtils.createSetVariableString("architecture", getVm().getClusterArch()), ReplacementUtils.createSetVariableString("memorySize", getParameters().getMemoryDeviceSizeMb()), ReplacementUtils.createSetVariableString("factor", hotplugMemorySizeFactor));
        }
    } else if (!FeatureSupported.hotUnplugMemory(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
        return failValidation(EngineMessage.HOT_UNPLUG_MEMORY_IS_NOT_SUPPORTED);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (getVm().getStatus() != VMStatus.Up) {
        return failVmStatusIllegal();
    }
    if (getParameters().getPlugAction() == PlugAction.PLUG) {
        if (!FeatureSupported.hotPlugMemory(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
            return failValidation(EngineMessage.HOT_PLUG_MEMORY_IS_NOT_SUPPORTED);
        }
        // check max slots
        List<VmDevice> memDevices = vmDeviceDao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.MEMORY);
        if (memDevices.size() == Config.<Integer>getValue(ConfigValues.MaxMemorySlots)) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NO_MORE_MEMORY_SLOTS, "$maxMemSlots " + Config.getValue(ConfigValues.MaxMemorySlots).toString());
        }
        final int hotplugMemorySizeFactor = getVm().getClusterArch().getHotplugMemorySizeFactorMb();
        if (getParameters().getMemoryDeviceSizeMb() % hotplugMemorySizeFactor != 0) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NOT_PLUGGED_MEMORY_ON_ARCH_MUST_BE_DIVIDABLE_BY, ReplacementUtils.createSetVariableString("architecture", getVm().getClusterArch()), ReplacementUtils.createSetVariableString("memorySize", getParameters().getMemoryDeviceSizeMb()), ReplacementUtils.createSetVariableString("factor", hotplugMemorySizeFactor));
        }
    } else if (!FeatureSupported.hotUnplugMemory(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
        return failValidation(EngineMessage.HOT_UNPLUG_MEMORY_IS_NOT_SUPPORTED);
    }
    return true;
}
#end_block

#method_before
private static String getMessageOrNull(AuditLogType logType) {
    final String key = logType.name();
    try {
        return resourceBundle.getString(key);
    } catch (Exception e) {
        log.error("Key '{}' is not translated in '{}'", key, getResourceBundleName());
        return null;
    }
}
#method_after
protected static String getMessageOrNull(AuditLogType logType) {
    final String key = logType.name();
    try {
        return resourceBundle.getString(key);
    } catch (Exception e) {
        log.error("Key '{}' is not translated in '{}'", key, getResourceBundleName());
        return null;
    }
}
#end_block

#method_before
private static String getMessageOrNull(AuditLogType logType) {
    final String key = logType.name();
    try {
        return resourceBundle.getString(key);
    } catch (Exception e) {
        log.error("Key '{}' is not translated in '{}'", key, getResourceBundleName());
        return null;
    }
}
#method_after
protected static String getMessageOrNull(AuditLogType logType) {
    final String key = logType.name();
    try {
        return resourceBundle.getString(key);
    } catch (Exception e) {
        log.error("Key '{}' is not translated in '{}'", key, getResourceBundleName());
        return null;
    }
}
#end_block

#method_before
public boolean discover() {
    boolean dbUpdated = false;
    Optional<ExternalSchedulerDiscoveryResult> discoveryResult = broker.runDiscover();
    if (discoveryResult.isPresent()) {
        updateDB(discoveryResult.get());
        log.debug("PolicyUnits updated for external broker.");
        dbUpdated = true;
    } else {
        AuditLogable loggable = new AuditLogableImpl();
        new AuditLogDirector().log(loggable, AuditLogType.FAILED_TO_CONNECT_TO_SCHEDULER_PROXY);
        log.warn("Discovery returned empty result when talking to broker. Disabling external units");
        List<PolicyUnit> failingPolicyUnits = policyUnitDao.getAll().stream().collect(Collectors.toList());
        markExternalPoliciesAsDisabled(failingPolicyUnits);
        dbUpdated = true;
    }
    return dbUpdated;
}
#method_after
public boolean discover() {
    boolean dbUpdated;
    Optional<ExternalSchedulerDiscoveryResult> discoveryResult = broker.runDiscover();
    if (discoveryResult.isPresent()) {
        updateDB(discoveryResult.get());
        log.debug("PolicyUnits updated for external broker.");
        dbUpdated = true;
    } else {
        AuditLogable loggable = new AuditLogableImpl();
        new AuditLogDirector().log(loggable, AuditLogType.FAILED_TO_CONNECT_TO_SCHEDULER_PROXY);
        log.warn("Discovery returned empty result when talking to broker. Disabling external units");
        List<PolicyUnit> failingPolicyUnits = policyUnitDao.getAll().stream().collect(Collectors.toList());
        markExternalPoliciesAsDisabled(failingPolicyUnits);
        dbUpdated = true;
    }
    return dbUpdated;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    AuditLogableBase event = Injector.injectMembers(new AuditLogableBase(getParameters().getEvent()));
    event.setExternal(true);
    String message = truncateMessage(getEvent().getMessage());
    switch(getEvent().getSeverity()) {
        case NORMAL:
            auditLogDirector.log(event, AuditLogType.EXTERNAL_EVENT_NORMAL, message);
            break;
        case WARNING:
            auditLogDirector.log(event, AuditLogType.EXTERNAL_EVENT_WARNING, message);
            break;
        case ERROR:
            auditLogDirector.log(event, AuditLogType.EXTERNAL_EVENT_ERROR, message);
            break;
        case ALERT:
            AlertDirector.alert(event, AuditLogType.EXTERNAL_ALERT, auditLogDirector, message);
            break;
    }
    AuditLog auditLog = auditLogDao.getByOriginAndCustomEventId(getEvent().getOrigin(), getEvent().getCustomEventId());
    if (auditLog != null) {
        setActionReturnValue(auditLog.getAuditLogId());
        setSucceeded(true);
    }
    // Update host external status if set
    if (hasHostExternalStatus()) {
        vdsDynamicDao.updateExternalStatus(getEvent().getVdsId(), getParameters().getExternalStatus());
    }
    // update storage domain external status if set
    if (hasStorageDomainExternalStatus()) {
        storageDomainDynamicDao.updateExternalStatus(getEvent().getStorageDomainId(), getParameters().getExternalStatus());
    }
}
#method_after
@Override
protected void executeCommand() {
    AuditLogableBase event = Injector.injectMembers(new AuditLogableBase(getParameters().getEvent()));
    event.setExternal(true);
    String message = StringUtils.abbreviate(getEvent().getMessage(), Config.getValue(ConfigValues.MaxAuditLogMessageLength));
    switch(getEvent().getSeverity()) {
        case NORMAL:
            auditLogDirector.log(event, AuditLogType.EXTERNAL_EVENT_NORMAL, message);
            break;
        case WARNING:
            auditLogDirector.log(event, AuditLogType.EXTERNAL_EVENT_WARNING, message);
            break;
        case ERROR:
            auditLogDirector.log(event, AuditLogType.EXTERNAL_EVENT_ERROR, message);
            break;
        case ALERT:
            AlertDirector.alert(event, AuditLogType.EXTERNAL_ALERT, auditLogDirector, message);
            break;
    }
    AuditLog auditLog = auditLogDao.getByOriginAndCustomEventId(getEvent().getOrigin(), getEvent().getCustomEventId());
    if (auditLog != null) {
        setActionReturnValue(auditLog.getAuditLogId());
        setSucceeded(true);
    }
    // Update host external status if set
    if (hasHostExternalStatus()) {
        vdsDynamicDao.updateExternalStatus(getEvent().getVdsId(), getParameters().getExternalStatus());
    }
    // update storage domain external status if set
    if (hasStorageDomainExternalStatus()) {
        storageDomainDynamicDao.updateExternalStatus(getEvent().getStorageDomainId(), getParameters().getExternalStatus());
    }
}
#end_block

#method_before
@Test
public void testSaveExternalEvent() {
    AuditLog newExternalEvent = new AuditLog();
    newExternalEvent.setLogType(AuditLogType.EXTERNAL_EVENT_NORMAL);
    newExternalEvent.setExternal(true);
    newExternalEvent.setOrigin("XYZ");
    newExternalEvent.setCustomEventId(123123123);
    newExternalEvent.setCustomData("Some text here");
    newExternalEvent.setMessage("And here");
    newExternalEvent.setEventFloodInSec(100);
    dao.save(newExternalEvent);
    AuditLog result = dao.get(newExternalEvent.getAuditLogId());
    assertNotNull(result);
    assertEquals(newExternalEvent.getOrigin(), result.getOrigin());
    assertEquals(newExternalEvent.getCustomEventId(), result.getCustomEventId());
    assertEquals(newExternalEvent.getCustomData(), result.getCustomData());
    assertEquals(newExternalEvent.getMessage(), result.getMessage());
    assertEquals(newExternalEvent.getEventFloodInSec(), result.getEventFloodInSec());
}
#method_after
@Test
public void testSaveExternalEvent() {
    AuditLog newExternalEvent = new AuditLog();
    newExternalEvent.setLogType(AuditLogType.EXTERNAL_EVENT_NORMAL);
    newExternalEvent.setExternal(true);
    newExternalEvent.setOrigin("XYZ");
    newExternalEvent.setCustomEventId(123123123);
    newExternalEvent.setCustomData("Some text here");
    newExternalEvent.setMessage("And here");
    newExternalEvent.setEventFloodInSec(100);
    dao.save(newExternalEvent);
    AuditLog result = dao.get(newExternalEvent.getAuditLogId());
    assertNotNull(result);
    assertTrue(result.getAuditLogId() > 0);
    assertEquals(newExternalEvent.getOrigin(), result.getOrigin());
    assertEquals(newExternalEvent.getCustomEventId(), result.getCustomEventId());
    assertEquals(newExternalEvent.getCustomData(), result.getCustomData());
    assertEquals(newExternalEvent.getMessage(), result.getMessage());
    assertEquals(newExternalEvent.getEventFloodInSec(), result.getEventFloodInSec());
}
#end_block

#method_before
protected boolean updateVnicForBackwardCompatibility(VmNic oldNic) {
    if (!validate(VnicProfileHelper.updateNicForBackwardCompatibility(getParameters().getInterface(), oldNic, getParameters().getNetworkName(), getParameters().isPortMirroring(), getVm().getStaticData(), getCurrentUser()))) {
        return false;
    }
    return true;
}
#method_after
protected boolean updateVnicForBackwardCompatibility(VmNic oldNic) {
    if (!validate(backwardCompatibilityVnicHelper.updateNicForBackwardCompatibility(getParameters().getInterface(), oldNic, getParameters().getNetworkName(), getParameters().isPortMirroring(), getVm().getStaticData(), getCurrentUser()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void endActionOnAllImageGroups() {
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        getBackend().endAction(VdcActionType.CopyImageGroup, p, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
        initQcowVersionForDisks(((MoveOrCopyImageGroupParameters) p).getDestImageGroupId());
    }
}
#method_after
@Override
protected void endActionOnAllImageGroups() {
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        getBackend().endAction(VdcActionType.CopyImageGroup, p, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
    }
}
#end_block

#method_before
protected boolean setAndValidateCpuProfile() {
    getVmTemplate().setClusterId(getClusterId());
    getVmTemplate().setCpuProfileId(getParameters().getCpuProfileId());
    return validate(cpuProfileHelper.setAndValidateCpuProfile(getVmTemplate(), getUserId()));
}
#method_after
protected boolean setAndValidateCpuProfile() {
    getVmTemplate().setClusterId(getClusterId());
    getVmTemplate().setCpuProfileId(getParameters().getCpuProfileId());
    return validate(cpuProfileHelper.setAndValidateCpuProfile(getVmTemplate(), getUserIdIfExternal().orElse(null)));
}
#end_block

#method_before
protected boolean setAndValidateCpuProfile() {
    getVm().getStaticData().setClusterId(getClusterId());
    getVm().getStaticData().setCpuProfileId(getParameters().getCpuProfileId());
    return validate(cpuProfileHelper.setAndValidateCpuProfile(getVm().getStaticData(), getUserId()));
}
#method_after
protected boolean setAndValidateCpuProfile() {
    getVm().getStaticData().setClusterId(getClusterId());
    getVm().getStaticData().setCpuProfileId(getParameters().getCpuProfileId());
    return validate(cpuProfileHelper.setAndValidateCpuProfile(getVm().getStaticData(), getUserIdIfExternal().orElse(null)));
}
#end_block

#method_before
protected boolean shouldPerformOvfUpdate() {
    return !getParameters().isInactive() && getStorageDomain().getStatus() == StorageDomainStatus.Active && getStorageDomain().getStorageDomainType().isDataDomain();
}
#method_after
protected boolean shouldPerformOvfUpdate() {
    return !getParameters().isInactive() && StorageConstants.monitoredDomainStatuses.contains(getStorageDomain().getStatus()) && getStorageDomain().getStorageDomainType().isDataDomain();
}
#end_block

#method_before
protected boolean setAndValidateCpuProfile() {
    return validate(cpuProfileHelper.setAndValidateCpuProfile(getParameters().getVm().getStaticData(), getUserId()));
}
#method_after
protected boolean setAndValidateCpuProfile() {
    return validate(cpuProfileHelper.setAndValidateCpuProfile(getParameters().getVm().getStaticData(), getUserIdIfExternal().orElse(null)));
}
#end_block

#method_before
private AuditLogType attemptToAttachDisksToImportedVm(Collection<Disk> disks) {
    List<String> failedDisks = new LinkedList<>();
    for (Disk disk : disks) {
        AttachDetachVmDiskParameters params = new AttachDetachVmDiskParameters(new DiskVmElement(disk.getId(), getVm().getId()), disk.getPlugged(), disk.getReadOnly());
        VdcReturnValueBase returnVal = runInternalAction(VdcActionType.AttachDiskToVm, params, cloneContextAndDetachFromParent());
        if (!returnVal.getSucceeded()) {
            failedDisks.add(disk.getDiskAlias());
        }
    }
    if (!failedDisks.isEmpty()) {
        this.addCustomValue("DiskAliases", StringUtils.join(failedDisks, ","));
        return AuditLogType.VM_IMPORT_FROM_CONFIGURATION_ATTACH_DISKS_FAILED;
    }
    return AuditLogType.VM_IMPORT_FROM_CONFIGURATION_EXECUTED_SUCCESSFULLY;
}
#method_after
private AuditLogType attemptToAttachDisksToImportedVm(Collection<Disk> disks) {
    List<String> failedDisks = new LinkedList<>();
    for (Disk disk : disks) {
        DiskVmElement dve = disk.getDiskVmElements().iterator().next();
        AttachDetachVmDiskParameters params = new AttachDetachVmDiskParameters(new DiskVmElement(disk.getId(), getVm().getId()), dve.isPlugged(), dve.isReadOnly());
        VdcReturnValueBase returnVal = runInternalAction(VdcActionType.AttachDiskToVm, params, cloneContextAndDetachFromParent());
        if (!returnVal.getSucceeded()) {
            failedDisks.add(disk.getDiskAlias());
        }
    }
    if (!failedDisks.isEmpty()) {
        this.addCustomValue("DiskAliases", StringUtils.join(failedDisks, ","));
        return AuditLogType.VM_IMPORT_FROM_CONFIGURATION_ATTACH_DISKS_FAILED;
    }
    return AuditLogType.VM_IMPORT_FROM_CONFIGURATION_EXECUTED_SUCCESSFULLY;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final DisplayNetworkClusterHelper displayNetworkClusterHelper = new DisplayNetworkClusterHelper(networkClusterDao, vmDao, getNetworkCluster(), getNetworkName(), auditLogDirector);
    if (displayNetworkClusterHelper.isDisplayToBeUpdated()) {
        displayNetworkClusterHelper.warnOnActiveVm();
    }
    networkClusterDao.update(getNetworkCluster());
    final Network managementNetwork;
    if (getNetworkCluster().isManagement() && !getOldNetworkCluster().isManagement()) {
        networkClusterDao.setNetworkExclusivelyAsManagement(getClusterId(), getPersistedNetwork().getId());
        managementNetwork = getPersistedNetwork();
    } else {
        managementNetwork = managementNetworkUtil.getManagementNetwork(getClusterId());
    }
    if (getNetworkCluster().isDisplay() != getOldNetworkCluster().isDisplay()) {
        networkClusterDao.setNetworkExclusivelyAsDisplay(getClusterId(), getNetworkCluster().isDisplay() ? getPersistedNetwork().getId() : managementNetwork.getId());
    }
    if (getNetworkCluster().isMigration() != getOldNetworkCluster().isMigration()) {
        networkClusterDao.setNetworkExclusivelyAsMigration(getClusterId(), getNetworkCluster().isMigration() ? getPersistedNetwork().getId() : managementNetwork.getId());
    }
    if (getNetworkCluster().isGluster() != getOldNetworkCluster().isGluster()) {
        networkClusterDao.setNetworkExclusivelyAsGluster(getClusterId(), getNetworkCluster().isGluster() ? getPersistedNetwork().getId() : null);
    }
    if (getNetworkCluster().isDefaultRoute() != getOldNetworkCluster().isDefaultRoute()) {
        networkClusterDao.setNetworkExclusivelyAsDefaultRoute(getClusterId(), getNetworkCluster().isDefaultRoute() ? getPersistedNetwork().getId() : managementNetwork.getId());
    }
    networkClusterHelper.setStatus(getClusterId(), getPersistedNetwork());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    final DisplayNetworkClusterHelper displayNetworkClusterHelper = new DisplayNetworkClusterHelper(networkClusterDao, vmDao, clusterDao, getNetworkCluster(), getNetworkName(), auditLogDirector);
    if (displayNetworkClusterHelper.isDisplayToBeUpdated()) {
        displayNetworkClusterHelper.warnOnActiveVm();
    }
    preserveStatus();
    networkClusterDao.update(getNetworkCluster());
    final Network managementNetwork;
    if (getNetworkCluster().isManagement() && !getOldNetworkCluster().isManagement()) {
        networkClusterDao.setNetworkExclusivelyAsManagement(getClusterId(), getPersistedNetwork().getId());
        managementNetwork = getPersistedNetwork();
    } else {
        managementNetwork = managementNetworkUtil.getManagementNetwork(getClusterId());
    }
    if (getNetworkCluster().isDisplay() != getOldNetworkCluster().isDisplay()) {
        networkClusterDao.setNetworkExclusivelyAsDisplay(getClusterId(), getNetworkCluster().isDisplay() ? getPersistedNetwork().getId() : managementNetwork.getId());
    }
    if (getNetworkCluster().isMigration() != getOldNetworkCluster().isMigration()) {
        networkClusterDao.setNetworkExclusivelyAsMigration(getClusterId(), getNetworkCluster().isMigration() ? getPersistedNetwork().getId() : managementNetwork.getId());
    }
    if (getNetworkCluster().isGluster() != getOldNetworkCluster().isGluster()) {
        networkClusterDao.setNetworkExclusivelyAsGluster(getClusterId(), getNetworkCluster().isGluster() ? getPersistedNetwork().getId() : null);
    }
    if (getNetworkCluster().isDefaultRoute() != getOldNetworkCluster().isDefaultRoute()) {
        networkClusterDao.setNetworkExclusivelyAsDefaultRoute(getClusterId(), getNetworkCluster().isDefaultRoute() ? getPersistedNetwork().getId() : managementNetwork.getId());
    }
    networkClusterHelper.setStatus(getClusterId(), getPersistedNetwork());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean validate() {
    AuditLog event = auditLogDao.get(getParameters().getAuditLogId());
    if (event == null) {
        return failValidation(EngineMessage.AUDIT_LOG_CANNOT_REMOVE_AUDIT_LOG_NOT_EXIST);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getAuditLog() == null) {
        return failValidation(EngineMessage.AUDIT_LOG_CANNOT_REMOVE_AUDIT_LOG_NOT_EXIST);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    AuditLog auditLog = auditLogDao.get(getParameters().getAuditLogId());
    auditLogDao.remove(getParameters().getAuditLogId());
    setAuditLogDetails(auditLog);
    // clean cache manager entry (if exists)
    evict(auditLogDirector.composeSystemObjectId(this, auditLog.getLogType()));
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    AuditLog auditLog = getAuditLog();
    auditLogDao.remove(getParameters().getAuditLogId());
    setAuditLogDetails(auditLog);
    // clear the id so the auditLog will be considered as a system-level auditLog
    auditLog.setUserId(Guid.Empty);
    AuditLogableBase logableToClear = new AuditLogableBase(auditLog);
    // clean cache manager entry (if exists)
    EventFloodRegulator eventFloodRegulator = new EventFloodRegulator(logableToClear, auditLog.getLogType());
    eventFloodRegulator.evict();
    setSucceeded(true);
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    AuditLog event = auditLogDao.get(getParameters().getAuditLogId());
    if (AuditLogSeverity.ALERT.equals(event.getSeverity())) {
        return Collections.singletonList(new PermissionSubject(Guid.SYSTEM, VdcObjectType.System, ActionGroup.AUDIT_LOG_MANAGEMENT));
    }
    return getPermissionList(event);
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    AuditLog event = getAuditLog();
    if (AuditLogSeverity.ALERT.equals(event.getSeverity())) {
        return Collections.singletonList(new PermissionSubject(Guid.SYSTEM, VdcObjectType.System, ActionGroup.AUDIT_LOG_MANAGEMENT));
    }
    return getPermissionList(event);
}
#end_block

#method_before
@Override
public VdcReturnValueBase endAction() {
    boolean shouldEndAction = handleCommandExecutionEnded();
    if (shouldEndAction) {
        handleStepsOnEnd();
        handleChildCommands();
        try {
            initiateLockEndAction();
            setActionState();
            handleTransactivity();
            TransactionSupport.executeInScope(endActionScope, this);
        } catch (TransactionRolledbackLocalException e) {
            log.info("endAction: Transaction was aborted in {}", this.getClass().getName());
        } finally {
            endStepsAndJobIfNeeded();
            freeLockEndAction();
            // NOTE: this update persists updates made during the endSuccessfully()/endWithFailure() execution.
            // The update is done intentionally after the freeLock() call, change with care.
            persistCommandIfNeeded();
            if (getCommandShouldBeLogged()) {
                logCommand();
            }
        }
    } else {
        getReturnValue().setSucceeded(true);
    }
    return getReturnValue();
}
#method_after
@Override
public VdcReturnValueBase endAction() {
    boolean shouldEndAction = handleCommandExecutionEnded();
    if (shouldEndAction) {
        handleStepsOnEnd();
        handleChildCommands();
        try {
            initiateLockEndAction();
            setActionState();
            handleTransactivity();
            TransactionSupport.executeInScope(endActionScope, this);
        } catch (TransactionRolledbackLocalException e) {
            log.info("endAction: Transaction was aborted in {}", this.getClass().getName());
        } finally {
            endStepsAndJobIfNeeded();
            freeLockEndAction();
            // NOTE: this update persists updates made during the endSuccessfully()/endWithFailure() execution.
            // The update is done intentionally after the freeLock() call, change with care.
            updateCommandIfNeeded();
            if (getCommandShouldBeLogged()) {
                logCommand();
            }
        }
    } else {
        getReturnValue().setSucceeded(true);
    }
    return getReturnValue();
}
#end_block

#method_before
void logRenamedEntity() {
    if (this instanceof RenamedEntityInfoProvider) {
        RenamedEntityInfoProvider renameable = (RenamedEntityInfoProvider) this;
        String oldEntityName = renameable.getEntityOldName();
        String newEntityName = renameable.getEntityNewName();
        if (!StringUtils.equals(oldEntityName, newEntityName)) {
            // log entity rename details
            AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase());
            String entityType = renameable.getEntityType();
            logable.addCustomValue("EntityType", entityType);
            logable.addCustomValue("OldEntityName", oldEntityName);
            logable.addCustomValue("NewEntityName", newEntityName);
            logable.addCustomValue("UserName", getCurrentUser().getLoginName());
            renameable.setEntityId(logable);
            auditLog(logable, AuditLogType.ENTITY_RENAMED);
        }
    }
}
#method_after
void logRenamedEntity() {
    if (this instanceof RenamedEntityInfoProvider) {
        RenamedEntityInfoProvider renameable = (RenamedEntityInfoProvider) this;
        String oldEntityName = renameable.getEntityOldName();
        String newEntityName = renameable.getEntityNewName();
        if (!StringUtils.equals(oldEntityName, newEntityName)) {
            // log entity rename details
            AuditLogableBase logable = new AuditLogableBase();
            String entityType = renameable.getEntityType();
            logable.addCustomValue("EntityType", entityType);
            logable.addCustomValue("OldEntityName", oldEntityName);
            logable.addCustomValue("NewEntityName", newEntityName);
            logable.addCustomValue("UserName", getCurrentUser().getLoginName());
            renameable.setEntityId(logable);
            auditLog(logable, AuditLogType.ENTITY_RENAMED);
        }
    }
}
#end_block

#method_before
protected final boolean failValidation(EngineMessage message, String... variableReplacements) {
    return failValidation(Collections.singletonList(message), variableReplacements);
}
#method_after
protected final boolean failValidation(EngineMessage message, String... variableReplacements) {
    return failValidation(message, Arrays.asList(variableReplacements));
}
#end_block

#method_before
protected final boolean failValidation(List<EngineMessage> messages, String... variableReplacements) {
    addValidationMessages(messages);
    for (String variableReplacement : variableReplacements) {
        addValidationMessage(variableReplacement);
    }
    return false;
}
#method_after
protected final boolean failValidation(EngineMessage message, Collection<String> variableReplacements) {
    return failValidation(Collections.singletonList(message), variableReplacements);
}
#end_block

#method_before
protected final boolean failValidation(List<EngineMessage> messages, String... variableReplacements) {
    addValidationMessages(messages);
    for (String variableReplacement : variableReplacements) {
        addValidationMessage(variableReplacement);
    }
    return false;
}
#method_after
protected final boolean failValidation(List<EngineMessage> messages, String... variableReplacements) {
    return failValidation(messages, Arrays.asList(variableReplacements));
}
#end_block

#method_before
private void updateImagesInfo() {
    for (DiskImage image : diskImageDao.getAllSnapshotsForImageGroup(getParameters().getImageGroupID())) {
        VDSReturnValue ret = runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getTargetStorageDomainId(), getParameters().getImageGroupID(), image.getImageId()));
        DiskImage imageFromIRS = (DiskImage) ret.getReturnValue();
        DiskImageDynamic diskImageDynamic = diskImageDynamicDao.get(image.getImageId());
        // Update image's actual size in DB
        if (imageFromIRS != null && diskImageDynamic != null) {
            diskImageDynamic.setActualSize(imageFromIRS.getActualSizeInBytes());
            diskImageDynamicDao.update(diskImageDynamic);
        }
    }
}
#method_after
private void updateImagesInfo() {
    for (DiskImage image : diskImageDao.getAllSnapshotsForImageGroup(getParameters().getImageGroupID())) {
        VDSReturnValue ret = runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getTargetStorageDomainId(), getParameters().getImageGroupID(), image.getImageId()));
        DiskImage imageFromIRS = (DiskImage) ret.getReturnValue();
        setQcowCompatForSnapshot(image, imageFromIRS);
        DiskImageDynamic diskImageDynamic = diskImageDynamicDao.get(image.getImageId());
        // Update image's actual size in DB
        if (imageFromIRS != null && diskImageDynamic != null) {
            diskImageDynamic.setActualSize(imageFromIRS.getActualSizeInBytes());
            diskImageDynamicDao.update(diskImageDynamic);
        }
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!isFloatingDisk() && (!validate(new VmValidator(getVm()).isVmExists()) || !validateDiskVmData())) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE || diskInfo.getDiskStorageType() == DiskStorageType.CINDER) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    DiskVmElementValidator diskVmElementValidator = getDiskVmElementValidator(getParameters().getDiskInfo(), getDiskVmElement());
    if (vm != null) {
        if (!validateDiskVmData() || !canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        if (getDiskVmElement().isBoot() && !validate(diskValidator.isVmNotContainsBootDisk(vm))) {
            return false;
        }
        if (!validatePassDiscardSupported(diskVmElementValidator)) {
            return false;
        }
        // if user sent drive check that its not in use
        if (!isDiskPassPciAndIdeLimit()) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failValidation(EngineMessage.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    if (!validate(diskVmElementValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (!validateQuota()) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        if (!checkIfImageDiskCanBeAdded(vm, diskVmElementValidator)) {
            return false;
        }
        return setAndValidateDiskProfiles();
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    if (DiskStorageType.CINDER == getParameters().getDiskInfo().getDiskStorageType()) {
        CinderDisk cinderDisk = (CinderDisk) getParameters().getDiskInfo();
        cinderDisk.setStorageIds(new ArrayList<>(Collections.singletonList(getStorageDomainId())));
        StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisk);
        return validate(storageDomainValidator.isDomainExistAndActive()) && validate(cinderDisksValidator.validateCinderDiskLimits()) && validate(cinderDisksValidator.validateCinderVolumeTypesExist());
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!isFloatingDisk() && (!validate(new VmValidator(getVm()).isVmExists()) || !validateDiskVmData())) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE || diskInfo.getDiskStorageType() == DiskStorageType.CINDER) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    DiskVmElementValidator diskVmElementValidator = getDiskVmElementValidator(getParameters().getDiskInfo(), getDiskVmElement());
    if (vm != null) {
        if (!validateDiskVmData() || !canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        if (getDiskVmElement().isBoot() && !validate(diskValidator.isVmNotContainsBootDisk(vm))) {
            return false;
        }
        if (!validatePassDiscardSupported(diskVmElementValidator)) {
            return false;
        }
        // if user sent drive check that its not in use
        if (!isDiskPassPciAndIdeLimit()) {
            return false;
        }
        if (!validate(diskVmElementValidator.isReadOnlyPropertyCompatibleWithInterface())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failValidation(EngineMessage.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    if (!validateQuota()) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        if (!checkIfImageDiskCanBeAdded(vm, diskVmElementValidator)) {
            return false;
        }
        return setAndValidateDiskProfiles();
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    if (DiskStorageType.CINDER == getParameters().getDiskInfo().getDiskStorageType()) {
        CinderDisk cinderDisk = (CinderDisk) getParameters().getDiskInfo();
        cinderDisk.setStorageIds(new ArrayList<>(Collections.singletonList(getStorageDomainId())));
        StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisk);
        return validate(storageDomainValidator.isDomainExistAndActive()) && validate(cinderDisksValidator.validateCinderDiskLimits()) && validate(cinderDisksValidator.validateCinderVolumeTypesExist());
    }
    return true;
}
#end_block

#method_before
protected VmDevice addManagedDeviceForDisk(Guid diskId) {
    return getVmDeviceUtils().addDiskDevice(getVmId(), diskId, shouldDiskBePlugged(), Boolean.TRUE.equals(getParameters().getDiskInfo().getReadOnly()));
}
#method_after
protected VmDevice addManagedDeviceForDisk(Guid diskId) {
    return getVmDeviceUtils().addDiskDevice(getVmId(), diskId, shouldDiskBePlugged(), Boolean.TRUE.equals(getParameters().getDiskVmElement().isReadOnly()));
}
#end_block

#method_before
private DbUser buildUser(T params, String authzName) {
    DbUser dbUser = dbUserDao.getByExternalId(authzName, params.getPrincipalId());
    DbUser user = new DbUser(dbUser);
    user.setId(dbUser == null ? Guid.newGuid() : dbUser.getId());
    user.setExternalId(params.getPrincipalId());
    user.setDomain(authzName);
    user.setEmail(params.getEmail());
    user.setFirstName(params.getFirstName());
    user.setLastName(params.getLastName());
    user.setNamespace(params.getNamespace());
    user.setLoginName(params.getPrincipalName());
    List<Guid> groupIds = new ArrayList<>();
    List<String> groupRecordIds = new ArrayList<>();
    flatGroups((Collection<ExtMap>) params.getGroupIds(), groupRecordIds);
    for (String groupId : groupRecordIds) {
        DbGroup dbGroup = dbGroupDao.getByExternalId(authzName, groupId);
        if (dbGroup != null) {
            groupIds.add(dbGroup.getId());
        }
    }
    user.setGroupIds(groupIds);
    user.setAdmin(!roleDao.getAnyAdminRoleForUserAndGroups(user.getId(), StringUtils.join(user.getGroupIds(), ",")).isEmpty());
    if (dbUser == null) {
        dbUserDao.save(user);
    } else if (!dbUser.equals(user)) {
        dbUserDao.update(user);
    }
    return user;
}
#method_after
private DbUser buildUser(T params, String authzName) {
    DbUser dbUser = dbUserDao.getByExternalId(authzName, params.getPrincipalId());
    DbUser user = new DbUser(dbUser);
    user.setId(dbUser == null ? Guid.newGuid() : dbUser.getId());
    user.setExternalId(params.getPrincipalId());
    user.setDomain(authzName);
    user.setEmail(params.getEmail());
    user.setFirstName(params.getFirstName());
    user.setLastName(params.getLastName());
    user.setNamespace(params.getNamespace());
    user.setLoginName(params.getPrincipalName());
    List<Guid> groupIds = new ArrayList<>();
    Map<String, ExtMap> groupRecords = new HashMap<>();
    flatGroups((Collection<ExtMap>) params.getGroupIds(), groupRecords);
    for (Map.Entry<String, ExtMap> group : groupRecords.entrySet()) {
        DbGroup dbGroup = dbGroupDao.getByExternalId(authzName, group.getKey());
        if (dbGroup != null) {
            dbGroup.setName(group.getValue().get(Authz.GroupRecord.NAME));
            dbGroupDao.update(dbGroup);
            groupIds.add(dbGroup.getId());
        }
    }
    user.setGroupIds(groupIds);
    user.setAdmin(!roleDao.getAnyAdminRoleForUserAndGroups(user.getId(), StringUtils.join(user.getGroupIds(), ",")).isEmpty());
    if (dbUser == null) {
        dbUserDao.save(user);
    } else if (!dbUser.equals(user)) {
        dbUserDao.update(user);
    }
    return user;
}
#end_block

#method_before
private static void flatGroups(ExtMap entity, ExtKey key, List<String> accumulator) {
    for (ExtMap group : entity.<Collection<ExtMap>>get(key, Collections.<ExtMap>emptyList())) {
        if (!accumulator.contains(group.<String>get(Authz.GroupRecord.ID))) {
            accumulator.add(group.get(Authz.GroupRecord.ID));
            flatGroups(group, Authz.GroupRecord.GROUPS, accumulator);
        }
    }
}
#method_after
private static void flatGroups(Collection<ExtMap> groupIds, Map<String, ExtMap> accumulator) {
    for (ExtMap group : groupIds) {
        if (!accumulator.containsKey(group.<String>get(Authz.GroupRecord.ID))) {
            accumulator.put(group.get(Authz.GroupRecord.ID), group);
            flatGroups(group, Authz.GroupRecord.GROUPS, accumulator);
        }
    }
}
#end_block

#method_before
protected boolean setAndValidateCpuProfile() {
    // cpu profile isn't supported for instance types nor for blank template.
    if (isInstanceType() || isBlankTemplate()) {
        return true;
    }
    return validate(cpuProfileHelper.setAndValidateCpuProfile(getVmTemplate(), getUserId()));
}
#method_after
protected boolean setAndValidateCpuProfile() {
    // cpu profile isn't supported for instance types nor for blank template.
    if (isInstanceType() || isBlankTemplate()) {
        return true;
    }
    return validate(cpuProfileHelper.setAndValidateCpuProfile(getVmTemplate(), getUserIdIfExternal().orElse(null)));
}
#end_block

#method_before
protected boolean updateVnicForBackwardCompatibility(VmNic oldNic) {
    if (!validate(VnicProfileHelper.updateNicForBackwardCompatibility(getParameters().getInterface(), oldNic, getParameters().getNetworkName(), getParameters().isPortMirroring(), getVmTemplate(), getCurrentUser()))) {
        return false;
    }
    return true;
}
#method_after
protected boolean updateVnicForBackwardCompatibility(VmNic oldNic) {
    if (!validate(backwardCompatibilityVnicHelper.updateNicForBackwardCompatibility(getParameters().getInterface(), oldNic, getParameters().getNetworkName(), getParameters().isPortMirroring(), getVmTemplate(), getCurrentUser()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
private void updateVmAfterMigrationToDifferentCluster() {
    if (getVm().getClusterId().equals(getParameters().getTargetClusterId())) {
        return;
    }
    ChangeVMClusterParameters params = new ChangeVMClusterParameters(getParameters().getTargetClusterId(), getVmId(), getVm().getCustomCompatibilityVersion());
    setSucceeded(getBackend().runInternalAction(VdcActionType.ChangeVMCluster, params).getSucceeded());
}
#method_after
private void updateVmAfterMigrationToDifferentCluster() {
    if (getParameters().getTargetClusterId() == null || getVm().getClusterId().equals(getParameters().getTargetClusterId())) {
        return;
    }
    ChangeVMClusterParameters params = new ChangeVMClusterParameters(getParameters().getTargetClusterId(), getVmId(), getVm().getCustomCompatibilityVersion());
    setSucceeded(getBackend().runInternalAction(VdcActionType.ChangeVMCluster, params).getSucceeded());
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (CollectionUtils.isEmpty(getParameters().getDevicesToReduce())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NO_DEVICES_PROVIDED);
    }
    if (!(checkStorageDomain())) {
        return false;
    }
    if (!validateReduceDeviceSupported()) {
        return false;
    }
    if (!getStorageDomain().getStorageType().isBlockDomain()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (!validateDevices()) {
        return false;
    }
    if (!checkStorageDomainStatus(StorageDomainStatus.Maintenance)) {
        return false;
    }
    if (!initializeVds()) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (CollectionUtils.isEmpty(getParameters().getDevicesToReduce())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NO_DEVICES_PROVIDED);
    }
    if (!checkStorageDomain()) {
        return false;
    }
    if (!getStorageDomain().getStorageType().isBlockDomain()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (!validateReduceDeviceSupported()) {
        return false;
    }
    if (!validateDevices()) {
        return false;
    }
    if (!checkStorageDomainStatus(StorageDomainStatus.Maintenance)) {
        return false;
    }
    if (!initializeVds()) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getDiskImage().getDiskStorageType() == DiskStorageType.IMAGE) {
        final DiskImage newDiskImage = getDiskImage();
        newDiskImage.setDiskAlias(ImagesHandler.getDiskAliasWithDefault(newDiskImage, generateDefaultAliasForRegiteredDisk(Calendar.getInstance())));
        ArrayList<Guid> storageIds = new ArrayList<>();
        storageIds.add(getParameters().getStorageDomainId());
        newDiskImage.setStorageIds(storageIds);
        addDiskImageToDb(newDiskImage, getCompensationContext(), Boolean.TRUE);
        unregisteredDisksDao.removeUnregisteredDisk(newDiskImage.getId(), null);
        getReturnValue().setActionReturnValue(newDiskImage.getId());
        getReturnValue().setSucceeded(true);
    } else if (getDiskImage().getDiskStorageType() == DiskStorageType.CINDER) {
        VdcReturnValueBase returnValue = runInternalAction(VdcActionType.RegisterCinderDisk, new RegisterCinderDiskParameters((CinderDisk) getDiskImage(), getParameters().getStorageDomainId()));
        setReturnValue(returnValue);
    }
}
#method_after
@Override
protected void executeCommand() {
    TransactionSupport.executeInNewTransaction(() -> {
        if (getDiskImage().getDiskStorageType() == DiskStorageType.IMAGE) {
            final DiskImage newDiskImage = getDiskImage();
            newDiskImage.setDiskAlias(ImagesHandler.getDiskAliasWithDefault(newDiskImage, generateDefaultAliasForRegiteredDisk(Calendar.getInstance())));
            addRegisterInitatedAuditLog();
            ArrayList<Guid> storageIds = new ArrayList<>();
            storageIds.add(getParameters().getStorageDomainId());
            newDiskImage.setStorageIds(storageIds);
            addDiskImageToDb(newDiskImage, getCompensationContext(), Boolean.TRUE);
            unregisteredDisksDao.removeUnregisteredDisk(newDiskImage.getId(), null);
            getReturnValue().setActionReturnValue(newDiskImage.getId());
            getReturnValue().setSucceeded(true);
        } else if (getDiskImage().getDiskStorageType() == DiskStorageType.CINDER) {
            VdcReturnValueBase returnValue = runInternalAction(VdcActionType.RegisterCinderDisk, new RegisterCinderDiskParameters((CinderDisk) getDiskImage(), getParameters().getStorageDomainId()));
            setReturnValue(returnValue);
        }
        return null;
    });
    fetchQcowCompat();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VM vm = getVm();
    boolean clusterRemainedTheSame = originalClusterId.equals(newClusterId);
    if (clusterRemainedTheSame) {
        setSucceeded(true);
        return;
    }
    // update vm interfaces
    List<Network> networks = networkDao.getAllForCluster(newClusterId);
    List<VmNic> interfaces = vmNicDao.getAllForVm(getParameters().getVmId());
    for (final VmNic iface : interfaces) {
        if (iface.getVnicProfileId() != null) {
            final Network network = NetworkHelper.getNetworkByVnicProfileId(iface.getVnicProfileId());
            boolean networkFoundInCluster = networks.stream().anyMatch(n -> Objects.equals(n.getId(), network.getId()));
            // interface connection
            if (!networkFoundInCluster) {
                iface.setVnicProfileId(null);
                vmNicDao.update(iface);
            }
        }
    }
    if (vm.getDedicatedVmForVdsList().size() > 0) {
        vm.setDedicatedVmForVdsList(Collections.emptyList());
        dedicatedHostWasCleared = true;
    }
    vm.setClusterId(newClusterId);
    // Set cpu profile from the new cluster
    cpuProfileHelper.assignFirstCpuProfile(vm.getStaticData(), getUserId());
    vmStaticDao.update(vm.getStaticData());
    moveMacsToAnotherMacPoolIfNeeded();
    // change vm cluster should remove the vm from all associated affinity groups
    List<AffinityGroup> allAffinityGroupsByVmId = affinityGroupDao.getAllAffinityGroupsByVmId(vm.getId());
    if (!allAffinityGroupsByVmId.isEmpty()) {
        String groups = allAffinityGroupsByVmId.stream().map(AffinityGroup::getName).collect(Collectors.joining(" "));
        log.info("Due to cluster change, removing VM from associated affinity group(s): {}", groups);
        affinityGroupDao.removeVmFromAffinityGroups(vm.getId());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    VM vm = getVm();
    boolean clusterRemainedTheSame = originalClusterId.equals(newClusterId);
    if (clusterRemainedTheSame) {
        setSucceeded(true);
        return;
    }
    // update vm interfaces
    List<Network> networks = networkDao.getAllForCluster(newClusterId);
    List<VmNic> interfaces = vmNicDao.getAllForVm(getParameters().getVmId());
    for (final VmNic iface : interfaces) {
        if (iface.getVnicProfileId() != null) {
            final Network network = NetworkHelper.getNetworkByVnicProfileId(iface.getVnicProfileId());
            boolean networkFoundInCluster = networks.stream().anyMatch(n -> Objects.equals(n.getId(), network.getId()));
            // interface connection
            if (!networkFoundInCluster) {
                iface.setVnicProfileId(null);
                vmNicDao.update(iface);
            }
        }
    }
    if (vm.getDedicatedVmForVdsList().size() > 0) {
        vm.setDedicatedVmForVdsList(Collections.emptyList());
        dedicatedHostWasCleared = true;
    }
    vm.setClusterId(newClusterId);
    // Set cpu profile from the new cluster
    cpuProfileHelper.assignFirstCpuProfile(vm.getStaticData(), getUserIdIfExternal().orElse(null));
    vmStaticDao.update(vm.getStaticData());
    moveMacsToAnotherMacPoolIfNeeded();
    // change vm cluster should remove the vm from all associated affinity groups
    List<AffinityGroup> allAffinityGroupsByVmId = affinityGroupDao.getAllAffinityGroupsByVmId(vm.getId());
    if (!allAffinityGroupsByVmId.isEmpty()) {
        String groups = allAffinityGroupsByVmId.stream().map(AffinityGroup::getName).collect(Collectors.joining(" "));
        log.info("Due to cluster change, removing VM from associated affinity group(s): {}", groups);
        affinityGroupDao.removeVmFromAffinityGroups(vm.getId());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (!previousHostedEngineHost.isPreviousHostId(getVds().getId()) && !new FenceValidator().isStartupTimeoutPassed()) {
        log.error("Failed to run Fence script on vds '{}'.", getVdsName());
        alertIfPowerManagementOperationSkipped(RESTART, null);
        // If fencing can't be done and the host is the SPM, set storage-pool to non-operational
        if (getVds().getSpmStatus() != VdsSpmStatus.None) {
            setStoragePoolNonOperational();
        }
        return;
    }
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.info("Host '{}' ({}) not fenced since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    if (shouldFencingBeSkipped(getVds())) {
        setSucceeded(false);
        setCommandShouldBeLogged(false);
        return;
    }
    boolean shouldBeFenced = getVds().shouldVdsBeFenced();
    RestartVdsReturnValue restartVdsResult = null;
    if (shouldBeFenced) {
        getParameters().setParentCommand(VdcActionType.VdsNotRespondingTreatment);
        VdcReturnValueBase retVal;
        retVal = runInternalAction(VdcActionType.SshSoftFencing, getParameters(), cloneContext().withoutExecutionContext());
        if (retVal.getSucceeded()) {
            // SSH Soft Fencing was successful and host is Up, stop non responding treatment
            getReturnValue().setSucceeded(true);
            return;
        }
        // proceed with non responding treatment only if PM action are allowed and PM enabled for host
        if (!monitoringStrategyFactory.getMonitoringStrategyForVds(getVds()).isPowerManagementSupported() || !getVds().isPmEnabled()) {
            setSucceeded(false);
            setCommandShouldBeLogged(false);
            return;
        }
        retVal = runInternalAction(VdcActionType.VdsKdumpDetection, getParameters(), cloneContext().withoutExecutionContext());
        if (retVal.getSucceeded()) {
            // kdump on host detected and finished successfully, stop hard fencing execution
            getReturnValue().setSucceeded(true);
            return;
        }
        // load cluster fencing policy
        FencingPolicy fencingPolicy = clusterDao.get(getVds().getClusterId()).getFencingPolicy();
        getParameters().setFencingPolicy(fencingPolicy);
        waitUntilSkipFencingIfSDActiveAllowed(fencingPolicy.isSkipFencingIfSDActive());
        restartVdsResult = (RestartVdsReturnValue) runInternalAction(VdcActionType.RestartVds, getParameters(), cloneContext().withoutExecutionContext());
    } else {
        setCommandShouldBeLogged(false);
        log.info("Host '{}' ({}) not fenced since it's status is ok, or it doesn't exist anymore.", getVdsName(), getVdsId());
    }
    if (restartVdsResult != null && restartVdsResult.isSkippedDueToFencingPolicy()) {
        // fencing was skipped, fire an alert and suppress standard command logging
        AuditLogableBase alb = Injector.injectMembers(new AuditLogableBase(getVds().getId()));
        alb.setRepeatable(true);
        auditLogDirector.log(alb, AuditLogType.VDS_ALERT_NOT_RESTARTED_DUE_TO_POLICY);
        setSucceeded(false);
        setCommandShouldBeLogged(false);
    } else {
        getReturnValue().setSucceeded(shouldBeFenced);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (!previousHostedEngineHost.isPreviousHostId(getVds().getId()) && !new FenceValidator().isStartupTimeoutPassed()) {
        log.error("Failed to run Fence script on vds '{}'.", getVdsName());
        alertIfPowerManagementOperationSkipped(RESTART, null);
        // If fencing can't be done and the host is the SPM, set storage-pool to non-operational
        if (getVds().getSpmStatus() != VdsSpmStatus.None) {
            setStoragePoolNonOperational();
        }
        return;
    }
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.info("Host '{}' ({}) not fenced since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    if (shouldFencingBeSkipped(getVds())) {
        setSucceeded(false);
        setCommandShouldBeLogged(false);
        return;
    }
    boolean shouldBeFenced = getVds().shouldVdsBeFenced();
    VdcReturnValueBase restartVdsResult = null;
    if (shouldBeFenced) {
        getParameters().setParentCommand(VdcActionType.VdsNotRespondingTreatment);
        VdcReturnValueBase retVal;
        retVal = runInternalAction(VdcActionType.SshSoftFencing, getParameters(), cloneContext().withoutExecutionContext());
        if (retVal.getSucceeded()) {
            // SSH Soft Fencing was successful and host is Up, stop non responding treatment
            getReturnValue().setSucceeded(true);
            return;
        }
        // proceed with non responding treatment only if PM action are allowed and PM enabled for host
        if (!monitoringStrategyFactory.getMonitoringStrategyForVds(getVds()).isPowerManagementSupported() || !getVds().isPmEnabled()) {
            setSucceeded(false);
            setCommandShouldBeLogged(false);
            return;
        }
        retVal = runInternalAction(VdcActionType.VdsKdumpDetection, getParameters(), cloneContext().withoutExecutionContext());
        if (retVal.getSucceeded()) {
            // kdump on host detected and finished successfully, stop hard fencing execution
            getReturnValue().setSucceeded(true);
            return;
        }
        // load cluster fencing policy
        FencingPolicy fencingPolicy = clusterDao.get(getVds().getClusterId()).getFencingPolicy();
        getParameters().setFencingPolicy(fencingPolicy);
        waitUntilSkipFencingIfSDActiveAllowed(fencingPolicy.isSkipFencingIfSDActive());
        restartVdsResult = runInternalAction(VdcActionType.RestartVds, getParameters(), cloneContext().withoutExecutionContext());
    } else {
        setCommandShouldBeLogged(false);
        log.info("Host '{}' ({}) not fenced since it's status is ok, or it doesn't exist anymore.", getVdsName(), getVdsId());
    }
    if (restartVdsResult != null && restartVdsResult.<RestartVdsResult>getActionReturnValue().isSkippedDueToFencingPolicy()) {
        // fencing was skipped, fire an alert and suppress standard command logging
        AuditLogableBase alb = Injector.injectMembers(new AuditLogableBase(getVds().getId()));
        alb.setRepeatable(true);
        auditLogDirector.log(alb, AuditLogType.VDS_ALERT_NOT_RESTARTED_DUE_TO_POLICY);
        setSucceeded(false);
        setCommandShouldBeLogged(false);
    } else {
        getReturnValue().setSucceeded(shouldBeFenced);
    }
}
#end_block

#method_before
protected void setVmName(final String value) {
    vmName = value;
}
#method_after
public void setVmName(final String value) {
    vmName = value;
}
#end_block

#method_before
protected void setVdsName(final String value) {
    vdsName = value;
}
#method_after
public void setVdsName(final String value) {
    vdsName = value;
}
#end_block

#method_before
public String getStorageDomainName() {
    if (getStorageDomain() != null) {
        return getStorageDomain().getStorageName();
    }
    return "";
}
#method_after
public String getStorageDomainName() {
    if (storageDomainName == null && getStorageDomain() != null) {
        storageDomainName = getStorageDomain().getStorageName();
    }
    return StringUtils.defaultString(storageDomainName);
}
#end_block

#method_before
public String getStoragePoolName() {
    if (getStoragePool() != null) {
        return getStoragePool().getName();
    }
    return "";
}
#method_after
public String getStoragePoolName() {
    if (storagePoolName == null && getStoragePool() != null) {
        storagePoolName = getStoragePool().getName();
    }
    return StringUtils.defaultString(storagePoolName);
}
#end_block

#method_before
public String getClusterName() {
    if (getCluster() != null) {
        return getCluster().getName();
    }
    return "";
}
#method_after
public String getClusterName() {
    if (clusterName == null) {
        if (getCluster() != null) {
            clusterName = getCluster().getName();
        } else {
            clusterName = "";
        }
    }
    return clusterName;
}
#end_block

#method_before
public AuditLogableBase addCustomValue(final String name, final String value) {
    allocateCustomValues();
    customValues.put(name.toLowerCase(), value);
    return this;
}
#method_after
public AuditLogable addCustomValue(final String name, final String value) {
    allocateCustomValues();
    customValues.put(name.toLowerCase(), value);
    return this;
}
#end_block

#method_before
protected void endActionOnAllImageGroups() {
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        getBackend().endAction(VdcActionType.CopyImageGroup, p, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
        initQcowVersionForDisks(((MoveOrCopyImageGroupParameters) p).getDestImageGroupId());
    }
}
#method_after
protected void endActionOnAllImageGroups() {
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        getBackend().endAction(VdcActionType.CopyImageGroup, p, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
    }
}
#end_block

#method_before
protected void registerAllOvfDisks(List<DiskImage> ovfStoreDiskImages, Guid storageDomainId) {
    for (DiskImage ovfStoreDiskImage : ovfStoreDiskImages) {
        ovfStoreDiskImage.setDiskAlias(OvfInfoFileConstants.OvfStoreDescriptionLabel);
        ovfStoreDiskImage.setDiskDescription(OvfInfoFileConstants.OvfStoreDescriptionLabel);
        ovfStoreDiskImage.setShareable(true);
        RegisterDiskParameters registerDiskParams = new RegisterDiskParameters(ovfStoreDiskImage, storageDomainId);
        boolean registerDiskResult = runInternalAction(VdcActionType.RegisterDisk, registerDiskParams, cloneContext()).getSucceeded();
        log.info("Register new floating OVF_STORE disk with disk id '{}' for storage domain '{}' has {}", ovfStoreDiskImage.getId(), storageDomainId, registerDiskResult ? "succeeded" : "failed");
        if (registerDiskResult) {
            addOvfStoreDiskToDomain(ovfStoreDiskImage);
        }
    }
}
#method_after
protected void registerAllOvfDisks(List<DiskImage> ovfStoreDiskImages, Guid storageDomainId) {
    for (DiskImage ovfStoreDiskImage : ovfStoreDiskImages) {
        ovfStoreDiskImage.setDiskAlias(OvfInfoFileConstants.OvfStoreDescriptionLabel);
        ovfStoreDiskImage.setDiskDescription(OvfInfoFileConstants.OvfStoreDescriptionLabel);
        ovfStoreDiskImage.setShareable(true);
        ovfStoreDiskImage.setContentType(DiskContentType.OVF_STORE);
        RegisterDiskParameters registerDiskParams = new RegisterDiskParameters(ovfStoreDiskImage, storageDomainId);
        boolean registerDiskResult = runInternalAction(VdcActionType.RegisterDisk, registerDiskParams, cloneContext()).getSucceeded();
        log.info("Register new floating OVF_STORE disk with disk id '{}' for storage domain '{}' has {}", ovfStoreDiskImage.getId(), storageDomainId, registerDiskResult ? "succeeded" : "failed");
        if (registerDiskResult) {
            addOvfStoreDiskToDomain(ovfStoreDiskImage);
        }
    }
}
#end_block

#method_before
private void alert(AuditLogType logType, String operation) {
    AuditLogableBase alert = Injector.injectMembers(new AuditLogableBase());
    alert.setVdsId(getVds().getId());
    String op = (operation == null) ? getActionType().name() : operation;
    alert.addCustomValue("Operation", op);
    AlertDirector.alert(alert, logType, auditLogDirector);
}
#method_after
private void alert(AuditLogType logType, String operation) {
    AuditLogableBase alert = createAlert(operation);
    AlertDirector.alert(alert, logType, auditLogDirector);
}
#end_block

#method_before
private void alert(AuditLogType logType, String operation, Throwable throwable) {
    AuditLogableBase alert = Injector.injectMembers(new AuditLogableBase());
    alert.setVdsId(getVds().getId());
    String op = (operation == null) ? getActionType().name() : operation;
    alert.addCustomValue("Operation", op);
    alert.updateCallStackFromThrowable(throwable);
    AlertDirector.alert(alert, logType, auditLogDirector);
}
#method_after
private void alert(AuditLogType logType, String operation, Throwable throwable) {
    AuditLogableBase alert = createAlert(operation);
    alert.updateCallStackFromThrowable(throwable);
    AlertDirector.alert(alert, logType, auditLogDirector);
}
#end_block

#method_before
protected void logSettingVmToDown(Guid vdsId, Guid vmId) {
    AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase(vdsId, vmId));
    auditLogDirector.log(logable, AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE);
}
#method_after
protected void logSettingVmToDown(String vmName) {
    AuditLogableBase logable = new AuditLogableBase();
    logable.setVdsName(getVds().getName());
    logable.setVmName(vmName);
    auditLogDirector.log(logable, AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE);
}
#end_block

#method_before
protected boolean setAndValidateCpuProfile() {
    // cpu profile isn't supported for instance types.
    if (getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE) {
        return true;
    }
    return validate(cpuProfileHelper.setAndValidateCpuProfile(getParameters().getMasterVm(), getUserId()));
}
#method_after
protected boolean setAndValidateCpuProfile() {
    // cpu profile isn't supported for instance types.
    if (getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE) {
        return true;
    }
    return validate(cpuProfileHelper.setAndValidateCpuProfile(getParameters().getMasterVm(), getUserIdIfExternal().orElse(null)));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setImageGroupId(getParameters().getDiskInfo().getId());
    if (Guid.isNullOrEmpty(getDestinationImageId())) {
        setDestinationImageId(Guid.newGuid());
    }
    newDiskImage = new DiskImage();
    newDiskImage.setImageId(getDestinationImageId());
    newDiskImage.setPropagateErrors(getParameters().getDiskInfo().getPropagateErrors());
    newDiskImage.setWipeAfterDelete(getParameters().getDiskInfo().isWipeAfterDelete());
    newDiskImage.setDiskAlias(getParameters().getDiskInfo().getDiskAlias());
    newDiskImage.setDiskDescription(getParameters().getDiskInfo().getDiskDescription());
    newDiskImage.setShareable(getParameters().getDiskInfo().isShareable());
    newDiskImage.setId(getImageGroupId());
    newDiskImage.setStoragePoolId(getParameters().getStoragePoolId());
    newDiskImage.setStorageIds(new ArrayList<>(Arrays.asList(getParameters().getStorageDomainId())));
    newDiskImage.setSize(getParameters().getDiskInfo().getSize());
    newDiskImage.setVolumeType(getParameters().getDiskInfo().getVolumeType());
    newDiskImage.setVolumeFormat(getParameters().getDiskInfo().getVolumeFormat());
    newDiskImage.setDescription("");
    newDiskImage.setCreationDate(new Date());
    newDiskImage.setLastModified(new Date());
    newDiskImage.setActive(true);
    newDiskImage.setImageStatus(ImageStatus.LOCKED);
    newDiskImage.setVmSnapshotId(getParameters().getVmSnapshotId());
    newDiskImage.setQuotaId(getParameters().getQuotaId());
    newDiskImage.setDiskProfileId(getParameters().getDiskProfileId());
    TransactionSupport.executeInNewTransaction(() -> {
        if (!getParameters().isShouldRemainIllegalOnFailedExecution()) {
            addDiskImageToDb(newDiskImage, getCompensationContext(), Boolean.TRUE);
        } else {
            addDiskImageToDb(newDiskImage, null, Boolean.TRUE);
            getCompensationContext().snapshotEntityStatus(newDiskImage.getImage(), ImageStatus.ILLEGAL);
        }
        return null;
    });
    freeLock();
    if (getParameters().isShouldRemainIllegalOnFailedExecution()) {
        getReturnValue().setActionReturnValue(newDiskImage);
    }
    processImageInIrs();
    getReturnValue().setActionReturnValue(newDiskImage);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    setImageGroupId(getParameters().getDiskInfo().getId());
    if (Guid.isNullOrEmpty(getDestinationImageId())) {
        setDestinationImageId(Guid.newGuid());
    }
    newDiskImage = new DiskImage();
    newDiskImage.setImageId(getDestinationImageId());
    newDiskImage.setPropagateErrors(getParameters().getDiskInfo().getPropagateErrors());
    newDiskImage.setWipeAfterDelete(getParameters().getDiskInfo().isWipeAfterDelete());
    newDiskImage.setDiskAlias(getParameters().getDiskInfo().getDiskAlias());
    newDiskImage.setDiskDescription(getParameters().getDiskInfo().getDiskDescription());
    newDiskImage.setShareable(getParameters().getDiskInfo().isShareable());
    newDiskImage.setId(getImageGroupId());
    newDiskImage.setStoragePoolId(getParameters().getStoragePoolId());
    newDiskImage.setStorageIds(new ArrayList<>(Arrays.asList(getParameters().getStorageDomainId())));
    newDiskImage.setSize(getParameters().getDiskInfo().getSize());
    newDiskImage.setVolumeType(getParameters().getDiskInfo().getVolumeType());
    newDiskImage.setVolumeFormat(getParameters().getDiskInfo().getVolumeFormat());
    newDiskImage.setDescription("");
    newDiskImage.setCreationDate(new Date());
    newDiskImage.setLastModified(new Date());
    newDiskImage.setActive(true);
    newDiskImage.setImageStatus(ImageStatus.LOCKED);
    newDiskImage.setVmSnapshotId(getParameters().getVmSnapshotId());
    newDiskImage.setQuotaId(getParameters().getQuotaId());
    newDiskImage.setDiskProfileId(getParameters().getDiskProfileId());
    newDiskImage.setContentType(getParameters().getDiskInfo().getContentType());
    TransactionSupport.executeInNewTransaction(() -> {
        if (!getParameters().isShouldRemainIllegalOnFailedExecution()) {
            addDiskImageToDb(newDiskImage, getCompensationContext(), Boolean.TRUE);
        } else {
            addDiskImageToDb(newDiskImage, null, Boolean.TRUE);
            getCompensationContext().snapshotEntityStatus(newDiskImage.getImage(), ImageStatus.ILLEGAL);
        }
        return null;
    });
    freeLock();
    if (getParameters().isShouldRemainIllegalOnFailedExecution()) {
        getReturnValue().setActionReturnValue(newDiskImage);
    }
    processImageInIrs();
    getReturnValue().setActionReturnValue(newDiskImage);
    setSucceeded(true);
}
#end_block

#method_before
private void attachNetwork(Guid clusterId, NetworkCluster networkClusterFromUserRequest, Network network) {
    networkClusterDao.save(new NetworkCluster(clusterId, network.getId(), NetworkStatus.OPERATIONAL, false, networkClusterFromUserRequest.isRequired(), false, false, false, false));
    List<VDS> hosts = vdsDao.getAllForCluster(clusterId);
    List<Network> networksOfCluster = networkDao.getAllForCluster(clusterId);
    for (VDS host : hosts) {
        HostNetworkAttachmentsPersister persister = new HostNetworkAttachmentsPersister(this.networkAttachmentDao, host.getId(), interfaceDao.getAllInterfacesForVds(host.getId()), Collections.emptyList(), networksOfCluster);
        persister.persistNetworkAttachments();
    }
    if (network.getCluster().isDisplay()) {
        final DisplayNetworkClusterHelper displayNetworkClusterHelper = new DisplayNetworkClusterHelper(networkClusterDao, vmDao, networkClusterFromUserRequest, network.getName(), auditLogDirector);
        if (displayNetworkClusterHelper.isDisplayToBeUpdated()) {
            displayNetworkClusterHelper.warnOnActiveVm();
        }
        networkClusterDao.setNetworkExclusivelyAsDisplay(clusterId, network.getId());
    }
    if (network.getCluster().isMigration()) {
        networkClusterDao.setNetworkExclusivelyAsMigration(clusterId, network.getId());
    }
    if (network.getCluster().isGluster()) {
        networkClusterDao.setNetworkExclusivelyAsGluster(clusterId, network.getId());
    }
    if (network.getCluster().isDefaultRoute()) {
        networkClusterDao.setNetworkExclusivelyAsDefaultRoute(clusterId, network.getId());
    }
    networkClusterHelper.setStatus(clusterId, network);
}
#method_after
private void attachNetwork(Guid clusterId, NetworkCluster networkClusterFromUserRequest, Network network) {
    networkClusterDao.save(new NetworkCluster(clusterId, network.getId(), NetworkStatus.OPERATIONAL, false, networkClusterFromUserRequest.isRequired(), false, false, false, false));
    List<VDS> hosts = vdsDao.getAllForCluster(clusterId);
    List<Network> networksOfCluster = networkDao.getAllForCluster(clusterId);
    for (VDS host : hosts) {
        HostNetworkAttachmentsPersister persister = new HostNetworkAttachmentsPersister(this.networkAttachmentDao, host.getId(), interfaceDao.getAllInterfacesForVds(host.getId()), Collections.emptyList(), networksOfCluster);
        persister.persistNetworkAttachments();
    }
    if (network.getCluster().isDisplay()) {
        final DisplayNetworkClusterHelper displayNetworkClusterHelper = new DisplayNetworkClusterHelper(networkClusterDao, vmDao, clusterDao, networkClusterFromUserRequest, network.getName(), auditLogDirector);
        if (displayNetworkClusterHelper.isDisplayToBeUpdated()) {
            displayNetworkClusterHelper.warnOnActiveVm();
        }
        networkClusterDao.setNetworkExclusivelyAsDisplay(clusterId, network.getId());
    }
    if (network.getCluster().isMigration()) {
        networkClusterDao.setNetworkExclusivelyAsMigration(clusterId, network.getId());
    }
    if (network.getCluster().isGluster()) {
        networkClusterDao.setNetworkExclusivelyAsGluster(clusterId, network.getId());
    }
    if (network.getCluster().isDefaultRoute()) {
        networkClusterDao.setNetworkExclusivelyAsDefaultRoute(clusterId, network.getId());
    }
    networkClusterHelper.setStatus(clusterId, network);
}
#end_block

#method_before
protected boolean setAndValidateCpuProfile() {
    return validate(cpuProfileHelper.setAndValidateCpuProfile(getParameters().getVmStaticData(), getUserId()));
}
#method_after
protected boolean setAndValidateCpuProfile() {
    return validate(cpuProfileHelper.setAndValidateCpuProfile(getParameters().getVmStaticData(), getUserIdIfExternal().orElse(null)));
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean result = true;
    Map<Guid, Cluster> clusters = new HashMap<>();
    Set<Guid> clustersAsSet = new HashSet<>();
    Set<Guid> vdsWithRunningVMs = new HashSet<>();
    List<String> hostNotRespondingList = new ArrayList<>();
    List<String> hostsWithNonMigratableVms = new ArrayList<>();
    List<String> hostsWithVmsWithPluggedDiskSnapshots = new ArrayList<>();
    List<String> nonMigratableVms = new ArrayList<>();
    for (Guid vdsId : getParameters().getVdsIdList()) {
        VDS vds = vdsDao.get(vdsId);
        if (vds == null) {
            log.error("ResourceManager::vdsMaintenance could not find VDS '{}'", vdsId);
            result = failValidation(EngineMessage.VDS_INVALID_SERVER_ID);
            continue;
        }
        // TODO make a more efficient call but normally the command just loads one cluster anyway
        if (!clusters.containsKey(vds.getClusterId())) {
            final Cluster cluster = clusterDao.get(vds.getClusterId());
            clusters.put(cluster.getId(), cluster);
        }
        if (!vdssToMaintenance.containsKey(vdsId)) {
            vdssToMaintenance.put(vdsId, vds);
            if (vds.getSpmStatus() == VdsSpmStatus.SPM) {
                addSharedLockEntry(vds);
            }
        }
        if (getParameters().isStopGlusterService() && !vds.getClusterSupportsGlusterService()) {
            result = failValidation(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_SERVICE_MAINTENANCE_NOT_SUPPORTED_FOR_CLUSTER);
            break;
        }
    }
    result = result && acquireLockInternal();
    if (result) {
        // tasks running
        for (Guid vdsId : getParameters().getVdsIdList()) {
            VDS vds = vdssToMaintenance.get(vdsId);
            if (vds != null) {
                if ((vds.getStatus() != VDSStatus.Maintenance) && (vds.getStatus() != VDSStatus.NonResponsive) && (vds.getStatus() != VDSStatus.Up) && (vds.getStatus() != VDSStatus.Error) && (vds.getStatus() != VDSStatus.PreparingForMaintenance) && (vds.getStatus() != VDSStatus.Down) && (vds.getStatus() != VDSStatus.NonOperational && (vds.getStatus() != VDSStatus.InstallFailed))) {
                    result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL);
                } else {
                    List<VM> vms = vmDao.getAllRunningForVds(vdsId);
                    if (!vms.isEmpty()) {
                        vdsWithRunningVMs.add(vdsId);
                    }
                    clustersAsSet.add(vds.getClusterId());
                    List<String> nonMigratableVmDescriptionsToFrontEnd = new ArrayList<>();
                    for (VM vm : vms) {
                        // And they need safe place for migration
                        if (vm.isHostedEngine()) {
                            List<VDS> clusterVdses = vdsDao.getAllForClusterWithStatus(vds.getClusterId(), VDSStatus.Up);
                            if (!HostedEngineHelper.haveHostsAvailableforHE(clusterVdses, getParameters().getVdsIdList())) {
                                failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_NO_ALTERNATE_HOST_FOR_HOSTED_ENGINE);
                                return false;
                            }
                        }
                        // other non-migratable VMs are reported
                        if (vm.getMigrationSupport() != MigrationSupport.MIGRATABLE && !vm.isHostedEngine()) {
                            nonMigratableVmDescriptionsToFrontEnd.add(vm.getName());
                        }
                    }
                    if (nonMigratableVmDescriptionsToFrontEnd.size() > 0) {
                        hostsWithNonMigratableVms.add(vds.getName());
                        nonMigratableVms.addAll(nonMigratableVmDescriptionsToFrontEnd);
                        // The non migratable VM names will be comma separated
                        log.error("VDS '{}' contains non migratable VMs", vdsId);
                        result = false;
                    } else if (!validate(new MultipleVmsValidator(vms).vmNotHavingPluggedDiskSnapshots(EngineMessage.VDS_CANNOT_MAINTENANCE_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
                        hostsWithVmsWithPluggedDiskSnapshots.add(vds.getName());
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.Maintenance) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_IN_MAINTENANCE);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.Contending) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_SPM_CONTENDING);
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getVmCount() > 0) {
                        result = false;
                        hostNotRespondingList.add(vds.getName());
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getSpmStatus() != VdsSpmStatus.None) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_RESPONDING_AND_IS_SPM);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.SPM && vds.getStatus() == VDSStatus.Up && asyncTaskDao.getAsyncTaskIdsByStoragePoolId(vds.getStoragePoolId()).size() > 0) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_SPM_WITH_RUNNING_TASKS);
                    } else if (!clusters.get(vds.getClusterId()).isInUpgradeMode()) {
                        result = handlePositiveEnforcingAffinityGroup(vdsId, vms);
                    }
                }
            }
        }
        // If one of the host is non responsive with running VM's, add a Validate message.
        handleNonResponsiveHosts(hostNotRespondingList);
        // If one of the vms is non migratable, add a Validate message.
        handleNonMigratableVms(hostsWithNonMigratableVms, nonMigratableVms);
        handleHostsWithVmsWithPluggedDiskSnapshots(hostsWithVmsWithPluggedDiskSnapshots);
        if (result) {
            // Remove all redundant clusters in clusters list, by adding it to a
            // set.
            // For each cluster check for each host that belongs to it, if its a
            // part of the parameters and
            // if there are running hosts for it - if it is up and is not in the
            // parameters -migration will be possible
            // to be performed, and there is no point to continue the check for
            // the given cluster - otherwise,
            // if the host is up and in the parameters - it may be that the
            // cluster is problematic (no hosts in up
            // state that we will be able to migrate VMs to)
            // In the end - if the clusters list is not empty - this is an
            // error, use the "problematic clusters list" to format an error to
            // the client
            List<String> problematicClusters = new ArrayList<>();
            List<String> allHostsWithRunningVms = new ArrayList<>();
            for (Guid clusterID : clustersAsSet) {
                List<VDS> vdsList = vdsDao.getAllForCluster(clusterID);
                boolean vdsForMigrationExists = checkIfThereIsVDSToHoldMigratedVMs(getParameters().getVdsIdList(), vdsList);
                if (!vdsForMigrationExists) {
                    List<String> candidateHostsWithRunningVms = new ArrayList<>();
                    for (VDS vdsInCluster : vdsList) {
                        if (vdsWithRunningVMs.contains(vdsInCluster.getId())) {
                            candidateHostsWithRunningVms.add(vdsInCluster.getName());
                        }
                    }
                    // cluster
                    if (!candidateHostsWithRunningVms.isEmpty()) {
                        addClusterDetails(clusterID, problematicClusters);
                        allHostsWithRunningVms.addAll(candidateHostsWithRunningVms);
                    }
                }
            }
            // If there are problematic clusters
            result = problematicClusters.isEmpty();
            if (!result) {
                addValidationMessage(EngineMessage.CANNOT_MAINTENANCE_VDS_RUN_VMS_NO_OTHER_RUNNING_VDS);
                String commaDelimitedClusters = StringUtils.join(problematicClusters, ",");
                getReturnValue().getValidationMessages().add(String.format("$ClustersList %1$s", commaDelimitedClusters));
                getReturnValue().getValidationMessages().add(String.format("$HostsList %1$s", StringUtils.join(allHostsWithRunningVms, ",")));
            }
        }
        if (result && !getParameters().isForceMaintenance()) {
            result = validateGlusterParams(clustersAsSet);
        }
    }
    return result;
}
#method_after
@Override
protected boolean validate() {
    boolean result = true;
    Map<Guid, Cluster> clusters = new HashMap<>();
    Set<Guid> clustersAsSet = new HashSet<>();
    Set<Guid> vdsWithRunningVMs = new HashSet<>();
    List<String> hostNotRespondingList = new ArrayList<>();
    List<String> hostsWithNonMigratableVms = new ArrayList<>();
    List<String> hostsWithVmsWithPluggedDiskSnapshots = new ArrayList<>();
    List<String> nonMigratableVms = new ArrayList<>();
    for (Guid vdsId : getParameters().getVdsIdList()) {
        VDS vds = vdsDao.get(vdsId);
        if (vds == null) {
            log.error("ResourceManager::vdsMaintenance could not find VDS '{}'", vdsId);
            result = failValidation(EngineMessage.VDS_INVALID_SERVER_ID);
            continue;
        }
        // TODO make a more efficient call but normally the command just loads one cluster anyway
        if (!clusters.containsKey(vds.getClusterId())) {
            final Cluster cluster = clusterDao.get(vds.getClusterId());
            clusters.put(cluster.getId(), cluster);
        }
        if (!vdssToMaintenance.containsKey(vdsId)) {
            vdssToMaintenance.put(vdsId, vds);
            if (vds.getSpmStatus() == VdsSpmStatus.SPM) {
                addSharedLockEntry(vds);
            }
        }
        if (getParameters().isStopGlusterService() && !vds.getClusterSupportsGlusterService()) {
            result = failValidation(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_SERVICE_MAINTENANCE_NOT_SUPPORTED_FOR_CLUSTER);
            break;
        }
    }
    result = result && acquireLockInternal();
    if (result) {
        // tasks running
        for (Guid vdsId : getParameters().getVdsIdList()) {
            VDS vds = vdssToMaintenance.get(vdsId);
            if (vds != null) {
                if ((vds.getStatus() != VDSStatus.Maintenance) && (vds.getStatus() != VDSStatus.NonResponsive) && (vds.getStatus() != VDSStatus.Up) && (vds.getStatus() != VDSStatus.Error) && (vds.getStatus() != VDSStatus.PreparingForMaintenance) && (vds.getStatus() != VDSStatus.Down) && (vds.getStatus() != VDSStatus.NonOperational && (vds.getStatus() != VDSStatus.InstallFailed))) {
                    result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL);
                } else {
                    List<VM> vms = vmDao.getAllRunningForVds(vdsId);
                    if (!vms.isEmpty()) {
                        vdsWithRunningVMs.add(vdsId);
                    }
                    clustersAsSet.add(vds.getClusterId());
                    List<String> nonMigratableVmDescriptionsToFrontEnd = new ArrayList<>();
                    for (VM vm : vms) {
                        // And they need safe place for migration
                        if (vm.isHostedEngine()) {
                            List<VDS> clusterVdses = vdsDao.getAllForClusterWithStatus(vds.getClusterId(), VDSStatus.Up);
                            if (!HostedEngineHelper.haveHostsAvailableforHE(clusterVdses, getParameters().getVdsIdList())) {
                                failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_NO_ALTERNATE_HOST_FOR_HOSTED_ENGINE);
                                return false;
                            }
                        }
                        // other non-migratable VMs are reported
                        if (vm.getMigrationSupport() != MigrationSupport.MIGRATABLE && !vm.isHostedEngine()) {
                            nonMigratableVmDescriptionsToFrontEnd.add(vm.getName());
                        }
                    }
                    if (nonMigratableVmDescriptionsToFrontEnd.size() > 0) {
                        hostsWithNonMigratableVms.add(vds.getName());
                        nonMigratableVms.addAll(nonMigratableVmDescriptionsToFrontEnd);
                        // The non migratable VM names will be comma separated
                        log.error("VDS '{}' contains non migratable VMs", vdsId);
                        result = false;
                    } else if (!validate(new MultipleVmsValidator(vms).vmNotHavingPluggedDiskSnapshots(EngineMessage.VDS_CANNOT_MAINTENANCE_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
                        hostsWithVmsWithPluggedDiskSnapshots.add(vds.getName());
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.Maintenance) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_IN_MAINTENANCE);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.Contending) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_SPM_CONTENDING);
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getVmCount() > 0) {
                        result = false;
                        hostNotRespondingList.add(vds.getName());
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getSpmStatus() != VdsSpmStatus.None) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_RESPONDING_AND_IS_SPM);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.SPM && vds.getStatus() == VDSStatus.Up && asyncTaskDao.getAsyncTaskIdsByStoragePoolId(vds.getStoragePoolId()).size() > 0) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_SPM_WITH_RUNNING_TASKS);
                    } else if (!validateNoRunningJobs(vds)) {
                        result = false;
                    } else if (!clusters.get(vds.getClusterId()).isInUpgradeMode()) {
                        result = handlePositiveEnforcingAffinityGroup(vdsId, vms);
                    }
                }
            }
        }
        // If one of the host is non responsive with running VM's, add a Validate message.
        handleNonResponsiveHosts(hostNotRespondingList);
        // If one of the vms is non migratable, add a Validate message.
        handleNonMigratableVms(hostsWithNonMigratableVms, nonMigratableVms);
        handleHostsWithVmsWithPluggedDiskSnapshots(hostsWithVmsWithPluggedDiskSnapshots);
        if (result) {
            // Remove all redundant clusters in clusters list, by adding it to a
            // set.
            // For each cluster check for each host that belongs to it, if its a
            // part of the parameters and
            // if there are running hosts for it - if it is up and is not in the
            // parameters -migration will be possible
            // to be performed, and there is no point to continue the check for
            // the given cluster - otherwise,
            // if the host is up and in the parameters - it may be that the
            // cluster is problematic (no hosts in up
            // state that we will be able to migrate VMs to)
            // In the end - if the clusters list is not empty - this is an
            // error, use the "problematic clusters list" to format an error to
            // the client
            List<String> problematicClusters = new ArrayList<>();
            List<String> allHostsWithRunningVms = new ArrayList<>();
            for (Guid clusterID : clustersAsSet) {
                List<VDS> vdsList = vdsDao.getAllForCluster(clusterID);
                boolean vdsForMigrationExists = checkIfThereIsVDSToHoldMigratedVMs(getParameters().getVdsIdList(), vdsList);
                if (!vdsForMigrationExists) {
                    List<String> candidateHostsWithRunningVms = new ArrayList<>();
                    for (VDS vdsInCluster : vdsList) {
                        if (vdsWithRunningVMs.contains(vdsInCluster.getId())) {
                            candidateHostsWithRunningVms.add(vdsInCluster.getName());
                        }
                    }
                    // cluster
                    if (!candidateHostsWithRunningVms.isEmpty()) {
                        addClusterDetails(clusterID, problematicClusters);
                        allHostsWithRunningVms.addAll(candidateHostsWithRunningVms);
                    }
                }
            }
            // If there are problematic clusters
            result = problematicClusters.isEmpty();
            if (!result) {
                addValidationMessage(EngineMessage.CANNOT_MAINTENANCE_VDS_RUN_VMS_NO_OTHER_RUNNING_VDS);
                String commaDelimitedClusters = StringUtils.join(problematicClusters, ",");
                getReturnValue().getValidationMessages().add(String.format("$ClustersList %1$s", commaDelimitedClusters));
                getReturnValue().getValidationMessages().add(String.format("$HostsList %1$s", StringUtils.join(allHostsWithRunningVms, ",")));
            }
        }
        if (result && !getParameters().isForceMaintenance()) {
            result = validateGlusterParams(clustersAsSet);
        }
    }
    return result;
}
#end_block

#method_before
protected boolean checkStorageDomainStatus(final StorageDomainStatus... statuses) {
    boolean valid = false;
    StorageDomainStatus status = getStorageDomainStatus();
    if (status != null) {
        valid = Arrays.asList(statuses).contains(status);
    }
    if (!valid) {
        if (status != null && status.isStorageDomainInProcess()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED);
        }
        addStorageDomainStatusIllegalMessage();
    }
    return valid;
}
#method_after
protected boolean checkStorageDomainStatus(final StorageDomainStatus... statuses) {
    return checkStorageDomainStatus(Arrays.stream(statuses).collect(toSet()));
}
#end_block

#method_before
protected boolean checkStorageDomainStatus(final StorageDomainStatus... statuses) {
    boolean valid = false;
    StorageDomainStatus status = getStorageDomainStatus();
    if (status != null) {
        valid = Arrays.asList(statuses).contains(status);
    }
    if (!valid) {
        if (status != null && status.isStorageDomainInProcess()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED);
        }
        addStorageDomainStatusIllegalMessage();
    }
    return valid;
}
#method_after
protected boolean checkStorageDomainStatus(Set<StorageDomainStatus> statuses) {
    boolean valid = false;
    StorageDomainStatus status = getStorageDomainStatus();
    if (status != null) {
        valid = statuses.contains(status);
    }
    if (!valid) {
        if (status != null && status.isStorageDomainInProcess()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED);
        }
        addStorageDomainStatusIllegalMessage();
    }
    return valid;
}
#end_block

#method_before
protected boolean isLunsAlreadyInUse(List<String> lunIds) {
    // Get LUNs from DB
    List<LUNs> lunsFromDb = lunDao.getAll();
    Set<LUNs> lunsUsedBySDs = new HashSet<>();
    Set<LUNs> lunsUsedByDisks = new HashSet<>();
    for (LUNs lun : lunsFromDb) {
        if (lunIds.contains(lun.getLUNId())) {
            if (lun.getStorageDomainId() != null) {
                // LUN is already part of a storage domain
                lunsUsedBySDs.add(lun);
            }
            if (lun.getDiskId() != null) {
                // LUN is already used by a disk
                lunsUsedByDisks.add(lun);
            }
        }
    }
    if (!lunsUsedBySDs.isEmpty()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_LUNS_ALREADY_PART_OF_STORAGE_DOMAINS);
        Set<String> formattedIds = lunsUsedBySDs.stream().map(lun -> getFormattedLunId(lun, lun.getStorageDomainName())).collect(Collectors.toSet());
        addValidationMessageVariable("lunIds", StringUtils.join(formattedIds, ", "));
    }
    if (!lunsUsedByDisks.isEmpty()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_LUNS_ALREADY_USED_BY_DISKS);
        Set<String> formattedIds = lunsUsedByDisks.stream().map(lun -> getFormattedLunId(lun, lun.getDiskAlias())).collect(Collectors.toSet());
        addValidationMessageVariable("lunIds", StringUtils.join(formattedIds, ", "));
    }
    return !lunsUsedBySDs.isEmpty() || !lunsUsedByDisks.isEmpty();
}
#method_after
protected boolean isLunsAlreadyInUse(List<String> lunIds) {
    // Get LUNs from DB
    List<LUNs> lunsFromDb = lunDao.getAll();
    Set<LUNs> lunsUsedBySDs = new HashSet<>();
    Set<LUNs> lunsUsedByDisks = new HashSet<>();
    for (LUNs lun : lunsFromDb) {
        if (lunIds.contains(lun.getLUNId())) {
            if (lun.getStorageDomainId() != null) {
                // LUN is already part of a storage domain
                lunsUsedBySDs.add(lun);
            }
            if (lun.getDiskId() != null) {
                // LUN is already used by a disk
                lunsUsedByDisks.add(lun);
            }
        }
    }
    if (!lunsUsedBySDs.isEmpty()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_LUNS_ALREADY_PART_OF_STORAGE_DOMAINS);
        Set<String> formattedIds = lunsUsedBySDs.stream().map(lun -> getFormattedLunId(lun, lun.getStorageDomainName())).collect(toSet());
        addValidationMessageVariable("lunIds", StringUtils.join(formattedIds, ", "));
    }
    if (!lunsUsedByDisks.isEmpty()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_LUNS_ALREADY_USED_BY_DISKS);
        Set<String> formattedIds = lunsUsedByDisks.stream().map(lun -> getFormattedLunId(lun, lun.getDiskAlias())).collect(toSet());
        addValidationMessageVariable("lunIds", StringUtils.join(formattedIds, ", "));
    }
    return !lunsUsedBySDs.isEmpty() || !lunsUsedByDisks.isEmpty();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    List<VM> vms = vmDao.getAllRunningForVds(getVdsId());
    Collections.sort(vms, Collections.reverseOrder(new VmsComparer()));
    List<Guid> autoStartVmIdsToRerun = new ArrayList<>();
    for (VM vm : vms) {
        if (vm.isAutoStartup()) {
            autoStartVmIdsToRerun.add(vm.getId());
        }
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.SetVmStatus, new SetVmStatusVDSCommandParameters(vm.getId(), VMStatus.Down, VmExitStatus.Error));
        // Write that this VM was shut down by host reboot or manual fence
        if (returnValue != null && returnValue.getSucceeded()) {
            logSettingVmToDown(getVds().getId(), vm.getId());
        }
        runInternalActionWithTasksContext(VdcActionType.ProcessDownVm, new ProcessDownVmParameters(vm.getId(), true));
    }
    runVdsCommand(VDSCommandType.UpdateVdsVMsCleared, new UpdateVdsVMsClearedVDSCommandParameters(getVdsId()));
    if (!autoStartVmIdsToRerun.isEmpty()) {
        haAutoStartVmsRunner.addVmsToRun(autoStartVmIdsToRerun);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    List<VM> vms = vmDao.getAllRunningForVds(getVdsId());
    Collections.sort(vms, Collections.reverseOrder(new VmsComparer()));
    List<Guid> autoStartVmIdsToRerun = new ArrayList<>();
    for (VM vm : vms) {
        if (vm.isAutoStartup()) {
            autoStartVmIdsToRerun.add(vm.getId());
        }
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.SetVmStatus, new SetVmStatusVDSCommandParameters(vm.getId(), VMStatus.Down, VmExitStatus.Error));
        // Write that this VM was shut down by host reboot or manual fence
        if (returnValue != null && returnValue.getSucceeded()) {
            logSettingVmToDown(vm.getName());
        }
        runInternalActionWithTasksContext(VdcActionType.ProcessDownVm, new ProcessDownVmParameters(vm.getId(), true));
    }
    runVdsCommand(VDSCommandType.UpdateVdsVMsCleared, new UpdateVdsVMsClearedVDSCommandParameters(getVdsId()));
    if (!autoStartVmIdsToRerun.isEmpty()) {
        haAutoStartVmsRunner.addVmsToRun(autoStartVmIdsToRerun);
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean result = true;
    if (getParameters().getEvent() == null || getParameters().getEvent().getOrigin().equalsIgnoreCase(OVIRT)) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_EXTERNAL_EVENT_ILLEGAL_ORIGIN);
        result = false;
    }
    if (!result) {
        addValidationMessage(EngineMessage.VAR__ACTION__ADD);
        addValidationMessage(EngineMessage.VAR__TYPE__EXTERNAL_EVENT);
    }
    return result;
}
#method_after
@Override
protected boolean validate() {
    if (getEvent() == null || AuditLog.OVIRT_ORIGIN.equalsIgnoreCase(getEvent().getOrigin())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_EXTERNAL_EVENT_ILLEGAL_ORIGIN);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    AuditLogableBase event = new AuditLogableBase(getParameters().getEvent());
    event.setExternal(true);
    String message = getParameters().getEvent().getMessage();
    switch(getParameters().getEvent().getSeverity()) {
        case NORMAL:
            auditLogDirector.log(event, AuditLogType.EXTERNAL_EVENT_NORMAL, message);
            break;
        case WARNING:
            auditLogDirector.log(event, AuditLogType.EXTERNAL_EVENT_WARNING, message);
            break;
        case ERROR:
            auditLogDirector.log(event, AuditLogType.EXTERNAL_EVENT_ERROR, message);
            break;
        case ALERT:
            AlertDirector.alert(event, AuditLogType.EXTERNAL_ALERT, auditLogDirector, message);
            break;
    }
    AuditLog auditLog = auditLogDao.getByOriginAndCustomEventId(getParameters().getEvent().getOrigin(), getParameters().getEvent().getCustomEventId());
    if (auditLog != null) {
        setActionReturnValue(auditLog.getAuditLogId());
        setSucceeded(true);
    }
    // Update host external status if set
    if (hasHostExternalStatus()) {
        vdsDynamicDao.updateExternalStatus(getParameters().getEvent().getVdsId(), getParameters().getExternalStatus());
    }
    // update storage domain external status if set
    if (hasStorageDomainExternalStatus()) {
        storageDomainDynamicDao.updateExternalStatus(getParameters().getEvent().getStorageDomainId(), getParameters().getExternalStatus());
    }
}
#method_after
@Override
protected void executeCommand() {
    AuditLogableBase event = Injector.injectMembers(new AuditLogableBase(getParameters().getEvent()));
    event.setExternal(true);
    String message = getEvent().getMessage();
    switch(getEvent().getSeverity()) {
        case NORMAL:
            auditLogDirector.log(event, AuditLogType.EXTERNAL_EVENT_NORMAL, message);
            break;
        case WARNING:
            auditLogDirector.log(event, AuditLogType.EXTERNAL_EVENT_WARNING, message);
            break;
        case ERROR:
            auditLogDirector.log(event, AuditLogType.EXTERNAL_EVENT_ERROR, message);
            break;
        case ALERT:
            AlertDirector.alert(event, AuditLogType.EXTERNAL_ALERT, auditLogDirector, message);
            break;
    }
    AuditLog auditLog = auditLogDao.getByOriginAndCustomEventId(getEvent().getOrigin(), getEvent().getCustomEventId());
    if (auditLog != null) {
        setActionReturnValue(auditLog.getAuditLogId());
        setSucceeded(true);
    }
    // Update host external status if set
    if (hasHostExternalStatus()) {
        vdsDynamicDao.updateExternalStatus(getEvent().getVdsId(), getParameters().getExternalStatus());
    }
    // update storage domain external status if set
    if (hasStorageDomainExternalStatus()) {
        storageDomainDynamicDao.updateExternalStatus(getEvent().getStorageDomainId(), getParameters().getExternalStatus());
    }
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = getPermissionList(getParameters().getEvent());
    // check for external host status modification
    if (hasHostExternalStatus()) {
        permissionList.add(new PermissionSubject(getParameters().getEvent().getVdsId(), VdcObjectType.VDS, ActionGroup.EDIT_HOST_CONFIGURATION));
    }
    // check for external storage domain status modification
    if (hasStorageDomainExternalStatus()) {
        permissionList.add(new PermissionSubject(getParameters().getEvent().getStorageDomainId(), VdcObjectType.Storage, ActionGroup.EDIT_STORAGE_DOMAIN_CONFIGURATION));
    }
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = getPermissionList(getEvent());
    // check for external host status modification
    if (hasHostExternalStatus()) {
        permissionList.add(new PermissionSubject(getEvent().getVdsId(), VdcObjectType.VDS, ActionGroup.EDIT_HOST_CONFIGURATION));
    }
    // check for external storage domain status modification
    if (hasStorageDomainExternalStatus()) {
        permissionList.add(new PermissionSubject(getEvent().getStorageDomainId(), VdcObjectType.Storage, ActionGroup.EDIT_STORAGE_DOMAIN_CONFIGURATION));
    }
    return permissionList;
}
#end_block

#method_before
private boolean hasHostExternalStatus() {
    return getParameters().getEvent().getVdsId() != null && getParameters().getExternalStatus() != null;
}
#method_after
private boolean hasHostExternalStatus() {
    return getEvent().getVdsId() != null && getParameters().getExternalStatus() != null;
}
#end_block

#method_before
private boolean hasStorageDomainExternalStatus() {
    return getParameters().getEvent().getStorageDomainId() != null && getParameters().getExternalStatus() != null;
}
#method_after
private boolean hasStorageDomainExternalStatus() {
    return getEvent().getStorageDomainId() != null && getParameters().getExternalStatus() != null;
}
#end_block

#method_before
protected void performDiskUpdate(final boolean unlockImage) {
    if (shouldPerformMetadataUpdate()) {
        updateMetaDataDescription((DiskImage) getNewDisk());
    }
    final Disk diskForUpdate = diskDao.get(getParameters().getDiskInfo().getId());
    final DiskVmElement diskVmElementForUpdate = diskVmElementDao.get(new VmDeviceId(getOldDisk().getId(), getVmId()));
    applyUserChanges(diskForUpdate, diskVmElementForUpdate);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            vmStaticDao.incrementDbGeneration(getVm().getId());
            updateDeviceProperties();
            baseDiskDao.update(diskForUpdate);
            diskVmElementDao.update(diskVmElementForUpdate);
            switch(diskForUpdate.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) diskForUpdate;
                    diskImage.setQuotaId(getQuotaId());
                    if (unlockImage && diskImage.getImageStatus() == ImageStatus.LOCKED) {
                        diskImage.setImageStatus(ImageStatus.OK);
                    }
                    imageDao.update(diskImage.getImage());
                    updateQuota(diskImage);
                    updateDiskProfile();
                    break;
                case CINDER:
                    CinderDisk cinderDisk = (CinderDisk) diskForUpdate;
                    cinderDisk.setQuotaId(getQuotaId());
                    setStorageDomainId(cinderDisk.getStorageIds().get(0));
                    getCinderBroker().updateDisk(cinderDisk);
                    if (unlockImage && cinderDisk.getImageStatus() == ImageStatus.LOCKED) {
                        cinderDisk.setImageStatus(ImageStatus.OK);
                    }
                    imageDao.update(cinderDisk.getImage());
                    updateQuota(cinderDisk);
                    break;
                case LUN:
                    // No specific update for LUN disk
                    break;
            }
            reloadDisks();
            setSucceeded(true);
            // If necessary set the new Storage QoS values on running VMs asynchronously
            liveUpdateDiskProfile();
            return null;
        }

        private void updateDeviceProperties() {
            if (updateReadOnlyRequested()) {
                vmDeviceForVm.setReadOnly(getNewDisk().getReadOnly());
                vmDeviceDao.update(vmDeviceForVm);
            }
            if ((getOldDiskVmElement().getDiskInterface() != getDiskVmElement().getDiskInterface()) || ((getOldDiskVmElement().isBoot() != getDiskVmElement().isBoot()) && (getDiskVmElement().getDiskInterface() == DiskInterface.IDE))) {
                vmDeviceForVm.setAddress("");
                vmDeviceDao.clearDeviceAddress(getOldDisk().getId());
            }
        }
    });
}
#method_after
protected void performDiskUpdate(final boolean unlockImage) {
    if (shouldPerformMetadataUpdate()) {
        updateMetaDataDescription((DiskImage) getNewDisk());
    }
    final Disk diskForUpdate = diskDao.get(getParameters().getDiskInfo().getId());
    final DiskVmElement diskVmElementForUpdate = diskVmElementDao.get(new VmDeviceId(getOldDisk().getId(), getVmId()));
    applyUserChanges(diskForUpdate, diskVmElementForUpdate);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            vmStaticDao.incrementDbGeneration(getVm().getId());
            updateDeviceProperties();
            baseDiskDao.update(diskForUpdate);
            diskVmElementDao.update(diskVmElementForUpdate);
            switch(diskForUpdate.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) diskForUpdate;
                    diskImage.setQuotaId(getQuotaId());
                    if (unlockImage && diskImage.getImageStatus() == ImageStatus.LOCKED) {
                        diskImage.setImageStatus(ImageStatus.OK);
                    }
                    imageDao.update(diskImage.getImage());
                    updateQuota(diskImage);
                    updateDiskProfile();
                    break;
                case CINDER:
                    CinderDisk cinderDisk = (CinderDisk) diskForUpdate;
                    cinderDisk.setQuotaId(getQuotaId());
                    setStorageDomainId(cinderDisk.getStorageIds().get(0));
                    getCinderBroker().updateDisk(cinderDisk);
                    if (unlockImage && cinderDisk.getImageStatus() == ImageStatus.LOCKED) {
                        cinderDisk.setImageStatus(ImageStatus.OK);
                    }
                    imageDao.update(cinderDisk.getImage());
                    updateQuota(cinderDisk);
                    break;
                case LUN:
                    // No specific update for LUN disk
                    break;
            }
            reloadDisks();
            setSucceeded(true);
            // If necessary set the new Storage QoS values on running VMs asynchronously
            liveUpdateDiskProfile();
            return null;
        }

        private void updateDeviceProperties() {
            if (updateReadOnlyRequested()) {
                vmDeviceForVm.setReadOnly(getDiskVmElement().isReadOnly());
                vmDeviceDao.update(vmDeviceForVm);
            }
            if ((getOldDiskVmElement().getDiskInterface() != getDiskVmElement().getDiskInterface()) || ((getOldDiskVmElement().isBoot() != getDiskVmElement().isBoot()) && (getDiskVmElement().getDiskInterface() == DiskInterface.IDE))) {
                vmDeviceForVm.setAddress("");
                vmDeviceDao.clearDeviceAddress(getOldDisk().getId());
            }
        }
    });
}
#end_block

#method_before
private void applyUserChanges(Disk diskToUpdate, DiskVmElement dveToUpdate) {
    updateSnapshotIdOnShareableChange(diskToUpdate, getNewDisk());
    diskToUpdate.setPropagateErrors(getNewDisk().getPropagateErrors());
    diskToUpdate.setWipeAfterDelete(getNewDisk().isWipeAfterDelete());
    diskToUpdate.setDiskAlias(getNewDisk().getDiskAlias());
    diskToUpdate.setDiskDescription(getNewDisk().getDiskDescription());
    diskToUpdate.setShareable(getNewDisk().isShareable());
    diskToUpdate.setReadOnly(getNewDisk().getReadOnly());
    diskToUpdate.setSgio(getNewDisk().getSgio());
    dveToUpdate.setBoot(getDiskVmElement().isBoot());
    dveToUpdate.setDiskInterface(getDiskVmElement().getDiskInterface());
    dveToUpdate.setPassDiscard(getDiskVmElement().isPassDiscard());
    dveToUpdate.setUsingScsiReservation(getDiskVmElement().isUsingScsiReservation());
}
#method_after
private void applyUserChanges(Disk diskToUpdate, DiskVmElement dveToUpdate) {
    updateSnapshotIdOnShareableChange(diskToUpdate, getNewDisk());
    diskToUpdate.setPropagateErrors(getNewDisk().getPropagateErrors());
    diskToUpdate.setWipeAfterDelete(getNewDisk().isWipeAfterDelete());
    diskToUpdate.setDiskAlias(getNewDisk().getDiskAlias());
    diskToUpdate.setDiskDescription(getNewDisk().getDiskDescription());
    diskToUpdate.setShareable(getNewDisk().isShareable());
    diskToUpdate.setSgio(getNewDisk().getSgio());
    dveToUpdate.setBoot(getDiskVmElement().isBoot());
    dveToUpdate.setDiskInterface(getDiskVmElement().getDiskInterface());
    dveToUpdate.setPassDiscard(getDiskVmElement().isPassDiscard());
    dveToUpdate.setUsingScsiReservation(getDiskVmElement().isUsingScsiReservation());
}
#end_block

#method_before
protected boolean updateReadOnlyRequested() {
    Boolean readOnlyNewValue = getNewDisk().getReadOnly();
    return readOnlyNewValue != null && !getVmDeviceForVm().getReadOnly().equals(readOnlyNewValue);
}
#method_after
protected boolean updateReadOnlyRequested() {
    boolean readOnlyNewValue = getDiskVmElement().isReadOnly();
    return !getVmDeviceForVm().getReadOnly().equals(readOnlyNewValue);
}
#end_block

#method_before
private void attachDetachDisk(Disk disk, VdcActionType actionType) {
    runInternalAction(actionType, new AttachDetachVmDiskParameters(new DiskVmElement(disk.getId(), getParameters().getNewVmGuid()), disk.getPlugged(), disk.getReadOnly()));
}
#method_after
private void attachDetachDisk(Disk disk, VdcActionType actionType) {
    DiskVmElement oldDve = disk.getDiskVmElementForVm(oldVmId);
    runInternalAction(actionType, new AttachDetachVmDiskParameters(new DiskVmElement(disk.getId(), getParameters().getNewVmGuid()), oldDve.isPlugged(), oldDve.isReadOnly()));
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (disk == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
    }
    DiskValidator oldDiskValidator = new DiskValidator(disk);
    ValidationResult isHostedEngineDisk = oldDiskValidator.validateNotHostedEngineDisk();
    if (!isHostedEngineDisk.isValid()) {
        return validate(isHostedEngineDisk);
    }
    disk.setReadOnly(getParameters().isReadOnly());
    DiskValidator diskValidator = getDiskValidator(disk);
    if (!checkDiskUsedAsOvfStore(diskValidator)) {
        return false;
    }
    if (isOperationPerformedOnDiskSnapshot() && (!validate(snapshotsValidator.snapshotExists(getSnapshot())) || !validate(snapshotsValidator.isRegularSnapshot(getSnapshot())))) {
        return false;
    }
    boolean isImageDisk = disk.getDiskStorageType().isInternal();
    if (isImageDisk) {
        // TODO : this load and check of the active disk will be removed
        // after inspecting upgrade
        Disk activeDisk = diskHandler.loadActiveDisk(disk.getId());
        if (((DiskImage) activeDisk).getImageStatus() == ImageStatus.ILLEGAL) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_DISK_OPERATION);
        }
        if (((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_DISKS_LOCKED);
            addValidationMessageVariable("diskAliases", disk.getDiskAlias());
            return false;
        }
    }
    if (!validate(new VmValidator(getVm()).isVmExists()) || !isVmInUpPausedDownStatus()) {
        return false;
    }
    if (!validateDiskVmData()) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    updateDisksFromDb();
    if (getDiskVmElement().isBoot() && !validate(diskValidator.isVmNotContainsBootDisk(getVm()))) {
        return false;
    }
    if (!isDiskPassPciAndIdeLimit()) {
        return false;
    }
    if (vmDeviceDao.exists(new VmDeviceId(disk.getId(), getVmId()))) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_ALREADY_ATTACHED);
    }
    if (!isOperationPerformedOnDiskSnapshot() && !disk.isShareable() && disk.getNumberOfVms() > 0) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NOT_SHAREABLE_DISK_ALREADY_ATTACHED);
    }
    if (isImageDisk && storagePoolIsoMapDao.get(new StoragePoolIsoMapId(((DiskImage) disk).getStorageIds().get(0), getVm().getStoragePoolId())) == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (isImageDisk) {
        StorageDomain storageDomain = storageDomainDao.getForStoragePool(((DiskImage) disk).getStorageIds().get(0), ((DiskImage) disk).getStoragePoolId());
        StorageDomainValidator storageDomainValidator = getStorageDomainValidator(storageDomain);
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
    }
    DiskVmElementValidator diskVmElementValidator = getDiskVmElementValidator(disk, getDiskVmElement());
    if (!validate(diskVmElementValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (!validate(diskVmElementValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!validate(diskVmElementValidator.isDiskInterfaceSupported(getVm()))) {
        return false;
    }
    Guid storageDomainId = disk.getDiskStorageType() == DiskStorageType.IMAGE ? ((DiskImage) disk).getStorageIds().get(0) : null;
    if (!validate(diskVmElementValidator.isPassDiscardSupported(storageDomainId))) {
        return false;
    }
    if (!isVmNotInPreviewSnapshot()) {
        return false;
    }
    if (getParameters().isPlugUnPlug() && getVm().getStatus() != VMStatus.Down) {
        return isDiskSupportedForPlugUnPlug(getDiskVmElement(), disk.getDiskAlias());
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (disk == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
    }
    DiskValidator oldDiskValidator = new DiskValidator(disk);
    ValidationResult isHostedEngineDisk = oldDiskValidator.validateNotHostedEngineDisk();
    if (!isHostedEngineDisk.isValid()) {
        return validate(isHostedEngineDisk);
    }
    DiskValidator diskValidator = getDiskValidator(disk);
    if (!checkDiskUsedAsOvfStore(diskValidator)) {
        return false;
    }
    if (isOperationPerformedOnDiskSnapshot() && (!validate(snapshotsValidator.snapshotExists(getSnapshot())) || !validate(snapshotsValidator.isRegularSnapshot(getSnapshot())))) {
        return false;
    }
    boolean isImageDisk = disk.getDiskStorageType().isInternal();
    if (isImageDisk) {
        // TODO : this load and check of the active disk will be removed
        // after inspecting upgrade
        Disk activeDisk = diskHandler.loadActiveDisk(disk.getId());
        if (((DiskImage) activeDisk).getImageStatus() == ImageStatus.ILLEGAL) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_DISK_OPERATION);
        }
        if (((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_DISKS_LOCKED);
            addValidationMessageVariable("diskAliases", disk.getDiskAlias());
            return false;
        }
    }
    if (!validate(new VmValidator(getVm()).isVmExists()) || !isVmInUpPausedDownStatus()) {
        return false;
    }
    if (!validateDiskVmData()) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    updateDisksFromDb();
    if (getDiskVmElement().isBoot() && !validate(diskValidator.isVmNotContainsBootDisk(getVm()))) {
        return false;
    }
    if (!isDiskPassPciAndIdeLimit()) {
        return false;
    }
    if (vmDeviceDao.exists(new VmDeviceId(disk.getId(), getVmId()))) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_ALREADY_ATTACHED);
    }
    if (!isOperationPerformedOnDiskSnapshot() && !disk.isShareable() && disk.getNumberOfVms() > 0) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NOT_SHAREABLE_DISK_ALREADY_ATTACHED);
    }
    if (isImageDisk && storagePoolIsoMapDao.get(new StoragePoolIsoMapId(((DiskImage) disk).getStorageIds().get(0), getVm().getStoragePoolId())) == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (isImageDisk) {
        StorageDomain storageDomain = storageDomainDao.getForStoragePool(((DiskImage) disk).getStorageIds().get(0), ((DiskImage) disk).getStoragePoolId());
        StorageDomainValidator storageDomainValidator = getStorageDomainValidator(storageDomain);
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
    }
    DiskVmElementValidator diskVmElementValidator = getDiskVmElementValidator(disk, getDiskVmElement());
    if (!validate(diskVmElementValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (!validate(diskVmElementValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!validate(diskVmElementValidator.isDiskInterfaceSupported(getVm()))) {
        return false;
    }
    Guid storageDomainId = disk.getDiskStorageType() == DiskStorageType.IMAGE ? ((DiskImage) disk).getStorageIds().get(0) : null;
    if (!validate(diskVmElementValidator.isPassDiscardSupported(storageDomainId))) {
        return false;
    }
    if (!isVmNotInPreviewSnapshot()) {
        return false;
    }
    if (getParameters().isPlugUnPlug() && getVm().getStatus() != VMStatus.Down) {
        return isDiskSupportedForPlugUnPlug(getDiskVmElement(), disk.getDiskAlias());
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    newVmStatic = getParameters().getVmStaticData();
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    } else if (!updateVmLease()) {
        return;
    }
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    vmStaticDao.incrementDbGeneration(getVm().getId());
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    newVmStatic.setQuotaId(getQuotaId());
    // Trigger OVF update for hosted engine VM only
    if (getVm().isHostedEngine()) {
        registerRollbackHandler(new TransactionCompletionListener() {

            @Override
            public void onSuccess() {
                ovfDataUpdater.triggerNow();
            }

            @Override
            public void onRollback() {
            // No notification is needed
            }
        });
    }
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!vmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    if ((getVm().isRunningOrPaused() || getVm().isPreviewSnapshot() || getVm().isSuspended()) && !getVm().isHostedEngine()) {
        if (getVm().getCustomCompatibilityVersion() == null && getParameters().getClusterLevelChangeFromVersion() != null) {
            // For backward compatibility after cluster version change
            // When running/paused: Set temporary custom compatibility version till the NextRun is applied (VM cold reboot)
            // When snapshot in preview: keep the custom compatibility version even after commit or roll back by undo
            newVmStatic.setCustomCompatibilityVersion(getParameters().getClusterLevelChangeFromVersion());
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    resourceManager.getVmManager(getVmId()).update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    vmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    liveUpdateCpuProfile();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    newVmStatic = getParameters().getVmStaticData();
    if (isRunningConfigurationNeeded()) {
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContext());
    } else if (!updateVmLease()) {
        return;
    }
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    vmStaticDao.incrementDbGeneration(getVm().getId());
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    newVmStatic.setQuotaId(getQuotaId());
    // Trigger OVF update for hosted engine VM only
    if (getVm().isHostedEngine()) {
        registerRollbackHandler(new TransactionCompletionListener() {

            @Override
            public void onSuccess() {
                ovfDataUpdater.triggerNow();
            }

            @Override
            public void onRollback() {
            // No notification is needed
            }
        });
    }
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!vmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    if ((getVm().isRunningOrPaused() || getVm().isPreviewSnapshot() || getVm().isSuspended()) && !getVm().isHostedEngine()) {
        if (getVm().getCustomCompatibilityVersion() == null && getParameters().getClusterLevelChangeFromVersion() != null) {
            // For backward compatibility after cluster version change
            // When running/paused: Set temporary custom compatibility version till the NextRun is applied (VM cold reboot)
            // When snapshot in preview: keep the custom compatibility version even after commit or roll back by undo
            newVmStatic.setCustomCompatibilityVersion(getParameters().getClusterLevelChangeFromVersion());
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    resourceManager.getVmManager(getVmId()).update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    vmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    liveUpdateCpuProfile();
    setSucceeded(true);
}
#end_block

#method_before
private void updateVmTemplateVersion() {
    if (getVm().getStatus() == VMStatus.Down) {
        VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.UpdateVmVersion, new UpdateVmVersionParameters(getVmId(), getParameters().getVm().getVmtGuid(), getParameters().getVm().isUseLatestVersion()), getLock());
        if (result.getSucceeded()) {
            getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
        }
        setSucceeded(result.getSucceeded());
        setActionReturnValue(VdcActionType.UpdateVmVersion);
    } else {
        createNextRunSnapshot();
        setSucceeded(true);
    }
}
#method_after
private void updateVmTemplateVersion() {
    if (getVm().getStatus() == VMStatus.Down) {
        VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.UpdateVmVersion, new UpdateVmVersionParameters(getVmId(), getParameters().getVm().getVmtGuid(), getParameters().getVm().isUseLatestVersion()), getLock());
        if (result.getSucceeded()) {
            getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
        }
        setSucceeded(result.getSucceeded());
        setActionReturnValue(VdcActionType.UpdateVmVersion);
    } else {
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContext());
        setSucceeded(true);
    }
}
#end_block

#method_before
private void updateCurrentMemory(VM newVm) {
    int currentMemory = getVm().getMemSizeMb();
    int newAmountOfMemory = newVm.getMemSizeMb();
    if (getVm().getStatus().isNotRunning()) {
        newVmStatic.setMemSizeMb(newAmountOfMemory);
        return;
    }
    if (getVm().getStatus() != VMStatus.Up) {
        newVmStatic.setMemSizeMb(currentMemory);
        log.warn("Memory update {}MB -> {}MB of VM {} ({}) left out. Memory can't be updated in current VM state ({}).", currentMemory, newAmountOfMemory, getVm().getName(), getVm().getId(), getVm().getStatus());
        return;
    }
    boolean isMemoryHotUnplugSupported = FeatureSupported.hotUnplugMemory(getVm().getCompatibilityVersion(), getVm().getClusterArch());
    if (VmCommonUtils.isMemoryToBeHotplugged(getVm(), newVm, isMemoryHotUnplugSupported)) {
        hotSetMemory(currentMemory, newAmountOfMemory);
    }
}
#method_after
private void updateCurrentMemory(VM newVm) {
    int currentMemory = getVm().getMemSizeMb();
    int newAmountOfMemory = newVm.getMemSizeMb();
    if (getVm().getStatus().isNotRunning()) {
        newVmStatic.setMemSizeMb(newAmountOfMemory);
        return;
    }
    if (getVm().getStatus() != VMStatus.Up) {
        newVmStatic.setMemSizeMb(currentMemory);
        log.warn("Memory update {}MB -> {}MB of VM {} ({}) left out. Memory can't be updated in current VM state ({}).", currentMemory, newAmountOfMemory, getVm().getName(), getVm().getId(), getVm().getStatus());
        return;
    }
    if (VmCommonUtils.isMemoryToBeHotplugged(getVm(), newVm)) {
        hotSetMemory(currentMemory, newAmountOfMemory);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    final Guid vdsId = getVdsId();
    final String sessionId = getParameters().getSessionId();
    // do not try to stop Host if Host is reported as Down via PM
    if (new HostFenceActionExecutor(getVds()).isHostPoweredOff()) {
        returnValue.setSucceeded(true);
    } else {
        // execute StopVds action
        returnValue = executeVdsFenceAction(vdsId, sessionId, VdcActionType.StopVds);
    }
    if (wasSkippedDueToPolicy(returnValue)) {
        // fence execution was skipped due to fencing policy, host should be alive
        getReturnValue().setSkippedDueToFencingPolicy(true);
        setSucceeded(false);
        setVdsStatus(VDSStatus.NonResponsive);
        return;
    } else if (returnValue.getSucceeded()) {
        executeFenceVdsManuallyAction(vdsId, sessionId);
        // execute StartVds action
        returnValue = executeVdsFenceAction(vdsId, sessionId, VdcActionType.StartVds);
        setSucceeded(returnValue.getSucceeded());
    } else {
        handleError();
        setSucceeded(false);
    }
    if (!getSucceeded()) {
        log.warn("Restart host action failed, updating host '{}' to '{}'", vdsId, VDSStatus.NonResponsive.name());
        setVdsStatus(VDSStatus.NonResponsive);
    }
}
#method_after
@Override
protected void executeCommand() {
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    final Guid vdsId = getVdsId();
    final String sessionId = getParameters().getSessionId();
    // do not try to stop Host if Host is reported as Down via PM
    if (new HostFenceActionExecutor(getVds()).isHostPoweredOff()) {
        returnValue.setSucceeded(true);
    } else {
        // execute StopVds action
        returnValue = executeVdsFenceAction(vdsId, sessionId, VdcActionType.StopVds);
    }
    if (wasSkippedDueToPolicy(returnValue)) {
        // fence execution was skipped due to fencing policy, host should be alive
        RestartVdsResult restartVdsResult = new RestartVdsResult();
        restartVdsResult.setSkippedDueToFencingPolicy(true);
        setActionReturnValue(restartVdsResult);
        setSucceeded(false);
        setVdsStatus(VDSStatus.NonResponsive);
        return;
    } else if (returnValue.getSucceeded()) {
        executeFenceVdsManuallyAction(vdsId, sessionId);
        // execute StartVds action
        returnValue = executeVdsFenceAction(vdsId, sessionId, VdcActionType.StartVds);
        setSucceeded(returnValue.getSucceeded());
    } else {
        handleError();
        setSucceeded(false);
    }
    if (!getSucceeded()) {
        log.warn("Restart host action failed, updating host '{}' to '{}'", vdsId, VDSStatus.NonResponsive.name());
        setVdsStatus(VDSStatus.NonResponsive);
    }
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    if (shouldUpdateStorageDisk()) {
        List<DiskImage> snapshots = diskImageDao.getAllSnapshotsForImageGroup(getParameters().getDestImageGroupId());
        setSnapshotForShareableDisk(snapshots);
        for (DiskImage snapshot : snapshots) {
            imageStorageDomainMapDao.remove(new ImageStorageDomainMapId(snapshot.getImageId(), snapshot.getStorageIds().get(0)));
            imageStorageDomainMapDao.save(new ImageStorageDomainMap(snapshot.getImageId(), getParameters().getStorageDomainId(), getParameters().getQuotaId(), getParameters().getDiskProfileId()));
        }
    }
    super.endSuccessfully();
}
#method_after
@Override
protected void endSuccessfully() {
    if (shouldUpdateStorageDisk()) {
        List<DiskImage> snapshots = diskImageDao.getAllSnapshotsForImageGroup(getParameters().getDestImageGroupId());
        setSnapshotForShareableDisk(snapshots);
        for (DiskImage snapshot : snapshots) {
            imageStorageDomainMapDao.remove(new ImageStorageDomainMapId(snapshot.getImageId(), snapshot.getStorageIds().get(0)));
            imageStorageDomainMapDao.save(new ImageStorageDomainMap(snapshot.getImageId(), getParameters().getStorageDomainId(), getParameters().getQuotaId(), getParameters().getDiskProfileId()));
            setQcowCompatForSnapshot(snapshot, null);
        }
    }
    super.endSuccessfully();
}
#end_block

#method_before
private void createVolume() {
    populateDiskSnapshotsInfoFromStorage();
    CreateVolumeContainerCommandParameters parameters = new CreateVolumeContainerCommandParameters(getParameters().getStoragePoolId(), getParameters().getDestDomain(), Guid.Empty, Guid.Empty, getParameters().getDestImageGroupId(), getParameters().getDestinationImageId(), getParameters().getDestinationFormat(), getParameters().getDescription(), getDiskImage().getSize(), ImagesHandler.determineTotalImageInitialSize(getDiskImage(), getParameters().getDestinationFormat(), getParameters().getDestDomain()));
    parameters.setJobWeight(getParameters().getOperationsJobWeight().get(CopyStage.DEST_CREATION.name()));
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    runInternalAction(VdcActionType.CreateVolumeContainer, parameters);
}
#method_after
private void createVolume() {
    populateDiskSnapshotsInfoFromStorage();
    CreateVolumeContainerCommandParameters parameters = new CreateVolumeContainerCommandParameters(getParameters().getStoragePoolId(), getParameters().getDestDomain(), Guid.Empty, Guid.Empty, getParameters().getDestImageGroupId(), getParameters().getDestinationImageId(), getParameters().getDestinationFormat(), getParameters().getDescription(), getDiskImage().getSize(), ImagesHandler.determineTotalImageInitialSize(getDiskImage(), getParameters().getDestinationFormat(), getParameters().getSrcDomain(), getParameters().getDestDomain()));
    parameters.setJobWeight(getParameters().getOperationsJobWeight().get(CopyStage.DEST_CREATION.name()));
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    runInternalAction(VdcActionType.CreateVolumeContainer, parameters);
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getParameters().isSkipChecks()) {
        return true;
    }
    if (!checkStorageDomain()) {
        return false;
    }
    // when the execution is internal, proceed also if the domain is in unknown status.
    if (!((getParameters().getIsInternal() && checkStorageDomainStatus(StorageDomainStatus.Active, StorageDomainStatus.Unknown)) || checkStorageDomainStatus(StorageDomainStatus.Active))) {
        return false;
    }
    if (!getParameters().getIsInternal()) {
        if (getStorageDomain().isHostedEngineStorage()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOSTED_ENGINE_STORAGE);
        }
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master && !validateMasterDeactivationAllowed()) {
            return false;
        }
        if (!isNoRunningVmsWithLeasesExist()) {
            return false;
        }
    }
    if (!isRunningVmsWithIsoAttached()) {
        return false;
    }
    if (!getParameters().getIsInternal() && !vmDao.getAllActiveForStorageDomain(getStorageDomain().getId()).isEmpty()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DETECTED_ACTIVE_VMS);
    }
    if (getStoragePool().getSpmVdsId() != null) {
        // In case there are running tasks in the pool, it is impossible to deactivate the master storage domain
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master && asyncTaskDao.getAsyncTaskIdsByStoragePoolId(getStorageDomain().getStoragePoolId()).size() > 0) {
            return failValidation(EngineMessage.ERROR_CANNOT_DEACTIVATE_MASTER_DOMAIN_WITH_TASKS_ON_POOL);
        } else if (getStorageDomain().getStorageDomainType() != StorageDomainType.ISO && !getParameters().getIsInternal() && (asyncTaskDao.getAsyncTaskIdsByEntity(getParameters().getStorageDomainId()).size() > 0 || commandEntityDao.getCommandIdsByEntity(getParameters().getStorageDomainId()).size() > 0)) {
            return failValidation(EngineMessage.ERROR_CANNOT_DEACTIVATE_DOMAIN_WITH_TASKS);
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getParameters().isSkipChecks()) {
        return true;
    }
    if (!checkStorageDomain()) {
        return false;
    }
    if (!validateDomainStatus()) {
        return false;
    }
    if (!getParameters().getIsInternal()) {
        if (getStorageDomain().isHostedEngineStorage()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOSTED_ENGINE_STORAGE);
        }
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master && !validateMasterDeactivationAllowed()) {
            return false;
        }
        if (!isNoRunningVmsWithLeasesExist()) {
            return false;
        }
    }
    if (!isRunningVmsWithIsoAttached()) {
        return false;
    }
    if (!getParameters().getIsInternal() && !vmDao.getAllActiveForStorageDomain(getStorageDomain().getId()).isEmpty()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DETECTED_ACTIVE_VMS);
    }
    if (getStoragePool().getSpmVdsId() != null) {
        // In case there are running tasks in the pool, it is impossible to deactivate the master storage domain
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master && asyncTaskDao.getAsyncTaskIdsByStoragePoolId(getStorageDomain().getStoragePoolId()).size() > 0) {
            return failValidation(EngineMessage.ERROR_CANNOT_DEACTIVATE_MASTER_DOMAIN_WITH_TASKS_ON_POOL);
        } else if (getStorageDomain().getStorageDomainType() != StorageDomainType.ISO && !getParameters().getIsInternal() && (asyncTaskDao.getAsyncTaskIdsByEntity(getParameters().getStorageDomainId()).size() > 0 || commandEntityDao.getCommandIdsByEntity(getParameters().getStorageDomainId()).size() > 0)) {
            return failValidation(EngineMessage.ERROR_CANNOT_DEACTIVATE_DOMAIN_WITH_TASKS);
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    if (getDestinationDiskImage() != null) {
        Guid storagePoolId = getDestinationDiskImage().getStoragePoolId() != null ? getDestinationDiskImage().getStoragePoolId() : Guid.Empty;
        setStoragePoolId(storagePoolId);
        Guid newImageGroupId = getDestinationDiskImage().getId() != null ? getDestinationDiskImage().getId() : Guid.Empty;
        Guid newImageId = getDestinationDiskImage().getImageId();
        Guid newStorageDomainID = getDestinationDiskImage().getStorageIds().get(0);
        // complete IRS data to DB disk image:
        try {
            DiskImage newImageIRS = getVolumeInfo(storagePoolId, newStorageDomainID, newImageGroupId, newImageId);
            if (newImageIRS != null) {
                completeImageData(newImageIRS);
                // Set volume type/format before updating DB in the 'finally' branch
                getDestinationDiskImage().getImage().setVolumeType(newImageIRS.getVolumeType());
                getDestinationDiskImage().getImage().setVolumeFormat(newImageIRS.getVolumeFormat());
                if (newImageIRS.getVolumeFormat().equals(VolumeFormat.COW)) {
                    setQcowCompatByQemuImageInfo(storagePoolId, newImageGroupId, newImageId, newStorageDomainID);
                }
            }
        } catch (EngineException e) {
            // Logging only
            log.error("Unable to update the image info for image '{}' (image group: '{}') on domain '{}'", newImageId, newImageGroupId, newStorageDomainID);
        } finally {
            if (!getParameters().isLeaveLocked()) {
                getDestinationDiskImage().setImageStatus(ImageStatus.OK);
            }
            imageDao.update(getDestinationDiskImage().getImage());
        }
    }
    if (!getParameters().isLeaveLocked()) {
        unLockImage();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    if (getDestinationDiskImage() != null) {
        Guid storagePoolId = getDestinationDiskImage().getStoragePoolId() != null ? getDestinationDiskImage().getStoragePoolId() : Guid.Empty;
        setStoragePoolId(storagePoolId);
        Guid newImageGroupId = getDestinationDiskImage().getId() != null ? getDestinationDiskImage().getId() : Guid.Empty;
        Guid newImageId = getDestinationDiskImage().getImageId();
        Guid newStorageDomainID = getDestinationDiskImage().getStorageIds().get(0);
        // complete IRS data to DB disk image:
        try {
            DiskImage newImageIRS = getVolumeInfo(storagePoolId, newStorageDomainID, newImageGroupId, newImageId);
            if (newImageIRS != null) {
                completeImageData(newImageIRS);
                // Set volume type/format before updating DB in the 'finally' branch
                getDestinationDiskImage().getImage().setVolumeType(newImageIRS.getVolumeType());
                getDestinationDiskImage().getImage().setVolumeFormat(newImageIRS.getVolumeFormat());
                if (newImageIRS.getVolumeFormat().equals(VolumeFormat.COW)) {
                    setQcowCompatByQemuImageInfo(storagePoolId, newImageGroupId, newImageId, newStorageDomainID, getDestinationDiskImage());
                }
            }
        } catch (EngineException e) {
            // Logging only
            log.error("Unable to update the image info for image '{}' (image group: '{}') on domain '{}'", newImageId, newImageGroupId, newStorageDomainID);
        } finally {
            if (!getParameters().isLeaveLocked()) {
                getDestinationDiskImage().setImageStatus(ImageStatus.OK);
            }
            imageDao.update(getDestinationDiskImage().getImage());
        }
    }
    if (!getParameters().isLeaveLocked()) {
        unLockImage();
    }
    setSucceeded(true);
}
#end_block

#method_before
private void setQcowCompatByQemuImageInfo(Guid storagePoolId, Guid newImageGroupId, Guid newImageId, Guid newStorageDomainID) {
    // If the VM is running then the volume is already prepared in the guest's host so there
    // is no need for prepare and teardown.
    Guid hostIdToExecuteQemuImageInfo = null;
    List<Pair<VM, VmDevice>> attachedVmsInfo = vmDao.getVmsWithPlugInfo(getDestinationDiskImage().getId());
    for (Pair<VM, VmDevice> pair : attachedVmsInfo) {
        VM vm = pair.getFirst();
        if (Boolean.TRUE.equals(pair.getSecond().isPlugged())) {
            if (vm.isStartingOrUp()) {
                hostIdToExecuteQemuImageInfo = vm.getRunOnVds();
                break;
            }
        }
    }
    setQcowCompat(getDestinationDiskImage().getImage(), storagePoolId, newImageGroupId, newImageId, newStorageDomainID, hostIdToExecuteQemuImageInfo);
}
#method_after
protected void setQcowCompatByQemuImageInfo(Guid storagePoolId, Guid newImageGroupId, Guid newImageId, Guid newStorageDomainID, DiskImage diskImage) {
    // If the VM is running then the volume is already prepared in the guest's host so there
    // is no need for prepare and teardown.
    Guid hostIdToExecuteQemuImageInfo = null;
    List<Pair<VM, VmDevice>> attachedVmsInfo = vmDao.getVmsWithPlugInfo(diskImage.getId());
    for (Pair<VM, VmDevice> pair : attachedVmsInfo) {
        VM vm = pair.getFirst();
        if (Boolean.TRUE.equals(pair.getSecond().isPlugged())) {
            if (vm.isStartingOrUp()) {
                hostIdToExecuteQemuImageInfo = vm.getRunOnVds();
                break;
            }
        }
    }
    setQcowCompat(diskImage.getImage(), storagePoolId, newImageGroupId, newImageId, newStorageDomainID, hostIdToExecuteQemuImageInfo);
}
#end_block

#method_before
private void initVmTemplate() {
    List<OvfEntityData> ovfEntityList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityList.get(0);
            vmTemplateFromConfiguration = ovfHelper.readVmTemplateFromOvf(ovfEntityData.getOvfData());
            vmTemplateFromConfiguration.setClusterId(getParameters().getClusterId());
            setVmTemplate(vmTemplateFromConfiguration);
            getParameters().setVmTemplate(vmTemplateFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            // For quota, update disks when required
            if (getParameters().getDiskTemplateMap() != null) {
                ArrayList imageList = new ArrayList<>(getParameters().getDiskTemplateMap().values());
                vmTemplateFromConfiguration.setDiskList(imageList);
                ensureDomainMap(imageList, getParameters().getDestDomainId());
            }
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
    setClusterId(getParameters().getClusterId());
    setStoragePoolId(getCluster().getStoragePoolId());
}
#method_after
private void initVmTemplate() {
    List<OvfEntityData> ovfEntityList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityList.get(0);
            vmTemplateFromConfiguration = ovfHelper.readVmTemplateFromOvf(ovfEntityData.getOvfData());
            vmTemplateFromConfiguration.setClusterId(getParameters().getClusterId());
            setVmTemplate(vmTemplateFromConfiguration);
            setEffectiveCompatibilityVersion(CompatibilityVersionUtils.getEffective(getVmTemplate(), this::getCluster));
            VmHandler.updateMaxMemorySize(getVmTemplate(), getEffectiveCompatibilityVersion());
            getParameters().setVmTemplate(vmTemplateFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            // For quota, update disks when required
            if (getParameters().getDiskTemplateMap() != null) {
                ArrayList imageList = new ArrayList<>(getParameters().getDiskTemplateMap().values());
                vmTemplateFromConfiguration.setDiskList(imageList);
                ensureDomainMap(imageList, getParameters().getDestDomainId());
            }
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
    setClusterId(getParameters().getClusterId());
    setStoragePoolId(getCluster().getStoragePoolId());
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    if (getDiskImage() != null && getDiskImage().getVmEntityType().isTemplateType()) {
        initVmTemplateId();
    }
}
#method_after
@Override
protected void init() {
    super.init();
    if (getDiskImage() != null && getDiskImage().getVmEntityType() != null && getDiskImage().getVmEntityType().isTemplateType()) {
        initVmTemplateId();
    }
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    if (Guid.Empty.equals(getParameters().getVmId()) && getVmPool() != null) {
        boolean vmPrestarted = true;
        Guid vmToAttach = vmPoolHandler.selectPrestartedVm(getVmPoolId(), getVmPool().isStateful(), (vmId, errors) -> getReturnValue().getValidationMessages().addAll(errors));
        if (Guid.Empty.equals(vmToAttach)) {
            vmPrestarted = false;
            vmToAttach = vmPoolHandler.selectNonPrestartedVm(getVmPoolId(), (vmId, errors) -> getReturnValue().getValidationMessages().addAll(errors));
        }
        getParameters().setVmId(vmToAttach);
        getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VM, vmToAttach));
        getParameters().setVmPrestarted(vmPrestarted);
        getParameters().setVmLockedOnSelect(!vmPrestarted);
    }
    setVmId(getParameters().getVmId());
}
#method_after
@Override
protected void init() {
    super.init();
    if (Guid.Empty.equals(getParameters().getVmId()) && getVmPool() != null) {
        boolean vmPrestarted = true;
        Guid vmToAttach = vmPoolHandler.selectPrestartedVm(getVmPoolId(), getVmPool().isStateful(), (vmId, errors) -> getReturnValue().getValidationMessages().addAll(errors));
        if (Guid.Empty.equals(vmToAttach)) {
            vmPrestarted = false;
            vmToAttach = vmPoolHandler.selectNonPrestartedVm(getVmPoolId(), (vmId, errors) -> getReturnValue().getValidationMessages().addAll(errors));
        }
        getParameters().setVmId(vmToAttach);
        getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VM, vmToAttach));
        getParameters().setVmPrestarted(vmPrestarted);
    }
    setVmId(getParameters().getVmId());
}
#end_block

#method_before
@Override
protected void freeCustomLocks() {
    if (getCommandStatus() == CommandStatus.ENDED_WITH_FAILURE && !Guid.Empty.equals(getVmId()) && getParameters().isVmLockedOnSelect()) {
        EngineLock runLock = vmPoolHandler.createLock(getVmId());
        lockManager.releaseLock(runLock);
        log.info("VM lock freed: {}", runLock);
        getParameters().setVmLockedOnSelect(false);
    }
}
#method_after
@Override
protected void freeCustomLocks() {
    if (getCommandStatus() == CommandStatus.ENDED_WITH_FAILURE && !Guid.Empty.equals(getVmId()) && !getParameters().isVmPrestarted()) {
        EngineLock runLock = vmPoolHandler.createLock(getVmId());
        lockManager.releaseLock(runLock);
        log.info("VM lock freed: {}", runLock);
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getEvent() == null || AuditLog.OVIRT_ORIGIN.equalsIgnoreCase(getEvent().getOrigin())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_EXTERNAL_EVENT_ILLEGAL_ORIGIN);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    boolean result = true;
    if (getParameters().getEvent() == null || getParameters().getEvent().getOrigin().equalsIgnoreCase(AuditLog.OVIRT_ORIGIN)) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_EXTERNAL_EVENT_ILLEGAL_ORIGIN);
        result = false;
    }
    if (!result) {
        addValidationMessage(EngineMessage.VAR__ACTION__ADD);
        addValidationMessage(EngineMessage.VAR__TYPE__EXTERNAL_EVENT);
    }
    return result;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    AuditLogableBase event = Injector.injectMembers(new AuditLogableBase(getEvent()));
    event.setExternal(true);
    String message = getEvent().getMessage();
    switch(getEvent().getSeverity()) {
        case NORMAL:
            auditLogDirector.log(event, AuditLogType.EXTERNAL_EVENT_NORMAL, message);
            break;
        case WARNING:
            auditLogDirector.log(event, AuditLogType.EXTERNAL_EVENT_WARNING, message);
            break;
        case ERROR:
            auditLogDirector.log(event, AuditLogType.EXTERNAL_EVENT_ERROR, message);
            break;
        case ALERT:
            AlertDirector.alert(event, AuditLogType.EXTERNAL_ALERT, auditLogDirector, message);
            break;
    }
    AuditLog auditLog = auditLogDao.getByOriginAndCustomEventId(getEvent().getOrigin(), getEvent().getCustomEventId());
    if (auditLog != null) {
        setActionReturnValue(auditLog.getAuditLogId());
        setSucceeded(true);
    }
    // Update host external status if set
    if (hasHostExternalStatus()) {
        vdsDynamicDao.updateExternalStatus(getEvent().getVdsId(), getParameters().getExternalStatus());
    }
    // update storage domain external status if set
    if (hasStorageDomainExternalStatus()) {
        storageDomainDynamicDao.updateExternalStatus(getEvent().getStorageDomainId(), getParameters().getExternalStatus());
    }
}
#method_after
@Override
protected void executeCommand() {
    AuditLogableBase event = Injector.injectMembers(new AuditLogableBase(getParameters().getEvent()));
    event.setExternal(true);
    String message = getParameters().getEvent().getMessage();
    switch(getParameters().getEvent().getSeverity()) {
        case NORMAL:
            auditLogDirector.log(event, AuditLogType.EXTERNAL_EVENT_NORMAL, message);
            break;
        case WARNING:
            auditLogDirector.log(event, AuditLogType.EXTERNAL_EVENT_WARNING, message);
            break;
        case ERROR:
            auditLogDirector.log(event, AuditLogType.EXTERNAL_EVENT_ERROR, message);
            break;
        case ALERT:
            AlertDirector.alert(event, AuditLogType.EXTERNAL_ALERT, auditLogDirector, message);
            break;
    }
    AuditLog auditLog = auditLogDao.getByOriginAndCustomEventId(getParameters().getEvent().getOrigin(), getParameters().getEvent().getCustomEventId());
    if (auditLog != null) {
        setActionReturnValue(auditLog.getAuditLogId());
        setSucceeded(true);
    }
    // Update host external status if set
    if (hasHostExternalStatus()) {
        vdsDynamicDao.updateExternalStatus(getParameters().getEvent().getVdsId(), getParameters().getExternalStatus());
    }
    // update storage domain external status if set
    if (hasStorageDomainExternalStatus()) {
        storageDomainDynamicDao.updateExternalStatus(getParameters().getEvent().getStorageDomainId(), getParameters().getExternalStatus());
    }
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = getPermissionList(getEvent());
    // check for external host status modification
    if (hasHostExternalStatus()) {
        permissionList.add(new PermissionSubject(getEvent().getVdsId(), VdcObjectType.VDS, ActionGroup.EDIT_HOST_CONFIGURATION));
    }
    // check for external storage domain status modification
    if (hasStorageDomainExternalStatus()) {
        permissionList.add(new PermissionSubject(getEvent().getStorageDomainId(), VdcObjectType.Storage, ActionGroup.EDIT_STORAGE_DOMAIN_CONFIGURATION));
    }
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = getPermissionList(getParameters().getEvent());
    // check for external host status modification
    if (hasHostExternalStatus()) {
        permissionList.add(new PermissionSubject(getParameters().getEvent().getVdsId(), VdcObjectType.VDS, ActionGroup.EDIT_HOST_CONFIGURATION));
    }
    // check for external storage domain status modification
    if (hasStorageDomainExternalStatus()) {
        permissionList.add(new PermissionSubject(getParameters().getEvent().getStorageDomainId(), VdcObjectType.Storage, ActionGroup.EDIT_STORAGE_DOMAIN_CONFIGURATION));
    }
    return permissionList;
}
#end_block

#method_before
private boolean hasHostExternalStatus() {
    return getEvent().getVdsId() != null && getParameters().getExternalStatus() != null;
}
#method_after
private boolean hasHostExternalStatus() {
    return getParameters().getEvent().getVdsId() != null && getParameters().getExternalStatus() != null;
}
#end_block

#method_before
private boolean hasStorageDomainExternalStatus() {
    return getEvent().getStorageDomainId() != null && getParameters().getExternalStatus() != null;
}
#method_after
private boolean hasStorageDomainExternalStatus() {
    return getParameters().getEvent().getStorageDomainId() != null && getParameters().getExternalStatus() != null;
}
#end_block

#method_before
private String composeObjectId() {
    return new EventKeyComposer(event, logType).composeObjectId();
}
#method_after
private String composeObjectId() {
    return EventKeyComposer.composeObjectId(event, logType);
}
#end_block

#method_before
public String composeObjectId() {
    final StringBuilder builder = new StringBuilder();
    compose(builder, "type", logType.toString());
    compose(builder, "sd", nullToEmptyString(event.getStorageDomainId()));
    compose(builder, "dc", nullToEmptyString(event.getStoragePoolId()));
    compose(builder, "user", nullToEmptyString(event.getUserId()));
    compose(builder, "cluster", event.getClusterId().toString());
    compose(builder, "vds", event.getVdsId().toString());
    compose(builder, "vm", emptyGuidToEmptyString(event.getVmId()));
    compose(builder, "template", emptyGuidToEmptyString(event.getVmTemplateId()));
    compose(builder, "customId", StringUtils.defaultString(event.getCustomId()));
    return builder.toString();
}
#method_after
public static String composeObjectId(AuditLogableBase event, AuditLogType logType) {
    final StringBuilder builder = new StringBuilder();
    compose(builder, "type", logType.toString());
    compose(builder, "sd", nullToEmptyString(event.getStorageDomainId()));
    compose(builder, "dc", nullToEmptyString(event.getStoragePoolId()));
    compose(builder, "user", nullToEmptyString(event.getUserId()));
    compose(builder, "cluster", event.getClusterId().toString());
    compose(builder, "vds", event.getVdsId().toString());
    compose(builder, "vm", emptyGuidToEmptyString(event.getVmId()));
    compose(builder, "template", emptyGuidToEmptyString(event.getVmTemplateId()));
    compose(builder, "customId", StringUtils.defaultString(event.getCustomId()));
    return builder.toString();
}
#end_block

#method_before
private void compose(StringBuilder builder, String key, String value) {
    final char DELIMITER = ',';
    final char NAME_VALUE_SEPARATOR = '=';
    if (builder.length() > 0) {
        builder.append(DELIMITER);
    }
    builder.append(key).append(NAME_VALUE_SEPARATOR).append(value);
}
#method_after
private static void compose(StringBuilder builder, String key, String value) {
    final char DELIMITER = ',';
    final char NAME_VALUE_SEPARATOR = '=';
    if (builder.length() > 0) {
        builder.append(DELIMITER);
    }
    builder.append(key).append(NAME_VALUE_SEPARATOR).append(value);
}
#end_block

#method_before
private String emptyGuidToEmptyString(Guid guid) {
    return Guid.Empty.equals(guid) ? "" : guid.toString();
}
#method_after
private static String emptyGuidToEmptyString(Guid guid) {
    return Guid.Empty.equals(guid) ? "" : guid.toString();
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().externalHostProvider().id());
    // DEPRECATED
    optional(host().rootPassword());
}
#method_after
@InputDetail
default void inputDetail() {
    // DEPRECATED
    mandatory(host().rootPassword());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().ssh().fingerprint());
    optional(host().ssh().port());
    optional(host().ssh().user().userName());
}
#method_after
@InputDetail
default void inputDetail() {
    mandatory(host().ssh().authenticationMethod());
    mandatory(host().ssh().user().password());
    mandatory(host().ssh().user().userName());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().externalHostProvider().id());
    // DEPRECATED
    optional(host().rootPassword());
}
#method_after
@InputDetail
default void inputDetail() {
    optional(rootPassword());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().ssh().fingerprint());
    optional(host().ssh().port());
    optional(host().ssh().user().userName());
}
#method_after
@InputDetail
default void inputDetail() {
    optional(ssh().authenticationMethod());
    optional(ssh().fingerprint());
    optional(ssh().port());
    optional(ssh().user().password());
    optional(ssh().user().userName());
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean result = true;
    Map<Guid, Cluster> clusters = new HashMap<>();
    Set<Guid> clustersAsSet = new HashSet<>();
    Set<Guid> vdsWithRunningVMs = new HashSet<>();
    List<String> hostNotRespondingList = new ArrayList<>();
    List<String> hostsWithNonMigratableVms = new ArrayList<>();
    List<String> hostsWithVmsWithPluggedDiskSnapshots = new ArrayList<>();
    List<String> nonMigratableVms = new ArrayList<>();
    for (Guid vdsId : getParameters().getVdsIdList()) {
        VDS vds = vdsDao.get(vdsId);
        if (vds == null) {
            log.error("ResourceManager::vdsMaintenance could not find VDS '{}'", vdsId);
            result = failValidation(EngineMessage.VDS_INVALID_SERVER_ID);
            continue;
        }
        // TODO make a more efficient call but normally the command just loads one cluster anyway
        if (!clusters.containsKey(vds.getClusterId())) {
            final Cluster cluster = clusterDao.get(vds.getClusterId());
            clusters.put(cluster.getId(), cluster);
        }
        if (!vdssToMaintenance.containsKey(vdsId)) {
            vdssToMaintenance.put(vdsId, vds);
            if (vds.getSpmStatus() == VdsSpmStatus.SPM) {
                addSharedLockEntry(vds);
            }
        }
        if (getParameters().isStopGlusterService() && !vds.getClusterSupportsGlusterService()) {
            result = failValidation(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_SERVICE_MAINTENANCE_NOT_SUPPORTED_FOR_CLUSTER);
            break;
        }
    }
    result = result && acquireLockInternal();
    if (result) {
        // tasks running
        for (Guid vdsId : getParameters().getVdsIdList()) {
            VDS vds = vdssToMaintenance.get(vdsId);
            if (vds != null) {
                if ((vds.getStatus() != VDSStatus.Maintenance) && (vds.getStatus() != VDSStatus.NonResponsive) && (vds.getStatus() != VDSStatus.Up) && (vds.getStatus() != VDSStatus.Error) && (vds.getStatus() != VDSStatus.PreparingForMaintenance) && (vds.getStatus() != VDSStatus.Down) && (vds.getStatus() != VDSStatus.NonOperational && (vds.getStatus() != VDSStatus.InstallFailed))) {
                    result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL);
                } else {
                    List<VM> vms = vmDao.getAllRunningForVds(vdsId);
                    if (!vms.isEmpty()) {
                        vdsWithRunningVMs.add(vdsId);
                    }
                    clustersAsSet.add(vds.getClusterId());
                    List<String> nonMigratableVmDescriptionsToFrontEnd = new ArrayList<>();
                    for (VM vm : vms) {
                        // And they need safe place for migration
                        if (vm.isHostedEngine()) {
                            List<VDS> clusterVdses = vdsDao.getAllForClusterWithStatus(vds.getClusterId(), VDSStatus.Up);
                            if (!HostedEngineHelper.haveHostsAvailableforHE(clusterVdses, getParameters().getVdsIdList())) {
                                failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_NO_ALTERNATE_HOST_FOR_HOSTED_ENGINE);
                                return false;
                            }
                        }
                        // other non-migratable VMs are reported
                        if (vm.getMigrationSupport() != MigrationSupport.MIGRATABLE && !vm.isHostedEngine()) {
                            nonMigratableVmDescriptionsToFrontEnd.add(vm.getName());
                        }
                    }
                    if (nonMigratableVmDescriptionsToFrontEnd.size() > 0) {
                        hostsWithNonMigratableVms.add(vds.getName());
                        nonMigratableVms.addAll(nonMigratableVmDescriptionsToFrontEnd);
                        // The non migratable VM names will be comma separated
                        log.error("VDS '{}' contains non migratable VMs", vdsId);
                        result = false;
                    } else if (!validate(new MultipleVmsValidator(vms).vmNotHavingPluggedDiskSnapshots(EngineMessage.VDS_CANNOT_MAINTENANCE_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
                        hostsWithVmsWithPluggedDiskSnapshots.add(vds.getName());
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.Maintenance) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_IN_MAINTENANCE);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.Contending) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_SPM_CONTENDING);
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getVmCount() > 0) {
                        result = false;
                        hostNotRespondingList.add(vds.getName());
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getSpmStatus() != VdsSpmStatus.None) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_RESPONDING_AND_IS_SPM);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.SPM && vds.getStatus() == VDSStatus.Up && asyncTaskDao.getAsyncTaskIdsByStoragePoolId(vds.getStoragePoolId()).size() > 0) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_SPM_WITH_RUNNING_TASKS);
                    } else if (!validateNoRunningJobs(vdsId)) {
                        result = false;
                    } else if (!clusters.get(vds.getClusterId()).isInUpgradeMode()) {
                        result = handlePositiveEnforcingAffinityGroup(vdsId, vms);
                    }
                    List<Step> steps = stepDao.getStartedStepsByStepSubjectEntity(new SubjectEntity(VdcObjectType.EXECUTION_HOST, vds.getId()));
                    if (!steps.isEmpty()) {
                        getReturnValue().getValidationMessages().add(String.format("$jobs %1$s", steps.stream().map(s -> s.getDescription()).collect(Collectors.joining(System.lineSeparator()))));
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_HOST_WITH_RUNNING_JOBS);
                    }
                }
            }
        }
        // If one of the host is non responsive with running VM's, add a Validate message.
        handleNonResponsiveHosts(hostNotRespondingList);
        // If one of the vms is non migratable, add a Validate message.
        handleNonMigratableVms(hostsWithNonMigratableVms, nonMigratableVms);
        handleHostsWithVmsWithPluggedDiskSnapshots(hostsWithVmsWithPluggedDiskSnapshots);
        if (result) {
            // Remove all redundant clusters in clusters list, by adding it to a
            // set.
            // For each cluster check for each host that belongs to it, if its a
            // part of the parameters and
            // if there are running hosts for it - if it is up and is not in the
            // parameters -migration will be possible
            // to be performed, and there is no point to continue the check for
            // the given cluster - otherwise,
            // if the host is up and in the parameters - it may be that the
            // cluster is problematic (no hosts in up
            // state that we will be able to migrate VMs to)
            // In the end - if the clusters list is not empty - this is an
            // error, use the "problematic clusters list" to format an error to
            // the client
            List<String> problematicClusters = new ArrayList<>();
            List<String> allHostsWithRunningVms = new ArrayList<>();
            for (Guid clusterID : clustersAsSet) {
                List<VDS> vdsList = vdsDao.getAllForCluster(clusterID);
                boolean vdsForMigrationExists = checkIfThereIsVDSToHoldMigratedVMs(getParameters().getVdsIdList(), vdsList);
                if (!vdsForMigrationExists) {
                    List<String> candidateHostsWithRunningVms = new ArrayList<>();
                    for (VDS vdsInCluster : vdsList) {
                        if (vdsWithRunningVMs.contains(vdsInCluster.getId())) {
                            candidateHostsWithRunningVms.add(vdsInCluster.getName());
                        }
                    }
                    // cluster
                    if (!candidateHostsWithRunningVms.isEmpty()) {
                        addClusterDetails(clusterID, problematicClusters);
                        allHostsWithRunningVms.addAll(candidateHostsWithRunningVms);
                    }
                }
            }
            // If there are problematic clusters
            result = problematicClusters.isEmpty();
            if (!result) {
                addValidationMessage(EngineMessage.CANNOT_MAINTENANCE_VDS_RUN_VMS_NO_OTHER_RUNNING_VDS);
                String commaDelimitedClusters = StringUtils.join(problematicClusters, ",");
                getReturnValue().getValidationMessages().add(String.format("$ClustersList %1$s", commaDelimitedClusters));
                getReturnValue().getValidationMessages().add(String.format("$HostsList %1$s", StringUtils.join(allHostsWithRunningVms, ",")));
            }
        }
        if (result && !getParameters().isForceMaintenance()) {
            result = validateGlusterParams(clustersAsSet);
        }
    }
    return result;
}
#method_after
@Override
protected boolean validate() {
    boolean result = true;
    Map<Guid, Cluster> clusters = new HashMap<>();
    Set<Guid> clustersAsSet = new HashSet<>();
    Set<Guid> vdsWithRunningVMs = new HashSet<>();
    List<String> hostNotRespondingList = new ArrayList<>();
    List<String> hostsWithNonMigratableVms = new ArrayList<>();
    List<String> hostsWithVmsWithPluggedDiskSnapshots = new ArrayList<>();
    List<String> nonMigratableVms = new ArrayList<>();
    for (Guid vdsId : getParameters().getVdsIdList()) {
        VDS vds = vdsDao.get(vdsId);
        if (vds == null) {
            log.error("ResourceManager::vdsMaintenance could not find VDS '{}'", vdsId);
            result = failValidation(EngineMessage.VDS_INVALID_SERVER_ID);
            continue;
        }
        // TODO make a more efficient call but normally the command just loads one cluster anyway
        if (!clusters.containsKey(vds.getClusterId())) {
            final Cluster cluster = clusterDao.get(vds.getClusterId());
            clusters.put(cluster.getId(), cluster);
        }
        if (!vdssToMaintenance.containsKey(vdsId)) {
            vdssToMaintenance.put(vdsId, vds);
            if (vds.getSpmStatus() == VdsSpmStatus.SPM) {
                addSharedLockEntry(vds);
            }
        }
        if (getParameters().isStopGlusterService() && !vds.getClusterSupportsGlusterService()) {
            result = failValidation(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_SERVICE_MAINTENANCE_NOT_SUPPORTED_FOR_CLUSTER);
            break;
        }
    }
    result = result && acquireLockInternal();
    if (result) {
        // tasks running
        for (Guid vdsId : getParameters().getVdsIdList()) {
            VDS vds = vdssToMaintenance.get(vdsId);
            if (vds != null) {
                if ((vds.getStatus() != VDSStatus.Maintenance) && (vds.getStatus() != VDSStatus.NonResponsive) && (vds.getStatus() != VDSStatus.Up) && (vds.getStatus() != VDSStatus.Error) && (vds.getStatus() != VDSStatus.PreparingForMaintenance) && (vds.getStatus() != VDSStatus.Down) && (vds.getStatus() != VDSStatus.NonOperational && (vds.getStatus() != VDSStatus.InstallFailed))) {
                    result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL);
                } else {
                    List<VM> vms = vmDao.getAllRunningForVds(vdsId);
                    if (!vms.isEmpty()) {
                        vdsWithRunningVMs.add(vdsId);
                    }
                    clustersAsSet.add(vds.getClusterId());
                    List<String> nonMigratableVmDescriptionsToFrontEnd = new ArrayList<>();
                    for (VM vm : vms) {
                        // And they need safe place for migration
                        if (vm.isHostedEngine()) {
                            List<VDS> clusterVdses = vdsDao.getAllForClusterWithStatus(vds.getClusterId(), VDSStatus.Up);
                            if (!HostedEngineHelper.haveHostsAvailableforHE(clusterVdses, getParameters().getVdsIdList())) {
                                failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_NO_ALTERNATE_HOST_FOR_HOSTED_ENGINE);
                                return false;
                            }
                        }
                        // other non-migratable VMs are reported
                        if (vm.getMigrationSupport() != MigrationSupport.MIGRATABLE && !vm.isHostedEngine()) {
                            nonMigratableVmDescriptionsToFrontEnd.add(vm.getName());
                        }
                    }
                    if (nonMigratableVmDescriptionsToFrontEnd.size() > 0) {
                        hostsWithNonMigratableVms.add(vds.getName());
                        nonMigratableVms.addAll(nonMigratableVmDescriptionsToFrontEnd);
                        // The non migratable VM names will be comma separated
                        log.error("VDS '{}' contains non migratable VMs", vdsId);
                        result = false;
                    } else if (!validate(new MultipleVmsValidator(vms).vmNotHavingPluggedDiskSnapshots(EngineMessage.VDS_CANNOT_MAINTENANCE_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
                        hostsWithVmsWithPluggedDiskSnapshots.add(vds.getName());
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.Maintenance) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_IN_MAINTENANCE);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.Contending) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_SPM_CONTENDING);
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getVmCount() > 0) {
                        result = false;
                        hostNotRespondingList.add(vds.getName());
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getSpmStatus() != VdsSpmStatus.None) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_RESPONDING_AND_IS_SPM);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.SPM && vds.getStatus() == VDSStatus.Up && asyncTaskDao.getAsyncTaskIdsByStoragePoolId(vds.getStoragePoolId()).size() > 0) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_SPM_WITH_RUNNING_TASKS);
                    } else if (!validateNoRunningJobs(vds)) {
                        result = false;
                    } else if (!clusters.get(vds.getClusterId()).isInUpgradeMode()) {
                        result = handlePositiveEnforcingAffinityGroup(vdsId, vms);
                    }
                }
            }
        }
        // If one of the host is non responsive with running VM's, add a Validate message.
        handleNonResponsiveHosts(hostNotRespondingList);
        // If one of the vms is non migratable, add a Validate message.
        handleNonMigratableVms(hostsWithNonMigratableVms, nonMigratableVms);
        handleHostsWithVmsWithPluggedDiskSnapshots(hostsWithVmsWithPluggedDiskSnapshots);
        if (result) {
            // Remove all redundant clusters in clusters list, by adding it to a
            // set.
            // For each cluster check for each host that belongs to it, if its a
            // part of the parameters and
            // if there are running hosts for it - if it is up and is not in the
            // parameters -migration will be possible
            // to be performed, and there is no point to continue the check for
            // the given cluster - otherwise,
            // if the host is up and in the parameters - it may be that the
            // cluster is problematic (no hosts in up
            // state that we will be able to migrate VMs to)
            // In the end - if the clusters list is not empty - this is an
            // error, use the "problematic clusters list" to format an error to
            // the client
            List<String> problematicClusters = new ArrayList<>();
            List<String> allHostsWithRunningVms = new ArrayList<>();
            for (Guid clusterID : clustersAsSet) {
                List<VDS> vdsList = vdsDao.getAllForCluster(clusterID);
                boolean vdsForMigrationExists = checkIfThereIsVDSToHoldMigratedVMs(getParameters().getVdsIdList(), vdsList);
                if (!vdsForMigrationExists) {
                    List<String> candidateHostsWithRunningVms = new ArrayList<>();
                    for (VDS vdsInCluster : vdsList) {
                        if (vdsWithRunningVMs.contains(vdsInCluster.getId())) {
                            candidateHostsWithRunningVms.add(vdsInCluster.getName());
                        }
                    }
                    // cluster
                    if (!candidateHostsWithRunningVms.isEmpty()) {
                        addClusterDetails(clusterID, problematicClusters);
                        allHostsWithRunningVms.addAll(candidateHostsWithRunningVms);
                    }
                }
            }
            // If there are problematic clusters
            result = problematicClusters.isEmpty();
            if (!result) {
                addValidationMessage(EngineMessage.CANNOT_MAINTENANCE_VDS_RUN_VMS_NO_OTHER_RUNNING_VDS);
                String commaDelimitedClusters = StringUtils.join(problematicClusters, ",");
                getReturnValue().getValidationMessages().add(String.format("$ClustersList %1$s", commaDelimitedClusters));
                getReturnValue().getValidationMessages().add(String.format("$HostsList %1$s", StringUtils.join(allHostsWithRunningVms, ",")));
            }
        }
        if (result && !getParameters().isForceMaintenance()) {
            result = validateGlusterParams(clustersAsSet);
        }
    }
    return result;
}
#end_block

#method_before
private boolean validateNoRunningJobs(Guid vdsId) {
    List<Step> steps = stepDao.getStartedStepsByStepSubjectEntity(new SubjectEntity(VdcObjectType.EXECUTION_HOST, vdsId));
    if (!steps.isEmpty()) {
        getReturnValue().getValidationMessages().add(String.format("$jobs %1$s", steps.stream().map(s -> s.getDescription()).collect(Collectors.joining(System.lineSeparator()))));
        return failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_HOST_WITH_RUNNING_JOBS);
    }
    return true;
}
#method_after
private boolean validateNoRunningJobs(VDS vds) {
    List<Step> steps = stepDao.getStartedStepsByStepSubjectEntity(new SubjectEntity(VdcObjectType.EXECUTION_HOST, vds.getId()));
    if (!steps.isEmpty()) {
        List<String> replacements = new ArrayList<>(2);
        replacements.add(ReplacementUtils.createSetVariableString("host", vds.getName()));
        replacements.addAll(ReplacementUtils.replaceWith("jobs", steps.stream().map(s -> s.getDescription()).collect(Collectors.toList())));
        return failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_HOST_WITH_RUNNING_OPERATIONS, replacements);
    }
    return true;
}
#end_block

#method_before
private List<StepSubjectEntity> prepareProgressTest(Guid entityId) {
    VdcObjectType type = VdcObjectType.Disk;
    BaseDisk diskImage = getDiskDao().get(entityId);
    assertProgress(null, diskImage);
    List<StepSubjectEntity> subjectEntities = Arrays.asList(new StepSubjectEntity(FixturesTool.STEP_ID, type, entityId, 30), new StepSubjectEntity(FixturesTool.STEP_ID_2, type, entityId, 50));
    getStepSubjectEntityDao().saveAll(subjectEntities);
    return subjectEntities;
}
#method_after
private void prepareProgressTest(Guid entityId) {
    VdcObjectType type = VdcObjectType.Disk;
    BaseDisk diskImage = getDiskDao().get(entityId);
    assertProgress(null, diskImage);
    getStepSubjectEntityDao().saveAll(Arrays.asList(new StepSubjectEntity(FixturesTool.STEP_ID, type, entityId, 30), new StepSubjectEntity(FixturesTool.STEP_ID_2, type, entityId, 50)));
}
#end_block

#method_before
@Test
public void startedStepsByStepSubjectEntityOtherStatuses() {
    StepSubjectEntity subjectEntity = prepareStartedStepsByStepSubjectEntityTest();
    Step step = dao.get(FixturesTool.STEP_ID);
    Arrays.stream(JobExecutionStatus.values()).filter(status -> status != JobExecutionStatus.STARTED).forEach(status -> {
        step.setStatus(status);
        dao.update(step);
        assertEmpty(dao.getStartedStepsByStepSubjectEntity(subjectEntity));
    });
}
#method_after
@Test
public void startedStepsByStepSubjectEntityOtherStatuses() {
    StepSubjectEntity subjectEntity = prepareStartedStepsByStepSubjectEntityTest();
    Step step = dao.get(FixturesTool.STEP_ID);
    Arrays.stream(JobExecutionStatus.values()).filter(status -> status != JobExecutionStatus.STARTED).forEach(status -> {
        step.setStatus(status);
        dao.update(step);
        assertNoStartedStepsForSubjectEntity(subjectEntity);
    });
}
#end_block

#method_before
@Test
public void startedStepsByStepSubjectEntityOtherId() {
    StepSubjectEntity subjectEntity = prepareStartedStepsByStepSubjectEntityTest();
    subjectEntity.setEntityId(Guid.Empty);
    assertEmpty(dao.getStartedStepsByStepSubjectEntity(subjectEntity));
}
#method_after
@Test
public void startedStepsByStepSubjectEntityOtherId() {
    StepSubjectEntity subjectEntity = prepareStartedStepsByStepSubjectEntityTest();
    subjectEntity.setEntityId(Guid.Empty);
    assertNoStartedStepsForSubjectEntity(subjectEntity);
}
#end_block

#method_before
@Test
public void startedStepsByStepSubjectEntityOtherEntityTYpe() {
    StepSubjectEntity subjectEntity = prepareStartedStepsByStepSubjectEntityTest();
    subjectEntity.setEntityType(VdcObjectType.AdElements);
    assertEmpty(dao.getStartedStepsByStepSubjectEntity(subjectEntity));
}
#method_after
@Test
public void startedStepsByStepSubjectEntityOtherEntityTYpe() {
    StepSubjectEntity subjectEntity = prepareStartedStepsByStepSubjectEntityTest();
    subjectEntity.setEntityType(VdcObjectType.AdElements);
    assertNoStartedStepsForSubjectEntity(subjectEntity);
}
#end_block

#method_before
private void addHelpButtonHandler() {
    infoAnchor.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            helpCommand.execute();
        }
    });
}
#method_after
private void addHelpButtonHandler() {
    infoAnchor.addClickHandler(event -> helpCommand.execute());
}
#end_block

#method_before
private void validateUpdateWipeAfterDelete(VMStatus status) {
    DiskImage disk = createDiskImage();
    disk.setWipeAfterDelete(false);
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    command.getParameters().getDiskInfo().setWipeAfterDelete(true);
    initializeCommand(createVm(status));
    ValidateTestUtils.runAndAssertValidateSuccess(command);
}
#method_after
private void validateUpdateWipeAfterDelete(VMStatus status) {
    DiskImage disk = createDiskImage();
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    command.getParameters().getDiskInfo().setWipeAfterDelete(true);
    initializeCommand(createVm(status));
    ValidateTestUtils.runAndAssertValidateSuccess(command);
}
#end_block

#method_before
@Override
protected void verify(Disk model, Disk transform) {
    assertNotNull(transform);
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getImageId(), transform.getImageId());
    assertEquals(model.getFormat(), transform.getFormat());
    assertEquals(model.isReadOnly(), transform.isReadOnly());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getLogicalName(), transform.getLogicalName());
    assertEquals(model.getOpenstackVolumeType().getName(), transform.getOpenstackVolumeType().getName());
    assertNotNull(model.getSnapshot());
    assertEquals(model.getSnapshot().getId(), transform.getSnapshot().getId());
    assertEquals("unexpected status", model.getStatus(), transform.getStatus());
    assertEquals("unexpected sparse", model.isSparse(), transform.isSparse());
    assertEquals("unexpected propagate errors", model.isPropagateErrors(), transform.isPropagateErrors());
    assertEquals("unexpected wipe after delete", model.isWipeAfterDelete(), transform.isWipeAfterDelete());
    assertEquals("unexpected shareable", model.isShareable(), transform.isShareable());
}
#method_after
@Override
protected void verify(Disk model, Disk transform) {
    assertNotNull(transform);
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getImageId(), transform.getImageId());
    assertEquals(model.getFormat(), transform.getFormat());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getLogicalName(), transform.getLogicalName());
    assertEquals(model.getOpenstackVolumeType().getName(), transform.getOpenstackVolumeType().getName());
    assertNotNull(model.getSnapshot());
    assertEquals(model.getSnapshot().getId(), transform.getSnapshot().getId());
    assertEquals("unexpected status", model.getStatus(), transform.getStatus());
    assertEquals("unexpected sparse", model.isSparse(), transform.isSparse());
    assertEquals("unexpected propagate errors", model.isPropagateErrors(), transform.isPropagateErrors());
    assertEquals("unexpected wipe after delete", model.isWipeAfterDelete(), transform.isWipeAfterDelete());
    assertEquals("unexpected shareable", model.isShareable(), transform.isShareable());
}
#end_block

#method_before
@Override
public VdcActionParametersBase getParameters(DiskAttachment incoming, org.ovirt.engine.core.common.businessentities.storage.DiskVmElement entity) {
    DiskVmElement dve = map(incoming, entity);
    dve.getId().setVmId(vmId);
    // Disk has to be sent along with the attachment data to the update command
    Disk disk = runQuery(VdcQueryType.GetDiskByDiskId, new IdQueryParameters(Guid.createGuidFromString(diskId))).getReturnValue();
    // If a <disk> was specified inside the attachment data we can update its properties too
    if (incoming.isSetDisk()) {
        disk = DiskMapper.map(incoming.getDisk(), disk);
        if (incoming.getDisk().isSetReadOnly()) {
            dve.setReadOnly(incoming.getDisk().isReadOnly());
        }
    }
    return new VmDiskOperationParameterBase(dve, disk);
}
#method_after
@Override
public VdcActionParametersBase getParameters(DiskAttachment incoming, org.ovirt.engine.core.common.businessentities.storage.DiskVmElement entity) {
    DiskVmElement dve = map(incoming, entity);
    dve.getId().setVmId(vmId);
    // Disk has to be sent along with the attachment data to the update command
    Disk disk = runQuery(VdcQueryType.GetDiskByDiskId, new IdQueryParameters(Guid.createGuidFromString(diskId))).getReturnValue();
    // If a <disk> was specified inside the attachment data we can update its properties too
    if (incoming.isSetDisk()) {
        disk = DiskMapper.map(incoming.getDisk(), disk);
        // TODO: Remove this in version 5 of the API as the setting of the read only attribute should be from DiskAttachment
        if (incoming.getDisk().isSetReadOnly()) {
            dve.setReadOnly(incoming.getDisk().isReadOnly());
        }
    }
    return new VmDiskOperationParameterBase(dve, disk);
}
#end_block

#method_before
@Test
public void testUpdateReadOnly() throws Exception {
    setUpGetEntityExpectations(2);
    setUpDiskVmElementExpectations();
    setUriInfo(setUpActionExpectations(VdcActionType.UpdateVmDisk, VmDiskOperationParameterBase.class, new String[] { "VmId", "DiskInfo.ReadOnly" }, new Object[] { VM_ID, Boolean.TRUE }, true, true));
    Disk disk = resource.update(getUpdate());
    assertNotNull(disk);
}
#method_after
@Test
public void testUpdateReadOnly() throws Exception {
    setUpGetEntityExpectations(2);
    setUpDiskVmElementExpectations();
    setUriInfo(setUpActionExpectations(VdcActionType.UpdateVmDisk, VmDiskOperationParameterBase.class, new String[] { "VmId", "DiskVmElement.ReadOnly" }, new Object[] { VM_ID, Boolean.TRUE }, true, true));
    Disk disk = resource.update(getUpdate());
    assertNotNull(disk);
}
#end_block

#method_before
protected Disk getUpdate() {
    Disk update = new Disk();
    update.setWipeAfterDelete(false);
    update.setReadOnly(false);
    return update;
}
#method_after
protected Disk getUpdate() {
    Disk update = new Disk();
    update.setWipeAfterDelete(false);
    update.setReadOnly(true);
    return update;
}
#end_block

#method_before
public boolean isBeingUnplugged() {
    return isBeingUnplugged;
}
#method_after
public boolean isBeingUnplugged() {
    return beingUnplugged;
}
#end_block

#method_before
public void setBeingUnplugged(boolean beingUnplugged) {
    isBeingUnplugged = beingUnplugged;
}
#method_after
public void setBeingUnplugged(boolean beingUnplugged) {
    this.beingUnplugged = beingUnplugged;
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (!(o instanceof VmDeviceFeEntity)) {
        return false;
    }
    if (!super.equals(o)) {
        return false;
    }
    VmDeviceFeEntity that = (VmDeviceFeEntity) o;
    return isBeingUnplugged == that.isBeingUnplugged && isVmUp == that.isVmUp;
}
#method_after
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (!(o instanceof VmDeviceFeEntity)) {
        return false;
    }
    VmDeviceFeEntity that = (VmDeviceFeEntity) o;
    return Objects.equals(vmDevice, that.vmDevice) && Objects.equals(vm, that.vm);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(super.hashCode(), isBeingUnplugged, isVmUp);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(vmDevice, vm);
}
#end_block

#method_before
@Override
public void onBrowserEvent(Context context, Element parent, VmDeviceFeEntity device, NativeEvent event, ValueUpdater<VmDeviceFeEntity> valueUpdater) {
    super.onBrowserEvent(context, parent, device, event, valueUpdater);
    if (!BrowserEvents.CLICK.equals(event.getType())) {
        return;
    }
    if (parent.getFirstChildElement() == null || !parent.getFirstChildElement().isOrHasChild(Element.as(event.getEventTarget()))) {
        return;
    }
    final boolean isButtonEnabled = device.isVmUp() && !device.isBeingUnplugged();
    if (!isButtonEnabled) {
        return;
    }
    for (CellClickHandler<VmDeviceFeEntity> clickHandler : clickHandlers) {
        clickHandler.onClick(event, device);
    }
}
#method_after
@Override
public void onBrowserEvent(Context context, Element parent, VmDeviceFeEntity device, NativeEvent event, ValueUpdater<VmDeviceFeEntity> valueUpdater) {
    super.onBrowserEvent(context, parent, device, event, valueUpdater);
    if (!BrowserEvents.CLICK.equals(event.getType())) {
        return;
    }
    if (parent.getFirstChildElement() == null || !parent.getFirstChildElement().isOrHasChild(Element.as(event.getEventTarget()))) {
        return;
    }
    final boolean isButtonEnabled = device.getVm().getStatus() == VMStatus.Up && !device.isBeingUnplugged();
    if (!isButtonEnabled) {
        return;
    }
    for (CellClickHandler<VmDeviceFeEntity> clickHandler : clickHandlers) {
        clickHandler.onClick(event, device);
    }
}
#end_block

#method_before
@Override
public void render(Context context, VmDeviceFeEntity device, SafeHtmlBuilder sb, String id) {
    if (!isHotUnpluggable(device)) {
        return;
    }
    if (!device.isVmUp()) {
        sb.append(cellTemplate.disabledButton(id, AssetProvider.getConstants().hotUnplug()));
        return;
    }
    if (device.isBeingUnplugged()) {
        sb.append(cellTemplate.disabledButton(id, AssetProvider.getConstants().unplugging()));
        return;
    }
    sb.append(cellTemplate.button(id, AssetProvider.getConstants().hotUnplug()));
}
#method_after
@Override
public void render(Context context, VmDeviceFeEntity deviceEntity, SafeHtmlBuilder sb, String id) {
    if (!isHotUnpluggable(deviceEntity.getVmDevice())) {
        return;
    }
    if (deviceEntity.getVm() == null) {
        return;
    }
    final boolean memoryHotUnplugSupported = AsyncDataProvider.getInstance().isMemoryHotUnplugSupportedByArchitecture(deviceEntity.getVm().getClusterArch(), deviceEntity.getVm().getCompatibilityVersion());
    if (!memoryHotUnplugSupported) {
        sb.append(cellTemplate.disabledButton(id, AssetProvider.getConstants().hotUnplug(), AssetProvider.getMessages().memoryHotUnplugNotSupportedForCompatibilityVersionAndArchitecture(deviceEntity.getVm().getCompatibilityVersion(), deviceEntity.getVm().getClusterArch())));
        return;
    }
    if (deviceEntity.getVm().getStatus() != VMStatus.Up) {
        sb.append(cellTemplate.disabledButton(id, AssetProvider.getConstants().hotUnplug(), AssetProvider.getConstants().vmHasToBeUp()));
        return;
    }
    if (deviceEntity.isBeingUnplugged()) {
        sb.append(cellTemplate.disabledButton(id, AssetProvider.getConstants().unplugging(), ""));
        return;
    }
    sb.append(cellTemplate.button(id, AssetProvider.getConstants().hotUnplug()));
}
#end_block

#method_before
public void makeSortable() {
    makeSortable(new Comparator<T>() {

        @Override
        public int compare(T o1, T o2) {
            String type1 = (getDeviceFromObject(o1) == null) ? null : getDeviceFromObject(o1).getType().getValue();
            String type2 = (getDeviceFromObject(o2) == null) ? null : getDeviceFromObject(o2).getType().getValue();
            return LexoNumericComparator.comp(type1, type2);
        }
    });
}
#method_after
public void makeSortable() {
    makeSortable(Comparator.comparing((T o) -> getDeviceFromObject(o) != null).thenComparing(o -> getDeviceFromObject(o).getType().getValue(), new LexoNumericComparator()));
}
#end_block

#method_before
private VmDevice getDeviceFromObject(T object) {
    VmDevice device = null;
    if (object instanceof VmDevice) {
        device = (VmDevice) object;
    } else if (object instanceof PairQueryable && ((PairQueryable) object).getFirst() instanceof VmDevice) {
        device = ((PairQueryable<VmDevice, VM>) object).getFirst();
    }
    return device;
}
#method_after
private VmDevice getDeviceFromObject(T object) {
    VmDevice device = null;
    if (object instanceof VmDeviceFeEntity) {
        device = ((VmDeviceFeEntity) object).getVmDevice();
    } else if (object instanceof PairQueryable && ((PairQueryable) object).getFirst() instanceof VmDevice) {
        device = ((PairQueryable<VmDevice, VM>) object).getFirst();
    }
    return device;
}
#end_block

#method_before
@Override
protected void syncSearch() {
    if (getEntity() != null) {
        super.syncSearch(VdcQueryType.GetVmDevicesForVm, new IdQueryParameters(getEntity().getId()));
    }
}
#method_after
@Override
protected void syncSearch() {
    if (getEntity() != null) {
        final E vm = getEntity();
        final AsyncQuery<VdcQueryReturnValue> asyncQuery = new AsyncQuery<VdcQueryReturnValue>(new AsyncCallback<VdcQueryReturnValue>() {

            @Override
            public void onSuccess(VdcQueryReturnValue returnValue) {
                final Collection<VmDevice> vmDevices = returnValue.getReturnValue();
                final ArrayList<VmDeviceFeEntity> frontendDevices = new ArrayList<>();
                for (VmDevice vmDevice : vmDevices) {
                    frontendDevices.add(new VmDeviceFeEntity(vmDevice, vm, idsOfDevicesBeingUnplugged.contains(vmDevice.getId())));
                }
                setItems(frontendDevices);
            }
        }) {
        };
        super.syncSearch(VdcQueryType.GetVmDevicesForVm, new IdQueryParameters(vm.getId()), asyncQuery);
    }
}
#end_block

#method_before
public void onHotUnplug(VmDeviceFeEntity vmDeviceFeEntity) {
    if (getEntity() == null) {
        return;
    }
    if (vmDeviceFeEntity == null || vmDeviceFeEntity.getType() != VmDeviceGeneralType.MEMORY) {
        return;
    }
    // $NON-NLS-1$
    final Integer memorySizeMb = (Integer) vmDeviceFeEntity.getSpecParams().get("size");
    if (memorySizeMb == null) {
        return;
    }
    setSelectedItem(vmDeviceFeEntity);
    ConfirmationModel confirmationModel = new ConfirmationModel();
    confirmationModel.setTitle(constants.memoryHotUnplug());
    confirmationModel.setHelpTag(HelpTag.template_not_found_on_export_domain);
    confirmationModel.setMessage(messages.memoryHotUnplugConfirmation(memorySizeMb, getEntity().getName()));
    confirmationModel.getCommands().add(memoryHotUnplugCommand);
    confirmationModel.getCommands().add(cancelMemoryHotUnplugCommand);
    setConfirmWindow(confirmationModel);
}
#method_after
public void onHotUnplug(VmDeviceFeEntity deviceEntity) {
    if (getEntity() == null) {
        return;
    }
    if (deviceEntity == null || deviceEntity.getVmDevice().getType() != VmDeviceGeneralType.MEMORY) {
        return;
    }
    // $NON-NLS-1$
    final Integer memorySizeMb = (Integer) deviceEntity.getVmDevice().getSpecParams().get("size");
    if (memorySizeMb == null) {
        return;
    }
    setSelectedItem(deviceEntity);
    ConfirmationModel confirmationModel = new ConfirmationModel();
    confirmationModel.setTitle(constants.memoryHotUnplug());
    confirmationModel.setHelpTag(HelpTag.template_not_found_on_export_domain);
    confirmationModel.setMessage(messages.memoryHotUnplugConfirmation(memorySizeMb, getEntity().getName()));
    confirmationModel.getCommands().add(memoryHotUnplugCommand);
    confirmationModel.getCommands().add(cancelMemoryHotUnplugCommand);
    setConfirmWindow(confirmationModel);
}
#end_block

#method_before
private void onMemoryHotUnplugConfirmed() {
    setConfirmWindow(null);
    final VmDeviceFeEntity vmDevice = getSelectedItem();
    if (vmDevice == null || vmDevice.getType() != VmDeviceGeneralType.MEMORY) {
        return;
    }
    updateButtonLabel(vmDevice);
    Frontend.getInstance().runAction(VdcActionType.HotUnplugMemory, new HotUnplugMemoryParameters(VmDeviceCommonUtils.getSizeOfMemoryDeviceMb(vmDevice), vmDevice.getVmId()), true);
}
#method_after
private void onMemoryHotUnplugConfirmed() {
    setConfirmWindow(null);
    final VmDeviceFeEntity deviceEntity = getSelectedItem();
    if (deviceEntity == null || deviceEntity.getVmDevice().getType() != VmDeviceGeneralType.MEMORY) {
        return;
    }
    idsOfDevicesBeingUnplugged.add(deviceEntity.getVmDevice().getId(), new ExpiringSet.RemovalAction<VmDeviceId>() {

        @Override
        public void itemRemoved(VmDeviceId item) {
            updateItems();
        }
    });
    updateItems();
    Frontend.getInstance().runAction(VdcActionType.HotUnplugMemory, new HotUnplugMemoryParameters(deviceEntity.getVmDevice().getId()), true);
}
#end_block

#method_before
private void addDeviceTypeColumn() {
    final AbstractTextColumn<VmDeviceFeEntity> deviceTypeColumn = new AbstractTextColumn<VmDeviceFeEntity>() {

        @Override
        public String getValue(VmDeviceFeEntity device) {
            return device.getDevice();
        }
    };
    deviceTypeColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(deviceTypeColumn, constants.deviceType(), "70px");
}
#method_after
private void addDeviceTypeColumn() {
    final AbstractTextColumn<VmDeviceFeEntity> deviceTypeColumn = new AbstractTextColumn<VmDeviceFeEntity>() {

        @Override
        public String getValue(VmDeviceFeEntity deviceEntity) {
            return deviceEntity.getVmDevice().getDevice();
        }
    };
    deviceTypeColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(deviceTypeColumn, constants.deviceType(), "70px");
}
#end_block

#method_before
private void addAddressColumn() {
    final AbstractTextColumn<VmDeviceFeEntity> deviceAddressColumn = new AbstractTextColumn<VmDeviceFeEntity>() {

        @Override
        public String getValue(VmDeviceFeEntity device) {
            return device.getAddress();
        }
    };
    deviceAddressColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(deviceAddressColumn, constants.deviceAddress(), "395px");
}
#method_after
private void addAddressColumn() {
    final AbstractTextColumn<VmDeviceFeEntity> deviceAddressColumn = new AbstractTextColumn<VmDeviceFeEntity>() {

        @Override
        public String getValue(VmDeviceFeEntity deviceEntity) {
            return deviceEntity.getVmDevice().getAddress();
        }
    };
    deviceAddressColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(deviceAddressColumn, constants.deviceAddress(), "395px");
}
#end_block

#method_before
private void addReadOnlyColumn() {
    final AbstractCheckboxColumn<VmDeviceFeEntity> readonlyColumn = new AbstractCheckboxColumn<VmDeviceFeEntity>() {

        @Override
        public Boolean getValue(VmDeviceFeEntity object) {
            return object.getReadOnly();
        }

        @Override
        protected boolean canEdit(VmDeviceFeEntity object) {
            return false;
        }
    };
    readonlyColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(readonlyColumn, constants.deviceReadOnlyAlias(), "70px");
}
#method_after
private void addReadOnlyColumn() {
    final AbstractCheckboxColumn<VmDeviceFeEntity> readonlyColumn = new AbstractCheckboxColumn<VmDeviceFeEntity>() {

        @Override
        public Boolean getValue(VmDeviceFeEntity object) {
            return object.getVmDevice().getReadOnly();
        }

        @Override
        protected boolean canEdit(VmDeviceFeEntity object) {
            return false;
        }
    };
    readonlyColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(readonlyColumn, constants.deviceReadOnlyAlias(), "70px");
}
#end_block

#method_before
private void addPluggedColumn() {
    final AbstractCheckboxColumn<VmDeviceFeEntity> pluggedColumn = new AbstractCheckboxColumn<VmDeviceFeEntity>() {

        @Override
        public Boolean getValue(VmDeviceFeEntity object) {
            return object.isPlugged();
        }

        @Override
        protected boolean canEdit(VmDeviceFeEntity object) {
            return false;
        }
    };
    pluggedColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(pluggedColumn, constants.devicePluggedAlias(), "70px");
}
#method_after
private void addPluggedColumn() {
    final AbstractCheckboxColumn<VmDeviceFeEntity> pluggedColumn = new AbstractCheckboxColumn<VmDeviceFeEntity>() {

        @Override
        public Boolean getValue(VmDeviceFeEntity object) {
            return object.getVmDevice().isPlugged();
        }

        @Override
        protected boolean canEdit(VmDeviceFeEntity object) {
            return false;
        }
    };
    pluggedColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(pluggedColumn, constants.devicePluggedAlias(), "70px");
}
#end_block

#method_before
private void addManagedColumn() {
    final AbstractCheckboxColumn<VmDeviceFeEntity> managedColumn = new AbstractCheckboxColumn<VmDeviceFeEntity>() {

        @Override
        public Boolean getValue(VmDeviceFeEntity object) {
            return object.isManaged();
        }

        @Override
        protected boolean canEdit(VmDeviceFeEntity object) {
            return false;
        }
    };
    managedColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(managedColumn, constants.deviceManagedAlias(), "70px");
}
#method_after
private void addManagedColumn() {
    final AbstractCheckboxColumn<VmDeviceFeEntity> managedColumn = new AbstractCheckboxColumn<VmDeviceFeEntity>() {

        @Override
        public Boolean getValue(VmDeviceFeEntity object) {
            return object.getVmDevice().isManaged();
        }

        @Override
        protected boolean canEdit(VmDeviceFeEntity object) {
            return false;
        }
    };
    managedColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(managedColumn, constants.deviceManagedAlias(), "70px");
}
#end_block

#method_before
private void addSpecParamsColumn() {
    final AbstractTextColumn<VmDeviceFeEntity> specParamsColumn = new AbstractTextColumn<VmDeviceFeEntity>() {

        @Override
        public String getValue(VmDeviceFeEntity device) {
            return device.getSpecParams().toString();
        }
    };
    specParamsColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(specParamsColumn, constants.deviceSpecParamsAlias(), "300px");
}
#method_after
private void addSpecParamsColumn() {
    final AbstractTextColumn<VmDeviceFeEntity> specParamsColumn = new AbstractTextColumn<VmDeviceFeEntity>() {

        @Override
        public String getValue(VmDeviceFeEntity deviceEntity) {
            return deviceEntity.getVmDevice().getSpecParams().toString();
        }
    };
    specParamsColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(specParamsColumn, constants.deviceSpecParamsAlias(), "300px");
}
#end_block

#method_before
private void addTimerChangeHandler() {
    timerChangeHandler = timer.addGridTimerStateChangeEventHandler(new GridTimerStateChangeEventHandler() {

        @Override
        public void onGridTimerStateChange(GridTimerStateChangeEvent event) {
            int newInterval = event.getRefreshRate();
            if (timer.isActive()) {
                // Immediately adjust timer and restart if it was active.
                if (newInterval != timer.getRefreshRate()) {
                    timer.stop();
                    timer.setRefreshRate(newInterval, false);
                    timer.start();
                }
            } else {
                // Update the timer interval for inactive timers, so they are correct when they become active
                timer.setRefreshRate(newInterval, false);
            }
        }
    });
}
#method_after
private void addTimerChangeHandler() {
    timerChangeHandler = timer.addGridTimerStateChangeEventHandler(event -> {
        int newInterval = event.getRefreshRate();
        if (timer.isActive()) {
            // Immediately adjust timer and restart if it was active.
            if (newInterval != timer.getRefreshRate()) {
                timer.stop();
                timer.setRefreshRate(newInterval, false);
                timer.start();
            }
        } else {
            // Update the timer interval for inactive timers, so they are correct when they become active
            timer.setRefreshRate(newInterval, false);
        }
    });
}
#end_block

#method_before
public void search() {
    // Defer search if there max result limit was not yet retrieved.
    if (getSearchPageSize() == UnknownInteger) {
        asyncCallback.requestSearch();
    } else {
        stopRefresh();
        if (getIsQueryFirstTime()) {
            setSelectedItem(null);
            setSelectedItems(null);
        }
        if (getIsTimerDisabled() == false) {
            setIsQueryFirstTime(true);
            onPropertyChanged(new PropertyChangedEventArgs(PropertyChangedEventArgs.PROGRESS));
            syncSearch();
            setIsQueryFirstTime(false);
            startGridTimer();
        } else {
            syncSearch();
        }
    }
}
#method_after
public void search() {
    // Defer search if there max result limit was not yet retrieved.
    if (getSearchPageSize() == UnknownInteger) {
        asyncCallback.requestSearch();
    } else {
        stopRefresh();
        if (getIsQueryFirstTime()) {
            setSelectedItem(null);
            setSelectedItems(null);
        }
        if (!getIsTimerDisabled()) {
            setIsQueryFirstTime(true);
            onPropertyChanged(new PropertyChangedEventArgs(PropertyChangedEventArgs.PROGRESS));
            syncSearch();
            setIsQueryFirstTime(false);
            startGridTimer();
        } else {
            syncSearch();
        }
    }
}
#end_block

#method_before
protected void startGridTimer() {
    if (getTimer() != null) {
        // Timer can be null if the event bus hasn't been set yet (model hasn't been fully initialized)
        startRefresh();
    } else {
        // Defer the start of the timer until after the event bus has been added to this model. Then we
        // can pass the event bus to the timer and the timer can become active.
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                startRefresh();
            }
        });
    }
}
#method_after
protected void startGridTimer() {
    if (getTimer() != null) {
        // Timer can be null if the event bus hasn't been set yet (model hasn't been fully initialized)
        startRefresh();
    } else {
        // Defer the start of the timer until after the event bus has been added to this model. Then we
        // can pass the event bus to the timer and the timer can become active.
        Scheduler.get().scheduleDeferred(() -> startRefresh());
    }
}
#end_block

#method_before
protected void syncSearch(VdcQueryType vdcQueryType, VdcQueryParametersBase vdcQueryParametersBase) {
    vdcQueryParametersBase.setRefresh(getIsQueryFirstTime());
    Frontend.getInstance().runQuery(vdcQueryType, vdcQueryParametersBase, new SetItemsAsyncQuery());
    setIsQueryFirstTime(false);
}
#method_after
protected void syncSearch(VdcQueryType vdcQueryType, VdcQueryParametersBase vdcQueryParametersBase, AsyncQuery<VdcQueryReturnValue> asyncCallback) {
    vdcQueryParametersBase.setRefresh(getIsQueryFirstTime());
    Frontend.getInstance().runQuery(vdcQueryType, vdcQueryParametersBase, asyncCallback);
    setIsQueryFirstTime(false);
}
#end_block

#method_before
protected void syncSearch(VdcQueryType vdcQueryType, VdcQueryParametersBase vdcQueryParametersBase) {
    vdcQueryParametersBase.setRefresh(getIsQueryFirstTime());
    Frontend.getInstance().runQuery(vdcQueryType, vdcQueryParametersBase, new SetItemsAsyncQuery());
    setIsQueryFirstTime(false);
}
#method_after
protected void syncSearch(VdcQueryType vdcQueryType, VdcQueryParametersBase vdcQueryParametersBase) {
    syncSearch(vdcQueryType, vdcQueryParametersBase, new SetItemsAsyncQuery());
}
#end_block

#method_before
@Override
protected void registerHandlers() {
    // Register to listen for operation complete events.
    registerHandler(getEventBus().addHandler(RefreshActiveModelEvent.getType(), new RefreshActiveModelHandler() {

        @Override
        public void onRefreshActiveModel(RefreshActiveModelEvent event) {
            if (getTimer().isActive() || refreshOnInactiveTimer()) {
                // Only if we are active should we refresh.
                if (handleRefreshActiveModel(event)) {
                    syncSearch();
                }
                if (event.isDoFastForward()) {
                    // Start the fast refresh.
                    getTimer().fastForward();
                }
            }
        }
    }));
}
#method_after
@Override
protected void registerHandlers() {
    // Register to listen for operation complete events.
    registerHandler(getEventBus().addHandler(RefreshActiveModelEvent.getType(), event -> {
        if (getTimer().isActive() || refreshOnInactiveTimer()) {
            // Only if we are active should we refresh.
            if (handleRefreshActiveModel(event)) {
                syncSearch();
            }
            if (event.isDoFastForward()) {
                // Start the fast refresh.
                getTimer().fastForward();
            }
        }
    }));
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<Snapshot, VmListModel<Void>, VmSnapshotListModel> getVmSnapshotListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<VmSnapshotCreatePopupPresenterWidget> createPopupProvider, final Provider<VmClonePopupPresenterWidget> cloneVmPopupProvider, final Provider<VmMakeTemplatePopupPresenterWidget> cloneTemplatePopupProvider, final Provider<VmSnapshotPreviewPopupPresenterWidget> previewPopupProvider, final Provider<VmSnapshotCustomPreviewPopupPresenterWidget> customPreviewPopupProvider, final Provider<VmListModel<Void>> mainModelProvider, final Provider<VmSnapshotListModel> modelProvider) {
    SearchableDetailTabModelProvider<Snapshot, VmListModel<Void>, VmSnapshotListModel> result = new SearchableDetailTabModelProvider<Snapshot, VmListModel<Void>, VmSnapshotListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VmSnapshotListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand()) {
                return createPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCloneVmCommand()) {
                getModel().setSystemTreeSelectedItem(this.getMainModel().getSystemTreeSelectedItem());
                return cloneVmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getPreviewCommand()) {
                return previewPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCustomPreviewCommand()) {
                return customPreviewPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCloneTemplateCommand()) {
                return cloneTemplatePopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<Snapshot, VmListModel<Void>, VmSnapshotListModel> getVmSnapshotListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<VmSnapshotCreatePopupPresenterWidget> createPopupProvider, final Provider<VmClonePopupPresenterWidget> cloneVmPopupProvider, final Provider<VmMakeTemplatePopupPresenterWidget> cloneTemplatePopupProvider, final Provider<VmSnapshotPreviewPopupPresenterWidget> previewPopupProvider, final Provider<VmSnapshotCustomPreviewPopupPresenterWidget> customPreviewPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<VmListModel<Void>> mainModelProvider, final Provider<VmSnapshotListModel> modelProvider) {
    SearchableDetailTabModelProvider<Snapshot, VmListModel<Void>, VmSnapshotListModel> result = new SearchableDetailTabModelProvider<Snapshot, VmListModel<Void>, VmSnapshotListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VmSnapshotListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand()) {
                return createPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCloneVmCommand()) {
                getModel().setSystemTreeSelectedItem(this.getMainModel().getSystemTreeSelectedItem());
                return cloneVmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getPreviewCommand()) {
                return previewPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCustomPreviewCommand()) {
                return customPreviewPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCloneTemplateCommand()) {
                return cloneTemplatePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(VmSnapshotListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
private void setSessionUser(Session session) {
    try {
        User user = getUserResource().getUserByNameAndDomain(session.getUser().getUserName(), session.getUser().getDomain().getName());
        if (user != null) {
            session.getUser().setId(user.getId());
            session.getUser().setHref(user.getHref());
            session.getUser().getDomain().setId(user.getDomain().getId());
            session.getUser().getDomain().setHref(user.getDomain().getHref());
        }
    } catch (WebApplicationException ex) {
    // If user was not found, ignore it.
    }
}
#method_after
private void setSessionUser(Session session) {
    // Get the user entity and don't fail if user is not found in database:
    DbUser entity = getEntity(DbUser.class, VdcQueryType.GetDbUserByUserNameAndDomain, new GetDbUserByUserNameAndDomainQueryParameters(session.getUser().getUserName(), session.getUser().getDomain().getName()), "", false, false);
    // Map the database user to model user:
    if (entity != null) {
        User user = BackendApiResource.getInstance().getUsersResource().getUserResource(entity.getId().toString()).get();
        /**
         * TODO: It's enough to set user ID and href, we don't have to set also domain, please consider this
         * when moving to API version 5.
         */
        if (user != null) {
            session.getUser().setId(user.getId());
            session.getUser().setHref(user.getHref());
            session.getUser().getDomain().setId(user.getDomain().getId());
            session.getUser().getDomain().setHref(user.getDomain().getHref());
        }
    }
}
#end_block

#method_before
public void warnMemorySizeLegal(VmBase vm, Version clusterVersion) {
    if (!VmValidationUtils.isMemorySizeLegal(vm.getOsId(), vm.getMemSizeMb(), clusterVersion)) {
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVmId(vm.getId());
        logable.addCustomValue("VmName", vm.getName());
        logable.addCustomValue("VmMemInMb", String.valueOf(vm.getMemSizeMb()));
        logable.addCustomValue("VmMinMemInMb", String.valueOf(VmValidationUtils.getMinMemorySizeInMb(vm.getOsId(), clusterVersion)));
        logable.addCustomValue("VmMaxMemInMb", String.valueOf(VmValidationUtils.getMaxMemorySizeInMb(vm.getOsId(), clusterVersion)));
        auditLogDirector.log(logable, AuditLogType.VM_MEMORY_NOT_IN_RECOMMENDED_RANGE);
    }
}
#method_after
public void warnMemorySizeLegal(VmBase vm, Version clusterVersion) {
    if (!VmValidationUtils.isMemorySizeLegal(vm.getOsId(), vm.getMemSizeMb(), clusterVersion)) {
        AuditLogableBase logable = new AuditLogableBase();
        logable.addCustomValue("VmName", vm.getName());
        logable.addCustomValue("VmMemInMb", String.valueOf(vm.getMemSizeMb()));
        logable.addCustomValue("VmMinMemInMb", String.valueOf(VmValidationUtils.getMinMemorySizeInMb(vm.getOsId(), clusterVersion)));
        logable.addCustomValue("VmMaxMemInMb", String.valueOf(VmValidationUtils.getMaxMemorySizeInMb(vm.getOsId(), clusterVersion)));
        auditLogDirector.log(logable, AuditLogType.VM_MEMORY_NOT_IN_RECOMMENDED_RANGE);
    }
}
#end_block

#method_before
private boolean canPlugInterface(VmNic iface, VmBase vmBase) {
    ReadMacPool macPool = macPoolPerCluster.getMacPoolForCluster(vmBase.getClusterId());
    VmInterfaceManager vmIfaceManager = new VmInterfaceManager();
    if (vmIfaceManager.tooManyPluggedInterfaceWithSameMac(iface, macPool)) {
        vmIfaceManager.auditLogMacInUseUnplug(iface);
        return false;
    } else {
        return true;
    }
}
#method_after
private boolean canPlugInterface(VmNic iface, VmBase vmBase) {
    ReadMacPool macPool = macPoolPerCluster.getMacPoolForCluster(vmBase.getClusterId());
    VmInterfaceManager vmIfaceManager = new VmInterfaceManager();
    if (vmIfaceManager.tooManyPluggedInterfaceWithSameMac(iface, macPool)) {
        vmIfaceManager.auditLogMacInUseUnplug(iface, vmBase.getName());
        return false;
    } else {
        return true;
    }
}
#end_block

#method_before
private void disableSpiceUsb(Guid vmId) {
    removeUsbControllers(vmId);
    removeUsbSlots(vmId);
}
#method_after
private void disableSpiceUsb(Guid vmId) {
    removeUsbControllers(vmId);
    removeUsbSlots(vmId);
    removeUsbChannels(vmId);
}
#end_block

#method_before
private void acquireUnmanagedUsbController(VmBase vmBase, List<VmDevice> managedUsbControllers, List<VmDevice> unmanagedControllers) {
    if (unmanagedControllers.size() > 1) {
        throw new IllegalStateException(format("At most one unmanaged USB controller expected for VM=%s(%s), found=%s", vmBase.getName(), vmBase.getId(), unmanagedControllers));
    }
    final UsbControllerModel controllerModel = getUsbControllerModel(vmBase);
    if (unmanagedControllers.size() == 1) {
        // should not be here but due to https://bugzilla.redhat.com/show_bug.cgi?id=1438188 can appear one
        // remove it
        removeVmDevices(managedUsbControllers);
        // has been created on pre 4.0 engine by VDSM, adopt it as ours
        VmDevice device = unmanagedControllers.iterator().next();
        device.setManaged(true);
        device.setPlugged(true);
        device.setReadOnly(false);
        device.setSpecParams(createUsbControllerSpecParams(controllerModel.libvirtName, 0));
        vmDeviceDao.update(device);
        return;
    }
}
#method_after
private void acquireUnmanagedUsbController(VmBase vmBase, List<VmDevice> managedUsbControllers, List<VmDevice> unmanagedControllers) {
    if (unmanagedControllers.size() > 1) {
        throw new IllegalStateException(format("At most one unmanaged USB controller expected for VM=%s(%s), found=%s", vmBase.getName(), vmBase.getId(), unmanagedControllers));
    }
    final UsbControllerModel controllerModel = getUsbControllerModel(vmBase);
    if (unmanagedControllers.isEmpty()) {
        return;
    }
    // should not be here but due to https://bugzilla.redhat.com/1438188 can appear one
    // remove it
    removeVmDevices(managedUsbControllers);
    // has been created on pre 4.0 engine by VDSM, adopt it as ours
    VmDevice device = unmanagedControllers.iterator().next();
    device.setManaged(true);
    device.setPlugged(true);
    device.setReadOnly(false);
    device.setSpecParams(createUsbControllerSpecParams(controllerModel.libvirtName, 0));
    vmDeviceDao.update(device);
}
#end_block

#method_before
public void updateVmDevicesOnRun(VmBase vmBase) {
    if (vmBase != null) {
        updateUsbSlots(vmBase, vmBase);
    }
}
#method_after
public void updateVmDevicesOnRun(VmBase vmBase) {
    if (vmBase != null) {
        updateUsbSlots(vmBase, vmBase);
        removeLeftOverDevices(vmBase);
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation(DWH_HEART_BEAT_METHOD)
public void engineIsRunningNotification() {
    try {
        log.debug("DWH Heart Beat - Start");
        TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, () -> {
            heartBeatVar.setDateTime(new Date());
            dwhHistoryTimekeepingDao.save(heartBeatVar);
            log.debug("DWH Heart Beat - End");
            return null;
        });
    } catch (Exception ex) {
        log.error("Error updating DWH Heart Beat: {}", ex.getMessage());
        log.debug("Exception", ex);
    }
}
#method_after
@OnTimerMethodAnnotation(DWH_HEART_BEAT_METHOD)
public void engineIsRunningNotification() {
    try {
        log.debug("DWH Heart Beat - Start");
        TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, () -> {
            heartBeatVar.setDateTime(new Date());
            dwhHistoryTimekeepingDao.save(heartBeatVar);
            return null;
        });
        log.debug("DWH Heart Beat - End");
    } catch (Exception ex) {
        log.error("Error updating DWH Heart Beat: {}", ex.getMessage());
        log.debug("Exception", ex);
    }
}
#end_block

#method_before
private boolean canPlugInterface(VmNic iface, VmBase vmBase) {
    ReadMacPool macPool = macPoolPerCluster.getMacPoolForCluster(vmBase.getClusterId());
    VmInterfaceManager vmIfaceManager = new VmInterfaceManager();
    if (vmIfaceManager.tooManyPluggedInterfaceWithSameMac(iface, macPool)) {
        vmIfaceManager.auditLogMacInUseUnplug(iface);
        return false;
    } else {
        return true;
    }
}
#method_after
private boolean canPlugInterface(VmNic iface, VmBase vmBase) {
    ReadMacPool macPool = macPoolPerCluster.getMacPoolForCluster(vmBase.getClusterId());
    VmInterfaceManager vmIfaceManager = new VmInterfaceManager();
    if (vmIfaceManager.tooManyPluggedInterfaceWithSameMac(iface, macPool)) {
        vmIfaceManager.auditLogMacInUseUnplug(iface, vmBase.getName());
        return false;
    } else {
        return true;
    }
}
#end_block

#method_before
public void updateVmDevicesOnRun(VmBase vmBase) {
    if (vmBase != null) {
        updateUsbSlots(vmBase, vmBase);
        removeLeftoverDevices(vmBase);
    }
}
#method_after
public void updateVmDevicesOnRun(VmBase vmBase) {
    if (vmBase != null) {
        updateUsbSlots(vmBase, vmBase);
        removeLeftOverDevices(vmBase);
    }
}
#end_block

#method_before
@Override
protected void doNicManipulation(final ArrayList<VdcActionParametersBase> createVnicParameters, final ArrayList<VdcActionParametersBase> updateVnicParameters, final ArrayList<VdcActionParametersBase> removeVnicParameters, final boolean isAddingNewVm, final Guid id, final UnitVmModel unitVmModel) {
    Frontend.getInstance().runMultipleActions(VdcActionType.AddVmInterface, createVnicParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            Frontend.getInstance().runMultipleActions(VdcActionType.UpdateVmInterface, updateVnicParameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Frontend.getInstance().runMultipleActions(VdcActionType.RemoveVmInterface, removeVnicParameters, result12 -> {
                        if (isAddingNewVm) {
                            VmOperationParameterBase reorderParams = new VmOperationParameterBase(id);
                            Frontend.getInstance().runAction(VdcActionType.ReorderVmNics, reorderParams, result1 -> getCallback().vnicCreated(id, unitVmModel));
                        } else {
                            getCallback().vnicCreated(id, unitVmModel);
                        }
                    }, this);
                }
            }, this);
        }
    }, this);
}
#method_after
@Override
protected void doNicManipulation(final ArrayList<VdcActionParametersBase> createVnicParameters, final ArrayList<VdcActionParametersBase> updateVnicParameters, final ArrayList<VdcActionParametersBase> removeVnicParameters, final boolean isAddingNewVm, final Guid id, final UnitVmModel unitVmModel) {
    Frontend.getInstance().runMultipleActions(VdcActionType.AddVmInterface, createVnicParameters, addInterfaceResult -> Frontend.getInstance().runMultipleActions(VdcActionType.UpdateVmInterface, updateVnicParameters, updateInterfaceResult -> Frontend.getInstance().runMultipleActions(VdcActionType.RemoveVmInterface, removeVnicParameters, removeInterfaceResult -> {
        if (isAddingNewVm) {
            VmOperationParameterBase reorderParams = new VmOperationParameterBase(id);
            Frontend.getInstance().runAction(VdcActionType.ReorderVmNics, reorderParams, reorderResult -> getCallback().vnicCreated(id, unitVmModel));
        } else {
            getCallback().vnicCreated(id, unitVmModel);
        }
    }, this), this), this);
}
#end_block

#method_before
private void saveNewPosixStorage() {
    StorageModel model = (StorageModel) getWindow();
    PosixStorageModel posixModel = (PosixStorageModel) model.getCurrentStorageItem();
    VDS host = model.getHost().getSelectedItem();
    hostId = host.getId();
    // Create storage connection.
    StorageServerConnections connection = new StorageServerConnections();
    connection.setConnection(path);
    connection.setStorageType(posixModel.getType());
    connection.setVfsType(posixModel.getVfsType().getEntity());
    connection.setMountOptions(posixModel.getMountOptions().getEntity());
    this.connection = connection;
    ArrayList<VdcActionType> actionTypes = new ArrayList<>();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    actionTypes.add(VdcActionType.AddStorageServerConnection);
    actionTypes.add(posixModel.getAddStorageDomainVdcAction());
    parameters.add(new StorageServerConnectionParametersBase(this.connection, host.getId(), false));
    StorageDomainManagementParameter parameter = new StorageDomainManagementParameter(storageDomain);
    parameter.setVdsId(host.getId());
    StoragePool dataCenter = model.getDataCenter().getSelectedItem();
    parameter.setStoragePoolId(dataCenter.getId());
    parameters.add(parameter);
    IFrontendActionAsyncCallback callback1 = result -> {
        DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) result.getState();
        VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
        dataCenterGuideModel.storageDomain.setStorage((String) vdcReturnValueBase.getActionReturnValue());
        dataCenterGuideModel.connection.setId((String) vdcReturnValueBase.getActionReturnValue());
    };
    IFrontendActionAsyncCallback callback2 = result -> {
        DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) result.getState();
        VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
        dataCenterGuideModel.storageId = vdcReturnValueBase.getActionReturnValue();
        // Attach storage to data center as necessary.
        StorageModel storageModel = (StorageModel) dataCenterGuideModel.getWindow();
        StoragePool dataCenter1 = storageModel.getDataCenter().getSelectedItem();
        if (!dataCenter1.getId().equals(StorageModel.UnassignedDataCenterId)) {
            dataCenterGuideModel.attachStorageToDataCenter(dataCenterGuideModel.storageId, dataCenter1.getId());
        }
        dataCenterGuideModel.onFinish(dataCenterGuideModel.context, true, dataCenterGuideModel.storageModel);
    };
    IFrontendActionAsyncCallback failureCallback = result -> {
        DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) result.getState();
        dataCenterGuideModel.cleanConnection(dataCenterGuideModel.connection, dataCenterGuideModel.hostId);
        dataCenterGuideModel.onFinish(dataCenterGuideModel.context, false, dataCenterGuideModel.storageModel);
    };
    Frontend.getInstance().runMultipleActions(actionTypes, parameters, new ArrayList<>(Arrays.asList(new IFrontendActionAsyncCallback[] { callback1, callback2 })), failureCallback, this);
}
#method_after
private void saveNewPosixStorage() {
    StorageModel model = (StorageModel) getWindow();
    PosixStorageModel posixModel = (PosixStorageModel) model.getCurrentStorageItem();
    VDS host = model.getHost().getSelectedItem();
    hostId = host.getId();
    // Create storage connection.
    StorageServerConnections connection = new StorageServerConnections();
    connection.setConnection(path);
    connection.setStorageType(posixModel.getType());
    connection.setVfsType(posixModel.getVfsType().getEntity());
    connection.setMountOptions(posixModel.getMountOptions().getEntity());
    this.connection = connection;
    ArrayList<VdcActionType> actionTypes = new ArrayList<>();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    actionTypes.add(VdcActionType.AddStorageServerConnection);
    actionTypes.add(posixModel.getAddStorageDomainVdcAction());
    parameters.add(new StorageServerConnectionParametersBase(this.connection, host.getId(), false));
    StorageDomainManagementParameter parameter = new StorageDomainManagementParameter(storageDomain);
    parameter.setVdsId(host.getId());
    StoragePool dataCenter = model.getDataCenter().getSelectedItem();
    parameter.setStoragePoolId(dataCenter.getId());
    parameters.add(parameter);
    IFrontendActionAsyncCallback callback1 = result -> {
        DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) result.getState();
        VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
        dataCenterGuideModel.storageDomain.setStorage((String) vdcReturnValueBase.getActionReturnValue());
        dataCenterGuideModel.connection.setId((String) vdcReturnValueBase.getActionReturnValue());
    };
    IFrontendActionAsyncCallback callback2 = result -> {
        DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) result.getState();
        VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
        dataCenterGuideModel.storageId = vdcReturnValueBase.getActionReturnValue();
        // Attach storage to data center as necessary.
        StorageModel storageModel = (StorageModel) dataCenterGuideModel.getWindow();
        StoragePool selectedDataCenter = storageModel.getDataCenter().getSelectedItem();
        if (!selectedDataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
            dataCenterGuideModel.attachStorageToDataCenter(dataCenterGuideModel.storageId, selectedDataCenter.getId());
        }
        dataCenterGuideModel.onFinish(dataCenterGuideModel.context, true, dataCenterGuideModel.storageModel);
    };
    IFrontendActionAsyncCallback failureCallback = result -> {
        DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) result.getState();
        dataCenterGuideModel.cleanConnection(dataCenterGuideModel.connection, dataCenterGuideModel.hostId);
        dataCenterGuideModel.onFinish(dataCenterGuideModel.context, false, dataCenterGuideModel.storageModel);
    };
    Frontend.getInstance().runMultipleActions(actionTypes, parameters, new ArrayList<>(Arrays.asList(new IFrontendActionAsyncCallback[] { callback1, callback2 })), failureCallback, this);
}
#end_block

#method_before
@Override
public void init(final T model) {
    // Let the parent do its work
    super.init(model);
    // Listen to Properties
    model.getPropertyChangedEvent().addListener((ev, sender, args) -> {
        NetworkModel model1 = (NetworkModel) sender;
        String propertyName = args.propertyName;
        if ("Message".equals(propertyName)) {
            // $NON-NLS-1$
            getView().setMessageLabel(model1.getMessage());
        }
    });
    getView().toggleSubnetVisibility(model.getExport().getEntity());
    model.getExport().getEntityChangedEvent().addListener((ev, sender, args) -> getView().toggleSubnetVisibility(model.getExport().getEntity()));
    getView().toggleProfilesVisibility(model.getProfiles().getIsAvailable());
    model.getProfiles().getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if ("IsAvailable".equals(args.propertyName)) {
            // $NON-NLS-1$
            getView().toggleProfilesVisibility(model.getProfiles().getIsAvailable());
        }
    });
    getView().getQosButton().setCommand(model.getAddQosCommand());
    getView().getQosButton().addClickHandler(event -> getView().getQosButton().getCommand().execute());
    getView().addMtuEditor();
}
#method_after
@Override
public void init(final T model) {
    // Let the parent do its work
    super.init(model);
    // Listen to Properties
    model.getPropertyChangedEvent().addListener((ev, sender, args) -> {
        NetworkModel senderModel = (NetworkModel) sender;
        String propertyName = args.propertyName;
        if ("Message".equals(propertyName)) {
            // $NON-NLS-1$
            getView().setMessageLabel(senderModel.getMessage());
        }
    });
    getView().toggleSubnetVisibility(model.getExport().getEntity());
    model.getExport().getEntityChangedEvent().addListener((ev, sender, args) -> getView().toggleSubnetVisibility(model.getExport().getEntity()));
    getView().toggleProfilesVisibility(model.getProfiles().getIsAvailable());
    model.getProfiles().getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if ("IsAvailable".equals(args.propertyName)) {
            // $NON-NLS-1$
            getView().toggleProfilesVisibility(model.getProfiles().getIsAvailable());
        }
    });
    getView().getQosButton().setCommand(model.getAddQosCommand());
    getView().getQosButton().addClickHandler(event -> getView().getQosButton().getCommand().execute());
    getView().addMtuEditor();
}
#end_block

#method_before
private AuditLogableBase createAuditLog(final VmNic iface) {
    AuditLogableBase logable = new AuditLogableBase();
    logable.setVmId(iface.getVmId());
    logable.addCustomValue("MACAddr", iface.getMacAddress());
    logable.addCustomValue("IfaceName", iface.getName());
    return logable;
}
#method_after
private AuditLogableBase createAuditLog(final VmNic iface) {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("MACAddr", iface.getMacAddress());
    logable.addCustomValue("IfaceName", iface.getName());
    return logable;
}
#end_block

#method_before
public VmDevice addSoundDevice(VmBase vmBase) {
    return addSoundDevice(vmBase.getId(), vmBase.getOsId(), clusterUtils.getCompatibilityVersion(vmBase));
}
#method_after
public VmDevice addSoundDevice(VmBase vmBase) {
    return addSoundDevice(vmBase.getId(), vmBase.getOsId(), ClusterUtils.getCompatibilityVersion(vmBase));
}
#end_block

#method_before
private Map<String, Object> getVideoDeviceSpecParams(VmBase vmBase) {
    return videoDeviceSettings.getVideoDeviceSpecParams(vmBase);
}
#method_after
private Map<String, Object> getVideoDeviceSpecParams(VmBase vmBase) {
    return VideoDeviceSettings.getVideoDeviceSpecParams(vmBase);
}
#end_block

#method_before
private void disableSpiceUsb(Guid vmId) {
    removeUsbControllers(vmId);
    removeUsbSlots(vmId);
}
#method_after
private void disableSpiceUsb(Guid vmId) {
    removeUsbControllers(vmId);
    removeUsbSlots(vmId);
    removeUsbChannels(vmId);
}
#end_block

#method_before
@PostConstruct
private void initCache() {
    dashboardCache = cacheContainer.getCache(DASHBOARD);
    inventoryCache = cacheContainer.getCache(INVENTORY);
    dwhAvailable = checkForDWH();
    EngineLocalConfig config = EngineLocalConfig.getInstance();
    boolean enableBackground;
    try {
        enableBackground = config.getBoolean(ENABLE_CACHE_UPDATE_KEY, Boolean.FALSE);
    } catch (IllegalArgumentException e) {
        // $NON-NLS-1$
        log.error("Missing/Invalid key \"{}\", using default value of 'false'", ENABLE_CACHE_UPDATE_KEY, e);
        enableBackground = false;
    }
    if (!enableBackground || !dwhAvailable) {
        // $NON-NLS-1$
        log.info("Dashboard DB query cache has been disabled.");
        return;
    }
    /*
         * Update the utilization cache now and every 5 minutes (by default) thereafter, but never run 2 updates simultaneously.
         */
    try {
        UTILIZATION_CACHE_UPDATE_INTERVAL = config.getLong(UTILIZATION_CACHE_UPDATE_INTERVAL_KEY);
    } catch (IllegalArgumentException e) {
        // $NON-NLS-1$
        log.error("Missing/Invalid key \"{}\", using default value of 300", UTILIZATION_CACHE_UPDATE_INTERVAL_KEY, e);
        UTILIZATION_CACHE_UPDATE_INTERVAL = 300;
    }
    utilizationCacheUpdate = scheduledExecutor.scheduleAtFixedRate(new Runnable() {

        // $NON-NLS-1$
        Logger log = LoggerFactory.getLogger(DashboardDataServlet.class.getName() + ".CacheUpdate.Utilization");

        @Override
        public void run() {
            // $NON-NLS-1$
            log.trace("Attempting to update the Utilization cache");
            try {
                populateUtilizationCache();
            } catch (DashboardDataException e) {
                // $NON-NLS-1$
                log.error("Could not update the Utilization Cache: {}", e.getMessage(), e);
            }
        }
    }, 0, UTILIZATION_CACHE_UPDATE_INTERVAL, TimeUnit.SECONDS);
    // $NON-NLS-1$
    log.info("Dashboard utilization cache updater initialized (update interval {}s)", UTILIZATION_CACHE_UPDATE_INTERVAL);
    /*
         * Update the inventory cache now and every 60 seconds (by default) thereafter, but never run 2 updates simultaneously.
         */
    try {
        INVENTORY_CACHE_UPDATE_INTERVAL = config.getLong(INVENTORY_CACHE_UPDATE_INTERVAL_KEY);
    } catch (IllegalArgumentException e) {
        // $NON-NLS-1$
        log.error("Missing/Invalid key \"{}\", using default value of 60", INVENTORY_CACHE_UPDATE_INTERVAL_KEY, e);
        INVENTORY_CACHE_UPDATE_INTERVAL = 60;
    }
    inventoryCacheUpdate = scheduledExecutor.scheduleAtFixedRate(new Runnable() {

        // $NON-NLS-1$
        Logger log = LoggerFactory.getLogger(DashboardDataServlet.class.getName() + ".CacheUpdate.Inventory");

        @Override
        public void run() {
            // $NON-NLS-1$
            log.trace("Attempting to update the Inventory cache");
            try {
                populateInventoryCache();
            } catch (DashboardDataException e) {
                // $NON-NLS-1$
                log.error("Could not update the Inventory Cache: {}", e.getMessage(), e);
            }
        }
    }, 0, INVENTORY_CACHE_UPDATE_INTERVAL, TimeUnit.SECONDS);
    // $NON-NLS-1$
    log.info("Dashboard inventory cache updater initialized (update interval {}s)", INVENTORY_CACHE_UPDATE_INTERVAL);
}
#method_after
@PostConstruct
private void initCache() {
    dashboardCache = cacheContainer.getCache(DASHBOARD);
    inventoryCache = cacheContainer.getCache(INVENTORY);
    dwhAvailable = checkDwhConfigInEngine() && checkDwhDataSource();
    EngineLocalConfig config = EngineLocalConfig.getInstance();
    try {
        enableBackgroundCacheUpdate = config.getBoolean(ENABLE_CACHE_UPDATE_KEY, Boolean.FALSE);
    } catch (IllegalArgumentException e) {
        // $NON-NLS-1$
        log.error("Missing/Invalid key \"{}\", using default value of 'false'", ENABLE_CACHE_UPDATE_KEY, e);
        enableBackgroundCacheUpdate = false;
    }
    if (!enableBackgroundCacheUpdate || !dwhAvailable) {
        // $NON-NLS-1$
        log.info("Dashboard DB query cache has been disabled.");
        return;
    }
    /*
         * Update the utilization cache now and every 5 minutes (by default) thereafter, but never run 2 updates simultaneously.
         */
    try {
        UTILIZATION_CACHE_UPDATE_INTERVAL = config.getLong(UTILIZATION_CACHE_UPDATE_INTERVAL_KEY);
    } catch (IllegalArgumentException e) {
        // $NON-NLS-1$
        log.error("Missing/Invalid key \"{}\", using default value of 300", UTILIZATION_CACHE_UPDATE_INTERVAL_KEY, e);
        UTILIZATION_CACHE_UPDATE_INTERVAL = 300;
    }
    utilizationCacheUpdate = scheduledExecutor.scheduleWithFixedDelay(new Runnable() {

        // $NON-NLS-1$
        Logger log = LoggerFactory.getLogger(DashboardDataServlet.class.getName() + ".CacheUpdate.Utilization");

        @Override
        public void run() {
            // $NON-NLS-1$
            log.trace("Attempting to update the Utilization cache");
            try {
                populateUtilizationCache();
            } catch (DashboardDataException e) {
                // $NON-NLS-1$
                log.error("Could not update the Utilization Cache: {}", e.getMessage(), e);
            }
        }
    }, 0, UTILIZATION_CACHE_UPDATE_INTERVAL, TimeUnit.SECONDS);
    // $NON-NLS-1$
    log.info("Dashboard utilization cache updater initialized (update interval {}s)", UTILIZATION_CACHE_UPDATE_INTERVAL);
    /*
         * Update the inventory cache now and every 60 seconds (by default) thereafter, but never run 2 updates simultaneously.
         */
    try {
        INVENTORY_CACHE_UPDATE_INTERVAL = config.getLong(INVENTORY_CACHE_UPDATE_INTERVAL_KEY);
    } catch (IllegalArgumentException e) {
        // $NON-NLS-1$
        log.error("Missing/Invalid key \"{}\", using default value of 60", INVENTORY_CACHE_UPDATE_INTERVAL_KEY, e);
        INVENTORY_CACHE_UPDATE_INTERVAL = 60;
    }
    inventoryCacheUpdate = scheduledExecutor.scheduleWithFixedDelay(new Runnable() {

        // $NON-NLS-1$
        Logger log = LoggerFactory.getLogger(DashboardDataServlet.class.getName() + ".CacheUpdate.Inventory");

        @Override
        public void run() {
            // $NON-NLS-1$
            log.trace("Attempting to update the Inventory cache");
            try {
                populateInventoryCache();
            } catch (DashboardDataException e) {
                // $NON-NLS-1$
                log.error("Could not update the Inventory Cache: {}", e.getMessage(), e);
            }
        }
    }, 0, INVENTORY_CACHE_UPDATE_INTERVAL, TimeUnit.SECONDS);
    // $NON-NLS-1$
    log.info("Dashboard inventory cache updater initialized (update interval {}s)", INVENTORY_CACHE_UPDATE_INTERVAL);
}
#end_block

#method_before
private Dashboard populateUtilizationCache() throws DashboardDataException {
    long startTime = System.currentTimeMillis();
    Dashboard dashboard = getDashboard();
    long endTime = System.currentTimeMillis();
    // Put the data in the cache for a default of 5 minutes, after 5 minutes it is evicted and the next
    // request will populate it again.
    dashboardCache.put(UTILIZATION_KEY, dashboard, UTILIZATION_CACHE_UPDATE_INTERVAL, TimeUnit.SECONDS);
    // $NON-NLS-1$
    log.debug("Dashboard utilization cache updated in {}ms", endTime - startTime);
    return dashboard;
}
#method_after
private Dashboard populateUtilizationCache() throws DashboardDataException {
    long startTime = System.currentTimeMillis();
    Dashboard dashboard = getDashboard();
    long endTime = System.currentTimeMillis();
    if (enableBackgroundCacheUpdate) {
        dashboardCache.put(UTILIZATION_KEY, dashboard);
    } else {
        dashboardCache.put(UTILIZATION_KEY, dashboard, UTILIZATION_CACHE_UPDATE_INTERVAL, TimeUnit.SECONDS);
    }
    // $NON-NLS-1$
    log.debug("Dashboard utilization cache updated in {}ms", endTime - startTime);
    return dashboard;
}
#end_block

#method_before
private Inventory populateInventoryCache() throws DashboardDataException {
    long startTime = System.currentTimeMillis();
    Inventory inventory = lookupInventory();
    long endTime = System.currentTimeMillis();
    // Put the inventory in the cache for a default of 60 seconds, after 60 seconds it is evicted and the
    // next request will populate it again.
    inventoryCache.put(INVENTORY_KEY, inventory, INVENTORY_CACHE_UPDATE_INTERVAL, TimeUnit.SECONDS);
    // $NON-NLS-1$
    log.debug("Dashboard inventoy cache updated in {}ms", endTime - startTime);
    return inventory;
}
#method_after
private Inventory populateInventoryCache() throws DashboardDataException {
    long startTime = System.currentTimeMillis();
    Inventory inventory = lookupInventory();
    long endTime = System.currentTimeMillis();
    if (enableBackgroundCacheUpdate) {
        inventoryCache.put(INVENTORY_KEY, inventory);
    } else {
        inventoryCache.put(INVENTORY_KEY, inventory, INVENTORY_CACHE_UPDATE_INTERVAL, TimeUnit.SECONDS);
    }
    // $NON-NLS-1$
    log.debug("Dashboard inventoy cache updated in {}ms", endTime - startTime);
    return inventory;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public void execute(JobExecutionContext context) throws JobExecutionException {
    String methodName = null;
    try {
        JobDataMap data = context.getJobDetail().getJobDataMap();
        Map paramsMap = data.getWrappedMap();
        methodName = (String) paramsMap.get(SchedulerUtilBaseImpl.RUN_METHOD_NAME);
        final Object instance = getInstanceToRun(paramsMap);
        final Object[] methodParams = (Object[]) paramsMap.get(SchedulerUtilBaseImpl.RUN_METHOD_PARAM);
        String methodKey = getMethodKey(instance.getClass().getName(), methodName);
        final Method methodToRun;
        if (!cachedMethods.containsKey(methodKey)) {
            cachedMethods.putIfAbsent(methodKey, getMethodToRun(instance, methodName));
        }
        methodToRun = cachedMethods.get(methodKey);
        String correlationId = LoggedUtils.getObjectId(this);
        CorrelationIdTracker.setCorrelationId(correlationId);
        invokeMethod(instance, methodToRun, methodParams);
        CorrelationIdTracker.setCorrelationId(null);
    } catch (Exception e) {
        log.error("Failed to invoke scheduled method {}: {}", methodName, e.getMessage());
        log.debug("Exception", e);
        JobExecutionException jee = new JobExecutionException("failed to execute job");
        jee.setStackTrace(e.getStackTrace());
        throw jee;
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public void execute(JobExecutionContext context) throws JobExecutionException {
    String methodName = null;
    try {
        JobDataMap data = context.getJobDetail().getJobDataMap();
        Map paramsMap = data.getWrappedMap();
        methodName = (String) paramsMap.get(SchedulerUtilBaseImpl.RUN_METHOD_NAME);
        final Object instance = getInstanceToRun(paramsMap);
        final Object[] methodParams = (Object[]) paramsMap.get(SchedulerUtilBaseImpl.RUN_METHOD_PARAM);
        String methodKey = getMethodKey(instance.getClass().getName(), methodName);
        final Method methodToRun;
        if (!cachedMethods.containsKey(methodKey)) {
            cachedMethods.putIfAbsent(methodKey, getMethodToRun(instance, methodName));
        }
        methodToRun = cachedMethods.get(methodKey);
        String correlationId = LoggedUtils.getObjectId(this);
        CorrelationIdTracker.setCorrelationId(correlationId);
        invokeMethod(instance, methodToRun, methodParams);
    } catch (Exception e) {
        log.error("Failed to invoke scheduled method {}: {}", methodName, e.getMessage());
        log.debug("Exception", e);
        JobExecutionException jee = new JobExecutionException("failed to execute job");
        jee.setStackTrace(e.getStackTrace());
        throw jee;
    } finally {
        CorrelationIdTracker.setCorrelationId(null);
    }
}
#end_block

#method_before
private DbUser buildUser(T params, String authzName) {
    DbUser dbUser = dbUserDao.getByExternalId(authzName, params.getPrincipalId());
    DbUser user = new DbUser(dbUser);
    user.setId(dbUser == null ? Guid.newGuid() : dbUser.getId());
    user.setExternalId(params.getPrincipalId());
    user.setDomain(authzName);
    user.setEmail(params.getEmail());
    user.setFirstName(params.getFirstName());
    user.setLastName(params.getLastName());
    user.setNamespace(params.getNamespace());
    user.setLoginName(params.getPrincipalName());
    List<Guid> groupIds = new ArrayList<>();
    List<String> groupRecordIds = new ArrayList<>();
    Collection<ExtMap> externalGroups = (Collection<ExtMap>) params.getGroupIds();
    flatGroups(externalGroups, groupRecordIds);
    for (String groupId : groupRecordIds) {
        DbGroup dbGroup = dbGroupDao.getByExternalId(authzName, groupId);
        if (dbGroup != null) {
            for (ExtMap group : externalGroups) {
                if (group.<String>get(Authz.GroupRecord.ID).equals(groupId)) {
                    dbGroup.setName(group.<String>get(Authz.GroupRecord.NAME));
                    dbGroupDao.update(dbGroup);
                }
            }
            groupIds.add(dbGroup.getId());
        }
    }
    user.setGroupIds(groupIds);
    user.setAdmin(!roleDao.getAnyAdminRoleForUserAndGroups(user.getId(), StringUtils.join(user.getGroupIds(), ",")).isEmpty());
    if (dbUser == null) {
        dbUserDao.save(user);
    } else if (!dbUser.equals(user)) {
        dbUserDao.update(user);
    }
    return user;
}
#method_after
private DbUser buildUser(T params, String authzName) {
    DbUser dbUser = dbUserDao.getByExternalId(authzName, params.getPrincipalId());
    DbUser user = new DbUser(dbUser);
    user.setId(dbUser == null ? Guid.newGuid() : dbUser.getId());
    user.setExternalId(params.getPrincipalId());
    user.setDomain(authzName);
    user.setEmail(params.getEmail());
    user.setFirstName(params.getFirstName());
    user.setLastName(params.getLastName());
    user.setNamespace(params.getNamespace());
    user.setLoginName(params.getPrincipalName());
    List<Guid> groupIds = new ArrayList<>();
    Map<String, ExtMap> groupRecords = new HashMap<>();
    flatGroups((Collection<ExtMap>) params.getGroupIds(), groupRecords);
    for (Map.Entry<String, ExtMap> group : groupRecords.entrySet()) {
        DbGroup dbGroup = dbGroupDao.getByExternalId(authzName, group.getKey());
        if (dbGroup != null) {
            dbGroup.setName(group.getValue().get(Authz.GroupRecord.NAME));
            dbGroupDao.update(dbGroup);
            groupIds.add(dbGroup.getId());
        }
    }
    user.setGroupIds(groupIds);
    user.setAdmin(!roleDao.getAnyAdminRoleForUserAndGroups(user.getId(), StringUtils.join(user.getGroupIds(), ",")).isEmpty());
    if (dbUser == null) {
        dbUserDao.save(user);
    } else if (!dbUser.equals(user)) {
        dbUserDao.update(user);
    }
    return user;
}
#end_block

#method_before
private static void flatGroups(ExtMap entity, ExtKey key, List<String> accumulator) {
    for (ExtMap group : entity.<Collection<ExtMap>>get(key, Collections.<ExtMap>emptyList())) {
        if (!accumulator.contains(group.<String>get(Authz.GroupRecord.ID))) {
            accumulator.add(group.get(Authz.GroupRecord.ID));
            flatGroups(group, Authz.GroupRecord.GROUPS, accumulator);
        }
    }
}
#method_after
private static void flatGroups(Collection<ExtMap> groupIds, Map<String, ExtMap> accumulator) {
    for (ExtMap group : groupIds) {
        if (!accumulator.containsKey(group.<String>get(Authz.GroupRecord.ID))) {
            accumulator.put(group.<String>get(Authz.GroupRecord.ID), group);
            flatGroups(group, Authz.GroupRecord.GROUPS, accumulator);
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    auditLogDirector.log(this, AuditLogType.USER_REGISTER_DISK_INITIATE);
    setQcowCompat();
    TransactionSupport.executeInNewTransaction(() -> {
        if (getDiskImage().getDiskStorageType() == DiskStorageType.IMAGE) {
            final DiskImage newDiskImage = getDiskImage();
            newDiskImage.setDiskAlias(ImagesHandler.getDiskAliasWithDefault(newDiskImage, generateDefaultAliasForRegiteredDisk(Calendar.getInstance())));
            ArrayList<Guid> storageIds = new ArrayList<>();
            storageIds.add(getParameters().getStorageDomainId());
            newDiskImage.setStorageIds(storageIds);
            addDiskImageToDb(newDiskImage, getCompensationContext(), Boolean.TRUE);
            unregisteredDisksDao.removeUnregisteredDisk(newDiskImage.getId(), null);
            getReturnValue().setActionReturnValue(newDiskImage.getId());
            getReturnValue().setSucceeded(true);
        } else if (getDiskImage().getDiskStorageType() == DiskStorageType.CINDER) {
            VdcReturnValueBase returnValue = runInternalAction(VdcActionType.RegisterCinderDisk, new RegisterCinderDiskParameters((CinderDisk) getDiskImage(), getParameters().getStorageDomainId()));
            setReturnValue(returnValue);
        }
        return null;
    });
}
#method_after
@Override
protected void executeCommand() {
    TransactionSupport.executeInNewTransaction(() -> {
        if (getDiskImage().getDiskStorageType() == DiskStorageType.IMAGE) {
            final DiskImage newDiskImage = getDiskImage();
            newDiskImage.setDiskAlias(ImagesHandler.getDiskAliasWithDefault(newDiskImage, generateDefaultAliasForRegiteredDisk(Calendar.getInstance())));
            addRegisterInitatedAuditLog();
            ArrayList<Guid> storageIds = new ArrayList<>();
            storageIds.add(getParameters().getStorageDomainId());
            newDiskImage.setStorageIds(storageIds);
            addDiskImageToDb(newDiskImage, getCompensationContext(), Boolean.TRUE);
            unregisteredDisksDao.removeUnregisteredDisk(newDiskImage.getId(), null);
            getReturnValue().setActionReturnValue(newDiskImage.getId());
            getReturnValue().setSucceeded(true);
        } else if (getDiskImage().getDiskStorageType() == DiskStorageType.CINDER) {
            VdcReturnValueBase returnValue = runInternalAction(VdcActionType.RegisterCinderDisk, new RegisterCinderDiskParameters((CinderDisk) getDiskImage(), getParameters().getStorageDomainId()));
            setReturnValue(returnValue);
        }
        return null;
    });
    fetchQcowCompat();
}
#end_block

#method_before
private void onExecute() {
    if (getProgress() != null) {
        return;
    }
    startProgress();
    for (DiskModel item : getDisks()) {
        DiskImage disk = (DiskImage) item.getDisk();
        if (item.getQuota().getSelectedItem() != null) {
            disk.setQuotaId(item.getQuota().getSelectedItem().getId());
        }
        List<VdcActionParametersBase> parameters = new ArrayList<>();
        RegisterDiskParameters registerDiskParams = new RegisterDiskParameters(disk, disk.getStorageIds().get(0));
        registerDiskParams.setRefreshFromStorage(true);
        parameters.add(registerDiskParams);
        Frontend.getInstance().runMultipleAction(VdcActionType.RegisterDisk, parameters);
    }
    stopProgress();
    getCancelCommand().execute();
}
#method_after
private void onExecute() {
    if (getProgress() != null) {
        return;
    }
    startProgress();
    for (DiskModel item : getDisks()) {
        DiskImage disk = (DiskImage) item.getDisk();
        if (item.getQuota().getSelectedItem() != null) {
            disk.setQuotaId(item.getQuota().getSelectedItem().getId());
        }
        RegisterDiskParameters registerDiskParams = new RegisterDiskParameters(disk, disk.getStorageIds().get(0));
        registerDiskParams.setRefreshFromStorage(true);
        Frontend.getInstance().runMultipleAction(VdcActionType.RegisterDisk, Arrays.asList(registerDiskParams));
    }
    stopProgress();
    getCancelCommand().execute();
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    Guid storagePoolId = getParameters().getStoragePoolId();
    Guid storageDomainId = getParameters().getStorageDomainId();
    Guid diskId = getParameters().getDiskId();
    StorageDomain storageDomain = storageDomainDao.get(storageDomainId);
    if (storageDomain == null) {
        getQueryReturnValue().setExceptionString(EngineMessage.STORAGE_DOMAIN_DOES_NOT_EXIST.toString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    if (storageDomain.getStorageType().isCinderDomain()) {
        VdcQueryReturnValue returnValue = runInternalQuery(VdcQueryType.GetUnregisteredCinderDiskByIdAndStorageDomainId, new GetCinderEntityByStorageDomainIdParameters(diskId, getParameters().getStorageDomainId()));
        setReturnValue(returnValue.getReturnValue());
        return;
    }
    // Now get the list of volumes for each new image.
    StoragePoolDomainAndGroupIdBaseVDSCommandParameters getVolumesParameters = new StoragePoolDomainAndGroupIdBaseVDSCommandParameters(storagePoolId, storageDomainId, diskId);
    VDSReturnValue volumesListReturn = runVdsCommand(VDSCommandType.GetVolumesList, getVolumesParameters);
    if (!volumesListReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(volumesListReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    @SuppressWarnings("unchecked")
    List<Guid> volumesList = (List<Guid>) volumesListReturn.getReturnValue();
    // image. If there are multiple volumes, skip the image and move on to the next.
    if (volumesList.size() != 1) {
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    Guid volumeId = volumesList.get(0);
    // Get the information about the volume from VDSM.
    GetImageInfoVDSCommandParameters imageInfoParameters = new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskId, volumeId);
    VDSReturnValue imageInfoReturn = runVdsCommand(VDSCommandType.GetImageInfo, imageInfoParameters);
    if (!imageInfoReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(imageInfoReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    DiskImage newDiskImage = (DiskImage) imageInfoReturn.getReturnValue();
    if (StringUtils.isNotEmpty(newDiskImage.getDescription())) {
        try {
            MetadataDiskDescriptionHandler.getInstance().enrichDiskByJsonDescription(newDiskImage.getDescription(), newDiskImage);
        } catch (IOException | DecoderException e) {
            log.warn("Exception while parsing JSON for disk. Exception: '{}'", e);
        }
    }
    if (!setQcowCompat(storagePoolId, storageDomainId, diskId, volumeId, newDiskImage)) {
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    newDiskImage.setStoragePoolId(storagePoolId);
    getQueryReturnValue().setReturnValue(newDiskImage);
    getQueryReturnValue().setSucceeded(true);
}
#method_after
@Override
protected void executeQueryCommand() {
    Guid storagePoolId = getParameters().getStoragePoolId();
    Guid storageDomainId = getParameters().getStorageDomainId();
    Guid diskId = getParameters().getDiskId();
    StorageDomain storageDomain = storageDomainDao.get(storageDomainId);
    if (storageDomain == null) {
        getQueryReturnValue().setExceptionString(EngineMessage.STORAGE_DOMAIN_DOES_NOT_EXIST.toString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    if (storageDomain.getStorageType().isCinderDomain()) {
        VdcQueryReturnValue returnValue = runInternalQuery(VdcQueryType.GetUnregisteredCinderDiskByIdAndStorageDomainId, new GetCinderEntityByStorageDomainIdParameters(diskId, getParameters().getStorageDomainId()));
        setReturnValue(returnValue.getReturnValue());
        return;
    }
    // Now get the list of volumes for each new image.
    StoragePoolDomainAndGroupIdBaseVDSCommandParameters getVolumesParameters = new StoragePoolDomainAndGroupIdBaseVDSCommandParameters(storagePoolId, storageDomainId, diskId);
    VDSReturnValue volumesListReturn = runVdsCommand(VDSCommandType.GetVolumesList, getVolumesParameters);
    if (!volumesListReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(volumesListReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    @SuppressWarnings("unchecked")
    List<Guid> volumesList = (List<Guid>) volumesListReturn.getReturnValue();
    // image. If there are multiple volumes, skip the image and move on to the next.
    if (volumesList.size() != 1) {
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    Guid volumeId = volumesList.get(0);
    // Get the information about the volume from VDSM.
    GetImageInfoVDSCommandParameters imageInfoParameters = new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskId, volumeId);
    VDSReturnValue imageInfoReturn = runVdsCommand(VDSCommandType.GetImageInfo, imageInfoParameters);
    if (!imageInfoReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(imageInfoReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    DiskImage newDiskImage = (DiskImage) imageInfoReturn.getReturnValue();
    if (!fetchQcowCompat(storagePoolId, storageDomainId, diskId, volumeId, newDiskImage)) {
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    if (StringUtils.isNotEmpty(newDiskImage.getDescription())) {
        try {
            MetadataDiskDescriptionHandler.getInstance().enrichDiskByJsonDescription(newDiskImage.getDescription(), newDiskImage);
        } catch (IOException | DecoderException e) {
            log.warn("Exception while parsing JSON for disk. Exception: '{}'", e);
        }
    }
    newDiskImage.setStoragePoolId(storagePoolId);
    getQueryReturnValue().setReturnValue(newDiskImage);
    getQueryReturnValue().setSucceeded(true);
}
#end_block

#method_before
/*
     * USB slot
     */
public void updateUsbSlots(VmBase oldVm, VmBase newVm) {
    final int oldNumberOfSlots = getUsbSlots(oldVm.getId()).size();
    final int newNumberOfUsbSlots = Config.<Integer>getValue(ConfigValues.NumberOfUSBSlots);
    if (!requiresSpiceUsb(oldVm) && requiresSpiceUsb(newVm)) {
        disableNormalUsb(newVm.getId());
        enableSpiceUsb(newVm.getId(), newNumberOfUsbSlots);
        return;
    }
    if (requiresSpiceUsb(oldVm) && requiresSpiceUsb(newVm)) {
        updateSpiceUsb(newVm.getId(), oldNumberOfSlots, newNumberOfUsbSlots);
        return;
    }
    if (requiresSpiceUsb(oldVm) && !requiresSpiceUsb(newVm)) {
        disableSpiceUsb(newVm.getId());
        enableNormalUsb(newVm);
        return;
    }
    if (!requiresSpiceUsb(oldVm) && !requiresSpiceUsb(newVm)) {
        updateNormalUsb(newVm);
        return;
    }
    throw new RuntimeException(format("Unexpected state: oldUsbPolicy=%s, oldGraphicsDevices=%s, newUsbPolicy=%s, newGraphicsDevices=%s", oldVm.getUsbPolicy(), getGraphicsDevices(oldVm.getId()), newVm.getUsbPolicy(), getGraphicsDevices(newVm.getId())));
}
#method_after
/*
     * USB slot
     */
public void updateUsbSlots(VmBase oldVm, VmBase newVm) {
    final UsbPolicy oldUsbPolicy = oldVm.getUsbPolicy();
    final UsbPolicy newUsbPolicy = newVm.getUsbPolicy();
    final int oldNumberOfSlots = getUsbSlots(oldVm.getId()).size();
    final int newNumberOfUsbSlots = Config.<Integer>getValue(ConfigValues.NumberOfUSBSlots);
    if (UsbPolicy.DISABLED == oldUsbPolicy && UsbPolicy.ENABLED_NATIVE == newUsbPolicy) {
        disableNormalUsb(newVm.getId());
        enableSpiceUsb(newVm.getId(), newNumberOfUsbSlots);
        return;
    }
    if (UsbPolicy.ENABLED_NATIVE == oldUsbPolicy && UsbPolicy.ENABLED_NATIVE == newUsbPolicy) {
        updateSpiceUsb(newVm.getId(), oldNumberOfSlots, newNumberOfUsbSlots);
        return;
    }
    if (UsbPolicy.ENABLED_NATIVE == oldUsbPolicy && UsbPolicy.DISABLED == newUsbPolicy) {
        disableSpiceUsb(newVm.getId());
        enableNormalUsb(newVm);
        return;
    }
    if (UsbPolicy.DISABLED == oldUsbPolicy && UsbPolicy.DISABLED == newUsbPolicy) {
        updateNormalUsb(newVm);
        return;
    }
    throw new RuntimeException(format("Unexpected state: oldUsbPolicy=%s, newUsbPolicy=%s", oldUsbPolicy, newUsbPolicy));
}
#end_block

#method_before
private void disableSpiceUsb(Guid vmId) {
    removeUsbControllers(vmId);
    removeUsbSlots(vmId);
}
#method_after
private void disableSpiceUsb(Guid vmId) {
    removeUsbControllers(vmId);
    removeUsbSlots(vmId);
    removeUsbChannels(vmId);
}
#end_block

#method_before
public UICommand getAssignTagsCommand() {
    return privateAssignTagsCommand;
}
#method_after
@Override
public UICommand getAssignTagsCommand() {
    return privateAssignTagsCommand;
}
#end_block

#method_before
public void postOnAssignTags(Map<Guid, Boolean> attachedTags) {
    TagListModel model = (TagListModel) getWindow();
    ArrayList<Guid> vmIds = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        vmIds.add(vm.getId());
    }
    // prepare attach/detach lists
    ArrayList<Guid> tagsToAttach = new ArrayList<>();
    ArrayList<Guid> tagsToDetach = new ArrayList<>();
    if (model.getItems() != null && model.getItems().size() > 0) {
        ArrayList<TagModel> tags = (ArrayList<TagModel>) model.getItems();
        TagModel rootTag = tags.get(0);
        TagModel.recursiveEditAttachDetachLists(rootTag, attachedTags, tagsToAttach, tagsToDetach);
    }
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    for (Guid a : tagsToAttach) {
        parameters.add(new AttachEntityToTagParameters(a, vmIds));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.AttachVmsToTag, parameters);
    parameters = new ArrayList<>();
    for (Guid a : tagsToDetach) {
        parameters.add(new AttachEntityToTagParameters(a, vmIds));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.DetachVmFromTag, parameters);
    cancel();
}
#method_after
@Override
public void postOnAssignTags(Map<Guid, Boolean> attachedTags) {
    TagListModel model = (TagListModel) getWindow();
    ArrayList<Guid> vmIds = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        vmIds.add(vm.getId());
    }
    // prepare attach/detach lists
    ArrayList<Guid> tagsToAttach = new ArrayList<>();
    ArrayList<Guid> tagsToDetach = new ArrayList<>();
    if (model.getItems() != null && model.getItems().size() > 0) {
        ArrayList<TagModel> tags = (ArrayList<TagModel>) model.getItems();
        TagModel rootTag = tags.get(0);
        TagModel.recursiveEditAttachDetachLists(rootTag, attachedTags, tagsToAttach, tagsToDetach);
    }
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    for (Guid a : tagsToAttach) {
        parameters.add(new AttachEntityToTagParameters(a, vmIds));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.AttachVmsToTag, parameters);
    parameters = new ArrayList<>();
    for (Guid a : tagsToDetach) {
        parameters.add(new AttachEntityToTagParameters(a, vmIds));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.DetachVmFromTag, parameters);
    cancel();
}
#end_block

#method_before
private void changeCD() {
    final VM vm = getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = new ArrayList<>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrNull(images1));
    AsyncDataProvider.getInstance().getIrsImageList(new AsyncQuery<>(new AsyncCallback<List<String>>() {

        @Override
        public void onSuccess(List<String> images) {
            AttachCdModel _attachCdModel = (AttachCdModel) getWindow();
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                String selectedIso = Linq.firstOrNull(images, new Linq.IPredicate<String>() {

                    @Override
                    public boolean match(String s) {
                        return vm.getCurrentCd() != null && vm.getCurrentCd().equals(s);
                    }
                });
                _attachCdModel.getIsoImage().setSelectedItem(selectedIso == null ? ConsoleModel.getEjectLabel() : selectedIso);
            }
        }
    }), vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnChangeCD", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#method_after
private void changeCD() {
    final VM vm = getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = new ArrayList<>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrNull(images1));
    AsyncDataProvider.getInstance().getIrsImageList(new AsyncQuery<>(new AsyncCallback<List<String>>() {

        @Override
        public void onSuccess(List<String> images) {
            AttachCdModel _attachCdModel = (AttachCdModel) getWindow();
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                String selectedIso = Linq.firstOrNull(images, s -> vm.getCurrentCd() != null && vm.getCurrentCd().equals(s));
                _attachCdModel.getIsoImage().setSelectedItem(selectedIso == null ? ConsoleModel.getEjectLabel() : selectedIso);
            }
        }
    }), vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnChangeCD", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void changeCD() {
    UserPortalItemModel selectedItem = getSelectedItem();
    if (selectedItem == null || selectedItem.getEntity() == null) {
        return;
    }
    final VM vm = (VM) selectedItem.getEntity();
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    ArrayList<String> defaultImages = new ArrayList<>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    model.getIsoImage().setItems(defaultImages);
    model.getIsoImage().setSelectedItem(Linq.firstOrNull(defaultImages));
    AsyncQuery<List<String>> getImagesQuery = new AsyncQuery<>(new AsyncCallback<List<String>>() {

        @Override
        public void onSuccess(List<String> images) {
            AttachCdModel _attachCdModel = (AttachCdModel) getWindow();
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                String selectedIso = Linq.firstOrNull(images, new Linq.IPredicate<String>() {

                    @Override
                    public boolean match(String s) {
                        return vm.getCurrentCd().equals(s);
                    }
                });
                _attachCdModel.getIsoImage().setSelectedItem(selectedIso == null ? ConsoleModel.getEjectLabel() : selectedIso);
            }
        }
    });
    AsyncDataProvider.getInstance().getIrsImageList(getImagesQuery, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnChangeCD", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#method_after
private void changeCD() {
    UserPortalItemModel selectedItem = getSelectedItem();
    if (selectedItem == null || selectedItem.getEntity() == null) {
        return;
    }
    final VM vm = (VM) selectedItem.getEntity();
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    ArrayList<String> defaultImages = new ArrayList<>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    model.getIsoImage().setItems(defaultImages);
    model.getIsoImage().setSelectedItem(Linq.firstOrNull(defaultImages));
    AsyncQuery<List<String>> getImagesQuery = new AsyncQuery<>(new AsyncCallback<List<String>>() {

        @Override
        public void onSuccess(List<String> images) {
            AttachCdModel _attachCdModel = (AttachCdModel) getWindow();
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                String selectedIso = Linq.firstOrDefault(images, s -> vm.getCurrentCd().equals(s), ConsoleModel.getEjectLabel());
                _attachCdModel.getIsoImage().setSelectedItem(selectedIso);
            }
        }
    });
    AsyncDataProvider.getInstance().getIrsImageList(getImagesQuery, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnChangeCD", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmHandler.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion().toString()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!getParameters().getVmStaticData().isAutoStartup()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED_WITH_HA_OFF);
        }
        if (!FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED);
        }
        if (!validateLeaseStorageDomain(getParameters().getVmStaticData().getLeaseStorageDomainId())) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmHandler.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!getParameters().getVmStaticData().isAutoStartup()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED_WITH_HA_OFF);
        }
        if (!FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED);
        }
        if (!validateLeaseStorageDomain(getParameters().getVmStaticData().getLeaseStorageDomainId())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private static void updateStepMessage(CommandBase<?> cmd, Guid vdsForExecution) {
    // supposed to contain "vds" place holder.
    try {
        Step step = cmd.getExecutionContext().getStep();
        Map<String, String> jobProperties = cmd.getJobMessageProperties();
        jobProperties.put("vds", getVdsDao().get(vdsForExecution).getName());
        StepEnum stepEnum = StepEnum.valueOf(cmd.getCommandStep().toString() + "_ON_HOST");
        step.setDescription(ExecutionMessageDirector.resolveStepMessage(stepEnum, jobProperties));
        getStepDao().update(step);
    } catch (IllegalArgumentException e) {
    // Ignore this exception and do nothing as no corresponding step_ON_HOST found.
    }
}
#method_after
private static void updateStepMessage(CommandBase<?> cmd, Guid vdsForExecution) {
    // As an HSM job can run on any host, we want to display the host running the job when it is
    // chosen. To do so, we look for a corresponding command step with an "_ON_HOST" suffix that
    // is supposed to contain a "vds" placeholder.
    StepEnum stepEnum = null;
    try {
        stepEnum = StepEnum.valueOf(getStepWithHostname(cmd));
    } catch (IllegalArgumentException e) {
        // Ignore this exception and do nothing as no corresponding step_ON_HOST found.
        log.debug("No StepEnum found for " + getStepWithHostname(cmd));
        return;
    }
    Step step = cmd.getExecutionContext().getStep();
    Map<String, String> jobProperties = cmd.getJobMessageProperties();
    jobProperties.put(VdcObjectType.VDS.name().toLowerCase(), getVdsDao().get(vdsForExecution).getName());
    step.setDescription(ExecutionMessageDirector.resolveStepMessage(stepEnum, jobProperties));
    getStepDao().update(step);
}
#end_block

#method_before
public static int getCdDeviceIndex(String cdInterface) {
    switch(cdInterface) {
        case "scsi":
            return 0;
        case "ide":
            return 2;
        case "sata":
            return 0;
        default:
            return -1;
    }
}
#method_after
public static int getCdDeviceIndex(String cdInterface) {
    switch(cdInterface) {
        case "scsi":
        case "ide":
        case "sata":
            return 2;
        default:
            return -1;
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmHandler.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion().toString()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!getParameters().getVmStaticData().isAutoStartup()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED_WITH_HA_OFF);
        }
        if (!FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED);
        }
        if (!validateLeaseStorageDomain(getParameters().getVmStaticData().getLeaseStorageDomainId())) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmHandler.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!getParameters().getVmStaticData().isAutoStartup()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED_WITH_HA_OFF);
        }
        if (!FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED);
        }
        if (!validateLeaseStorageDomain(getParameters().getVmStaticData().getLeaseStorageDomainId())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected VmDevice getDeviceToHotUnplug() {
    if (deviceToHotUnplug == null) {
        deviceToHotUnplug = computeDeviceToHotUnplug();
    }
    return deviceToHotUnplug;
}
#method_after
protected VmDevice getDeviceToHotUnplug() {
    if (deviceToHotUnplug == null) {
        deviceToHotUnplug = vmDeviceDao.get(new VmDeviceId(getParameters().getDeviceId(), getVmId()));
    }
    return deviceToHotUnplug;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    if (getVm().getStatus() != VMStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NEEDS_TO_BE_UP, ReplacementUtils.createSetVariableString("vmId", getVmId()), ReplacementUtils.createSetVariableString("vmName", getVm().getName()), ReplacementUtils.createSetVariableString("currentVmState", getVm().getStatus()));
    }
    if (getDeviceToHotUnplug() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_MEMORY_DEVICE_NOT_FOUND, ReplacementUtils.createSetVariableString("memorySize", getParameters().getMemorySizeMb()), ReplacementUtils.createSetVariableString("vmId", getVmId()), ReplacementUtils.createSetVariableString("vmName", getVm().getName()));
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    if (!FeatureSupported.hotUnplugMemory(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_UNPLUG_NOT_SUPPORTED_FOR_COMPAT_VERSION_AND_ARCH, ReplacementUtils.createSetVariableString("compatibilityVersion", getVm().getCompatibilityVersion()), ReplacementUtils.createSetVariableString("architecture", getVm().getClusterArch()));
    }
    if (getVm().getStatus() != VMStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_UP);
    }
    if (getDeviceToHotUnplug() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_MEMORY_DEVICE_DOESNT_EXIST, ReplacementUtils.createSetVariableString("deviceId", getParameters().getDeviceId()));
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    addCustomValue(AUDIT_LOG_VAR_VM_NAME, getVmName());
    addCustomValue(AUDIT_LOG_VAR_MEMORY_SIZE_MB, String.valueOf(getParameters().getMemorySizeMb()));
    final VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.HotUnplugMemory, new HotUnplugMemoryVDSCommand.Params(getVm().getRunOnVds(), getDeviceToHotUnplug()));
    if (!vdsReturnValue.getSucceeded()) {
        addCustomValue(AUDIT_LOG_VAR_ERROR_MESSAGE, vdsReturnValue.getVdsError().getMessage());
        setReturnValueFailure(vdsReturnValue);
        return;
    }
    if (getVm().getMemSizeMb() - getParameters().getMemorySizeMb() < getVm().getMinAllocatedMem()) {
        // If memory hot unplug fails on guest with a delay (not in synchronous way when calling
        // HotUnplugMemoryVDSCommand), we can get out of sync between what vm devices are reported and
        // value of getVm().getMemSizeMb(). This `if` branch tries to mitigate such situations.
        setSucceeded(true);
        return;
    }
    updateVm();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    addCustomValue(AUDIT_LOG_VAR_VM_NAME, getVmName());
    addCustomValue(AUDIT_LOG_VAR_MEMORY_SIZE_MB, String.valueOf(getUnpluggedDeviceSize()));
    addCustomValue(AUDIT_LOG_VAR_DEVICE_ID, getParameters().getDeviceId().toString());
    final VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.HotUnplugMemory, new HotUnplugMemoryVDSCommand.Params(getVm().getRunOnVds(), getDeviceToHotUnplug()));
    if (!vdsReturnValue.getSucceeded()) {
        addCustomValue(AUDIT_LOG_VAR_ERROR_MESSAGE, vdsReturnValue.getVdsError().getMessage());
        setReturnValueFailure(vdsReturnValue);
        return;
    }
    if (getVm().getMemSizeMb() - getUnpluggedDeviceSize() >= getVm().getMinAllocatedMem()) {
        /*
             * If memory hot unplug fails on guest with a delay (not in synchronous way when calling
             * HotUnplugMemoryVDSCommand), we can get out of sync between what vm devices are reported and
             * value of getVm().getMemSizeMb(). This `if` branch tries to mitigate such situations. It uses
             * the fact that getVm().getMinAllocatedMem() can't be changed when VM is running.
             * Example:
             * | getVm().getMemorySizeMb() | getVm().getMinAllocatedMem() | real VM memory |
             * +---------------------------+------------------------------+----------------+
             * | 8 GB                      | 8 GB                         | 8 BG           |
             * successful hot plug of 2GB
             * | 10 GB                     | 8 GB                         | 10 BG          |
             * asynchronously unsuccessful hot unplug of 2GB
             * | 8 GB                      | 8 GB                         | 10 BG          |
             * second try to hot unplug 2GB, successful, getVm().getMemorySizeMb() not decrease because
             * of this `if`
             * | 8 GB                      | 8 GB                         | 8 BG           |
             */
        updateVm();
    }
    setSucceeded(true);
}
#end_block

#method_before
private void updateCurrentConfiguration() {
    final VmStatic updatedVmStatic = new VmStatic(getVm().getStaticData());
    updatedVmStatic.setMemSizeMb(updatedVmStatic.getMemSizeMb() - getParameters().getMemorySizeMb());
    vmStaticDao.update(updatedVmStatic);
}
#method_after
private void updateCurrentConfiguration() {
    final VmStatic updatedVmStatic = new VmStatic(getVm().getStaticData());
    updatedVmStatic.setMemSizeMb(updatedVmStatic.getMemSizeMb() - getUnpluggedDeviceSize());
    getVmManager().update(updatedVmStatic);
}
#end_block

#method_before
private void updateNextRunConfiguration() {
    final VmStatic nextRunConfigurationStatic = runInternalQuery(VdcQueryType.GetVmNextRunConfiguration, new IdQueryParameters(getVmId())).<VM>getReturnValue().getStaticData();
    final int newMemorySize = nextRunConfigurationStatic.getMemSizeMb() - getParameters().getMemorySizeMb();
    if (newMemorySize <= 0) {
        return;
    }
    nextRunConfigurationStatic.setMemSizeMb(newMemorySize);
    if (newMemorySize < nextRunConfigurationStatic.getMinAllocatedMem()) {
        nextRunConfigurationStatic.setMinAllocatedMem(newMemorySize);
    }
    vmHandler.createNextRunSnapshot(getVm(), nextRunConfigurationStatic, null, getCompensationContext());
}
#method_after
private void updateNextRunConfiguration() {
    final VmStatic nextRunConfigurationStatic = getNextRunConfiguration();
    if (nextRunConfigurationStatic == null) {
        return;
    }
    final int newMemorySize = nextRunConfigurationStatic.getMemSizeMb() - getUnpluggedDeviceSize();
    if (newMemorySize <= 0) {
        return;
    }
    // Update next run snapshot only if old memory state matches old next run snapshot state
    if (getVm().getMemSizeMb() != nextRunConfigurationStatic.getMemSizeMb()) {
        return;
    }
    nextRunConfigurationStatic.setMemSizeMb(newMemorySize);
    if (newMemorySize < nextRunConfigurationStatic.getMinAllocatedMem()) {
        nextRunConfigurationStatic.setMinAllocatedMem(newMemorySize);
    }
    TransactionSupport.executeInNewTransaction(() -> {
        vmHandler.createNextRunSnapshot(getVm(), nextRunConfigurationStatic, null, getCompensationContext());
        return null;
    });
}
#end_block

#method_before
public void setReturnValueFailure(VDSReturnValue returnValueFailure) {
    setSucceeded(false);
    final EngineFault engineFault = new EngineFault();
    engineFault.setError(returnValueFailure.getVdsError().getCode());
    engineFault.setMessage(returnValueFailure.getVdsError().getMessage());
    getReturnValue().setFault(engineFault);
}
#method_after
public void setReturnValueFailure(VDSReturnValue returnValueFailure) {
    final EngineFault engineFault = new EngineFault();
    engineFault.setError(returnValueFailure.getVdsError().getCode());
    engineFault.setMessage(returnValueFailure.getVdsError().getMessage());
    getReturnValue().setFault(engineFault);
}
#end_block

#method_before
private void initMacPools() {
    setMacPoolListModel(new SortedListModel<>(new Linq.SharedMacPoolComparator()));
    setMacPoolModel(new MacPoolModel());
    getMacPoolModel().setIsChangeable(false);
    getMacPoolListModel().getItemsChangedEvent().addListener(this);
    getMacPoolListModel().getSelectedItemChangedEvent().addListener(this);
    startProgress();
    Frontend.getInstance().runQuery(VdcQueryType.GetAllMacPools, new VdcQueryParametersBase(), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            getMacPoolListModel().setItems((Collection<MacPool>) returnValue.getReturnValue());
            stopProgress();
        }
    }));
}
#method_after
private void initMacPools() {
    setMacPoolListModel(new SortedListModel<>(Linq.SharedMacPoolComparator));
    setMacPoolModel(new MacPoolModel());
    getMacPoolModel().setIsChangeable(false);
    getMacPoolListModel().getItemsChangedEvent().addListener(this);
    getMacPoolListModel().getSelectedItemChangedEvent().addListener(this);
    startProgress();
    Frontend.getInstance().runQuery(VdcQueryType.GetAllMacPools, new VdcQueryParametersBase(), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            getMacPoolListModel().setItems((Collection<MacPool>) returnValue.getReturnValue());
            stopProgress();
        }
    }));
}
#end_block

#method_before
public void initTunedProfiles() {
    this.startProgress();
    if (getVersion() == null || getVersion().getSelectedItem() == null) {
        return;
    }
    Version version = getVersion().getSelectedItem();
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterTunedProfiles, new IdAndNameQueryParameters(null, version.getValue()), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            stopProgress();
            List<String> glusterTunedProfiles = new ArrayList<>();
            if (returnValue.getSucceeded()) {
                glusterTunedProfiles.addAll((List<String>) returnValue.getReturnValue());
            }
            final String oldSelectedProfile = glusterTunedProfile.getSelectedItem();
            glusterTunedProfile.setItems(glusterTunedProfiles);
            glusterTunedProfile.setIsAvailable(glusterTunedProfile.getItems().size() > 0);
            String newSelectedItem = null;
            if (oldSelectedProfile != null) {
                newSelectedItem = Linq.firstOrNull(glusterTunedProfiles, new Linq.EqualsPredicate(oldSelectedProfile));
            }
            if (newSelectedItem != null) {
                glusterTunedProfile.setSelectedItem(newSelectedItem);
            } else if (getIsEdit()) {
                glusterTunedProfile.setSelectedItem(Linq.firstOrNull(glusterTunedProfiles, new Linq.EqualsPredicate(getEntity().getGlusterTunedProfile())));
            }
        }
    }));
}
#method_after
public void initTunedProfiles() {
    this.startProgress();
    if (getVersion() == null || getVersion().getSelectedItem() == null) {
        return;
    }
    Version version = getVersion().getSelectedItem();
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterTunedProfiles, new IdAndNameQueryParameters(null, version.getValue()), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            stopProgress();
            List<String> glusterTunedProfiles = new ArrayList<>();
            if (returnValue.getSucceeded()) {
                glusterTunedProfiles.addAll((List<String>) returnValue.getReturnValue());
            }
            final String oldSelectedProfile = glusterTunedProfile.getSelectedItem();
            glusterTunedProfile.setItems(glusterTunedProfiles);
            glusterTunedProfile.setIsAvailable(glusterTunedProfile.getItems().size() > 0);
            String newSelectedItem = null;
            if (oldSelectedProfile != null) {
                newSelectedItem = Linq.firstOrNull(glusterTunedProfiles, x -> x.equals(oldSelectedProfile));
            }
            if (newSelectedItem != null) {
                glusterTunedProfile.setSelectedItem(newSelectedItem);
            } else if (getIsEdit()) {
                glusterTunedProfile.setSelectedItem(Linq.firstOrNull(glusterTunedProfiles, x -> x.equals(getEntity().getGlusterTunedProfile())));
            }
        }
    }));
}
#end_block

#method_before
private void initImportCluster(boolean isEdit) {
    setGlusterHostAddress(new EntityModel<String>());
    getGlusterHostAddress().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            setIsFingerprintVerified(false);
            if (getGlusterHostAddress().getEntity() == null || getGlusterHostAddress().getEntity().trim().length() == 0) {
                // $NON-NLS-1$
                getGlusterHostFingerprint().setEntity("");
                return;
            }
            fetchFingerprint(getGlusterHostAddress().getEntity(), 22);
        }
    });
    setGlusterHostFingerprint(new EntityModel<String>());
    // $NON-NLS-1$
    getGlusterHostFingerprint().setEntity("");
    setIsFingerprintVerified(false);
    setGlusterHostPassword(new EntityModel<String>());
    setIsImportGlusterConfiguration(new EntityModel<Boolean>());
    getIsImportGlusterConfiguration().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (getIsImportGlusterConfiguration().getEntity() != null && getIsImportGlusterConfiguration().getEntity()) {
                getGlusterHostAddress().setIsChangeable(true);
                getGlusterHostPassword().setIsChangeable(true);
            } else {
                getGlusterHostAddress().setIsChangeable(false);
                getGlusterHostPassword().setIsChangeable(false);
            }
        }
    });
    getIsImportGlusterConfiguration().setIsAvailable(false);
    getGlusterHostAddress().setIsAvailable(false);
    getGlusterHostFingerprint().setIsAvailable(false);
    getGlusterHostPassword().setIsAvailable(false);
    getIsImportGlusterConfiguration().setEntity(false);
}
#method_after
private void initImportCluster(boolean isEdit) {
    setGlusterHostAddress(new EntityModel<String>());
    getGlusterHostAddress().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            setIsFingerprintVerified(false);
            if (getGlusterHostAddress().getEntity() == null || getGlusterHostAddress().getEntity().trim().length() == 0) {
                // $NON-NLS-1$
                getGlusterHostFingerprint().setEntity("");
                return;
            }
            fetchFingerprint(getGlusterHostAddress().getEntity(), VdsStatic.DEFAULT_SSH_PORT);
        }
    });
    setGlusterHostFingerprint(new EntityModel<String>());
    // $NON-NLS-1$
    getGlusterHostFingerprint().setEntity("");
    setIsFingerprintVerified(false);
    setGlusterHostPassword(new EntityModel<String>());
    setIsImportGlusterConfiguration(new EntityModel<Boolean>());
    getIsImportGlusterConfiguration().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (getIsImportGlusterConfiguration().getEntity() != null && getIsImportGlusterConfiguration().getEntity()) {
                getGlusterHostAddress().setIsChangeable(true);
                getGlusterHostPassword().setIsChangeable(true);
            } else {
                getGlusterHostAddress().setIsChangeable(false);
                getGlusterHostPassword().setIsChangeable(false);
            }
        }
    });
    getIsImportGlusterConfiguration().setIsAvailable(false);
    getGlusterHostAddress().setIsAvailable(false);
    getGlusterHostFingerprint().setIsAvailable(false);
    getGlusterHostPassword().setIsAvailable(false);
    getIsImportGlusterConfiguration().setEntity(false);
}
#end_block

#method_before
private void storagePool_SelectedItemChanged(EventArgs e) {
    // possible versions for new cluster (when editing cluster, this event won't occur)
    // are actually the possible versions for the data-center that the cluster is going
    // to be attached to.
    final StoragePool selectedDataCenter = getDataCenter().getSelectedItem();
    if (selectedDataCenter == null) {
        getManagementNetwork().setItems(Collections.<Network>emptyList());
        return;
    }
    if (selectedDataCenter.isLocal()) {
        setMigrationTabAvailable(false);
    } else {
        setMigrationTabAvailable(true);
    }
    AsyncDataProvider.getInstance().getDataCenterVersions(new AsyncQuery<>(new AsyncCallback<List<Version>>() {

        @Override
        public void onSuccess(List<Version> versions) {
            Version versionToSelect = calculateNewVersionWhichShouldBeSelected(versions);
            getVersion().setItems(versions, versionToSelect);
        }

        private Version calculateNewVersionWhichShouldBeSelected(List<Version> versions) {
            ListModel<Version> version = getVersion();
            Version selectedVersion = version.getSelectedItem();
            if (!getIsEdit() && (selectedVersion == null || !versions.contains(selectedVersion) || selectedVersion.compareTo(selectedDataCenter.getCompatibilityVersion()) > 0)) {
                if (ApplicationModeHelper.getUiMode().equals(ApplicationMode.GlusterOnly)) {
                    return Linq.selectHighestVersion(versions);
                } else {
                    return selectedDataCenter.getCompatibilityVersion();
                }
            } else if (getIsEdit()) {
                return Linq.firstOrNull(versions, new Linq.EqualsPredicate(getEntity().getCompatibilityVersion()));
            } else {
                return selectedVersion;
            }
        }
    }), ApplicationModeHelper.getUiMode().equals(ApplicationMode.GlusterOnly) ? null : selectedDataCenter.getId());
    if (getManagementNetwork().getIsChangable()) {
        loadDcNetworks(selectedDataCenter.getId());
    }
}
#method_after
private void storagePool_SelectedItemChanged(EventArgs e) {
    // possible versions for new cluster (when editing cluster, this event won't occur)
    // are actually the possible versions for the data-center that the cluster is going
    // to be attached to.
    final StoragePool selectedDataCenter = getDataCenter().getSelectedItem();
    if (selectedDataCenter == null) {
        getManagementNetwork().setItems(Collections.<Network>emptyList());
        return;
    }
    if (selectedDataCenter.isLocal()) {
        setMigrationTabAvailable(false);
    } else {
        setMigrationTabAvailable(true);
    }
    AsyncDataProvider.getInstance().getDataCenterVersions(new AsyncQuery<>(new AsyncCallback<List<Version>>() {

        @Override
        public void onSuccess(List<Version> versions) {
            Version versionToSelect = calculateNewVersionWhichShouldBeSelected(versions);
            getVersion().setItems(versions, versionToSelect);
        }

        private Version calculateNewVersionWhichShouldBeSelected(List<Version> versions) {
            ListModel<Version> version = getVersion();
            Version selectedVersion = version.getSelectedItem();
            if (!getIsEdit() && (selectedVersion == null || !versions.contains(selectedVersion) || selectedVersion.compareTo(selectedDataCenter.getCompatibilityVersion()) > 0)) {
                if (ApplicationModeHelper.getUiMode().equals(ApplicationMode.GlusterOnly)) {
                    return versions.stream().max(Comparator.naturalOrder()).orElse(null);
                } else {
                    return selectedDataCenter.getCompatibilityVersion();
                }
            } else if (getIsEdit()) {
                return Linq.firstOrNull(versions, x -> x.equals(getEntity().getCompatibilityVersion()));
            } else {
                return selectedVersion;
            }
        }
    }), ApplicationModeHelper.getUiMode().equals(ApplicationMode.GlusterOnly) ? null : selectedDataCenter.getId());
    if (getManagementNetwork().getIsChangable()) {
        loadDcNetworks(selectedDataCenter.getId());
    }
}
#end_block

#method_before
public void getAllProvidersByProvidedEntity(AsyncQuery query, final VdcObjectType providedEntity) {
    query.converterCallback = new Converter<List<Provider>>() {

        @Override
        public List<Provider> convert(Object returnValue) {
            if (returnValue == null) {
                return new ArrayList<>();
            }
            List<Provider> providers = Linq.toList(Linq.filterProvidersByProvidedType((Collection<Provider>) returnValue, providedEntity));
            Collections.sort(providers, new NameableComparator());
            return providers;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(), query);
}
#method_after
public void getAllProvidersByProvidedEntity(AsyncQuery query, final VdcObjectType providedEntity) {
    query.converterCallback = new Converter<List<Provider>>() {

        @Override
        public List<Provider> convert(Object returnValue) {
            if (returnValue == null) {
                return new ArrayList<>();
            }
            return ((Collection<Provider>) returnValue).stream().filter(p -> p.getType().getProvidedTypes().contains(providedEntity)).sorted(new NameableComparator()).collect(Collectors.toList());
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(), query);
}
#end_block

#method_before
@GET
public V3Capabilities list() {
    // Calculate the prefix that should be added to the "href" attributes:
    Current current = CurrentManager.get();
    StringBuilder buffer = new StringBuilder();
    if (current.getVersionSource() == VersionSource.URL) {
        buffer.append("/v");
        buffer.append(current.getVersion());
    }
    buffer.append(current.getPrefix());
    String prefix = buffer.toString();
    // Load the document into a DOM tree:
    Document document;
    try {
        DocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();
        try (InputStream in = this.getClass().getResourceAsStream("/v3/capabilities.xml")) {
            document = parser.parse(in);
        }
    } catch (Exception exception) {
        throw new WebApplicationException(exception, Response.Status.INTERNAL_SERVER_ERROR);
    }
    // Create an XPath engine, we will use it for several things later:
    XPath xpath = XPathFactory.newInstance().newXPath();
    try {
        // Find the 3.6 capabilities and duplicate them for 4.0 and 4.1, as from the point of view of the user of
        // version 3 of the API version 4.0 and 4.1 should be identical to version 3.6:
        Element versionElement = (Element) xpath.evaluate("/capabilities/version[@major='3' and @minor='6']", document, XPathConstants.NODE);
        versionElement = (Element) versionElement.cloneNode(true);
        String versionId = "332e4033-2e40-332e-4033-2e40332e4033";
        versionElement.setAttribute("id", versionId);
        versionElement.setAttribute("href", "/capabilities/" + versionId);
        versionElement.setAttribute("major", "4");
        versionElement.setAttribute("minor", "0");
        // Set the "current" flag of the 4.0 capabilities to "true":
        Element currentElement = (Element) xpath.evaluate("current", versionElement, XPathConstants.NODE);
        currentElement.setTextContent("true");
        // Add the 4.0 capabilities to the end of the document:
        document.getDocumentElement().appendChild(versionElement);
        versionElement = (Element) xpath.evaluate("/capabilities/version[@major='3' and @minor='6']", document, XPathConstants.NODE);
        versionElement = (Element) versionElement.cloneNode(true);
        versionId = "876c3672-1ad3-11e7-b157-507b9dcf131d";
        versionElement.setAttribute("id", versionId);
        versionElement.setAttribute("href", "/capabilities/" + versionId);
        versionElement.setAttribute("major", "4");
        versionElement.setAttribute("minor", "1");
        // Set the "current" flag of the 4.0 capabilities to "true"
        currentElement = (Element) xpath.evaluate("current", versionElement, XPathConstants.NODE);
        currentElement.setTextContent("true");
        // Add the 4.1 capabilities to the end of the document
        document.getDocumentElement().appendChild(versionElement);
    } catch (XPathExpressionException exception) {
        throw new WebApplicationException(exception, Response.Status.INTERNAL_SERVER_ERROR);
    }
    // Modify all the "href" attributes to include the prefix:
    try {
        NodeList nodes = (NodeList) xpath.evaluate("//@href", document, XPathConstants.NODESET);
        for (int i = 0; i < nodes.getLength(); i++) {
            Node node = nodes.item(i);
            String href = node.getNodeValue();
            href = prefix + href;
            node.setNodeValue(href);
        }
    } catch (XPathExpressionException exception) {
        throw new WebApplicationException(exception, Response.Status.INTERNAL_SERVER_ERROR);
    }
    // Create the capabilities object from the DOM tree:
    return JAXB.unmarshal(new DOMSource(document), V3Capabilities.class);
}
#method_after
@GET
public V3Capabilities list() {
    // Calculate the prefix that should be added to the "href" attributes:
    Current current = CurrentManager.get();
    StringBuilder buffer = new StringBuilder();
    if (current.getVersionSource() == VersionSource.URL) {
        buffer.append("/v");
        buffer.append(current.getVersion());
    }
    buffer.append(current.getPrefix());
    String prefix = buffer.toString();
    // Load the document into a DOM tree:
    Document document;
    try {
        DocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();
        try (InputStream in = this.getClass().getResourceAsStream("/v3/capabilities.xml")) {
            document = parser.parse(in);
        }
    } catch (Exception exception) {
        throw new WebApplicationException(exception, Response.Status.INTERNAL_SERVER_ERROR);
    }
    // Create an XPath engine, we will use it for several things later:
    XPath xpath = XPathFactory.newInstance().newXPath();
    try {
        // Find the 3.6 capabilities and duplicate them for 4.0 and 4.1, as from the point of view of the user of
        // version 3 of the API version 4.0 and 4.1 should be identical to version 3.6:
        Element versionElement36 = (Element) xpath.evaluate("/capabilities/version[@major='3' and @minor='6']", document, XPathConstants.NODE);
        // Clone capabilities from 3.6 to 4.0
        Element versionElement40 = cloneCapabilities(versionElement36, 4, 0);
        // Add the 4.0 capabilities to the end of the document:
        document.getDocumentElement().appendChild(versionElement40);
        // Clone capabilities from 3.6 to 4.1
        Element versionElement41 = cloneCapabilities(versionElement36, 4, 1);
        // Set the "current" flag of the 4.1 capabilities to "true"
        Element currentElement = (Element) xpath.evaluate("current", versionElement41, XPathConstants.NODE);
        currentElement.setTextContent("true");
        // Add the 4.1 capabilities to the end of the document
        document.getDocumentElement().appendChild(versionElement41);
    } catch (XPathExpressionException exception) {
        throw new WebApplicationException(exception, Response.Status.INTERNAL_SERVER_ERROR);
    }
    // Modify all the "href" attributes to include the prefix:
    try {
        NodeList nodes = (NodeList) xpath.evaluate("//@href", document, XPathConstants.NODESET);
        for (int i = 0; i < nodes.getLength(); i++) {
            Node node = nodes.item(i);
            String href = node.getNodeValue();
            href = prefix + href;
            node.setNodeValue(href);
        }
    } catch (XPathExpressionException exception) {
        throw new WebApplicationException(exception, Response.Status.INTERNAL_SERVER_ERROR);
    }
    // Create the capabilities object from the DOM tree:
    return JAXB.unmarshal(new DOMSource(document), V3Capabilities.class);
}
#end_block

#method_before
private void populateDiskSnapshotsInfoFromStorage() {
    getDiskImage().getSnapshots().clear();
    List<DiskImage> images = diskImageDao.getAllSnapshotsForImageGroup(getParameters().getImageGroupID());
    for (DiskImage image : images) {
        getDiskImage().getSnapshots().add(ImagesHandler.getVolumeInfoFromVdsm(getParameters().getStoragePoolId(), getParameters().getSrcDomain(), getParameters().getImageGroupID(), image.getImageId()));
    }
}
#method_after
private void populateDiskSnapshotsInfoFromStorage() {
    getDiskImage().getSnapshots().clear();
    List<DiskImage> images = diskImageDao.getAllSnapshotsForImageGroup(getParameters().getImageGroupID());
    for (DiskImage image : images) {
        getDiskImage().getSnapshots().add(imagesHandler.getVolumeInfoFromVdsm(getParameters().getStoragePoolId(), getParameters().getSrcDomain(), getParameters().getImageGroupID(), image.getImageId()));
    }
}
#end_block

#method_before
private void createVolume() {
    populateDiskSnapshotsInfoFromStorage();
    CreateVolumeContainerCommandParameters parameters = new CreateVolumeContainerCommandParameters(getParameters().getStoragePoolId(), getParameters().getDestDomain(), Guid.Empty, Guid.Empty, getParameters().getDestImageGroupId(), getParameters().getDestinationImageId(), getParameters().getDestinationFormat(), getParameters().getDescription(), getDiskImage().getSize(), ImagesHandler.determineTotalImageInitialSize(getDiskImage(), getParameters().getDestinationFormat(), getParameters().getSrcDomain()));
    parameters.setJobWeight(getParameters().getOperationsJobWeight().get(CopyStage.DEST_CREATION.name()));
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    runInternalAction(VdcActionType.CreateVolumeContainer, parameters);
}
#method_after
private void createVolume() {
    populateDiskSnapshotsInfoFromStorage();
    CreateVolumeContainerCommandParameters parameters = new CreateVolumeContainerCommandParameters(getParameters().getStoragePoolId(), getParameters().getDestDomain(), Guid.Empty, Guid.Empty, getParameters().getDestImageGroupId(), getParameters().getDestinationImageId(), getParameters().getDestinationFormat(), getParameters().getDescription(), getDiskImage().getSize(), imagesHandler.determineTotalImageInitialSize(getDiskImage(), getParameters().getDestinationFormat(), getParameters().getSrcDomain(), getParameters().getDestDomain()));
    parameters.setJobWeight(getParameters().getOperationsJobWeight().get(CopyStage.DEST_CREATION.name()));
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    runInternalAction(VdcActionType.CreateVolumeContainer, parameters);
}
#end_block

#method_before
public static void fillImagesMapBasedOnTemplate(VmTemplate template, Map<Guid, DiskImage> diskInfoDestinationMap, Map<Guid, StorageDomain> destStorages) {
    List<StorageDomain> domains = DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(template.getStoragePoolId());
    fillImagesMapBasedOnTemplate(template, domains, diskInfoDestinationMap, destStorages);
}
#method_after
public void fillImagesMapBasedOnTemplate(VmTemplate template, Map<Guid, DiskImage> diskInfoDestinationMap, Map<Guid, StorageDomain> destStorages) {
    List<StorageDomain> domains = storageDomainDao.getAllForStoragePool(template.getStoragePoolId());
    fillImagesMapBasedOnTemplate(template, domains, diskInfoDestinationMap, destStorages);
}
#end_block

#method_before
public static void addDiskImage(DiskImage image, boolean active, ImageStorageDomainMap imageStorageDomainMap, Guid vmId) {
    try {
        addImage(image, active, imageStorageDomainMap);
        addDiskToVmIfNotExists(image, vmId);
    } catch (RuntimeException ex) {
        log.error("Failed adding new disk image and related entities to db: {}", ex.getMessage());
        log.debug("Exception", ex);
        throw new EngineException(EngineError.DB, ex);
    }
}
#method_after
public void addDiskImage(DiskImage image, boolean active, ImageStorageDomainMap imageStorageDomainMap, Guid vmId) {
    try {
        addImage(image, active, imageStorageDomainMap);
        addDiskToVmIfNotExists(image, vmId);
    } catch (RuntimeException ex) {
        log.error("Failed adding new disk image and related entities to db: {}", ex.getMessage());
        log.debug("Exception", ex);
        throw new EngineException(EngineError.DB, ex);
    }
}
#end_block

#method_before
public static void addDiskImageWithNoVmDevice(DiskImage image, boolean active, ImageStorageDomainMap imageStorageDomainMap) {
    try {
        addImage(image, active, imageStorageDomainMap);
        addDisk(image);
    } catch (RuntimeException ex) {
        log.error("Failed adding new disk image and related entities to db: {}", ex.getMessage());
        log.debug("Exception", ex);
        throw new EngineException(EngineError.DB, ex);
    }
}
#method_after
public void addDiskImageWithNoVmDevice(DiskImage image, boolean active, ImageStorageDomainMap imageStorageDomainMap) {
    try {
        addImage(image, active, imageStorageDomainMap);
        addDisk(image);
    } catch (RuntimeException ex) {
        log.error("Failed adding new disk image and related entities to db: {}", ex.getMessage());
        log.debug("Exception", ex);
        throw new EngineException(EngineError.DB, ex);
    }
}
#end_block

#method_before
public static void addDiskImageWithNoVmDevice(DiskImage image) {
    addDiskImageWithNoVmDevice(image, image.getActive(), new ImageStorageDomainMap(image.getImageId(), image.getStorageIds().get(0), image.getQuotaId(), image.getDiskProfileId()));
}
#method_after
public void addDiskImageWithNoVmDevice(DiskImage image) {
    addDiskImageWithNoVmDevice(image, image.getActive(), new ImageStorageDomainMap(image.getImageId(), image.getStorageIds().get(0), image.getQuotaId(), image.getDiskProfileId()));
}
#end_block

#method_before
public static void addDisk(BaseDisk disk) {
    if (!DbFacade.getInstance().getBaseDiskDao().exists(disk.getId())) {
        DbFacade.getInstance().getBaseDiskDao().save(disk);
    }
}
#method_after
public void addDisk(BaseDisk disk) {
    if (!baseDiskDao.exists(disk.getId())) {
        baseDiskDao.save(disk);
    }
}
#end_block

#method_before
public static void addDiskImage(DiskImage image, Guid vmId) {
    addDiskImage(image, image.getActive(), new ImageStorageDomainMap(image.getImageId(), image.getStorageIds().get(0), image.getQuotaId(), image.getDiskProfileId()), vmId);
}
#method_after
public void addDiskImage(DiskImage image, Guid vmId) {
    addDiskImage(image, image.getActive(), new ImageStorageDomainMap(image.getImageId(), image.getStorageIds().get(0), image.getQuotaId(), image.getDiskProfileId()), vmId);
}
#end_block

#method_before
public static void addImage(DiskImage image, boolean active, ImageStorageDomainMap imageStorageDomainMap) {
    image.setActive(active);
    DbFacade.getInstance().getImageDao().save(image.getImage());
    DiskImageDynamic diskDynamic = new DiskImageDynamic();
    diskDynamic.setId(image.getImageId());
    diskDynamic.setActualSize(image.getActualSizeInBytes());
    DbFacade.getInstance().getDiskImageDynamicDao().save(diskDynamic);
    if (imageStorageDomainMap != null) {
        DbFacade.getInstance().getImageStorageDomainMapDao().save(imageStorageDomainMap);
    }
}
#method_after
public void addImage(DiskImage image, boolean active, ImageStorageDomainMap imageStorageDomainMap) {
    image.setActive(active);
    imageDao.save(image.getImage());
    DiskImageDynamic diskDynamic = new DiskImageDynamic();
    diskDynamic.setId(image.getImageId());
    diskDynamic.setActualSize(image.getActualSizeInBytes());
    diskImageDynamicDao.save(diskDynamic);
    if (imageStorageDomainMap != null) {
        imageStorageDomainMapDao.save(imageStorageDomainMap);
    }
}
#end_block

#method_before
public static void addDiskToVmIfNotExists(BaseDisk disk, Guid vmId) {
    if (!DbFacade.getInstance().getBaseDiskDao().exists(disk.getId())) {
        addDiskToVm(disk, vmId);
    }
}
#method_after
public void addDiskToVmIfNotExists(BaseDisk disk, Guid vmId) {
    if (!baseDiskDao.exists(disk.getId())) {
        addDiskToVm(disk, vmId);
    }
}
#end_block

#method_before
public static void addDiskToVm(BaseDisk disk, Guid vmId) {
    DbFacade.getInstance().getBaseDiskDao().save(disk);
    if (disk.getDiskVmElementForVm(vmId) != null) {
        getDiskVmElementDao().save(disk.getDiskVmElementForVm(vmId));
    }
    final VmDeviceUtils vmDeviceUtils = Injector.get(VmDeviceUtils.class);
    vmDeviceUtils.addDiskDevice(vmId, disk.getId());
}
#method_after
public void addDiskToVm(BaseDisk disk, Guid vmId) {
    baseDiskDao.save(disk);
    if (disk.getDiskVmElementForVm(vmId) != null) {
        diskVmElementDao.save(disk.getDiskVmElementForVm(vmId));
    }
    final VmDeviceUtils vmDeviceUtils = Injector.get(VmDeviceUtils.class);
    vmDeviceUtils.addDiskDevice(vmId, disk.getId());
}
#end_block

#method_before
public static ImageStorageDomainMap saveImage(DiskImage diskImage) {
    DbFacade.getInstance().getImageDao().save(diskImage.getImage());
    ImageStorageDomainMap imageStorageDomainMap = new ImageStorageDomainMap(diskImage.getImageId(), diskImage.getStorageIds().get(0), diskImage.getQuotaId(), diskImage.getDiskProfileId());
    DbFacade.getInstance().getImageStorageDomainMapDao().save(imageStorageDomainMap);
    return imageStorageDomainMap;
}
#method_after
public ImageStorageDomainMap saveImage(DiskImage diskImage) {
    imageDao.save(diskImage.getImage());
    ImageStorageDomainMap imageStorageDomainMap = new ImageStorageDomainMap(diskImage.getImageId(), diskImage.getStorageIds().get(0), diskImage.getQuotaId(), diskImage.getDiskProfileId());
    imageStorageDomainMapDao.save(imageStorageDomainMap);
    return imageStorageDomainMap;
}
#end_block

#method_before
public static boolean isImagesExists(Iterable<DiskImage> images, Guid storagePoolId) {
    for (DiskImage image : images) {
        DiskImage fromIrs = isImageExist(storagePoolId, image);
        if (fromIrs == null) {
            return false;
        }
    }
    return true;
}
#method_after
public boolean isImagesExists(Iterable<DiskImage> images, Guid storagePoolId) {
    for (DiskImage image : images) {
        DiskImage fromIrs = isImageExist(storagePoolId, image);
        if (fromIrs == null) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private static DiskImage isImageExist(Guid storagePoolId, DiskImage image) {
    DiskImage fromIrs = null;
    Guid storageDomainId = image.getStorageIds().get(0);
    Guid imageGroupId = image.getId() != null ? image.getId() : Guid.Empty;
    try {
        fromIrs = (DiskImage) Backend.getInstance().getResourceManager().runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, image.getImageId())).getReturnValue();
    } catch (Exception e) {
        log.debug("Unable to get image info from storage", e);
    }
    return fromIrs;
}
#method_after
private DiskImage isImageExist(Guid storagePoolId, DiskImage image) {
    DiskImage fromIrs = null;
    Guid storageDomainId = image.getStorageIds().get(0);
    Guid imageGroupId = image.getId() != null ? image.getId() : Guid.Empty;
    try {
        fromIrs = (DiskImage) resourceManager.runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, image.getImageId())).getReturnValue();
    } catch (Exception e) {
        log.debug("Unable to get image info from storage", e);
    }
    return fromIrs;
}
#end_block

#method_before
public static boolean checkImagesConfiguration(Guid storageDomainId, Collection<? extends Disk> disksConfigList, List<String> messages) {
    boolean result = true;
    StorageDomainStatic storageDomain = DbFacade.getInstance().getStorageDomainStaticDao().get(storageDomainId);
    for (Disk diskInfo : disksConfigList) {
        if (DiskStorageType.IMAGE == diskInfo.getDiskStorageType()) {
            result = checkImageConfiguration(storageDomain, (DiskImage) diskInfo, messages);
        }
        if (!result) {
            break;
        }
    }
    return result;
}
#method_after
public boolean checkImagesConfiguration(Guid storageDomainId, Collection<? extends Disk> disksConfigList, List<String> messages) {
    boolean result = true;
    StorageDomainStatic storageDomain = storageDomainStaticDao.get(storageDomainId);
    for (Disk diskInfo : disksConfigList) {
        if (DiskStorageType.IMAGE == diskInfo.getDiskStorageType()) {
            result = checkImageConfiguration(storageDomain, (DiskImage) diskInfo, messages);
        }
        if (!result) {
            break;
        }
    }
    return result;
}
#end_block

#method_before
public static void fillImagesBySnapshots(VM vm) {
    for (Disk disk : vm.getDiskMap().values()) {
        if (disk.getDiskStorageType().isInternal()) {
            DiskImage diskImage = (DiskImage) disk;
            diskImage.getSnapshots().addAll(DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForLeaf(diskImage.getImageId()));
        }
    }
}
#method_after
public void fillImagesBySnapshots(VM vm) {
    for (Disk disk : vm.getDiskMap().values()) {
        if (disk.getDiskStorageType().isInternal()) {
            DiskImage diskImage = (DiskImage) disk;
            diskImage.getSnapshots().addAll(diskImageDao.getAllSnapshotsForLeaf(diskImage.getImageId()));
        }
    }
}
#end_block

#method_before
public static void removeDiskImage(DiskImage diskImage, Guid vmId) {
    try {
        removeDiskFromVm(vmId, diskImage.getId());
        removeImage(diskImage);
    } catch (RuntimeException ex) {
        log.error("Failed to remove disk image and related entities from db: {}", ex.getMessage());
        log.debug("Exception", ex);
        throw new EngineException(EngineError.DB, ex);
    }
}
#method_after
public void removeDiskImage(DiskImage diskImage, Guid vmId) {
    try {
        removeDiskFromVm(vmId, diskImage.getId());
        removeImage(diskImage);
    } catch (RuntimeException ex) {
        log.error("Failed to remove disk image and related entities from db: {}", ex.getMessage());
        log.debug("Exception", ex);
        throw new EngineException(EngineError.DB, ex);
    }
}
#end_block

#method_before
public static void removeLunDisk(LunDisk lunDisk) {
    DbFacade.getInstance().getVmDeviceDao().remove(new VmDeviceId(lunDisk.getId(), null));
    LUNs lun = lunDisk.getLun();
    DbFacade.getInstance().getDiskLunMapDao().remove(new DiskLunMapId(lunDisk.getId(), lun.getLUNId()));
    DbFacade.getInstance().getBaseDiskDao().remove(lunDisk.getId());
    lun.setLunConnections(new ArrayList<>(DbFacade.getInstance().getStorageServerConnectionDao().getAllForLun(lun.getLUNId())));
    if (!lun.getLunConnections().isEmpty()) {
        StorageHelperDirector.getInstance().getItem(lun.getLunConnections().get(0).getStorageType()).removeLun(lun);
    } else {
        // if there are no connections then the lun is fcp.
        StorageHelperDirector.getInstance().getItem(StorageType.FCP).removeLun(lun);
    }
}
#method_after
public void removeLunDisk(LunDisk lunDisk) {
    vmDeviceDao.remove(new VmDeviceId(lunDisk.getId(), null));
    LUNs lun = lunDisk.getLun();
    diskLunMapDao.remove(new DiskLunMapId(lunDisk.getId(), lun.getLUNId()));
    baseDiskDao.remove(lunDisk.getId());
    lun.setLunConnections(new ArrayList<>(storageServerConnectionDao.getAllForLun(lun.getLUNId())));
    if (!lun.getLunConnections().isEmpty()) {
        storageHelperDirector.getItem(lun.getLunConnections().get(0).getStorageType()).removeLun(lun);
    } else {
        // if there are no connections then the lun is fcp.
        storageHelperDirector.getItem(StorageType.FCP).removeLun(lun);
    }
}
#end_block

#method_before
public static void removeImage(DiskImage diskImage) {
    DbFacade.getInstance().getImageStorageDomainMapDao().remove(diskImage.getImageId());
    DbFacade.getInstance().getDiskImageDynamicDao().remove(diskImage.getImageId());
    DbFacade.getInstance().getImageDao().remove(diskImage.getImageId());
}
#method_after
public void removeImage(DiskImage diskImage) {
    imageStorageDomainMapDao.remove(diskImage.getImageId());
    diskImageDynamicDao.remove(diskImage.getImageId());
    imageDao.remove(diskImage.getImageId());
}
#end_block

#method_before
public static void removeDiskFromVm(Guid vmGuid, Guid diskId) {
    DbFacade.getInstance().getVmDeviceDao().remove(new VmDeviceId(diskId, vmGuid));
    DbFacade.getInstance().getBaseDiskDao().remove(diskId);
}
#method_after
public void removeDiskFromVm(Guid vmGuid, Guid diskId) {
    vmDeviceDao.remove(new VmDeviceId(diskId, vmGuid));
    baseDiskDao.remove(diskId);
}
#end_block

#method_before
public static void updateImageStatus(Guid imageId, ImageStatus imageStatus) {
    DbFacade.getInstance().getImageDao().updateStatus(imageId, imageStatus);
}
#method_after
public void updateImageStatus(Guid imageId, ImageStatus imageStatus) {
    imageDao.updateStatus(imageId, imageStatus);
}
#end_block

#method_before
public static void updateAllDiskImageSnapshotsStatusWithCompensation(final Guid diskId, final ImageStatus status, ImageStatus statusForCompensation, final CompensationContext compensationContext) {
    updateAllDiskImagesSnapshotsStatusInTransactionWithCompensation(Collections.singletonList(diskId), status, statusForCompensation, compensationContext);
}
#method_after
public void updateAllDiskImageSnapshotsStatusWithCompensation(final Guid diskId, final ImageStatus status, ImageStatus statusForCompensation, final CompensationContext compensationContext) {
    updateAllDiskImagesSnapshotsStatusInTransactionWithCompensation(Collections.singletonList(diskId), status, statusForCompensation, compensationContext);
}
#end_block

#method_before
public static DiskImage getSnapshotLeaf(Guid diskId) {
    List<DiskImage> diskSnapshots = DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForImageGroup(diskId);
    sortImageList(diskSnapshots);
    return diskSnapshots.get(diskSnapshots.size() - 1);
}
#method_after
public DiskImage getSnapshotLeaf(Guid diskId) {
    List<DiskImage> diskSnapshots = diskImageDao.getAllSnapshotsForImageGroup(diskId);
    sortImageList(diskSnapshots);
    return diskSnapshots.get(diskSnapshots.size() - 1);
}
#end_block

#method_before
public static List<DiskImage> getCinderLeafImages(List<Disk> disks) {
    List<DiskImage> leafCinderDisks = new ArrayList<>();
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(disks);
    for (CinderDisk cinder : cinderDisks) {
        leafCinderDisks.add(getSnapshotLeaf(cinder.getId()));
    }
    return leafCinderDisks;
}
#method_after
public List<DiskImage> getCinderLeafImages(List<Disk> disks) {
    List<DiskImage> leafCinderDisks = new ArrayList<>();
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(disks);
    for (CinderDisk cinder : cinderDisks) {
        leafCinderDisks.add(getSnapshotLeaf(cinder.getId()));
    }
    return leafCinderDisks;
}
#end_block

#method_before
public static void updateAllDiskImagesSnapshotsStatusInTransactionWithCompensation(final Collection<Guid> diskIds, final ImageStatus status, ImageStatus statusForCompensation, final CompensationContext compensationContext) {
    if (compensationContext != null) {
        for (Guid diskId : diskIds) {
            List<DiskImage> diskSnapshots = DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForImageGroup(diskId);
            for (DiskImage diskSnapshot : diskSnapshots) {
                diskSnapshot.setImageStatus(statusForCompensation);
                compensationContext.snapshotEntityStatus(diskSnapshot.getImage());
            }
        }
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            for (Guid diskId : diskIds) {
                DbFacade.getInstance().getImageDao().updateStatusOfImagesByImageGroupId(diskId, status);
            }
            compensationContext.stateChanged();
            return null;
        });
    } else {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            for (Guid diskId : diskIds) {
                DbFacade.getInstance().getImageDao().updateStatusOfImagesByImageGroupId(diskId, status);
            }
            return null;
        });
    }
}
#method_after
public void updateAllDiskImagesSnapshotsStatusInTransactionWithCompensation(final Collection<Guid> diskIds, final ImageStatus status, ImageStatus statusForCompensation, final CompensationContext compensationContext) {
    if (compensationContext != null) {
        for (Guid diskId : diskIds) {
            List<DiskImage> diskSnapshots = diskImageDao.getAllSnapshotsForImageGroup(diskId);
            for (DiskImage diskSnapshot : diskSnapshots) {
                diskSnapshot.setImageStatus(statusForCompensation);
                compensationContext.snapshotEntityStatus(diskSnapshot.getImage());
            }
        }
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            for (Guid diskId : diskIds) {
                imageDao.updateStatusOfImagesByImageGroupId(diskId, status);
            }
            compensationContext.stateChanged();
            return null;
        });
    } else {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            for (Guid diskId : diskIds) {
                imageDao.updateStatusOfImagesByImageGroupId(diskId, status);
            }
            return null;
        });
    }
}
#end_block

#method_before
public static Snapshot prepareSnapshotConfigWithoutImageSingleImage(Snapshot snapshot, Guid imageId, OvfManager ovfManager) {
    return prepareSnapshotConfigWithAlternateImage(snapshot, imageId, null, ovfManager);
}
#method_after
public Snapshot prepareSnapshotConfigWithoutImageSingleImage(Snapshot snapshot, Guid imageId, OvfManager ovfManager) {
    return prepareSnapshotConfigWithAlternateImage(snapshot, imageId, null, ovfManager);
}
#end_block

#method_before
public static Snapshot prepareSnapshotConfigWithAlternateImage(Snapshot snapshot, Guid oldImageId, DiskImage newImage, OvfManager ovfManager) {
    try {
        String snapConfig = snapshot.getVmConfiguration();
        if (snapshot.isVmConfigurationAvailable() && snapConfig != null) {
            VM vmSnapshot = new VM();
            ArrayList<DiskImage> snapshotImages = new ArrayList<>();
            ovfManager.importVm(snapConfig, vmSnapshot, snapshotImages, new ArrayList<>());
            // Remove the image from the disk list
            Iterator<DiskImage> diskIter = snapshotImages.iterator();
            while (diskIter.hasNext()) {
                DiskImage imageInList = diskIter.next();
                if (imageInList.getImageId().equals(oldImageId)) {
                    log.debug("Recreating vmSnapshot '{}' without the image '{}'", snapshot.getId(), oldImageId);
                    diskIter.remove();
                    break;
                }
            }
            if (newImage != null) {
                log.debug("Adding image '{}' to vmSnapshot '{}'", newImage.getImageId(), snapshot.getId());
                newImage.setDiskVmElements(Collections.singletonList(getDiskVmElementDao().get(new VmDeviceId(newImage.getId(), vmSnapshot.getId()))));
                snapshotImages.add(newImage);
            }
            String newOvf = ovfManager.exportVm(vmSnapshot, snapshotImages, ClusterUtils.getCompatibilityVersion(vmSnapshot));
            snapshot.setVmConfiguration(newOvf);
        }
    } catch (OvfReaderException e) {
        log.error("Can't remove image '{}' from snapshot '{}'", oldImageId, snapshot.getId());
    }
    return snapshot;
}
#method_after
public Snapshot prepareSnapshotConfigWithAlternateImage(Snapshot snapshot, Guid oldImageId, DiskImage newImage, OvfManager ovfManager) {
    try {
        String snapConfig = snapshot.getVmConfiguration();
        if (snapshot.isVmConfigurationAvailable() && snapConfig != null) {
            VM vmSnapshot = new VM();
            ArrayList<DiskImage> snapshotImages = new ArrayList<>();
            ovfManager.importVm(snapConfig, vmSnapshot, snapshotImages, new ArrayList<>());
            // Remove the image from the disk list
            Iterator<DiskImage> diskIter = snapshotImages.iterator();
            while (diskIter.hasNext()) {
                DiskImage imageInList = diskIter.next();
                if (imageInList.getImageId().equals(oldImageId)) {
                    log.debug("Recreating vmSnapshot '{}' without the image '{}'", snapshot.getId(), oldImageId);
                    diskIter.remove();
                    break;
                }
            }
            if (newImage != null) {
                log.debug("Adding image '{}' to vmSnapshot '{}'", newImage.getImageId(), snapshot.getId());
                newImage.setDiskVmElements(Collections.singletonList(diskVmElementDao.get(new VmDeviceId(newImage.getId(), vmSnapshot.getId()))));
                snapshotImages.add(newImage);
            }
            String newOvf = ovfManager.exportVm(vmSnapshot, snapshotImages, clusterUtils.getCompatibilityVersion(vmSnapshot));
            snapshot.setVmConfiguration(newOvf);
        }
    } catch (OvfReaderException e) {
        log.error("Can't remove image '{}' from snapshot '{}'", oldImageId, snapshot.getId());
    }
    return snapshot;
}
#end_block

#method_before
public static DiskImage createDiskImageWithExcessData(DiskImage diskImage, Guid sdId) {
    DiskImage dummy = DiskImage.copyOf(diskImage);
    dummy.setStorageIds(new ArrayList<>(Collections.singletonList(sdId)));
    dummy.getSnapshots().addAll(DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForLeaf(dummy.getImageId()));
    return dummy;
}
#method_after
public DiskImage createDiskImageWithExcessData(DiskImage diskImage, Guid sdId) {
    DiskImage dummy = DiskImage.copyOf(diskImage);
    dummy.setStorageIds(new ArrayList<>(Collections.singletonList(sdId)));
    dummy.getSnapshots().addAll(diskImageDao.getAllSnapshotsForLeaf(dummy.getImageId()));
    return dummy;
}
#end_block

#method_before
public static List<DiskImage> getSnapshotsDummiesForStorageAllocations(Collection<DiskImage> originalDisks) {
    List<DiskImage> diskDummies = new ArrayList<>();
    for (DiskImage snapshot : originalDisks) {
        DiskImage clone = DiskImage.copyOf(snapshot);
        // Add the child snapshot into which the deleted snapshot is going to be merged to the
        // DiskImage for StorageDomainValidator to handle
        List<DiskImage> snapshots = DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForParent(clone.getImageId());
        clone.getSnapshots().clear();
        // Add the clone itself since snapshots should contain the entire chain.
        clone.getSnapshots().add(clone);
        clone.getSnapshots().addAll(snapshots);
        diskDummies.add(clone);
    }
    return diskDummies;
}
#method_after
public List<DiskImage> getSnapshotsDummiesForStorageAllocations(Collection<DiskImage> originalDisks) {
    List<DiskImage> diskDummies = new ArrayList<>();
    for (DiskImage snapshot : originalDisks) {
        DiskImage clone = DiskImage.copyOf(snapshot);
        // Add the child snapshot into which the deleted snapshot is going to be merged to the
        // DiskImage for StorageDomainValidator to handle
        List<DiskImage> snapshots = diskImageDao.getAllSnapshotsForParent(clone.getImageId());
        clone.getSnapshots().clear();
        // Add the clone itself since snapshots should contain the entire chain.
        clone.getSnapshots().add(clone);
        clone.getSnapshots().addAll(snapshots);
        diskDummies.add(clone);
    }
    return diskDummies;
}
#end_block

#method_before
protected static DiskImage getVolumeInfoFromVdsm(Guid storagePoolId, Guid newStorageDomainID, Guid newImageGroupId, Guid newImageId) {
    return (DiskImage) VdsCommandsHelper.runVdsCommandWithFailover(VDSCommandType.GetVolumeInfo, new GetVolumeInfoVDSCommandParameters(storagePoolId, newStorageDomainID, newImageGroupId, newImageId), storagePoolId, null).getReturnValue();
}
#method_after
protected DiskImage getVolumeInfoFromVdsm(Guid storagePoolId, Guid newStorageDomainID, Guid newImageGroupId, Guid newImageId) {
    return (DiskImage) VdsCommandsHelper.runVdsCommandWithFailover(VDSCommandType.GetVolumeInfo, new GetVolumeInfoVDSCommandParameters(storagePoolId, newStorageDomainID, newImageGroupId, newImageId), storagePoolId, null).getReturnValue();
}
#end_block

#method_before
public static QemuImageInfo getQemuImageInfoFromVdsm(Guid storagePoolId, Guid newStorageDomainID, Guid newImageGroupId, Guid newImageId, Guid vdsId, boolean shouldPrepareAndTeardown) {
    if (vdsId == null) {
        vdsId = VdsCommandsHelper.getHostForExecution(storagePoolId, Collections.emptyList());
    }
    QemuImageInfo qemuImageInfo = null;
    if (shouldPrepareAndTeardown) {
        prepareImage(storagePoolId, newStorageDomainID, newImageGroupId, newImageId, vdsId);
    }
    try {
        qemuImageInfo = (QemuImageInfo) Backend.getInstance().getResourceManager().runVdsCommand(VDSCommandType.GetQemuImageInfo, new GetVolumeInfoVDSCommandParameters(vdsId, storagePoolId, newStorageDomainID, newImageGroupId, newImageId)).getReturnValue();
    } catch (Exception e) {
        log.error("Unable to get qemu image info from storage", e);
    } finally {
        if (shouldPrepareAndTeardown) {
            teardownImage(storagePoolId, newStorageDomainID, newImageGroupId, newImageId, vdsId);
        }
    }
    return qemuImageInfo;
}
#method_after
public QemuImageInfo getQemuImageInfoFromVdsm(Guid storagePoolId, Guid newStorageDomainID, Guid newImageGroupId, Guid newImageId, Guid vdsId, boolean shouldPrepareAndTeardown) {
    if (vdsId == null) {
        vdsId = VdsCommandsHelper.getHostForExecution(storagePoolId, Collections.emptyList());
    }
    QemuImageInfo qemuImageInfo = null;
    if (shouldPrepareAndTeardown) {
        prepareImage(storagePoolId, newStorageDomainID, newImageGroupId, newImageId, vdsId);
    }
    try {
        qemuImageInfo = (QemuImageInfo) resourceManager.runVdsCommand(VDSCommandType.GetQemuImageInfo, new GetVolumeInfoVDSCommandParameters(vdsId, storagePoolId, newStorageDomainID, newImageGroupId, newImageId)).getReturnValue();
    } catch (Exception e) {
        log.error("Unable to get qemu image info from storage", e);
    } finally {
        if (shouldPrepareAndTeardown) {
            try {
                teardownImage(storagePoolId, newStorageDomainID, newImageGroupId, newImageId, vdsId);
            } catch (Exception e) {
                log.warn("Unable to tear down image", e);
            }
        }
    }
    return qemuImageInfo;
}
#end_block

#method_before
public static DiskImage cloneDiskImage(Guid storageDomainId, Guid newImageGroupId, Guid newImageGuid, DiskImage srcDiskImage, Guid diskProfileId, Guid snapshotId, DiskImage diskImageFromClient) {
    DiskImage clonedDiskImage = DiskImage.copyOf(srcDiskImage);
    clonedDiskImage.setImageId(newImageGuid);
    clonedDiskImage.setParentId(Guid.Empty);
    clonedDiskImage.setImageTemplateId(Guid.Empty);
    clonedDiskImage.setVmSnapshotId(snapshotId);
    clonedDiskImage.setId(newImageGroupId);
    clonedDiskImage.setLastModifiedDate(new Date());
    clonedDiskImage.setVolumeFormat(srcDiskImage.getVolumeFormat());
    clonedDiskImage.setVolumeType(srcDiskImage.getVolumeType());
    ArrayList<Guid> storageIds = new ArrayList<>();
    storageIds.add(storageDomainId);
    clonedDiskImage.setStorageIds(storageIds);
    clonedDiskImage.setDiskProfileId(diskProfileId);
    // If volume information was not changed at client - use the volume information of the ancestral image
    if (diskImageFromClient != null) {
        if (volumeInfoChanged(diskImageFromClient, srcDiskImage)) {
            changeVolumeInfo(clonedDiskImage, diskImageFromClient);
        } else {
            DiskImage ancestorDiskImage = getDiskImageDao().getAncestor(srcDiskImage.getImageId());
            changeVolumeInfo(clonedDiskImage, ancestorDiskImage);
        }
    } else {
        DiskImage ancestorDiskImage = getDiskImageDao().getAncestor(srcDiskImage.getImageId());
        changeVolumeInfo(clonedDiskImage, ancestorDiskImage);
    }
    return clonedDiskImage;
}
#method_after
public DiskImage cloneDiskImage(Guid storageDomainId, Guid newImageGroupId, Guid newImageGuid, DiskImage srcDiskImage, Guid diskProfileId, Guid snapshotId, DiskImage diskImageFromClient) {
    DiskImage clonedDiskImage = DiskImage.copyOf(srcDiskImage);
    clonedDiskImage.setImageId(newImageGuid);
    clonedDiskImage.setParentId(Guid.Empty);
    clonedDiskImage.setImageTemplateId(Guid.Empty);
    clonedDiskImage.setVmSnapshotId(snapshotId);
    clonedDiskImage.setId(newImageGroupId);
    clonedDiskImage.setLastModifiedDate(new Date());
    clonedDiskImage.setVolumeFormat(srcDiskImage.getVolumeFormat());
    clonedDiskImage.setVolumeType(srcDiskImage.getVolumeType());
    ArrayList<Guid> storageIds = new ArrayList<>();
    storageIds.add(storageDomainId);
    clonedDiskImage.setStorageIds(storageIds);
    clonedDiskImage.setDiskProfileId(diskProfileId);
    // If volume information was not changed at client - use the volume information of the ancestral image
    if (diskImageFromClient != null) {
        if (volumeInfoChanged(diskImageFromClient, srcDiskImage)) {
            changeVolumeInfo(clonedDiskImage, diskImageFromClient);
        } else {
            DiskImage ancestorDiskImage = diskImageDao.getAncestor(srcDiskImage.getImageId());
            changeVolumeInfo(clonedDiskImage, ancestorDiskImage);
        }
    } else {
        DiskImage ancestorDiskImage = diskImageDao.getAncestor(srcDiskImage.getImageId());
        changeVolumeInfo(clonedDiskImage, ancestorDiskImage);
    }
    return clonedDiskImage;
}
#end_block

#method_before
public static Long determineImageInitialSize(Image sourceImage, VolumeFormat destFormat, Guid storagePoolId, Guid srcDomain, Guid dstDomain, Guid imageGroupID) {
    // need to pass initial size (it can be only preallocated).
    if (isInitialSizeSupportedForFormat(destFormat, dstDomain)) {
        // TODO: inspect if we can rely on the database to get the actual size.
        DiskImage imageInfoFromStorage = getVolumeInfoFromVdsm(storagePoolId, srcDomain, imageGroupID, sourceImage.getId());
        return computeCowImageNeededSize(sourceImage.getVolumeFormat(), imageInfoFromStorage.getActualSizeInBytes());
    }
    return null;
}
#method_after
public Long determineImageInitialSize(Image sourceImage, VolumeFormat destFormat, Guid storagePoolId, Guid srcDomain, Guid dstDomain, Guid imageGroupID) {
    // need to pass initial size (it can be only preallocated).
    if (isInitialSizeSupportedForFormat(destFormat, dstDomain)) {
        // TODO: inspect if we can rely on the database to get the actual size.
        DiskImage imageInfoFromStorage = getVolumeInfoFromVdsm(storagePoolId, srcDomain, imageGroupID, sourceImage.getId());
        return computeCowImageNeededSize(sourceImage.getVolumeFormat(), imageInfoFromStorage.getActualSizeInBytes());
    }
    return null;
}
#end_block

#method_before
public static Long determineTotalImageInitialSize(DiskImage sourceImage, VolumeFormat destFormat, Guid srcDomain) {
    if (isInitialSizeSupportedForFormat(destFormat, srcDomain)) {
        double totalSizeForClonedDisk = getTotalActualSizeOfDisk(sourceImage, DbFacade.getInstance().getStorageDomainDao().get(srcDomain).getStorageStaticData());
        return computeCowImageNeededSize(sourceImage.getVolumeFormat(), Double.valueOf(totalSizeForClonedDisk).longValue());
    }
    return null;
}
#method_after
public Long determineTotalImageInitialSize(DiskImage sourceImage, VolumeFormat destFormat, Guid srcDomain, Guid dstDomain) {
    if (isInitialSizeSupportedForFormat(destFormat, dstDomain)) {
        double totalSizeForClonedDisk = getTotalActualSizeOfDisk(sourceImage, storageDomainDao.get(srcDomain).getStorageStaticData());
        return computeCowImageNeededSize(sourceImage.getVolumeFormat(), Double.valueOf(totalSizeForClonedDisk).longValue());
    }
    return null;
}
#end_block

#method_before
private static boolean isInitialSizeSupportedForFormat(VolumeFormat destFormat, Guid dstDomain) {
    return destFormat == VolumeFormat.COW && isImageInitialSizeSupported(DbFacade.getInstance().getStorageDomainDao().get(dstDomain).getStorageType());
}
#method_after
private boolean isInitialSizeSupportedForFormat(VolumeFormat destFormat, Guid dstDomain) {
    return destFormat == VolumeFormat.COW && isImageInitialSizeSupported(storageDomainDao.get(dstDomain).getStorageType());
}
#end_block

#method_before
public static void prepareImage(Guid storagePoolId, Guid newStorageDomainID, Guid newImageGroupId, Guid newImageId, Guid vdsId) {
    Backend.getInstance().getResourceManager().runVdsCommand(VDSCommandType.PrepareImage, new PrepareImageVDSCommandParameters(vdsId, storagePoolId, newStorageDomainID, newImageGroupId, newImageId, true));
}
#method_after
public void prepareImage(Guid storagePoolId, Guid newStorageDomainID, Guid newImageGroupId, Guid newImageId, Guid vdsId) {
    resourceManager.runVdsCommand(VDSCommandType.PrepareImage, new PrepareImageVDSCommandParameters(vdsId, storagePoolId, newStorageDomainID, newImageGroupId, newImageId, true));
}
#end_block

#method_before
public static void teardownImage(Guid storagePoolId, Guid newStorageDomainID, Guid newImageGroupId, Guid newImageId, Guid vdsId) {
    Backend.getInstance().getResourceManager().runVdsCommand(VDSCommandType.TeardownImage, new ImageActionsVDSCommandParameters(vdsId, storagePoolId, newStorageDomainID, newImageGroupId, newImageId));
}
#method_after
public void teardownImage(Guid storagePoolId, Guid newStorageDomainID, Guid newImageGroupId, Guid newImageId, Guid vdsId) {
    resourceManager.runVdsCommand(VDSCommandType.TeardownImage, new ImageActionsVDSCommandParameters(vdsId, storagePoolId, newStorageDomainID, newImageGroupId, newImageId));
}
#end_block

#method_before
protected static DiskImage getVolumeInfoFromVdsm(Guid storagePoolId, Guid newStorageDomainID, Guid newImageGroupId, Guid newImageId) {
    return (DiskImage) VdsCommandsHelper.runVdsCommandWithFailover(VDSCommandType.GetVolumeInfo, new GetVolumeInfoVDSCommandParameters(storagePoolId, newStorageDomainID, newImageGroupId, newImageId), storagePoolId, null).getReturnValue();
}
#method_after
protected DiskImage getVolumeInfoFromVdsm(Guid storagePoolId, Guid newStorageDomainID, Guid newImageGroupId, Guid newImageId) {
    return (DiskImage) VdsCommandsHelper.runVdsCommandWithFailover(VDSCommandType.GetVolumeInfo, new GetVolumeInfoVDSCommandParameters(storagePoolId, newStorageDomainID, newImageGroupId, newImageId), storagePoolId, null).getReturnValue();
}
#end_block

#method_before
public QemuImageInfo getQemuImageInfoFromVdsm(Guid storagePoolId, Guid newStorageDomainID, Guid newImageGroupId, Guid newImageId, Guid vdsId, boolean shouldPrepareAndTeardown) {
    if (vdsId == null) {
        vdsId = VdsCommandsHelper.getHostForExecution(storagePoolId, Collections.emptyList());
    }
    QemuImageInfo qemuImageInfo = null;
    if (shouldPrepareAndTeardown) {
        prepareImage(storagePoolId, newStorageDomainID, newImageGroupId, newImageId, vdsId);
    }
    try {
        qemuImageInfo = (QemuImageInfo) resourceManager.runVdsCommand(VDSCommandType.GetQemuImageInfo, new GetVolumeInfoVDSCommandParameters(vdsId, storagePoolId, newStorageDomainID, newImageGroupId, newImageId)).getReturnValue();
    } catch (Exception e) {
        log.error("Unable to get qemu image info from storage", e);
    } finally {
        if (shouldPrepareAndTeardown) {
            teardownImage(storagePoolId, newStorageDomainID, newImageGroupId, newImageId, vdsId);
        }
    }
    return qemuImageInfo;
}
#method_after
public QemuImageInfo getQemuImageInfoFromVdsm(Guid storagePoolId, Guid newStorageDomainID, Guid newImageGroupId, Guid newImageId, Guid vdsId, boolean shouldPrepareAndTeardown) {
    if (vdsId == null) {
        vdsId = VdsCommandsHelper.getHostForExecution(storagePoolId, Collections.emptyList());
    }
    QemuImageInfo qemuImageInfo = null;
    if (shouldPrepareAndTeardown) {
        prepareImage(storagePoolId, newStorageDomainID, newImageGroupId, newImageId, vdsId);
    }
    try {
        qemuImageInfo = (QemuImageInfo) resourceManager.runVdsCommand(VDSCommandType.GetQemuImageInfo, new GetVolumeInfoVDSCommandParameters(vdsId, storagePoolId, newStorageDomainID, newImageGroupId, newImageId)).getReturnValue();
    } catch (Exception e) {
        log.error("Unable to get qemu image info from storage", e);
    } finally {
        if (shouldPrepareAndTeardown) {
            try {
                teardownImage(storagePoolId, newStorageDomainID, newImageGroupId, newImageId, vdsId);
            } catch (Exception e) {
                log.warn("Unable to tear down image", e);
            }
        }
    }
    return qemuImageInfo;
}
#end_block

#method_before
public Long determineImageInitialSize(Image sourceImage, VolumeFormat destFormat, Guid storagePoolId, Guid srcDomain, Guid dstDomain, Guid imageGroupID) {
    // need to pass initial size (it can be only preallocated).
    if (isInitialSizeSupportedForFormat(destFormat, dstDomain)) {
        // TODO: inspect if we can rely on the database to get the actual size.
        DiskImage imageInfoFromStorage = getVolumeInfoFromVdsm(storagePoolId, srcDomain, imageGroupID, sourceImage.getId());
        // space.
        return computeCowImageNeededSize(imageInfoFromStorage.getActualSizeInBytes());
    }
    return null;
}
#method_after
public Long determineImageInitialSize(Image sourceImage, VolumeFormat destFormat, Guid storagePoolId, Guid srcDomain, Guid dstDomain, Guid imageGroupID) {
    // need to pass initial size (it can be only preallocated).
    if (isInitialSizeSupportedForFormat(destFormat, dstDomain)) {
        // TODO: inspect if we can rely on the database to get the actual size.
        DiskImage imageInfoFromStorage = getVolumeInfoFromVdsm(storagePoolId, srcDomain, imageGroupID, sourceImage.getId());
        return computeCowImageNeededSize(sourceImage.getVolumeFormat(), imageInfoFromStorage.getActualSizeInBytes());
    }
    return null;
}
#end_block

#method_before
private static long computeCowImageNeededSize(long actualSize) {
    return Double.valueOf(Math.ceil(actualSize / StorageConstants.QCOW_OVERHEAD_FACTOR)).longValue();
}
#method_after
private static long computeCowImageNeededSize(VolumeFormat sourceFormat, long actualSize) {
    // space.
    return sourceFormat == VolumeFormat.COW ? Double.valueOf(Math.ceil(actualSize / StorageConstants.QCOW_OVERHEAD_FACTOR)).longValue() : actualSize;
}
#end_block

#method_before
public Long determineTotalImageInitialSize(DiskImage sourceImage, VolumeFormat destFormat, Guid dstDomain) {
    if (isInitialSizeSupportedForFormat(destFormat, dstDomain)) {
        double totalSizeForClonedDisk = getTotalActualSizeOfDisk(sourceImage, storageDomainDao.get(dstDomain).getStorageStaticData());
        return computeCowImageNeededSize(Double.valueOf(totalSizeForClonedDisk).longValue());
    }
    return null;
}
#method_after
public Long determineTotalImageInitialSize(DiskImage sourceImage, VolumeFormat destFormat, Guid dstDomain) {
    if (isInitialSizeSupportedForFormat(destFormat, dstDomain)) {
        double totalSizeForClonedDisk = getTotalActualSizeOfDisk(sourceImage, storageDomainDao.get(dstDomain).getStorageStaticData());
        return computeCowImageNeededSize(sourceImage.getVolumeFormat(), Double.valueOf(totalSizeForClonedDisk).longValue());
    }
    return null;
}
#end_block

#method_before
protected void registerAllOvfDisks(List<DiskImage> ovfStoreDiskImages, Guid storageDomainId) {
    for (DiskImage ovfStoreDiskImage : ovfStoreDiskImages) {
        ovfStoreDiskImage.setDiskAlias(OvfInfoFileConstants.OvfStoreDescriptionLabel);
        ovfStoreDiskImage.setDiskDescription(OvfInfoFileConstants.OvfStoreDescriptionLabel);
        ovfStoreDiskImage.setShareable(true);
        RegisterDiskParameters registerDiskParams = new RegisterDiskParameters(ovfStoreDiskImage, storageDomainId);
        boolean registerDiskResult = runInternalAction(VdcActionType.RegisterDisk, registerDiskParams, cloneContext()).getSucceeded();
        log.info("Register new floating OVF_STORE disk with disk id '{}' for storage domain '{}' has {}", ovfStoreDiskImage.getId(), storageDomainId, registerDiskResult ? "succeeded" : "failed");
        if (registerDiskResult) {
            addOvfStoreDiskToDomain(ovfStoreDiskImage);
        }
    }
}
#method_after
protected void registerAllOvfDisks(List<DiskImage> ovfStoreDiskImages, Guid storageDomainId) {
    for (DiskImage ovfStoreDiskImage : ovfStoreDiskImages) {
        ovfStoreDiskImage.setDiskAlias(OvfInfoFileConstants.OvfStoreDescriptionLabel);
        ovfStoreDiskImage.setDiskDescription(OvfInfoFileConstants.OvfStoreDescriptionLabel);
        ovfStoreDiskImage.setShareable(true);
        ovfStoreDiskImage.setContentType(DiskContentType.OVF_STORE);
        RegisterDiskParameters registerDiskParams = new RegisterDiskParameters(ovfStoreDiskImage, storageDomainId);
        boolean registerDiskResult = runInternalAction(VdcActionType.RegisterDisk, registerDiskParams, cloneContext()).getSucceeded();
        log.info("Register new floating OVF_STORE disk with disk id '{}' for storage domain '{}' has {}", ovfStoreDiskImage.getId(), storageDomainId, registerDiskResult ? "succeeded" : "failed");
        if (registerDiskResult) {
            addOvfStoreDiskToDomain(ovfStoreDiskImage);
        }
    }
}
#end_block

#method_before
/*
     * Video device
     */
public void updateVideoDevices(VmBase oldVmBase, VmBase newVmBase) {
    boolean displayTypeChanged = oldVmBase.getDefaultDisplayType() != newVmBase.getDefaultDisplayType();
    boolean numOfMonitorsChanged = newVmBase.getDefaultDisplayType() == DisplayType.qxl && oldVmBase.getNumOfMonitors() != newVmBase.getNumOfMonitors();
    boolean singleQxlChanged = oldVmBase.getSingleQxlPci() != newVmBase.getSingleQxlPci();
    boolean guestOsChanged = oldVmBase.getOsId() != newVmBase.getOsId();
    if (displayTypeChanged || numOfMonitorsChanged || singleQxlChanged || guestOsChanged) {
        removeVideoDevices(oldVmBase.getId());
        addVideoDevices(newVmBase, getNeededNumberOfVideoDevices(newVmBase));
    }
}
#method_after
/*
     * Video device
     */
public void updateVideoDevices(VmBase oldVmBase, VmBase newVmBase) {
    boolean displayTypeChanged = oldVmBase.getDefaultDisplayType() != newVmBase.getDefaultDisplayType();
    boolean numOfMonitorsChanged = newVmBase.getDefaultDisplayType() == DisplayType.qxl && oldVmBase.getNumOfMonitors() != newVmBase.getNumOfMonitors();
    boolean singleQxlChanged = oldVmBase.getSingleQxlPci() != newVmBase.getSingleQxlPci();
    boolean guestOsChanged = oldVmBase.getOsId() != newVmBase.getOsId();
    if (displayTypeChanged || numOfMonitorsChanged || singleQxlChanged || guestOsChanged) {
        removeVideoDevices(oldVmBase.getId());
        addVideoDevices(newVmBase, getNeededNumberOfVideoDevices(newVmBase));
    } else {
        // fix vm's without video devices
        addVideoDevicesOnlyIfNoVideoDeviceExists(newVmBase);
    }
}
#end_block

#method_before
@PostConstruct
private void init() {
    // init the singleton. TODO remove once all code is using CDI
    setInstance(this);
    log.info("Start initializing {}", getClass().getSimpleName());
    populateVdsAndVmsList();
    // Populate the VDS dictionary
    final List<VDS> allVdsList = hostDao.getAll();
    for (VDS curVds : allVdsList) {
        addVds(curVds, true);
    }
    log.info("Finished initializing {}", getClass().getSimpleName());
}
#method_after
@PostConstruct
private void init() {
    log.info("Start initializing {}", getClass().getSimpleName());
    populateVdsAndVmsList();
    // Populate the VDS dictionary
    final List<VDS> allVdsList = hostDao.getAll();
    for (VDS curVds : allVdsList) {
        addVds(curVds, true);
    }
    log.info("Finished initializing {}", getClass().getSimpleName());
}
#end_block

#method_before
@Override
protected void endActionOnAllImageGroups() {
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        getBackend().endAction(VdcActionType.CopyImageGroup, p, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
        initQcowVersionForDisks(((MoveOrCopyImageGroupParameters) p).getDestImageGroupId());
    }
}
#method_after
@Override
protected void endActionOnAllImageGroups() {
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        getBackend().endAction(VdcActionType.CopyImageGroup, p, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
    }
}
#end_block

#method_before
protected boolean setAndValidateCpuProfile() {
    getVmTemplate().setClusterId(getClusterId());
    getVmTemplate().setCpuProfileId(getParameters().getCpuProfileId());
    return validate(cpuProfileHelper.setAndValidateCpuProfile(getVmTemplate(), getUserId()));
}
#method_after
protected boolean setAndValidateCpuProfile() {
    getVmTemplate().setClusterId(getClusterId());
    getVmTemplate().setCpuProfileId(getParameters().getCpuProfileId());
    return validate(cpuProfileHelper.setAndValidateCpuProfile(getVmTemplate(), getUserIdIfExternal().orElse(null)));
}
#end_block

#method_before
protected boolean setAndValidateCpuProfile() {
    getVm().getStaticData().setClusterId(getClusterId());
    getVm().getStaticData().setCpuProfileId(getParameters().getCpuProfileId());
    return validate(cpuProfileHelper.setAndValidateCpuProfile(getVm().getStaticData(), getUserId()));
}
#method_after
protected boolean setAndValidateCpuProfile() {
    getVm().getStaticData().setClusterId(getClusterId());
    getVm().getStaticData().setCpuProfileId(getParameters().getCpuProfileId());
    return validate(cpuProfileHelper.setAndValidateCpuProfile(getVm().getStaticData(), getUserIdIfExternal().orElse(null)));
}
#end_block

#method_before
protected boolean setAndValidateCpuProfile() {
    return validate(cpuProfileHelper.setAndValidateCpuProfile(getParameters().getVmStaticData(), getUserId()));
}
#method_after
protected boolean setAndValidateCpuProfile() {
    return validate(cpuProfileHelper.setAndValidateCpuProfile(getParameters().getVmStaticData(), getUserIdIfExternal().orElse(null)));
}
#end_block

#method_before
@Test
public void sufficientStorageSpace() {
    setupForStorageTests();
    assertTrue(cmd.imagesRelatedChecks());
}
#method_after
@Test
public void sufficientStorageSpace() {
    setupForStorageTests();
    assertTrue(cmd.validateImages());
}
#end_block

#method_before
@Test
public void storageSpaceNotWithinThreshold() {
    setupForStorageTests();
    doReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN)).when(multipleSdValidator).allDomainsWithinThresholds();
    assertFalse(cmd.imagesRelatedChecks());
}
#method_after
@Test
public void storageSpaceNotWithinThreshold() {
    setupForStorageTests();
    doReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN)).when(multipleSdValidator).allDomainsWithinThresholds();
    assertFalse(cmd.validateImages());
}
#end_block

#method_before
@Test
public void insufficientStorageSpace() {
    setupForStorageTests();
    doReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN)).when(multipleSdValidator).allDomainsHaveSpaceForClonedDisks(anyList());
    assertFalse(cmd.imagesRelatedChecks());
}
#method_after
@Test
public void insufficientStorageSpace() {
    setupForStorageTests();
    doReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN)).when(multipleSdValidator).allDomainsHaveSpaceForClonedDisks(anyList());
    assertFalse(cmd.validateImages());
}
#end_block

#method_before
@Test
public void imagesRelatedChecksFailPassDiscardNotSupported() {
    setupForStorageTests();
    doReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_PASS_DISCARD_NOT_SUPPORTED_BY_DISK_INTERFACE)).when(cmd).isPassDiscardSupportedForImagesDestSds();
    assertFalse(cmd.imagesRelatedChecks());
}
#method_after
@Test
public void imagesRelatedChecksFailPassDiscardNotSupported() {
    setupForStorageTests();
    doReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_PASS_DISCARD_NOT_SUPPORTED_BY_DISK_INTERFACE)).when(cmd).isPassDiscardSupportedForImagesDestSds();
    assertFalse(cmd.validateImages());
}
#end_block

#method_before
@Override
protected void init() {
    T parameters = getParameters();
    if (Guid.isNullOrEmpty(getParameters().getVmTemplateId())) {
        getParameters().setVmTemplateId(Guid.newGuid());
    }
    setVmTemplateId(getParameters().getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    super.setVmTemplateName(parameters.getName());
    VmStatic parameterMasterVm = parameters.getMasterVm();
    if (parameterMasterVm != null) {
        super.setVmId(parameterMasterVm.getId());
        setClusterId(parameterMasterVm.getClusterId());
        // API backward compatibility
        if (getVmDeviceUtils().shouldOverrideSoundDevice(getParameters().getMasterVm(), getMasterVmCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (getParameters().isSoundDeviceEnabled() == null) {
            parameters.setSoundDeviceEnabled(false);
        }
        if (getParameters().isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmHandler.updateDefaultTimeZone(parameterMasterVm);
        vmHandler.autoSelectUsbPolicy(getParameters().getMasterVm());
        vmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getMasterVm(), getCluster(), getParameters().getGraphicsDevices());
        vmHandler.autoSelectGraphicsDevice(getVmId(), parameterMasterVm, getCluster(), getParameters().getGraphicsDevices(), getMasterVmCompatibilityVersion());
        separateCustomProperties(parameterMasterVm);
    }
    if (getVm() != null) {
        updateVmDevices();
        images.addAll(getVmDisksFromDB());
        setStoragePoolId(getVm().getStoragePoolId());
        isVmInDb = true;
    } else if (getCluster() != null && parameterMasterVm != null) {
        VM vm = new VM(parameterMasterVm, new VmDynamic(), null);
        vm.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        setVm(vm);
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    updateDiskInfoDestinationMap();
    generateTargetDiskIds();
    parameters.setUseCinderCommandCallback(!getCinderDisks().isEmpty());
}
#method_after
@Override
protected void init() {
    if (Guid.isNullOrEmpty(getParameters().getVmTemplateId())) {
        getParameters().setVmTemplateId(Guid.newGuid());
    }
    setVmTemplateId(getParameters().getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    setVmTemplateName(getParameters().getName());
    VmStatic masterVm = getParameters().getMasterVm();
    if (masterVm != null) {
        setVmId(masterVm.getId());
        setClusterId(masterVm.getClusterId());
        // API backward compatibility
        if (getVmDeviceUtils().shouldOverrideSoundDevice(masterVm, getMasterVmCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            getParameters().setSoundDeviceEnabled(true);
        }
        if (getParameters().isSoundDeviceEnabled() == null) {
            getParameters().setSoundDeviceEnabled(false);
        }
        if (getParameters().isConsoleEnabled() == null) {
            getParameters().setConsoleEnabled(false);
        }
        vmHandler.updateDefaultTimeZone(masterVm);
        vmHandler.autoSelectUsbPolicy(masterVm);
        vmHandler.autoSelectDefaultDisplayType(getVmId(), masterVm, getCluster(), getParameters().getGraphicsDevices());
        vmHandler.autoSelectGraphicsDevice(getVmId(), masterVm, getCluster(), getParameters().getGraphicsDevices(), getMasterVmCompatibilityVersion());
        separateCustomProperties(masterVm);
    }
    if (getVm() != null) {
        updateVmDevices();
        images.addAll(getVmDisksFromDB());
        setStoragePoolId(getVm().getStoragePoolId());
        isVmInDb = true;
    } else if (getCluster() != null && masterVm != null) {
        VM vm = new VM(masterVm, new VmDynamic(), null);
        vm.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        setVm(vm);
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    updateDiskInfoDestinationMap();
    generateTargetDiskIds();
    getParameters().setUseCinderCommandCallback(!getCinderDisks().isEmpty());
}
#end_block

#method_before
protected void updateDiskInfoDestinationMap() {
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<>();
    }
    sourceImageDomainsImageMap = new HashMap<>();
    for (DiskImage image : images) {
        MultiValueMapUtils.addToMap(image.getStorageIds().get(0), image, sourceImageDomainsImageMap);
        if (!diskInfoDestinationMap.containsKey(image.getId())) {
            // The volume's format and type were not specified and thus should be null.
            image.setVolumeFormat(null);
            image.setVolumeType(null);
            diskInfoDestinationMap.put(image.getId(), image);
        }
    }
}
#method_after
private void updateDiskInfoDestinationMap() {
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<>();
    }
    sourceImageDomainsImageMap = new HashMap<>();
    for (DiskImage image : images) {
        MultiValueMapUtils.addToMap(image.getStorageIds().get(0), image, sourceImageDomainsImageMap);
        if (!diskInfoDestinationMap.containsKey(image.getId())) {
            // The volume's format and type were not specified and thus should be null.
            image.setVolumeFormat(null);
            image.setVolumeType(null);
            diskInfoDestinationMap.put(image.getId(), image);
        }
    }
}
#end_block

#method_before
protected void updateVmDevices() {
    getVmDeviceUtils().setVmDevices(getVm().getStaticData());
}
#method_after
private void updateVmDevices() {
    getVmDeviceUtils().setVmDevices(getVm().getStaticData());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = vmDynamicDao.get(getVmId());
        if (!isVmStatusValid(vmDynamic.getStatus())) {
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        vmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (!StringUtils.isEmpty(jobId)) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                getSchedulUtil().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("Failed deleting job '{}' at cancelRecoveryJob", jobId);
            }
        }
    }
    TransactionSupport.executeInNewTransaction(() -> {
        addVmTemplateToDb();
        getCompensationContext().stateChanged();
        return null;
    });
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = addAllTemplateDisks();
    srcDeviceIdToTargetDeviceIdMapping.forEach((oldImageId, newImageId) -> addTemplateDiskVmElement(newImageId, oldImageId));
    TransactionSupport.executeInNewTransaction(() -> {
        addPermission();
        addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
        Set<GraphicsType> graphicsToSkip = getParameters().getGraphicsDevices().keySet();
        if (isVmInDb) {
            getVmDeviceUtils().copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getVmDeviceUtils().hasMemoryBalloon(getVmId()), graphicsToSkip, false, getEffectiveVersion());
        } else {
            // for instance type and new template without a VM
            getVmDeviceUtils().copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), Boolean.TRUE.equals(getParameters().isBalloonEnabled()), graphicsToSkip, false, getEffectiveVersion());
        }
        updateWatchdog(getVmTemplateId());
        updateRngDevice(getVmTemplateId());
        addGraphicsDevice();
        setSucceeded(true);
        return null;
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        vmHandler.warnMemorySizeLegal(getVmTemplate(), getVm().getCompatibilityVersion());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = vmDynamicDao.get(getVmId());
        if (!isVmStatusValid(vmDynamic.getStatus())) {
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        vmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (!StringUtils.isEmpty(jobId)) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                getSchedulerUtil().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("Failed deleting job '{}' at cancelRecoveryJob", jobId);
            }
        }
    }
    TransactionSupport.executeInNewTransaction(() -> {
        addVmTemplateToDb();
        getCompensationContext().stateChanged();
        return null;
    });
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = addAllTemplateDisks();
    srcDeviceIdToTargetDeviceIdMapping.forEach((oldImageId, newImageId) -> addTemplateDiskVmElement(newImageId, oldImageId));
    TransactionSupport.executeInNewTransaction(() -> {
        addPermission();
        addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
        Set<GraphicsType> graphicsToSkip = getParameters().getGraphicsDevices().keySet();
        if (isVmInDb) {
            getVmDeviceUtils().copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getVmDeviceUtils().hasMemoryBalloon(getVmId()), graphicsToSkip, false, getEffectiveCompatibilityVersion());
        } else {
            // for instance type and new template without a VM
            getVmDeviceUtils().copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), Boolean.TRUE.equals(getParameters().isBalloonEnabled()), graphicsToSkip, false, getEffectiveCompatibilityVersion());
        }
        updateWatchdog(getVmTemplateId());
        updateRngDevice(getVmTemplateId());
        addGraphicsDevice();
        setSucceeded(true);
        return null;
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        vmHandler.warnMemorySizeLegal(getVmTemplate(), getVm().getCompatibilityVersion());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean isInstanceType = getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getCluster() == null && !isInstanceType) {
        return failValidation(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
    }
    if (!VmHandler.isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (isVmInDb && !isVmStatusValid(getVm().getStatus())) {
        return failValidation(EngineMessage.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM);
    }
    // be unique also across datacenters.
    if (!isTemplateVersion()) {
        if (isInstanceType) {
            if (isInstanceWithSameNameExists(getVmTemplateName())) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            }
        } else {
            if (isVmTemplateWithSameNameExist(getVmTemplateName(), getCluster().getStoragePoolId())) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            }
        }
    }
    if (isTemplateVersion()) {
        VmTemplate userSelectedBaseTemplate = getBaseTemplate();
        if (userSelectedBaseTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!userSelectedBaseTemplate.isBaseTemplate()) {
            // currently template version cannot be base template
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    if (isTemplateVersion() && getBaseTemplate().isBlank()) {
        return failValidation(EngineMessage.BLANK_TEMPLATE_CANT_HAVE_SUBTEMPLATES);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!isDisksAliasNotEmpty()) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getMasterVm().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getMasterVm().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getMasterVm().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getMasterVm().getLargeIconId(), "Large"))) {
        return false;
    }
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator.VmWatchdogClusterIndependentValidator(getParameters().getWatchdog()).isValid())) {
            return false;
        }
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getMasterVm(), CompatibilityVersionUtils.getEffective(getParameters().getMasterVm(), this::getCluster)))) {
        return false;
    }
    if (getParameters().isSealTemplate() && vmHandler.isWindowsVm(getVm())) {
        return failValidation(EngineMessage.VM_TEMPLATE_CANNOT_SEAL_WINDOWS);
    }
    if (isInstanceType) {
        return true;
    } else {
        return doClusterRelatedChecks();
    }
}
#method_after
@Override
protected boolean validate() {
    boolean isInstanceType = getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getCluster() == null && !isInstanceType) {
        return failValidation(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
    }
    if (!VmHandler.isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (isVmInDb && !isVmStatusValid(getVm().getStatus())) {
        return failValidation(EngineMessage.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM);
    }
    // be unique also across datacenters.
    if (!isTemplateVersion()) {
        if (isInstanceType) {
            if (isInstanceWithSameNameExists(getVmTemplateName())) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            }
        } else {
            if (isVmTemplateWithSameNameExist(getVmTemplateName(), getCluster().getStoragePoolId())) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            }
        }
    }
    if (isTemplateVersion()) {
        VmTemplate userSelectedBaseTemplate = getBaseTemplate();
        if (userSelectedBaseTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!userSelectedBaseTemplate.isBaseTemplate()) {
            // currently template version cannot be base template
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    if (isTemplateVersion() && getBaseTemplate().isBlank()) {
        return failValidation(EngineMessage.BLANK_TEMPLATE_CANT_HAVE_SUBTEMPLATES);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!isDisksAliasNotEmpty()) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getMasterVm().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getMasterVm().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getMasterVm().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getMasterVm().getLargeIconId(), "Large"))) {
        return false;
    }
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator.VmWatchdogClusterIndependentValidator(getParameters().getWatchdog()).isValid())) {
            return false;
        }
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getMasterVm(), CompatibilityVersionUtils.getEffective(getParameters().getMasterVm(), this::getCluster)))) {
        return false;
    }
    if (getParameters().isSealTemplate() && vmHandler.isWindowsVm(getVm())) {
        return failValidation(EngineMessage.VM_TEMPLATE_CANNOT_SEAL_WINDOWS);
    }
    if (isInstanceType) {
        return true;
    }
    return validateCluster() && validateImages() && validate(VmValidator.validateCpuSockets(getParameters().getMasterVm(), getVm().getCompatibilityVersion()));
}
#end_block

#method_before
protected boolean setAndValidateCpuProfile() {
    // cpu profile isn't supported for instance types.
    if (getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE) {
        return true;
    }
    return validate(cpuProfileHelper.setAndValidateCpuProfile(getParameters().getMasterVm(), getUserId()));
}
#method_after
protected boolean setAndValidateCpuProfile() {
    // cpu profile isn't supported for instance types.
    if (getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE) {
        return true;
    }
    return validate(cpuProfileHelper.setAndValidateCpuProfile(getParameters().getMasterVm(), getUserIdIfExternal().orElse(null)));
}
#end_block

#method_before
protected List<DiskImage> createDiskDummiesForSpaceValidations(Collection<DiskImage> disksList) {
    List<DiskImage> dummies = new ArrayList<>(disksList.size());
    for (DiskImage image : disksList) {
        Guid targetSdId = diskInfoDestinationMap.get(image.getId()).getStorageIds().get(0);
        DiskImage dummy = imagesHandler.createDiskImageWithExcessData(image, targetSdId);
        dummies.add(dummy);
    }
    return dummies;
}
#method_after
private List<DiskImage> createDiskDummiesForSpaceValidations(Collection<DiskImage> disksList) {
    List<DiskImage> dummies = new ArrayList<>(disksList.size());
    for (DiskImage image : disksList) {
        Guid targetSdId = diskInfoDestinationMap.get(image.getId()).getStorageIds().get(0);
        DiskImage dummy = imagesHandler.createDiskImageWithExcessData(image, targetSdId);
        dummies.add(dummy);
    }
    return dummies;
}
#end_block

#method_before
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getParameters().getMasterVm().getMaxMemorySizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getThreadsPerCpu(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getClusterId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVdsList(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled(), getParameters().getMasterVm().getCpuProfileId(), getParameters().getMasterVm().getNumaTuneMode(), getParameters().getMasterVm().getAutoConverge(), getParameters().getMasterVm().getMigrateCompressed(), getParameters().getMasterVm().getUserDefinedProperties(), getParameters().getMasterVm().getPredefinedProperties(), getParameters().getMasterVm().getCustomProperties(), getParameters().getMasterVm().getCustomEmulatedMachine(), getParameters().getMasterVm().getCustomCpuName(), getParameters().getMasterVm().getSmallIconId(), getParameters().getMasterVm().getLargeIconId(), getParameters().getMasterVm().getNumOfIoThreads(), getParameters().getMasterVm().getConsoleDisconnectAction(), getParameters().getMasterVm().getCustomCompatibilityVersion(), getParameters().getMasterVm().getMigrationPolicyId(), null));
    updateVmIcons();
    vmTemplateDao.save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    vmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    vmHandler.addVmInitToDB(getVmTemplate());
}
#method_after
private void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getParameters().getMasterVm().getMaxMemorySizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getThreadsPerCpu(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getClusterId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVdsList(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled(), getParameters().getMasterVm().getCpuProfileId(), getParameters().getMasterVm().getNumaTuneMode(), getParameters().getMasterVm().getAutoConverge(), getParameters().getMasterVm().getMigrateCompressed(), getParameters().getMasterVm().getUserDefinedProperties(), getParameters().getMasterVm().getPredefinedProperties(), getParameters().getMasterVm().getCustomProperties(), getParameters().getMasterVm().getCustomEmulatedMachine(), getParameters().getMasterVm().getCustomCpuName(), getParameters().getMasterVm().getSmallIconId(), getParameters().getMasterVm().getLargeIconId(), getParameters().getMasterVm().getNumOfIoThreads(), getParameters().getMasterVm().getConsoleDisconnectAction(), getParameters().getMasterVm().getCustomCompatibilityVersion(), getParameters().getMasterVm().getMigrationPolicyId(), null));
    updateVmIcons();
    vmTemplateDao.save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    vmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    vmHandler.addVmInitToDB(getVmTemplate());
}
#end_block

#method_before
protected void addVmInterfaces(Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping) {
    List<VmNic> interfaces = vmNicDao.getAllForVm(getParameters().getMasterVm().getId());
    for (VmNic iface : interfaces) {
        VmNic iDynamic = new VmNic();
        iDynamic.setId(Guid.newGuid());
        iDynamic.setVmTemplateId(getVmTemplateId());
        iDynamic.setName(iface.getName());
        iDynamic.setVnicProfileId(iface.getVnicProfileId());
        iDynamic.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iDynamic.setType(iface.getType());
        iDynamic.setLinked(iface.isLinked());
        vmNicDao.save(iDynamic);
        srcDeviceIdToTargetDeviceIdMapping.put(iface.getId(), iDynamic.getId());
    }
}
#method_after
private void addVmInterfaces(Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping) {
    List<VmNic> interfaces = vmNicDao.getAllForVm(getParameters().getMasterVm().getId());
    for (VmNic iface : interfaces) {
        VmNic iDynamic = new VmNic();
        iDynamic.setId(Guid.newGuid());
        iDynamic.setVmTemplateId(getVmTemplateId());
        iDynamic.setName(iface.getName());
        iDynamic.setVnicProfileId(iface.getVnicProfileId());
        iDynamic.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iDynamic.setType(iface.getType());
        iDynamic.setLinked(iface.isLinked());
        vmNicDao.save(iDynamic);
        srcDeviceIdToTargetDeviceIdMapping.put(iface.getId(), iDynamic.getId());
    }
}
#end_block

#method_before
private void endDefaultOperations() {
    endUnlockOps();
    // in case of new version of a template, update vms marked to use latest
    if (isTemplateVersion()) {
        updateVmsJobIdMap.put(getParameters().getBaseTemplateId(), StringUtils.EMPTY);
        String jobId = getSchedulUtil().scheduleAOneTimeJob(this, "updateVmVersion", new Class[0], new Object[0], 0, TimeUnit.SECONDS);
        updateVmsJobIdMap.put(getParameters().getBaseTemplateId(), jobId);
    }
}
#method_after
private void endDefaultOperations() {
    endUnlockOps();
    // in case of new version of a template, update vms marked to use latest
    if (isTemplateVersion()) {
        updateVmsJobIdMap.put(getParameters().getBaseTemplateId(), StringUtils.EMPTY);
        String jobId = getSchedulerUtil().scheduleAOneTimeJob(this, "updateVmVersion", new Class[0], new Object[0], 0, TimeUnit.SECONDS);
        updateVmsJobIdMap.put(getParameters().getBaseTemplateId(), jobId);
    }
}
#end_block

#method_before
protected static DiskImage getVolumeInfoFromVdsm(Guid storagePoolId, Guid newStorageDomainID, Guid newImageGroupId, Guid newImageId) {
    return (DiskImage) VdsCommandsHelper.runVdsCommandWithFailover(VDSCommandType.GetVolumeInfo, new GetVolumeInfoVDSCommandParameters(storagePoolId, newStorageDomainID, newImageGroupId, newImageId), storagePoolId, null).getReturnValue();
}
#method_after
protected DiskImage getVolumeInfoFromVdsm(Guid storagePoolId, Guid newStorageDomainID, Guid newImageGroupId, Guid newImageId) {
    return (DiskImage) VdsCommandsHelper.runVdsCommandWithFailover(VDSCommandType.GetVolumeInfo, new GetVolumeInfoVDSCommandParameters(storagePoolId, newStorageDomainID, newImageGroupId, newImageId), storagePoolId, null).getReturnValue();
}
#end_block

#method_before
public QemuImageInfo getQemuImageInfoFromVdsm(Guid storagePoolId, Guid newStorageDomainID, Guid newImageGroupId, Guid newImageId, Guid vdsId, boolean shouldPrepareAndTeardown) {
    if (vdsId == null) {
        vdsId = VdsCommandsHelper.getHostForExecution(storagePoolId, Collections.emptyList());
    }
    QemuImageInfo qemuImageInfo = null;
    if (shouldPrepareAndTeardown) {
        prepareImage(storagePoolId, newStorageDomainID, newImageGroupId, newImageId, vdsId);
    }
    try {
        qemuImageInfo = (QemuImageInfo) resourceManager.runVdsCommand(VDSCommandType.GetQemuImageInfo, new GetVolumeInfoVDSCommandParameters(vdsId, storagePoolId, newStorageDomainID, newImageGroupId, newImageId)).getReturnValue();
    } catch (Exception e) {
        log.error("Unable to get qemu image info from storage", e);
    } finally {
        if (shouldPrepareAndTeardown) {
            teardownImage(storagePoolId, newStorageDomainID, newImageGroupId, newImageId, vdsId);
        }
    }
    return qemuImageInfo;
}
#method_after
public QemuImageInfo getQemuImageInfoFromVdsm(Guid storagePoolId, Guid newStorageDomainID, Guid newImageGroupId, Guid newImageId, Guid vdsId, boolean shouldPrepareAndTeardown) {
    if (vdsId == null) {
        vdsId = VdsCommandsHelper.getHostForExecution(storagePoolId, Collections.emptyList());
    }
    QemuImageInfo qemuImageInfo = null;
    if (shouldPrepareAndTeardown) {
        prepareImage(storagePoolId, newStorageDomainID, newImageGroupId, newImageId, vdsId);
    }
    try {
        qemuImageInfo = (QemuImageInfo) resourceManager.runVdsCommand(VDSCommandType.GetQemuImageInfo, new GetVolumeInfoVDSCommandParameters(vdsId, storagePoolId, newStorageDomainID, newImageGroupId, newImageId)).getReturnValue();
    } catch (Exception e) {
        log.error("Unable to get qemu image info from storage", e);
    } finally {
        if (shouldPrepareAndTeardown) {
            try {
                teardownImage(storagePoolId, newStorageDomainID, newImageGroupId, newImageId, vdsId);
            } catch (Exception e) {
                log.warn("Unable to tear down image", e);
            }
        }
    }
    return qemuImageInfo;
}
#end_block

#method_before
public Long determineImageInitialSize(Image sourceImage, VolumeFormat destFormat, Guid storagePoolId, Guid srcDomain, Guid dstDomain, Guid imageGroupID) {
    // need to pass initial size (it can be only preallocated).
    if (isInitialSizeSupportedForFormat(destFormat, dstDomain)) {
        // TODO: inspect if we can rely on the database to get the actual size.
        DiskImage imageInfoFromStorage = getVolumeInfoFromVdsm(storagePoolId, srcDomain, imageGroupID, sourceImage.getId());
        // space.
        return computeCowImageNeededSize(imageInfoFromStorage.getActualSizeInBytes());
    }
    return null;
}
#method_after
public Long determineImageInitialSize(Image sourceImage, VolumeFormat destFormat, Guid storagePoolId, Guid srcDomain, Guid dstDomain, Guid imageGroupID) {
    // need to pass initial size (it can be only preallocated).
    if (isInitialSizeSupportedForFormat(destFormat, dstDomain)) {
        // TODO: inspect if we can rely on the database to get the actual size.
        DiskImage imageInfoFromStorage = getVolumeInfoFromVdsm(storagePoolId, srcDomain, imageGroupID, sourceImage.getId());
        return computeCowImageNeededSize(sourceImage.getVolumeFormat(), imageInfoFromStorage.getActualSizeInBytes());
    }
    return null;
}
#end_block

#method_before
private static long computeCowImageNeededSize(long actualSize) {
    return Double.valueOf(Math.ceil(actualSize / StorageConstants.QCOW_OVERHEAD_FACTOR)).longValue();
}
#method_after
private static long computeCowImageNeededSize(VolumeFormat sourceFormat, long actualSize) {
    // space.
    return sourceFormat == VolumeFormat.COW ? Double.valueOf(Math.ceil(actualSize / StorageConstants.QCOW_OVERHEAD_FACTOR)).longValue() : actualSize;
}
#end_block

#method_before
public Long determineTotalImageInitialSize(DiskImage sourceImage, VolumeFormat destFormat, Guid dstDomain) {
    if (isInitialSizeSupportedForFormat(destFormat, dstDomain)) {
        double totalSizeForClonedDisk = getTotalActualSizeOfDisk(sourceImage, storageDomainDao.get(dstDomain).getStorageStaticData());
        return computeCowImageNeededSize(Double.valueOf(totalSizeForClonedDisk).longValue());
    }
    return null;
}
#method_after
public Long determineTotalImageInitialSize(DiskImage sourceImage, VolumeFormat destFormat, Guid dstDomain) {
    if (isInitialSizeSupportedForFormat(destFormat, dstDomain)) {
        double totalSizeForClonedDisk = getTotalActualSizeOfDisk(sourceImage, storageDomainDao.get(dstDomain).getStorageStaticData());
        return computeCowImageNeededSize(sourceImage.getVolumeFormat(), Double.valueOf(totalSizeForClonedDisk).longValue());
    }
    return null;
}
#end_block

#method_before
private void cloneStructureNotCollapsed() {
    CloneImageGroupVolumesStructureCommandParameters p = new CloneImageGroupVolumesStructureCommandParameters(getParameters().getStoragePoolId(), getParameters().getSrcDomain(), getParameters().getDestDomain(), getParameters().getImageGroupID(), getParameters().getDestinationFormat(), getActionType(), getParameters());
    p.setParentParameters(getParameters());
    p.setParentCommand(getActionType());
    p.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    p.setJobWeight(getParameters().getOperationsJobWeight().get(CopyStage.DEST_CREATION.name()));
    runInternalAction(VdcActionType.CloneImageGroupVolumesStructure, p);
}
#method_after
private void cloneStructureNotCollapsed() {
    CloneImageGroupVolumesStructureCommandParameters p = new CloneImageGroupVolumesStructureCommandParameters(getParameters().getStoragePoolId(), getParameters().getSrcDomain(), getParameters().getDestDomain(), getParameters().getImageGroupID(), getActionType(), getParameters());
    p.setParentParameters(getParameters());
    p.setParentCommand(getActionType());
    p.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    p.setJobWeight(getParameters().getOperationsJobWeight().get(CopyStage.DEST_CREATION.name()));
    runInternalAction(VdcActionType.CloneImageGroupVolumesStructure, p);
}
#end_block

#method_before
private void populateDiskSnapshotsInfoFromStorage() {
    getDiskImage().getSnapshots().clear();
    List<DiskImage> images = diskImageDao.getAllSnapshotsForImageGroup(getParameters().getImageGroupID());
    for (DiskImage image : images) {
        getDiskImage().getSnapshots().add(ImagesHandler.getVolumeInfoFromVdsm(getParameters().getStoragePoolId(), getParameters().getSrcDomain(), getParameters().getImageGroupID(), image.getImageId()));
    }
}
#method_after
private void populateDiskSnapshotsInfoFromStorage() {
    getDiskImage().getSnapshots().clear();
    List<DiskImage> images = diskImageDao.getAllSnapshotsForImageGroup(getParameters().getImageGroupID());
    for (DiskImage image : images) {
        getDiskImage().getSnapshots().add(imagesHandler.getVolumeInfoFromVdsm(getParameters().getStoragePoolId(), getParameters().getSrcDomain(), getParameters().getImageGroupID(), image.getImageId()));
    }
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    if (getDestinationDiskImage() != null) {
        Guid storagePoolId = getDestinationDiskImage().getStoragePoolId() != null ? getDestinationDiskImage().getStoragePoolId() : Guid.Empty;
        setStoragePoolId(storagePoolId);
        Guid newImageGroupId = getDestinationDiskImage().getId() != null ? getDestinationDiskImage().getId() : Guid.Empty;
        Guid newImageId = getDestinationDiskImage().getImageId();
        Guid newStorageDomainID = getDestinationDiskImage().getStorageIds().get(0);
        // complete IRS data to DB disk image:
        try {
            DiskImage newImageIRS = getVolumeInfo(storagePoolId, newStorageDomainID, newImageGroupId, newImageId);
            if (newImageIRS != null) {
                completeImageData(newImageIRS);
                // Set volume type/format before updating DB in the 'finally' branch
                getDestinationDiskImage().getImage().setVolumeType(newImageIRS.getVolumeType());
                getDestinationDiskImage().getImage().setVolumeFormat(newImageIRS.getVolumeFormat());
                if (newImageIRS.getVolumeFormat().equals(VolumeFormat.COW)) {
                    setQcowCompatByQemuImageInfo(storagePoolId, newImageGroupId, newImageId, newStorageDomainID);
                }
            }
        } catch (EngineException e) {
            // Logging only
            log.error("Unable to update the image info for image '{}' (image group: '{}') on domain '{}'", newImageId, newImageGroupId, newStorageDomainID);
        } finally {
            if (!getParameters().isLeaveLocked()) {
                getDestinationDiskImage().setImageStatus(ImageStatus.OK);
            }
            imageDao.update(getDestinationDiskImage().getImage());
        }
    }
    if (!getParameters().isLeaveLocked()) {
        unLockImage();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    if (getDestinationDiskImage() != null) {
        Guid storagePoolId = getDestinationDiskImage().getStoragePoolId() != null ? getDestinationDiskImage().getStoragePoolId() : Guid.Empty;
        setStoragePoolId(storagePoolId);
        Guid newImageGroupId = getDestinationDiskImage().getId() != null ? getDestinationDiskImage().getId() : Guid.Empty;
        Guid newImageId = getDestinationDiskImage().getImageId();
        Guid newStorageDomainID = getDestinationDiskImage().getStorageIds().get(0);
        // complete IRS data to DB disk image:
        try {
            DiskImage newImageIRS = getVolumeInfo(storagePoolId, newStorageDomainID, newImageGroupId, newImageId);
            if (newImageIRS != null) {
                completeImageData(newImageIRS);
                // Set volume type/format before updating DB in the 'finally' branch
                getDestinationDiskImage().getImage().setVolumeType(newImageIRS.getVolumeType());
                getDestinationDiskImage().getImage().setVolumeFormat(newImageIRS.getVolumeFormat());
                if (newImageIRS.getVolumeFormat().equals(VolumeFormat.COW)) {
                    setQcowCompatByQemuImageInfo(storagePoolId, newImageGroupId, newImageId, newStorageDomainID, getDestinationDiskImage());
                }
            }
        } catch (EngineException e) {
            // Logging only
            log.error("Unable to update the image info for image '{}' (image group: '{}') on domain '{}'", newImageId, newImageGroupId, newStorageDomainID);
        } finally {
            if (!getParameters().isLeaveLocked()) {
                getDestinationDiskImage().setImageStatus(ImageStatus.OK);
            }
            imageDao.update(getDestinationDiskImage().getImage());
        }
    }
    if (!getParameters().isLeaveLocked()) {
        unLockImage();
    }
    setSucceeded(true);
}
#end_block

#method_before
private void setQcowCompatByQemuImageInfo(Guid storagePoolId, Guid newImageGroupId, Guid newImageId, Guid newStorageDomainID) {
    // If the VM is running then the volume is already prepared in the guest's host so there
    // is no need for prepare and teardown.
    Guid hostIdToExecuteQemuImageInfo = null;
    List<Pair<VM, VmDevice>> attachedVmsInfo = vmDao.getVmsWithPlugInfo(getDestinationDiskImage().getId());
    for (Pair<VM, VmDevice> pair : attachedVmsInfo) {
        VM vm = pair.getFirst();
        if (Boolean.TRUE.equals(pair.getSecond().isPlugged())) {
            if (vm.isStartingOrUp()) {
                hostIdToExecuteQemuImageInfo = vm.getRunOnVds();
                break;
            }
        }
    }
    setQcowCompat(getDestinationDiskImage().getImage(), storagePoolId, newImageGroupId, newImageId, newStorageDomainID, hostIdToExecuteQemuImageInfo);
}
#method_after
protected void setQcowCompatByQemuImageInfo(Guid storagePoolId, Guid newImageGroupId, Guid newImageId, Guid newStorageDomainID, DiskImage diskImage) {
    // If the VM is running then the volume is already prepared in the guest's host so there
    // is no need for prepare and teardown.
    Guid hostIdToExecuteQemuImageInfo = null;
    List<Pair<VM, VmDevice>> attachedVmsInfo = vmDao.getVmsWithPlugInfo(diskImage.getId());
    for (Pair<VM, VmDevice> pair : attachedVmsInfo) {
        VM vm = pair.getFirst();
        if (Boolean.TRUE.equals(pair.getSecond().isPlugged())) {
            if (vm.isStartingOrUp()) {
                hostIdToExecuteQemuImageInfo = vm.getRunOnVds();
                break;
            }
        }
    }
    setQcowCompat(diskImage.getImage(), storagePoolId, newImageGroupId, newImageId, newStorageDomainID, hostIdToExecuteQemuImageInfo);
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    if (getDiskImage() != null && getDiskImage().getVmEntityType().isTemplateType()) {
        initVmTemplateId();
    }
}
#method_after
@Override
protected void init() {
    super.init();
    if (getDiskImage() != null && getDiskImage().getVmEntityType() != null && getDiskImage().getVmEntityType().isTemplateType()) {
        initVmTemplateId();
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    DiskValidator diskValidator = new DiskValidator(getDiskImage());
    if (!validate(diskValidator.isDiskExists()) || !validate(diskValidator.isDiskPluggedToVmsThatAreNotDown(false, vmsForDisk)) || !validate(diskValidator.isSparsifySupported())) {
        return false;
    }
    if (diskImageDao.getAllSnapshotsForImageGroup(getDiskImage().getId()).size() > 1) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_HAS_SNAPSHOTS);
    }
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(Collections.singletonList(getDiskImage()));
    return validate(diskImagesValidator.diskImagesNotIllegal()) && validate(diskImagesValidator.diskImagesNotLocked()) && validate(diskImagesValidator.diskImagesHaveNoDerivedDisks(null));
}
#method_after
@Override
protected boolean validate() {
    DiskValidator diskValidator = new DiskValidator(getDiskImage());
    if (!validate(diskValidator.isDiskExists()) || !validate(diskValidator.isDiskPluggedToVmsThatAreNotDown(false, getVmsForDisk())) || !validate(diskValidator.isSparsifySupported())) {
        return false;
    }
    if (diskImageDao.getAllSnapshotsForImageGroup(getDiskImage().getId()).size() > 1) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_HAS_SNAPSHOTS);
    }
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(Collections.singletonList(getDiskImage()));
    return validate(diskImagesValidator.diskImagesNotIllegal()) && validate(diskImagesValidator.diskImagesNotLocked()) && validate(diskImagesValidator.diskImagesHaveNoDerivedDisks(null));
}
#end_block

#method_before
private Map<String, Pair<String, String>> getSharedLocksForVmDisk() {
    Map<String, Pair<String, String>> sharedLocks = new HashMap<>();
    if (vmsForDisk != null) {
        for (Pair<VM, VmDevice> vmForDisk : vmsForDisk) {
            sharedLocks.put(vmForDisk.getFirst().getId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, EngineMessage.ACTION_TYPE_FAILED_VM_IS_LOCKED));
        }
    }
    return sharedLocks;
}
#method_after
private Map<String, Pair<String, String>> getSharedLocksForVmDisk() {
    Map<String, Pair<String, String>> sharedLocks = new HashMap<>();
    if (getVmsForDisk() != null) {
        for (Pair<VM, VmDevice> vmForDisk : getVmsForDisk()) {
            sharedLocks.put(vmForDisk.getFirst().getId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, EngineMessage.ACTION_TYPE_FAILED_VM_IS_LOCKED));
        }
    }
    return sharedLocks;
}
#end_block

#method_before
private void createImage(DiskImage image) {
    CreateVolumeContainerCommandParameters parameters = new CreateVolumeContainerCommandParameters(getParameters().getStoragePoolId(), getParameters().getDestDomain(), determineSourceImageGroup(image), image.getParentId(), getParameters().getImageGroupID(), image.getImageId(), getParameters().getDestFormat(), getParameters().getDescription(), image.getSize(), imagesHandler.determineImageInitialSize(image.getImage(), getParameters().getDestFormat(), getParameters().getStoragePoolId(), getParameters().getSrcDomain(), getParameters().getDestDomain(), getParameters().getImageGroupID()));
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setJobWeight(getParameters().getOperationsJobWeight().get(image.getImageId().toString()));
    runInternalActionWithTasksContext(VdcActionType.CreateVolumeContainer, parameters);
}
#method_after
private void createImage(DiskImage image) {
    CreateVolumeContainerCommandParameters parameters = new CreateVolumeContainerCommandParameters(getParameters().getStoragePoolId(), getParameters().getDestDomain(), determineSourceImageGroup(image), image.getParentId(), getParameters().getImageGroupID(), image.getImageId(), image.getVolumeFormat(), getParameters().getDescription(), image.getSize(), imagesHandler.determineImageInitialSize(image.getImage(), image.getVolumeFormat(), getParameters().getStoragePoolId(), getParameters().getSrcDomain(), getParameters().getDestDomain(), getParameters().getImageGroupID()));
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setJobWeight(getParameters().getOperationsJobWeight().get(image.getImageId().toString()));
    runInternalActionWithTasksContext(VdcActionType.CreateVolumeContainer, parameters);
}
#end_block

#method_before
protected void endActionOnAllImageGroups() {
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        getBackend().endAction(VdcActionType.CopyImageGroup, p, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
        initQcowVersionForDisks(((MoveOrCopyImageGroupParameters) p).getDestImageGroupId());
    }
}
#method_after
protected void endActionOnAllImageGroups() {
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        getBackend().endAction(VdcActionType.CopyImageGroup, p, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
    }
}
#end_block

#method_before
@Override
public boolean performNextOperation(int completedChildCount) {
    if (getParameters().getNextStep() == null) {
        return false;
    }
    switch(getParameters().getNextStep()) {
        case GEO_REP:
            GlusterVolumeGeoRepSessionParameters parameters = new GlusterVolumeGeoRepSessionParameters(getSession().getMasterVolumeId(), getSession().getId());
            parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
            parameters.setParentCommand(getActionType());
            parameters.setParentParameters(getParameters());
            getParameters().setNextStep(DRStep.REMOVE_TMP_SNAPSHOTS);
            CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.GlusterStorageGeoRepSyncInternal, parameters, cloneContextAndDetachFromParent());
            persistCommandIfNeeded();
            break;
        case REMOVE_TMP_SNAPSHOTS:
            removeDRSnapshots();
            getParameters().setNextStep(null);
            persistCommandIfNeeded();
            break;
    }
    return true;
}
#method_after
@Override
public boolean performNextOperation(int completedChildCount) {
    if (getParameters().getNextStep() == null) {
        return false;
    }
    switch(getParameters().getNextStep()) {
        case GEO_REP:
            GlusterVolumeGeoRepSessionParameters parameters = new GlusterVolumeGeoRepSessionParameters(getSession().getMasterVolumeId(), getSession().getId());
            parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
            parameters.setParentCommand(getActionType());
            parameters.setParentParameters(getParameters());
            getParameters().setNextStep(DRStep.REMOVE_TMP_SNAPSHOTS);
            runInternalActionWithTasksContext(VdcActionType.GlusterStorageGeoRepSyncInternal, parameters);
            persistCommandIfNeeded();
            break;
        case REMOVE_TMP_SNAPSHOTS:
            removeDRSnapshots();
            getParameters().setNextStep(null);
            persistCommandIfNeeded();
            break;
    }
    return true;
}
#end_block

#method_before
private void configureTimeouts(DefaultHttpClient httpClient) {
    int socketTimeOut = Config.<Integer>getValue(ConfigValues.ExternalNetworkProviderTimeout) * 1000;
    int connectionTimeOut = Config.<Integer>getValue(ConfigValues.ExternalNetworkProviderConnectionTimeout) * 1000;
    HttpParams params = httpClient.getParams();
    HttpConnectionParams.setConnectionTimeout(params, connectionTimeOut);
    HttpConnectionParams.setSoTimeout(params, socketTimeOut);
}
#method_after
private void configureTimeouts(DefaultHttpClient httpClient) {
    long socketTimeOut = TimeUnit.SECONDS.toMillis(Config.<Integer>getValue(ConfigValues.ExternalNetworkProviderTimeout));
    long connectionTimeOut = TimeUnit.SECONDS.toMillis(Config.<Integer>getValue(ConfigValues.ExternalNetworkProviderConnectionTimeout));
    HttpParams params = httpClient.getParams();
    HttpConnectionParams.setConnectionTimeout(params, toIntExact(connectionTimeOut));
    HttpConnectionParams.setSoTimeout(params, toIntExact(socketTimeOut));
}
#end_block

#method_before
private void registerExternalProvidersTrustStore(DefaultHttpClient httpClient) {
    try {
        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        FileInputStream inputStream = new FileInputStream(new File(EngineLocalConfig.getInstance().getExternalProvidersTrustStore().getAbsolutePath()));
        try {
            trustStore.load(inputStream, EngineLocalConfig.getInstance().getExternalProvidersTrustStorePassword().toCharArray());
        } finally {
            inputStream.close();
        }
        SSLSocketFactory socketFactory = new SSLSocketFactory(trustStore);
        Scheme sch = new Scheme("https", 443, socketFactory);
        httpClient.getConnectionManager().getSchemeRegistry().register(sch);
    } catch (Exception ex) {
        log.warn("Cannot register external providers trust store: ", ex);
    }
}
#method_after
private void registerExternalProvidersTrustStore(DefaultHttpClient httpClient) {
    try (FileInputStream inputStream = new FileInputStream(new File(EngineLocalConfig.getInstance().getExternalProvidersTrustStore().getAbsolutePath()))) {
        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        trustStore.load(inputStream, EngineLocalConfig.getInstance().getExternalProvidersTrustStorePassword().toCharArray());
        SSLSocketFactory socketFactory = new SSLSocketFactory(trustStore);
        Scheme scheme = new Scheme("https", 443, socketFactory);
        httpClient.getConnectionManager().getSchemeRegistry().register(scheme);
    } catch (Exception ex) {
        log.warn("Cannot register external providers trust store: {}", ex.getMessage());
        log.debug("Exception", ex);
    }
}
#end_block

#method_before
private Quantum getClient() {
    if (client == null) {
        client = new Quantum(provider.getUrl() + API_VERSION, new CustomizedRESTEasyConnector());
        if (provider.isRequiringAuthentication()) {
            setClientTokenProvider(client);
        }
    }
    return client;
}
#method_after
private Quantum getClient() {
    if (client == null) {
        client = new Quantum(getProvider().getUrl() + API_VERSION, new CustomizedRESTEasyConnector());
        if (getProvider().isRequiringAuthentication()) {
            setClientTokenProvider(client);
        }
    }
    return client;
}
#end_block

#method_before
protected void setClientTokenProvider(Quantum client) {
    String tenantName = provider.getAdditionalProperties().getTenantName();
    KeystoneTokenProvider keystoneTokenProvider = new KeystoneTokenProvider(provider.getAuthUrl(), provider.getUsername(), provider.getPassword());
    client.setTokenProvider(keystoneTokenProvider.getProviderByTenant(tenantName));
}
#method_after
protected void setClientTokenProvider(Quantum client) {
    String tenantName = getProvider().getAdditionalProperties().getTenantName();
    KeystoneTokenProvider keystoneTokenProvider = new KeystoneTokenProvider(getProvider().getAuthUrl(), getProvider().getUsername(), getProvider().getPassword());
    client.setTokenProvider(keystoneTokenProvider.getProviderByTenant(tenantName));
}
#end_block

#method_before
protected com.woorea.openstack.quantum.model.Network createNewNetworkEntity(Network network) {
    com.woorea.openstack.quantum.model.Network networkForCreate = new com.woorea.openstack.quantum.model.Network();
    networkForCreate.setAdminStateUp(true);
    networkForCreate.setName(network.getName());
    if (NetworkUtils.isLabeled(network)) {
        networkForCreate.setProviderPhysicalNetwork(network.getLabel());
        if (NetworkUtils.isVlan(network)) {
            networkForCreate.setProviderNetworkType(VLAN_NETWORK);
            networkForCreate.setProviderSegmentationId(network.getVlanId());
        } else {
            networkForCreate.setProviderNetworkType(FLAT_NETWORK);
        }
    }
    if (!provider.isRequiringAuthentication()) {
        networkForCreate.setTenantId(DEVICE_OWNER);
    }
    return networkForCreate;
}
#method_after
protected com.woorea.openstack.quantum.model.Network createNewNetworkEntity(Network network) {
    com.woorea.openstack.quantum.model.Network networkForCreate = new com.woorea.openstack.quantum.model.Network();
    networkForCreate.setAdminStateUp(true);
    networkForCreate.setName(network.getName());
    if (NetworkUtils.isLabeled(network)) {
        networkForCreate.setProviderPhysicalNetwork(network.getLabel());
        if (NetworkUtils.isVlan(network)) {
            networkForCreate.setProviderNetworkType(VLAN_NETWORK);
            networkForCreate.setProviderSegmentationId(network.getVlanId());
        } else {
            networkForCreate.setProviderNetworkType(FLAT_NETWORK);
        }
    }
    if (!getProvider().isRequiringAuthentication()) {
        networkForCreate.setTenantId(DEVICE_OWNER);
    }
    return networkForCreate;
}
#end_block

#method_before
private List<Network> map(List<com.woorea.openstack.quantum.model.Network> externalNetworks) {
    List<Network> networks = new ArrayList<>(externalNetworks.size());
    for (com.woorea.openstack.quantum.model.Network externalNetwork : externalNetworks) {
        Network network = new Network();
        network.setVmNetwork(true);
        network.setProvidedBy(new ProviderNetwork(provider.getId(), externalNetwork.getId()));
        network.setName(externalNetwork.getName());
        networks.add(network);
    }
    return networks;
}
#method_after
private List<Network> map(List<com.woorea.openstack.quantum.model.Network> externalNetworks) {
    List<Network> networks = new ArrayList<>(externalNetworks.size());
    for (com.woorea.openstack.quantum.model.Network externalNetwork : externalNetworks) {
        Network network = new Network();
        network.setVmNetwork(true);
        network.setProvidedBy(new ProviderNetwork(getProvider().getId(), externalNetwork.getId()));
        network.setName(externalNetwork.getName());
        networks.add(network);
    }
    return networks;
}
#end_block

#method_before
protected Map<String, String> createPortAllocationRuntimeProperties(Port port) {
    Map<String, String> runtimeProperties = new HashMap<>();
    runtimeProperties.put("vnic_id", port.getId());
    String providerType = provider.getType().name();
    runtimeProperties.put("provider_type", providerType);
    if (port.getSecurityGroups() != null && !port.getSecurityGroups().isEmpty()) {
        runtimeProperties.put("security_groups", StringUtils.join(port.getSecurityGroups(), ','));
    }
    return runtimeProperties;
}
#method_after
protected Map<String, String> createPortAllocationRuntimeProperties(Port port) {
    Map<String, String> runtimeProperties = new HashMap<>();
    runtimeProperties.put("vnic_id", port.getId());
    String providerType = getProvider().getType().name();
    runtimeProperties.put("provider_type", providerType);
    if (port.getSecurityGroups() != null && !port.getSecurityGroups().isEmpty()) {
        runtimeProperties.put("security_groups", StringUtils.join(port.getSecurityGroups(), ','));
    }
    return runtimeProperties;
}
#end_block

#method_before
private Quantum getClient() {
    if (client == null) {
        client = new Quantum(provider.getUrl() + API_VERSION, new CustomizedRESTEasyConnector());
        if (provider.isRequiringAuthentication()) {
            setClientTokenProvider(client);
        }
    }
    return client;
}
#method_after
private Quantum getClient() {
    if (client == null) {
        client = new Quantum(getProvider().getUrl() + API_VERSION, new CustomizedRESTEasyConnector());
        if (getProvider().isRequiringAuthentication()) {
            setClientTokenProvider(client);
        }
    }
    return client;
}
#end_block

#method_before
protected void setClientTokenProvider(Quantum client) {
    String tenantName = provider.getAdditionalProperties().getTenantName();
    KeystoneTokenProvider keystoneTokenProvider = new KeystoneTokenProvider(provider.getAuthUrl(), provider.getUsername(), provider.getPassword());
    client.setTokenProvider(keystoneTokenProvider.getProviderByTenant(tenantName));
}
#method_after
protected void setClientTokenProvider(Quantum client) {
    String tenantName = getProvider().getAdditionalProperties().getTenantName();
    KeystoneTokenProvider keystoneTokenProvider = new KeystoneTokenProvider(getProvider().getAuthUrl(), getProvider().getUsername(), getProvider().getPassword());
    client.setTokenProvider(keystoneTokenProvider.getProviderByTenant(tenantName));
}
#end_block

#method_before
protected com.woorea.openstack.quantum.model.Network createNewNetworkEntity(Network network) {
    com.woorea.openstack.quantum.model.Network networkForCreate = new com.woorea.openstack.quantum.model.Network();
    networkForCreate.setAdminStateUp(true);
    networkForCreate.setName(network.getName());
    if (NetworkUtils.isLabeled(network)) {
        networkForCreate.setProviderPhysicalNetwork(network.getLabel());
        if (NetworkUtils.isVlan(network)) {
            networkForCreate.setProviderNetworkType(VLAN_NETWORK);
            networkForCreate.setProviderSegmentationId(network.getVlanId());
        } else {
            networkForCreate.setProviderNetworkType(FLAT_NETWORK);
        }
    }
    if (!provider.isRequiringAuthentication()) {
        networkForCreate.setTenantId(DEVICE_OWNER);
    }
    return networkForCreate;
}
#method_after
protected com.woorea.openstack.quantum.model.Network createNewNetworkEntity(Network network) {
    com.woorea.openstack.quantum.model.Network networkForCreate = new com.woorea.openstack.quantum.model.Network();
    networkForCreate.setAdminStateUp(true);
    networkForCreate.setName(network.getName());
    if (NetworkUtils.isLabeled(network)) {
        networkForCreate.setProviderPhysicalNetwork(network.getLabel());
        if (NetworkUtils.isVlan(network)) {
            networkForCreate.setProviderNetworkType(VLAN_NETWORK);
            networkForCreate.setProviderSegmentationId(network.getVlanId());
        } else {
            networkForCreate.setProviderNetworkType(FLAT_NETWORK);
        }
    }
    if (!getProvider().isRequiringAuthentication()) {
        networkForCreate.setTenantId(DEVICE_OWNER);
    }
    return networkForCreate;
}
#end_block

#method_before
private List<Network> map(List<com.woorea.openstack.quantum.model.Network> externalNetworks) {
    List<Network> networks = new ArrayList<>(externalNetworks.size());
    for (com.woorea.openstack.quantum.model.Network externalNetwork : externalNetworks) {
        Network network = new Network();
        network.setVmNetwork(true);
        network.setProvidedBy(new ProviderNetwork(provider.getId(), externalNetwork.getId()));
        network.setName(externalNetwork.getName());
        networks.add(network);
    }
    return networks;
}
#method_after
private List<Network> map(List<com.woorea.openstack.quantum.model.Network> externalNetworks) {
    List<Network> networks = new ArrayList<>(externalNetworks.size());
    for (com.woorea.openstack.quantum.model.Network externalNetwork : externalNetworks) {
        Network network = new Network();
        network.setVmNetwork(true);
        network.setProvidedBy(new ProviderNetwork(getProvider().getId(), externalNetwork.getId()));
        network.setName(externalNetwork.getName());
        networks.add(network);
    }
    return networks;
}
#end_block

#method_before
protected Map<String, String> createPortAllocationRuntimeProperties(Port port) {
    Map<String, String> runtimeProperties = new HashMap<>();
    runtimeProperties.put("vnic_id", port.getId());
    String providerType = provider.getType().name();
    runtimeProperties.put("provider_type", providerType);
    if (port.getSecurityGroups() != null && !port.getSecurityGroups().isEmpty()) {
        runtimeProperties.put("security_groups", StringUtils.join(port.getSecurityGroups(), ','));
    }
    return runtimeProperties;
}
#method_after
protected Map<String, String> createPortAllocationRuntimeProperties(Port port) {
    Map<String, String> runtimeProperties = new HashMap<>();
    runtimeProperties.put("vnic_id", port.getId());
    String providerType = getProvider().getType().name();
    runtimeProperties.put("provider_type", providerType);
    if (port.getSecurityGroups() != null && !port.getSecurityGroups().isEmpty()) {
        runtimeProperties.put("security_groups", StringUtils.join(port.getSecurityGroups(), ','));
    }
    return runtimeProperties;
}
#end_block

#method_before
public HostUpgradeManagerResult checkForUpdates(VDS host) {
    AuditLogableBase auditLog = Injector.injectMembers(new AuditLogableBase());
    auditLog.setVds(host);
    if (!vdsDynamicDao.get(host.getId()).getStatus().isEligibleForOnDemandCheckUpdates()) {
        log.warn("Check for available updates is skipped for host '{}' due to unsupported host status '{}' ", host.getName(), host.getStatus());
        auditLog.addCustomValue("VdsStatus", host.getStatus().toString());
        auditLogDirector.log(auditLog, AuditLogType.HOST_AVAILABLE_UPDATES_SKIPPED_UNSUPPORTED_STATUS);
        return null;
    }
    HostUpgradeManagerResult updatesResult = null;
    try {
        updatesResult = availableUpdatesFinder.checkForUpdates(host);
        if (updatesResult.isUpdatesAvailable()) {
            String message = updatesResult.getAvailablePackages() == null ? "found updates." : String.format("found updates for packages %s", StringUtils.join(updatesResult.getAvailablePackages(), ", "));
            auditLog.addCustomValue("Message", message);
        } else {
            auditLog.addCustomValue("Message", "no updates found.");
        }
        auditLogDirector.log(auditLog, AuditLogType.HOST_AVAILABLE_UPDATES_FINISHED);
    } catch (IllegalStateException e) {
        log.warn(e.getMessage());
        auditLogDirector.log(auditLog, AuditLogType.HOST_AVAILABLE_UPDATES_PROCESS_IS_ALREADY_RUNNING);
    } catch (Exception e) {
        log.error("Failed to check if updates are available for host '{}' with error message '{}'", host.getName(), e.getMessage());
        log.debug("Exception", e);
        auditLog.addCustomValue("Message", StringUtils.defaultString(e.getMessage(), e.getCause() == null ? null : e.getCause().toString()));
        auditLogDirector.log(auditLog, AuditLogType.HOST_AVAILABLE_UPDATES_FAILED);
    }
    if (updatesResult != null && updatesResult.isUpdatesAvailable() != host.isUpdateAvailable()) {
        VdsManager hostManager = resourceManager.getVdsManager(host.getId());
        synchronized (hostManager) {
            hostManager.updateUpdateAvailable(updatesResult.isUpdatesAvailable());
        }
    }
    return updatesResult;
}
#method_after
public HostUpgradeManagerResult checkForUpdates(VDS host) {
    AuditLogableBase auditLog = new AuditLogableBase();
    auditLog.addCustomValue("VdsName", host.getName());
    if (!vdsDynamicDao.get(host.getId()).getStatus().isEligibleForOnDemandCheckUpdates()) {
        log.warn("Check for available updates is skipped for host '{}' due to unsupported host status '{}' ", host.getName(), host.getStatus());
        auditLogDirector.log(auditLog, AuditLogType.HOST_AVAILABLE_UPDATES_SKIPPED_UNSUPPORTED_STATUS);
        return null;
    }
    HostUpgradeManagerResult updatesResult = null;
    try {
        updatesResult = availableUpdatesFinder.checkForUpdates(host);
        if (updatesResult.isUpdatesAvailable()) {
            String message = updatesResult.getAvailablePackages() == null ? "found updates." : String.format("found updates for packages %s", StringUtils.join(updatesResult.getAvailablePackages(), ", "));
            auditLog.addCustomValue("Message", message);
        } else {
            auditLog.addCustomValue("Message", "no updates found.");
        }
        auditLogDirector.log(auditLog, AuditLogType.HOST_AVAILABLE_UPDATES_FINISHED);
    } catch (IllegalStateException e) {
        log.warn(e.getMessage());
        auditLogDirector.log(auditLog, AuditLogType.HOST_AVAILABLE_UPDATES_PROCESS_IS_ALREADY_RUNNING);
    } catch (Exception e) {
        log.error("Failed to check if updates are available for host '{}' with error message '{}'", host.getName(), e.getMessage());
        log.debug("Exception", e);
        auditLog.addCustomValue("Message", StringUtils.defaultString(e.getMessage(), e.getCause() == null ? null : e.getCause().toString()));
        auditLogDirector.log(auditLog, AuditLogType.HOST_AVAILABLE_UPDATES_FAILED);
    }
    if (updatesResult != null && updatesResult.isUpdatesAvailable() != host.isUpdateAvailable()) {
        VdsManager hostManager = resourceManager.getVdsManager(host.getId());
        synchronized (hostManager) {
            hostManager.updateUpdateAvailable(updatesResult.isUpdatesAvailable());
        }
    }
    return updatesResult;
}
#end_block

#method_before
protected void setQcowCompatForSnapshot(DiskImage snapshot, DiskImage volInfo) {
    if (snapshot.getVolumeFormat().equals(VolumeFormat.COW)) {
        try {
            if (volInfo == null) {
                volInfo = getVolumeInfo(snapshot.getStoragePoolId(), getParameters().getStorageDomainId(), snapshot.getId(), snapshot.getImageId());
            }
            if (volInfo != null) {
                setQcowCompatByQemuImageInfo(snapshot.getStoragePoolId(), snapshot.getId(), snapshot.getImageId(), getParameters().getStorageDomainId(), snapshot);
            }
            imageDao.update(snapshot.getImage());
        } catch (EngineException e) {
            // Logging only
            log.error("Unable to update the image info for image '{}' (image group: '{}') on domain '{}'", snapshot.getImageId(), snapshot.getId(), getParameters().getStorageDomainId());
        }
    }
}
#method_after
protected void setQcowCompatForSnapshot(DiskImage snapshot, DiskImage volInfo) {
    DiskImage info = volInfo;
    if (snapshot.getVolumeFormat().equals(VolumeFormat.COW)) {
        try {
            if (info == null) {
                info = getVolumeInfo(snapshot.getStoragePoolId(), getParameters().getStorageDomainId(), snapshot.getId(), snapshot.getImageId());
            }
            if (info != null) {
                setQcowCompatByQemuImageInfo(snapshot.getStoragePoolId(), snapshot.getId(), snapshot.getImageId(), getParameters().getStorageDomainId(), snapshot);
            }
            imageDao.update(snapshot.getImage());
        } catch (EngineException e) {
            // Logging only
            log.error("Unable to update the image info for image '{}' (image group: '{}') on domain '{}'", snapshot.getImageId(), snapshot.getId(), getParameters().getStorageDomainId());
        }
    }
}
#end_block

#method_before
public static void redirectToModule(HttpServletRequest request, HttpServletResponse response) throws IOException {
    log.debug("Entered redirectToModule");
    try {
        SsoSession ssoSession = getSsoSession(request);
        URLBuilder redirectUrl = new URLBuilder(getRedirectUrl(request).toString()).addParameter("code", ssoSession.getAuthorizationCode());
        String appUrl = ssoSession.getAppUrl();
        if (StringUtils.isNotEmpty(appUrl)) {
            redirectUrl.addParameter("app_url", appUrl);
        }
        String state = ssoSession.getState();
        if (StringUtils.isNotEmpty(state)) {
            redirectUrl.addParameter("state", state);
        }
        response.sendRedirect(redirectUrl.build());
        log.debug("Redirecting back to module: {}", redirectUrl);
    } catch (Exception ex) {
        log.error("Error redirecting back to module: {}", ex.getMessage());
        log.debug("Exception", ex);
        throw new RuntimeException(ex);
    } finally {
        SsoUtils.getSsoSession(request).cleanup();
    }
}
#method_after
public static void redirectToModule(HttpServletRequest request, HttpServletResponse response) throws IOException {
    log.debug("Entered redirectToModule");
    try {
        SsoSession ssoSession = getSsoSession(request);
        URLBuilder redirectUrl = new URLBuilder(getRedirectUrl(request)).addParameter("code", ssoSession.getAuthorizationCode());
        String appUrl = ssoSession.getAppUrl();
        if (StringUtils.isNotEmpty(appUrl)) {
            redirectUrl.addParameter("app_url", appUrl);
        }
        String state = ssoSession.getState();
        if (StringUtils.isNotEmpty(state)) {
            redirectUrl.addParameter("state", state);
        }
        response.sendRedirect(redirectUrl.build());
        log.debug("Redirecting back to module: {}", redirectUrl);
    } catch (Exception ex) {
        log.error("Error redirecting back to module: {}", ex.getMessage());
        log.debug("Exception", ex);
        throw new RuntimeException(ex);
    } finally {
        getSsoSession(request).cleanup();
    }
}
#end_block

#method_before
private static void redirectToErrorPageImpl(HttpServletRequest request, HttpServletResponse response, OAuthException ex) {
    log.debug("Entered redirectToErrorPage");
    SsoSession ssoSession = null;
    try {
        ssoSession = SsoUtils.getSsoSession(request, true);
        if (ssoSession.getStatus() != SsoSession.Status.authenticated) {
            ssoSession.setStatus(SsoSession.Status.unauthenticated);
        }
        String redirectUrl = new URLBuilder(getRedirectUrl(request)).addParameter("error_code", ex.getCode()).addParameter("error", ex.getMessage()).build();
        response.sendRedirect(redirectUrl);
        log.debug("Redirecting back to module: {}", redirectUrl);
    } catch (Exception e) {
        log.error("Error redirecting to error page: {}", e.getMessage());
        log.debug("Exception", e);
        throw new RuntimeException(ex);
    } finally {
        if (ssoSession != null) {
            ssoSession.cleanup();
        }
    }
}
#method_after
private static void redirectToErrorPageImpl(HttpServletRequest request, HttpServletResponse response, OAuthException ex) {
    log.debug("Entered redirectToErrorPage");
    SsoSession ssoSession = null;
    try {
        ssoSession = getSsoSession(request, true);
        if (ssoSession.getStatus() != SsoSession.Status.authenticated) {
            ssoSession.setStatus(SsoSession.Status.unauthenticated);
        }
        String redirectUrl = new URLBuilder(getRedirectUrl(request)).addParameter("error_code", ex.getCode()).addParameter("error", ex.getMessage()).build();
        response.sendRedirect(redirectUrl);
        log.debug("Redirecting back to module: {}", redirectUrl);
    } catch (Exception e) {
        log.error("Error redirecting to error page: {}", e.getMessage());
        log.debug("Exception", e);
        throw new RuntimeException(ex);
    } finally {
        if (ssoSession != null) {
            ssoSession.cleanup();
        }
    }
}
#end_block

#method_before
public static SsoSession getSsoSession(HttpServletRequest request, String clientId, String token, boolean mustExist) {
    TokenCleanupUtility.cleanupExpiredTokens(request.getServletContext());
    SsoSession ssoSession = null;
    if (StringUtils.isNotEmpty(token)) {
        ssoSession = getSsoContext(request).getSsoSession(token);
        if (ssoSession != null) {
            ssoSession.touch();
        }
    }
    if (mustExist && ssoSession == null) {
        throw new OAuthException(SsoConstants.ERR_CODE_INVALID_GRANT, "The provided authorization grant for the auth code has expired");
    }
    if (StringUtils.isNotEmpty(clientId) && StringUtils.isNotEmpty(ssoSession.getClientId()) && !ssoSession.getClientId().equals(clientId)) {
        throw new OAuthException(SsoConstants.ERR_CODE_UNAUTHORIZED_CLIENT, SsoConstants.ERR_CODE_UNAUTHORIZED_CLIENT);
    }
    return ssoSession;
}
#method_after
public static SsoSession getSsoSession(HttpServletRequest request, String clientId, String token, boolean mustExist) {
    TokenCleanupUtility.cleanupExpiredTokens(request.getServletContext());
    SsoContext ssoContext = getSsoContext(request);
    SsoSession ssoSession = null;
    if (StringUtils.isNotEmpty(token)) {
        ssoSession = getSsoContext(request).getSsoSession(token);
        if (ssoSession != null) {
            ssoSession.touch();
        }
    }
    if (mustExist && ssoSession == null) {
        throw new OAuthException(SsoConstants.ERR_CODE_INVALID_GRANT, ssoContext.getLocalizationUtils().localize(SsoConstants.APP_ERROR_INVALID_GRANT, (Locale) request.getAttribute(SsoConstants.LOCALE)));
    }
    if (StringUtils.isNotEmpty(clientId) && StringUtils.isNotEmpty(ssoSession.getClientId()) && !ssoSession.getClientId().equals(clientId)) {
        throw new OAuthException(SsoConstants.ERR_CODE_UNAUTHORIZED_CLIENT, SsoConstants.ERR_CODE_UNAUTHORIZED_CLIENT);
    }
    return ssoSession;
}
#end_block

#method_before
public static SsoSession getSsoSession(HttpServletRequest request) {
    SsoSession ssoSession = request.getSession(false) == null ? null : (SsoSession) request.getSession().getAttribute(SsoConstants.OVIRT_SSO_SESSION);
    // If the session has expired, attempt to extract the session from SsoContext persisted session
    if (ssoSession == null) {
        try {
            ssoSession = getSsoContext(request).getSsoSessionById(SsoUtils.getFormParameter(request, "sessionIdToken"));
            // If the server is restarted the session will be missing from SsoContext
            if (ssoSession == null) {
                throw new OAuthException(SsoConstants.ERR_CODE_INVALID_GRANT, "Session expired please try again.");
            }
            HttpSession session = request.getSession(true);
            session.setAttribute(SsoConstants.OVIRT_SSO_SESSION, ssoSession);
            ssoSession.setHttpSession(session);
        } catch (UnsupportedEncodingException ex) {
            throw new OAuthException(SsoConstants.ERR_CODE_SERVER_ERROR, "Unable to decode sessionIdToken.");
        }
    }
    return ssoSession;
}
#method_after
public static SsoSession getSsoSession(HttpServletRequest request) {
    SsoContext ssoContext = getSsoContext(request);
    SsoSession ssoSession = request.getSession(false) == null ? null : (SsoSession) request.getSession().getAttribute(SsoConstants.OVIRT_SSO_SESSION);
    // If the session has expired, attempt to extract the session from SsoContext persisted session
    if (ssoSession == null) {
        try {
            ssoSession = getSsoContext(request).getSsoSessionById(getFormParameter(request, "sessionIdToken"));
            // If the server is restarted the session will be missing from SsoContext
            if (ssoSession == null) {
                throw new OAuthException(SsoConstants.ERR_CODE_INVALID_GRANT, ssoContext.getLocalizationUtils().localize(SsoConstants.APP_ERROR_SESSION_EXPIRED, (Locale) request.getAttribute(SsoConstants.LOCALE)));
            }
            HttpSession session = request.getSession(true);
            session.setAttribute(SsoConstants.OVIRT_SSO_SESSION, ssoSession);
            ssoSession.setHttpSession(session);
        } catch (UnsupportedEncodingException ex) {
            throw new OAuthException(SsoConstants.ERR_CODE_SERVER_ERROR, ssoContext.getLocalizationUtils().localize(SsoConstants.APP_ERROR_UNABLE_TO_DECODE_SESSION_ID_TOKEN, (Locale) request.getAttribute(SsoConstants.LOCALE)));
        }
    }
    return ssoSession;
}
#end_block

#method_before
public static String getUserId(ExtMap principalRecord) {
    String principal = principalRecord.get(Authz.PrincipalRecord.PRINCIPAL);
    return principal != null ? principal : principalRecord.<String>get(Authz.PrincipalRecord.NAME);
}
#method_after
public static String getUserId(ExtMap principalRecord) {
    String principal = principalRecord.get(Authz.PrincipalRecord.PRINCIPAL);
    return principal != null ? principal : principalRecord.get(Authz.PrincipalRecord.NAME);
}
#end_block

#method_before
public static void sendJsonData(HttpServletResponse response, Map<String, Object> payload) throws IOException {
    try (OutputStream os = response.getOutputStream()) {
        Map<String, Object> ovirtData = (Map<String, Object>) payload.get("ovirt");
        if (ovirtData != null) {
            Collection<ExtMap> groupIds = (Collection<ExtMap>) ovirtData.get("group_ids");
            if (groupIds != null) {
                ovirtData.put("group_ids", SsoUtils.prepareGroupMembershipsForJson(groupIds));
            }
        }
        String jsonPayload = getJson(payload);
        response.setContentType("application/json");
        byte[] jsonPayloadBytes = jsonPayload.getBytes(StandardCharsets.UTF_8.name());
        response.setContentLength(jsonPayloadBytes.length);
        os.write(jsonPayloadBytes);
        log.trace("Sending json data {}", jsonPayload);
    }
}
#method_after
public static void sendJsonData(HttpServletResponse response, Map<String, Object> payload) throws IOException {
    try (OutputStream os = response.getOutputStream()) {
        Map<String, Object> ovirtData = (Map<String, Object>) payload.get("ovirt");
        if (ovirtData != null) {
            Collection<ExtMap> groupIds = (Collection<ExtMap>) ovirtData.get("group_ids");
            if (groupIds != null) {
                ovirtData.put("group_ids", prepareGroupMembershipsForJson(groupIds));
            }
        }
        String jsonPayload = getJson(payload);
        response.setContentType("application/json");
        byte[] jsonPayloadBytes = jsonPayload.getBytes(StandardCharsets.UTF_8.name());
        response.setContentLength(jsonPayloadBytes.length);
        os.write(jsonPayloadBytes);
        log.trace("Sending json data {}", jsonPayload);
    }
}
#end_block

#method_before
public static List<String> scopeAsList(String scope) {
    return StringUtils.isEmpty(scope) ? Collections.<String>emptyList() : Arrays.asList(scope.trim().split("\\s *"));
}
#method_after
public static List<String> scopeAsList(String scope) {
    return StringUtils.isEmpty(scope) ? Collections.emptyList() : Arrays.asList(scope.trim().split("\\s *"));
}
#end_block

#method_before
private static CloseableHttpClient createClient(SsoContext ssoContext, String clientId) throws Exception {
    SsoLocalConfig config = ssoContext.getSsoLocalConfig();
    ClientInfo clientInfo = ssoContext.getClienInfo(clientId);
    return new HttpClientBuilder().setSslProtocol(clientInfo.getNotificationCallbackProtocol()).setPoolSize(config.getInteger("SSO_CALLBACK_CLIENT_POOL_SIZE")).setReadTimeout(config.getInteger("SSO_CALLBACK_READ_TIMEOUT")).setConnectTimeout(config.getInteger("SSO_CALLBACK_CONNECT_TIMEOUT")).setTrustManagerAlgorithm(TrustManagerFactory.getDefaultAlgorithm()).setTrustStore(config.getProperty("ENGINE_HTTPS_PKI_TRUST_STORE")).setTrustStorePassword(config.getProperty("ENGINE_HTTPS_PKI_TRUST_STORE_PASSWORD")).setTrustStoreType(config.getProperty("ENGINE_HTTPS_PKI_TRUST_STORE_TYPE")).setVerifyChain(clientInfo.isNotificationCallbackVerifyChain()).setVerifyHost(clientInfo.isNotificationCallbackVerifyHost()).build();
}
#method_after
private static CloseableHttpClient createClient(SsoContext ssoContext, String clientId) throws Exception {
    SsoLocalConfig config = ssoContext.getSsoLocalConfig();
    ClientInfo clientInfo = ssoContext.getClienInfo(clientId);
    return new HttpClientBuilder().setSslProtocol(clientInfo.getNotificationCallbackProtocol()).setPoolSize(config.getInteger("SSO_CALLBACK_CLIENT_POOL_SIZE")).setReadTimeout(config.getInteger("SSO_CALLBACK_READ_TIMEOUT")).setConnectTimeout(config.getInteger("SSO_CALLBACK_CONNECT_TIMEOUT")).setRetryCount(config.getInteger("SSO_CALLBACK_CONNECTION_RETRY_COUNT")).setTrustManagerAlgorithm(TrustManagerFactory.getDefaultAlgorithm()).setTrustStore(config.getProperty("ENGINE_HTTPS_PKI_TRUST_STORE")).setTrustStorePassword(config.getProperty("ENGINE_HTTPS_PKI_TRUST_STORE_PASSWORD")).setTrustStoreType(config.getProperty("ENGINE_HTTPS_PKI_TRUST_STORE_TYPE")).setValidateAfterInactivity(config.getInteger("SSO_CALLBACK_CONNECTION_VALIDATE_AFTER_INACTIVITY")).setVerifyChain(clientInfo.isNotificationCallbackVerifyChain()).setVerifyHost(clientInfo.isNotificationCallbackVerifyHost()).build();
}
#end_block

#method_before
public static Collection<ExtMap> prepareGroupMembershipsForJson(Collection<ExtMap> groupRecords) {
    Map<String, ExtMap> resolvedGroups = new HashMap<>();
    for (ExtMap origRecord : groupRecords) {
        if (!resolvedGroups.containsKey(origRecord.<String>get(Authz.GroupRecord.ID))) {
            ExtMap groupRecord = new ExtMap(origRecord);
            groupRecord.put(Authz.PrincipalRecord.PRINCIPAL, "");
            resolvedGroups.put(groupRecord.<String>get(Authz.GroupRecord.ID), groupRecord);
            groupRecord.put(Authz.GroupRecord.GROUPS, processGroupMemberships(groupRecord.<Collection<ExtMap>>get(Authz.GroupRecord.GROUPS, Collections.<ExtMap>emptyList()), resolvedGroups));
        }
    }
    return new ArrayList<>(resolvedGroups.values());
}
#method_after
public static Collection<ExtMap> prepareGroupMembershipsForJson(Collection<ExtMap> groupRecords) {
    Map<String, ExtMap> resolvedGroups = new HashMap<>();
    for (ExtMap origRecord : groupRecords) {
        if (!resolvedGroups.containsKey(origRecord.<String>get(Authz.GroupRecord.ID))) {
            ExtMap groupRecord = new ExtMap(origRecord);
            groupRecord.put(Authz.PrincipalRecord.PRINCIPAL, "");
            resolvedGroups.put(groupRecord.get(Authz.GroupRecord.ID), groupRecord);
            groupRecord.put(Authz.GroupRecord.GROUPS, processGroupMemberships(groupRecord.get(Authz.GroupRecord.GROUPS, Collections.emptyList()), resolvedGroups));
        }
    }
    return new ArrayList<>(resolvedGroups.values());
}
#end_block

#method_before
public static String createJWT(HttpServletRequest request, SsoSession ssoSession, String clientId) throws NoSuchAlgorithmException {
    String serverName = request.getServerName();
    String issuer = String.format("%s://%s:%s", request.getScheme(), InetAddressUtils.isIPv6Address(serverName) ? String.format("[%s]", serverName) : serverName, request.getServerPort());
    JwtBuilder builder = Jwts.builder().setId(ssoSession.getPrincipalRecord().<String>get(Authz.PrincipalRecord.ID)).setIssuedAt(new Date(System.currentTimeMillis())).setIssuer(issuer).setSubject(String.format("%s@%s", ssoSession.getUserId(), ssoSession.getProfile())).setAudience(clientId).signWith(SignatureAlgorithm.HS256, base64SecretBytes);
    Claims claims = Jwts.claims();
    claims.put("sub", String.format("%s@%s", ssoSession.getUserId(), ssoSession.getProfile()));
    claims.put("preferred_username", String.format("%s@%s", ssoSession.getUserId(), ssoSession.getProfile()));
    claims.put("email", ssoSession.getPrincipalRecord().<String>get(Authz.PrincipalRecord.EMAIL));
    claims.put("name", ssoSession.getPrincipalRecord().<String>get(Authz.PrincipalRecord.FIRST_NAME));
    builder.setClaims(claims);
    // Builds the JWT and serializes it to a compact, URL-safe string
    return builder.compact();
}
#method_after
public static String createJWT(HttpServletRequest request, SsoSession ssoSession, String clientId) throws NoSuchAlgorithmException, JOSEException {
    String serverName = request.getServerName();
    String issuer = String.format("%s://%s:%s", request.getScheme(), InetAddressUtils.isIPv6Address(serverName) ? String.format("[%s]", serverName) : serverName, request.getServerPort());
    // Compose the JWT claims set
    JWTClaimsSet jwtClaims = (new JWTClaimsSet.Builder()).jwtID(ssoSession.getPrincipalRecord().<String>get(Authz.PrincipalRecord.ID)).issueTime(new Date(System.currentTimeMillis())).issuer(issuer).subject(String.format("%s@%s", ssoSession.getUserId(), ssoSession.getProfile())).audience(Arrays.asList(clientId)).claim("sub", String.format("%s@%s", ssoSession.getUserId(), ssoSession.getProfile())).claim("preferred_username", String.format("%s@%s", ssoSession.getUserId(), ssoSession.getProfile())).claim("email", ssoSession.getPrincipalRecord().<String>get(Authz.PrincipalRecord.EMAIL)).claim("name", ssoSession.getPrincipalRecord().<String>get(Authz.PrincipalRecord.FIRST_NAME)).build();
    // Create HMAC signer
    JWSSigner signer = new MACSigner(sharedSecret);
    SignedJWT signedJWT = new SignedJWT(new JWSHeader(JWSAlgorithm.HS256), jwtClaims);
    signedJWT.sign(signer);
    return signedJWT.serialize();
}
#end_block

#method_before
private static Set<String> processGroupMemberships(Collection<ExtMap> memberships, Map<String, ExtMap> resolvedGroups) {
    Set<String> membershipIds = new HashSet<>();
    for (ExtMap origRecord : memberships) {
        ExtMap groupRecord = new ExtMap(origRecord);
        membershipIds.add(groupRecord.<String>get(Authz.GroupRecord.ID));
        if (!resolvedGroups.containsKey(groupRecord.<String>get(Authz.GroupRecord.ID))) {
            resolvedGroups.put(groupRecord.<String>get(Authz.GroupRecord.ID), groupRecord);
            groupRecord.put(Authz.GroupRecord.GROUPS, processGroupMemberships(groupRecord.<Collection<ExtMap>>get(Authz.GroupRecord.GROUPS, Collections.<ExtMap>emptyList()), resolvedGroups));
        }
    }
    return membershipIds;
}
#method_after
private static Set<String> processGroupMemberships(Collection<ExtMap> memberships, Map<String, ExtMap> resolvedGroups) {
    Set<String> membershipIds = new HashSet<>();
    for (ExtMap origRecord : memberships) {
        ExtMap groupRecord = new ExtMap(origRecord);
        membershipIds.add(groupRecord.get(Authz.GroupRecord.ID));
        if (!resolvedGroups.containsKey(groupRecord.<String>get(Authz.GroupRecord.ID))) {
            resolvedGroups.put(groupRecord.get(Authz.GroupRecord.ID), groupRecord);
            groupRecord.put(Authz.GroupRecord.GROUPS, processGroupMemberships(groupRecord.get(Authz.GroupRecord.GROUPS, Collections.emptyList()), resolvedGroups));
        }
    }
    return membershipIds;
}
#end_block

#method_before
private void issueTokenForPasswd(HttpServletRequest request, HttpServletResponse response, String scope) throws Exception {
    log.debug("Entered issueTokenForPasswd");
    Credentials credentials = null;
    try {
        credentials = SsoUtils.translateUser(SsoUtils.getRequestParameter(request, "username"), SsoUtils.getRequestParameter(request, "password"), ssoContext);
        String token = null;
        if (credentials != null && credentials.isValid()) {
            AuthenticationUtils.handleCredentials(ssoContext, request, credentials, false);
            token = (String) request.getAttribute(SsoConstants.HTTP_REQ_ATTR_ACCESS_TOKEN);
        }
        log.debug("Attempting to issueTokenForPasswd for user: {}", credentials.getUsername());
        SsoSession ssoSession = SsoUtils.getSsoSessionFromRequest(request, token);
        if (ssoSession == null) {
            throw new OAuthException(SsoConstants.ERR_CODE_INVALID_GRANT, ssoContext.getLocalizationUtils().localize(SsoConstants.APP_ERROR_AUTHORIZATION_GRANT_EXPIRED_FOR_USERNAME_PASSWORD, (Locale) request.getAttribute(SsoConstants.LOCALE)));
        }
        SsoUtils.validateRequestScope(request, token, scope);
        log.debug("Sending json response");
        SsoUtils.sendJsonData(response, buildResponse(ssoSession));
    } catch (AuthenticationException ex) {
        String profile = "N/A";
        if (credentials != null) {
            profile = credentials.getProfile() == null ? "N/A" : credentials.getProfile();
        }
        throw new AuthenticationException(String.format(ssoContext.getLocalizationUtils().localize(SsoConstants.APP_ERROR_CANNOT_AUTHENTICATE_USER_IN_DOMAIN, (Locale) request.getAttribute(SsoConstants.LOCALE)), credentials == null ? "N/A" : credentials.getUsername(), profile, ex.getMessage()));
    }
}
#method_after
private void issueTokenForPasswd(HttpServletRequest request, HttpServletResponse response, String scope) throws Exception {
    log.debug("Entered issueTokenForPasswd");
    Credentials credentials = null;
    try {
        credentials = SsoUtils.translateUser(SsoUtils.getRequestParameter(request, "username"), SsoUtils.getRequestParameter(request, "password"), ssoContext);
        String token = null;
        if (credentials != null && credentials.isValid()) {
            AuthenticationUtils.handleCredentials(ssoContext, request, credentials, false);
            token = (String) request.getAttribute(SsoConstants.HTTP_REQ_ATTR_ACCESS_TOKEN);
        }
        log.debug("Attempting to issueTokenForPasswd for user: {}", Optional.ofNullable(credentials).map(Credentials::getUsername).orElse("null"));
        SsoSession ssoSession = SsoUtils.getSsoSessionFromRequest(request, token);
        if (ssoSession == null) {
            throw new OAuthException(SsoConstants.ERR_CODE_INVALID_GRANT, ssoContext.getLocalizationUtils().localize(SsoConstants.APP_ERROR_AUTHORIZATION_GRANT_EXPIRED_FOR_USERNAME_PASSWORD, (Locale) request.getAttribute(SsoConstants.LOCALE)));
        }
        SsoUtils.validateRequestScope(request, token, scope);
        log.debug("Sending json response");
        SsoUtils.sendJsonData(response, buildResponse(ssoSession));
    } catch (AuthenticationException ex) {
        String profile = "N/A";
        if (credentials != null) {
            profile = credentials.getProfile() == null ? "N/A" : credentials.getProfile();
        }
        throw new AuthenticationException(String.format(ssoContext.getLocalizationUtils().localize(SsoConstants.APP_ERROR_CANNOT_AUTHENTICATE_USER_IN_DOMAIN, (Locale) request.getAttribute(SsoConstants.LOCALE)), credentials == null ? "N/A" : credentials.getUsername(), profile, ex.getMessage()));
    }
}
#end_block

#method_before
private void issueTokenUsingHttpHeaders(HttpServletRequest request, HttpServletResponse response) throws Exception {
    log.debug("Entered issueTokenUsingHttpHeaders");
    try {
        AuthResult authResult = null;
        for (NonInteractiveAuth auth : getAuthSeq()) {
            authResult = auth.doAuth(request, response);
            if (authResult.getStatus() == Authn.AuthResult.SUCCESS || authResult.getStatus() == Authn.AuthResult.NEGOTIATION_INCOMPLETE) {
                break;
            }
        }
        if (authResult != null && authResult.getStatus() != Authn.AuthResult.SUCCESS) {
            log.debug("Authentication failed using http headers");
            List<String> schemes = (List<String>) request.getAttribute(NegotiateAuthUtils.REQUEST_SCHEMES_KEY);
            for (String scheme : new HashSet<>(schemes == null ? Collections.<String>emptyList() : schemes)) {
                response.setHeader("WWW-Authenticate", scheme);
            }
            response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
        } else if (authResult != null && StringUtils.isNotEmpty(authResult.getToken())) {
            SsoSession ssoSession = SsoUtils.getSsoSessionFromRequest(request, authResult.getToken());
            if (ssoSession == null) {
                throw new OAuthException(SsoConstants.ERR_CODE_INVALID_GRANT, ssoContext.getLocalizationUtils().localize(SsoConstants.APP_ERROR_AUTHORIZATION_GRANT_EXPIRED, (Locale) request.getAttribute(SsoConstants.LOCALE)));
            }
            log.debug("Sending json response");
            SsoUtils.sendJsonData(response, buildResponse(ssoSession));
        } else {
            throw new AuthenticationException(ssoContext.getLocalizationUtils().localize(SsoConstants.APP_ERROR_AUTHENTICATION_FAILED, (Locale) request.getAttribute(SsoConstants.LOCALE)));
        }
    } catch (Exception ex) {
        throw new AuthenticationException(String.format(ssoContext.getLocalizationUtils().localize(SsoConstants.APP_ERROR_CANNOT_AUTHENTICATE_USER, (Locale) request.getAttribute(SsoConstants.LOCALE)), ex.getMessage()));
    }
}
#method_after
private void issueTokenUsingHttpHeaders(HttpServletRequest request, HttpServletResponse response) throws Exception {
    log.debug("Entered issueTokenUsingHttpHeaders");
    try {
        AuthResult authResult = null;
        for (NonInteractiveAuth auth : getAuthSeq()) {
            authResult = auth.doAuth(request, response);
            if (authResult.getStatus() == Authn.AuthResult.SUCCESS || authResult.getStatus() == Authn.AuthResult.NEGOTIATION_INCOMPLETE) {
                break;
            }
        }
        if (authResult != null && authResult.getStatus() != Authn.AuthResult.SUCCESS) {
            log.debug("Authentication failed using http headers");
            List<String> schemes = (List<String>) request.getAttribute(NegotiateAuthUtils.REQUEST_SCHEMES_KEY);
            for (String scheme : new HashSet<>(schemes == null ? Collections.emptyList() : schemes)) {
                response.setHeader("WWW-Authenticate", scheme);
            }
            response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
        } else if (authResult != null && StringUtils.isNotEmpty(authResult.getToken())) {
            SsoSession ssoSession = SsoUtils.getSsoSessionFromRequest(request, authResult.getToken());
            if (ssoSession == null) {
                throw new OAuthException(SsoConstants.ERR_CODE_INVALID_GRANT, ssoContext.getLocalizationUtils().localize(SsoConstants.APP_ERROR_AUTHORIZATION_GRANT_EXPIRED, (Locale) request.getAttribute(SsoConstants.LOCALE)));
            }
            log.debug("Sending json response");
            SsoUtils.sendJsonData(response, buildResponse(ssoSession));
        } else {
            throw new AuthenticationException(ssoContext.getLocalizationUtils().localize(SsoConstants.APP_ERROR_AUTHENTICATION_FAILED, (Locale) request.getAttribute(SsoConstants.LOCALE)));
        }
    } catch (Exception ex) {
        throw new AuthenticationException(String.format(ssoContext.getLocalizationUtils().localize(SsoConstants.APP_ERROR_CANNOT_AUTHENTICATE_USER, (Locale) request.getAttribute(SsoConstants.LOCALE)), ex.getMessage()));
    }
}
#end_block

#method_before
public void setScope(String scope) {
    if (scopeAsList == null && !SsoUtils.strippedScopeAsList(SsoUtils.scopeAsList(scope)).isEmpty()) {
        this.scope = scope;
        this.scopeAsList = StringUtils.isEmpty(scope) ? Collections.<String>emptyList() : SsoUtils.scopeAsList(scope);
    }
}
#method_after
public void setScope(String scope) {
    if (scopeAsList == null && !SsoUtils.strippedScopeAsList(SsoUtils.scopeAsList(scope)).isEmpty()) {
        this.scope = scope;
        this.scopeAsList = SsoUtils.scopeAsList(scope);
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    DiskValidator diskValidator = new DiskValidator(getDiskImage());
    if (!validate(diskValidator.isDiskExists()) || !validate(diskValidator.isDiskPluggedToVmsThatAreNotDown(false, vmsForDisk)) || !validate(diskValidator.isSparsifySupported())) {
        return false;
    }
    if (diskImageDao.getAllSnapshotsForImageGroup(getDiskImage().getId()).size() > 1) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_HAS_SNAPSHOTS);
    }
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(Collections.singletonList(getDiskImage()));
    return validate(diskImagesValidator.diskImagesNotIllegal()) && validate(diskImagesValidator.diskImagesNotLocked()) && validate(diskImagesValidator.diskImagesHaveNoDerivedDisks(null));
}
#method_after
@Override
protected boolean validate() {
    DiskValidator diskValidator = new DiskValidator(getDiskImage());
    if (!validate(diskValidator.isDiskExists()) || !validate(diskValidator.isDiskPluggedToVmsThatAreNotDown(false, getVmsForDisk())) || !validate(diskValidator.isSparsifySupported())) {
        return false;
    }
    if (diskImageDao.getAllSnapshotsForImageGroup(getDiskImage().getId()).size() > 1) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_HAS_SNAPSHOTS);
    }
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(Collections.singletonList(getDiskImage()));
    return validate(diskImagesValidator.diskImagesNotIllegal()) && validate(diskImagesValidator.diskImagesNotLocked()) && validate(diskImagesValidator.diskImagesHaveNoDerivedDisks(null));
}
#end_block

#method_before
private Map<String, Pair<String, String>> getSharedLocksForVmDisk() {
    Map<String, Pair<String, String>> sharedLocks = new HashMap<>();
    if (vmsForDisk != null) {
        for (Pair<VM, VmDevice> vmForDisk : vmsForDisk) {
            sharedLocks.put(vmForDisk.getFirst().getId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, EngineMessage.ACTION_TYPE_FAILED_VM_IS_LOCKED));
        }
    }
    return sharedLocks;
}
#method_after
private Map<String, Pair<String, String>> getSharedLocksForVmDisk() {
    Map<String, Pair<String, String>> sharedLocks = new HashMap<>();
    if (getVmsForDisk() != null) {
        for (Pair<VM, VmDevice> vmForDisk : getVmsForDisk()) {
            sharedLocks.put(vmForDisk.getFirst().getId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, EngineMessage.ACTION_TYPE_FAILED_VM_IS_LOCKED));
        }
    }
    return sharedLocks;
}
#end_block

