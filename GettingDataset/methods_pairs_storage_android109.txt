555
#method_before
public void test_readlink() throws Exception {
    String tmpDir = System.getProperty("java.io.tmpdir");
    String path = tmpDir + "/symlink";
    try {
        // ext2 and ext4 have PAGE_SIZE limits on symlink targets.
        String xs = "";
        for (int i = 0; i < (4096 - 1); ++i) xs += "x";
        Libcore.os.symlink(xs, path);
        assertEquals(xs, Libcore.os.readlink(path));
    } finally {
        Boolean deleted_symlink = new File(path).delete();
        assertTrue("Symlink is not deleted", deleted_symlink);
    }
}
#method_after
public void test_readlink() throws Exception {
    String tmpDir = System.getProperty("java.io.tmpdir");
    String path = tmpDir + "/symlink";
    try {
        // ext2 and ext4 have PAGE_SIZE limits on symlink targets.
        String xs = "";
        for (int i = 0; i < (4096 - 1); ++i) xs += "x";
        Libcore.os.symlink(xs, path);
        assertEquals(xs, Libcore.os.readlink(path));
    } finally {
        assertTrue("Could not delete symlink: " + path, new File(path).delete());
    }
}
#end_block

#method_before
@Before
public void setUp() throws RemoteException {
    // Initialize UiDevice instance
    mDevice = UiDevice.getInstance(mInstrumentation);
    if (!mDevice.isScreenOn()) {
        mDevice.wakeUp();
        mDevice.wait(Until.hasObject(By.res("android", "glow_pad_view")), 10000);
        mDevice.swipe(560, 1500, 560, 1000, 40);
    }
    mDevice.pressHome();
    mContext = mInstrumentation.getTargetContext();
}
#method_after
@Before
public void setUp() throws RemoteException {
    if (!mDevice.isScreenOn()) {
        mDevice.wakeUp();
        mDevice.wait(Until.hasObject(By.res("android", "glow_pad_view")), 10000);
        mDevice.swipe(560, 1500, 560, 1000, 40);
    }
    mDevice.pressHome();
}
#end_block

#method_before
private void registerService() {
    ServiceLocator.register(new TelephonyManagerService(mContext));
    ServiceLocator.register(new SmsManagerService(mContext));
    registerReceiver();
}
#method_after
private void registerService() {
    ServiceLocator.register(new TelephonyManagerService(mContext));
    ServiceLocator.register(new SmsManagerService(mContext));
}
#end_block

#method_before
@Override
public String execute(String json) throws IOException {
    boolean isSuccess = false;
    SmsManagerModel smsModel = new Gson().fromJson(json, SmsManagerModel.class);
    if (smsModel == null) {
        Log.e(TAG, "SmsManagerModel is null. Invalid POST Request body: " + json);
        result.setIsFail(true);
        result.setDescription("Invalid POST Request Body");
        return new Gson().toJson(result);
    }
    Uri smsQueryUri = Uri.parse(SMS_INBOX_URI);
    ContentResolver contentResolver = mContext.getContentResolver();
    Cursor cursor = null;
    try {
        cursor = contentResolver.query(smsQueryUri, null, null, null, null);
        if (cursor == null) {
            Log.i(TAG, "cursor is null. uri: " + smsQueryUri);
            result.setIsFail(!isSuccess);
            return new Gson().toJson("cursor is null. uri: " + smsQueryUri);
        }
        if (cursor.moveToFirst()) {
            for (String s : cursor.getColumnNames()) {
                Log.d(TAG + "smsColumns", "Column: " + s);
            }
            final String address = cursor.getString(cursor.getColumnIndexOrThrow("address"));
            result.setSmsAddress(address);
            final String body = cursor.getString(cursor.getColumnIndexOrThrow("body"));
            result.setSmsTextMessage(body);
            isSuccess = true;
        }
    } catch (Exception e) {
        Log.e(TAG, Log.getStackTraceString(e));
        isSuccess = false;
        result.setDescription("Unknown Action specified in request.");
    } finally {
        cursor.close();
    }
    result.setIsFail(!isSuccess);
    return new Gson().toJson(result);
}
#method_after
@Override
public String execute(String json) throws IOException {
    boolean isSuccess = false;
    Result result = new Result();
    SmsManagerModel smsModel = new Gson().fromJson(json, SmsManagerModel.class);
    if (smsModel == null) {
        Log.e(TAG, "SmsManagerModel is null. Invalid POST Request body: " + json);
        result.setIsFail(true);
        result.setDescription("Invalid POST Request Body");
        return new Gson().toJson(result);
    }
    Uri smsQueryUri = Uri.parse(SMS_INBOX_URI);
    ContentResolver contentResolver = mContext.getContentResolver();
    Cursor cursor = null;
    try {
        cursor = contentResolver.query(smsQueryUri, null, null, null, null);
        if (cursor == null) {
            final String CURSOR_IS_NULL = "cursor is null.";
            Log.i(TAG, CURSOR_IS_NULL + " uri: " + smsQueryUri);
            result.setIsFail(!isSuccess);
            return new Gson().toJson(CURSOR_IS_NULL + " uri: " + smsQueryUri);
        }
        if (cursor.moveToFirst()) {
            for (String s : cursor.getColumnNames()) {
                Log.d(TAG + "smsColumns", "Column: " + s);
            }
            final String address = cursor.getString(cursor.getColumnIndexOrThrow(SMS_ADDRESS_COLUMN));
            result.setSmsAddress(address);
            final String body = cursor.getString(cursor.getColumnIndexOrThrow(SMS_BODY_COLUMN));
            result.setSmsTextMessage(body);
            isSuccess = true;
        }
    } catch (NullPointerException npe) {
        Log.e(TAG, npe.getMessage());
        isSuccess = false;
        result.setDescription(Log.getStackTraceString(npe));
    } catch (Exception e) {
        Log.e(TAG, e.getMessage());
        isSuccess = false;
        result.setDescription(Log.getStackTraceString(e));
    } finally {
        cursor.close();
    }
    result.setIsFail(!isSuccess);
    return new Gson().toJson(result);
}
#end_block

#method_before
@Override
public String toString() {
    return new Gson().toJson(new RestServiceModel(POST, "/SmsManagerService", new SmsManagerModel("String").toString()));
}
#method_after
@Override
public String toString() {
    return new Gson().toJson(new RestServiceModel(POST, SMS_SERVICE_PATH, new SmsManagerModel(ACTION).toString()));
}
#end_block

#method_before
@Test
@TestInfo(id = "14581151")
public void testAddAccountUsingContactsApp() throws Exception {
    Instrumentation instrumentation = testFramework.getInstrumentation();
    UiDevice mDevice = testFramework.getDevice();
    if (testFramework.getApi() > 19) {
        AppLauncher.launch(instrumentation, "Contacts");
        // Check if the app is running for the first time.
        UiObject checkingInfo = mDevice.findObject(new UiSelector().textContains("Checking Info"));
        if (checkingInfo.exists()) {
            mDevice.pressBack();
        }
        AppLauncher.launch(instrumentation, "Contacts");
    } else {
        AppLauncher.launch(instrumentation, "People");
        // Check if the app is running for the first time.
        UiObject notNow = mDevice.findObject(new UiSelector().textContains("Not now"));
        if (notNow.exists()) {
            notNow.click();
        }
    }
    // which requires Google API support. Test is irrelevant on API 24 without google services.
    if (testFramework.getApi() > 23) {
        UiObject add_contact = mDevice.findObject(new UiSelector().description("add new contact"));
        add_contact.clickAndWaitForNewWindow();
    } else {
        UiObject add_contact = mDevice.findObject(new UiSelector().textContains("NEW CONTACT"));
        add_contact.waitForExists(TimeUnit.SECONDS.toMillis(5));
        add_contact.clickAndWaitForNewWindow();
    }
    mDevice.findObject(new UiSelector().textContains("ADD ACCOUNT")).click();
}
#method_after
@Test
@TestInfo(id = "14581151")
public void testAddAccountUsingContactsApp() throws Exception {
    Instrumentation instrumentation = testFramework.getInstrumentation();
    UiDevice mDevice = testFramework.getDevice();
    if (testFramework.getApi() > 19) {
        AppLauncher.launch(instrumentation, "Contacts");
        // Check if the app is running for the first time.
        UiObject checkingInfo = mDevice.findObject(new UiSelector().textContains("Checking Info"));
        if (checkingInfo.exists()) {
            mDevice.pressBack();
        }
        AppLauncher.launch(instrumentation, "Contacts");
    } else {
        AppLauncher.launch(instrumentation, "People");
        // Check if the app is running for the first time.
        UiObject notNow = mDevice.findObject(new UiSelector().textContains("Not now"));
        if (notNow.exists()) {
            notNow.click();
        }
    }
    // which requires Google API support.
    if (testFramework.isGoogleApiImage()) {
        UiObject add_contact = mDevice.findObject(new UiSelector().description("add new contact"));
        add_contact.waitForExists(TimeUnit.SECONDS.toMillis(5));
        add_contact.clickAndWaitForNewWindow();
    }
    mDevice.findObject(new UiSelector().textContains("ADD ACCOUNT")).click();
}
#end_block

#method_before
@Test
@TestInfo(id = "14578831")
public void bookmarkWebSiteInBrowser() throws Exception {
    Instrumentation instrumentation = testFramework.getInstrumentation();
    UiDevice device = UiDevice.getInstance(instrumentation);
    if (testFramework.getApi() >= 24 && testFramework.isGoogleApiImage()) {
        AppLauncher.launch(instrumentation, "Chrome");
        // If this is the first launch, dismiss the "Welcome to Chrome" screen.
        UiObject acceptButton = device.findObject(new UiSelector().resourceId(Res.CHROME_TERMS_ACCEPT_BUTTON_RES));
        if (device.hasObject(By.res(Res.CHROME_WELCOME_TITLE_RES)) && acceptButton.exists()) {
            acceptButton.clickAndWaitForNewWindow();
        }
        // Dismiss the "Sign in to Chrome" screen if it's there.
        if (device.hasObject(By.res(Res.CHROME_SIGN_IN_TITLE_RES))) {
            device.findObject(new UiSelector().resourceId(Res.CHROME_NEGATIVE_BUTTON_RES)).clickAndWaitForNewWindow();
        }
        // Dismiss the "Browse more for less" screen if it's there.
        UiObject noThanksButton = device.findObject(new UiSelector().resourceId(Res.CHROME_NO_THANKS_BUTTON));
        if (noThanksButton.exists()) {
            noThanksButton.clickAndWaitForNewWindow();
        }
        // Click the search box if it's there.
        UiObject searchBox = device.findObject(new UiSelector().resourceId(Res.CHROME_SEARCH_BOX_RES));
        if (searchBox.exists()) {
            searchBox.clickAndWaitForNewWindow();
        }
        UiObject textField = device.findObject(new UiSelector().resourceId(Res.CHROME_URL_BAR_RES));
        textField.click();
        textField.clearTextField();
        // Include a timestamp in the URL so it's not already bookmarked. (On Chrome, the UI
        // changes in that case.)
        textField.setText("https://httpbin.org/?d=" + new Date().getTime());
        device.pressEnter();
        device.pressMenu();
        device.findObject(new UiSelector().description("Bookmark this page")).click();
        device.pressMenu();
        // After bookmarking, the button description changes.
        assertTrue("Bookmark was not set", device.findObject(new UiSelector().description("Edit bookmark")).exists());
        // Verify the new bookmark is in the list.
        device.findObject(new UiSelector().text("Bookmarks")).clickAndWaitForNewWindow();
        assertTrue("Cannot find bookmark", device.findObject(new UiSelector().text("Bookmarks")).exists() && device.findObject(new UiSelector().textContains("httpbin").resourceId(Res.CHROME_BOOKMARKS_LABEL_RES)).exists());
        device.findObject(new UiSelector().resourceId(Res.CHROME_CLOSE_MENU_BUTTON_RES)).clickAndWaitForNewWindow();
        // Delete the bookmark.
        device.pressMenu();
        device.findObject(new UiSelector().description("Edit bookmark")).clickAndWaitForNewWindow();
        device.findObject(new UiSelector().description("Delete bookmarks")).click();
    } else {
        AppLauncher.launch(instrumentation, "Browser");
        UiObject textField = device.findObject(new UiSelector().resourceId(Res.BROWSER_URL_TEXT_FIELD_RES));
        textField.click();
        textField.clearTextField();
        textField.setText("espn.com");
        device.pressEnter();
        device.pressMenu();
        device.findObject(new UiSelector().text("Save to bookmarks")).click();
        device.findObject(new UiSelector().text("OK")).click();
        device.pressMenu();
        UiObject bookmarks = device.findObject(new UiSelector().text("Bookmarks"));
        bookmarks.waitForExists(5000);
        bookmarks.click();
        assertTrue("Cannot find ESPN bookmark", device.findObject(new UiSelector().text("Bookmarks")).exists() && device.findObject(new UiSelector().textContains("ESPN").resourceId(Res.BROWSER_BOOKMARKS_LABEL_RES)).exists());
    }
}
#method_after
@Test
@TestInfo(id = "14578831")
public void bookmarkWebSiteInBrowser() throws Exception {
    Instrumentation instrumentation = testFramework.getInstrumentation();
    UiDevice device = UiDevice.getInstance(instrumentation);
    if (testFramework.getApi() >= 24 && testFramework.isGoogleApiImage()) {
        AppLauncher.launch(instrumentation, "Chrome");
        // If this is the first launch, dismiss the "Welcome to Chrome" screen.
        UiObject acceptButton = device.findObject(new UiSelector().resourceId(Res.CHROME_TERMS_ACCEPT_BUTTON_RES));
        if (device.hasObject(By.res(Res.CHROME_WELCOME_TITLE_RES)) && acceptButton.exists()) {
            acceptButton.clickAndWaitForNewWindow();
        }
        // Dismiss the "Sign in to Chrome" screen if it's there.
        if (device.hasObject(By.res(Res.CHROME_SIGN_IN_TITLE_RES))) {
            device.findObject(new UiSelector().resourceId(Res.CHROME_NEGATIVE_BUTTON_RES)).clickAndWaitForNewWindow();
        }
        // Dismiss the "Browse more for less" screen if it's there.
        UiObject noThanksButton = device.findObject(new UiSelector().resourceId(Res.CHROME_NO_THANKS_BUTTON));
        if (noThanksButton.exists()) {
            noThanksButton.clickAndWaitForNewWindow();
        }
        // Click the search box if it's there.
        UiObject searchBox = device.findObject(new UiSelector().resourceId(Res.CHROME_SEARCH_BOX_RES));
        if (searchBox.exists()) {
            searchBox.clickAndWaitForNewWindow();
        }
        UiObject textField = device.findObject(new UiSelector().resourceId(Res.CHROME_URL_BAR_RES));
        textField.click();
        textField.clearTextField();
        // Include a timestamp in the URL so it's not already bookmarked. (On Chrome, the UI
        // changes in that case.)
        textField.setText("https://httpbin.org/?d=" + new Date().getTime());
        device.pressEnter();
        device.pressMenu();
        device.findObject(new UiSelector().description("Bookmark this page")).click();
        device.pressMenu();
        // After bookmarking, the button description changes.
        assertTrue("Bookmark was not set", device.findObject(new UiSelector().description("Edit bookmark")).exists());
        // Verify the new bookmark is in the list.
        device.findObject(new UiSelector().text("Bookmarks")).clickAndWaitForNewWindow();
        assertTrue("Cannot find bookmark", device.findObject(new UiSelector().text("Bookmarks")).exists() && device.findObject(new UiSelector().textContains("httpbin").resourceId(Res.CHROME_BOOKMARKS_LABEL_RES)).exists());
        device.findObject(new UiSelector().resourceId(Res.CHROME_CLOSE_MENU_BUTTON_RES)).clickAndWaitForNewWindow();
        // Delete the bookmark.
        device.pressMenu();
        device.findObject(new UiSelector().description("Edit bookmark")).clickAndWaitForNewWindow();
        device.findObject(new UiSelector().description("Delete bookmarks")).click();
    } else {
        AppLauncher.launch(instrumentation, "Browser");
        UiObject textField = device.findObject(new UiSelector().resourceId(Res.BROWSER_URL_TEXT_FIELD_RES));
        textField.click();
        textField.clearTextField();
        textField.setText("espn.com");
        device.pressEnter();
        device.pressMenu();
        device.findObject(new UiSelector().text("Save to bookmarks")).click();
        device.findObject(new UiSelector().text("OK")).click();
        device.pressMenu();
        UiObject bookmarks = device.findObject(new UiSelector().text("Bookmarks"));
        bookmarks.waitForExists(TimeUnit.SECONDS.toMillis(5));
        bookmarks.click();
        assertTrue("Cannot find ESPN bookmark", device.findObject(new UiSelector().text("Bookmarks")).exists() && device.findObject(new UiSelector().textContains("ESPN").resourceId(Res.BROWSER_BOOKMARKS_LABEL_RES)).exists());
    }
}
#end_block

#method_before
@MediumTest
public void testDeviceTreeCpuCurrent() throws Exception {
    String arch = System.getProperty("os.arch");
    String[] osVersion = System.getProperty("os.version").split("\\.");
    /*
         * Perform the test for only arm-based architecture and
         * kernel version 3.10 and above.
         */
    if (!arch.contains("arm") || Integer.parseInt(osVersion[0]) < 2 || (Integer.parseInt(osVersion[0]) == 3 && Integer.parseInt(osVersion[1]) < 10))
        return;
    final File f = new File("/proc/device-tree/cpus");
    if (!f.exists())
        return;
    String[] dir = f.list(new FilenameFilter() {

        @Override
        public boolean accept(File pathname, String name) {
            return (pathname.isDirectory() && name.matches("cpu@[0-9]+"));
        }
    });
    if (dir == null)
        return;
    for (String cpuDir : dir) {
        File fCpu = new File(cpuDir + "/current");
        assertTrue(f.canRead());
    }
}
#method_after
@MediumTest
public void testDeviceTreeCpuCurrent() throws Exception {
    String arch = System.getProperty("os.arch");
    String[] osVersion = System.getProperty("os.version").split("\\.");
    /*
         * Perform the test for only arm-based architecture and
         * kernel version 3.10 and above.
         */
    if (!arch.contains("arm") || Integer.parseInt(osVersion[0]) < 2 || (Integer.parseInt(osVersion[0]) == 3 && Integer.parseInt(osVersion[1]) < 10))
        return;
    final File f = new File("/proc/device-tree/cpus");
    if (!f.exists())
        return;
    String[] dir = f.list(new FilenameFilter() {

        @Override
        public boolean accept(File pathname, String name) {
            return (pathname.isDirectory() && name.matches("cpu@[0-9]+"));
        }
    });
    if (dir == null)
        return;
    for (String cpuDir : dir) {
        File fCpu = new File(cpuDir + "/current");
        assertTrue(fCpu.canRead());
    }
}
#end_block

#method_before
public static void setEnabledProtocols(long ssl, String[] protocols) {
    checkEnabledProtocols(protocols);
    // openssl uses negative logic letting you disable protocols.
    // so first, assume we need to set all (disable all) and clear none (enable none).
    // in the loop, selectively move bits from set to clear (from disable to enable)
    long optionsToSet = (NativeConstants.SSL_OP_NO_SSLv3 | NativeConstants.SSL_OP_NO_TLSv1 | NativeConstants.SSL_OP_NO_TLSv1_1 | NativeConstants.SSL_OP_NO_TLSv1_2);
    long optionsToClear = 0;
    for (int i = 0; i < protocols.length; i++) {
        String protocol = protocols[i];
        if (protocol.equals(SUPPORTED_PROTOCOL_TLSV1)) {
            optionsToSet &= ~NativeConstants.SSL_OP_NO_TLSv1;
            optionsToClear |= NativeConstants.SSL_OP_NO_TLSv1;
        } else if (protocol.equals(SUPPORTED_PROTOCOL_TLSV1_1)) {
            optionsToSet &= ~NativeConstants.SSL_OP_NO_TLSv1_1;
            optionsToClear |= NativeConstants.SSL_OP_NO_TLSv1_1;
        } else if (protocol.equals(SUPPORTED_PROTOCOL_TLSV1_2)) {
            optionsToSet &= ~NativeConstants.SSL_OP_NO_TLSv1_2;
            optionsToClear |= NativeConstants.SSL_OP_NO_TLSv1_2;
        } else {
            // error checked by checkEnabledProtocols
            throw new IllegalStateException();
        }
    }
    SSL_set_options(ssl, optionsToSet);
    SSL_clear_options(ssl, optionsToClear);
}
#method_after
public static void setEnabledProtocols(long ssl, String[] protocols) {
    checkEnabledProtocols(protocols);
    // openssl uses negative logic letting you disable protocols.
    // so first, assume we need to set all (disable all) and clear none (enable none).
    // in the loop, selectively move bits from set to clear (from disable to enable)
    long optionsToSet = (NativeConstants.SSL_OP_NO_SSLv3 | NativeConstants.SSL_OP_NO_TLSv1 | NativeConstants.SSL_OP_NO_TLSv1_1 | NativeConstants.SSL_OP_NO_TLSv1_2);
    long optionsToClear = 0;
    for (String protocol : protocols) {
        if (protocol.equals(SUPPORTED_PROTOCOL_TLSV1)) {
            optionsToSet &= ~NativeConstants.SSL_OP_NO_TLSv1;
            optionsToClear |= NativeConstants.SSL_OP_NO_TLSv1;
        } else if (protocol.equals(SUPPORTED_PROTOCOL_TLSV1_1)) {
            optionsToSet &= ~NativeConstants.SSL_OP_NO_TLSv1_1;
            optionsToClear |= NativeConstants.SSL_OP_NO_TLSv1_1;
        } else if (protocol.equals(SUPPORTED_PROTOCOL_TLSV1_2)) {
            optionsToSet &= ~NativeConstants.SSL_OP_NO_TLSv1_2;
            optionsToClear |= NativeConstants.SSL_OP_NO_TLSv1_2;
        } else if (protocol.equals(OBSOLETE_PROTOCOL_SSLV3)) {
        // Do nothing since we no longer support this protocol, but
        // allow it in the list of protocols so we can give an error
        // message about it if the handshake fails.
        } else {
            // error checked by checkEnabledProtocols
            throw new IllegalStateException();
        }
    }
    SSL_set_options(ssl, optionsToSet);
    SSL_clear_options(ssl, optionsToClear);
}
#end_block

#method_before
public static String[] checkEnabledProtocols(String[] protocols) {
    if (protocols == null) {
        throw new IllegalArgumentException("protocols == null");
    }
    for (int i = 0; i < protocols.length; i++) {
        String protocol = protocols[i];
        if (protocol == null) {
            throw new IllegalArgumentException("protocols[" + i + "] == null");
        }
        if ((!protocol.equals(SUPPORTED_PROTOCOL_TLSV1)) && (!protocol.equals(SUPPORTED_PROTOCOL_TLSV1_1)) && (!protocol.equals(SUPPORTED_PROTOCOL_TLSV1_2))) {
            throw new IllegalArgumentException("protocol " + protocol + " is not supported");
        }
    }
    return protocols;
}
#method_after
public static String[] checkEnabledProtocols(String[] protocols) {
    if (protocols == null) {
        throw new IllegalArgumentException("protocols == null");
    }
    for (String protocol : protocols) {
        if (protocol == null) {
            throw new IllegalArgumentException("protocols contains null");
        }
        if (!protocol.equals(SUPPORTED_PROTOCOL_TLSV1) && !protocol.equals(SUPPORTED_PROTOCOL_TLSV1_1) && !protocol.equals(SUPPORTED_PROTOCOL_TLSV1_2) && !protocol.equals(OBSOLETE_PROTOCOL_SSLV3)) {
            throw new IllegalArgumentException("protocol " + protocol + " is not supported");
        }
    }
    return protocols;
}
#end_block

#method_before
@Override
public void enter() {
    mDeathRecipient.unlinkToDeath();
    try {
        if (mNetworkObserver != null) {
            mNwService.unregisterObserver(mNetworkObserver);
            mNetworkObserver = null;
        }
    } catch (RemoteException e) {
    }
}
#method_after
@Override
public void enter() {
    mDeathRecipient.unlinkToDeath();
    unregisterObserver();
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CMD_START:
            updateApState(WifiManager.WIFI_AP_STATE_ENABLING, 0);
            if (!mDeathRecipient.linkToDeath(mApInterface.asBinder())) {
                mDeathRecipient.unlinkToDeath();
                updateApState(WifiManager.WIFI_AP_STATE_FAILED, WifiManager.SAP_START_FAILURE_GENERAL);
                break;
            }
            try {
                mNetworkObserver = new NetworkObserver(mApInterface.getInterfaceName());
                mNwService.registerObserver(mNetworkObserver);
            } catch (RemoteException e) {
                mDeathRecipient.unlinkToDeath();
                updateApState(WifiManager.WIFI_AP_STATE_FAILED, WifiManager.SAP_START_FAILURE_GENERAL);
                break;
            }
            int result = startSoftAp((WifiConfiguration) message.obj);
            if (result != SUCCESS) {
                int failureReason = WifiManager.SAP_START_FAILURE_GENERAL;
                if (result == ERROR_NO_CHANNEL) {
                    failureReason = WifiManager.SAP_START_FAILURE_NO_CHANNEL;
                }
                mDeathRecipient.unlinkToDeath();
                try {
                    mNwService.unregisterObserver(mNetworkObserver);
                } catch (RemoteException e) {
                }
                updateApState(WifiManager.WIFI_AP_STATE_FAILED, failureReason);
                break;
            }
            transitionTo(mStartedState);
            break;
        default:
            /* Ignore all other commands. */
            break;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CMD_START:
            updateApState(WifiManager.WIFI_AP_STATE_ENABLING, 0);
            if (!mDeathRecipient.linkToDeath(mApInterface.asBinder())) {
                mDeathRecipient.unlinkToDeath();
                updateApState(WifiManager.WIFI_AP_STATE_FAILED, WifiManager.SAP_START_FAILURE_GENERAL);
                break;
            }
            try {
                mNetworkObserver = new NetworkObserver(mApInterface.getInterfaceName());
                mNwService.registerObserver(mNetworkObserver);
            } catch (RemoteException e) {
                mDeathRecipient.unlinkToDeath();
                unregisterObserver();
                updateApState(WifiManager.WIFI_AP_STATE_FAILED, WifiManager.SAP_START_FAILURE_GENERAL);
                break;
            }
            int result = startSoftAp((WifiConfiguration) message.obj);
            if (result != SUCCESS) {
                int failureReason = WifiManager.SAP_START_FAILURE_GENERAL;
                if (result == ERROR_NO_CHANNEL) {
                    failureReason = WifiManager.SAP_START_FAILURE_NO_CHANNEL;
                }
                mDeathRecipient.unlinkToDeath();
                unregisterObserver();
                updateApState(WifiManager.WIFI_AP_STATE_FAILED, failureReason);
                break;
            }
            transitionTo(mStartedState);
            break;
        default:
            /* Ignore all other commands. */
            break;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void enter() {
    mIfaceIsUp = false;
}
#method_after
@Override
public void enter() {
    mIfaceIsUp = false;
    InterfaceConfiguration config = null;
    try {
        config = mNwService.getInterfaceConfig(mApInterface.getInterfaceName());
    } catch (RemoteException e) {
    }
    if (config != null) {
        onUpChanged(config.isUp());
    }
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CMD_INTERFACE_STATUS_CHANGED:
            if (message.obj != mNetworkObserver) {
                // This is from some time before the most recent configuration.
                break;
            }
            boolean isUp = message.arg1 == 1;
            if (isUp == mIfaceIsUp) {
                // We're only watching for transitions from down to up and vice versa.
                break;
            }
            mIfaceIsUp = isUp;
            if (isUp) {
                Log.d(TAG, "SoftAp is ready for use");
                updateApState(WifiManager.WIFI_AP_STATE_ENABLED, 0);
            } else {
            // TODO: handle the case where the interface was up, but goes down
            }
            break;
        case CMD_START:
            /* Already started, ignore this command. */
            break;
        case CMD_AP_INTERFACE_BINDER_DEATH:
        case CMD_STOP:
            updateApState(WifiManager.WIFI_AP_STATE_DISABLING, 0);
            stopSoftAp();
            if (message.what == CMD_AP_INTERFACE_BINDER_DEATH) {
                updateApState(WifiManager.WIFI_AP_STATE_FAILED, WifiManager.SAP_START_FAILURE_GENERAL);
            } else {
                updateApState(WifiManager.WIFI_AP_STATE_DISABLED, 0);
            }
            transitionTo(mIdleState);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CMD_INTERFACE_STATUS_CHANGED:
            if (message.obj != mNetworkObserver) {
                // This is from some time before the most recent configuration.
                break;
            }
            boolean isUp = message.arg1 == 1;
            onUpChanged(isUp);
            break;
        case CMD_START:
            /* Already started, ignore this command. */
            break;
        case CMD_AP_INTERFACE_BINDER_DEATH:
        case CMD_STOP:
            updateApState(WifiManager.WIFI_AP_STATE_DISABLING, 0);
            stopSoftAp();
            if (message.what == CMD_AP_INTERFACE_BINDER_DEATH) {
                updateApState(WifiManager.WIFI_AP_STATE_FAILED, WifiManager.SAP_START_FAILURE_GENERAL);
            } else {
                updateApState(WifiManager.WIFI_AP_STATE_DISABLED, 0);
            }
            transitionTo(mIdleState);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
final boolean forceStopPackageLocked(String packageName, int appId, boolean callerWillRestart, boolean purgeCache, boolean doit, boolean evenPersistent, boolean uninstalling, int userId, String reason) {
    int i;
    if (userId == UserHandle.USER_ALL && packageName == null) {
        Slog.w(TAG, "Can't force stop all processes of all users, that is insane!");
    }
    if (appId < 0 && packageName != null) {
        try {
            appId = UserHandle.getAppId(AppGlobals.getPackageManager().getPackageUid(packageName, MATCH_DEBUG_TRIAGED_MISSING, 0));
        } catch (RemoteException e) {
        }
    }
    if (doit) {
        if (packageName != null) {
            Slog.i(TAG, "Force stopping " + packageName + " appid=" + appId + " user=" + userId + ": " + reason);
        } else {
            Slog.i(TAG, "Force stopping u" + userId + ": " + reason);
        }
        mAppErrors.resetProcessCrashTimeLocked(packageName == null, appId, userId);
    }
    boolean didSomething = killPackageProcessesLocked(packageName, appId, userId, ProcessList.INVALID_ADJ, callerWillRestart, true, doit, evenPersistent, packageName == null ? ("stop user " + userId) : ("stop " + packageName));
    if (mStackSupervisor.finishDisabledPackageActivitiesLocked(packageName, null, doit, evenPersistent, userId)) {
        if (!doit) {
            return true;
        }
        didSomething = true;
    }
    if (mServices.bringDownDisabledPackageServicesLocked(packageName, null, userId, evenPersistent, true, doit)) {
        if (!doit) {
            return true;
        }
        didSomething = true;
    }
    if (packageName == null) {
        // Remove all sticky broadcasts from this user.
        mStickyBroadcasts.remove(userId);
    }
    ArrayList<ContentProviderRecord> providers = new ArrayList<>();
    if (mProviderMap.collectPackageProvidersLocked(packageName, null, doit, evenPersistent, userId, providers)) {
        if (!doit) {
            return true;
        }
        didSomething = true;
    }
    for (i = providers.size() - 1; i >= 0; i--) {
        removeDyingProviderLocked(null, providers.get(i), true);
    }
    // Remove transient permissions granted from/to this package/user
    removeUriPermissionsForPackageLocked(packageName, userId, false);
    if (doit) {
        for (i = mBroadcastQueues.length - 1; i >= 0; i--) {
            didSomething |= mBroadcastQueues[i].cleanupDisabledPackageReceiversLocked(packageName, null, userId, doit);
        }
    }
    if (packageName == null || uninstalling) {
        // such packages, so they can be left with bad pending intents.
        if (mIntentSenderRecords.size() > 0) {
            Iterator<WeakReference<PendingIntentRecord>> it = mIntentSenderRecords.values().iterator();
            while (it.hasNext()) {
                WeakReference<PendingIntentRecord> wpir = it.next();
                if (wpir == null) {
                    it.remove();
                    continue;
                }
                PendingIntentRecord pir = wpir.get();
                if (pir == null) {
                    it.remove();
                    continue;
                }
                if (packageName == null) {
                    // Stopping user, remove all objects for the user.
                    if (pir.key.userId != userId) {
                        // Not the same user, skip it.
                        continue;
                    }
                } else {
                    if (UserHandle.getAppId(pir.uid) != appId) {
                        // Different app id, skip it.
                        continue;
                    }
                    if (userId != UserHandle.USER_ALL && pir.key.userId != userId) {
                        // Different user, skip it.
                        continue;
                    }
                    if (!pir.key.packageName.equals(packageName)) {
                        // Different package, skip it.
                        continue;
                    }
                }
                if (!doit) {
                    return true;
                }
                didSomething = true;
                it.remove();
                pir.canceled = true;
                if (pir.key.activity != null && pir.key.activity.pendingResults != null) {
                    pir.key.activity.pendingResults.remove(pir.ref);
                }
            }
        }
    }
    if (doit) {
        if (purgeCache && packageName != null) {
            AttributeCache ac = AttributeCache.instance();
            if (ac != null) {
                ac.removePackage(packageName);
            }
        }
        if (mBooted) {
            mStackSupervisor.resumeFocusedStackTopActivityLocked();
            mStackSupervisor.scheduleIdleLocked();
        }
    }
    return didSomething;
}
#method_after
final boolean forceStopPackageLocked(String packageName, int appId, boolean callerWillRestart, boolean purgeCache, boolean doit, boolean evenPersistent, boolean uninstalling, int userId, String reason) {
    int i;
    if (userId == UserHandle.USER_ALL && packageName == null) {
        Slog.w(TAG, "Can't force stop all processes of all users, that is insane!");
    }
    if (appId < 0 && packageName != null) {
        try {
            appId = UserHandle.getAppId(AppGlobals.getPackageManager().getPackageUid(packageName, MATCH_DEBUG_TRIAGED_MISSING, 0));
        } catch (RemoteException e) {
        }
    }
    if (doit) {
        if (packageName != null) {
            Slog.i(TAG, "Force stopping " + packageName + " appid=" + appId + " user=" + userId + ": " + reason);
        } else {
            Slog.i(TAG, "Force stopping u" + userId + ": " + reason);
        }
        mAppErrors.resetProcessCrashTimeLocked(packageName == null, appId, userId);
    }
    boolean didSomething = killPackageProcessesLocked(packageName, appId, userId, ProcessList.INVALID_ADJ, callerWillRestart, true, doit, evenPersistent, packageName == null ? ("stop user " + userId) : ("stop " + packageName));
    didSomething |= mActivityStarter.clearPendingActivityLaunchesLocked(packageName);
    if (mStackSupervisor.finishDisabledPackageActivitiesLocked(packageName, null, doit, evenPersistent, userId)) {
        if (!doit) {
            return true;
        }
        didSomething = true;
    }
    if (mServices.bringDownDisabledPackageServicesLocked(packageName, null, userId, evenPersistent, true, doit)) {
        if (!doit) {
            return true;
        }
        didSomething = true;
    }
    if (packageName == null) {
        // Remove all sticky broadcasts from this user.
        mStickyBroadcasts.remove(userId);
    }
    ArrayList<ContentProviderRecord> providers = new ArrayList<>();
    if (mProviderMap.collectPackageProvidersLocked(packageName, null, doit, evenPersistent, userId, providers)) {
        if (!doit) {
            return true;
        }
        didSomething = true;
    }
    for (i = providers.size() - 1; i >= 0; i--) {
        removeDyingProviderLocked(null, providers.get(i), true);
    }
    // Remove transient permissions granted from/to this package/user
    removeUriPermissionsForPackageLocked(packageName, userId, false);
    if (doit) {
        for (i = mBroadcastQueues.length - 1; i >= 0; i--) {
            didSomething |= mBroadcastQueues[i].cleanupDisabledPackageReceiversLocked(packageName, null, userId, doit);
        }
    }
    if (packageName == null || uninstalling) {
        // such packages, so they can be left with bad pending intents.
        if (mIntentSenderRecords.size() > 0) {
            Iterator<WeakReference<PendingIntentRecord>> it = mIntentSenderRecords.values().iterator();
            while (it.hasNext()) {
                WeakReference<PendingIntentRecord> wpir = it.next();
                if (wpir == null) {
                    it.remove();
                    continue;
                }
                PendingIntentRecord pir = wpir.get();
                if (pir == null) {
                    it.remove();
                    continue;
                }
                if (packageName == null) {
                    // Stopping user, remove all objects for the user.
                    if (pir.key.userId != userId) {
                        // Not the same user, skip it.
                        continue;
                    }
                } else {
                    if (UserHandle.getAppId(pir.uid) != appId) {
                        // Different app id, skip it.
                        continue;
                    }
                    if (userId != UserHandle.USER_ALL && pir.key.userId != userId) {
                        // Different user, skip it.
                        continue;
                    }
                    if (!pir.key.packageName.equals(packageName)) {
                        // Different package, skip it.
                        continue;
                    }
                }
                if (!doit) {
                    return true;
                }
                didSomething = true;
                it.remove();
                pir.canceled = true;
                if (pir.key.activity != null && pir.key.activity.pendingResults != null) {
                    pir.key.activity.pendingResults.remove(pir.ref);
                }
            }
        }
    }
    if (doit) {
        if (purgeCache && packageName != null) {
            AttributeCache ac = AttributeCache.instance();
            if (ac != null) {
                ac.removePackage(packageName);
            }
        }
        if (mBooted) {
            mStackSupervisor.resumeFocusedStackTopActivityLocked();
            mStackSupervisor.scheduleIdleLocked();
        }
    }
    return didSomething;
}
#end_block

#method_before
private void cleanUpRemovedTaskLocked(TaskRecord tr, boolean killProcess, boolean removeFromRecents) {
    if (removeFromRecents) {
        mRecentTasks.remove(tr);
        tr.removedFromRecents();
    }
    ComponentName component = tr.getBaseIntent().getComponent();
    if (component == null) {
        Slog.w(TAG, "No component for base intent of task: " + tr);
        return;
    }
    // Find any running services associated with this app and stop if needed.
    mServices.cleanUpRemovedTaskLocked(tr, component, new Intent(tr.getBaseIntent()));
    if (!killProcess) {
        return;
    }
    // Determine if the process(es) for this task should be killed.
    final String pkg = component.getPackageName();
    ArrayList<ProcessRecord> procsToKill = new ArrayList<>();
    ArrayMap<String, SparseArray<ProcessRecord>> pmap = mProcessNames.getMap();
    for (int i = 0; i < pmap.size(); i++) {
        SparseArray<ProcessRecord> uids = pmap.valueAt(i);
        for (int j = 0; j < uids.size(); j++) {
            ProcessRecord proc = uids.valueAt(j);
            if (proc.userId != tr.userId) {
                // Don't kill process for a different user.
                continue;
            }
            if (proc == mHomeProcess) {
                // Don't kill the home process along with tasks from the same package.
                continue;
            }
            if (!proc.pkgList.containsKey(pkg)) {
                // Don't kill process that is not associated with this task.
                continue;
            }
            for (int k = 0; k < proc.activities.size(); k++) {
                TaskRecord otherTask = proc.activities.get(k).task;
                if (tr.taskId != otherTask.taskId && otherTask.inRecents) {
                    // also in recents.
                    return;
                }
            }
            if (proc.foregroundServices) {
                // Don't kill process(es) with foreground service.
                return;
            }
            // Add process to kill list.
            procsToKill.add(proc);
        }
    }
    // Kill the running processes.
    for (int i = 0; i < procsToKill.size(); i++) {
        ProcessRecord pr = procsToKill.get(i);
        if (pr.setSchedGroup == ProcessList.SCHED_GROUP_BACKGROUND && pr.curReceivers.size() == 0) {
            pr.kill("remove task", true);
        } else {
            // We delay killing processes that are not in the background or running a receiver.
            pr.waitingToKill = "remove task";
        }
    }
}
#method_after
private void cleanUpRemovedTaskLocked(TaskRecord tr, boolean killProcess, boolean removeFromRecents) {
    if (removeFromRecents) {
        mRecentTasks.remove(tr);
        tr.removedFromRecents();
    }
    ComponentName component = tr.getBaseIntent().getComponent();
    if (component == null) {
        Slog.w(TAG, "No component for base intent of task: " + tr);
        return;
    }
    // Find any running services associated with this app and stop if needed.
    mServices.cleanUpRemovedTaskLocked(tr, component, new Intent(tr.getBaseIntent()));
    if (!killProcess) {
        return;
    }
    // Determine if the process(es) for this task should be killed.
    final String pkg = component.getPackageName();
    ArrayList<ProcessRecord> procsToKill = new ArrayList<>();
    ArrayMap<String, SparseArray<ProcessRecord>> pmap = mProcessNames.getMap();
    for (int i = 0; i < pmap.size(); i++) {
        SparseArray<ProcessRecord> uids = pmap.valueAt(i);
        for (int j = 0; j < uids.size(); j++) {
            ProcessRecord proc = uids.valueAt(j);
            if (proc.userId != tr.userId) {
                // Don't kill process for a different user.
                continue;
            }
            if (proc == mHomeProcess) {
                // Don't kill the home process along with tasks from the same package.
                continue;
            }
            if (!proc.pkgList.containsKey(pkg)) {
                // Don't kill process that is not associated with this task.
                continue;
            }
            for (int k = 0; k < proc.activities.size(); k++) {
                TaskRecord otherTask = proc.activities.get(k).task;
                if (tr.taskId != otherTask.taskId && otherTask.inRecents) {
                    // also in recents.
                    return;
                }
            }
            if (proc.foregroundServices) {
                // Don't kill process(es) with foreground service.
                return;
            }
            // Add process to kill list.
            procsToKill.add(proc);
        }
    }
    // Kill the running processes.
    for (int i = 0; i < procsToKill.size(); i++) {
        ProcessRecord pr = procsToKill.get(i);
        if (pr.setSchedGroup == ProcessList.SCHED_GROUP_BACKGROUND && pr.curReceivers.isEmpty()) {
            pr.kill("remove task", true);
        } else {
            // We delay killing processes that are not in the background or running a receiver.
            pr.waitingToKill = "remove task";
        }
    }
}
#end_block

#method_before
// =========================================================
// GLOBAL MANAGEMENT
// =========================================================
final ProcessRecord newProcessRecordLocked(ApplicationInfo info, String customProcess, boolean isolated, int isolatedUid) {
    String proc = customProcess != null ? customProcess : info.processName;
    BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
    final int userId = UserHandle.getUserId(info.uid);
    int uid = info.uid;
    if (isolated) {
        if (isolatedUid == 0) {
            int stepsLeft = Process.LAST_ISOLATED_UID - Process.FIRST_ISOLATED_UID + 1;
            while (true) {
                if (mNextIsolatedProcessUid < Process.FIRST_ISOLATED_UID || mNextIsolatedProcessUid > Process.LAST_ISOLATED_UID) {
                    mNextIsolatedProcessUid = Process.FIRST_ISOLATED_UID;
                }
                uid = UserHandle.getUid(userId, mNextIsolatedProcessUid);
                mNextIsolatedProcessUid++;
                if (mIsolatedProcesses.indexOfKey(uid) < 0) {
                    // No process for this uid, use it.
                    break;
                }
                stepsLeft--;
                if (stepsLeft <= 0) {
                    return null;
                }
            }
        } else {
            // Special case for startIsolatedProcess (internal only), where
            // the uid of the isolated process is specified by the caller.
            uid = isolatedUid;
        }
    }
    final ProcessRecord r = new ProcessRecord(stats, info, proc, uid);
    if (!mBooted && !mBooting && userId == UserHandle.USER_SYSTEM && (info.flags & PERSISTENT_MASK) == PERSISTENT_MASK) {
        r.persistent = true;
    }
    addProcessNameLocked(r);
    return r;
}
#method_after
// =========================================================
// GLOBAL MANAGEMENT
// =========================================================
final ProcessRecord newProcessRecordLocked(ApplicationInfo info, String customProcess, boolean isolated, int isolatedUid) {
    String proc = customProcess != null ? customProcess : info.processName;
    BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
    final int userId = UserHandle.getUserId(info.uid);
    int uid = info.uid;
    if (isolated) {
        if (isolatedUid == 0) {
            int stepsLeft = Process.LAST_ISOLATED_UID - Process.FIRST_ISOLATED_UID + 1;
            while (true) {
                if (mNextIsolatedProcessUid < Process.FIRST_ISOLATED_UID || mNextIsolatedProcessUid > Process.LAST_ISOLATED_UID) {
                    mNextIsolatedProcessUid = Process.FIRST_ISOLATED_UID;
                }
                uid = UserHandle.getUid(userId, mNextIsolatedProcessUid);
                mNextIsolatedProcessUid++;
                if (mIsolatedProcesses.indexOfKey(uid) < 0) {
                    // No process for this uid, use it.
                    break;
                }
                stepsLeft--;
                if (stepsLeft <= 0) {
                    return null;
                }
            }
        } else {
            // Special case for startIsolatedProcess (internal only), where
            // the uid of the isolated process is specified by the caller.
            uid = isolatedUid;
        }
    }
    final ProcessRecord r = new ProcessRecord(stats, info, proc, uid);
    if (!mBooted && !mBooting && userId == UserHandle.USER_SYSTEM && (info.flags & PERSISTENT_MASK) == PERSISTENT_MASK) {
        r.persistent = true;
        r.maxAdj = ProcessList.PERSISTENT_PROC_ADJ;
    }
    addProcessNameLocked(r);
    return r;
}
#end_block

#method_before
private final int computeOomAdjLocked(ProcessRecord app, int cachedAdj, ProcessRecord TOP_APP, boolean doingAll, long now) {
    if (mAdjSeq == app.adjSeq) {
        // This adjustment has already been computed.
        return app.curRawAdj;
    }
    if (app.thread == null) {
        app.adjSeq = mAdjSeq;
        app.curSchedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
        app.curProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        return (app.curAdj = app.curRawAdj = ProcessList.CACHED_APP_MAX_ADJ);
    }
    app.adjTypeCode = ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
    app.adjSource = null;
    app.adjTarget = null;
    app.empty = false;
    app.cached = false;
    final int activitiesSize = app.activities.size();
    if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
        // The max adjustment doesn't allow this app to be anything
        // below foreground, so it is not worth doing work for it.
        app.adjType = "fixed";
        app.adjSeq = mAdjSeq;
        app.curRawAdj = app.maxAdj;
        app.foregroundActivities = false;
        app.curSchedGroup = ProcessList.SCHED_GROUP_DEFAULT;
        app.curProcState = ActivityManager.PROCESS_STATE_PERSISTENT;
        // System processes can do UI, and when they do we want to have
        // them trim their memory after the user leaves the UI.  To
        // facilitate this, here we need to determine whether or not it
        // is currently showing UI.
        app.systemNoUi = true;
        if (app == TOP_APP) {
            app.systemNoUi = false;
            app.curSchedGroup = ProcessList.SCHED_GROUP_TOP_APP;
            app.adjType = "pers-top-activity";
        } else if (activitiesSize > 0) {
            for (int j = 0; j < activitiesSize; j++) {
                final ActivityRecord r = app.activities.get(j);
                if (r.visible) {
                    app.systemNoUi = false;
                }
            }
        }
        if (!app.systemNoUi) {
            app.curProcState = ActivityManager.PROCESS_STATE_PERSISTENT_UI;
        }
        return (app.curAdj = app.maxAdj);
    }
    app.systemNoUi = false;
    final int PROCESS_STATE_CUR_TOP = mTopProcessState;
    // Determine the importance of the process, starting with most
    // important to least, and assign an appropriate OOM adjustment.
    int adj;
    int schedGroup;
    int procState;
    boolean foregroundActivities = false;
    ArraySet<BroadcastQueue> queues;
    if (app == TOP_APP) {
        // The last app on the list is the foreground app.
        adj = ProcessList.FOREGROUND_APP_ADJ;
        schedGroup = ProcessList.SCHED_GROUP_TOP_APP;
        app.adjType = "top-activity";
        foregroundActivities = true;
        procState = PROCESS_STATE_CUR_TOP;
    } else if (app.instrumentationClass != null) {
        // Don't want to kill running instrumentation.
        adj = ProcessList.FOREGROUND_APP_ADJ;
        schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
        app.adjType = "instrumentation";
        procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
    } else if ((queues = isReceivingBroadcast(app)).size() > 0) {
        // An app that is currently receiving a broadcast also
        // counts as being in the foreground for OOM killer purposes.
        // It's placed in a sched group based on the nature of the
        // broadcast as reflected by which queue it's active in.
        adj = ProcessList.FOREGROUND_APP_ADJ;
        schedGroup = (queues.contains(mFgBroadcastQueue)) ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;
        app.adjType = "broadcast";
        procState = ActivityManager.PROCESS_STATE_RECEIVER;
    } else if (app.executingServices.size() > 0) {
        // An app that is currently executing a service callback also
        // counts as being in the foreground.
        adj = ProcessList.FOREGROUND_APP_ADJ;
        schedGroup = app.execServicesFg ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;
        app.adjType = "exec-service";
        procState = ActivityManager.PROCESS_STATE_SERVICE;
    // Slog.i(TAG, "EXEC " + (app.execServicesFg ? "FG" : "BG") + ": " + app);
    } else {
        // As far as we know the process is empty.  We may change our mind later.
        schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
        // At this point we don't actually know the adjustment.  Use the cached adj
        // value that the caller wants us to.
        adj = cachedAdj;
        procState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        app.cached = true;
        app.empty = true;
        app.adjType = "cch-empty";
    }
    // Examine all activities if not already foreground.
    if (!foregroundActivities && activitiesSize > 0) {
        int minLayer = ProcessList.VISIBLE_APP_LAYER_MAX;
        for (int j = 0; j < activitiesSize; j++) {
            final ActivityRecord r = app.activities.get(j);
            if (r.app != app) {
                Log.e(TAG, "Found activity " + r + " in proc activity list using " + r.app + " instead of expected " + app);
                if (r.app == null || (r.app.uid == app.uid)) {
                    // Only fix things up when they look sane
                    r.app = app;
                } else {
                    continue;
                }
            }
            if (r.visible) {
                // App has a visible activity; only upgrade adjustment.
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                    adj = ProcessList.VISIBLE_APP_ADJ;
                    app.adjType = "visible";
                }
                if (procState > PROCESS_STATE_CUR_TOP) {
                    procState = PROCESS_STATE_CUR_TOP;
                }
                schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
                app.cached = false;
                app.empty = false;
                foregroundActivities = true;
                if (r.task != null && minLayer > 0) {
                    final int layer = r.task.mLayerRank;
                    if (layer >= 0 && minLayer > layer) {
                        minLayer = layer;
                    }
                }
                break;
            } else if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
                if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                    adj = ProcessList.PERCEPTIBLE_APP_ADJ;
                    app.adjType = "pausing";
                }
                if (procState > PROCESS_STATE_CUR_TOP) {
                    procState = PROCESS_STATE_CUR_TOP;
                }
                schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
                app.cached = false;
                app.empty = false;
                foregroundActivities = true;
            } else if (r.state == ActivityState.STOPPING) {
                if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                    adj = ProcessList.PERCEPTIBLE_APP_ADJ;
                    app.adjType = "stopping";
                }
                // processes and they should soon all go into the cached state.
                if (!r.finishing) {
                    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
                        procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
                    }
                }
                app.cached = false;
                app.empty = false;
                foregroundActivities = true;
            } else {
                if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
                    procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
                    app.adjType = "cch-act";
                }
            }
        }
        if (adj == ProcessList.VISIBLE_APP_ADJ) {
            adj += minLayer;
        }
    }
    if (adj > ProcessList.PERCEPTIBLE_APP_ADJ || procState > ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE) {
        if (app.foregroundServices) {
            // The user is aware of this app, so make it visible.
            adj = ProcessList.PERCEPTIBLE_APP_ADJ;
            procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
            app.cached = false;
            app.adjType = "fg-service";
            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
        } else if (app.forcingToForeground != null) {
            // The user is aware of this app, so make it visible.
            adj = ProcessList.PERCEPTIBLE_APP_ADJ;
            procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
            app.cached = false;
            app.adjType = "force-fg";
            app.adjSource = app.forcingToForeground;
            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
        }
    }
    if (app == mHeavyWeightProcess) {
        if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
            // We don't want to kill the current heavy-weight process.
            adj = ProcessList.HEAVY_WEIGHT_APP_ADJ;
            schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
            app.cached = false;
            app.adjType = "heavy";
        }
        if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
            procState = ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
        }
    }
    if (app == mHomeProcess) {
        if (adj > ProcessList.HOME_APP_ADJ) {
            // This process is hosting what we currently consider to be the
            // home app, so we don't want to let it go into the background.
            adj = ProcessList.HOME_APP_ADJ;
            schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
            app.cached = false;
            app.adjType = "home";
        }
        if (procState > ActivityManager.PROCESS_STATE_HOME) {
            procState = ActivityManager.PROCESS_STATE_HOME;
        }
    }
    if (app == mPreviousProcess && app.activities.size() > 0) {
        if (adj > ProcessList.PREVIOUS_APP_ADJ) {
            // This was the previous process that showed UI to the user.
            // We want to try to keep it around more aggressively, to give
            // a good experience around switching between two apps.
            adj = ProcessList.PREVIOUS_APP_ADJ;
            schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
            app.cached = false;
            app.adjType = "previous";
        }
        if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
            procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
        }
    }
    if (false)
        Slog.i(TAG, "OOM " + app + ": initial adj=" + adj + " reason=" + app.adjType);
    // By default, we use the computed adjustment.  It may be changed if
    // there are applications dependent on our services or providers, but
    // this gives us a baseline and makes sure we don't get into an
    // infinite recursion.
    app.adjSeq = mAdjSeq;
    app.curRawAdj = adj;
    app.hasStartedServices = false;
    if (mBackupTarget != null && app == mBackupTarget.app) {
        // If possible we want to avoid killing apps while they're being backed up
        if (adj > ProcessList.BACKUP_APP_ADJ) {
            if (DEBUG_BACKUP)
                Slog.v(TAG_BACKUP, "oom BACKUP_APP_ADJ for " + app);
            adj = ProcessList.BACKUP_APP_ADJ;
            if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
                procState = ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
            app.adjType = "backup";
            app.cached = false;
        }
        if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
            procState = ActivityManager.PROCESS_STATE_BACKUP;
        }
    }
    boolean mayBeTop = false;
    for (int is = app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); is--) {
        ServiceRecord s = app.services.valueAt(is);
        if (s.startRequested) {
            app.hasStartedServices = true;
            if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
                procState = ActivityManager.PROCESS_STATE_SERVICE;
            }
            if (app.hasShownUi && app != mHomeProcess) {
                // debug and understand what is going on.
                if (adj > ProcessList.SERVICE_ADJ) {
                    app.adjType = "cch-started-ui-services";
                }
            } else {
                if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                    // of the background processes.
                    if (adj > ProcessList.SERVICE_ADJ) {
                        adj = ProcessList.SERVICE_ADJ;
                        app.adjType = "started-services";
                        app.cached = false;
                    }
                }
                // even though the service no longer has an impact.
                if (adj > ProcessList.SERVICE_ADJ) {
                    app.adjType = "cch-started-services";
                }
            }
        }
        for (int conni = s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); conni--) {
            ArrayList<ConnectionRecord> clist = s.connections.valueAt(conni);
            for (int i = 0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); i++) {
                // XXX should compute this based on the max of
                // all connected clients.
                ConnectionRecord cr = clist.get(i);
                if (cr.binding.client == app) {
                    // Binding to ourself is not interesting.
                    continue;
                }
                if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
                    ProcessRecord client = cr.binding.client;
                    int clientAdj = computeOomAdjLocked(client, cachedAdj, TOP_APP, doingAll, now);
                    int clientProcState = client.curProcState;
                    if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
                        // If the other app is cached for any reason, for purposes here
                        // we are going to consider it empty.  The specific cached state
                        // doesn't propagate except under certain conditions.
                        clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
                    }
                    String adjType = null;
                    if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
                        // this guy more like a started service.
                        if (app.hasShownUi && app != mHomeProcess) {
                            // debug and understand what is going on.
                            if (adj > clientAdj) {
                                adjType = "cch-bound-ui-services";
                            }
                            app.cached = false;
                            clientAdj = adj;
                            clientProcState = procState;
                        } else {
                            if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                                // to help debug and undertand what is going on.
                                if (adj > clientAdj) {
                                    adjType = "cch-bound-services";
                                }
                                clientAdj = adj;
                            }
                        }
                    }
                    if (adj > clientAdj) {
                        // memory.
                        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                            adjType = "cch-bound-ui-services";
                        } else {
                            if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                                adj = clientAdj >= ProcessList.PERSISTENT_SERVICE_ADJ ? clientAdj : ProcessList.PERSISTENT_SERVICE_ADJ;
                            } else if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                                adj = ProcessList.PERCEPTIBLE_APP_ADJ;
                            } else if (clientAdj >= ProcessList.PERCEPTIBLE_APP_ADJ) {
                                adj = clientAdj;
                            } else {
                                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                                    adj = Math.max(clientAdj, ProcessList.VISIBLE_APP_ADJ);
                                }
                            }
                            if (!client.cached) {
                                app.cached = false;
                            }
                            adjType = "service";
                        }
                    }
                    if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
                        // foreground work.
                        if (client.curSchedGroup > schedGroup) {
                            if ((cr.flags & Context.BIND_IMPORTANT) != 0) {
                                schedGroup = client.curSchedGroup;
                            } else {
                                schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
                            }
                        }
                        if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
                            if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                                // Special handling of clients who are in the top state.
                                // We *may* want to consider this process to be in the
                                // top state as well, but only if there is not another
                                // reason for it to be running.  Being on the top is a
                                // special state, meaning you are specifically running
                                // for the current top app.  If the process is already
                                // running in the background for some other reason, it
                                // is more important to continue considering it to be
                                // in the background state.
                                mayBeTop = true;
                                clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
                            } else {
                                // give them the best state after that.
                                if ((cr.flags & Context.BIND_FOREGROUND_SERVICE) != 0) {
                                    clientProcState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                                } else if (mWakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE && (cr.flags & Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE) != 0) {
                                    clientProcState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                                } else {
                                    clientProcState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
                                }
                            }
                        }
                    } else {
                        if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
                            clientProcState = ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
                        }
                    }
                    if (procState > clientProcState) {
                        procState = clientProcState;
                    }
                    if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
                        app.pendingUiClean = true;
                    }
                    if (adjType != null) {
                        app.adjType = adjType;
                        app.adjTypeCode = ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
                        app.adjSource = cr.binding.client;
                        app.adjSourceProcState = clientProcState;
                        app.adjTarget = s.name;
                    }
                }
                if ((cr.flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
                    app.treatLikeActivity = true;
                }
                final ActivityRecord a = cr.activity;
                if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
                    if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
                        adj = ProcessList.FOREGROUND_APP_ADJ;
                        if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
                            if ((cr.flags & Context.BIND_IMPORTANT) != 0) {
                                schedGroup = ProcessList.SCHED_GROUP_TOP_APP;
                            } else {
                                schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
                            }
                        }
                        app.cached = false;
                        app.adjType = "service";
                        app.adjTypeCode = ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
                        app.adjSource = a;
                        app.adjSourceProcState = procState;
                        app.adjTarget = s.name;
                    }
                }
            }
        }
    }
    for (int provi = app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); provi--) {
        ContentProviderRecord cpr = app.pubProviders.valueAt(provi);
        for (int i = cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); i--) {
            ContentProviderConnection conn = cpr.connections.get(i);
            ProcessRecord client = conn.client;
            if (client == app) {
                // Being our own client is not interesting.
                continue;
            }
            int clientAdj = computeOomAdjLocked(client, cachedAdj, TOP_APP, doingAll, now);
            int clientProcState = client.curProcState;
            if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
                // If the other app is cached for any reason, for purposes here
                // we are going to consider it empty.
                clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
            }
            if (adj > clientAdj) {
                if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                    app.adjType = "cch-ui-provider";
                } else {
                    adj = clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
                    app.adjType = "provider";
                }
                app.cached &= client.cached;
                app.adjTypeCode = ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
                app.adjSource = client;
                app.adjSourceProcState = clientProcState;
                app.adjTarget = cpr.name;
            }
            if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
                if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                    // Special handling of clients who are in the top state.
                    // We *may* want to consider this process to be in the
                    // top state as well, but only if there is not another
                    // reason for it to be running.  Being on the top is a
                    // special state, meaning you are specifically running
                    // for the current top app.  If the process is already
                    // running in the background for some other reason, it
                    // is more important to continue considering it to be
                    // in the background state.
                    mayBeTop = true;
                    clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
                } else {
                    // Special handling for above-top states (persistent
                    // processes).  These should not bring the current process
                    // into the top state, since they are not on top.  Instead
                    // give them the best state after that.
                    clientProcState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                }
            }
            if (procState > clientProcState) {
                procState = clientProcState;
            }
            if (client.curSchedGroup > schedGroup) {
                schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
            }
        }
        // FOREGROUND_APP_ADJ.
        if (cpr.hasExternalProcessHandles()) {
            if (adj > ProcessList.FOREGROUND_APP_ADJ) {
                adj = ProcessList.FOREGROUND_APP_ADJ;
                schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
                app.cached = false;
                app.adjType = "provider";
                app.adjTarget = cpr.name;
            }
            if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
                procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
            }
        }
    }
    if (app.lastProviderTime > 0 && (app.lastProviderTime + CONTENT_PROVIDER_RETAIN_TIME) > now) {
        if (adj > ProcessList.PREVIOUS_APP_ADJ) {
            adj = ProcessList.PREVIOUS_APP_ADJ;
            schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
            app.cached = false;
            app.adjType = "provider";
        }
        if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
            procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
        }
    }
    if (mayBeTop && procState > ActivityManager.PROCESS_STATE_TOP) {
        // to the top state.
        switch(procState) {
            case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
            case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
            case ActivityManager.PROCESS_STATE_SERVICE:
                // These all are longer-term states, so pull them up to the top
                // of the background states, but not all the way to the top state.
                procState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                break;
            default:
                // Otherwise, top is a better choice, so take it.
                procState = ActivityManager.PROCESS_STATE_TOP;
                break;
        }
    }
    if (procState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
        if (app.hasClientActivities) {
            // This is a cached process, but with client activities.  Mark it so.
            procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
            app.adjType = "cch-client-act";
        } else if (app.treatLikeActivity) {
            // This is a cached process, but somebody wants us to treat it like it has
            // an activity, okay!
            procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
            app.adjType = "cch-as-act";
        }
    }
    if (adj == ProcessList.SERVICE_ADJ) {
        if (doingAll) {
            app.serviceb = mNewNumAServiceProcs > (mNumServiceProcs / 3);
            mNewNumServiceProcs++;
            // Slog.i(TAG, "ADJ " + app + " serviceb=" + app.serviceb);
            if (!app.serviceb) {
                // keep launcher over it.
                if (mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
                    app.serviceHighRam = true;
                    app.serviceb = true;
                // Slog.i(TAG, "ADJ " + app + " high ram!");
                } else {
                    mNewNumAServiceProcs++;
                // Slog.i(TAG, "ADJ " + app + " not high ram!");
                }
            } else {
                app.serviceHighRam = false;
            }
        }
        if (app.serviceb) {
            adj = ProcessList.SERVICE_B_ADJ;
        }
    }
    app.curRawAdj = adj;
    // " adj=" + adj + " curAdj=" + app.curAdj + " maxAdj=" + app.maxAdj);
    if (adj > app.maxAdj) {
        adj = app.maxAdj;
        if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
        }
    }
    // Do final modification to adj.  Everything we do between here and applying
    // the final setAdj must be done in this function, because we will also use
    // it when computing the final cached adj later.  Note that we don't need to
    // worry about this for max adj above, since max adj will always be used to
    // keep it out of the cached vaues.
    app.curAdj = app.modifyRawOomAdj(adj);
    app.curSchedGroup = schedGroup;
    app.curProcState = procState;
    app.foregroundActivities = foregroundActivities;
    return app.curRawAdj;
}
#method_after
private final int computeOomAdjLocked(ProcessRecord app, int cachedAdj, ProcessRecord TOP_APP, boolean doingAll, long now) {
    if (mAdjSeq == app.adjSeq) {
        // This adjustment has already been computed.
        return app.curRawAdj;
    }
    if (app.thread == null) {
        app.adjSeq = mAdjSeq;
        app.curSchedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
        app.curProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        return (app.curAdj = app.curRawAdj = ProcessList.CACHED_APP_MAX_ADJ);
    }
    app.adjTypeCode = ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
    app.adjSource = null;
    app.adjTarget = null;
    app.empty = false;
    app.cached = false;
    final int activitiesSize = app.activities.size();
    if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
        // The max adjustment doesn't allow this app to be anything
        // below foreground, so it is not worth doing work for it.
        app.adjType = "fixed";
        app.adjSeq = mAdjSeq;
        app.curRawAdj = app.maxAdj;
        app.foregroundActivities = false;
        app.curSchedGroup = ProcessList.SCHED_GROUP_DEFAULT;
        app.curProcState = ActivityManager.PROCESS_STATE_PERSISTENT;
        // System processes can do UI, and when they do we want to have
        // them trim their memory after the user leaves the UI.  To
        // facilitate this, here we need to determine whether or not it
        // is currently showing UI.
        app.systemNoUi = true;
        if (app == TOP_APP) {
            app.systemNoUi = false;
            app.curSchedGroup = ProcessList.SCHED_GROUP_TOP_APP;
            app.adjType = "pers-top-activity";
        } else if (activitiesSize > 0) {
            for (int j = 0; j < activitiesSize; j++) {
                final ActivityRecord r = app.activities.get(j);
                if (r.visible) {
                    app.systemNoUi = false;
                }
            }
        }
        if (!app.systemNoUi) {
            app.curProcState = ActivityManager.PROCESS_STATE_PERSISTENT_UI;
        }
        return (app.curAdj = app.maxAdj);
    }
    app.systemNoUi = false;
    final int PROCESS_STATE_CUR_TOP = mTopProcessState;
    // Determine the importance of the process, starting with most
    // important to least, and assign an appropriate OOM adjustment.
    int adj;
    int schedGroup;
    int procState;
    boolean foregroundActivities = false;
    final ArraySet<BroadcastQueue> queues = new ArraySet<BroadcastQueue>();
    if (app == TOP_APP) {
        // The last app on the list is the foreground app.
        adj = ProcessList.FOREGROUND_APP_ADJ;
        schedGroup = ProcessList.SCHED_GROUP_TOP_APP;
        app.adjType = "top-activity";
        foregroundActivities = true;
        procState = PROCESS_STATE_CUR_TOP;
    } else if (app.instrumentationClass != null) {
        // Don't want to kill running instrumentation.
        adj = ProcessList.FOREGROUND_APP_ADJ;
        schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
        app.adjType = "instrumentation";
        procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
    } else if (isReceivingBroadcastLocked(app, queues)) {
        // An app that is currently receiving a broadcast also
        // counts as being in the foreground for OOM killer purposes.
        // It's placed in a sched group based on the nature of the
        // broadcast as reflected by which queue it's active in.
        adj = ProcessList.FOREGROUND_APP_ADJ;
        schedGroup = (queues.contains(mFgBroadcastQueue)) ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;
        app.adjType = "broadcast";
        procState = ActivityManager.PROCESS_STATE_RECEIVER;
    } else if (app.executingServices.size() > 0) {
        // An app that is currently executing a service callback also
        // counts as being in the foreground.
        adj = ProcessList.FOREGROUND_APP_ADJ;
        schedGroup = app.execServicesFg ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;
        app.adjType = "exec-service";
        procState = ActivityManager.PROCESS_STATE_SERVICE;
    // Slog.i(TAG, "EXEC " + (app.execServicesFg ? "FG" : "BG") + ": " + app);
    } else {
        // As far as we know the process is empty.  We may change our mind later.
        schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
        // At this point we don't actually know the adjustment.  Use the cached adj
        // value that the caller wants us to.
        adj = cachedAdj;
        procState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        app.cached = true;
        app.empty = true;
        app.adjType = "cch-empty";
    }
    // Examine all activities if not already foreground.
    if (!foregroundActivities && activitiesSize > 0) {
        int minLayer = ProcessList.VISIBLE_APP_LAYER_MAX;
        for (int j = 0; j < activitiesSize; j++) {
            final ActivityRecord r = app.activities.get(j);
            if (r.app != app) {
                Log.e(TAG, "Found activity " + r + " in proc activity list using " + r.app + " instead of expected " + app);
                if (r.app == null || (r.app.uid == app.uid)) {
                    // Only fix things up when they look sane
                    r.app = app;
                } else {
                    continue;
                }
            }
            if (r.visible) {
                // App has a visible activity; only upgrade adjustment.
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                    adj = ProcessList.VISIBLE_APP_ADJ;
                    app.adjType = "visible";
                }
                if (procState > PROCESS_STATE_CUR_TOP) {
                    procState = PROCESS_STATE_CUR_TOP;
                }
                schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
                app.cached = false;
                app.empty = false;
                foregroundActivities = true;
                if (r.task != null && minLayer > 0) {
                    final int layer = r.task.mLayerRank;
                    if (layer >= 0 && minLayer > layer) {
                        minLayer = layer;
                    }
                }
                break;
            } else if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
                if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                    adj = ProcessList.PERCEPTIBLE_APP_ADJ;
                    app.adjType = "pausing";
                }
                if (procState > PROCESS_STATE_CUR_TOP) {
                    procState = PROCESS_STATE_CUR_TOP;
                }
                schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
                app.cached = false;
                app.empty = false;
                foregroundActivities = true;
            } else if (r.state == ActivityState.STOPPING) {
                if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                    adj = ProcessList.PERCEPTIBLE_APP_ADJ;
                    app.adjType = "stopping";
                }
                // processes and they should soon all go into the cached state.
                if (!r.finishing) {
                    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
                        procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
                    }
                }
                app.cached = false;
                app.empty = false;
                foregroundActivities = true;
            } else {
                if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
                    procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
                    app.adjType = "cch-act";
                }
            }
        }
        if (adj == ProcessList.VISIBLE_APP_ADJ) {
            adj += minLayer;
        }
    }
    if (adj > ProcessList.PERCEPTIBLE_APP_ADJ || procState > ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE) {
        if (app.foregroundServices) {
            // The user is aware of this app, so make it visible.
            adj = ProcessList.PERCEPTIBLE_APP_ADJ;
            procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
            app.cached = false;
            app.adjType = "fg-service";
            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
        } else if (app.forcingToForeground != null) {
            // The user is aware of this app, so make it visible.
            adj = ProcessList.PERCEPTIBLE_APP_ADJ;
            procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
            app.cached = false;
            app.adjType = "force-fg";
            app.adjSource = app.forcingToForeground;
            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
        }
    }
    if (app == mHeavyWeightProcess) {
        if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
            // We don't want to kill the current heavy-weight process.
            adj = ProcessList.HEAVY_WEIGHT_APP_ADJ;
            schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
            app.cached = false;
            app.adjType = "heavy";
        }
        if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
            procState = ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
        }
    }
    if (app == mHomeProcess) {
        if (adj > ProcessList.HOME_APP_ADJ) {
            // This process is hosting what we currently consider to be the
            // home app, so we don't want to let it go into the background.
            adj = ProcessList.HOME_APP_ADJ;
            schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
            app.cached = false;
            app.adjType = "home";
        }
        if (procState > ActivityManager.PROCESS_STATE_HOME) {
            procState = ActivityManager.PROCESS_STATE_HOME;
        }
    }
    if (app == mPreviousProcess && app.activities.size() > 0) {
        if (adj > ProcessList.PREVIOUS_APP_ADJ) {
            // This was the previous process that showed UI to the user.
            // We want to try to keep it around more aggressively, to give
            // a good experience around switching between two apps.
            adj = ProcessList.PREVIOUS_APP_ADJ;
            schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
            app.cached = false;
            app.adjType = "previous";
        }
        if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
            procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
        }
    }
    if (false)
        Slog.i(TAG, "OOM " + app + ": initial adj=" + adj + " reason=" + app.adjType);
    // By default, we use the computed adjustment.  It may be changed if
    // there are applications dependent on our services or providers, but
    // this gives us a baseline and makes sure we don't get into an
    // infinite recursion.
    app.adjSeq = mAdjSeq;
    app.curRawAdj = adj;
    app.hasStartedServices = false;
    if (mBackupTarget != null && app == mBackupTarget.app) {
        // If possible we want to avoid killing apps while they're being backed up
        if (adj > ProcessList.BACKUP_APP_ADJ) {
            if (DEBUG_BACKUP)
                Slog.v(TAG_BACKUP, "oom BACKUP_APP_ADJ for " + app);
            adj = ProcessList.BACKUP_APP_ADJ;
            if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
                procState = ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
            app.adjType = "backup";
            app.cached = false;
        }
        if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
            procState = ActivityManager.PROCESS_STATE_BACKUP;
        }
    }
    boolean mayBeTop = false;
    for (int is = app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); is--) {
        ServiceRecord s = app.services.valueAt(is);
        if (s.startRequested) {
            app.hasStartedServices = true;
            if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
                procState = ActivityManager.PROCESS_STATE_SERVICE;
            }
            if (app.hasShownUi && app != mHomeProcess) {
                // debug and understand what is going on.
                if (adj > ProcessList.SERVICE_ADJ) {
                    app.adjType = "cch-started-ui-services";
                }
            } else {
                if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                    // of the background processes.
                    if (adj > ProcessList.SERVICE_ADJ) {
                        adj = ProcessList.SERVICE_ADJ;
                        app.adjType = "started-services";
                        app.cached = false;
                    }
                }
                // even though the service no longer has an impact.
                if (adj > ProcessList.SERVICE_ADJ) {
                    app.adjType = "cch-started-services";
                }
            }
        }
        for (int conni = s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); conni--) {
            ArrayList<ConnectionRecord> clist = s.connections.valueAt(conni);
            for (int i = 0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); i++) {
                // XXX should compute this based on the max of
                // all connected clients.
                ConnectionRecord cr = clist.get(i);
                if (cr.binding.client == app) {
                    // Binding to ourself is not interesting.
                    continue;
                }
                if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
                    ProcessRecord client = cr.binding.client;
                    int clientAdj = computeOomAdjLocked(client, cachedAdj, TOP_APP, doingAll, now);
                    int clientProcState = client.curProcState;
                    if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
                        // If the other app is cached for any reason, for purposes here
                        // we are going to consider it empty.  The specific cached state
                        // doesn't propagate except under certain conditions.
                        clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
                    }
                    String adjType = null;
                    if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
                        // this guy more like a started service.
                        if (app.hasShownUi && app != mHomeProcess) {
                            // debug and understand what is going on.
                            if (adj > clientAdj) {
                                adjType = "cch-bound-ui-services";
                            }
                            app.cached = false;
                            clientAdj = adj;
                            clientProcState = procState;
                        } else {
                            if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                                // to help debug and undertand what is going on.
                                if (adj > clientAdj) {
                                    adjType = "cch-bound-services";
                                }
                                clientAdj = adj;
                            }
                        }
                    }
                    if (adj > clientAdj) {
                        // memory.
                        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                            adjType = "cch-bound-ui-services";
                        } else {
                            if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                                adj = clientAdj >= ProcessList.PERSISTENT_SERVICE_ADJ ? clientAdj : ProcessList.PERSISTENT_SERVICE_ADJ;
                            } else if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                                adj = ProcessList.PERCEPTIBLE_APP_ADJ;
                            } else if (clientAdj >= ProcessList.PERCEPTIBLE_APP_ADJ) {
                                adj = clientAdj;
                            } else {
                                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                                    adj = Math.max(clientAdj, ProcessList.VISIBLE_APP_ADJ);
                                }
                            }
                            if (!client.cached) {
                                app.cached = false;
                            }
                            adjType = "service";
                        }
                    }
                    if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
                        // foreground work.
                        if (client.curSchedGroup > schedGroup) {
                            if ((cr.flags & Context.BIND_IMPORTANT) != 0) {
                                schedGroup = client.curSchedGroup;
                            } else {
                                schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
                            }
                        }
                        if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
                            if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                                // Special handling of clients who are in the top state.
                                // We *may* want to consider this process to be in the
                                // top state as well, but only if there is not another
                                // reason for it to be running.  Being on the top is a
                                // special state, meaning you are specifically running
                                // for the current top app.  If the process is already
                                // running in the background for some other reason, it
                                // is more important to continue considering it to be
                                // in the background state.
                                mayBeTop = true;
                                clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
                            } else {
                                // give them the best state after that.
                                if ((cr.flags & Context.BIND_FOREGROUND_SERVICE) != 0) {
                                    clientProcState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                                } else if (mWakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE && (cr.flags & Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE) != 0) {
                                    clientProcState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                                } else {
                                    clientProcState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
                                }
                            }
                        }
                    } else {
                        if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
                            clientProcState = ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
                        }
                    }
                    if (procState > clientProcState) {
                        procState = clientProcState;
                    }
                    if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
                        app.pendingUiClean = true;
                    }
                    if (adjType != null) {
                        app.adjType = adjType;
                        app.adjTypeCode = ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
                        app.adjSource = cr.binding.client;
                        app.adjSourceProcState = clientProcState;
                        app.adjTarget = s.name;
                    }
                }
                if ((cr.flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
                    app.treatLikeActivity = true;
                }
                final ActivityRecord a = cr.activity;
                if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
                    if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
                        adj = ProcessList.FOREGROUND_APP_ADJ;
                        if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
                            if ((cr.flags & Context.BIND_IMPORTANT) != 0) {
                                schedGroup = ProcessList.SCHED_GROUP_TOP_APP;
                            } else {
                                schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
                            }
                        }
                        app.cached = false;
                        app.adjType = "service";
                        app.adjTypeCode = ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
                        app.adjSource = a;
                        app.adjSourceProcState = procState;
                        app.adjTarget = s.name;
                    }
                }
            }
        }
    }
    for (int provi = app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); provi--) {
        ContentProviderRecord cpr = app.pubProviders.valueAt(provi);
        for (int i = cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); i--) {
            ContentProviderConnection conn = cpr.connections.get(i);
            ProcessRecord client = conn.client;
            if (client == app) {
                // Being our own client is not interesting.
                continue;
            }
            int clientAdj = computeOomAdjLocked(client, cachedAdj, TOP_APP, doingAll, now);
            int clientProcState = client.curProcState;
            if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
                // If the other app is cached for any reason, for purposes here
                // we are going to consider it empty.
                clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
            }
            if (adj > clientAdj) {
                if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                    app.adjType = "cch-ui-provider";
                } else {
                    adj = clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
                    app.adjType = "provider";
                }
                app.cached &= client.cached;
                app.adjTypeCode = ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
                app.adjSource = client;
                app.adjSourceProcState = clientProcState;
                app.adjTarget = cpr.name;
            }
            if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
                if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                    // Special handling of clients who are in the top state.
                    // We *may* want to consider this process to be in the
                    // top state as well, but only if there is not another
                    // reason for it to be running.  Being on the top is a
                    // special state, meaning you are specifically running
                    // for the current top app.  If the process is already
                    // running in the background for some other reason, it
                    // is more important to continue considering it to be
                    // in the background state.
                    mayBeTop = true;
                    clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
                } else {
                    // Special handling for above-top states (persistent
                    // processes).  These should not bring the current process
                    // into the top state, since they are not on top.  Instead
                    // give them the best state after that.
                    clientProcState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                }
            }
            if (procState > clientProcState) {
                procState = clientProcState;
            }
            if (client.curSchedGroup > schedGroup) {
                schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
            }
        }
        // FOREGROUND_APP_ADJ.
        if (cpr.hasExternalProcessHandles()) {
            if (adj > ProcessList.FOREGROUND_APP_ADJ) {
                adj = ProcessList.FOREGROUND_APP_ADJ;
                schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
                app.cached = false;
                app.adjType = "provider";
                app.adjTarget = cpr.name;
            }
            if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
                procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
            }
        }
    }
    if (app.lastProviderTime > 0 && (app.lastProviderTime + CONTENT_PROVIDER_RETAIN_TIME) > now) {
        if (adj > ProcessList.PREVIOUS_APP_ADJ) {
            adj = ProcessList.PREVIOUS_APP_ADJ;
            schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
            app.cached = false;
            app.adjType = "provider";
        }
        if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
            procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
        }
    }
    if (mayBeTop && procState > ActivityManager.PROCESS_STATE_TOP) {
        // to the top state.
        switch(procState) {
            case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
            case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
            case ActivityManager.PROCESS_STATE_SERVICE:
                // These all are longer-term states, so pull them up to the top
                // of the background states, but not all the way to the top state.
                procState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                break;
            default:
                // Otherwise, top is a better choice, so take it.
                procState = ActivityManager.PROCESS_STATE_TOP;
                break;
        }
    }
    if (procState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
        if (app.hasClientActivities) {
            // This is a cached process, but with client activities.  Mark it so.
            procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
            app.adjType = "cch-client-act";
        } else if (app.treatLikeActivity) {
            // This is a cached process, but somebody wants us to treat it like it has
            // an activity, okay!
            procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
            app.adjType = "cch-as-act";
        }
    }
    if (adj == ProcessList.SERVICE_ADJ) {
        if (doingAll) {
            app.serviceb = mNewNumAServiceProcs > (mNumServiceProcs / 3);
            mNewNumServiceProcs++;
            // Slog.i(TAG, "ADJ " + app + " serviceb=" + app.serviceb);
            if (!app.serviceb) {
                // keep launcher over it.
                if (mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
                    app.serviceHighRam = true;
                    app.serviceb = true;
                // Slog.i(TAG, "ADJ " + app + " high ram!");
                } else {
                    mNewNumAServiceProcs++;
                // Slog.i(TAG, "ADJ " + app + " not high ram!");
                }
            } else {
                app.serviceHighRam = false;
            }
        }
        if (app.serviceb) {
            adj = ProcessList.SERVICE_B_ADJ;
        }
    }
    app.curRawAdj = adj;
    // " adj=" + adj + " curAdj=" + app.curAdj + " maxAdj=" + app.maxAdj);
    if (adj > app.maxAdj) {
        adj = app.maxAdj;
        if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
        }
    }
    // Do final modification to adj.  Everything we do between here and applying
    // the final setAdj must be done in this function, because we will also use
    // it when computing the final cached adj later.  Note that we don't need to
    // worry about this for max adj above, since max adj will always be used to
    // keep it out of the cached vaues.
    app.curAdj = app.modifyRawOomAdj(adj);
    app.curSchedGroup = schedGroup;
    app.curProcState = procState;
    app.foregroundActivities = foregroundActivities;
    return app.curRawAdj;
}
#end_block

#method_before
private final boolean applyOomAdjLocked(ProcessRecord app, boolean doingAll, long now, long nowElapsed) {
    boolean success = true;
    if (app.curRawAdj != app.setRawAdj) {
        app.setRawAdj = app.curRawAdj;
    }
    int changes = 0;
    if (app.curAdj != app.setAdj) {
        ProcessList.setOomAdj(app.pid, app.info.uid, app.curAdj);
        if (DEBUG_SWITCH || DEBUG_OOM_ADJ)
            Slog.v(TAG_OOM_ADJ, "Set " + app.pid + " " + app.processName + " adj " + app.curAdj + ": " + app.adjType);
        app.setAdj = app.curAdj;
        app.verifiedAdj = ProcessList.INVALID_ADJ;
    }
    if (app.setSchedGroup != app.curSchedGroup) {
        app.setSchedGroup = app.curSchedGroup;
        if (DEBUG_SWITCH || DEBUG_OOM_ADJ)
            Slog.v(TAG_OOM_ADJ, "Setting sched group of " + app.processName + " to " + app.curSchedGroup);
        if (app.waitingToKill != null && app.curReceivers.size() == 0 && app.setSchedGroup == ProcessList.SCHED_GROUP_BACKGROUND) {
            app.kill(app.waitingToKill, true);
            success = false;
        } else {
            int processGroup;
            switch(app.curSchedGroup) {
                case ProcessList.SCHED_GROUP_BACKGROUND:
                    processGroup = Process.THREAD_GROUP_BG_NONINTERACTIVE;
                    break;
                case ProcessList.SCHED_GROUP_TOP_APP:
                    processGroup = Process.THREAD_GROUP_TOP_APP;
                    break;
                default:
                    processGroup = Process.THREAD_GROUP_DEFAULT;
                    break;
            }
            if (true) {
                long oldId = Binder.clearCallingIdentity();
                try {
                    Process.setProcessGroup(app.pid, processGroup);
                } catch (Exception e) {
                    Slog.w(TAG, "Failed setting process group of " + app.pid + " to " + app.curSchedGroup);
                    e.printStackTrace();
                } finally {
                    Binder.restoreCallingIdentity(oldId);
                }
            } else {
                if (app.thread != null) {
                    try {
                        app.thread.setSchedulingGroup(processGroup);
                    } catch (RemoteException e) {
                    }
                }
            }
        }
    }
    if (app.repForegroundActivities != app.foregroundActivities) {
        app.repForegroundActivities = app.foregroundActivities;
        changes |= ProcessChangeItem.CHANGE_ACTIVITIES;
    }
    if (app.repProcState != app.curProcState) {
        app.repProcState = app.curProcState;
        changes |= ProcessChangeItem.CHANGE_PROCESS_STATE;
        if (app.thread != null) {
            try {
                if (false) {
                    // RuntimeException h = new RuntimeException("here");
                    Slog.i(TAG, "Sending new process state " + app.repProcState + " to " + app);
                }
                app.thread.setProcessState(app.repProcState);
            } catch (RemoteException e) {
            }
        }
    }
    if (app.setProcState == ActivityManager.PROCESS_STATE_NONEXISTENT || ProcessList.procStatesDifferForMem(app.curProcState, app.setProcState)) {
        if (false && mTestPssMode && app.setProcState >= 0 && app.lastStateTime <= (now - 200)) {
            // Experimental code to more aggressively collect pss while
            // running test...  the problem is that this tends to collect
            // the data right when a process is transitioning between process
            // states, which well tend to give noisy data.
            long start = SystemClock.uptimeMillis();
            long pss = Debug.getPss(app.pid, mTmpLong, null);
            recordPssSampleLocked(app, app.curProcState, pss, mTmpLong[0], mTmpLong[1], now);
            mPendingPssProcesses.remove(app);
            Slog.i(TAG, "Recorded pss for " + app + " state " + app.setProcState + " to " + app.curProcState + ": " + (SystemClock.uptimeMillis() - start) + "ms");
        }
        app.lastStateTime = now;
        app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, true, mTestPssMode, isSleepingLocked(), now);
        if (DEBUG_PSS)
            Slog.d(TAG_PSS, "Process state change from " + ProcessList.makeProcStateString(app.setProcState) + " to " + ProcessList.makeProcStateString(app.curProcState) + " next pss in " + (app.nextPssTime - now) + ": " + app);
    } else {
        if (now > app.nextPssTime || (now > (app.lastPssTime + ProcessList.PSS_MAX_INTERVAL) && now > (app.lastStateTime + ProcessList.minTimeFromStateChange(mTestPssMode)))) {
            requestPssLocked(app, app.setProcState);
            app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, false, mTestPssMode, isSleepingLocked(), now);
        } else if (false && DEBUG_PSS)
            Slog.d(TAG_PSS, "Not requesting PSS of " + app + ": next=" + (app.nextPssTime - now));
    }
    if (app.setProcState != app.curProcState) {
        if (DEBUG_SWITCH || DEBUG_OOM_ADJ)
            Slog.v(TAG_OOM_ADJ, "Proc state change of " + app.processName + " to " + app.curProcState);
        boolean setImportant = app.setProcState < ActivityManager.PROCESS_STATE_SERVICE;
        boolean curImportant = app.curProcState < ActivityManager.PROCESS_STATE_SERVICE;
        if (setImportant && !curImportant) {
            // This app is no longer something we consider important enough to allow to
            // use arbitrary amounts of battery power.  Note
            // its current wake lock time to later know to kill it if
            // it is not behaving well.
            BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
            synchronized (stats) {
                app.lastWakeTime = stats.getProcessWakeTime(app.info.uid, app.pid, nowElapsed);
            }
            app.lastCpuTime = app.curCpuTime;
        }
        // Inform UsageStats of important process state change
        // Must be called before updating setProcState
        maybeUpdateUsageStatsLocked(app, nowElapsed);
        app.setProcState = app.curProcState;
        if (app.setProcState >= ActivityManager.PROCESS_STATE_HOME) {
            app.notCachedSinceIdle = false;
        }
        if (!doingAll) {
            setProcessTrackerStateLocked(app, mProcessStats.getMemFactorLocked(), now);
        } else {
            app.procStateChanged = true;
        }
    } else if (app.reportedInteraction && (nowElapsed - app.interactionEventTime) > USAGE_STATS_INTERACTION_INTERVAL) {
        // For apps that sit around for a long time in the interactive state, we need
        // to report this at least once a day so they don't go idle.
        maybeUpdateUsageStatsLocked(app, nowElapsed);
    }
    if (changes != 0) {
        if (DEBUG_PROCESS_OBSERVERS)
            Slog.i(TAG_PROCESS_OBSERVERS, "Changes in " + app + ": " + changes);
        int i = mPendingProcessChanges.size() - 1;
        ProcessChangeItem item = null;
        while (i >= 0) {
            item = mPendingProcessChanges.get(i);
            if (item.pid == app.pid) {
                if (DEBUG_PROCESS_OBSERVERS)
                    Slog.i(TAG_PROCESS_OBSERVERS, "Re-using existing item: " + item);
                break;
            }
            i--;
        }
        if (i < 0) {
            // No existing item in pending changes; need a new one.
            final int NA = mAvailProcessChanges.size();
            if (NA > 0) {
                item = mAvailProcessChanges.remove(NA - 1);
                if (DEBUG_PROCESS_OBSERVERS)
                    Slog.i(TAG_PROCESS_OBSERVERS, "Retrieving available item: " + item);
            } else {
                item = new ProcessChangeItem();
                if (DEBUG_PROCESS_OBSERVERS)
                    Slog.i(TAG_PROCESS_OBSERVERS, "Allocating new item: " + item);
            }
            item.changes = 0;
            item.pid = app.pid;
            item.uid = app.info.uid;
            if (mPendingProcessChanges.size() == 0) {
                if (DEBUG_PROCESS_OBSERVERS)
                    Slog.i(TAG_PROCESS_OBSERVERS, "*** Enqueueing dispatch processes changed!");
                mUiHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED_UI_MSG).sendToTarget();
            }
            mPendingProcessChanges.add(item);
        }
        item.changes |= changes;
        item.processState = app.repProcState;
        item.foregroundActivities = app.repForegroundActivities;
        if (DEBUG_PROCESS_OBSERVERS)
            Slog.i(TAG_PROCESS_OBSERVERS, "Item " + Integer.toHexString(System.identityHashCode(item)) + " " + app.toShortString() + ": changes=" + item.changes + " procState=" + item.processState + " foreground=" + item.foregroundActivities + " type=" + app.adjType + " source=" + app.adjSource + " target=" + app.adjTarget);
    }
    return success;
}
#method_after
private final boolean applyOomAdjLocked(ProcessRecord app, boolean doingAll, long now, long nowElapsed) {
    boolean success = true;
    if (app.curRawAdj != app.setRawAdj) {
        app.setRawAdj = app.curRawAdj;
    }
    int changes = 0;
    if (app.curAdj != app.setAdj) {
        ProcessList.setOomAdj(app.pid, app.info.uid, app.curAdj);
        if (DEBUG_SWITCH || DEBUG_OOM_ADJ)
            Slog.v(TAG_OOM_ADJ, "Set " + app.pid + " " + app.processName + " adj " + app.curAdj + ": " + app.adjType);
        app.setAdj = app.curAdj;
        app.verifiedAdj = ProcessList.INVALID_ADJ;
    }
    if (app.setSchedGroup != app.curSchedGroup) {
        app.setSchedGroup = app.curSchedGroup;
        if (DEBUG_SWITCH || DEBUG_OOM_ADJ)
            Slog.v(TAG_OOM_ADJ, "Setting sched group of " + app.processName + " to " + app.curSchedGroup);
        if (app.waitingToKill != null && app.curReceivers.isEmpty() && app.setSchedGroup == ProcessList.SCHED_GROUP_BACKGROUND) {
            app.kill(app.waitingToKill, true);
            success = false;
        } else {
            int processGroup;
            switch(app.curSchedGroup) {
                case ProcessList.SCHED_GROUP_BACKGROUND:
                    processGroup = Process.THREAD_GROUP_BG_NONINTERACTIVE;
                    break;
                case ProcessList.SCHED_GROUP_TOP_APP:
                    processGroup = Process.THREAD_GROUP_TOP_APP;
                    break;
                default:
                    processGroup = Process.THREAD_GROUP_DEFAULT;
                    break;
            }
            if (true) {
                long oldId = Binder.clearCallingIdentity();
                try {
                    Process.setProcessGroup(app.pid, processGroup);
                } catch (Exception e) {
                    Slog.w(TAG, "Failed setting process group of " + app.pid + " to " + app.curSchedGroup);
                    e.printStackTrace();
                } finally {
                    Binder.restoreCallingIdentity(oldId);
                }
            } else {
                if (app.thread != null) {
                    try {
                        app.thread.setSchedulingGroup(processGroup);
                    } catch (RemoteException e) {
                    }
                }
            }
        }
    }
    if (app.repForegroundActivities != app.foregroundActivities) {
        app.repForegroundActivities = app.foregroundActivities;
        changes |= ProcessChangeItem.CHANGE_ACTIVITIES;
    }
    if (app.repProcState != app.curProcState) {
        app.repProcState = app.curProcState;
        changes |= ProcessChangeItem.CHANGE_PROCESS_STATE;
        if (app.thread != null) {
            try {
                if (false) {
                    // RuntimeException h = new RuntimeException("here");
                    Slog.i(TAG, "Sending new process state " + app.repProcState + " to " + app);
                }
                app.thread.setProcessState(app.repProcState);
            } catch (RemoteException e) {
            }
        }
    }
    if (app.setProcState == ActivityManager.PROCESS_STATE_NONEXISTENT || ProcessList.procStatesDifferForMem(app.curProcState, app.setProcState)) {
        if (false && mTestPssMode && app.setProcState >= 0 && app.lastStateTime <= (now - 200)) {
            // Experimental code to more aggressively collect pss while
            // running test...  the problem is that this tends to collect
            // the data right when a process is transitioning between process
            // states, which well tend to give noisy data.
            long start = SystemClock.uptimeMillis();
            long pss = Debug.getPss(app.pid, mTmpLong, null);
            recordPssSampleLocked(app, app.curProcState, pss, mTmpLong[0], mTmpLong[1], now);
            mPendingPssProcesses.remove(app);
            Slog.i(TAG, "Recorded pss for " + app + " state " + app.setProcState + " to " + app.curProcState + ": " + (SystemClock.uptimeMillis() - start) + "ms");
        }
        app.lastStateTime = now;
        app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, true, mTestPssMode, isSleepingLocked(), now);
        if (DEBUG_PSS)
            Slog.d(TAG_PSS, "Process state change from " + ProcessList.makeProcStateString(app.setProcState) + " to " + ProcessList.makeProcStateString(app.curProcState) + " next pss in " + (app.nextPssTime - now) + ": " + app);
    } else {
        if (now > app.nextPssTime || (now > (app.lastPssTime + ProcessList.PSS_MAX_INTERVAL) && now > (app.lastStateTime + ProcessList.minTimeFromStateChange(mTestPssMode)))) {
            requestPssLocked(app, app.setProcState);
            app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, false, mTestPssMode, isSleepingLocked(), now);
        } else if (false && DEBUG_PSS)
            Slog.d(TAG_PSS, "Not requesting PSS of " + app + ": next=" + (app.nextPssTime - now));
    }
    if (app.setProcState != app.curProcState) {
        if (DEBUG_SWITCH || DEBUG_OOM_ADJ)
            Slog.v(TAG_OOM_ADJ, "Proc state change of " + app.processName + " to " + app.curProcState);
        boolean setImportant = app.setProcState < ActivityManager.PROCESS_STATE_SERVICE;
        boolean curImportant = app.curProcState < ActivityManager.PROCESS_STATE_SERVICE;
        if (setImportant && !curImportant) {
            // This app is no longer something we consider important enough to allow to
            // use arbitrary amounts of battery power.  Note
            // its current wake lock time to later know to kill it if
            // it is not behaving well.
            BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
            synchronized (stats) {
                app.lastWakeTime = stats.getProcessWakeTime(app.info.uid, app.pid, nowElapsed);
            }
            app.lastCpuTime = app.curCpuTime;
        }
        // Inform UsageStats of important process state change
        // Must be called before updating setProcState
        maybeUpdateUsageStatsLocked(app, nowElapsed);
        app.setProcState = app.curProcState;
        if (app.setProcState >= ActivityManager.PROCESS_STATE_HOME) {
            app.notCachedSinceIdle = false;
        }
        if (!doingAll) {
            setProcessTrackerStateLocked(app, mProcessStats.getMemFactorLocked(), now);
        } else {
            app.procStateChanged = true;
        }
    } else if (app.reportedInteraction && (nowElapsed - app.interactionEventTime) > USAGE_STATS_INTERACTION_INTERVAL) {
        // For apps that sit around for a long time in the interactive state, we need
        // to report this at least once a day so they don't go idle.
        maybeUpdateUsageStatsLocked(app, nowElapsed);
    }
    if (changes != 0) {
        if (DEBUG_PROCESS_OBSERVERS)
            Slog.i(TAG_PROCESS_OBSERVERS, "Changes in " + app + ": " + changes);
        int i = mPendingProcessChanges.size() - 1;
        ProcessChangeItem item = null;
        while (i >= 0) {
            item = mPendingProcessChanges.get(i);
            if (item.pid == app.pid) {
                if (DEBUG_PROCESS_OBSERVERS)
                    Slog.i(TAG_PROCESS_OBSERVERS, "Re-using existing item: " + item);
                break;
            }
            i--;
        }
        if (i < 0) {
            // No existing item in pending changes; need a new one.
            final int NA = mAvailProcessChanges.size();
            if (NA > 0) {
                item = mAvailProcessChanges.remove(NA - 1);
                if (DEBUG_PROCESS_OBSERVERS)
                    Slog.i(TAG_PROCESS_OBSERVERS, "Retrieving available item: " + item);
            } else {
                item = new ProcessChangeItem();
                if (DEBUG_PROCESS_OBSERVERS)
                    Slog.i(TAG_PROCESS_OBSERVERS, "Allocating new item: " + item);
            }
            item.changes = 0;
            item.pid = app.pid;
            item.uid = app.info.uid;
            if (mPendingProcessChanges.size() == 0) {
                if (DEBUG_PROCESS_OBSERVERS)
                    Slog.i(TAG_PROCESS_OBSERVERS, "*** Enqueueing dispatch processes changed!");
                mUiHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED_UI_MSG).sendToTarget();
            }
            mPendingProcessChanges.add(item);
        }
        item.changes |= changes;
        item.processState = app.repProcState;
        item.foregroundActivities = app.repForegroundActivities;
        if (DEBUG_PROCESS_OBSERVERS)
            Slog.i(TAG_PROCESS_OBSERVERS, "Item " + Integer.toHexString(System.identityHashCode(item)) + " " + app.toShortString() + ": changes=" + item.changes + " procState=" + item.processState + " foreground=" + item.foregroundActivities + " type=" + app.adjType + " source=" + app.adjSource + " target=" + app.adjTarget);
    }
    return success;
}
#end_block

#method_before
final void trimApplications() {
    synchronized (this) {
        int i;
        // has been removed.
        for (i = mRemovedProcesses.size() - 1; i >= 0; i--) {
            final ProcessRecord app = mRemovedProcesses.get(i);
            if (app.activities.size() == 0 && app.curReceivers.size() == 0 && app.services.size() == 0) {
                Slog.i(TAG, "Exiting empty application process " + app.toShortString() + " (" + (app.thread != null ? app.thread.asBinder() : null) + ")\n");
                if (app.pid > 0 && app.pid != MY_PID) {
                    app.kill("empty", false);
                } else {
                    try {
                        app.thread.scheduleExit();
                    } catch (Exception e) {
                    // Ignore exceptions.
                    }
                }
                cleanUpApplicationRecordLocked(app, false, true, -1);
                mRemovedProcesses.remove(i);
                if (app.persistent) {
                    addAppLocked(app.info, false, null);
                }
            }
        }
        // Now update the oom adj for all processes.
        updateOomAdjLocked();
    }
}
#method_after
final void trimApplications() {
    synchronized (this) {
        int i;
        // has been removed.
        for (i = mRemovedProcesses.size() - 1; i >= 0; i--) {
            final ProcessRecord app = mRemovedProcesses.get(i);
            if (app.activities.size() == 0 && app.curReceivers.isEmpty() && app.services.size() == 0) {
                Slog.i(TAG, "Exiting empty application process " + app.toShortString() + " (" + (app.thread != null ? app.thread.asBinder() : null) + ")\n");
                if (app.pid > 0 && app.pid != MY_PID) {
                    app.kill("empty", false);
                } else {
                    try {
                        app.thread.scheduleExit();
                    } catch (Exception e) {
                    // Ignore exceptions.
                    }
                }
                cleanUpApplicationRecordLocked(app, false, true, -1);
                mRemovedProcesses.remove(i);
                if (app.persistent) {
                    addAppLocked(app.info, false, null);
                }
            }
        }
        // Now update the oom adj for all processes.
        updateOomAdjLocked();
    }
}
#end_block

#method_before
void dump(PrintWriter pw, String prefix) {
    final long now = SystemClock.uptimeMillis();
    pw.print(prefix);
    pw.print("user #");
    pw.print(userId);
    pw.print(" uid=");
    pw.print(info.uid);
    if (uid != info.uid) {
        pw.print(" ISOLATED uid=");
        pw.print(uid);
    }
    pw.print(" gids={");
    if (gids != null) {
        for (int gi = 0; gi < gids.length; gi++) {
            if (gi != 0)
                pw.print(", ");
            pw.print(gids[gi]);
        }
    }
    pw.println("}");
    pw.print(prefix);
    pw.print("requiredAbi=");
    pw.print(requiredAbi);
    pw.print(" instructionSet=");
    pw.println(instructionSet);
    if (info.className != null) {
        pw.print(prefix);
        pw.print("class=");
        pw.println(info.className);
    }
    if (info.manageSpaceActivityName != null) {
        pw.print(prefix);
        pw.print("manageSpaceActivityName=");
        pw.println(info.manageSpaceActivityName);
    }
    pw.print(prefix);
    pw.print("dir=");
    pw.print(info.sourceDir);
    pw.print(" publicDir=");
    pw.print(info.publicSourceDir);
    pw.print(" data=");
    pw.println(info.dataDir);
    pw.print(prefix);
    pw.print("packageList={");
    for (int i = 0; i < pkgList.size(); i++) {
        if (i > 0)
            pw.print(", ");
        pw.print(pkgList.keyAt(i));
    }
    pw.println("}");
    if (pkgDeps != null) {
        pw.print(prefix);
        pw.print("packageDependencies={");
        for (int i = 0; i < pkgDeps.size(); i++) {
            if (i > 0)
                pw.print(", ");
            pw.print(pkgDeps.valueAt(i));
        }
        pw.println("}");
    }
    pw.print(prefix);
    pw.print("compat=");
    pw.println(compat);
    if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
        pw.print(prefix);
        pw.print("instrumentationClass=");
        pw.print(instrumentationClass);
        pw.print(" instrumentationProfileFile=");
        pw.println(instrumentationProfileFile);
        pw.print(prefix);
        pw.print("instrumentationArguments=");
        pw.println(instrumentationArguments);
        pw.print(prefix);
        pw.print("instrumentationInfo=");
        pw.println(instrumentationInfo);
        if (instrumentationInfo != null) {
            instrumentationInfo.dump(new PrintWriterPrinter(pw), prefix + "  ");
        }
    }
    pw.print(prefix);
    pw.print("thread=");
    pw.println(thread);
    pw.print(prefix);
    pw.print("pid=");
    pw.print(pid);
    pw.print(" starting=");
    pw.println(starting);
    pw.print(prefix);
    pw.print("lastActivityTime=");
    TimeUtils.formatDuration(lastActivityTime, now, pw);
    pw.print(" lastPssTime=");
    TimeUtils.formatDuration(lastPssTime, now, pw);
    pw.print(" nextPssTime=");
    TimeUtils.formatDuration(nextPssTime, now, pw);
    pw.println();
    pw.print(prefix);
    pw.print("adjSeq=");
    pw.print(adjSeq);
    pw.print(" lruSeq=");
    pw.print(lruSeq);
    pw.print(" lastPss=");
    DebugUtils.printSizeValue(pw, lastPss * 1024);
    pw.print(" lastSwapPss=");
    DebugUtils.printSizeValue(pw, lastSwapPss * 1024);
    pw.print(" lastCachedPss=");
    DebugUtils.printSizeValue(pw, lastCachedPss * 1024);
    pw.print(" lastCachedSwapPss=");
    DebugUtils.printSizeValue(pw, lastCachedSwapPss * 1024);
    pw.println();
    pw.print(prefix);
    pw.print("cached=");
    pw.print(cached);
    pw.print(" empty=");
    pw.println(empty);
    if (serviceb) {
        pw.print(prefix);
        pw.print("serviceb=");
        pw.print(serviceb);
        pw.print(" serviceHighRam=");
        pw.println(serviceHighRam);
    }
    if (notCachedSinceIdle) {
        pw.print(prefix);
        pw.print("notCachedSinceIdle=");
        pw.print(notCachedSinceIdle);
        pw.print(" initialIdlePss=");
        pw.println(initialIdlePss);
    }
    pw.print(prefix);
    pw.print("oom: max=");
    pw.print(maxAdj);
    pw.print(" curRaw=");
    pw.print(curRawAdj);
    pw.print(" setRaw=");
    pw.print(setRawAdj);
    pw.print(" cur=");
    pw.print(curAdj);
    pw.print(" set=");
    pw.println(setAdj);
    pw.print(prefix);
    pw.print("curSchedGroup=");
    pw.print(curSchedGroup);
    pw.print(" setSchedGroup=");
    pw.print(setSchedGroup);
    pw.print(" systemNoUi=");
    pw.print(systemNoUi);
    pw.print(" trimMemoryLevel=");
    pw.println(trimMemoryLevel);
    pw.print(prefix);
    pw.print("curProcState=");
    pw.print(curProcState);
    pw.print(" repProcState=");
    pw.print(repProcState);
    pw.print(" pssProcState=");
    pw.print(pssProcState);
    pw.print(" setProcState=");
    pw.print(setProcState);
    pw.print(" lastStateTime=");
    TimeUtils.formatDuration(lastStateTime, now, pw);
    pw.println();
    if (hasShownUi || pendingUiClean || hasAboveClient || treatLikeActivity) {
        pw.print(prefix);
        pw.print("hasShownUi=");
        pw.print(hasShownUi);
        pw.print(" pendingUiClean=");
        pw.print(pendingUiClean);
        pw.print(" hasAboveClient=");
        pw.print(hasAboveClient);
        pw.print(" treatLikeActivity=");
        pw.println(treatLikeActivity);
    }
    if (setIsForeground || foregroundServices || forcingToForeground != null) {
        pw.print(prefix);
        pw.print("setIsForeground=");
        pw.print(setIsForeground);
        pw.print(" foregroundServices=");
        pw.print(foregroundServices);
        pw.print(" forcingToForeground=");
        pw.println(forcingToForeground);
    }
    if (reportedInteraction || fgInteractionTime != 0) {
        pw.print(prefix);
        pw.print("reportedInteraction=");
        pw.print(reportedInteraction);
        if (interactionEventTime != 0) {
            pw.print(" time=");
            TimeUtils.formatDuration(interactionEventTime, SystemClock.elapsedRealtime(), pw);
        }
        if (fgInteractionTime != 0) {
            pw.print(" fgInteractionTime=");
            TimeUtils.formatDuration(fgInteractionTime, SystemClock.elapsedRealtime(), pw);
        }
        pw.println();
    }
    if (persistent || removed) {
        pw.print(prefix);
        pw.print("persistent=");
        pw.print(persistent);
        pw.print(" removed=");
        pw.println(removed);
    }
    if (hasClientActivities || foregroundActivities || repForegroundActivities) {
        pw.print(prefix);
        pw.print("hasClientActivities=");
        pw.print(hasClientActivities);
        pw.print(" foregroundActivities=");
        pw.print(foregroundActivities);
        pw.print(" (rep=");
        pw.print(repForegroundActivities);
        pw.println(")");
    }
    if (lastProviderTime > 0) {
        pw.print(prefix);
        pw.print("lastProviderTime=");
        TimeUtils.formatDuration(lastProviderTime, now, pw);
        pw.println();
    }
    if (hasStartedServices) {
        pw.print(prefix);
        pw.print("hasStartedServices=");
        pw.println(hasStartedServices);
    }
    if (setProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
        long wtime;
        synchronized (mBatteryStats) {
            wtime = mBatteryStats.getProcessWakeTime(info.uid, pid, SystemClock.elapsedRealtime());
        }
        pw.print(prefix);
        pw.print("lastWakeTime=");
        pw.print(lastWakeTime);
        pw.print(" timeUsed=");
        TimeUtils.formatDuration(wtime - lastWakeTime, pw);
        pw.println("");
        pw.print(prefix);
        pw.print("lastCpuTime=");
        pw.print(lastCpuTime);
        pw.print(" timeUsed=");
        TimeUtils.formatDuration(curCpuTime - lastCpuTime, pw);
        pw.println("");
    }
    pw.print(prefix);
    pw.print("lastRequestedGc=");
    TimeUtils.formatDuration(lastRequestedGc, now, pw);
    pw.print(" lastLowMemory=");
    TimeUtils.formatDuration(lastLowMemory, now, pw);
    pw.print(" reportLowMemory=");
    pw.println(reportLowMemory);
    if (killed || killedByAm || waitingToKill != null) {
        pw.print(prefix);
        pw.print("killed=");
        pw.print(killed);
        pw.print(" killedByAm=");
        pw.print(killedByAm);
        pw.print(" waitingToKill=");
        pw.println(waitingToKill);
    }
    if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
        pw.print(prefix);
        pw.print("debugging=");
        pw.print(debugging);
        pw.print(" crashing=");
        pw.print(crashing);
        pw.print(" ");
        pw.print(crashDialog);
        pw.print(" notResponding=");
        pw.print(notResponding);
        pw.print(" ");
        pw.print(anrDialog);
        pw.print(" bad=");
        pw.print(bad);
        // crashing or notResponding is always set before errorReportReceiver
        if (errorReportReceiver != null) {
            pw.print(" errorReportReceiver=");
            pw.print(errorReportReceiver.flattenToShortString());
        }
        pw.println();
    }
    if (whitelistManager) {
        pw.print(prefix);
        pw.print("whitelistManager=");
        pw.println(whitelistManager);
    }
    if (activities.size() > 0) {
        pw.print(prefix);
        pw.println("Activities:");
        for (int i = 0; i < activities.size(); i++) {
            pw.print(prefix);
            pw.print("  - ");
            pw.println(activities.get(i));
        }
    }
    if (services.size() > 0) {
        pw.print(prefix);
        pw.println("Services:");
        for (int i = 0; i < services.size(); i++) {
            pw.print(prefix);
            pw.print("  - ");
            pw.println(services.valueAt(i));
        }
    }
    if (executingServices.size() > 0) {
        pw.print(prefix);
        pw.print("Executing Services (fg=");
        pw.print(execServicesFg);
        pw.println(")");
        for (int i = 0; i < executingServices.size(); i++) {
            pw.print(prefix);
            pw.print("  - ");
            pw.println(executingServices.valueAt(i));
        }
    }
    if (connections.size() > 0) {
        pw.print(prefix);
        pw.println("Connections:");
        for (int i = 0; i < connections.size(); i++) {
            pw.print(prefix);
            pw.print("  - ");
            pw.println(connections.valueAt(i));
        }
    }
    if (pubProviders.size() > 0) {
        pw.print(prefix);
        pw.println("Published Providers:");
        for (int i = 0; i < pubProviders.size(); i++) {
            pw.print(prefix);
            pw.print("  - ");
            pw.println(pubProviders.keyAt(i));
            pw.print(prefix);
            pw.print("    -> ");
            pw.println(pubProviders.valueAt(i));
        }
    }
    if (conProviders.size() > 0) {
        pw.print(prefix);
        pw.println("Connected Providers:");
        for (int i = 0; i < conProviders.size(); i++) {
            pw.print(prefix);
            pw.print("  - ");
            pw.println(conProviders.get(i).toShortString());
        }
    }
    if (curReceivers.size() > 0) {
        pw.print(prefix);
        pw.println("Current Receivers:");
        for (int i = 0; i < curReceivers.size(); i++) {
            pw.print(prefix);
            pw.print(" -");
            pw.println(curReceivers.valueAt(i));
        }
    }
    if (receivers.size() > 0) {
        pw.print(prefix);
        pw.println("Receivers:");
        for (int i = 0; i < receivers.size(); i++) {
            pw.print(prefix);
            pw.print("  - ");
            pw.println(receivers.valueAt(i));
        }
    }
}
#method_after
void dump(PrintWriter pw, String prefix) {
    final long now = SystemClock.uptimeMillis();
    pw.print(prefix);
    pw.print("user #");
    pw.print(userId);
    pw.print(" uid=");
    pw.print(info.uid);
    if (uid != info.uid) {
        pw.print(" ISOLATED uid=");
        pw.print(uid);
    }
    pw.print(" gids={");
    if (gids != null) {
        for (int gi = 0; gi < gids.length; gi++) {
            if (gi != 0)
                pw.print(", ");
            pw.print(gids[gi]);
        }
    }
    pw.println("}");
    pw.print(prefix);
    pw.print("requiredAbi=");
    pw.print(requiredAbi);
    pw.print(" instructionSet=");
    pw.println(instructionSet);
    if (info.className != null) {
        pw.print(prefix);
        pw.print("class=");
        pw.println(info.className);
    }
    if (info.manageSpaceActivityName != null) {
        pw.print(prefix);
        pw.print("manageSpaceActivityName=");
        pw.println(info.manageSpaceActivityName);
    }
    pw.print(prefix);
    pw.print("dir=");
    pw.print(info.sourceDir);
    pw.print(" publicDir=");
    pw.print(info.publicSourceDir);
    pw.print(" data=");
    pw.println(info.dataDir);
    pw.print(prefix);
    pw.print("packageList={");
    for (int i = 0; i < pkgList.size(); i++) {
        if (i > 0)
            pw.print(", ");
        pw.print(pkgList.keyAt(i));
    }
    pw.println("}");
    if (pkgDeps != null) {
        pw.print(prefix);
        pw.print("packageDependencies={");
        for (int i = 0; i < pkgDeps.size(); i++) {
            if (i > 0)
                pw.print(", ");
            pw.print(pkgDeps.valueAt(i));
        }
        pw.println("}");
    }
    pw.print(prefix);
    pw.print("compat=");
    pw.println(compat);
    if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
        pw.print(prefix);
        pw.print("instrumentationClass=");
        pw.print(instrumentationClass);
        pw.print(" instrumentationProfileFile=");
        pw.println(instrumentationProfileFile);
        pw.print(prefix);
        pw.print("instrumentationArguments=");
        pw.println(instrumentationArguments);
        pw.print(prefix);
        pw.print("instrumentationInfo=");
        pw.println(instrumentationInfo);
        if (instrumentationInfo != null) {
            instrumentationInfo.dump(new PrintWriterPrinter(pw), prefix + "  ");
        }
    }
    pw.print(prefix);
    pw.print("thread=");
    pw.println(thread);
    pw.print(prefix);
    pw.print("pid=");
    pw.print(pid);
    pw.print(" starting=");
    pw.println(starting);
    pw.print(prefix);
    pw.print("lastActivityTime=");
    TimeUtils.formatDuration(lastActivityTime, now, pw);
    pw.print(" lastPssTime=");
    TimeUtils.formatDuration(lastPssTime, now, pw);
    pw.print(" nextPssTime=");
    TimeUtils.formatDuration(nextPssTime, now, pw);
    pw.println();
    pw.print(prefix);
    pw.print("adjSeq=");
    pw.print(adjSeq);
    pw.print(" lruSeq=");
    pw.print(lruSeq);
    pw.print(" lastPss=");
    DebugUtils.printSizeValue(pw, lastPss * 1024);
    pw.print(" lastSwapPss=");
    DebugUtils.printSizeValue(pw, lastSwapPss * 1024);
    pw.print(" lastCachedPss=");
    DebugUtils.printSizeValue(pw, lastCachedPss * 1024);
    pw.print(" lastCachedSwapPss=");
    DebugUtils.printSizeValue(pw, lastCachedSwapPss * 1024);
    pw.println();
    pw.print(prefix);
    pw.print("cached=");
    pw.print(cached);
    pw.print(" empty=");
    pw.println(empty);
    if (serviceb) {
        pw.print(prefix);
        pw.print("serviceb=");
        pw.print(serviceb);
        pw.print(" serviceHighRam=");
        pw.println(serviceHighRam);
    }
    if (notCachedSinceIdle) {
        pw.print(prefix);
        pw.print("notCachedSinceIdle=");
        pw.print(notCachedSinceIdle);
        pw.print(" initialIdlePss=");
        pw.println(initialIdlePss);
    }
    pw.print(prefix);
    pw.print("oom: max=");
    pw.print(maxAdj);
    pw.print(" curRaw=");
    pw.print(curRawAdj);
    pw.print(" setRaw=");
    pw.print(setRawAdj);
    pw.print(" cur=");
    pw.print(curAdj);
    pw.print(" set=");
    pw.println(setAdj);
    pw.print(prefix);
    pw.print("curSchedGroup=");
    pw.print(curSchedGroup);
    pw.print(" setSchedGroup=");
    pw.print(setSchedGroup);
    pw.print(" systemNoUi=");
    pw.print(systemNoUi);
    pw.print(" trimMemoryLevel=");
    pw.println(trimMemoryLevel);
    pw.print(prefix);
    pw.print("curProcState=");
    pw.print(curProcState);
    pw.print(" repProcState=");
    pw.print(repProcState);
    pw.print(" pssProcState=");
    pw.print(pssProcState);
    pw.print(" setProcState=");
    pw.print(setProcState);
    pw.print(" lastStateTime=");
    TimeUtils.formatDuration(lastStateTime, now, pw);
    pw.println();
    if (hasShownUi || pendingUiClean || hasAboveClient || treatLikeActivity) {
        pw.print(prefix);
        pw.print("hasShownUi=");
        pw.print(hasShownUi);
        pw.print(" pendingUiClean=");
        pw.print(pendingUiClean);
        pw.print(" hasAboveClient=");
        pw.print(hasAboveClient);
        pw.print(" treatLikeActivity=");
        pw.println(treatLikeActivity);
    }
    if (setIsForeground || foregroundServices || forcingToForeground != null) {
        pw.print(prefix);
        pw.print("setIsForeground=");
        pw.print(setIsForeground);
        pw.print(" foregroundServices=");
        pw.print(foregroundServices);
        pw.print(" forcingToForeground=");
        pw.println(forcingToForeground);
    }
    if (reportedInteraction || fgInteractionTime != 0) {
        pw.print(prefix);
        pw.print("reportedInteraction=");
        pw.print(reportedInteraction);
        if (interactionEventTime != 0) {
            pw.print(" time=");
            TimeUtils.formatDuration(interactionEventTime, SystemClock.elapsedRealtime(), pw);
        }
        if (fgInteractionTime != 0) {
            pw.print(" fgInteractionTime=");
            TimeUtils.formatDuration(fgInteractionTime, SystemClock.elapsedRealtime(), pw);
        }
        pw.println();
    }
    if (persistent || removed) {
        pw.print(prefix);
        pw.print("persistent=");
        pw.print(persistent);
        pw.print(" removed=");
        pw.println(removed);
    }
    if (hasClientActivities || foregroundActivities || repForegroundActivities) {
        pw.print(prefix);
        pw.print("hasClientActivities=");
        pw.print(hasClientActivities);
        pw.print(" foregroundActivities=");
        pw.print(foregroundActivities);
        pw.print(" (rep=");
        pw.print(repForegroundActivities);
        pw.println(")");
    }
    if (lastProviderTime > 0) {
        pw.print(prefix);
        pw.print("lastProviderTime=");
        TimeUtils.formatDuration(lastProviderTime, now, pw);
        pw.println();
    }
    if (hasStartedServices) {
        pw.print(prefix);
        pw.print("hasStartedServices=");
        pw.println(hasStartedServices);
    }
    if (setProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
        long wtime;
        synchronized (mBatteryStats) {
            wtime = mBatteryStats.getProcessWakeTime(info.uid, pid, SystemClock.elapsedRealtime());
        }
        pw.print(prefix);
        pw.print("lastWakeTime=");
        pw.print(lastWakeTime);
        pw.print(" timeUsed=");
        TimeUtils.formatDuration(wtime - lastWakeTime, pw);
        pw.println("");
        pw.print(prefix);
        pw.print("lastCpuTime=");
        pw.print(lastCpuTime);
        pw.print(" timeUsed=");
        TimeUtils.formatDuration(curCpuTime - lastCpuTime, pw);
        pw.println("");
    }
    pw.print(prefix);
    pw.print("lastRequestedGc=");
    TimeUtils.formatDuration(lastRequestedGc, now, pw);
    pw.print(" lastLowMemory=");
    TimeUtils.formatDuration(lastLowMemory, now, pw);
    pw.print(" reportLowMemory=");
    pw.println(reportLowMemory);
    if (killed || killedByAm || waitingToKill != null) {
        pw.print(prefix);
        pw.print("killed=");
        pw.print(killed);
        pw.print(" killedByAm=");
        pw.print(killedByAm);
        pw.print(" waitingToKill=");
        pw.println(waitingToKill);
    }
    if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
        pw.print(prefix);
        pw.print("debugging=");
        pw.print(debugging);
        pw.print(" crashing=");
        pw.print(crashing);
        pw.print(" ");
        pw.print(crashDialog);
        pw.print(" notResponding=");
        pw.print(notResponding);
        pw.print(" ");
        pw.print(anrDialog);
        pw.print(" bad=");
        pw.print(bad);
        // crashing or notResponding is always set before errorReportReceiver
        if (errorReportReceiver != null) {
            pw.print(" errorReportReceiver=");
            pw.print(errorReportReceiver.flattenToShortString());
        }
        pw.println();
    }
    if (whitelistManager) {
        pw.print(prefix);
        pw.print("whitelistManager=");
        pw.println(whitelistManager);
    }
    if (activities.size() > 0) {
        pw.print(prefix);
        pw.println("Activities:");
        for (int i = 0; i < activities.size(); i++) {
            pw.print(prefix);
            pw.print("  - ");
            pw.println(activities.get(i));
        }
    }
    if (services.size() > 0) {
        pw.print(prefix);
        pw.println("Services:");
        for (int i = 0; i < services.size(); i++) {
            pw.print(prefix);
            pw.print("  - ");
            pw.println(services.valueAt(i));
        }
    }
    if (executingServices.size() > 0) {
        pw.print(prefix);
        pw.print("Executing Services (fg=");
        pw.print(execServicesFg);
        pw.println(")");
        for (int i = 0; i < executingServices.size(); i++) {
            pw.print(prefix);
            pw.print("  - ");
            pw.println(executingServices.valueAt(i));
        }
    }
    if (connections.size() > 0) {
        pw.print(prefix);
        pw.println("Connections:");
        for (int i = 0; i < connections.size(); i++) {
            pw.print(prefix);
            pw.print("  - ");
            pw.println(connections.valueAt(i));
        }
    }
    if (pubProviders.size() > 0) {
        pw.print(prefix);
        pw.println("Published Providers:");
        for (int i = 0; i < pubProviders.size(); i++) {
            pw.print(prefix);
            pw.print("  - ");
            pw.println(pubProviders.keyAt(i));
            pw.print(prefix);
            pw.print("    -> ");
            pw.println(pubProviders.valueAt(i));
        }
    }
    if (conProviders.size() > 0) {
        pw.print(prefix);
        pw.println("Connected Providers:");
        for (int i = 0; i < conProviders.size(); i++) {
            pw.print(prefix);
            pw.print("  - ");
            pw.println(conProviders.get(i).toShortString());
        }
    }
    if (!curReceivers.isEmpty()) {
        pw.print(prefix);
        pw.println("Current Receivers:");
        for (int i = 0; i < curReceivers.size(); i++) {
            pw.print(prefix);
            pw.print("  - ");
            pw.println(curReceivers.valueAt(i));
        }
    }
    if (receivers.size() > 0) {
        pw.print(prefix);
        pw.println("Receivers:");
        for (int i = 0; i < receivers.size(); i++) {
            pw.print(prefix);
            pw.print("  - ");
            pw.println(receivers.valueAt(i));
        }
    }
}
#end_block

#method_before
@Test
@TestInfo(id = "14581152")
public void toggleCellularDataOff() throws Exception {
    final Instrumentation instrumentation = testFramework.getInstrumentation();
    UiDevice device = UiDevice.getInstance(instrumentation);
    // TODO: Add a fixture method in AppLauncher class to launch a specified path.
    int api = testFramework.getApi();
    if (api >= 23) {
        UiObject2 dataSwitch = navigateToDataSwitch(instrumentation);
        // Test requires "Cellular data" switch widget to start in the on state.
        if (!dataSwitch.isChecked()) {
            dataSwitch.click();
        }
        // Disable "Cellular data" option.
        dataSwitch.click();
        if (api < 24) {
            device.findObject(new UiSelector().text("OK")).click();
        }
        // Wait for data connection to turn off.
        new Wait().until(new Wait.ExpectedCondition() {

            @Override
            public boolean isTrue() throws Exception {
                return !NetworkUtil.hasCellularNetworkConnection(instrumentation);
            }
        });
        assertFalse("Cellular data is enabled.", NetworkUtil.hasCellularNetworkConnection(instrumentation));
        if (api < 24) {
            assertFalse("Set cellular data limit text is visible.", device.findObject(new UiSelector().textContains("Set cellular data limit")).exists());
        }
        if (api >= 24) {
            assertFalse("Set cellular data is not turned off.", device.findObject(new UiSelector().textContains("ON").resourceId("android:id/switch_widget").className("android.widget.Switch")).exists());
        }
        // Enable Cellular data.
        dataSwitch.click();
    }
}
#method_after
@Test
@TestInfo(id = "14581152")
public void toggleCellularDataOff() throws Exception {
    final Instrumentation instrumentation = testFramework.getInstrumentation();
    UiDevice device = UiDevice.getInstance(instrumentation);
    // TODO: Add a fixture method in AppLauncher class to launch a specified path.
    int api = testFramework.getApi();
    if (api >= 23) {
        UiObject2 dataSwitch = navigateToDataSwitch(instrumentation);
        // Test requires "Cellular data" switch widget to start in the on state.
        if (!dataSwitch.isChecked()) {
            dataSwitch.click();
        }
        // Disable "Cellular data" option.
        dataSwitch.click();
        if (api < 24) {
            device.findObject(new UiSelector().text("OK")).click();
        }
        // Wait for data connection to turn off.
        new Wait().until(new Wait.ExpectedCondition() {

            @Override
            public boolean isTrue() throws Exception {
                return !NetworkUtil.hasCellularNetworkConnection(instrumentation);
            }
        });
        assertFalse("Cellular data is enabled.", NetworkUtil.hasCellularNetworkConnection(instrumentation));
        if (api < 24) {
            assertFalse("Set cellular data limit text is visible.", device.findObject(new UiSelector().textContains("Set cellular data limit")).exists());
        }
        if (api >= 24) {
            assertFalse("Set cellular data is not turned off.", device.findObject(new UiSelector().textContains("ON").resourceId(Res.CELLULAR_DATA_SWITCH_RES).className("android.widget.Switch")).exists());
        }
        // Enable Cellular data.
        dataSwitch.click();
    }
}
#end_block

#method_before
@Test
@TestInfo(id = "14581408")
public void toggleCellularDataOn() throws Exception {
    final Instrumentation instrumentation = testFramework.getInstrumentation();
    UiDevice device = UiDevice.getInstance(instrumentation);
    // TODO: Add a fixture method in AppLauncher class to launch a specified path.
    int api = testFramework.getApi();
    if (api >= 23) {
        UiObject2 dataSwitch = navigateToDataSwitch(instrumentation);
        // Test requires "Cellular data" switch widget to start in the off state.
        if (dataSwitch.isChecked()) {
            dataSwitch.click();
            if (api < 24) {
                device.findObject(new UiSelector().text("OK")).click();
            }
        }
        // Enable Cellular data.
        dataSwitch.click();
        // Wait for data connection to turn off.
        new Wait().until(new Wait.ExpectedCondition() {

            @Override
            public boolean isTrue() throws Exception {
                return NetworkUtil.hasCellularNetworkConnection(instrumentation);
            }
        });
        assertTrue("Cellular data is disabled.", NetworkUtil.hasCellularNetworkConnection(instrumentation));
        if (api < 24) {
            assertTrue("Set cellular data limit text is not visible.", device.findObject(new UiSelector().textContains("Set cellular data limit")).exists());
        }
        if (api >= 24) {
            assertTrue("Set cellular data is not turned on.", device.findObject(new UiSelector().textContains("ON").resourceId("android:id/switch_widget").className("android.widget.Switch")).exists());
        }
    }
}
#method_after
@Test
@TestInfo(id = "14581408")
public void toggleCellularDataOn() throws Exception {
    final Instrumentation instrumentation = testFramework.getInstrumentation();
    UiDevice device = UiDevice.getInstance(instrumentation);
    // TODO: Add a fixture method in AppLauncher class to launch a specified path.
    int api = testFramework.getApi();
    if (api >= 23) {
        UiObject2 dataSwitch = navigateToDataSwitch(instrumentation);
        // Test requires "Cellular data" switch widget to start in the off state.
        if (dataSwitch.isChecked()) {
            dataSwitch.click();
            if (api < 24) {
                device.findObject(new UiSelector().text("OK")).click();
            }
        }
        // Enable Cellular data.
        dataSwitch.click();
        // Wait for data connection to turn off.
        new Wait().until(new Wait.ExpectedCondition() {

            @Override
            public boolean isTrue() throws Exception {
                return NetworkUtil.hasCellularNetworkConnection(instrumentation);
            }
        });
        assertTrue("Cellular data is disabled.", NetworkUtil.hasCellularNetworkConnection(instrumentation));
        if (api < 24) {
            assertTrue("Set cellular data limit text is not visible.", device.findObject(new UiSelector().textContains("Set cellular data limit")).exists());
        }
        if (api >= 24) {
            assertTrue("Set cellular data is not turned on.", device.findObject(new UiSelector().textContains("ON").resourceId(Res.CELLULAR_DATA_SWITCH_RES).className("android.widget.Switch")).exists());
        }
    }
}
#end_block

#method_before
private String getHostByAddr0(byte[] addr) throws UnknownHostException {
    // Android-changed: Rewritten on the top of Libcore.os
    InetAddress hostaddr = InetAddress.getByAddress(addr);
    try {
        return Libcore.os.getnameinfo(hostaddr, NI_NAMEREQD);
    } catch (GaiException e) {
        throw new UnknownHostException(hostaddr.toString());
    }
}
#method_after
private String getHostByAddr0(byte[] addr) throws UnknownHostException {
    // Android-changed: Rewritten on the top of Libcore.os
    InetAddress hostaddr = InetAddress.getByAddress(addr);
    try {
        return Libcore.os.getnameinfo(hostaddr, NI_NAMEREQD);
    } catch (GaiException e) {
        UnknownHostException uhe = new UnknownHostException(hostaddr.toString());
        uhe.initCause(e);
        throw uhe;
    }
}
#end_block

#method_before
public WifiConfiguration evaluateNetworks(List<ScanDetail> scanDetails, WifiConfiguration currentNetwork, String currentBssid, boolean connected, boolean untrustedNetworkAllowed, List<Pair<ScanDetail, WifiConfiguration>> connectableNetworks) {
    if (mScoreCache == null) {
        localLog("has no network score cache.");
        return null;
    }
    final ExternalScoreTracker externalScoreTracker = new ExternalScoreTracker(mLocalLog);
    ArrayList<NetworkKey> unscoredNetworks = new ArrayList<>();
    for (ScanDetail scanDetail : scanDetails) {
        ScanResult scanResult = scanDetail.getScanResult();
        // One ScanResult can be associated with more than one networks, hence we calculate all
        // the scores and use the highest one as the ScanResult's score.
        // TODO(b/31065385): WifiConfigManager does not support passpoint networks currently.
        // So this list has just one entry always.
        List<WifiConfiguration> associatedConfigs = null;
        WifiConfiguration associatedConfig = mWifiConfigManager.getSavedNetworkForScanDetailAndCache(scanDetail);
        if (associatedConfig != null) {
            associatedConfigs = new ArrayList<>(Arrays.asList(associatedConfig));
        }
        if (isPotentialEphemeralNetwork(associatedConfigs)) {
            if (untrustedNetworkAllowed) {
                if (!mWifiConfigManager.wasEphemeralNetworkDeleted(scanResult.SSID)) {
                    // Ephemeral network has either one WifiConfiguration or none yet.
                    // Checking BSSID is sufficient to determine whether this is the
                    // currently connected network.
                    boolean active = currentBssid != null && currentBssid.equals(scanResult.BSSID);
                    Integer score = getNetworkScore(scanResult, mScoreCache, active);
                    externalScoreTracker.trackUntrustedCandidate(score, scanResult);
                    if (connectableNetworks != null) {
                        connectableNetworks.add(Pair.create(scanDetail, getPotentialEphemeralNetworkConfiguration(associatedConfigs)));
                    }
                }
            }
            continue;
        }
        for (WifiConfiguration network : associatedConfigs) {
            WifiConfiguration.NetworkSelectionStatus status = network.getNetworkSelectionStatus();
            status.setSeenInLastQualifiedNetworkSelection(true);
            if (!status.isNetworkEnabled()) {
                continue;
            } else if (network.BSSID != null && !network.BSSID.equals("any") && !network.BSSID.equals(scanResult.BSSID)) {
                // App has specified the only BSSID to connect for this
                // configuration. So only the matching ScanResult can be a candidate.
                localLog("Network " + WifiNetworkSelector.toNetworkString(network) + " has specified BSSID " + network.BSSID + ". Skip " + scanResult.BSSID);
                continue;
            }
            // Saved network wth an external score.
            if (network.useExternalScores) {
                localLog("Network " + WifiNetworkSelector.toNetworkString(network) + " uses external score");
                boolean active = currentNetwork != null && currentNetwork == network && currentBssid != null && currentBssid.equals(scanResult.BSSID);
                Integer score = getNetworkScore(scanResult, mScoreCache, active);
                externalScoreTracker.trackSavedCandidate(score, network, scanResult);
                if (connectableNetworks != null) {
                    connectableNetworks.add(Pair.create(scanDetail, network));
                }
            }
        }
    }
    WifiConfiguration candidate = getExternalScoreCandidate(externalScoreTracker, mScoreCache);
    if (candidate != null && candidate.getNetworkSelectionStatus().getCandidate() != null) {
        return candidate;
    } else {
        return null;
    }
}
#method_after
public WifiConfiguration evaluateNetworks(List<ScanDetail> scanDetails, WifiConfiguration currentNetwork, String currentBssid, boolean connected, boolean untrustedNetworkAllowed, List<Pair<ScanDetail, WifiConfiguration>> connectableNetworks) {
    if (mScoreCache == null) {
        localLog("has no network score cache.");
        return null;
    }
    final ExternalScoreTracker externalScoreTracker = new ExternalScoreTracker(mLocalLog);
    ArrayList<NetworkKey> unscoredNetworks = new ArrayList<>();
    for (ScanDetail scanDetail : scanDetails) {
        ScanResult scanResult = scanDetail.getScanResult();
        // One ScanResult can be associated with more than one networks, hence we calculate all
        // the scores and use the highest one as the ScanResult's score.
        // TODO(b/31065385): WifiConfigManager does not support passpoint networks currently.
        // So this list has just one entry always.
        List<WifiConfiguration> associatedConfigs = null;
        WifiConfiguration associatedConfig = mWifiConfigManager.getSavedNetworkForScanDetailAndCache(scanDetail);
        if (associatedConfig != null) {
            associatedConfigs = new ArrayList<>(Arrays.asList(associatedConfig));
        }
        if (isPotentialEphemeralNetwork(associatedConfigs)) {
            if (untrustedNetworkAllowed) {
                if (!mWifiConfigManager.wasEphemeralNetworkDeleted(scanResult.SSID)) {
                    // Ephemeral network has either one WifiConfiguration or none yet.
                    // Checking BSSID is sufficient to determine whether this is the
                    // currently connected network.
                    boolean active = TextUtils.equals(currentBssid, scanResult.BSSID);
                    Integer score = getNetworkScore(scanResult, mScoreCache, active);
                    externalScoreTracker.trackUntrustedCandidate(score, scanResult);
                    if (connectableNetworks != null) {
                        connectableNetworks.add(Pair.create(scanDetail, getPotentialEphemeralNetworkConfiguration(associatedConfigs)));
                    }
                }
            }
            continue;
        }
        for (WifiConfiguration network : associatedConfigs) {
            WifiConfiguration.NetworkSelectionStatus status = network.getNetworkSelectionStatus();
            status.setSeenInLastQualifiedNetworkSelection(true);
            if (!status.isNetworkEnabled()) {
                continue;
            } else if (network.BSSID != null && !network.BSSID.equals("any") && !network.BSSID.equals(scanResult.BSSID)) {
                // App has specified the only BSSID to connect for this
                // configuration. So only the matching ScanResult can be a candidate.
                localLog("Network " + WifiNetworkSelector.toNetworkString(network) + " has specified BSSID " + network.BSSID + ". Skip " + scanResult.BSSID);
                continue;
            }
            // Saved network wth an external score.
            if (network.useExternalScores) {
                localLog("Network " + WifiNetworkSelector.toNetworkString(network) + " uses external score");
                boolean active = currentNetwork != null && currentNetwork == network && TextUtils.equals(currentBssid, scanResult.BSSID);
                Integer score = getNetworkScore(scanResult, mScoreCache, active);
                externalScoreTracker.trackSavedCandidate(score, network, scanResult);
                if (connectableNetworks != null) {
                    connectableNetworks.add(Pair.create(scanDetail, network));
                }
            }
        }
    }
    WifiConfiguration candidate = getExternalScoreCandidate(externalScoreTracker, mScoreCache);
    if (candidate != null && candidate.getNetworkSelectionStatus().getCandidate() != null) {
        return candidate;
    } else {
        return null;
    }
}
#end_block

#method_before
private synchronized boolean isBrowseSupported(String packageName) {
    boolean response = false;
    /* check if Browsable Player's list contains this package name */
    for (BrowsePlayerInfo info : mBrowsePlayerInfoList) {
        if (info.packageName.equals(packageName)) {
            // TODO: (apanicke) Currently browsing isn't implemented
            // properly and causes metadata to break. Fix browsing
            // interface and change this to true.
            response = false;
        }
    }
    if (DEBUG)
        Log.v(TAG, "isBrowseSupported for " + packageName + ": " + response);
    return response;
}
#method_after
private synchronized boolean isBrowseSupported(String packageName) {
    /* check if Browsable Player's list contains this package name */
    for (BrowsePlayerInfo info : mBrowsePlayerInfoList) {
        if (info.packageName.equals(packageName)) {
            if (DEBUG)
                Log.v(TAG, "isBrowseSupported for " + packageName + ": true");
            return true;
        }
    }
    if (DEBUG)
        Log.v(TAG, "isBrowseSupported for " + packageName + ": false");
    return false;
}
#end_block

#method_before
@Override
protected void engineInit(int opmode, Key key, AlgorithmParameterSpec params, SecureRandom random) throws InvalidKeyException, InvalidAlgorithmParameterException {
    if (params != null && padding != NativeConstants.RSA_PKCS1_OAEP_PADDING) {
        throw new InvalidAlgorithmParameterException("unknown param type: " + params.getClass().getName());
    }
    engineInitInternal(opmode, key);
}
#method_after
@Override
protected void engineInit(int opmode, Key key, AlgorithmParameterSpec params, SecureRandom random) throws InvalidKeyException, InvalidAlgorithmParameterException {
    if (params != null) {
        throw new InvalidAlgorithmParameterException("unknown param type: " + params.getClass().getName());
    }
    engineInitInternal(opmode, key);
}
#end_block

#method_before
public static void writeCertificate(Parcel dest, X509Certificate cert) {
    byte[] certBytes = null;
    if (cert != null) {
        try {
            certBytes = cert.getEncoded();
        } catch (CertificateEncodingException e) {
            certBytes = null;
        }
    }
    dest.writeByteArray(certBytes);
}
#method_after
public static void writeCertificate(Parcel dest, X509Certificate cert) {
    byte[] certBytes = null;
    if (cert != null) {
        try {
            certBytes = cert.getEncoded();
        } catch (CertificateEncodingException e) {
        /* empty, write null. */
        }
    }
    dest.writeByteArray(certBytes);
}
#end_block

#method_before
public static X509Certificate[] readCertificates(Parcel in) {
    int length = in.readInt();
    if (length <= 0) {
        return null;
    }
    X509Certificate[] certs = new X509Certificate[length];
    for (int i = 0; i < length; i++) {
        certs[i] = readCertificate(in);
    }
    return certs;
}
#method_after
public static X509Certificate[] readCertificates(Parcel in) {
    int length = in.readInt();
    if (length == 0) {
        return null;
    }
    X509Certificate[] certs = new X509Certificate[length];
    for (int i = 0; i < length; i++) {
        certs[i] = readCertificate(in);
    }
    return certs;
}
#end_block

#method_before
@Test
public void readWriteValidCertificates() throws Exception {
    X509Certificate[] writeCerts = new X509Certificate[2];
    writeCerts[0] = FakeKeys.CA_CERT0;
    writeCerts[1] = FakeKeys.CA_CERT1;
    ParcelUtil.writeCertificates(mParcel, writeCerts);
    // Rewind data position back to the beginning for read.
    mParcel.setDataPosition(0);
    X509Certificate[] readCerts = ParcelUtil.readCertificates(mParcel);
    assertNotNull(readCerts);
    assertEquals(writeCerts.length, readCerts.length);
    assertArrayEquals(writeCerts[0].getEncoded(), readCerts[0].getEncoded());
    assertArrayEquals(writeCerts[1].getEncoded(), readCerts[1].getEncoded());
}
#method_after
@Test
public void readWriteValidCertificates() throws Exception {
    X509Certificate[] writeCerts = new X509Certificate[2];
    writeCerts[0] = FakeKeys.CA_CERT0;
    writeCerts[1] = FakeKeys.CA_CERT1;
    ParcelUtil.writeCertificates(mParcel, writeCerts);
    // Rewind data position back to the beginning for read.
    mParcel.setDataPosition(0);
    X509Certificate[] readCerts = ParcelUtil.readCertificates(mParcel);
    assertNotNull(readCerts);
    assertEquals(writeCerts.length, readCerts.length);
    for (int i = 0; i < writeCerts.length; i++) {
        assertNotNull(readCerts[i]);
        assertArrayEquals(writeCerts[i].getEncoded(), readCerts[i].getEncoded());
    }
}
#end_block

#method_before
public void test_readStackOVerflow() throws Exception {
    // 2^16 should be enough to overflow
    Vector<InputStream> inputs = new Vector<>();
    for (int i = 0; i < 32768; i++) {
        inputs.add(new Support_ASimpleInputStream(new byte[] {}));
    }
    SequenceInputStream sequenceInputStream = new SequenceInputStream(inputs.elements());
    assertEquals(-1, sequenceInputStream.read());
    byte[] buf = new byte[10];
    sequenceInputStream = new SequenceInputStream(inputs.elements());
    assertEquals(-1, sequenceInputStream.read(buf, 0, 10));
}
#method_after
public void test_readStackOVerflow() throws Exception {
    // 2^16 should be enough to overflow
    Vector<InputStream> inputs = new Vector<>();
    InputStream emptyInputStream = new Support_ASimpleInputStream(new byte[0]);
    for (int i = 0; i < 32768; i++) {
        inputs.add(emptyInputStream);
    }
    SequenceInputStream sequenceInputStream = new SequenceInputStream(inputs.elements());
    assertEquals(-1, sequenceInputStream.read());
    byte[] buf = new byte[10];
    sequenceInputStream = new SequenceInputStream(inputs.elements());
    assertEquals(-1, sequenceInputStream.read(buf, 0, 10));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public static <T extends Comparable<? super T>> void sort(List<T> list) {
    list.sort(null);
}
#method_after
@SuppressWarnings("unchecked")
public static <T extends Comparable<? super T>> void sort(List<T> list) {
    if (list.getClass() == ArrayList.class) {
        Arrays.sort(((ArrayList) list).elementData, 0, list.size());
        return;
    }
    Object[] a = list.toArray();
    Arrays.sort(a);
    ListIterator<T> i = list.listIterator();
    for (int j = 0; j < a.length; j++) {
        i.next();
        i.set((T) a[j]);
    }
// Android-changed END
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "rawtypes" })
public static <T> void sort(List<T> list, Comparator<? super T> c) {
    list.sort(c);
}
#method_after
@SuppressWarnings({ "unchecked", "rawtypes" })
public static <T> void sort(List<T> list, Comparator<? super T> c) {
    if (list.getClass() == ArrayList.class) {
        Arrays.sort(((ArrayList) list).elementData, 0, list.size(), (Comparator) c);
        return;
    }
    Object[] a = list.toArray();
    Arrays.sort(a, (Comparator) c);
    ListIterator<T> i = list.listIterator();
    for (int j = 0; j < a.length; j++) {
        i.next();
        i.set((T) a[j]);
    }
// Android-changed END
}
#end_block

#method_before
// Singleton collections
public static <T> Set<T> singleton(T o) {
    return new SingletonSet<>(o);
}
#method_after
// Singleton collections
public static <E> Set<E> singleton(E o) {
    return new SingletonSet<>(o);
}
#end_block

#method_before
public static <T> List<T> singletonList(T o) {
    return new SingletonList<>(o);
}
#method_after
public static <E> List<E> singletonList(E o) {
    return new SingletonList<>(o);
}
#end_block

#method_before
public void startService() {
    mClientHandler = new ClientHandler(mLooper);
    mStateMachine = new RttStateMachine(mLooper);
    mWificond = makeWificond();
    mInterfaceEventHandler = new InterfaceEventHandler();
    try {
        List<IBinder> interfaces = mWificond.GetClientInterfaces();
        if (interfaces.size() > 0) {
            mClientInterface = IClientInterface.Stub.asInterface(interfaces.get(0));
        }
        mWificond.RegisterCallback(mInterfaceEventHandler);
    } catch (RemoteException e1) {
    }
    mContext.registerReceiver(new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            int state = intent.getIntExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WifiManager.WIFI_STATE_DISABLED);
            if (DBG)
                Log.d(TAG, "SCAN_AVAILABLE : " + state);
            if (state == WifiManager.WIFI_STATE_ENABLED) {
                mStateMachine.sendMessage(CMD_DRIVER_LOADED);
            } else if (state == WifiManager.WIFI_STATE_DISABLED) {
                mStateMachine.sendMessage(CMD_DRIVER_UNLOADED);
            }
        }
    }, new IntentFilter(WifiManager.WIFI_SCAN_AVAILABLE));
    mStateMachine.start();
}
#method_after
public void startService() {
    mClientHandler = new ClientHandler(mLooper);
    mStateMachine = new RttStateMachine(mLooper);
    mContext.registerReceiver(new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            int state = intent.getIntExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WifiManager.WIFI_STATE_DISABLED);
            if (DBG)
                Log.d(TAG, "SCAN_AVAILABLE : " + state);
            if (state == WifiManager.WIFI_STATE_ENABLED) {
                mStateMachine.sendMessage(CMD_DRIVER_LOADED);
            } else if (state == WifiManager.WIFI_STATE_DISABLED) {
                mStateMachine.sendMessage(CMD_DRIVER_UNLOADED);
            }
        }
    }, new IntentFilter(WifiManager.WIFI_SCAN_AVAILABLE));
    mStateMachine.start();
}
#end_block

#method_before
@Override
public void OnClientTorndownEvent(IClientInterface networkInterface) {
    if (networkInterface == mClientInterface) {
        mClientInterface = null;
    }
}
#method_after
@Override
public void OnClientTorndownEvent(IClientInterface networkInterface) {
    mRttStateMachine.sendMessage(CMD_CLIENT_INTERFACE_DOWN, networkInterface);
}
#end_block

#method_before
@Override
public void OnClientInterfaceReady(IClientInterface networkInterface) {
    mClientInterface = networkInterface;
}
#method_after
@Override
public void OnClientInterfaceReady(IClientInterface networkInterface) {
    mRttStateMachine.sendMessage(CMD_CLIENT_INTERFACE_READY, networkInterface);
}
#end_block

#method_before
@Override
public boolean processMessage(Message msg) {
    if (DBG)
        Log.d(TAG, "EnabledState got" + msg);
    ClientInfo ci;
    synchronized (mLock) {
        ci = mClients.get(msg.replyTo);
    }
    switch(msg.what) {
        case CMD_DRIVER_UNLOADED:
            transitionTo(mDefaultState);
            break;
        case CMD_ISSUE_NEXT_REQUEST:
            deferMessage(msg);
            transitionTo(mInitiatorEnabledState);
            break;
        case RttManager.CMD_OP_START_RANGING:
            {
                RttManager.ParcelableRttParams params = (RttManager.ParcelableRttParams) msg.obj;
                if (params == null || params.mParams == null || params.mParams.length == 0) {
                    replyFailed(msg, RttManager.REASON_INVALID_REQUEST, "No params");
                } else if (ci.addRttRequest(msg.arg2, params) == false) {
                    replyFailed(msg, RttManager.REASON_INVALID_REQUEST, "Unspecified");
                } else {
                    sendMessage(CMD_ISSUE_NEXT_REQUEST);
                }
            }
            break;
        case RttManager.CMD_OP_STOP_RANGING:
            for (Iterator<RttRequest> it = mRequestQueue.iterator(); it.hasNext(); ) {
                RttRequest request = it.next();
                if (request.key == msg.arg2) {
                    if (DBG)
                        Log.d(TAG, "Cancelling not-yet-scheduled RTT");
                    mRequestQueue.remove(request);
                    request.ci.reportAborted(request.key);
                    break;
                }
            }
            break;
        case RttManager.CMD_OP_ENABLE_RESPONDER:
            int key = msg.arg2;
            mResponderConfig = mWifiNative.enableRttResponder(MAX_RESPONDER_DURATION_SECONDS);
            if (DBG)
                Log.d(TAG, "mWifiNative.enableRttResponder called");
            if (mResponderConfig != null) {
                // TODO: remove once mac address is added when enabling responder.
                mResponderConfig.macAddress = mWifiNative.getMacAddress();
                ci.addResponderRequest(key);
                ci.reportResponderEnableSucceed(key, mResponderConfig);
                transitionTo(mResponderEnabledState);
            } else {
                Log.e(TAG, "enable responder failed");
                ci.reportResponderEnableFailed(key, RttManager.REASON_UNSPECIFIED);
            }
            break;
        case RttManager.CMD_OP_DISABLE_RESPONDER:
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message msg) {
    if (DBG)
        Log.d(TAG, "EnabledState got" + msg);
    ClientInfo ci;
    synchronized (mLock) {
        ci = mClients.get(msg.replyTo);
    }
    switch(msg.what) {
        case CMD_DRIVER_UNLOADED:
            transitionTo(mDefaultState);
            break;
        case CMD_ISSUE_NEXT_REQUEST:
            deferMessage(msg);
            transitionTo(mInitiatorEnabledState);
            break;
        case RttManager.CMD_OP_START_RANGING:
            {
                RttManager.ParcelableRttParams params = (RttManager.ParcelableRttParams) msg.obj;
                if (params == null || params.mParams == null || params.mParams.length == 0) {
                    replyFailed(msg, RttManager.REASON_INVALID_REQUEST, "No params");
                } else if (ci.addRttRequest(msg.arg2, params) == false) {
                    replyFailed(msg, RttManager.REASON_INVALID_REQUEST, "Unspecified");
                } else {
                    sendMessage(CMD_ISSUE_NEXT_REQUEST);
                }
            }
            break;
        case RttManager.CMD_OP_STOP_RANGING:
            for (Iterator<RttRequest> it = mRequestQueue.iterator(); it.hasNext(); ) {
                RttRequest request = it.next();
                if (request.key == msg.arg2) {
                    if (DBG)
                        Log.d(TAG, "Cancelling not-yet-scheduled RTT");
                    mRequestQueue.remove(request);
                    request.ci.reportAborted(request.key);
                    break;
                }
            }
            break;
        case RttManager.CMD_OP_ENABLE_RESPONDER:
            int key = msg.arg2;
            mResponderConfig = mWifiNative.enableRttResponder(MAX_RESPONDER_DURATION_SECONDS);
            if (DBG)
                Log.d(TAG, "mWifiNative.enableRttResponder called");
            if (mResponderConfig != null) {
                // TODO: remove once mac address is added when enabling responder.
                mResponderConfig.macAddress = mWifiNative.getMacAddress();
                ci.addResponderRequest(key);
                ci.reportResponderEnableSucceed(key, mResponderConfig);
                transitionTo(mResponderEnabledState);
            } else {
                Log.e(TAG, "enable responder failed");
                ci.reportResponderEnableFailed(key, RttManager.REASON_UNSPECIFIED);
            }
            break;
        case RttManager.CMD_OP_DISABLE_RESPONDER:
            break;
        case CMD_CLIENT_INTERFACE_DOWN:
            if (mClientInterface == (IClientInterface) msg.obj) {
                mClientInterface = null;
            }
            break;
        case CMD_CLIENT_INTERFACE_READY:
            mClientInterface = (IClientInterface) msg.obj;
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void onStart() {
    mImpl = new RttServiceImpl(getContext(), mHandlerThread.getLooper());
    Log.i(TAG, "Starting " + Context.WIFI_RTT_SERVICE);
    publishBinderService(Context.WIFI_RTT_SERVICE, mImpl);
}
#method_after
@Override
public void onStart() {
    mImpl = new RttServiceImpl(getContext(), mHandlerThread.getLooper(), WifiInjector.getInstance());
    Log.i(TAG, "Starting " + Context.WIFI_RTT_SERVICE);
    publishBinderService(Context.WIFI_RTT_SERVICE, mImpl);
}
#end_block

#method_before
@Override
public void onBootPhase(int phase) {
    if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {
        Log.i(TAG, "Registering " + Context.WIFI_RTT_SERVICE);
        if (mImpl == null) {
            mImpl = new RttServiceImpl(getContext(), mHandlerThread.getLooper());
        }
        mImpl.startService();
    }
}
#method_after
@Override
public void onBootPhase(int phase) {
    if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {
        Log.i(TAG, "Registering " + Context.WIFI_RTT_SERVICE);
        if (mImpl == null) {
            mImpl = new RttServiceImpl(getContext(), mHandlerThread.getLooper(), WifiInjector.getInstance());
        }
        mImpl.startService();
    }
}
#end_block

#method_before
public void write(byte[] b, int off, int len) throws IOException {
    if (closed && len > 0) {
        throw new IOException("Stream Closed");
    }
    IoBridge.write(fd, b, off, len);
}
#method_after
public void write(byte[] b, int off, int len) throws IOException {
    if (closed && len > 0) {
        throw new IOException("Stream Closed");
    }
    tracker.trackIo(len);
    IoBridge.write(fd, b, off, len);
}
#end_block

#method_before
public int read(byte[] b, int off, int len) throws IOException {
    if (closed && len > 0) {
        throw new IOException("Stream Closed");
    }
    return IoBridge.read(fd, b, off, len);
}
#method_after
public int read(byte[] b, int off, int len) throws IOException {
    if (closed && len > 0) {
        throw new IOException("Stream Closed");
    }
    tracker.trackIo(len);
    return IoBridge.read(fd, b, off, len);
}
#end_block

#method_before
public void test_getDisplayName_noLocaleArgument() {
    Currency currency = Currency.getInstance("DEM");
    Locales locales = getDefaultLocales();
    try {
        // Locales(locale, displayLocale, formatLocale)
        setDefaultLocales(new Locales(Locale.US, Locale.GERMANY, Locale.FRANCE));
        assertEquals("Deutsche Mark", currency.getDisplayName());
    } finally {
        setDefaultLocales(locales);
    }
}
#method_after
public void test_getDisplayName_noLocaleArgument() {
    Currency currency = Currency.getInstance("DEM");
    Locales locales = getDefaultLocales();
    try {
        // Locales(uncategorizedLocale, displayLocale, formatLocale)
        setDefaultLocales(new Locales(Locale.US, Locale.GERMANY, Locale.FRANCE));
        assertEquals("Deutsche Mark", currency.getDisplayName());
    } finally {
        setDefaultLocales(locales);
    }
}
#end_block

#method_before
static void setDefaultLocales(Locales locales) {
    // need to set these in this order because setDefault(Locale) overwrites the other
    // ones, at least on Android
    Locale.setDefault(locales.locale);
    Locale.setDefault(DISPLAY, locales.displayLocale);
    Locale.setDefault(FORMAT, locales.formatLocale);
}
#method_after
static void setDefaultLocales(Locales locales) {
    // The lines below must set the Locales in this order because setDefault(Locale)
    // overwrites the other ones.
    Locale.setDefault(locales.uncategorizedLocale);
    Locale.setDefault(DISPLAY, locales.displayLocale);
    Locale.setDefault(FORMAT, locales.formatLocale);
    // sanity check
    assertEquals(locales, getDefaultLocales());
}
#end_block

#method_before
public static String getJcaDigestAlgorithmStandardName(String algorithm) {
    if (("SHA-256".equalsIgnoreCase(algorithm)) || ("2.16.840.1.101.3.4.2.1".equals(algorithm))) {
        return "SHA-256";
    } else if (("SHA-512".equalsIgnoreCase(algorithm)) || ("2.16.840.1.101.3.4.2.3".equals(algorithm))) {
        return "SHA-512";
    } else if (("SHA-1".equalsIgnoreCase(algorithm)) || ("1.3.14.3.2.26".equals(algorithm))) {
        return "SHA-1";
    } else if (("SHA-384".equalsIgnoreCase(algorithm)) || ("2.16.840.1.101.3.4.2.2".equals(algorithm))) {
        return "SHA-384";
    } else if (("SHA-224".equalsIgnoreCase(algorithm)) || ("2.16.840.1.101.3.4.2.4".equals(algorithm))) {
        return "SHA-224";
    } else {
        return null;
    }
}
#method_after
public static String getJcaDigestAlgorithmStandardName(String algorithm) {
    String algorithmUpper = algorithm.toUpperCase(Locale.US);
    if ((SHA256.JCA_NAME.equals(algorithmUpper)) || (SHA256.OID.equals(algorithmUpper))) {
        return SHA256.JCA_NAME;
    } else if ((SHA512.JCA_NAME.equals(algorithmUpper)) || (SHA512.OID.equals(algorithmUpper))) {
        return SHA512.JCA_NAME;
    } else if ((SHA1.JCA_NAME.equals(algorithmUpper)) || (SHA1.OID.equals(algorithmUpper))) {
        return SHA1.JCA_NAME;
    } else if ((SHA384.JCA_NAME.equals(algorithmUpper)) || (SHA384.OID.equals(algorithmUpper))) {
        return SHA384.JCA_NAME;
    } else if ((SHA224.JCA_NAME.equals(algorithmUpper)) || (SHA224.OID.equals(algorithmUpper))) {
        return SHA224.JCA_NAME;
    } else {
        return null;
    }
}
#end_block

#method_before
public static long getEVP_MDByJcaDigestAlgorithmStandardName(String algorithm) throws NoSuchAlgorithmException {
    if ("SHA-256".equalsIgnoreCase(algorithm)) {
        return EvpMdRef.SHA256.EVP_MD;
    } else if ("SHA-512".equalsIgnoreCase(algorithm)) {
        return EvpMdRef.SHA512.EVP_MD;
    } else if ("SHA-1".equalsIgnoreCase(algorithm)) {
        return EvpMdRef.SHA1.EVP_MD;
    } else if ("SHA-384".equalsIgnoreCase(algorithm)) {
        return EvpMdRef.SHA384.EVP_MD;
    } else if ("SHA-224".equalsIgnoreCase(algorithm)) {
        return EvpMdRef.SHA224.EVP_MD;
    } else {
        throw new NoSuchAlgorithmException("Unsupported algorithm: " + algorithm);
    }
}
#method_after
public static long getEVP_MDByJcaDigestAlgorithmStandardName(String algorithm) throws NoSuchAlgorithmException {
    String algorithmUpper = algorithm.toUpperCase(Locale.US);
    if (SHA256.JCA_NAME.equals(algorithmUpper)) {
        return EvpMdRef.SHA256.EVP_MD;
    } else if (SHA512.JCA_NAME.equals(algorithmUpper)) {
        return EvpMdRef.SHA512.EVP_MD;
    } else if (SHA1.JCA_NAME.equals(algorithmUpper)) {
        return EvpMdRef.SHA1.EVP_MD;
    } else if (SHA384.JCA_NAME.equals(algorithmUpper)) {
        return EvpMdRef.SHA384.EVP_MD;
    } else if (SHA224.JCA_NAME.equals(algorithmUpper)) {
        return EvpMdRef.SHA224.EVP_MD;
    } else {
        throw new NoSuchAlgorithmException("Unsupported algorithm: " + algorithm);
    }
}
#end_block

#method_before
public static String toString(IBase.StringMatrix3x5 M) {
    return toString(M.s);
}
#method_after
public static String toString(IBase.VectorOfArray vec) {
    StringBuilder out = new StringBuilder();
    out.append("VectorOfArray(");
    for (int i = 0; i < vec.addresses.size(); ++i) {
        if (i > 0) {
            out.append(", ");
        }
        Byte[] address = vec.addresses.get(i);
        for (int j = 0; j < 6; ++j) {
            if (j > 0) {
                out.append(":");
            }
            byte b = address[j];
            if (b < 16) {
                out.append("0");
            }
            out.append(Integer.toHexString(b));
        }
    }
    out.append(")");
    return out.toString();
}
#end_block

#method_before
public void heyItsMe(IBazCallback cb) {
    Log.d(TAG, "SERVER: heyItsMe");
}
#method_after
public void heyItsMe(IBazCallback cb) {
    mCalled = true;
    cb.heyItsMe(null);
}
#end_block

#method_before
private void client() {
    {
        // Test access through base interface binder.
        IBase baseProxy = IBase.asInterface(HwBinder.getService("baz"));
        baseProxy.someBaseMethod();
    }
    IBaz proxy = IBaz.asInterface(HwBinder.getService("baz"));
    proxy.someBaseMethod();
    {
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        IBase.Foo result = proxy.someOtherBaseMethod(foo);
        Expect(toString(result), "Foo(x = 1, " + "y = Bar(z = 3.14, s = 'Lorem ipsum...'), " + "aaa = [Bar(z = 1.0, s = 'Hello, world 0'), " + "Bar(z = 1.01, s = 'Hello, world 1'), " + "Bar(z = 1.02, s = 'Hello, world 2'), " + "Bar(z = 1.03, s = 'Hello, world 3'), " + "Bar(z = 1.04, s = 'Hello, world 4')])");
    }
    {
        IBase.Foo[] inputArray = new IBase.Foo[2];
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        inputArray[0] = foo;
        foo = new IBase.Foo();
        foo.x = 2;
        for (int i = 0; i < 3; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 2.0f - (float) i * 0.01f;
            bar.s = "Lorem ipsum " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 1.1414f;
        foo.y.s = "Et tu brute?";
        inputArray[1] = foo;
        IBase.Foo[] outputArray = proxy.someMethodWithFooArrays(inputArray);
        Expect(toString(outputArray), "[Foo(x = 2, " + "y = Bar(z = 1.1414, s = 'Et tu brute?'), " + "aaa = [Bar(z = 2.0, s = 'Lorem ipsum 0'), " + "Bar(z = 1.99, s = 'Lorem ipsum 1'), " + "Bar(z = 1.98, s = 'Lorem ipsum 2')]), " + "Foo(x = 1, " + "y = Bar(z = 3.14, s = 'Lorem ipsum...'), " + "aaa = [Bar(z = 1.0, s = 'Hello, world 0'), " + "Bar(z = 1.01, s = 'Hello, world 1'), " + "Bar(z = 1.02, s = 'Hello, world 2'), " + "Bar(z = 1.03, s = 'Hello, world 3'), " + "Bar(z = 1.04, s = 'Hello, world 4')])]");
    }
    {
        IBase.Foo[] inputArray = new IBase.Foo[2];
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        inputArray[0] = foo;
        foo = new IBase.Foo();
        foo.x = 2;
        for (int i = 0; i < 3; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 2.0f - (float) i * 0.01f;
            bar.s = "Lorem ipsum " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 1.1414f;
        foo.y.s = "Et tu brute?";
        inputArray[1] = foo;
        IBase.Foo[] outputArray = proxy.someMethodWithFooVectors(inputArray);
        Expect(toString(outputArray), "[Foo(x = 2, " + "y = Bar(z = 1.1414, s = 'Et tu brute?'), " + "aaa = [Bar(z = 2.0, s = 'Lorem ipsum 0'), " + "Bar(z = 1.99, s = 'Lorem ipsum 1'), " + "Bar(z = 1.98, s = 'Lorem ipsum 2')]), " + "Foo(x = 1, " + "y = Bar(z = 3.14, s = 'Lorem ipsum...'), " + "aaa = [Bar(z = 1.0, s = 'Hello, world 0'), " + "Bar(z = 1.01, s = 'Hello, world 1'), " + "Bar(z = 1.02, s = 'Hello, world 2'), " + "Bar(z = 1.03, s = 'Hello, world 3'), " + "Bar(z = 1.04, s = 'Hello, world 4')])]");
    }
    {
        IBase.StringMatrix5x3 in = new IBase.StringMatrix5x3();
        for (int i = 0; i < 5; ++i) {
            for (int j = 0; j < 3; ++j) {
                in.s[i][j] = numberToEnglish(3 * i + j + 1);
            }
        }
        IBase.StringMatrix3x5 out = proxy.transpose(in);
        // [[1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15]]^T
        // = [[1 4 7 10 13] [2 5 8 11 14] [3 6 9 12 15]]
        Expect(toString(out), "[['one', 'four', 'seven', 'ten', 'thirteen'], " + "['two', 'five', 'eight', 'eleven', 'fourteen'], " + "['three', 'six', 'nine', 'twelve', 'fifteen']]");
    }
    {
        String[][] in = new String[5][3];
        for (int i = 0; i < 5; ++i) {
            for (int j = 0; j < 3; ++j) {
                in[i][j] = numberToEnglish(3 * i + j + 1);
            }
        }
        String[][] out = proxy.transpose2(in);
        // [[1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15]]^T
        // = [[1 4 7 10 13] [2 5 8 11 14] [3 6 9 12 15]]
        Expect(toString(out), "[['one', 'four', 'seven', 'ten', 'thirteen'], " + "['two', 'five', 'eight', 'eleven', 'fourteen'], " + "['three', 'six', 'nine', 'twelve', 'fifteen']]");
    }
    Expect(toString(proxy.someBoolMethod(true)), "false");
    {
        boolean[] someBoolArray = new boolean[3];
        someBoolArray[0] = true;
        someBoolArray[1] = false;
        someBoolArray[2] = true;
        Expect(toString(proxy.someBoolArrayMethod(someBoolArray)), "[false, true, false, true]");
        Expect(toString(proxy.someBoolVectorMethod(someBoolArray)), "[false, true, false]");
    }
    proxy.doThis(1.0f);
    Expect(toString(proxy.doThatAndReturnSomething(1)), "666");
    Expect(toString(proxy.doQuiteABit(1, 2L, 3.0f, 4.0)), "666.5");
    {
        int[] param = new int[15];
        for (int i = 0; i < param.length; ++i) {
            param[i] = i;
        }
        Expect(toString(proxy.doSomethingElse(param)), "[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, " + "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 1, 2]");
        Expect(toString(proxy.mapThisVector(param)), "[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28]");
    }
    Expect(toString(proxy.doStuffAndReturnAString()), "'Hello, world!'");
    BazCallback cb = new BazCallback();
    ExpectTrue(!cb.wasCalled());
    proxy.callMe(cb);
    ExpectTrue(cb.wasCalled());
    Expect(toString(proxy.useAnEnum(IBaz.SomeEnum.goober)), "-64");
    {
        String[] strings = new String[3];
        strings[0] = "one";
        strings[1] = "two";
        strings[2] = "three";
        Expect(toString(proxy.haveSomeStrings(strings)), "['Hello', 'World']");
        Expect(toString(proxy.haveAStringVec(strings)), "['Hello', 'World']");
    }
    proxy.returnABunchOfStrings(new IBaz.returnABunchOfStringsCallback() {

        @Override
        public void onValues(String a, String b, String c) {
            Expect(a, "Eins");
            Expect(b, "Zwei");
            Expect(c, "Drei");
        }
    });
}
#method_after
private void client() {
    {
        // Test access through base interface binder.
        IBase baseProxy = IBase.asInterface(HwBinder.getService("baz"));
        baseProxy.someBaseMethod();
    }
    IBaz proxy = IBaz.asInterface(HwBinder.getService("baz"));
    proxy.someBaseMethod();
    {
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        IBase.Foo result = proxy.someOtherBaseMethod(foo);
        Expect(toString(result), "Foo(x = 1, " + "y = Bar(z = 3.14, s = 'Lorem ipsum...'), " + "aaa = [Bar(z = 1.0, s = 'Hello, world 0'), " + "Bar(z = 1.01, s = 'Hello, world 1'), " + "Bar(z = 1.02, s = 'Hello, world 2'), " + "Bar(z = 1.03, s = 'Hello, world 3'), " + "Bar(z = 1.04, s = 'Hello, world 4')])");
    }
    {
        IBase.Foo[] inputArray = new IBase.Foo[2];
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        inputArray[0] = foo;
        foo = new IBase.Foo();
        foo.x = 2;
        for (int i = 0; i < 3; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 2.0f - (float) i * 0.01f;
            bar.s = "Lorem ipsum " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 1.1414f;
        foo.y.s = "Et tu brute?";
        inputArray[1] = foo;
        IBase.Foo[] outputArray = proxy.someMethodWithFooArrays(inputArray);
        Expect(toString(outputArray), "[Foo(x = 2, " + "y = Bar(z = 1.1414, s = 'Et tu brute?'), " + "aaa = [Bar(z = 2.0, s = 'Lorem ipsum 0'), " + "Bar(z = 1.99, s = 'Lorem ipsum 1'), " + "Bar(z = 1.98, s = 'Lorem ipsum 2')]), " + "Foo(x = 1, " + "y = Bar(z = 3.14, s = 'Lorem ipsum...'), " + "aaa = [Bar(z = 1.0, s = 'Hello, world 0'), " + "Bar(z = 1.01, s = 'Hello, world 1'), " + "Bar(z = 1.02, s = 'Hello, world 2'), " + "Bar(z = 1.03, s = 'Hello, world 3'), " + "Bar(z = 1.04, s = 'Hello, world 4')])]");
    }
    {
        IBase.Foo[] inputArray = new IBase.Foo[2];
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        inputArray[0] = foo;
        foo = new IBase.Foo();
        foo.x = 2;
        for (int i = 0; i < 3; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 2.0f - (float) i * 0.01f;
            bar.s = "Lorem ipsum " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 1.1414f;
        foo.y.s = "Et tu brute?";
        inputArray[1] = foo;
        IBase.Foo[] outputArray = proxy.someMethodWithFooVectors(inputArray);
        Expect(toString(outputArray), "[Foo(x = 2, " + "y = Bar(z = 1.1414, s = 'Et tu brute?'), " + "aaa = [Bar(z = 2.0, s = 'Lorem ipsum 0'), " + "Bar(z = 1.99, s = 'Lorem ipsum 1'), " + "Bar(z = 1.98, s = 'Lorem ipsum 2')]), " + "Foo(x = 1, " + "y = Bar(z = 3.14, s = 'Lorem ipsum...'), " + "aaa = [Bar(z = 1.0, s = 'Hello, world 0'), " + "Bar(z = 1.01, s = 'Hello, world 1'), " + "Bar(z = 1.02, s = 'Hello, world 2'), " + "Bar(z = 1.03, s = 'Hello, world 3'), " + "Bar(z = 1.04, s = 'Hello, world 4')])]");
    }
    {
        IBase.VectorOfArray in = new IBase.VectorOfArray();
        int k = 0;
        for (int i = 0; i < 3; ++i) {
            Byte[] mac = new Byte[6];
            for (int j = 0; j < 6; ++j, ++k) {
                mac[j] = (byte) k;
            }
            in.addresses.add(mac);
        }
        IBase.VectorOfArray out = proxy.someMethodWithVectorOfArray(in);
        Expect(toString(out), "VectorOfArray(" + "0c:0d:0e:0f:10:11, " + "06:07:08:09:0a:0b, " + "00:01:02:03:04:05)");
    }
    {
        IBase.StringMatrix5x3 in = new IBase.StringMatrix5x3();
        for (int i = 0; i < 5; ++i) {
            for (int j = 0; j < 3; ++j) {
                in.s[i][j] = numberToEnglish(3 * i + j + 1);
            }
        }
        IBase.StringMatrix3x5 out = proxy.transpose(in);
        // [[1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15]]^T
        // = [[1 4 7 10 13] [2 5 8 11 14] [3 6 9 12 15]]
        Expect(toString(out), "[['one', 'four', 'seven', 'ten', 'thirteen'], " + "['two', 'five', 'eight', 'eleven', 'fourteen'], " + "['three', 'six', 'nine', 'twelve', 'fifteen']]");
    }
    {
        String[][] in = new String[5][3];
        for (int i = 0; i < 5; ++i) {
            for (int j = 0; j < 3; ++j) {
                in[i][j] = numberToEnglish(3 * i + j + 1);
            }
        }
        String[][] out = proxy.transpose2(in);
        // [[1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15]]^T
        // = [[1 4 7 10 13] [2 5 8 11 14] [3 6 9 12 15]]
        Expect(toString(out), "[['one', 'four', 'seven', 'ten', 'thirteen'], " + "['two', 'five', 'eight', 'eleven', 'fourteen'], " + "['three', 'six', 'nine', 'twelve', 'fifteen']]");
    }
    Expect(toString(proxy.someBoolMethod(true)), "false");
    {
        boolean[] someBoolArray = new boolean[3];
        someBoolArray[0] = true;
        someBoolArray[1] = false;
        someBoolArray[2] = true;
        Expect(toString(proxy.someBoolArrayMethod(someBoolArray)), "[false, true, false, true]");
        Expect(toString(proxy.someBoolVectorMethod(someBoolArray)), "[false, true, false]");
    }
    proxy.doThis(1.0f);
    Expect(toString(proxy.doThatAndReturnSomething(1)), "666");
    Expect(toString(proxy.doQuiteABit(1, 2L, 3.0f, 4.0)), "666.5");
    {
        int[] param = new int[15];
        for (int i = 0; i < param.length; ++i) {
            param[i] = i;
        }
        Expect(toString(proxy.doSomethingElse(param)), "[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, " + "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 1, 2]");
        Expect(toString(proxy.mapThisVector(param)), "[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28]");
    }
    Expect(toString(proxy.doStuffAndReturnAString()), "'Hello, world!'");
    BazCallback cb = new BazCallback();
    ExpectTrue(!cb.wasCalled());
    proxy.callMe(cb);
    ExpectTrue(cb.wasCalled());
    Expect(toString(proxy.useAnEnum(IBaz.SomeEnum.goober)), "-64");
    {
        String[] strings = new String[3];
        strings[0] = "one";
        strings[1] = "two";
        strings[2] = "three";
        Expect(toString(proxy.haveSomeStrings(strings)), "['Hello', 'World']");
        Expect(toString(proxy.haveAStringVec(strings)), "['Hello', 'World']");
    }
    proxy.returnABunchOfStrings(new IBaz.returnABunchOfStringsCallback() {

        @Override
        public void onValues(String a, String b, String c) {
            Expect(a, "Eins");
            Expect(b, "Zwei");
            Expect(c, "Drei");
        }
    });
}
#end_block

#method_before
private void uncrypt() {
    Log.i(TAG, "Calling uncrypt and monitoring the progress...");
    final RecoverySystem.ProgressListener progressListener = new RecoverySystem.ProgressListener() {

        @Override
        public void onProgress(int status) {
            if (status >= 0 && status < 100) {
                // Scale down to [MOUNT_SERVICE_STOP_PERCENT, 100).
                status = (int) (status * (100.0 - MOUNT_SERVICE_STOP_PERCENT) / 100);
                status += MOUNT_SERVICE_STOP_PERCENT;
                CharSequence msg = mContext.getText(com.android.internal.R.string.reboot_to_update_package);
                sInstance.setRebootProgress(status, msg);
            } else if (status == 100) {
                CharSequence msg = mContext.getText(com.android.internal.R.string.reboot_to_update_reboot);
                sInstance.setRebootProgress(status, msg);
            } else {
            // Ignored
            }
        }
    };
    final boolean[] done = new boolean[1];
    done[0] = false;
    Thread t = new Thread() {

        @Override
        public void run() {
            RecoverySystem rs = (RecoverySystem) mContext.getSystemService(Context.RECOVERY_SERVICE);
            String filename = null;
            try {
                filename = FileUtils.readTextFile(RecoverySystem.UNCRYPT_PACKAGE_FILE, 0, null);
                rs.processPackage(mContext, new File(filename), progressListener);
            } catch (IOException e) {
                Log.e(TAG, "Error uncrypting file", e);
            }
            done[0] = true;
        }
    };
    t.start();
    try {
        t.join(MAX_UNCRYPT_WAIT_TIME);
    } catch (InterruptedException unused) {
    }
    if (!done[0]) {
        Log.w(TAG, "Timed out waiting for uncrypt.");
        final int kUncryptTimeoutError = 100;
        String timeoutMessage = String.format("uncrypt_time: %d\n", MAX_UNCRYPT_WAIT_TIME / 1000);
        timeoutMessage += String.format("uncrypt_error: %d\n", kUncryptTimeout);
        try {
            FileUtils.stringToFile(RecoverySystem.UNCRYPT_STATUS_FILE, timeoutMessage);
        } catch (IOException e) {
            Log.e(TAG, "Failed to write timeout message to uncrypt status", e);
        }
    }
}
#method_after
private void uncrypt() {
    Log.i(TAG, "Calling uncrypt and monitoring the progress...");
    final RecoverySystem.ProgressListener progressListener = new RecoverySystem.ProgressListener() {

        @Override
        public void onProgress(int status) {
            if (status >= 0 && status < 100) {
                // Scale down to [MOUNT_SERVICE_STOP_PERCENT, 100).
                status = (int) (status * (100.0 - MOUNT_SERVICE_STOP_PERCENT) / 100);
                status += MOUNT_SERVICE_STOP_PERCENT;
                CharSequence msg = mContext.getText(com.android.internal.R.string.reboot_to_update_package);
                sInstance.setRebootProgress(status, msg);
            } else if (status == 100) {
                CharSequence msg = mContext.getText(com.android.internal.R.string.reboot_to_update_reboot);
                sInstance.setRebootProgress(status, msg);
            } else {
            // Ignored
            }
        }
    };
    final boolean[] done = new boolean[1];
    done[0] = false;
    Thread t = new Thread() {

        @Override
        public void run() {
            RecoverySystem rs = (RecoverySystem) mContext.getSystemService(Context.RECOVERY_SERVICE);
            String filename = null;
            try {
                filename = FileUtils.readTextFile(RecoverySystem.UNCRYPT_PACKAGE_FILE, 0, null);
                rs.processPackage(mContext, new File(filename), progressListener);
            } catch (IOException e) {
                Log.e(TAG, "Error uncrypting file", e);
            }
            done[0] = true;
        }
    };
    t.start();
    try {
        t.join(MAX_UNCRYPT_WAIT_TIME);
    } catch (InterruptedException unused) {
    }
    if (!done[0]) {
        Log.w(TAG, "Timed out waiting for uncrypt.");
        final int uncryptTimeoutError = 100;
        String timeoutMessage = String.format("uncrypt_time: %d\n" + "uncrypt_error: %d\n", MAX_UNCRYPT_WAIT_TIME / 1000, uncryptTimeoutError);
        try {
            FileUtils.stringToFile(RecoverySystem.UNCRYPT_STATUS_FILE, timeoutMessage);
        } catch (IOException e) {
            Log.e(TAG, "Failed to write timeout message to uncrypt status", e);
        }
    }
}
#end_block

#method_before
public void untetherAll() {
    synchronized (mPublicSync) {
        stopTethering(ConnectivityManager.TETHERING_WIFI);
        stopTethering(ConnectivityManager.TETHERING_USB);
        stopTethering(ConnectivityManager.TETHERING_BLUETOOTH);
    }
}
#method_after
public void untetherAll() {
    stopTethering(ConnectivityManager.TETHERING_WIFI);
    stopTethering(ConnectivityManager.TETHERING_USB);
    stopTethering(ConnectivityManager.TETHERING_BLUETOOTH);
}
#end_block

#method_before
@Override
public void notifyInterfaceStateChange(String iface, TetherInterfaceStateMachine who, int state, int error) {
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState != null && tetherState.mStateMachine.equals(who)) {
            if (tetherState.mLastState != state) {
                try {
                    // Notify that we're tethering (or not) this interface.
                    // This is how data saver for instance knows if the user explicitly
                    // turned on tethering (thus keeping us from being in data saver mode).
                    mPolicyManager.onTetheringChanged(iface, state == IControlsTethering.STATE_TETHERED);
                } catch (RemoteException e) {
                // Not really very much we can do here.
                }
            }
            tetherState.mLastState = state;
            tetherState.mLastError = error;
        } else {
            if (DBG)
                Log.d(TAG, "got notification from stale iface " + iface);
        }
    }
    if (DBG) {
        Log.d(TAG, "iface " + iface + " notified that it was in state " + state + " with error " + error);
    }
    switch(state) {
        case IControlsTethering.STATE_UNAVAILABLE:
        case IControlsTethering.STATE_AVAILABLE:
            mTetherMasterSM.sendMessage(TetherMasterSM.CMD_TETHER_MODE_UNREQUESTED, who);
            break;
        case IControlsTethering.STATE_TETHERED:
            mTetherMasterSM.sendMessage(TetherMasterSM.CMD_TETHER_MODE_REQUESTED, who);
            break;
    }
    sendTetherStateChangedBroadcast();
}
#method_after
@Override
public void notifyInterfaceStateChange(String iface, TetherInterfaceStateMachine who, int state, int error) {
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState != null && tetherState.mStateMachine.equals(who)) {
            tetherState.mLastState = state;
            tetherState.mLastError = error;
        } else {
            if (DBG)
                Log.d(TAG, "got notification from stale iface " + iface);
        }
    }
    if (DBG) {
        Log.d(TAG, "iface " + iface + " notified that it was in state " + state + " with error " + error);
    }
    try {
        // Notify that we're tethering (or not) this interface.
        // This is how data saver for instance knows if the user explicitly
        // turned on tethering (thus keeping us from being in data saver mode).
        mPolicyManager.onTetheringChanged(iface, state == IControlsTethering.STATE_TETHERED);
    } catch (RemoteException e) {
    // Not really very much we can do here.
    }
    switch(state) {
        case IControlsTethering.STATE_UNAVAILABLE:
        case IControlsTethering.STATE_AVAILABLE:
            mTetherMasterSM.sendMessage(TetherMasterSM.CMD_TETHER_MODE_UNREQUESTED, who);
            break;
        case IControlsTethering.STATE_TETHERED:
            mTetherMasterSM.sendMessage(TetherMasterSM.CMD_TETHER_MODE_REQUESTED, who);
            break;
    }
    sendTetherStateChangedBroadcast();
}
#end_block

#method_before
@Override
public void notifyInterfaceStateChange(String iface, TetherInterfaceStateMachine who, int state, int error) {
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState != null && tetherState.mStateMachine.equals(who)) {
            if (tetherState.mLastState != state) {
                try {
                    // Notify that we're tethering (or not) this interface.
                    // This is how data saver for instance knows if the user explicitly
                    // turned on tethering (thus keeping us from being in data saver mode).
                    mPolicyManager.onTetheringChanged(iface, state == IControlsTethering.STATE_TETHERED);
                } catch (RemoteException e) {
                // Not really very much we can do here.
                }
            }
            tetherState.mLastState = state;
            tetherState.mLastError = error;
        } else {
            if (DBG)
                Log.d(TAG, "got notification from stale iface " + iface);
        }
    }
    if (DBG) {
        Log.d(TAG, "iface " + iface + " notified that it was in state " + state + " with error " + error);
    }
    switch(state) {
        case IControlsTethering.STATE_UNAVAILABLE:
        case IControlsTethering.STATE_AVAILABLE:
            mTetherMasterSM.sendMessage(TetherMasterSM.CMD_TETHER_MODE_UNREQUESTED, who);
            break;
        case IControlsTethering.STATE_TETHERED:
            mTetherMasterSM.sendMessage(TetherMasterSM.CMD_TETHER_MODE_REQUESTED, who);
            break;
    }
    sendTetherStateChangedBroadcast();
}
#method_after
@Override
public void notifyInterfaceStateChange(String iface, TetherInterfaceStateMachine who, int state, int error) {
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState != null && tetherState.mStateMachine.equals(who)) {
            tetherState.mLastState = state;
            tetherState.mLastError = error;
        } else {
            if (DBG)
                Log.d(TAG, "got notification from stale iface " + iface);
        }
    }
    if (DBG) {
        Log.d(TAG, "iface " + iface + " notified that it was in state " + state + " with error " + error);
    }
    try {
        // Notify that we're tethering (or not) this interface.
        // This is how data saver for instance knows if the user explicitly
        // turned on tethering (thus keeping us from being in data saver mode).
        mPolicyManager.onTetheringChanged(iface, state == IControlsTethering.STATE_TETHERED);
    } catch (RemoteException e) {
    // Not really very much we can do here.
    }
    switch(state) {
        case IControlsTethering.STATE_UNAVAILABLE:
        case IControlsTethering.STATE_AVAILABLE:
            mTetherMasterSM.sendMessage(TetherMasterSM.CMD_TETHER_MODE_UNREQUESTED, who);
            break;
        case IControlsTethering.STATE_TETHERED:
            mTetherMasterSM.sendMessage(TetherMasterSM.CMD_TETHER_MODE_REQUESTED, who);
            break;
    }
    sendTetherStateChangedBroadcast();
}
#end_block

#method_before
public void test_defaultLookupClassAndModes() {
    MethodHandles.Lookup deafultLookup = MethodHandles.lookup();
    assertSame(MethodHandlesTest.class, deafultLookup.lookupClass());
    assertEquals(ALL_LOOKUP_MODES, deafultLookup.lookupModes());
}
#method_after
public void test_defaultLookupClassAndModes() {
    MethodHandles.Lookup defaultLookup = MethodHandles.lookup();
    assertSame(MethodHandlesTest.class, defaultLookup.lookupClass());
    assertEquals(ALL_LOOKUP_MODES, defaultLookup.lookupModes());
}
#end_block

#method_before
public static boolean isSamePackage(Class<?> class1, Class<?> class2) {
    assert (!class1.isArray() && !class2.isArray());
    if (class1 == class2)
        return true;
    if (class1.getClassLoader() != class2.getClassLoader())
        return false;
    String name1 = class1.getName(), name2 = class2.getName();
    int dot = name1.lastIndexOf('.');
    if (dot != name2.lastIndexOf('.'))
        return false;
    for (int i = 0; i < dot; i++) {
        if (name1.charAt(i) != name2.charAt(i))
            return false;
    }
    return true;
}
#method_after
public static boolean isSamePackage(Class<?> class1, Class<?> class2) {
    // Android-changed: Throw IAE (instead of asserting) if called with array classes.
    if (class1.isArray() || class2.isArray()) {
        throw new IllegalArgumentException();
    }
    if (class1 == class2)
        return true;
    if (class1.getClassLoader() != class2.getClassLoader())
        return false;
    String name1 = class1.getName(), name2 = class2.getName();
    int dot = name1.lastIndexOf('.');
    if (dot != name2.lastIndexOf('.'))
        return false;
    for (int i = 0; i < dot; i++) {
        if (name1.charAt(i) != name2.charAt(i))
            return false;
    }
    return true;
}
#end_block

#method_before
private static void checkUnprivilegedlookupClass(Class<?> lookupClass, int allowedModes) {
    String name = lookupClass.getName();
    if (name.startsWith("java.lang.invoke."))
        throw newIllegalArgumentException("illegal lookupClass: " + lookupClass);
    // Android-changed: The bootstrap classloader isn't null.
    if (allowedModes == ALL_MODES && lookupClass.getClassLoader() == ClassLoader.getBootClassLoader()) {
        if (name.startsWith("java.") || (name.startsWith("sun.") && !name.startsWith("sun.invoke."))) {
            throw newIllegalArgumentException("illegal lookupClass: " + lookupClass);
        }
    }
}
#method_after
private static void checkUnprivilegedlookupClass(Class<?> lookupClass, int allowedModes) {
    String name = lookupClass.getName();
    if (name.startsWith("java.lang.invoke."))
        throw newIllegalArgumentException("illegal lookupClass: " + lookupClass);
    // Android-changed: The bootstrap classloader isn't null.
    if (allowedModes == ALL_MODES && lookupClass.getClassLoader() == Object.class.getClassLoader()) {
        if (name.startsWith("java.") || (name.startsWith("sun.") && !name.startsWith("sun.invoke."))) {
            throw newIllegalArgumentException("illegal lookupClass: " + lookupClass);
        }
    }
}
#end_block

#method_before
public MethodHandle findStatic(Class<?> refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
    // TODO(narayan): Implement this method.
    return null;
}
#method_after
public MethodHandle findStatic(Class<?> refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
    // TODO(narayan): Implement this method.
    throw new UnsupportedOperationException("MethodHandles.Lookup.findStatic is not implemented");
}
#end_block

#method_before
public MethodHandle findVirtual(Class<?> refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
    // TODO(narayan): Implement this method.
    return null;
}
#method_after
public MethodHandle findVirtual(Class<?> refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
    // TODO(narayan): Implement this method.
    throw new UnsupportedOperationException("MethodHandles.Lookup.findVirtual is not implemented");
}
#end_block

#method_before
public MethodHandle findConstructor(Class<?> refc, MethodType type) throws NoSuchMethodException, IllegalAccessException {
    // TODO(narayan): Implement this method.
    return null;
}
#method_after
public MethodHandle findConstructor(Class<?> refc, MethodType type) throws NoSuchMethodException, IllegalAccessException {
    // TODO(narayan): Implement this method.
    throw new UnsupportedOperationException("MethodHandles.Lookup.findConstructor is not implemented");
}
#end_block

#method_before
public MethodHandle findSpecial(Class<?> refc, String name, MethodType type, Class<?> specialCaller) throws NoSuchMethodException, IllegalAccessException {
    // TODO(narayan): Implement this method.
    return null;
}
#method_after
public MethodHandle findSpecial(Class<?> refc, String name, MethodType type, Class<?> specialCaller) throws NoSuchMethodException, IllegalAccessException {
    // TODO(narayan): Implement this method.
    throw new UnsupportedOperationException("MethodHandles.Lookup.findSpecial is not implemented");
}
#end_block

#method_before
public MethodHandle findGetter(Class<?> refc, String name, Class<?> type) throws NoSuchFieldException, IllegalAccessException {
    // TODO(narayan): Implement this method.
    return null;
}
#method_after
public MethodHandle findGetter(Class<?> refc, String name, Class<?> type) throws NoSuchFieldException, IllegalAccessException {
    // TODO(narayan): Implement this method.
    throw new UnsupportedOperationException("MethodHandles.Lookup.findGetter is not implemented");
}
#end_block

#method_before
public MethodHandle findSetter(Class<?> refc, String name, Class<?> type) throws NoSuchFieldException, IllegalAccessException {
    // TODO(narayan): Implement this method.
    return null;
}
#method_after
public MethodHandle findSetter(Class<?> refc, String name, Class<?> type) throws NoSuchFieldException, IllegalAccessException {
    // TODO(narayan): Implement this method.
    throw new UnsupportedOperationException("MethodHandles.Lookup.findSetter is not implemented");
}
#end_block

#method_before
public MethodHandle findStaticGetter(Class<?> refc, String name, Class<?> type) throws NoSuchFieldException, IllegalAccessException {
    // TODO(narayan): Implement this method.
    return null;
}
#method_after
public MethodHandle findStaticGetter(Class<?> refc, String name, Class<?> type) throws NoSuchFieldException, IllegalAccessException {
    // TODO(narayan): Implement this method.
    throw new UnsupportedOperationException("MethodHandles.Lookup.findStaticGetter is not implemented");
}
#end_block

#method_before
public MethodHandle findStaticSetter(Class<?> refc, String name, Class<?> type) throws NoSuchFieldException, IllegalAccessException {
    // TODO(narayan): Implement this method.
    return null;
}
#method_after
public MethodHandle findStaticSetter(Class<?> refc, String name, Class<?> type) throws NoSuchFieldException, IllegalAccessException {
    // TODO(narayan): Implement this method.
    throw new UnsupportedOperationException("MethodHandles.Lookup.findStaticSetter is not implemented");
}
#end_block

#method_before
public MethodHandle bind(Object receiver, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
    // TODO(narayan): Implement this method.
    return null;
}
#method_after
public MethodHandle bind(Object receiver, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
    // TODO(narayan): Implement this method.
    throw new UnsupportedOperationException("MethodHandles.Lookup.bind is not implemented");
}
#end_block

#method_before
public MethodHandle unreflect(Method m) throws IllegalAccessException {
    // TODO(narayan): Implement this method.
    return null;
}
#method_after
public MethodHandle unreflect(Method m) throws IllegalAccessException {
    // TODO(narayan): Implement this method.
    throw new UnsupportedOperationException("MethodHandles.Lookup.unreflect is not implemented");
}
#end_block

#method_before
public MethodHandle unreflectSpecial(Method m, Class<?> specialCaller) throws IllegalAccessException {
    // TODO(narayan): Implement this method.
    return null;
}
#method_after
public MethodHandle unreflectSpecial(Method m, Class<?> specialCaller) throws IllegalAccessException {
    // TODO(narayan): Implement this method.
    throw new UnsupportedOperationException("MethodHandles.Lookup.unreflectSpecial is not implemented");
}
#end_block

#method_before
public MethodHandle unreflectConstructor(Constructor<?> c) throws IllegalAccessException {
    // TODO(narayan): Implement this method.
    return null;
}
#method_after
public MethodHandle unreflectConstructor(Constructor<?> c) throws IllegalAccessException {
    // TODO(narayan): Implement this method.
    throw new UnsupportedOperationException("MethodHandles.Lookup.unreflectConstructor is not implemented");
}
#end_block

#method_before
public MethodHandle unreflectGetter(Field f) throws IllegalAccessException {
    // TODO(narayan): Implement this method.
    return null;
}
#method_after
public MethodHandle unreflectGetter(Field f) throws IllegalAccessException {
    // TODO(narayan): Implement this method.
    throw new UnsupportedOperationException("MethodHandles.Lookup.unreflectGetter is not implemented");
}
#end_block

#method_before
public MethodHandle unreflectSetter(Field f) throws IllegalAccessException {
    // TODO(narayan): Implement this method.
    return null;
}
#method_after
public MethodHandle unreflectSetter(Field f) throws IllegalAccessException {
    // TODO(narayan): Implement this method.
    throw new UnsupportedOperationException("MethodHandles.Lookup.unreflectSetter is not implemented");
}
#end_block

#method_before
public MethodHandleInfo revealDirect(MethodHandle target) {
    // 
    return null;
}
#method_after
public MethodHandleInfo revealDirect(MethodHandle target) {
    // 
    throw new UnsupportedOperationException("MethodHandles.Lookup.revealDirect is not implemented");
}
#end_block

#method_before
public static IWindowManager getWindowManagerService() {
    synchronized (WindowManagerGlobal.class) {
        if (sWindowManagerService == null) {
            sWindowManagerService = IWindowManager.Stub.asInterface(ServiceManager.getService("window"));
            try {
                sWindowManagerService = getWindowManagerService();
                ValueAnimator.setDurationScale(sWindowManagerService.getCurrentAnimatorScale());
            } catch (RemoteException e) {
                Log.e(TAG, "Failed to get WindowManagerService, cannot set animator scale", e);
            }
        }
        return sWindowManagerService;
    }
}
#method_after
public static IWindowManager getWindowManagerService() {
    synchronized (WindowManagerGlobal.class) {
        if (sWindowManagerService == null) {
            sWindowManagerService = IWindowManager.Stub.asInterface(ServiceManager.getService("window"));
            try {
                sWindowManagerService = getWindowManagerService();
                ValueAnimator.setDurationScale(sWindowManagerService.getCurrentAnimatorScale());
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
        return sWindowManagerService;
    }
}
#end_block

#method_before
public static IWindowSession getWindowSession() {
    synchronized (WindowManagerGlobal.class) {
        if (sWindowSession == null) {
            try {
                InputMethodManager imm = InputMethodManager.getInstance();
                IWindowManager windowManager = getWindowManagerService();
                sWindowSession = windowManager.openSession(new IWindowSessionCallback.Stub() {

                    @Override
                    public void onAnimatorScaleChanged(float scale) {
                        ValueAnimator.setDurationScale(scale);
                    }
                }, imm.getClient(), imm.getInputContext());
            } catch (RemoteException e) {
                Log.e(TAG, "Failed to open window session", e);
            }
        }
        return sWindowSession;
    }
}
#method_after
public static IWindowSession getWindowSession() {
    synchronized (WindowManagerGlobal.class) {
        if (sWindowSession == null) {
            try {
                InputMethodManager imm = InputMethodManager.getInstance();
                IWindowManager windowManager = getWindowManagerService();
                sWindowSession = windowManager.openSession(new IWindowSessionCallback.Stub() {

                    @Override
                    public void onAnimatorScaleChanged(float scale) {
                        ValueAnimator.setDurationScale(scale);
                    }
                }, imm.getClient(), imm.getInputContext());
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
        return sWindowSession;
    }
}
#end_block

#method_before
public void closeAll(IBinder token, String who, String what) {
    synchronized (mLock) {
        int count = mViews.size();
        // Log.i("foo", "Closing all windows of " + token);
        for (int i = 0; i < count; i++) {
            // + " view " + mRoots[i].getView());
            if (token == null || mParams.get(i).token == token) {
                ViewRootImpl root = mRoots.get(i);
                // Log.i("foo", "Force closing " + root);
                if (who != null) {
                    WindowLeaked leak = new WindowLeaked(what + " " + who + " has leaked window " + root.getView() + " that was originally added here");
                    leak.setStackTrace(root.getLocation().getStackTrace());
                    Log.e(TAG, "", leak);
                }
                removeViewLocked(i, false);
            }
        }
    }
}
#method_after
public void closeAll(IBinder token, String who, String what) {
    closeAllExceptView(token, null, /* view */
    who, what);
}
#end_block

#method_before
void doRemoveView(ViewRootImpl root) {
    synchronized (mLock) {
        final int index = mRoots.indexOf(root);
        if (index >= 0) {
            mRoots.remove(index);
            mParams.remove(index);
            final View view = mViews.remove(index);
            mDyingViews.remove(view);
        }
    }
    if (HardwareRenderer.sTrimForeground && HardwareRenderer.isAvailable()) {
        doTrimForeground();
    }
}
#method_after
void doRemoveView(ViewRootImpl root) {
    synchronized (mLock) {
        final int index = mRoots.indexOf(root);
        if (index >= 0) {
            mRoots.remove(index);
            mParams.remove(index);
            final View view = mViews.remove(index);
            mDyingViews.remove(view);
        }
    }
    if (ThreadedRenderer.sTrimForeground && ThreadedRenderer.isAvailable()) {
        doTrimForeground();
    }
}
#end_block

#method_before
public void trimMemory(int level) {
    if (HardwareRenderer.isAvailable()) {
        if (shouldDestroyEglContext(level)) {
            // known windows
            synchronized (mLock) {
                for (int i = mRoots.size() - 1; i >= 0; --i) {
                    mRoots.get(i).destroyHardwareResources();
                }
            }
            // Force a full memory flush
            level = ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
        }
        HardwareRenderer.trimMemory(level);
        if (HardwareRenderer.sTrimForeground) {
            doTrimForeground();
        }
    }
}
#method_after
public void trimMemory(int level) {
    if (ThreadedRenderer.isAvailable()) {
        if (shouldDestroyEglContext(level)) {
            // known windows
            synchronized (mLock) {
                for (int i = mRoots.size() - 1; i >= 0; --i) {
                    mRoots.get(i).destroyHardwareResources();
                }
            }
            // Force a full memory flush
            level = ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
        }
        ThreadedRenderer.trimMemory(level);
        if (ThreadedRenderer.sTrimForeground) {
            doTrimForeground();
        }
    }
}
#end_block

#method_before
public static void trimForeground() {
    if (HardwareRenderer.sTrimForeground && HardwareRenderer.isAvailable()) {
        WindowManagerGlobal wm = WindowManagerGlobal.getInstance();
        wm.doTrimForeground();
    }
}
#method_after
public static void trimForeground() {
    if (ThreadedRenderer.sTrimForeground && ThreadedRenderer.isAvailable()) {
        WindowManagerGlobal wm = WindowManagerGlobal.getInstance();
        wm.doTrimForeground();
    }
}
#end_block

#method_before
private void doTrimForeground() {
    boolean hasVisibleWindows = false;
    synchronized (mLock) {
        for (int i = mRoots.size() - 1; i >= 0; --i) {
            final ViewRootImpl root = mRoots.get(i);
            if (root.mView != null && root.getHostVisibility() == View.VISIBLE && root.mAttachInfo.mHardwareRenderer != null) {
                hasVisibleWindows = true;
            } else {
                root.destroyHardwareResources();
            }
        }
    }
    if (!hasVisibleWindows) {
        HardwareRenderer.trimMemory(ComponentCallbacks2.TRIM_MEMORY_COMPLETE);
    }
}
#method_after
private void doTrimForeground() {
    boolean hasVisibleWindows = false;
    synchronized (mLock) {
        for (int i = mRoots.size() - 1; i >= 0; --i) {
            final ViewRootImpl root = mRoots.get(i);
            if (root.mView != null && root.getHostVisibility() == View.VISIBLE && root.mAttachInfo.mHardwareRenderer != null) {
                hasVisibleWindows = true;
            } else {
                root.destroyHardwareResources();
            }
        }
    }
    if (!hasVisibleWindows) {
        ThreadedRenderer.trimMemory(ComponentCallbacks2.TRIM_MEMORY_COMPLETE);
    }
}
#end_block

#method_before
public void dumpGfxInfo(FileDescriptor fd, String[] args) {
    FileOutputStream fout = new FileOutputStream(fd);
    PrintWriter pw = new FastPrintWriter(fout);
    try {
        synchronized (mLock) {
            final int count = mViews.size();
            pw.println("Profile data in ms:");
            for (int i = 0; i < count; i++) {
                ViewRootImpl root = mRoots.get(i);
                String name = getWindowName(root);
                pw.printf("\n\t%s (visibility=%d)", name, root.getHostVisibility());
                HardwareRenderer renderer = root.getView().mAttachInfo.mHardwareRenderer;
                if (renderer != null) {
                    renderer.dumpGfxInfo(pw, fd, args);
                }
            }
            pw.println("\nView hierarchy:\n");
            int viewsCount = 0;
            int displayListsSize = 0;
            int[] info = new int[2];
            for (int i = 0; i < count; i++) {
                ViewRootImpl root = mRoots.get(i);
                root.dumpGfxInfo(info);
                String name = getWindowName(root);
                pw.printf("  %s\n  %d views, %.2f kB of display lists", name, info[0], info[1] / 1024.0f);
                pw.printf("\n\n");
                viewsCount += info[0];
                displayListsSize += info[1];
            }
            pw.printf("\nTotal ViewRootImpl: %d\n", count);
            pw.printf("Total Views:        %d\n", viewsCount);
            pw.printf("Total DisplayList:  %.2f kB\n\n", displayListsSize / 1024.0f);
        }
    } finally {
        pw.flush();
    }
}
#method_after
public void dumpGfxInfo(FileDescriptor fd, String[] args) {
    FileOutputStream fout = new FileOutputStream(fd);
    PrintWriter pw = new FastPrintWriter(fout);
    try {
        synchronized (mLock) {
            final int count = mViews.size();
            pw.println("Profile data in ms:");
            for (int i = 0; i < count; i++) {
                ViewRootImpl root = mRoots.get(i);
                String name = getWindowName(root);
                pw.printf("\n\t%s (visibility=%d)", name, root.getHostVisibility());
                ThreadedRenderer renderer = root.getView().mAttachInfo.mHardwareRenderer;
                if (renderer != null) {
                    renderer.dumpGfxInfo(pw, fd, args);
                }
            }
            pw.println("\nView hierarchy:\n");
            int viewsCount = 0;
            int displayListsSize = 0;
            int[] info = new int[2];
            for (int i = 0; i < count; i++) {
                ViewRootImpl root = mRoots.get(i);
                root.dumpGfxInfo(info);
                String name = getWindowName(root);
                pw.printf("  %s\n  %d views, %.2f kB of display lists", name, info[0], info[1] / 1024.0f);
                pw.printf("\n\n");
                viewsCount += info[0];
                displayListsSize += info[1];
            }
            pw.printf("\nTotal ViewRootImpl: %d\n", count);
            pw.printf("Total Views:        %d\n", viewsCount);
            pw.printf("Total DisplayList:  %.2f kB\n\n", displayListsSize / 1024.0f);
        }
    } finally {
        pw.flush();
    }
}
#end_block

#method_before
public final void compileAndValidate(@Nonnull CompilationProperties properties, @Nonnull DexValidator<DexFile> validator, @Nonnull String... testPackages) throws Exception {
    assert testPackages.length != 0;
    File[] testFolders = new File[testPackages.length];
    for (int i = 0; i < testPackages.length; i++) {
        testFolders[i] = AbstractTestTools.getTestRootDir(testPackages[i]);
    }
    File outFolder = AbstractTestTools.createTempDir();
    File out = new File(outFolder, DexFileWriter.DEX_FILENAME);
    List<Class<? extends IToolchain>> exclude = new ArrayList<>();
    // Because source path is not supported by the toolchain
    if (!properties.allowJillToolchains) {
        exclude.add(JillBasedToolchain.class);
    }
    JackBasedToolchain toolchain = AbstractTestTools.getCandidateToolchain(JackBasedToolchain.class, exclude);
    for (Map.Entry<String, Object> e : properties.properties.entrySet()) {
        toolchain.addProperty(e.getKey(), e.getValue().toString());
    }
    toolchain.addProperty(Optimizations.REMOVE_UNUSED_NON_SYNTHETIC_DEFINITION.getName(), String.valueOf(false));
    toolchain.addToClasspath(toolchain.getDefaultBootClasspath()).srcToExe(outFolder, /* zipFile = */
    false, testFolders);
    validator.validate(new DexFile(out));
    // Run runtime tests
    RuntimeTestHelper.runOnRuntimeEnvironments(Collections.singletonList(testPackages[0] + ".dx.Tests"), RuntimeTestHelper.getJunitDex(), out);
}
#method_after
public final void compileAndValidate(@Nonnull String testPackage, @Nonnull CompilationProperties properties, @Nonnull DexValidator<DexFile> validator, @Nonnull String... extraPackages) throws Exception {
    File testFolder = new File(AbstractTestTools.getTestRootDir(testPackage), "jack");
    File unitTestFolder = new File(AbstractTestTools.getTestRootDir(testPackage), "dx");
    // Plus testFolder and unitTestFolder.
    File[] allTestFolders = new File[extraPackages.length + 2];
    for (int i = 0; i < extraPackages.length; i++) {
        allTestFolders[i] = AbstractTestTools.getTestRootDir(extraPackages[i]);
    }
    allTestFolders[extraPackages.length] = testFolder;
    allTestFolders[extraPackages.length + 1] = unitTestFolder;
    File outFolder = AbstractTestTools.createTempDir();
    File out = new File(outFolder, DexFileWriter.DEX_FILENAME);
    List<Class<? extends IToolchain>> exclude = new ArrayList<>();
    // Because source path is not supported by the toolchain
    if (!properties.allowJillToolchains) {
        exclude.add(JillBasedToolchain.class);
    }
    JackBasedToolchain toolchain = AbstractTestTools.getCandidateToolchain(JackBasedToolchain.class, exclude);
    for (Map.Entry<String, Object> e : properties.properties.entrySet()) {
        toolchain.addProperty(e.getKey(), e.getValue().toString());
    }
    toolchain.addProperty(Optimizations.REMOVE_UNUSED_NON_SYNTHETIC_DEFINITION.getName(), String.valueOf(false));
    toolchain.addToClasspath(toolchain.getDefaultBootClasspath()).srcToExe(outFolder, /* zipFile = */
    false, allTestFolders);
    validator.validate(new DexFile(out));
    // Run runtime tests
    RuntimeTestHelper.runOnRuntimeEnvironments(Collections.singletonList(testPackage + ".dx.Tests"), RuntimeTestHelper.getJunitDex(), out);
}
#end_block

#method_before
@Override
protected void checkSupportedKeySize(int keyLength) throws InvalidKeyException {
    switch(keyLength) {
        // AES 128
        case 16:
        case // AES 256
        32:
            return;
        default:
            throw new InvalidKeyException("Unsupported key size: " + keyLength + " bytes (must be 16 or 32)");
    }
}
#method_after
@Override
protected void checkSupportedKeySize(int keyLength) throws InvalidKeyException {
    switch(keyLength) {
        // AES 128
        case 16:
        // AES 192
        case 24:
        case // AES 256
        32:
            return;
        default:
            throw new InvalidKeyException("Unsupported key size: " + keyLength + " bytes");
    }
}
#end_block

#method_before
@Override
protected void engineInitInternal(byte[] encodedKey, AlgorithmParameterSpec params, SecureRandom random) throws InvalidKeyException, InvalidAlgorithmParameterException {
    super.engineInitInternal(encodedKey, params, random);
    if (isEncrypting() && iv != null) {
        if (previousKey != null && previousIv != null && arraysAreEqual(previousKey, encodedKey) && arraysAreEqual(previousIv, iv)) {
            throw new InvalidAlgorithmParameterException("In GCM mode key and IV must not be re-used");
        }
        this.previousKey = encodedKey;
        this.previousIv = iv;
    }
    mustInitialize = false;
}
#method_after
@Override
protected void engineInitInternal(byte[] encodedKey, AlgorithmParameterSpec params, SecureRandom random) throws InvalidKeyException, InvalidAlgorithmParameterException {
    super.engineInitInternal(encodedKey, params, random);
    if (isEncrypting() && iv != null) {
        if (previousKey != null && previousIv != null && arraysAreEqual(previousKey, encodedKey) && arraysAreEqual(previousIv, iv)) {
            mustInitialize = true;
            throw new InvalidAlgorithmParameterException("In GCM mode key and IV must not be re-used");
        }
        this.previousKey = encodedKey;
        this.previousIv = iv;
    }
    mustInitialize = false;
}
#end_block

#method_before
@NotNull
public String getKey() {
    return myKey;
}
#method_after
@NotNull
String getKey() {
    return myKey;
}
#end_block

#method_before
public void removeTranslation(@NotNull Locale locale) {
    myLocaleToTranslationMap.remove(locale);
}
#method_after
void removeTranslation(@NotNull Locale locale) {
    myLocaleToTranslationMap.remove(locale);
}
#end_block

#method_before
public void setData(@NotNull StringResourceData data) {
    myData = data;
}
#method_after
public void setData(@NotNull StringResourceData data) {
    myData = data;
    myKeys = data.getKeys();
    myLocales = data.getLocales();
}
#end_block

#method_before
@NotNull
public String keyOfRow(int row) {
    return myData == null ? "" : myData.getKeys().get(row);
}
#method_after
@NotNull
public String keyOfRow(int row) {
    return myKeys == null ? "" : myKeys.get(row);
}
#end_block

#method_before
@Nullable
public Locale localeOfColumn(int column) {
    return (column < ConstantColumn.COUNT || myData == null) ? null : myData.getLocales().get(column - ConstantColumn.COUNT);
}
#method_after
@Nullable
public Locale localeOfColumn(int column) {
    return (column < ConstantColumn.COUNT || myLocales == null) ? null : myLocales.get(column - ConstantColumn.COUNT);
}
#end_block

#method_before
@Override
public int getRowCount() {
    return myData == null ? 0 : myData.getResources().size();
}
#method_after
@Override
public int getRowCount() {
    return myKeys == null ? 0 : myKeys.size();
}
#end_block

#method_before
@Override
public int getColumnCount() {
    return myData == null ? 0 : myData.getLocales().size() + ConstantColumn.COUNT;
}
#method_after
@Override
public int getColumnCount() {
    return myLocales == null ? 0 : myLocales.size() + ConstantColumn.COUNT;
}
#end_block

#method_before
@Override
public void setValueAt(Object value, int row, int column) {
    assert myData != null;
    if (ConstantColumn.KEY.ordinal() == column) {
        myData.changeKeyName(row, (String) value);
        fireTableRowsUpdated(0, myData.getResources().size());
    } else if (ConstantColumn.UNTRANSLATABLE.ordinal() == column) {
        Boolean doNotTranslate = (Boolean) value;
        if (myData.setDoNotTranslate(keyOfRow(row), doNotTranslate)) {
            fireTableCellUpdated(row, column);
        }
    } else {
        if (myData.setTranslation(keyOfRow(row), localeOfColumn(column), (String) value)) {
            fireTableCellUpdated(row, column);
        }
    }
}
#method_after
@Override
public void setValueAt(Object value, int row, int column) {
    assert myData != null && myKeys != null;
    if (ConstantColumn.KEY.ordinal() == column) {
        myData.changeKeyName(myKeys.get(row), (String) value);
        fireTableRowsUpdated(0, myKeys.size());
    } else if (ConstantColumn.UNTRANSLATABLE.ordinal() == column) {
        Boolean doNotTranslate = (Boolean) value;
        if (myData.setTranslatable(keyOfRow(row), !doNotTranslate)) {
            fireTableCellUpdated(row, column);
        }
    } else {
        if (myData.setTranslation(keyOfRow(row), localeOfColumn(column), (String) value)) {
            fireTableCellUpdated(row, column);
        }
    }
}
#end_block

#method_before
@NotNull
@Override
public Object getValueAt(int row, int column) {
    if (myData == null) {
        return "";
    }
    String key = keyOfRow(row);
    if (column >= ConstantColumn.COUNT) {
        Locale locale = localeOfColumn(column);
        return locale == null ? "" : myData.resourceToString(key, locale);
    }
    switch(ConstantColumn.values()[column]) {
        case KEY:
            return key;
        case DEFAULT_VALUE:
            return myData.resourceToString(key);
        case UNTRANSLATABLE:
            return !myData.getResource(key).isTranslatable();
        default:
            return "";
    }
}
#method_after
@NotNull
@Override
public Object getValueAt(int row, int column) {
    if (myData == null) {
        return "";
    }
    String key = keyOfRow(row);
    if (column >= ConstantColumn.COUNT) {
        Locale locale = localeOfColumn(column);
        return locale == null ? "" : myData.getStringResource(key).getTranslationAsString(locale);
    }
    switch(ConstantColumn.values()[column]) {
        case KEY:
            return key;
        case DEFAULT_VALUE:
            return myData.getStringResource(key).getDefaultValueAsString();
        case UNTRANSLATABLE:
            return !myData.getStringResource(key).isTranslatable();
        default:
            return "";
    }
}
#end_block

#method_before
public void changeKeyName(int index, String name) {
    if (index >= myKeys.size()) {
        throw new IllegalArgumentException(String.format("Cannot change key at index %1$d (# of entries: %2$d)", index, myKeys.size()));
    }
    if (myKeys.contains(name)) {
        throw new IllegalArgumentException("Key " + name + " already exists.");
    }
    String currentName = myKeys.get(index);
    myKeys.remove(index);
    myKeys.add(name);
    Collections.sort(myKeys);
    StringResource oldStringResource = myKeyToResourceMap.remove(currentName);
    assert oldStringResource != null;
    StringResource newStringResource = new StringResourceBuilder(oldStringResource).setKey(name).createStringResource();
    myKeyToResourceMap.put(name, newStringResource);
}
#method_after
public void changeKeyName(@NotNull String oldKey, @NotNull String newKey) {
    Set<String> keys = myKeyToResourceMap.keySet();
    if (!keys.contains(oldKey)) {
        throw new IllegalArgumentException("The old key \"" + oldKey + "\" doesn't exist.");
    }
    if (keys.contains(newKey)) {
        throw new IllegalArgumentException("The new key \"" + newKey + "\" already exists.");
    }
    StringResource stringResource = myKeyToResourceMap.remove(oldKey);
    assert stringResource != null;
    stringResource.setKey(newKey);
    myKeyToResourceMap.put(newKey, stringResource);
}
#end_block

#method_before
public boolean setTranslation(@NotNull String key, @Nullable Locale locale, @NotNull String value) {
    StringResource oldStringResource = myKeyToResourceMap.get(key);
    assert oldStringResource != null;
    ResourceItem currentItem = locale == null ? oldStringResource.getDefaultValue() : oldStringResource.getTranslation(locale);
    if (currentItem != null) {
        // modify existing item
        CharSequence oldText = resourceToString(currentItem);
        if (!StringUtil.equals(oldText, value)) {
            boolean changed = StringsWriteUtils.setItemText(myFacet.getModule().getProject(), currentItem, value);
            if (changed && value.isEmpty()) {
                if (locale == null) {
                    StringResource newStringResource = new StringResourceBuilder(oldStringResource).setDefaultValue(null).createStringResource();
                    myKeyToResourceMap.put(newStringResource.getKey(), newStringResource);
                } else {
                    oldStringResource.removeTranslation(locale);
                }
            }
            return changed;
        }
    } else {
        // create new item
        @SuppressWarnings("deprecation")
        VirtualFile primaryResourceDir = myFacet.getPrimaryResourceDir();
        assert primaryResourceDir != null;
        boolean translatable = oldStringResource.isTranslatable();
        ResourceItem item = StringsWriteUtils.createItem(myFacet, primaryResourceDir, locale, key, value, translatable);
        if (item != null) {
            if (locale == null) {
                StringResource newStringResource = new StringResourceBuilder(oldStringResource).setDefaultValue(item).createStringResource();
                myKeyToResourceMap.put(newStringResource.getKey(), newStringResource);
            } else {
                oldStringResource.addTranslation(locale, item);
            }
            return true;
        }
        return false;
    }
    return false;
}
#method_after
public boolean setTranslation(@NotNull String key, @Nullable Locale locale, @NotNull String value) {
    StringResource stringResource = getStringResource(key);
    ResourceItem currentItem = locale == null ? stringResource.getDefaultValueAsResourceItem() : stringResource.getTranslationAsResourceItem(locale);
    if (currentItem != null) {
        // modify existing item
        CharSequence oldText = locale == null ? stringResource.getDefaultValueAsString() : stringResource.getTranslationAsString(locale);
        if (!StringUtil.equals(oldText, value)) {
            boolean changed = StringsWriteUtils.setItemText(myFacet.getModule().getProject(), currentItem, value);
            if (changed) {
                if (value.isEmpty()) {
                    if (locale == null) {
                        stringResource.removeDefaultValue();
                    } else {
                        stringResource.removeTranslation(locale);
                    }
                } else {
                    if (locale == null) {
                        stringResource.setDefaultValue(currentItem, value);
                    } else {
                        stringResource.putTranslation(locale, currentItem, value);
                    }
                }
            }
            return changed;
        }
    } else {
        // create new item
        @SuppressWarnings("deprecation")
        VirtualFile primaryResourceDir = myFacet.getPrimaryResourceDir();
        assert primaryResourceDir != null;
        boolean translatable = stringResource.isTranslatable();
        ResourceItem item = StringsWriteUtils.createItem(myFacet, primaryResourceDir, locale, key, value, translatable);
        if (item != null) {
            if (locale == null) {
                stringResource.setDefaultValue(item, value);
            } else {
                stringResource.putTranslation(locale, item, value);
            }
            return true;
        }
        return false;
    }
    return false;
}
#end_block

#method_before
@Nullable
public String validateKey(@NotNull String key) {
    if (!myKeys.contains(key)) {
        throw new IllegalArgumentException("Key " + key + " does not exist.");
    }
    StringResource stringResource = myKeyToResourceMap.get(key);
    assert stringResource != null;
    if (!stringResource.isTranslatable()) {
        Map<Locale, ResourceItem> translationsForKey = stringResource.getLocaleToTranslationMap();
        if (!translationsForKey.isEmpty()) {
            Set<Locale> localesWithTranslation = translationsForKey.keySet();
            return String.format("Key '%1$s' is marked as non translatable, but is translated in %2$s %3$s", key, StringUtil.pluralize("locale", localesWithTranslation.size()), summarizeLocales(localesWithTranslation));
        }
    } else {
        // translatable key
        if (stringResource.getDefaultValue() == null) {
            return "Key '" + key + "' missing default value";
        }
        Collection<Locale> missingTranslations = getMissingTranslations(key);
        if (!missingTranslations.isEmpty()) {
            return String.format("Key '%1$s' has translations missing for %2$s %3$s", key, StringUtil.pluralize("locale", missingTranslations.size()), summarizeLocales(missingTranslations));
        }
    }
    return null;
}
#method_after
@Nullable
public String validateKey(@NotNull String key) {
    if (!myKeyToResourceMap.keySet().contains(key)) {
        throw new IllegalArgumentException("Key " + key + " does not exist.");
    }
    StringResource stringResource = getStringResource(key);
    if (!stringResource.isTranslatable()) {
        Collection<Locale> localesWithTranslation = stringResource.getTranslatedLocales();
        if (!localesWithTranslation.isEmpty()) {
            return String.format("Key '%1$s' is marked as non translatable, but is translated in %2$s %3$s", key, StringUtil.pluralize("locale", localesWithTranslation.size()), summarizeLocales(localesWithTranslation));
        }
    } else {
        // translatable key
        if (stringResource.getDefaultValueAsResourceItem() == null) {
            return "Key '" + key + "' missing default value";
        }
        Collection<Locale> missingTranslations = getMissingTranslations(key);
        if (!missingTranslations.isEmpty()) {
            return String.format("Key '%1$s' has translations missing for %2$s %3$s", key, StringUtil.pluralize("locale", missingTranslations.size()), summarizeLocales(missingTranslations));
        }
    }
    return null;
}
#end_block

#method_before
@Nullable
public String validateTranslation(@NotNull String key, @Nullable Locale locale) {
    if (!myKeys.contains(key)) {
        throw new IllegalArgumentException("Key " + key + " does not exist.");
    }
    StringResource stringResource = myKeyToResourceMap.get(key);
    assert stringResource != null;
    if (locale == null) {
        ResourceItem item = stringResource.getDefaultValue();
        return (item == null) ? String.format("Key '%1$s' is missing the default value", key) : null;
    }
    final boolean translationMissing = isTranslationMissing(key, locale);
    final boolean doNotTranslate = !stringResource.isTranslatable();
    if (translationMissing && !doNotTranslate) {
        return String.format("Key '%1$s' is missing %2$s translation", key, getLabel(locale));
    } else if (doNotTranslate && !translationMissing) {
        return String.format("Key '%1$s' is marked as non-localizable, and should not be translated to %2$s", key, getLabel(locale));
    }
    return null;
}
#method_after
@Nullable
public String validateTranslation(@NotNull String key, @Nullable Locale locale) {
    if (!myKeyToResourceMap.keySet().contains(key)) {
        throw new IllegalArgumentException("Key " + key + " does not exist.");
    }
    StringResource stringResource = getStringResource(key);
    if (locale == null) {
        ResourceItem item = stringResource.getDefaultValueAsResourceItem();
        return (item == null) ? String.format("Key '%1$s' is missing the default value", key) : null;
    }
    final boolean translationMissing = stringResource.isTranslationMissing(locale);
    final boolean doNotTranslate = !stringResource.isTranslatable();
    if (translationMissing && !doNotTranslate) {
        return String.format("Key '%1$s' is missing %2$s translation", key, getLabel(locale));
    } else if (doNotTranslate && !translationMissing) {
        return String.format("Key '%1$s' is marked as non-localizable, and should not be translated to %2$s", key, getLabel(locale));
    }
    return null;
}
#end_block

#method_before
@NotNull
@VisibleForTesting
Collection<Locale> getMissingTranslations(@NotNull String key) {
    Set<Locale> missingTranslations = Sets.newHashSet();
    for (Locale locale : myLocales) {
        if (isTranslationMissing(key, locale)) {
            missingTranslations.add(locale);
        }
    }
    return missingTranslations;
}
#method_after
@NotNull
@VisibleForTesting
Collection<Locale> getMissingTranslations(@NotNull String key) {
    Set<Locale> missingTranslations = Sets.newHashSet();
    for (Locale locale : getLocales()) {
        StringResource stringResource = getStringResource(key);
        if (stringResource.isTranslationMissing(locale)) {
            missingTranslations.add(locale);
        }
    }
    return missingTranslations;
}
#end_block

#method_before
@NotNull
public List<StringResource> getResources() {
    return Lists.newArrayList(myKeyToResourceMap.values());
}
#method_after
@NotNull
public Collection<StringResource> getResources() {
    return myKeyToResourceMap.values();
}
#end_block

#method_before
@NotNull
public List<String> getKeys() {
    return myKeys;
}
#method_after
@NotNull
public List<String> getKeys() {
    List<String> keys = new ArrayList<>(myKeyToResourceMap.keySet());
    Collections.sort(keys);
    return keys;
}
#end_block

#method_before
@NotNull
public List<Locale> getLocales() {
    return myLocales;
}
#method_after
@NotNull
public List<Locale> getLocales() {
    Set<Locale> locales = new TreeSet<>(Locale.LANGUAGE_CODE_COMPARATOR);
    for (StringResource stringResource : myKeyToResourceMap.values()) {
        locales.addAll(stringResource.getTranslatedLocales());
    }
    return new ArrayList<>(locales);
}
#end_block

#method_before
@NotNull
private static StringResourceData parseUnderReadLock(AndroidFacet facet, LocalResourceRepository repository) {
    List<String> keys = Lists.newArrayList(repository.getItemsOfType(ResourceType.STRING));
    Collections.sort(keys);
    SortedMap<String, StringResource> keyToResourceMap = Maps.newTreeMap();
    Set<Locale> locales = Sets.newTreeSet(Locale.LANGUAGE_CODE_COMPARATOR);
    Project project = facet.getModule().getProject();
    for (String key : keys) {
        List<ResourceItem> items = repository.getResourceItem(ResourceType.STRING, key);
        if (items == null) {
            continue;
        }
        StringResourceBuilder stringResourceBuilder = new StringResourceBuilder();
        SortedMap<Locale, ResourceItem> localeToTranslationMap = Maps.newTreeMap(Locale.LANGUAGE_CODE_COMPARATOR);
        for (ResourceItem item : items) {
            XmlTag tag = LocalResourceRepository.getItemTag(project, item);
            if (tag != null && SdkConstants.VALUE_FALSE.equals(tag.getAttributeValue(SdkConstants.ATTR_TRANSLATABLE))) {
                stringResourceBuilder.setTranslatable(false);
            }
            FolderConfiguration config = item.getConfiguration();
            LocaleQualifier qualifier = config == null ? null : config.getLocaleQualifier();
            if (qualifier == null) {
                stringResourceBuilder.setDefaultValue(item);
            } else {
                Locale locale = Locale.create(qualifier);
                locales.add(locale);
                localeToTranslationMap.put(locale, item);
            }
        }
        StringResource stringResource = stringResourceBuilder.setKey(key).setLocaleToTranslationMap(localeToTranslationMap).createStringResource();
        keyToResourceMap.put(key, stringResource);
    }
    return new StringResourceData(facet, keys, keyToResourceMap, locales);
}
#method_after
@NotNull
private static StringResourceData parseUnderReadLock(AndroidFacet facet, LocalResourceRepository repository) {
    List<String> keys = Lists.newArrayList(repository.getItemsOfType(ResourceType.STRING));
    Collections.sort(keys);
    Map<String, StringResource> keyToResourceMap = new HashMap<>();
    Project project = facet.getModule().getProject();
    for (String key : keys) {
        List<ResourceItem> items = repository.getResourceItem(ResourceType.STRING, key);
        if (items == null) {
            continue;
        }
        StringResource stringResource = new StringResource(key);
        for (ResourceItem item : items) {
            XmlTag tag = LocalResourceRepository.getItemTag(project, item);
            if (tag != null && SdkConstants.VALUE_FALSE.equals(tag.getAttributeValue(SdkConstants.ATTR_TRANSLATABLE))) {
                stringResource.setTranslatable(false);
            }
            String itemStringRepresentation = resourceToString(project, item);
            FolderConfiguration config = item.getConfiguration();
            LocaleQualifier qualifier = config == null ? null : config.getLocaleQualifier();
            if (qualifier == null) {
                stringResource.setDefaultValue(item, itemStringRepresentation);
            } else {
                Locale locale = Locale.create(qualifier);
                stringResource.putTranslation(locale, item, itemStringRepresentation);
            }
        }
        keyToResourceMap.put(key, stringResource);
    }
    return new StringResourceData(facet, keyToResourceMap);
}
#end_block

#method_before
private ActionToolbar createToolbar() {
    DefaultActionGroup group = new DefaultActionGroup();
    final ActionToolbar toolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, group, true);
    final AnAction addKeyAction = new AnAction("Add Key", "", AllIcons.ToolbarDecorator.Add) {

        @Override
        public void update(AnActionEvent e) {
            e.getPresentation().setEnabled(myData != null);
        }

        @Override
        public void actionPerformed(AnActionEvent e) {
            NewStringKeyDialog dialog = new NewStringKeyDialog(myFacet, ImmutableSet.copyOf(myData.getKeys()));
            if (dialog.showAndGet()) {
                StringsWriteUtils.createItem(myFacet, dialog.getResFolder(), null, dialog.getKey(), dialog.getDefaultValue(), true);
                reloadData();
            }
        }
    };
    group.add(addKeyAction);
    final AnAction addLocaleAction = new AnAction("Add Locale", "", AndroidIcons.Globe) {

        @Override
        public void update(AnActionEvent e) {
            e.getPresentation().setEnabled(myData != null);
        }

        @Override
        public void actionPerformed(AnActionEvent e) {
            List<Locale> currentLocales = myData.getLocales();
            List<Locale> missingLocales = LocaleMenuAction.getAllLocales();
            missingLocales.removeAll(currentLocales);
            Collections.sort(missingLocales, Locale.LANGUAGE_NAME_COMPARATOR);
            final JBList list = new JBList(missingLocales);
            list.setFixedCellHeight(20);
            list.setCellRenderer(new ColoredListCellRenderer<Locale>() {

                @Override
                protected void customizeCellRenderer(JList list, Locale value, int index, boolean selected, boolean hasFocus) {
                    append(LocaleMenuAction.getLocaleLabel(value, false));
                    setIcon(value.getFlagImage());
                }
            });
            new ListSpeedSearch(list) {

                @Override
                protected String getElementText(Object element) {
                    if (element instanceof Locale) {
                        return LocaleMenuAction.getLocaleLabel((Locale) element, false);
                    }
                    return super.getElementText(element);
                }
            };
            JBPopupFactory.getInstance().createListPopupBuilder(list).setItemChoosenCallback(new Runnable() {

                @Override
                public void run() {
                    // TODO(juancnuno) Ask the user to pick a source set instead of defaulting to the primary resource directory
                    VirtualFile primaryResourceDir = myFacet.getPrimaryResourceDir();
                    assert primaryResourceDir != null;
                    // Pick a value to add to this locale
                    String key = "app_name";
                    String string = myData.resourceToString(key);
                    StringsWriteUtils.createItem(myFacet, primaryResourceDir, (Locale) list.getSelectedValue(), key, string, true);
                    reloadData();
                }
            }).createPopup().showUnderneathOf(toolbar.getComponent());
        }
    };
    group.add(addLocaleAction);
    group.add(newShowOnlyKeysNeedingTranslationsAction());
    return toolbar;
}
#method_after
private ActionToolbar createToolbar() {
    DefaultActionGroup group = new DefaultActionGroup();
    final ActionToolbar toolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, group, true);
    final AnAction addKeyAction = new AnAction("Add Key", "", AllIcons.ToolbarDecorator.Add) {

        @Override
        public void update(AnActionEvent e) {
            e.getPresentation().setEnabled(myData != null);
        }

        @Override
        public void actionPerformed(AnActionEvent e) {
            NewStringKeyDialog dialog = new NewStringKeyDialog(myFacet, ImmutableSet.copyOf(myData.getKeys()));
            if (dialog.showAndGet()) {
                StringsWriteUtils.createItem(myFacet, dialog.getResFolder(), null, dialog.getKey(), dialog.getDefaultValue(), true);
                reloadData();
            }
        }
    };
    group.add(addKeyAction);
    final AnAction addLocaleAction = new AnAction("Add Locale", "", AndroidIcons.Globe) {

        @Override
        public void update(AnActionEvent e) {
            e.getPresentation().setEnabled(myData != null);
        }

        @Override
        public void actionPerformed(AnActionEvent e) {
            List<Locale> currentLocales = myData.getLocales();
            List<Locale> missingLocales = LocaleMenuAction.getAllLocales();
            missingLocales.removeAll(currentLocales);
            Collections.sort(missingLocales, Locale.LANGUAGE_NAME_COMPARATOR);
            final JBList list = new JBList(missingLocales);
            list.setFixedCellHeight(20);
            list.setCellRenderer(new ColoredListCellRenderer<Locale>() {

                @Override
                protected void customizeCellRenderer(JList list, Locale value, int index, boolean selected, boolean hasFocus) {
                    append(LocaleMenuAction.getLocaleLabel(value, false));
                    setIcon(value.getFlagImage());
                }
            });
            new ListSpeedSearch(list) {

                @Override
                protected String getElementText(Object element) {
                    if (element instanceof Locale) {
                        return LocaleMenuAction.getLocaleLabel((Locale) element, false);
                    }
                    return super.getElementText(element);
                }
            };
            JBPopupFactory.getInstance().createListPopupBuilder(list).setItemChoosenCallback(new Runnable() {

                @Override
                public void run() {
                    // TODO(juancnuno) Ask the user to pick a source set instead of defaulting to the primary resource directory
                    VirtualFile primaryResourceDir = myFacet.getPrimaryResourceDir();
                    assert primaryResourceDir != null;
                    // Pick a value to add to this locale
                    String key = "app_name";
                    String string = myData.getStringResource(key).getDefaultValueAsString();
                    StringsWriteUtils.createItem(myFacet, primaryResourceDir, (Locale) list.getSelectedValue(), key, string, true);
                    reloadData();
                }
            }).createPopup().showUnderneathOf(toolbar.getComponent());
        }
    };
    group.add(addLocaleAction);
    group.add(newShowOnlyKeysNeedingTranslationsAction());
    return toolbar;
}
#end_block

#method_before
private void setUpData() {
    Collection<VirtualFile> resourceDirectories = Collections.singletonList(resourceDirectory);
    ClassField field = Mockito.mock(ClassField.class);
    Mockito.when(field.getType()).thenReturn("string");
    Mockito.when(field.getName()).thenReturn("dynamic_key1");
    Mockito.when(field.getValue()).thenReturn("L\\'Étranger");
    Map<String, ClassField> values = Collections.singletonMap("dynamic_key1", field);
    LocalResourceRepository otherDelegate = DynamicResourceValueRepository.createForTest(myFacet, values);
    Collection<LocalResourceRepository> otherDelegates = Collections.singletonList(otherDelegate);
    data = StringResourceParser.parse(myFacet, ModuleResourceRepository.createForTest(myFacet, resourceDirectories, otherDelegates));
}
#method_after
private void setUpData() {
    Collection<VirtualFile> resourceDirectories = Collections.singletonList(resourceDirectory);
    ClassField field = Mockito.mock(ClassField.class);
    Mockito.when(field.getType()).thenReturn("string");
    Mockito.when(field.getName()).thenReturn("dynamic_key1");
    Mockito.when(field.getValue()).thenReturn("L\\'Étranger");
    Map<String, ClassField> values = Collections.singletonMap("dynamic_key1", field);
    LocalResourceRepository otherDelegate = DynamicResourceValueRepository.createForTest(myFacet, values);
    Disposer.register(myFacet, otherDelegate);
    Collection<LocalResourceRepository> otherDelegates = Collections.singletonList(otherDelegate);
    data = StringResourceParser.parse(myFacet, ModuleResourceRepository.createForTest(myFacet, resourceDirectories, otherDelegates));
}
#end_block

#method_before
public void testParser() {
    Set<String> locales = Sets.newHashSet(Iterables.transform(data.getLocales(), new Function<Locale, String>() {

        @Override
        public String apply(Locale input) {
            return input.toLocaleId();
        }
    }));
    assertSameElements(locales, ImmutableSet.of("en", "en-GB", "en-IN", "fr", "hi"));
    assertNotNull(data.getResource("key1").getDefaultValue());
    assertFalse(data.getResource("key5").isTranslatable());
    assertNull(data.getResource("key1").getLocaleToTranslationMap().get(Locale.create("hi")));
    assertEquals("Key 2 hi", data.resourceToString("key2", Locale.create("hi")));
}
#method_after
public void testParser() {
    Set<String> locales = Sets.newHashSet(Iterables.transform(data.getLocales(), new Function<Locale, String>() {

        @Override
        public String apply(Locale input) {
            return input.toLocaleId();
        }
    }));
    assertSameElements(locales, ImmutableSet.of("en", "en-GB", "en-IN", "fr", "hi"));
    assertNotNull(data.getStringResource("key1").getDefaultValueAsResourceItem());
    assertFalse(data.getStringResource("key5").isTranslatable());
    assertNull(data.getStringResource("key1").getTranslationAsResourceItem(Locale.create("hi")));
    assertEquals("Key 2 hi", data.getStringResource("key2").getTranslationAsString(Locale.create("hi")));
}
#end_block

#method_before
public void testResourceToStringPsi() {
    Locale locale = Locale.create("fr");
    assertEquals("L'Étranger", data.resourceToString("key8", locale));
    assertEquals("<![CDATA[L'Étranger]]>", data.resourceToString("key9", locale));
    assertEquals("<xliff:g>L'Étranger</xliff:g>", data.resourceToString("key10", locale));
}
#method_after
public void testResourceToStringPsi() {
    Locale locale = Locale.create("fr");
    assertEquals("L'Étranger", data.getStringResource("key8").getTranslationAsString(locale));
    assertEquals("<![CDATA[L'Étranger]]>", data.getStringResource("key9").getTranslationAsString(locale));
    assertEquals("<xliff:g>L'Étranger</xliff:g>", data.getStringResource("key10").getTranslationAsString(locale));
}
#end_block

#method_before
public void testResourceToStringDynamic() {
    assertEquals("L'Étranger", data.resourceToString("dynamic_key1"));
}
#method_after
public void testResourceToStringDynamic() {
    assertEquals("L'Étranger", data.getStringResource("dynamic_key1").getDefaultValueAsString());
}
#end_block

#method_before
public void testIsTranslationMissing() {
    assertTrue(data.isTranslationMissing("key7", Locale.create("fr")));
}
#method_after
public void testIsTranslationMissing() {
    assertTrue(data.getStringResource("key7").isTranslationMissing(Locale.create("fr")));
}
#end_block

#method_before
public void testRegionQualifier() {
    Locale en_rGB = Locale.create("en-rGB");
    assertTrue(data.isTranslationMissing("key4", en_rGB));
    assertFalse(data.isTranslationMissing("key3", en_rGB));
    assertFalse(data.isTranslationMissing("key8", en_rGB));
}
#method_after
public void testRegionQualifier() {
    Locale en_rGB = Locale.create("en-rGB");
    assertTrue(data.getStringResource("key4").isTranslationMissing(en_rGB));
    assertFalse(data.getStringResource("key3").isTranslationMissing(en_rGB));
    assertFalse(data.getStringResource("key8").isTranslationMissing(en_rGB));
}
#end_block

#method_before
public void testEditingDoNotTranslate() {
    VirtualFile stringsFile = resourceDirectory.findFileByRelativePath("values/strings.xml");
    assertNotNull(stringsFile);
    assertTrue(data.getResource("key1").isTranslatable());
    XmlTag tag = getNthXmlTag(stringsFile, 0);
    assertEquals("key1", tag.getAttributeValue(SdkConstants.ATTR_NAME));
    assertNull(tag.getAttributeValue(SdkConstants.ATTR_TRANSLATABLE));
    data.setDoNotTranslate("key1", true);
    assertFalse(data.getResource("key1").isTranslatable());
    tag = getNthXmlTag(stringsFile, 0);
    assertEquals(SdkConstants.VALUE_FALSE, tag.getAttributeValue(SdkConstants.ATTR_TRANSLATABLE));
    assertFalse(data.getResource("key5").isTranslatable());
    tag = getNthXmlTag(stringsFile, 3);
    assertEquals("key5", tag.getAttributeValue(SdkConstants.ATTR_NAME));
    assertEquals(SdkConstants.VALUE_FALSE, tag.getAttributeValue(SdkConstants.ATTR_TRANSLATABLE));
    data.setDoNotTranslate("key5", false);
    assertTrue(data.getResource("key5").isTranslatable());
    tag = getNthXmlTag(stringsFile, 3);
    assertNull(tag.getAttributeValue(SdkConstants.ATTR_TRANSLATABLE));
}
#method_after
public void testEditingDoNotTranslate() {
    VirtualFile stringsFile = resourceDirectory.findFileByRelativePath("values/strings.xml");
    assertNotNull(stringsFile);
    assertTrue(data.getStringResource("key1").isTranslatable());
    XmlTag tag = getNthXmlTag(stringsFile, 0);
    assertEquals("key1", tag.getAttributeValue(SdkConstants.ATTR_NAME));
    assertNull(tag.getAttributeValue(SdkConstants.ATTR_TRANSLATABLE));
    data.setTranslatable("key1", false);
    assertFalse(data.getStringResource("key1").isTranslatable());
    tag = getNthXmlTag(stringsFile, 0);
    assertEquals(SdkConstants.VALUE_FALSE, tag.getAttributeValue(SdkConstants.ATTR_TRANSLATABLE));
    assertFalse(data.getStringResource("key5").isTranslatable());
    tag = getNthXmlTag(stringsFile, 3);
    assertEquals("key5", tag.getAttributeValue(SdkConstants.ATTR_NAME));
    assertEquals(SdkConstants.VALUE_FALSE, tag.getAttributeValue(SdkConstants.ATTR_TRANSLATABLE));
    data.setTranslatable("key5", true);
    assertTrue(data.getStringResource("key5").isTranslatable());
    tag = getNthXmlTag(stringsFile, 3);
    assertNull(tag.getAttributeValue(SdkConstants.ATTR_TRANSLATABLE));
}
#end_block

#method_before
public void testEditingCdata() {
    final Locale locale = Locale.create("en-rIN");
    final String key = "key1";
    String currentData = data.resourceToString(key, locale);
    assertEquals("<![CDATA[\n" + "        <b>Google I/O 2014</b><br>\n" + "        Version %s<br><br>\n" + "        <a href=\"http://www.google.com/policies/privacy/\">Privacy Policy</a>\n" + "  ]]>", currentData);
    assertTrue(data.setTranslation(key, locale, currentData.replace("%s", "%1$s")));
    final String expected = "<![CDATA[\n" + "        <b>Google I/O 2014</b><br>\n" + "        Version %1$s<br><br>\n" + "        <a href=\"http://www.google.com/policies/privacy/\">Privacy Policy</a>\n" + "  ]]>";
    assertEquals(expected, data.resourceToString(key, locale));
    VirtualFile file = resourceDirectory.findFileByRelativePath("values-en-rIN/strings.xml");
    assert file != null;
    XmlTag tag = getNthXmlTag(file, 0);
    assertEquals("key1", tag.getAttributeValue(SdkConstants.ATTR_NAME));
    assertEquals(expected, tag.getValue().getText());
}
#method_after
public void testEditingCdata() {
    final Locale locale = Locale.create("en-rIN");
    final String key = "key1";
    String currentData = data.getStringResource(key).getTranslationAsString(locale);
    assertEquals("<![CDATA[\n" + "        <b>Google I/O 2014</b><br>\n" + "        Version %s<br><br>\n" + "        <a href=\"http://www.google.com/policies/privacy/\">Privacy Policy</a>\n" + "  ]]>", currentData);
    assertTrue(data.setTranslation(key, locale, currentData.replace("%s", "%1$s")));
    final String expected = "<![CDATA[\n" + "        <b>Google I/O 2014</b><br>\n" + "        Version %1$s<br><br>\n" + "        <a href=\"http://www.google.com/policies/privacy/\">Privacy Policy</a>\n" + "  ]]>";
    assertEquals(expected, data.getStringResource(key).getTranslationAsString(locale));
    VirtualFile file = resourceDirectory.findFileByRelativePath("values-en-rIN/strings.xml");
    assert file != null;
    XmlTag tag = getNthXmlTag(file, 0);
    assertEquals("key1", tag.getAttributeValue(SdkConstants.ATTR_NAME));
    assertEquals(expected, tag.getValue().getText());
}
#end_block

#method_before
public void testEditingXliff() {
    String key = "key3";
    Locale locale = Locale.create("en-rIN");
    String currentData = data.resourceToString(key, locale);
    assertEquals("start <xliff:g>middle1</xliff:g>%s<xliff:g>middle3</xliff:g> end", currentData);
    assertTrue(data.setTranslation(key, locale, currentData.replace("%s", "%1$s")));
    String expected = "start <xliff:g>middle1</xliff:g>%1$s<xliff:g>middle3</xliff:g> end";
    assertEquals(expected, data.resourceToString(key, locale));
    VirtualFile file = resourceDirectory.findFileByRelativePath("values-en-rIN/strings.xml");
    assert file != null;
    XmlTag tag = getNthXmlTag(file, 2);
    assertEquals("key3", tag.getAttributeValue(SdkConstants.ATTR_NAME));
    assertEquals(expected, tag.getValue().getText().trim());
}
#method_after
public void testEditingXliff() {
    String key = "key3";
    Locale locale = Locale.create("en-rIN");
    String currentData = data.getStringResource(key).getTranslationAsString(locale);
    assertEquals("start <xliff:g>middle1</xliff:g>%s<xliff:g>middle3</xliff:g> end", currentData);
    assertTrue(data.setTranslation(key, locale, currentData.replace("%s", "%1$s")));
    String expected = "start <xliff:g>middle1</xliff:g>%1$s<xliff:g>middle3</xliff:g> end";
    assertEquals(expected, data.getStringResource(key).getTranslationAsString(locale));
    VirtualFile file = resourceDirectory.findFileByRelativePath("values-en-rIN/strings.xml");
    assert file != null;
    XmlTag tag = getNthXmlTag(file, 2);
    assertEquals("key3", tag.getAttributeValue(SdkConstants.ATTR_NAME));
    assertEquals(expected, tag.getValue().getText().trim());
}
#end_block

#method_before
public void testAddingTranslation() {
    final Locale locale = Locale.create("en");
    final String key = "key4";
    assertNull(data.getResource(key).getLocaleToTranslationMap().get(locale));
    assertTrue(data.setTranslation(key, locale, "Hello"));
    VirtualFile file = resourceDirectory.findFileByRelativePath("values-en/strings.xml");
    assert file != null;
    XmlTag tag = getNthXmlTag(file, 4);
    assertEquals("key4", tag.getAttributeValue(SdkConstants.ATTR_NAME));
    assertEquals("Hello", tag.getValue().getText());
    assertEquals("Hello", data.resourceToString(key, locale));
}
#method_after
public void testAddingTranslation() {
    final Locale locale = Locale.create("en");
    final String key = "key4";
    assertNull(data.getStringResource(key).getTranslationAsResourceItem(locale));
    assertTrue(data.setTranslation(key, locale, "Hello"));
    VirtualFile file = resourceDirectory.findFileByRelativePath("values-en/strings.xml");
    assert file != null;
    XmlTag tag = getNthXmlTag(file, 4);
    assertEquals("key4", tag.getAttributeValue(SdkConstants.ATTR_NAME));
    assertEquals("Hello", tag.getValue().getText());
    assertEquals("Hello", data.getStringResource(key).getTranslationAsString(locale));
}
#end_block

#method_before
@Override
public boolean addOneIntentFilterVerification(int verifierUid, int userId, int verificationId, ActivityIntentInfo filter, String packageName) {
    if (!hasValidDomains(filter)) {
        return false;
    }
    IntentFilterVerificationState ivs = mIntentFilterVerificationStates.get(verificationId);
    if (ivs == null) {
        ivs = createDomainVerificationState(verifierUid, userId, verificationId, packageName);
    }
    if (DEBUG_DOMAIN_VERIFICATION) {
        Slog.d(TAG, "Adding verification filter for " + packageName + " : " + filter);
    }
    ivs.addFilter(filter);
    return true;
}
#method_after
@Override
public boolean addOneIntentFilterVerification(int verifierUid, int userId, int verificationId, ActivityIntentInfo filter, String packageName) {
    if (!hasValidDomains(filter)) {
        return false;
    }
    IntentFilterVerificationState ivs = mIntentFilterVerificationStates.get(verificationId);
    if (ivs == null) {
        ivs = createDomainVerificationState(verifierUid, userId, verificationId, packageName);
    }
    if (DEBUG_DOMAIN_VERIFICATION) {
        Slog.d(TAG, "Adding verification filter for " + packageName + ": " + filter);
    }
    ivs.addFilter(filter);
    return true;
}
#end_block

#method_before
private boolean connectToService() {
    if (DEBUG_SD_INSTALL)
        Log.i(TAG, "Trying to bind to" + " DefaultContainerService");
    Intent service = new Intent().setComponent(DEFAULT_CONTAINER_COMPONENT);
    Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
    if (mContext.bindServiceAsUser(service, mDefContainerConn, Context.BIND_AUTO_CREATE, UserHandle.OWNER)) {
        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
        mBound = true;
        return true;
    }
    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
    return false;
}
#method_after
private boolean connectToService() {
    if (DEBUG_SD_INSTALL)
        Log.i(TAG, "Trying to bind to" + " DefaultContainerService");
    Intent service = new Intent().setComponent(DEFAULT_CONTAINER_COMPONENT);
    Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
    if (mContext.bindServiceAsUser(service, mDefContainerConn, Context.BIND_AUTO_CREATE, UserHandle.SYSTEM)) {
        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
        mBound = true;
        return true;
    }
    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
    return false;
}
#end_block

#method_before
void doHandleMessage(Message msg) {
    switch(msg.what) {
        case INIT_COPY:
            {
                HandlerParams params = (HandlerParams) msg.obj;
                int idx = mPendingInstalls.size();
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "init_copy idx=" + idx + ": " + params);
                // will be processed later on.
                if (!mBound) {
                    // have to bind to the service again.
                    if (!connectToService()) {
                        Slog.e(TAG, "Failed to bind to media container service");
                        params.serviceError();
                        return;
                    } else {
                        // Once we bind to the service, the first
                        // pending request will be processed.
                        mPendingInstalls.add(idx, params);
                    }
                } else {
                    mPendingInstalls.add(idx, params);
                    // sure we trigger off processing the first request.
                    if (idx == 0) {
                        mHandler.sendEmptyMessage(MCS_BOUND);
                    }
                }
                break;
            }
        case MCS_BOUND:
            {
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "mcs_bound");
                if (msg.obj != null) {
                    mContainerService = (IMediaContainerService) msg.obj;
                }
                if (mContainerService == null) {
                    if (!mBound) {
                        // Something seriously wrong since we are not bound and we are not
                        // waiting for connection. Bail out.
                        Slog.e(TAG, "Cannot bind to media container service");
                        for (HandlerParams params : mPendingInstalls) {
                            // Indicate service bind error
                            params.serviceError();
                        }
                        mPendingInstalls.clear();
                    } else {
                        Slog.w(TAG, "Waiting to connect to media container service");
                    }
                } else if (mPendingInstalls.size() > 0) {
                    HandlerParams params = mPendingInstalls.get(0);
                    if (params != null) {
                        if (params.startCopy()) {
                            // go idle.
                            if (DEBUG_SD_INSTALL)
                                Log.i(TAG, "Checking for more work or unbind...");
                            // Delete pending install
                            if (mPendingInstalls.size() > 0) {
                                mPendingInstalls.remove(0);
                            }
                            if (mPendingInstalls.size() == 0) {
                                if (mBound) {
                                    if (DEBUG_SD_INSTALL)
                                        Log.i(TAG, "Posting delayed MCS_UNBIND");
                                    removeMessages(MCS_UNBIND);
                                    Message ubmsg = obtainMessage(MCS_UNBIND);
                                    // Unbind after a little delay, to avoid
                                    // continual thrashing.
                                    sendMessageDelayed(ubmsg, 10000);
                                }
                            } else {
                                // of next pending install.
                                if (DEBUG_SD_INSTALL)
                                    Log.i(TAG, "Posting MCS_BOUND for next work");
                                mHandler.sendEmptyMessage(MCS_BOUND);
                            }
                        }
                    }
                } else {
                    // Should never happen ideally.
                    Slog.w(TAG, "Empty queue");
                }
                break;
            }
        case MCS_RECONNECT:
            {
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "mcs_reconnect");
                if (mPendingInstalls.size() > 0) {
                    if (mBound) {
                        disconnectService();
                    }
                    if (!connectToService()) {
                        Slog.e(TAG, "Failed to bind to media container service");
                        for (HandlerParams params : mPendingInstalls) {
                            // Indicate service bind error
                            params.serviceError();
                        }
                        mPendingInstalls.clear();
                    }
                }
                break;
            }
        case MCS_UNBIND:
            {
                // If there is no actual work left, then time to unbind.
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "mcs_unbind");
                if (mPendingInstalls.size() == 0 && mPendingVerification.size() == 0) {
                    if (mBound) {
                        if (DEBUG_INSTALL)
                            Slog.i(TAG, "calling disconnectService()");
                        disconnectService();
                    }
                } else if (mPendingInstalls.size() > 0) {
                    // There are more pending requests in queue.
                    // Just post MCS_BOUND message to trigger processing
                    // of next pending install.
                    mHandler.sendEmptyMessage(MCS_BOUND);
                }
                break;
            }
        case MCS_GIVE_UP:
            {
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "mcs_giveup too many retries");
                mPendingInstalls.remove(0);
                break;
            }
        case SEND_PENDING_BROADCAST:
            {
                String[] packages;
                ArrayList<String>[] components;
                int size = 0;
                int[] uids;
                Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
                synchronized (mPackages) {
                    if (mPendingBroadcasts == null) {
                        return;
                    }
                    size = mPendingBroadcasts.size();
                    if (size <= 0) {
                        // Nothing to be done. Just return
                        return;
                    }
                    packages = new String[size];
                    components = new ArrayList[size];
                    uids = new int[size];
                    // filling out the above arrays
                    int i = 0;
                    for (int n = 0; n < mPendingBroadcasts.userIdCount(); n++) {
                        int packageUserId = mPendingBroadcasts.userIdAt(n);
                        Iterator<Map.Entry<String, ArrayList<String>>> it = mPendingBroadcasts.packagesForUserId(packageUserId).entrySet().iterator();
                        while (it.hasNext() && i < size) {
                            Map.Entry<String, ArrayList<String>> ent = it.next();
                            packages[i] = ent.getKey();
                            components[i] = ent.getValue();
                            PackageSetting ps = mSettings.mPackages.get(ent.getKey());
                            uids[i] = (ps != null) ? UserHandle.getUid(packageUserId, ps.appId) : -1;
                            i++;
                        }
                    }
                    size = i;
                    mPendingBroadcasts.clear();
                }
                // Send broadcasts
                for (int i = 0; i < size; i++) {
                    sendPackageChangedBroadcast(packages[i], true, components[i], uids[i]);
                }
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                break;
            }
        case START_CLEANING_PACKAGE:
            {
                Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
                final String packageName = (String) msg.obj;
                final int userId = msg.arg1;
                final boolean andCode = msg.arg2 != 0;
                synchronized (mPackages) {
                    if (userId == UserHandle.USER_ALL) {
                        int[] users = sUserManager.getUserIds();
                        for (int user : users) {
                            mSettings.addPackageToCleanLPw(new PackageCleanItem(user, packageName, andCode));
                        }
                    } else {
                        mSettings.addPackageToCleanLPw(new PackageCleanItem(userId, packageName, andCode));
                    }
                }
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                startCleaningPackages();
            }
            break;
        case POST_INSTALL:
            {
                if (DEBUG_INSTALL)
                    Log.v(TAG, "Handling post-install for " + msg.arg1);
                PostInstallData data = mRunningInstalls.get(msg.arg1);
                mRunningInstalls.delete(msg.arg1);
                boolean deleteOld = false;
                if (data != null) {
                    InstallArgs args = data.args;
                    PackageInstalledInfo res = data.res;
                    if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
                        final String packageName = res.pkg.applicationInfo.packageName;
                        res.removedInfo.sendBroadcast(false, true, false);
                        Bundle extras = new Bundle(1);
                        extras.putInt(Intent.EXTRA_UID, res.uid);
                        // permissions if requested before broadcasting the install.
                        if ((args.installFlags & PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0) {
                            grantRequestedRuntimePermissions(res.pkg, args.user.getIdentifier(), args.installGrantPermissions);
                        }
                        // Determine the set of users who are adding this
                        // package for the first time vs. those who are seeing
                        // an update.
                        int[] firstUsers;
                        int[] updateUsers = new int[0];
                        if (res.origUsers == null || res.origUsers.length == 0) {
                            firstUsers = res.newUsers;
                        } else {
                            firstUsers = new int[0];
                            for (int i = 0; i < res.newUsers.length; i++) {
                                int user = res.newUsers[i];
                                boolean isNew = true;
                                for (int j = 0; j < res.origUsers.length; j++) {
                                    if (res.origUsers[j] == user) {
                                        isNew = false;
                                        break;
                                    }
                                }
                                if (isNew) {
                                    int[] newFirst = new int[firstUsers.length + 1];
                                    System.arraycopy(firstUsers, 0, newFirst, 0, firstUsers.length);
                                    newFirst[firstUsers.length] = user;
                                    firstUsers = newFirst;
                                } else {
                                    int[] newUpdate = new int[updateUsers.length + 1];
                                    System.arraycopy(updateUsers, 0, newUpdate, 0, updateUsers.length);
                                    newUpdate[updateUsers.length] = user;
                                    updateUsers = newUpdate;
                                }
                            }
                        }
                        sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, packageName, extras, null, null, firstUsers);
                        final boolean update = res.removedInfo.removedPackage != null;
                        if (update) {
                            extras.putBoolean(Intent.EXTRA_REPLACING, true);
                        }
                        sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, packageName, extras, null, null, updateUsers);
                        if (update) {
                            sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED, packageName, extras, null, null, updateUsers);
                            sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED, null, null, packageName, null, updateUsers);
                            // treat asec-hosted packages like removable media on upgrade
                            if (res.pkg.isForwardLocked() || isExternal(res.pkg)) {
                                if (DEBUG_INSTALL) {
                                    Slog.i(TAG, "upgrading pkg " + res.pkg + " is ASEC-hosted -> AVAILABLE");
                                }
                                int[] uidArray = new int[] { res.pkg.applicationInfo.uid };
                                ArrayList<String> pkgList = new ArrayList<String>(1);
                                pkgList.add(packageName);
                                sendResourcesChangedBroadcast(true, true, pkgList, uidArray, null);
                            }
                        }
                        if (res.removedInfo.args != null) {
                            // Remove the replaced package's older resources safely now
                            deleteOld = true;
                        }
                        // users, clear any default-browser state in those users
                        if (firstUsers.length > 0) {
                            // check its browser nature in any user and generalize.
                            if (packageIsBrowser(packageName, firstUsers[0])) {
                                synchronized (mPackages) {
                                    for (int userId : firstUsers) {
                                        mSettings.setDefaultBrowserPackageNameLPw(null, userId);
                                    }
                                }
                            }
                        }
                        // Log current value of "unknown sources" setting
                        EventLog.writeEvent(EventLogTags.UNKNOWN_SOURCES_ENABLED, getUnknownSourcesSettings());
                    }
                    // Force a gc to clear up things
                    Runtime.getRuntime().gc();
                    // We delete after a gc for applications  on sdcard.
                    if (deleteOld) {
                        synchronized (mInstallLock) {
                            res.removedInfo.args.doPostDeleteLI(true);
                        }
                    }
                    if (args.observer != null) {
                        try {
                            Bundle extras = extrasForInstallResult(res);
                            args.observer.onPackageInstalled(res.name, res.returnCode, res.returnMsg, extras);
                        } catch (RemoteException e) {
                            Slog.i(TAG, "Observer no longer exists.");
                        }
                    }
                } else {
                    Slog.e(TAG, "Bogus post-install token " + msg.arg1);
                }
            }
            break;
        case UPDATED_MEDIA_STATUS:
            {
                if (DEBUG_SD_INSTALL)
                    Log.i(TAG, "Got message UPDATED_MEDIA_STATUS");
                boolean reportStatus = msg.arg1 == 1;
                boolean doGc = msg.arg2 == 1;
                if (DEBUG_SD_INSTALL)
                    Log.i(TAG, "reportStatus=" + reportStatus + ", doGc = " + doGc);
                if (doGc) {
                    // Force a gc to clear up stale containers.
                    Runtime.getRuntime().gc();
                }
                if (msg.obj != null) {
                    @SuppressWarnings("unchecked")
                    Set<AsecInstallArgs> args = (Set<AsecInstallArgs>) msg.obj;
                    if (DEBUG_SD_INSTALL)
                        Log.i(TAG, "Unloading all containers");
                    // Unload containers
                    unloadAllContainers(args);
                }
                if (reportStatus) {
                    try {
                        if (DEBUG_SD_INSTALL)
                            Log.i(TAG, "Invoking MountService call back");
                        PackageHelper.getMountService().finishMediaUpdate();
                    } catch (RemoteException e) {
                        Log.e(TAG, "MountService not running?");
                    }
                }
            }
            break;
        case WRITE_SETTINGS:
            {
                Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
                synchronized (mPackages) {
                    removeMessages(WRITE_SETTINGS);
                    removeMessages(WRITE_PACKAGE_RESTRICTIONS);
                    mSettings.writeLPr();
                    mDirtyUsers.clear();
                }
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
            }
            break;
        case WRITE_PACKAGE_RESTRICTIONS:
            {
                Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
                synchronized (mPackages) {
                    removeMessages(WRITE_PACKAGE_RESTRICTIONS);
                    for (int userId : mDirtyUsers) {
                        mSettings.writePackageRestrictionsLPr(userId);
                    }
                    mDirtyUsers.clear();
                }
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
            }
            break;
        case CHECK_PENDING_VERIFICATION:
            {
                final int verificationId = msg.arg1;
                final PackageVerificationState state = mPendingVerification.get(verificationId);
                if ((state != null) && !state.timeoutExtended()) {
                    final InstallArgs args = state.getInstallArgs();
                    final Uri originUri = Uri.fromFile(args.origin.resolvedFile);
                    Slog.i(TAG, "Verification timed out for " + originUri);
                    mPendingVerification.remove(verificationId);
                    int ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
                    if (getDefaultVerificationResponse() == PackageManager.VERIFICATION_ALLOW) {
                        Slog.i(TAG, "Continuing with installation of " + originUri);
                        state.setVerifierResponse(Binder.getCallingUid(), PackageManager.VERIFICATION_ALLOW_WITHOUT_SUFFICIENT);
                        broadcastPackageVerified(verificationId, originUri, PackageManager.VERIFICATION_ALLOW, state.getInstallArgs().getUser());
                        try {
                            ret = args.copyApk(mContainerService, true);
                        } catch (RemoteException e) {
                            Slog.e(TAG, "Could not contact the ContainerService");
                        }
                    } else {
                        broadcastPackageVerified(verificationId, originUri, PackageManager.VERIFICATION_REJECT, state.getInstallArgs().getUser());
                    }
                    processPendingInstall(args, ret);
                    mHandler.sendEmptyMessage(MCS_UNBIND);
                }
                break;
            }
        case PACKAGE_VERIFIED:
            {
                final int verificationId = msg.arg1;
                final PackageVerificationState state = mPendingVerification.get(verificationId);
                if (state == null) {
                    Slog.w(TAG, "Invalid verification token " + verificationId + " received");
                    break;
                }
                final PackageVerificationResponse response = (PackageVerificationResponse) msg.obj;
                state.setVerifierResponse(response.callerUid, response.code);
                if (state.isVerificationComplete()) {
                    mPendingVerification.remove(verificationId);
                    final InstallArgs args = state.getInstallArgs();
                    final Uri originUri = Uri.fromFile(args.origin.resolvedFile);
                    int ret;
                    if (state.isInstallAllowed()) {
                        ret = PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
                        broadcastPackageVerified(verificationId, originUri, response.code, state.getInstallArgs().getUser());
                        try {
                            ret = args.copyApk(mContainerService, true);
                        } catch (RemoteException e) {
                            Slog.e(TAG, "Could not contact the ContainerService");
                        }
                    } else {
                        ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
                    }
                    processPendingInstall(args, ret);
                    mHandler.sendEmptyMessage(MCS_UNBIND);
                }
                break;
            }
        case START_INTENT_FILTER_VERIFICATIONS:
            {
                IFVerificationParams params = (IFVerificationParams) msg.obj;
                verifyIntentFiltersIfNeeded(params.userId, params.verifierUid, params.replacing, params.pkg);
                break;
            }
        case INTENT_FILTER_VERIFIED:
            {
                final int verificationId = msg.arg1;
                final IntentFilterVerificationState state = mIntentFilterVerificationStates.get(verificationId);
                if (state == null) {
                    Slog.w(TAG, "Invalid IntentFilter verification token " + verificationId + " received");
                    break;
                }
                final int userId = state.getUserId();
                if (DEBUG_DOMAIN_VERIFICATION)
                    Slog.d(TAG, "Processing IntentFilter verification with token:" + verificationId + " and userId:" + userId);
                final IntentFilterVerificationResponse response = (IntentFilterVerificationResponse) msg.obj;
                state.setVerifierResponse(response.callerUid, response.code);
                if (DEBUG_DOMAIN_VERIFICATION)
                    Slog.d(TAG, "IntentFilter verification with token:" + verificationId + " and userId:" + userId + " is settings verifier response with response code:" + response.code);
                if (response.code == PackageManager.INTENT_FILTER_VERIFICATION_FAILURE) {
                    if (DEBUG_DOMAIN_VERIFICATION)
                        Slog.d(TAG, "Domains failing verification: " + response.getFailedDomainsString());
                }
                if (state.isVerificationComplete()) {
                    mIntentFilterVerifier.receiveVerificationResponse(verificationId);
                } else {
                    if (DEBUG_DOMAIN_VERIFICATION)
                        Slog.d(TAG, "IntentFilter verification with token:" + verificationId + " was not said to be complete");
                }
                break;
            }
    }
}
#method_after
void doHandleMessage(Message msg) {
    switch(msg.what) {
        case INIT_COPY:
            {
                HandlerParams params = (HandlerParams) msg.obj;
                int idx = mPendingInstalls.size();
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "init_copy idx=" + idx + ": " + params);
                // will be processed later on.
                if (!mBound) {
                    Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, "bindingMCS", System.identityHashCode(mHandler));
                    // have to bind to the service again.
                    if (!connectToService()) {
                        Slog.e(TAG, "Failed to bind to media container service");
                        params.serviceError();
                        Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, "bindingMCS", System.identityHashCode(mHandler));
                        if (params.traceMethod != null) {
                            Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, params.traceMethod, params.traceCookie);
                        }
                        return;
                    } else {
                        // Once we bind to the service, the first
                        // pending request will be processed.
                        mPendingInstalls.add(idx, params);
                    }
                } else {
                    mPendingInstalls.add(idx, params);
                    // sure we trigger off processing the first request.
                    if (idx == 0) {
                        mHandler.sendEmptyMessage(MCS_BOUND);
                    }
                }
                break;
            }
        case MCS_BOUND:
            {
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "mcs_bound");
                if (msg.obj != null) {
                    mContainerService = (IMediaContainerService) msg.obj;
                    Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, "bindingMCS", System.identityHashCode(mHandler));
                }
                if (mContainerService == null) {
                    if (!mBound) {
                        // Something seriously wrong since we are not bound and we are not
                        // waiting for connection. Bail out.
                        Slog.e(TAG, "Cannot bind to media container service");
                        for (HandlerParams params : mPendingInstalls) {
                            // Indicate service bind error
                            params.serviceError();
                            Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, "queueInstall", System.identityHashCode(params));
                            if (params.traceMethod != null) {
                                Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, params.traceMethod, params.traceCookie);
                            }
                            return;
                        }
                        mPendingInstalls.clear();
                    } else {
                        Slog.w(TAG, "Waiting to connect to media container service");
                    }
                } else if (mPendingInstalls.size() > 0) {
                    HandlerParams params = mPendingInstalls.get(0);
                    if (params != null) {
                        Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, "queueInstall", System.identityHashCode(params));
                        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "startCopy");
                        if (params.startCopy()) {
                            // go idle.
                            if (DEBUG_SD_INSTALL)
                                Log.i(TAG, "Checking for more work or unbind...");
                            // Delete pending install
                            if (mPendingInstalls.size() > 0) {
                                mPendingInstalls.remove(0);
                            }
                            if (mPendingInstalls.size() == 0) {
                                if (mBound) {
                                    if (DEBUG_SD_INSTALL)
                                        Log.i(TAG, "Posting delayed MCS_UNBIND");
                                    removeMessages(MCS_UNBIND);
                                    Message ubmsg = obtainMessage(MCS_UNBIND);
                                    // Unbind after a little delay, to avoid
                                    // continual thrashing.
                                    sendMessageDelayed(ubmsg, 10000);
                                }
                            } else {
                                // of next pending install.
                                if (DEBUG_SD_INSTALL)
                                    Log.i(TAG, "Posting MCS_BOUND for next work");
                                mHandler.sendEmptyMessage(MCS_BOUND);
                            }
                        }
                        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
                    }
                } else {
                    // Should never happen ideally.
                    Slog.w(TAG, "Empty queue");
                }
                break;
            }
        case MCS_RECONNECT:
            {
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "mcs_reconnect");
                if (mPendingInstalls.size() > 0) {
                    if (mBound) {
                        disconnectService();
                    }
                    if (!connectToService()) {
                        Slog.e(TAG, "Failed to bind to media container service");
                        for (HandlerParams params : mPendingInstalls) {
                            // Indicate service bind error
                            params.serviceError();
                            Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, "queueInstall", System.identityHashCode(params));
                        }
                        mPendingInstalls.clear();
                    }
                }
                break;
            }
        case MCS_UNBIND:
            {
                // If there is no actual work left, then time to unbind.
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "mcs_unbind");
                if (mPendingInstalls.size() == 0 && mPendingVerification.size() == 0) {
                    if (mBound) {
                        if (DEBUG_INSTALL)
                            Slog.i(TAG, "calling disconnectService()");
                        disconnectService();
                    }
                } else if (mPendingInstalls.size() > 0) {
                    // There are more pending requests in queue.
                    // Just post MCS_BOUND message to trigger processing
                    // of next pending install.
                    mHandler.sendEmptyMessage(MCS_BOUND);
                }
                break;
            }
        case MCS_GIVE_UP:
            {
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "mcs_giveup too many retries");
                HandlerParams params = mPendingInstalls.remove(0);
                Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, "queueInstall", System.identityHashCode(params));
                break;
            }
        case SEND_PENDING_BROADCAST:
            {
                String[] packages;
                ArrayList<String>[] components;
                int size = 0;
                int[] uids;
                Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
                synchronized (mPackages) {
                    if (mPendingBroadcasts == null) {
                        return;
                    }
                    size = mPendingBroadcasts.size();
                    if (size <= 0) {
                        // Nothing to be done. Just return
                        return;
                    }
                    packages = new String[size];
                    components = new ArrayList[size];
                    uids = new int[size];
                    // filling out the above arrays
                    int i = 0;
                    for (int n = 0; n < mPendingBroadcasts.userIdCount(); n++) {
                        int packageUserId = mPendingBroadcasts.userIdAt(n);
                        Iterator<Map.Entry<String, ArrayList<String>>> it = mPendingBroadcasts.packagesForUserId(packageUserId).entrySet().iterator();
                        while (it.hasNext() && i < size) {
                            Map.Entry<String, ArrayList<String>> ent = it.next();
                            packages[i] = ent.getKey();
                            components[i] = ent.getValue();
                            PackageSetting ps = mSettings.mPackages.get(ent.getKey());
                            uids[i] = (ps != null) ? UserHandle.getUid(packageUserId, ps.appId) : -1;
                            i++;
                        }
                    }
                    size = i;
                    mPendingBroadcasts.clear();
                }
                // Send broadcasts
                for (int i = 0; i < size; i++) {
                    sendPackageChangedBroadcast(packages[i], true, components[i], uids[i]);
                }
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                break;
            }
        case START_CLEANING_PACKAGE:
            {
                Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
                final String packageName = (String) msg.obj;
                final int userId = msg.arg1;
                final boolean andCode = msg.arg2 != 0;
                synchronized (mPackages) {
                    if (userId == UserHandle.USER_ALL) {
                        int[] users = sUserManager.getUserIds();
                        for (int user : users) {
                            mSettings.addPackageToCleanLPw(new PackageCleanItem(user, packageName, andCode));
                        }
                    } else {
                        mSettings.addPackageToCleanLPw(new PackageCleanItem(userId, packageName, andCode));
                    }
                }
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                startCleaningPackages();
            }
            break;
        case POST_INSTALL:
            {
                if (DEBUG_INSTALL)
                    Log.v(TAG, "Handling post-install for " + msg.arg1);
                PostInstallData data = mRunningInstalls.get(msg.arg1);
                final boolean didRestore = (msg.arg2 != 0);
                mRunningInstalls.delete(msg.arg1);
                if (data != null) {
                    InstallArgs args = data.args;
                    PackageInstalledInfo parentRes = data.res;
                    final boolean grantPermissions = (args.installFlags & PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0;
                    final boolean killApp = (args.installFlags & PackageManager.INSTALL_DONT_KILL_APP) == 0;
                    final String[] grantedPermissions = args.installGrantPermissions;
                    // Handle the parent package
                    handlePackagePostInstall(parentRes, grantPermissions, killApp, grantedPermissions, didRestore, args.installerPackageName, args.observer);
                    // Handle the child packages
                    final int childCount = (parentRes.addedChildPackages != null) ? parentRes.addedChildPackages.size() : 0;
                    for (int i = 0; i < childCount; i++) {
                        PackageInstalledInfo childRes = parentRes.addedChildPackages.valueAt(i);
                        handlePackagePostInstall(childRes, grantPermissions, killApp, grantedPermissions, false, args.installerPackageName, args.observer);
                    }
                    // Log tracing if needed
                    if (args.traceMethod != null) {
                        Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, args.traceMethod, args.traceCookie);
                    }
                } else {
                    Slog.e(TAG, "Bogus post-install token " + msg.arg1);
                }
                Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, "postInstall", msg.arg1);
            }
            break;
        case UPDATED_MEDIA_STATUS:
            {
                if (DEBUG_SD_INSTALL)
                    Log.i(TAG, "Got message UPDATED_MEDIA_STATUS");
                boolean reportStatus = msg.arg1 == 1;
                boolean doGc = msg.arg2 == 1;
                if (DEBUG_SD_INSTALL)
                    Log.i(TAG, "reportStatus=" + reportStatus + ", doGc = " + doGc);
                if (doGc) {
                    // Force a gc to clear up stale containers.
                    Runtime.getRuntime().gc();
                }
                if (msg.obj != null) {
                    @SuppressWarnings("unchecked")
                    Set<AsecInstallArgs> args = (Set<AsecInstallArgs>) msg.obj;
                    if (DEBUG_SD_INSTALL)
                        Log.i(TAG, "Unloading all containers");
                    // Unload containers
                    unloadAllContainers(args);
                }
                if (reportStatus) {
                    try {
                        if (DEBUG_SD_INSTALL)
                            Log.i(TAG, "Invoking MountService call back");
                        PackageHelper.getMountService().finishMediaUpdate();
                    } catch (RemoteException e) {
                        Log.e(TAG, "MountService not running?");
                    }
                }
            }
            break;
        case WRITE_SETTINGS:
            {
                Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
                synchronized (mPackages) {
                    removeMessages(WRITE_SETTINGS);
                    removeMessages(WRITE_PACKAGE_RESTRICTIONS);
                    mSettings.writeLPr();
                    mDirtyUsers.clear();
                }
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
            }
            break;
        case WRITE_PACKAGE_RESTRICTIONS:
            {
                Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
                synchronized (mPackages) {
                    removeMessages(WRITE_PACKAGE_RESTRICTIONS);
                    for (int userId : mDirtyUsers) {
                        mSettings.writePackageRestrictionsLPr(userId);
                    }
                    mDirtyUsers.clear();
                }
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
            }
            break;
        case WRITE_PACKAGE_LIST:
            {
                Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
                synchronized (mPackages) {
                    removeMessages(WRITE_PACKAGE_LIST);
                    mSettings.writePackageListLPr(msg.arg1);
                }
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
            }
            break;
        case CHECK_PENDING_VERIFICATION:
            {
                final int verificationId = msg.arg1;
                final PackageVerificationState state = mPendingVerification.get(verificationId);
                if ((state != null) && !state.timeoutExtended()) {
                    final InstallArgs args = state.getInstallArgs();
                    final Uri originUri = Uri.fromFile(args.origin.resolvedFile);
                    Slog.i(TAG, "Verification timed out for " + originUri);
                    mPendingVerification.remove(verificationId);
                    int ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
                    if (getDefaultVerificationResponse() == PackageManager.VERIFICATION_ALLOW) {
                        Slog.i(TAG, "Continuing with installation of " + originUri);
                        state.setVerifierResponse(Binder.getCallingUid(), PackageManager.VERIFICATION_ALLOW_WITHOUT_SUFFICIENT);
                        broadcastPackageVerified(verificationId, originUri, PackageManager.VERIFICATION_ALLOW, state.getInstallArgs().getUser());
                        try {
                            ret = args.copyApk(mContainerService, true);
                        } catch (RemoteException e) {
                            Slog.e(TAG, "Could not contact the ContainerService");
                        }
                    } else {
                        broadcastPackageVerified(verificationId, originUri, PackageManager.VERIFICATION_REJECT, state.getInstallArgs().getUser());
                    }
                    Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, "verification", verificationId);
                    processPendingInstall(args, ret);
                    mHandler.sendEmptyMessage(MCS_UNBIND);
                }
                break;
            }
        case PACKAGE_VERIFIED:
            {
                final int verificationId = msg.arg1;
                final PackageVerificationState state = mPendingVerification.get(verificationId);
                if (state == null) {
                    Slog.w(TAG, "Invalid verification token " + verificationId + " received");
                    break;
                }
                final PackageVerificationResponse response = (PackageVerificationResponse) msg.obj;
                state.setVerifierResponse(response.callerUid, response.code);
                if (state.isVerificationComplete()) {
                    mPendingVerification.remove(verificationId);
                    final InstallArgs args = state.getInstallArgs();
                    final Uri originUri = Uri.fromFile(args.origin.resolvedFile);
                    int ret;
                    if (state.isInstallAllowed()) {
                        ret = PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
                        broadcastPackageVerified(verificationId, originUri, response.code, state.getInstallArgs().getUser());
                        try {
                            ret = args.copyApk(mContainerService, true);
                        } catch (RemoteException e) {
                            Slog.e(TAG, "Could not contact the ContainerService");
                        }
                    } else {
                        ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
                    }
                    Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, "verification", verificationId);
                    processPendingInstall(args, ret);
                    mHandler.sendEmptyMessage(MCS_UNBIND);
                }
                break;
            }
        case START_INTENT_FILTER_VERIFICATIONS:
            {
                IFVerificationParams params = (IFVerificationParams) msg.obj;
                verifyIntentFiltersIfNeeded(params.userId, params.verifierUid, params.replacing, params.pkg);
                break;
            }
        case INTENT_FILTER_VERIFIED:
            {
                final int verificationId = msg.arg1;
                final IntentFilterVerificationState state = mIntentFilterVerificationStates.get(verificationId);
                if (state == null) {
                    Slog.w(TAG, "Invalid IntentFilter verification token " + verificationId + " received");
                    break;
                }
                final int userId = state.getUserId();
                if (DEBUG_DOMAIN_VERIFICATION)
                    Slog.d(TAG, "Processing IntentFilter verification with token:" + verificationId + " and userId:" + userId);
                final IntentFilterVerificationResponse response = (IntentFilterVerificationResponse) msg.obj;
                state.setVerifierResponse(response.callerUid, response.code);
                if (DEBUG_DOMAIN_VERIFICATION)
                    Slog.d(TAG, "IntentFilter verification with token:" + verificationId + " and userId:" + userId + " is settings verifier response with response code:" + response.code);
                if (response.code == PackageManager.INTENT_FILTER_VERIFICATION_FAILURE) {
                    if (DEBUG_DOMAIN_VERIFICATION)
                        Slog.d(TAG, "Domains failing verification: " + response.getFailedDomainsString());
                }
                if (state.isVerificationComplete()) {
                    mIntentFilterVerifier.receiveVerificationResponse(verificationId);
                } else {
                    if (DEBUG_DOMAIN_VERIFICATION)
                        Slog.d(TAG, "IntentFilter verification with token:" + verificationId + " was not said to be complete");
                }
                break;
            }
    }
}
#end_block

#method_before
private void grantRequestedRuntimePermissions(PackageParser.Package pkg, int userId, String[] grantedPermissions) {
    if (userId >= UserHandle.USER_OWNER) {
        grantRequestedRuntimePermissionsForUser(pkg, userId, grantedPermissions);
    } else if (userId == UserHandle.USER_ALL) {
        final int[] userIds;
        synchronized (mPackages) {
            userIds = UserManagerService.getInstance().getUserIds();
        }
        for (int someUserId : userIds) {
            grantRequestedRuntimePermissionsForUser(pkg, someUserId, grantedPermissions);
        }
    }
    // We could have touched GID membership, so flush out packages.list
    synchronized (mPackages) {
        mSettings.writePackageListLPr();
    }
}
#method_after
private void grantRequestedRuntimePermissions(PackageParser.Package pkg, int[] userIds, String[] grantedPermissions) {
    for (int userId : userIds) {
        grantRequestedRuntimePermissionsForUser(pkg, userId, grantedPermissions);
    }
    // We could have touched GID membership, so flush out packages.list
    synchronized (mPackages) {
        mSettings.writePackageListLPr();
    }
}
#end_block

#method_before
private void grantRequestedRuntimePermissionsForUser(PackageParser.Package pkg, int userId, String[] grantedPermissions) {
    SettingBase sb = (SettingBase) pkg.mExtras;
    if (sb == null) {
        return;
    }
    synchronized (mPackages) {
        for (String permission : pkg.requestedPermissions) {
            BasePermission bp = mSettings.mPermissions.get(permission);
            if (bp != null && (bp.isRuntime() || bp.isDevelopment()) && (grantedPermissions == null || ArrayUtils.contains(grantedPermissions, permission)) && (getPermissionFlags(permission, pkg.packageName, userId) & PackageManager.FLAG_PERMISSION_SYSTEM_FIXED) == 0) {
                grantRuntimePermission(pkg.packageName, permission, userId);
            }
        }
    }
}
#method_after
private void grantRequestedRuntimePermissionsForUser(PackageParser.Package pkg, int userId, String[] grantedPermissions) {
    SettingBase sb = (SettingBase) pkg.mExtras;
    if (sb == null) {
        return;
    }
    PermissionsState permissionsState = sb.getPermissionsState();
    final int immutableFlags = PackageManager.FLAG_PERMISSION_SYSTEM_FIXED | PackageManager.FLAG_PERMISSION_POLICY_FIXED;
    for (String permission : pkg.requestedPermissions) {
        final BasePermission bp;
        synchronized (mPackages) {
            bp = mSettings.mPermissions.get(permission);
        }
        if (bp != null && (bp.isRuntime() || bp.isDevelopment()) && (grantedPermissions == null || ArrayUtils.contains(grantedPermissions, permission))) {
            final int flags = permissionsState.getPermissionFlags(permission, userId);
            // Installer cannot change immutable permissions.
            if ((flags & immutableFlags) == 0) {
                grantRuntimePermission(pkg.packageName, permission, userId);
            }
        }
    }
}
#end_block

#method_before
void scheduleWritePackageRestrictionsLocked(int userId) {
    if (!sUserManager.exists(userId))
        return;
    mDirtyUsers.add(userId);
    if (!mHandler.hasMessages(WRITE_PACKAGE_RESTRICTIONS)) {
        mHandler.sendEmptyMessageDelayed(WRITE_PACKAGE_RESTRICTIONS, WRITE_SETTINGS_DELAY);
    }
}
#method_after
void scheduleWritePackageRestrictionsLocked(UserHandle user) {
    final int userId = user == null ? UserHandle.USER_ALL : user.getIdentifier();
    scheduleWritePackageRestrictionsLocked(userId);
}
#end_block

#method_before
void scheduleWritePackageRestrictionsLocked(int userId) {
    if (!sUserManager.exists(userId))
        return;
    mDirtyUsers.add(userId);
    if (!mHandler.hasMessages(WRITE_PACKAGE_RESTRICTIONS)) {
        mHandler.sendEmptyMessageDelayed(WRITE_PACKAGE_RESTRICTIONS, WRITE_SETTINGS_DELAY);
    }
}
#method_after
void scheduleWritePackageRestrictionsLocked(int userId) {
    final int[] userIds = (userId == UserHandle.USER_ALL) ? sUserManager.getUserIds() : new int[] { userId };
    for (int nextUserId : userIds) {
        if (!sUserManager.exists(nextUserId))
            return;
        mDirtyUsers.add(nextUserId);
        if (!mHandler.hasMessages(WRITE_PACKAGE_RESTRICTIONS)) {
            mHandler.sendEmptyMessageDelayed(WRITE_PACKAGE_RESTRICTIONS, WRITE_SETTINGS_DELAY);
        }
    }
}
#end_block

#method_before
public static PackageManagerService main(Context context, Installer installer, boolean factoryTest, boolean onlyCore) {
    PackageManagerService m = new PackageManagerService(context, installer, factoryTest, onlyCore);
    ServiceManager.addService("package", m);
    return m;
}
#method_after
public static PackageManagerService main(Context context, Installer installer, boolean factoryTest, boolean onlyCore) {
    // Self-check for initial settings.
    PackageManagerServiceCompilerMapping.checkProperties();
    PackageManagerService m = new PackageManagerService(context, installer, factoryTest, onlyCore);
    m.enableSystemUserPackages();
    // Disable any carrier apps. We do this very early in boot to prevent the apps from being
    // disabled after already being started.
    CarrierAppUtils.disableCarrierAppsUntilPrivileged(context.getOpPackageName(), m, UserHandle.USER_SYSTEM);
    ServiceManager.addService("package", m);
    return m;
}
#end_block

#method_before
@Override
public boolean isFirstBoot() {
    return !mRestoredSettings;
}
#method_after
@Override
public boolean isFirstBoot() {
    return mFirstBoot;
}
#end_block

#method_before
private String getRequiredInstallerLPr() {
    Intent installerIntent = new Intent(Intent.ACTION_INSTALL_PACKAGE);
    installerIntent.addCategory(Intent.CATEGORY_DEFAULT);
    installerIntent.setDataAndType(Uri.fromFile(new File("foo.apk")), PACKAGE_MIME_TYPE);
    final List<ResolveInfo> installers = queryIntentActivities(installerIntent, PACKAGE_MIME_TYPE, 0, 0);
    String requiredInstaller = null;
    final int N = installers.size();
    for (int i = 0; i < N; i++) {
        final ResolveInfo info = installers.get(i);
        final String packageName = info.activityInfo.packageName;
        if (!info.activityInfo.applicationInfo.isSystemApp()) {
            continue;
        }
        if (requiredInstaller != null) {
            throw new RuntimeException("There must be one required installer");
        }
        requiredInstaller = packageName;
    }
    if (requiredInstaller == null) {
        throw new RuntimeException("There must be one required installer");
    }
    return requiredInstaller;
}
#method_after
@NonNull
private String getRequiredInstallerLPr() {
    final Intent intent = new Intent(Intent.ACTION_INSTALL_PACKAGE);
    intent.addCategory(Intent.CATEGORY_DEFAULT);
    intent.setDataAndType(Uri.fromFile(new File("foo.apk")), PACKAGE_MIME_TYPE);
    final List<ResolveInfo> matches = queryIntentActivitiesInternal(intent, PACKAGE_MIME_TYPE, MATCH_SYSTEM_ONLY | MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE, UserHandle.USER_SYSTEM);
    if (matches.size() == 1) {
        ResolveInfo resolveInfo = matches.get(0);
        if (!resolveInfo.activityInfo.applicationInfo.isPrivilegedApp()) {
            throw new RuntimeException("The installer must be a privileged app");
        }
        return matches.get(0).getComponentInfo().packageName;
    } else {
        throw new RuntimeException("There must be exactly one installer; found " + matches);
    }
}
#end_block

#method_before
private ComponentName getIntentFilterVerifierComponentNameLPr() {
    final Intent verification = new Intent(Intent.ACTION_INTENT_FILTER_NEEDS_VERIFICATION);
    final List<ResolveInfo> receivers = queryIntentReceivers(verification, PACKAGE_MIME_TYPE, PackageManager.GET_DISABLED_COMPONENTS, 0);
    ComponentName verifierComponentName = null;
    int priority = -1000;
    final int N = receivers.size();
    for (int i = 0; i < N; i++) {
        final ResolveInfo info = receivers.get(i);
        if (info.activityInfo == null) {
            continue;
        }
        final String packageName = info.activityInfo.packageName;
        final PackageSetting ps = mSettings.mPackages.get(packageName);
        if (ps == null) {
            continue;
        }
        if (checkPermission(android.Manifest.permission.INTENT_FILTER_VERIFICATION_AGENT, packageName, UserHandle.USER_OWNER) != PackageManager.PERMISSION_GRANTED) {
            continue;
        }
        // Select the IntentFilterVerifier with the highest priority
        if (priority < info.priority) {
            priority = info.priority;
            verifierComponentName = new ComponentName(packageName, info.activityInfo.name);
            if (DEBUG_DOMAIN_VERIFICATION)
                Slog.d(TAG, "Selecting IntentFilterVerifier: " + verifierComponentName + " with priority: " + info.priority);
        }
    }
    return verifierComponentName;
}
#method_after
@NonNull
private ComponentName getIntentFilterVerifierComponentNameLPr() {
    final Intent intent = new Intent(Intent.ACTION_INTENT_FILTER_NEEDS_VERIFICATION);
    final List<ResolveInfo> matches = queryIntentReceiversInternal(intent, PACKAGE_MIME_TYPE, MATCH_SYSTEM_ONLY | MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE, UserHandle.USER_SYSTEM);
    ResolveInfo best = null;
    final int N = matches.size();
    for (int i = 0; i < N; i++) {
        final ResolveInfo cur = matches.get(i);
        final String packageName = cur.getComponentInfo().packageName;
        if (checkPermission(android.Manifest.permission.INTENT_FILTER_VERIFICATION_AGENT, packageName, UserHandle.USER_SYSTEM) != PackageManager.PERMISSION_GRANTED) {
            continue;
        }
        if (best == null || cur.priority > best.priority) {
            best = cur;
        }
    }
    if (best != null) {
        return best.getComponentInfo().getComponentName();
    } else {
        throw new RuntimeException("There must be at least one intent filter verifier");
    }
}
#end_block

#method_before
private void primeDomainVerificationsLPw(int userId) {
    if (DEBUG_DOMAIN_VERIFICATION) {
        Slog.d(TAG, "Priming domain verifications in user " + userId);
    }
    SystemConfig systemConfig = SystemConfig.getInstance();
    ArraySet<String> packages = systemConfig.getLinkedApps();
    ArraySet<String> domains = new ArraySet<String>();
    for (String packageName : packages) {
        PackageParser.Package pkg = mPackages.get(packageName);
        if (pkg != null) {
            if (!pkg.isSystemApp()) {
                Slog.w(TAG, "Non-system app '" + packageName + "' in sysconfig <app-link>");
                continue;
            }
            domains.clear();
            for (PackageParser.Activity a : pkg.activities) {
                for (ActivityIntentInfo filter : a.intents) {
                    if (hasValidDomains(filter)) {
                        domains.addAll(filter.getHostsList());
                    }
                }
            }
            if (domains.size() > 0) {
                if (DEBUG_DOMAIN_VERIFICATION) {
                    Slog.v(TAG, "      + " + packageName);
                }
                // 'Undefined' in the global IntentFilterVerificationInfo, i.e. the usual
                // state w.r.t. the formal app-linkage "no verification attempted" state;
                // and then 'always' in the per-user state actually used for intent resolution.
                final IntentFilterVerificationInfo ivi;
                ivi = mSettings.createIntentFilterVerificationIfNeededLPw(packageName, new ArrayList<String>(domains));
                ivi.setStatus(INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_UNDEFINED);
                mSettings.updateIntentFilterVerificationStatusLPw(packageName, INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_ALWAYS, userId);
            } else {
                Slog.w(TAG, "Sysconfig <app-link> package '" + packageName + "' does not handle web links");
            }
        } else {
            Slog.w(TAG, "Unknown package '" + packageName + "' in sysconfig <app-link>");
        }
    }
    scheduleWritePackageRestrictionsLocked(userId);
    scheduleWriteSettingsLocked();
}
#method_after
private void primeDomainVerificationsLPw(int userId) {
    if (DEBUG_DOMAIN_VERIFICATION) {
        Slog.d(TAG, "Priming domain verifications in user " + userId);
    }
    SystemConfig systemConfig = SystemConfig.getInstance();
    ArraySet<String> packages = systemConfig.getLinkedApps();
    ArraySet<String> domains = new ArraySet<String>();
    for (String packageName : packages) {
        PackageParser.Package pkg = mPackages.get(packageName);
        if (pkg != null) {
            if (!pkg.isSystemApp()) {
                Slog.w(TAG, "Non-system app '" + packageName + "' in sysconfig <app-link>");
                continue;
            }
            domains.clear();
            for (PackageParser.Activity a : pkg.activities) {
                for (ActivityIntentInfo filter : a.intents) {
                    if (hasValidDomains(filter)) {
                        domains.addAll(filter.getHostsList());
                    }
                }
            }
            if (domains.size() > 0) {
                if (DEBUG_DOMAIN_VERIFICATION) {
                    Slog.v(TAG, "      + " + packageName);
                }
                // 'Undefined' in the global IntentFilterVerificationInfo, i.e. the usual
                // state w.r.t. the formal app-linkage "no verification attempted" state;
                // and then 'always' in the per-user state actually used for intent resolution.
                final IntentFilterVerificationInfo ivi;
                ivi = mSettings.createIntentFilterVerificationIfNeededLPw(packageName, new ArrayList<String>(domains));
                ivi.setStatus(INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_UNDEFINED);
                mSettings.updateIntentFilterVerificationStatusLPw(packageName, INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_ALWAYS, userId);
            } else {
                Slog.w(TAG, "Sysconfig <app-link> package '" + packageName + "' does not handle web links");
            }
        } else {
            Slog.w(TAG, "Unknown package " + packageName + " in sysconfig <app-link>");
        }
    }
    scheduleWritePackageRestrictionsLocked(userId);
    scheduleWriteSettingsLocked();
}
#end_block

#method_before
private List<String> resolveAllBrowserApps(int userId) {
    // Resolve the canonical browser intent and check that the handleAllWebDataURI boolean is set
    List<ResolveInfo> list = queryIntentActivities(sBrowserIntent, null, PackageManager.MATCH_ALL, userId);
    final int count = list.size();
    List<String> result = new ArrayList<String>(count);
    for (int i = 0; i < count; i++) {
        ResolveInfo info = list.get(i);
        if (info.activityInfo == null || !info.handleAllWebDataURI || (info.activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0 || result.contains(info.activityInfo.packageName)) {
            continue;
        }
        result.add(info.activityInfo.packageName);
    }
    return result;
}
#method_after
private List<String> resolveAllBrowserApps(int userId) {
    // Resolve the canonical browser intent and check that the handleAllWebDataURI boolean is set
    List<ResolveInfo> list = queryIntentActivitiesInternal(sBrowserIntent, null, PackageManager.MATCH_ALL, userId);
    final int count = list.size();
    List<String> result = new ArrayList<String>(count);
    for (int i = 0; i < count; i++) {
        ResolveInfo info = list.get(i);
        if (info.activityInfo == null || !info.handleAllWebDataURI || (info.activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0 || result.contains(info.activityInfo.packageName)) {
            continue;
        }
        result.add(info.activityInfo.packageName);
    }
    return result;
}
#end_block

#method_before
private boolean packageIsBrowser(String packageName, int userId) {
    List<ResolveInfo> list = queryIntentActivities(sBrowserIntent, null, PackageManager.MATCH_ALL, userId);
    final int N = list.size();
    for (int i = 0; i < N; i++) {
        ResolveInfo info = list.get(i);
        if (packageName.equals(info.activityInfo.packageName)) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean packageIsBrowser(String packageName, int userId) {
    List<ResolveInfo> list = queryIntentActivitiesInternal(sBrowserIntent, null, PackageManager.MATCH_ALL, userId);
    final int N = list.size();
    for (int i = 0; i < N; i++) {
        ResolveInfo info = list.get(i);
        if (packageName.equals(info.activityInfo.packageName)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
PackageInfo generatePackageInfo(PackageParser.Package p, int flags, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    final PackageSetting ps = (PackageSetting) p.mExtras;
    if (ps == null) {
        return null;
    }
    final PermissionsState permissionsState = ps.getPermissionsState();
    final int[] gids = permissionsState.computeGids(userId);
    final Set<String> permissions = permissionsState.getPermissions(userId);
    final PackageUserState state = ps.readUserState(userId);
    return PackageParser.generatePackageInfo(p, gids, flags, ps.firstInstallTime, ps.lastUpdateTime, permissions, state, userId);
}
#method_after
private PackageInfo generatePackageInfo(PackageSetting ps, int flags, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    if (ps == null) {
        return null;
    }
    final PackageParser.Package p = ps.pkg;
    if (p == null) {
        return null;
    }
    final PermissionsState permissionsState = ps.getPermissionsState();
    final int[] gids = permissionsState.computeGids(userId);
    final Set<String> permissions = permissionsState.getPermissions(userId);
    final PackageUserState state = ps.readUserState(userId);
    return PackageParser.generatePackageInfo(p, gids, flags, ps.firstInstallTime, ps.lastUpdateTime, permissions, state, userId);
}
#end_block

#method_before
@Override
public boolean isPackageAvailable(String packageName, int userId) {
    if (!sUserManager.exists(userId))
        return false;
    enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "is package available");
    synchronized (mPackages) {
        PackageParser.Package p = mPackages.get(packageName);
        if (p != null) {
            final PackageSetting ps = (PackageSetting) p.mExtras;
            if (ps != null) {
                final PackageUserState state = ps.readUserState(userId);
                if (state != null) {
                    return PackageParser.isAvailable(state);
                }
            }
        }
    }
    return false;
}
#method_after
@Override
public boolean isPackageAvailable(String packageName, int userId) {
    if (!sUserManager.exists(userId))
        return false;
    enforceCrossUserPermission(Binder.getCallingUid(), userId, false, /* requireFullPermission */
    false, /* checkShell */
    "is package available");
    synchronized (mPackages) {
        PackageParser.Package p = mPackages.get(packageName);
        if (p != null) {
            final PackageSetting ps = (PackageSetting) p.mExtras;
            if (ps != null) {
                final PackageUserState state = ps.readUserState(userId);
                if (state != null) {
                    return PackageParser.isAvailable(state);
                }
            }
        }
    }
    return false;
}
#end_block

#method_before
@Override
public PackageInfo getPackageInfo(String packageName, int flags, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "get package info");
    // reader
    synchronized (mPackages) {
        PackageParser.Package p = mPackages.get(packageName);
        if (DEBUG_PACKAGE_INFO)
            Log.v(TAG, "getPackageInfo " + packageName + ": " + p);
        if (p != null) {
            return generatePackageInfo(p, flags, userId);
        }
        if ((flags & PackageManager.GET_UNINSTALLED_PACKAGES) != 0) {
            return generatePackageInfoFromSettingsLPw(packageName, flags, userId);
        }
    }
    return null;
}
#method_after
@Override
public PackageInfo getPackageInfo(String packageName, int flags, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    flags = updateFlagsForPackage(flags, userId, packageName);
    enforceCrossUserPermission(Binder.getCallingUid(), userId, false, /* requireFullPermission */
    false, /* checkShell */
    "get package info");
    // reader
    synchronized (mPackages) {
        final boolean matchFactoryOnly = (flags & MATCH_FACTORY_ONLY) != 0;
        PackageParser.Package p = null;
        if (matchFactoryOnly) {
            final PackageSetting ps = mSettings.getDisabledSystemPkgLPr(packageName);
            if (ps != null) {
                return generatePackageInfo(ps, flags, userId);
            }
        }
        if (p == null) {
            p = mPackages.get(packageName);
            if (matchFactoryOnly && p != null && !isSystemApp(p)) {
                return null;
            }
        }
        if (DEBUG_PACKAGE_INFO)
            Log.v(TAG, "getPackageInfo " + packageName + ": " + p);
        if (p != null) {
            return generatePackageInfo((PackageSetting) p.mExtras, flags, userId);
        }
        if (!matchFactoryOnly && (flags & MATCH_UNINSTALLED_PACKAGES) != 0) {
            final PackageSetting ps = mSettings.mPackages.get(packageName);
            return generatePackageInfo(ps, flags, userId);
        }
    }
    return null;
}
#end_block

#method_before
@Override
public int getPackageUid(String packageName, int userId) {
    return getPackageUidEtc(packageName, 0, userId);
}
#method_after
@Override
public int getPackageUid(String packageName, int flags, int userId) {
    if (!sUserManager.exists(userId))
        return -1;
    flags = updateFlagsForPackage(flags, userId, packageName);
    enforceCrossUserPermission(Binder.getCallingUid(), userId, false, /* requireFullPermission */
    false, /* checkShell */
    "get package uid");
    // reader
    synchronized (mPackages) {
        final PackageParser.Package p = mPackages.get(packageName);
        if (p != null && p.isMatch(flags)) {
            return UserHandle.getUid(userId, p.applicationInfo.uid);
        }
        if ((flags & MATCH_UNINSTALLED_PACKAGES) != 0) {
            final PackageSetting ps = mSettings.mPackages.get(packageName);
            if (ps != null && ps.isMatch(flags)) {
                return UserHandle.getUid(userId, ps.appId);
            }
        }
    }
    return -1;
}
#end_block

#method_before
@Override
public int[] getPackageGids(String packageName, int userId) {
    return getPackageGidsEtc(packageName, 0, userId);
}
#method_after
@Override
public int[] getPackageGids(String packageName, int flags, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    flags = updateFlagsForPackage(flags, userId, packageName);
    enforceCrossUserPermission(Binder.getCallingUid(), userId, false, /* requireFullPermission */
    false, /* checkShell */
    "getPackageGids");
    // reader
    synchronized (mPackages) {
        final PackageParser.Package p = mPackages.get(packageName);
        if (p != null && p.isMatch(flags)) {
            PackageSetting ps = (PackageSetting) p.mExtras;
            return ps.getPermissionsState().computeGids(userId);
        }
        if ((flags & MATCH_UNINSTALLED_PACKAGES) != 0) {
            final PackageSetting ps = mSettings.mPackages.get(packageName);
            if (ps != null && ps.isMatch(flags)) {
                return ps.getPermissionsState().computeGids(userId);
            }
        }
    }
    return null;
}
#end_block

#method_before
@Override
public List<PermissionInfo> queryPermissionsByGroup(String group, int flags) {
    // reader
    synchronized (mPackages) {
        ArrayList<PermissionInfo> out = new ArrayList<PermissionInfo>(10);
        for (BasePermission p : mSettings.mPermissions.values()) {
            if (group == null) {
                if (p.perm == null || p.perm.info.group == null) {
                    out.add(generatePermissionInfo(p, flags));
                }
            } else {
                if (p.perm != null && group.equals(p.perm.info.group)) {
                    out.add(PackageParser.generatePermissionInfo(p.perm, flags));
                }
            }
        }
        if (out.size() > 0) {
            return out;
        }
        return mPermissionGroups.containsKey(group) ? out : null;
    }
}
#method_after
@Override
@Nullable
public ParceledListSlice<PermissionInfo> queryPermissionsByGroup(String group, int flags) {
    // reader
    synchronized (mPackages) {
        if (group != null && !mPermissionGroups.containsKey(group)) {
            // This is thrown as NameNotFoundException
            return null;
        }
        ArrayList<PermissionInfo> out = new ArrayList<PermissionInfo>(10);
        for (BasePermission p : mSettings.mPermissions.values()) {
            if (group == null) {
                if (p.perm == null || p.perm.info.group == null) {
                    out.add(generatePermissionInfo(p, flags));
                }
            } else {
                if (p.perm != null && group.equals(p.perm.info.group)) {
                    out.add(PackageParser.generatePermissionInfo(p.perm, flags));
                }
            }
        }
        return new ParceledListSlice<>(out);
    }
}
#end_block

#method_before
@Override
public List<PermissionGroupInfo> getAllPermissionGroups(int flags) {
    // reader
    synchronized (mPackages) {
        final int N = mPermissionGroups.size();
        ArrayList<PermissionGroupInfo> out = new ArrayList<PermissionGroupInfo>(N);
        for (PackageParser.PermissionGroup pg : mPermissionGroups.values()) {
            out.add(PackageParser.generatePermissionGroupInfo(pg, flags));
        }
        return out;
    }
}
#method_after
@Override
@NonNull
public ParceledListSlice<PermissionGroupInfo> getAllPermissionGroups(int flags) {
    // reader
    synchronized (mPackages) {
        final int N = mPermissionGroups.size();
        ArrayList<PermissionGroupInfo> out = new ArrayList<PermissionGroupInfo>(N);
        for (PackageParser.PermissionGroup pg : mPermissionGroups.values()) {
            out.add(PackageParser.generatePermissionGroupInfo(pg, flags));
        }
        return new ParceledListSlice<>(out);
    }
}
#end_block

#method_before
private ApplicationInfo generateApplicationInfoFromSettingsLPw(String packageName, int flags, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    PackageSetting ps = mSettings.mPackages.get(packageName);
    if (ps != null) {
        if (ps.pkg == null) {
            PackageInfo pInfo = generatePackageInfoFromSettingsLPw(packageName, flags, userId);
            if (pInfo != null) {
                return pInfo.applicationInfo;
            }
            return null;
        }
        return PackageParser.generateApplicationInfo(ps.pkg, flags, ps.readUserState(userId), userId);
    }
    return null;
}
#method_after
private ApplicationInfo generateApplicationInfoFromSettingsLPw(String packageName, int flags, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    PackageSetting ps = mSettings.mPackages.get(packageName);
    if (ps != null) {
        if (ps.pkg == null) {
            final PackageInfo pInfo = generatePackageInfo(ps, flags, userId);
            if (pInfo != null) {
                return pInfo.applicationInfo;
            }
            return null;
        }
        return PackageParser.generateApplicationInfo(ps.pkg, flags, ps.readUserState(userId), userId);
    }
    return null;
}
#end_block

#method_before
@Override
public ApplicationInfo getApplicationInfo(String packageName, int flags, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "get application info");
    // writer
    synchronized (mPackages) {
        PackageParser.Package p = mPackages.get(packageName);
        if (DEBUG_PACKAGE_INFO)
            Log.v(TAG, "getApplicationInfo " + packageName + ": " + p);
        if (p != null) {
            PackageSetting ps = mSettings.mPackages.get(packageName);
            if (ps == null)
                return null;
            // Note: isEnabledLP() does not apply here - always return info
            return PackageParser.generateApplicationInfo(p, flags, ps.readUserState(userId), userId);
        }
        if ("android".equals(packageName) || "system".equals(packageName)) {
            return mAndroidApplication;
        }
        if ((flags & PackageManager.GET_UNINSTALLED_PACKAGES) != 0) {
            return generateApplicationInfoFromSettingsLPw(packageName, flags, userId);
        }
    }
    return null;
}
#method_after
@Override
public ApplicationInfo getApplicationInfo(String packageName, int flags, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    flags = updateFlagsForApplication(flags, userId, packageName);
    enforceCrossUserPermission(Binder.getCallingUid(), userId, false, /* requireFullPermission */
    false, /* checkShell */
    "get application info");
    // writer
    synchronized (mPackages) {
        PackageParser.Package p = mPackages.get(packageName);
        if (DEBUG_PACKAGE_INFO)
            Log.v(TAG, "getApplicationInfo " + packageName + ": " + p);
        if (p != null) {
            PackageSetting ps = mSettings.mPackages.get(packageName);
            if (ps == null)
                return null;
            // Note: isEnabledLP() does not apply here - always return info
            return PackageParser.generateApplicationInfo(p, flags, ps.readUserState(userId), userId);
        }
        if ("android".equals(packageName) || "system".equals(packageName)) {
            return mAndroidApplication;
        }
        if ((flags & MATCH_UNINSTALLED_PACKAGES) != 0) {
            return generateApplicationInfoFromSettingsLPw(packageName, flags, userId);
        }
    }
    return null;
}
#end_block

#method_before
@Override
public void freeStorageAndNotify(final String volumeUuid, final long freeStorageSize, final IPackageDataObserver observer) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.CLEAR_APP_CACHE, null);
    // Queue up an async operation since clearing cache may take a little while.
    mHandler.post(new Runnable() {

        public void run() {
            mHandler.removeCallbacks(this);
            int retCode = -1;
            synchronized (mInstallLock) {
                retCode = mInstaller.freeCache(volumeUuid, freeStorageSize);
                if (retCode < 0) {
                    Slog.w(TAG, "Couldn't clear application caches");
                }
            }
            if (observer != null) {
                try {
                    observer.onRemoveCompleted(null, (retCode >= 0));
                } catch (RemoteException e) {
                    Slog.w(TAG, "RemoveException when invoking call back");
                }
            }
        }
    });
}
#method_after
@Override
public void freeStorageAndNotify(final String volumeUuid, final long freeStorageSize, final IPackageDataObserver observer) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.CLEAR_APP_CACHE, null);
    // Queue up an async operation since clearing cache may take a little while.
    mHandler.post(new Runnable() {

        public void run() {
            mHandler.removeCallbacks(this);
            boolean success = true;
            synchronized (mInstallLock) {
                try {
                    mInstaller.freeCache(volumeUuid, freeStorageSize);
                } catch (InstallerException e) {
                    Slog.w(TAG, "Couldn't clear application caches: " + e);
                    success = false;
                }
            }
            if (observer != null) {
                try {
                    observer.onRemoveCompleted(null, success);
                } catch (RemoteException e) {
                    Slog.w(TAG, "RemoveException when invoking call back");
                }
            }
        }
    });
}
#end_block

#method_before
@Override
public void freeStorage(final String volumeUuid, final long freeStorageSize, final IntentSender pi) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.CLEAR_APP_CACHE, null);
    // Queue up an async operation since clearing cache may take a little while.
    mHandler.post(new Runnable() {

        public void run() {
            mHandler.removeCallbacks(this);
            int retCode = -1;
            synchronized (mInstallLock) {
                retCode = mInstaller.freeCache(volumeUuid, freeStorageSize);
                if (retCode < 0) {
                    Slog.w(TAG, "Couldn't clear application caches");
                }
            }
            if (pi != null) {
                try {
                    // Callback via pending intent
                    int code = (retCode >= 0) ? 1 : 0;
                    pi.sendIntent(null, code, null, null, null);
                } catch (SendIntentException e1) {
                    Slog.i(TAG, "Failed to send pending intent");
                }
            }
        }
    });
}
#method_after
@Override
public void freeStorage(final String volumeUuid, final long freeStorageSize, final IntentSender pi) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.CLEAR_APP_CACHE, null);
    // Queue up an async operation since clearing cache may take a little while.
    mHandler.post(new Runnable() {

        public void run() {
            mHandler.removeCallbacks(this);
            boolean success = true;
            synchronized (mInstallLock) {
                try {
                    mInstaller.freeCache(volumeUuid, freeStorageSize);
                } catch (InstallerException e) {
                    Slog.w(TAG, "Couldn't clear application caches: " + e);
                    success = false;
                }
            }
            if (pi != null) {
                try {
                    // Callback via pending intent
                    int code = success ? 1 : 0;
                    pi.sendIntent(null, code, null, null, null);
                } catch (SendIntentException e1) {
                    Slog.i(TAG, "Failed to send pending intent");
                }
            }
        }
    });
}
#end_block

#method_before
void freeStorage(String volumeUuid, long freeStorageSize) throws IOException {
    synchronized (mInstallLock) {
        if (mInstaller.freeCache(volumeUuid, freeStorageSize) < 0) {
            throw new IOException("Failed to free enough space");
        }
    }
}
#method_after
void freeStorage(String volumeUuid, long freeStorageSize) throws IOException {
    synchronized (mInstallLock) {
        try {
            mInstaller.freeCache(volumeUuid, freeStorageSize);
        } catch (InstallerException e) {
            throw new IOException("Failed to free enough space", e);
        }
    }
}
#end_block

#method_before
@Override
public ActivityInfo getActivityInfo(ComponentName component, int flags, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "get activity info");
    synchronized (mPackages) {
        PackageParser.Activity a = mActivities.mActivities.get(component);
        if (DEBUG_PACKAGE_INFO)
            Log.v(TAG, "getActivityInfo " + component + ": " + a);
        if (a != null && mSettings.isEnabledLPr(a.info, flags, userId)) {
            PackageSetting ps = mSettings.mPackages.get(component.getPackageName());
            if (ps == null)
                return null;
            return PackageParser.generateActivityInfo(a, flags, ps.readUserState(userId), userId);
        }
        if (mResolveComponentName.equals(component)) {
            return PackageParser.generateActivityInfo(mResolveActivity, flags, new PackageUserState(), userId);
        }
    }
    return null;
}
#method_after
@Override
public ActivityInfo getActivityInfo(ComponentName component, int flags, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    flags = updateFlagsForComponent(flags, userId, component);
    enforceCrossUserPermission(Binder.getCallingUid(), userId, false, /* requireFullPermission */
    false, /* checkShell */
    "get activity info");
    synchronized (mPackages) {
        PackageParser.Activity a = mActivities.mActivities.get(component);
        if (DEBUG_PACKAGE_INFO)
            Log.v(TAG, "getActivityInfo " + component + ": " + a);
        if (a != null && mSettings.isEnabledAndMatchLPr(a.info, flags, userId)) {
            PackageSetting ps = mSettings.mPackages.get(component.getPackageName());
            if (ps == null)
                return null;
            return PackageParser.generateActivityInfo(a, flags, ps.readUserState(userId), userId);
        }
        if (mResolveComponentName.equals(component)) {
            return PackageParser.generateActivityInfo(mResolveActivity, flags, new PackageUserState(), userId);
        }
    }
    return null;
}
#end_block

#method_before
@Override
public ActivityInfo getReceiverInfo(ComponentName component, int flags, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "get receiver info");
    synchronized (mPackages) {
        PackageParser.Activity a = mReceivers.mActivities.get(component);
        if (DEBUG_PACKAGE_INFO)
            Log.v(TAG, "getReceiverInfo " + component + ": " + a);
        if (a != null && mSettings.isEnabledLPr(a.info, flags, userId)) {
            PackageSetting ps = mSettings.mPackages.get(component.getPackageName());
            if (ps == null)
                return null;
            return PackageParser.generateActivityInfo(a, flags, ps.readUserState(userId), userId);
        }
    }
    return null;
}
#method_after
@Override
public ActivityInfo getReceiverInfo(ComponentName component, int flags, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    flags = updateFlagsForComponent(flags, userId, component);
    enforceCrossUserPermission(Binder.getCallingUid(), userId, false, /* requireFullPermission */
    false, /* checkShell */
    "get receiver info");
    synchronized (mPackages) {
        PackageParser.Activity a = mReceivers.mActivities.get(component);
        if (DEBUG_PACKAGE_INFO)
            Log.v(TAG, "getReceiverInfo " + component + ": " + a);
        if (a != null && mSettings.isEnabledAndMatchLPr(a.info, flags, userId)) {
            PackageSetting ps = mSettings.mPackages.get(component.getPackageName());
            if (ps == null)
                return null;
            return PackageParser.generateActivityInfo(a, flags, ps.readUserState(userId), userId);
        }
    }
    return null;
}
#end_block

#method_before
@Override
public ServiceInfo getServiceInfo(ComponentName component, int flags, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "get service info");
    synchronized (mPackages) {
        PackageParser.Service s = mServices.mServices.get(component);
        if (DEBUG_PACKAGE_INFO)
            Log.v(TAG, "getServiceInfo " + component + ": " + s);
        if (s != null && mSettings.isEnabledLPr(s.info, flags, userId)) {
            PackageSetting ps = mSettings.mPackages.get(component.getPackageName());
            if (ps == null)
                return null;
            return PackageParser.generateServiceInfo(s, flags, ps.readUserState(userId), userId);
        }
    }
    return null;
}
#method_after
@Override
public ServiceInfo getServiceInfo(ComponentName component, int flags, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    flags = updateFlagsForComponent(flags, userId, component);
    enforceCrossUserPermission(Binder.getCallingUid(), userId, false, /* requireFullPermission */
    false, /* checkShell */
    "get service info");
    synchronized (mPackages) {
        PackageParser.Service s = mServices.mServices.get(component);
        if (DEBUG_PACKAGE_INFO)
            Log.v(TAG, "getServiceInfo " + component + ": " + s);
        if (s != null && mSettings.isEnabledAndMatchLPr(s.info, flags, userId)) {
            PackageSetting ps = mSettings.mPackages.get(component.getPackageName());
            if (ps == null)
                return null;
            return PackageParser.generateServiceInfo(s, flags, ps.readUserState(userId), userId);
        }
    }
    return null;
}
#end_block

#method_before
@Override
public ProviderInfo getProviderInfo(ComponentName component, int flags, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "get provider info");
    synchronized (mPackages) {
        PackageParser.Provider p = mProviders.mProviders.get(component);
        if (DEBUG_PACKAGE_INFO)
            Log.v(TAG, "getProviderInfo " + component + ": " + p);
        if (p != null && mSettings.isEnabledLPr(p.info, flags, userId)) {
            PackageSetting ps = mSettings.mPackages.get(component.getPackageName());
            if (ps == null)
                return null;
            return PackageParser.generateProviderInfo(p, flags, ps.readUserState(userId), userId);
        }
    }
    return null;
}
#method_after
@Override
public ProviderInfo getProviderInfo(ComponentName component, int flags, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    flags = updateFlagsForComponent(flags, userId, component);
    enforceCrossUserPermission(Binder.getCallingUid(), userId, false, /* requireFullPermission */
    false, /* checkShell */
    "get provider info");
    synchronized (mPackages) {
        PackageParser.Provider p = mProviders.mProviders.get(component);
        if (DEBUG_PACKAGE_INFO)
            Log.v(TAG, "getProviderInfo " + component + ": " + p);
        if (p != null && mSettings.isEnabledAndMatchLPr(p.info, flags, userId)) {
            PackageSetting ps = mSettings.mPackages.get(component.getPackageName());
            if (ps == null)
                return null;
            return PackageParser.generateProviderInfo(p, flags, ps.readUserState(userId), userId);
        }
    }
    return null;
}
#end_block

#method_before
@Override
public FeatureInfo[] getSystemAvailableFeatures() {
    Collection<FeatureInfo> featSet;
    synchronized (mPackages) {
        featSet = mAvailableFeatures.values();
        int size = featSet.size();
        if (size > 0) {
            FeatureInfo[] features = new FeatureInfo[size + 1];
            featSet.toArray(features);
            FeatureInfo fi = new FeatureInfo();
            fi.reqGlEsVersion = SystemProperties.getInt("ro.opengles.version", FeatureInfo.GL_ES_VERSION_UNDEFINED);
            features[size] = fi;
            return features;
        }
    }
    return null;
}
#method_after
@Override
@NonNull
public ParceledListSlice<FeatureInfo> getSystemAvailableFeatures() {
    synchronized (mPackages) {
        final ArrayList<FeatureInfo> res = new ArrayList<>(mAvailableFeatures.values());
        final FeatureInfo fi = new FeatureInfo();
        fi.reqGlEsVersion = SystemProperties.getInt("ro.opengles.version", FeatureInfo.GL_ES_VERSION_UNDEFINED);
        res.add(fi);
        return new ParceledListSlice<>(res);
    }
}
#end_block

#method_before
@Override
public boolean hasSystemFeature(String name) {
    synchronized (mPackages) {
        return mAvailableFeatures.containsKey(name);
    }
}
#method_after
@Override
public boolean hasSystemFeature(String name, int version) {
    synchronized (mPackages) {
        final FeatureInfo feat = mAvailableFeatures.get(name);
        if (feat == null) {
            return false;
        } else {
            return feat.version >= version;
        }
    }
}
#end_block

#method_before
@Override
public void grantRuntimePermission(String packageName, String name, final int userId) {
    if (!sUserManager.exists(userId)) {
        Log.e(TAG, "No such user:" + userId);
        return;
    }
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.GRANT_RUNTIME_PERMISSIONS, "grantRuntimePermission");
    enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "grantRuntimePermission");
    final int uid;
    final SettingBase sb;
    synchronized (mPackages) {
        final PackageParser.Package pkg = mPackages.get(packageName);
        if (pkg == null) {
            throw new IllegalArgumentException("Unknown package: " + packageName);
        }
        final BasePermission bp = mSettings.mPermissions.get(name);
        if (bp == null) {
            throw new IllegalArgumentException("Unknown permission: " + name);
        }
        enforceDeclaredAsUsedAndRuntimeOrDevelopmentPermission(pkg, bp);
        uid = UserHandle.getUid(userId, pkg.applicationInfo.uid);
        sb = (SettingBase) pkg.mExtras;
        if (sb == null) {
            throw new IllegalArgumentException("Unknown package: " + packageName);
        }
        final PermissionsState permissionsState = sb.getPermissionsState();
        final int flags = permissionsState.getPermissionFlags(name, userId);
        if ((flags & PackageManager.FLAG_PERMISSION_SYSTEM_FIXED) != 0) {
            throw new SecurityException("Cannot grant system fixed permission: " + name + " for package: " + packageName);
        }
        if (bp.isDevelopment()) {
            // normal runtime permissions.  For now they apply to all users.
            if (permissionsState.grantInstallPermission(bp) != PermissionsState.PERMISSION_OPERATION_FAILURE) {
                scheduleWriteSettingsLocked();
            }
            return;
        }
        final int result = permissionsState.grantRuntimePermission(bp, userId);
        switch(result) {
            case PermissionsState.PERMISSION_OPERATION_FAILURE:
                {
                    return;
                }
            case PermissionsState.PERMISSION_OPERATION_SUCCESS_GIDS_CHANGED:
                {
                    final int appId = UserHandle.getAppId(pkg.applicationInfo.uid);
                    mHandler.post(new Runnable() {

                        @Override
                        public void run() {
                            killUid(appId, userId, KILL_APP_REASON_GIDS_CHANGED);
                        }
                    });
                }
                break;
        }
        mOnPermissionChangeListeners.onPermissionsChanged(uid);
        // Not critical if that is lost - app has to request again.
        mSettings.writeRuntimePermissionsForUserLPr(userId, false);
    }
    // to make an expensive call to remount processes for the changed permissions.
    if (READ_EXTERNAL_STORAGE.equals(name) || WRITE_EXTERNAL_STORAGE.equals(name)) {
        final long token = Binder.clearCallingIdentity();
        try {
            if (sUserManager.isInitialized(userId)) {
                MountServiceInternal mountServiceInternal = LocalServices.getService(MountServiceInternal.class);
                mountServiceInternal.onExternalStoragePolicyChanged(uid, packageName);
            }
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }
}
#method_after
@Override
public void grantRuntimePermission(String packageName, String name, final int userId) {
    if (!sUserManager.exists(userId)) {
        Log.e(TAG, "No such user:" + userId);
        return;
    }
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.GRANT_RUNTIME_PERMISSIONS, "grantRuntimePermission");
    enforceCrossUserPermission(Binder.getCallingUid(), userId, true, /* requireFullPermission */
    true, /* checkShell */
    "grantRuntimePermission");
    final int uid;
    final SettingBase sb;
    synchronized (mPackages) {
        final PackageParser.Package pkg = mPackages.get(packageName);
        if (pkg == null) {
            throw new IllegalArgumentException("Unknown package: " + packageName);
        }
        final BasePermission bp = mSettings.mPermissions.get(name);
        if (bp == null) {
            throw new IllegalArgumentException("Unknown permission: " + name);
        }
        enforceDeclaredAsUsedAndRuntimeOrDevelopmentPermission(pkg, bp);
        // install permission's state is shared across all users.
        if (Build.PERMISSIONS_REVIEW_REQUIRED && pkg.applicationInfo.targetSdkVersion < Build.VERSION_CODES.M && bp.isRuntime()) {
            return;
        }
        uid = UserHandle.getUid(userId, pkg.applicationInfo.uid);
        sb = (SettingBase) pkg.mExtras;
        if (sb == null) {
            throw new IllegalArgumentException("Unknown package: " + packageName);
        }
        final PermissionsState permissionsState = sb.getPermissionsState();
        final int flags = permissionsState.getPermissionFlags(name, userId);
        if ((flags & PackageManager.FLAG_PERMISSION_SYSTEM_FIXED) != 0) {
            throw new SecurityException("Cannot grant system fixed permission " + name + " for package " + packageName);
        }
        if (bp.isDevelopment()) {
            // normal runtime permissions.  For now they apply to all users.
            if (permissionsState.grantInstallPermission(bp) != PermissionsState.PERMISSION_OPERATION_FAILURE) {
                scheduleWriteSettingsLocked();
            }
            return;
        }
        if (pkg.applicationInfo.targetSdkVersion < Build.VERSION_CODES.M) {
            Slog.w(TAG, "Cannot grant runtime permission to a legacy app");
            return;
        }
        final int result = permissionsState.grantRuntimePermission(bp, userId);
        switch(result) {
            case PermissionsState.PERMISSION_OPERATION_FAILURE:
                {
                    return;
                }
            case PermissionsState.PERMISSION_OPERATION_SUCCESS_GIDS_CHANGED:
                {
                    final int appId = UserHandle.getAppId(pkg.applicationInfo.uid);
                    mHandler.post(new Runnable() {

                        @Override
                        public void run() {
                            killUid(appId, userId, KILL_APP_REASON_GIDS_CHANGED);
                        }
                    });
                }
                break;
        }
        mOnPermissionChangeListeners.onPermissionsChanged(uid);
        // Not critical if that is lost - app has to request again.
        mSettings.writeRuntimePermissionsForUserLPr(userId, false);
    }
    // to make an expensive call to remount processes for the changed permissions.
    if (READ_EXTERNAL_STORAGE.equals(name) || WRITE_EXTERNAL_STORAGE.equals(name)) {
        final long token = Binder.clearCallingIdentity();
        try {
            if (sUserManager.isInitialized(userId)) {
                MountServiceInternal mountServiceInternal = LocalServices.getService(MountServiceInternal.class);
                mountServiceInternal.onExternalStoragePolicyChanged(uid, packageName);
            }
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }
}
#end_block

#method_before
@Override
public void revokeRuntimePermission(String packageName, String name, int userId) {
    if (!sUserManager.exists(userId)) {
        Log.e(TAG, "No such user:" + userId);
        return;
    }
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.REVOKE_RUNTIME_PERMISSIONS, "revokeRuntimePermission");
    enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "revokeRuntimePermission");
    final int appId;
    synchronized (mPackages) {
        final PackageParser.Package pkg = mPackages.get(packageName);
        if (pkg == null) {
            throw new IllegalArgumentException("Unknown package: " + packageName);
        }
        final BasePermission bp = mSettings.mPermissions.get(name);
        if (bp == null) {
            throw new IllegalArgumentException("Unknown permission: " + name);
        }
        enforceDeclaredAsUsedAndRuntimeOrDevelopmentPermission(pkg, bp);
        SettingBase sb = (SettingBase) pkg.mExtras;
        if (sb == null) {
            throw new IllegalArgumentException("Unknown package: " + packageName);
        }
        final PermissionsState permissionsState = sb.getPermissionsState();
        final int flags = permissionsState.getPermissionFlags(name, userId);
        if ((flags & PackageManager.FLAG_PERMISSION_SYSTEM_FIXED) != 0) {
            throw new SecurityException("Cannot revoke system fixed permission: " + name + " for package: " + packageName);
        }
        if (bp.isDevelopment()) {
            // normal runtime permissions.  For now they apply to all users.
            if (permissionsState.revokeInstallPermission(bp) != PermissionsState.PERMISSION_OPERATION_FAILURE) {
                scheduleWriteSettingsLocked();
            }
            return;
        }
        if (permissionsState.revokeRuntimePermission(bp, userId) == PermissionsState.PERMISSION_OPERATION_FAILURE) {
            return;
        }
        mOnPermissionChangeListeners.onPermissionsChanged(pkg.applicationInfo.uid);
        // Critical, after this call app should never have the permission.
        mSettings.writeRuntimePermissionsForUserLPr(userId, true);
        appId = UserHandle.getAppId(pkg.applicationInfo.uid);
    }
    killUid(appId, userId, KILL_APP_REASON_PERMISSIONS_REVOKED);
}
#method_after
@Override
public void revokeRuntimePermission(String packageName, String name, int userId) {
    if (!sUserManager.exists(userId)) {
        Log.e(TAG, "No such user:" + userId);
        return;
    }
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.REVOKE_RUNTIME_PERMISSIONS, "revokeRuntimePermission");
    enforceCrossUserPermission(Binder.getCallingUid(), userId, true, /* requireFullPermission */
    true, /* checkShell */
    "revokeRuntimePermission");
    final int appId;
    synchronized (mPackages) {
        final PackageParser.Package pkg = mPackages.get(packageName);
        if (pkg == null) {
            throw new IllegalArgumentException("Unknown package: " + packageName);
        }
        final BasePermission bp = mSettings.mPermissions.get(name);
        if (bp == null) {
            throw new IllegalArgumentException("Unknown permission: " + name);
        }
        enforceDeclaredAsUsedAndRuntimeOrDevelopmentPermission(pkg, bp);
        // install permission's state is shared across all users.
        if (Build.PERMISSIONS_REVIEW_REQUIRED && pkg.applicationInfo.targetSdkVersion < Build.VERSION_CODES.M && bp.isRuntime()) {
            return;
        }
        SettingBase sb = (SettingBase) pkg.mExtras;
        if (sb == null) {
            throw new IllegalArgumentException("Unknown package: " + packageName);
        }
        final PermissionsState permissionsState = sb.getPermissionsState();
        final int flags = permissionsState.getPermissionFlags(name, userId);
        if ((flags & PackageManager.FLAG_PERMISSION_SYSTEM_FIXED) != 0) {
            throw new SecurityException("Cannot revoke system fixed permission " + name + " for package " + packageName);
        }
        if (bp.isDevelopment()) {
            // normal runtime permissions.  For now they apply to all users.
            if (permissionsState.revokeInstallPermission(bp) != PermissionsState.PERMISSION_OPERATION_FAILURE) {
                scheduleWriteSettingsLocked();
            }
            return;
        }
        if (permissionsState.revokeRuntimePermission(bp, userId) == PermissionsState.PERMISSION_OPERATION_FAILURE) {
            return;
        }
        mOnPermissionChangeListeners.onPermissionsChanged(pkg.applicationInfo.uid);
        // Critical, after this call app should never have the permission.
        mSettings.writeRuntimePermissionsForUserLPr(userId, true);
        appId = UserHandle.getAppId(pkg.applicationInfo.uid);
    }
    killUid(appId, userId, KILL_APP_REASON_PERMISSIONS_REVOKED);
}
#end_block

#method_before
@Override
public int getPermissionFlags(String name, String packageName, int userId) {
    if (!sUserManager.exists(userId)) {
        return 0;
    }
    enforceGrantRevokeRuntimePermissionPermissions("getPermissionFlags");
    enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "getPermissionFlags");
    synchronized (mPackages) {
        final PackageParser.Package pkg = mPackages.get(packageName);
        if (pkg == null) {
            throw new IllegalArgumentException("Unknown package: " + packageName);
        }
        final BasePermission bp = mSettings.mPermissions.get(name);
        if (bp == null) {
            throw new IllegalArgumentException("Unknown permission: " + name);
        }
        SettingBase sb = (SettingBase) pkg.mExtras;
        if (sb == null) {
            throw new IllegalArgumentException("Unknown package: " + packageName);
        }
        PermissionsState permissionsState = sb.getPermissionsState();
        return permissionsState.getPermissionFlags(name, userId);
    }
}
#method_after
@Override
public int getPermissionFlags(String name, String packageName, int userId) {
    if (!sUserManager.exists(userId)) {
        return 0;
    }
    enforceGrantRevokeRuntimePermissionPermissions("getPermissionFlags");
    enforceCrossUserPermission(Binder.getCallingUid(), userId, true, /* requireFullPermission */
    false, /* checkShell */
    "getPermissionFlags");
    synchronized (mPackages) {
        final PackageParser.Package pkg = mPackages.get(packageName);
        if (pkg == null) {
            return 0;
        }
        final BasePermission bp = mSettings.mPermissions.get(name);
        if (bp == null) {
            return 0;
        }
        SettingBase sb = (SettingBase) pkg.mExtras;
        if (sb == null) {
            return 0;
        }
        PermissionsState permissionsState = sb.getPermissionsState();
        return permissionsState.getPermissionFlags(name, userId);
    }
}
#end_block

#method_before
@Override
public void updatePermissionFlags(String name, String packageName, int flagMask, int flagValues, int userId) {
    if (!sUserManager.exists(userId)) {
        return;
    }
    enforceGrantRevokeRuntimePermissionPermissions("updatePermissionFlags");
    enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "updatePermissionFlags");
    // Only the system can change these flags and nothing else.
    if (getCallingUid() != Process.SYSTEM_UID) {
        flagMask &= ~PackageManager.FLAG_PERMISSION_SYSTEM_FIXED;
        flagValues &= ~PackageManager.FLAG_PERMISSION_SYSTEM_FIXED;
        flagMask &= ~PackageManager.FLAG_PERMISSION_GRANTED_BY_DEFAULT;
        flagValues &= ~PackageManager.FLAG_PERMISSION_GRANTED_BY_DEFAULT;
    }
    synchronized (mPackages) {
        final PackageParser.Package pkg = mPackages.get(packageName);
        if (pkg == null) {
            throw new IllegalArgumentException("Unknown package: " + packageName);
        }
        final BasePermission bp = mSettings.mPermissions.get(name);
        if (bp == null) {
            throw new IllegalArgumentException("Unknown permission: " + name);
        }
        SettingBase sb = (SettingBase) pkg.mExtras;
        if (sb == null) {
            throw new IllegalArgumentException("Unknown package: " + packageName);
        }
        PermissionsState permissionsState = sb.getPermissionsState();
        boolean hadState = permissionsState.getRuntimePermissionState(name, userId) != null;
        if (permissionsState.updatePermissionFlags(bp, userId, flagMask, flagValues)) {
            // so figure out what permission changed and persist the change.
            if (permissionsState.getInstallPermissionState(name) != null) {
                scheduleWriteSettingsLocked();
            } else if (permissionsState.getRuntimePermissionState(name, userId) != null || hadState) {
                mSettings.writeRuntimePermissionsForUserLPr(userId, false);
            }
        }
    }
}
#method_after
@Override
public void updatePermissionFlags(String name, String packageName, int flagMask, int flagValues, int userId) {
    if (!sUserManager.exists(userId)) {
        return;
    }
    enforceGrantRevokeRuntimePermissionPermissions("updatePermissionFlags");
    enforceCrossUserPermission(Binder.getCallingUid(), userId, true, /* requireFullPermission */
    true, /* checkShell */
    "updatePermissionFlags");
    // Only the system can change these flags and nothing else.
    if (getCallingUid() != Process.SYSTEM_UID) {
        flagMask &= ~PackageManager.FLAG_PERMISSION_SYSTEM_FIXED;
        flagValues &= ~PackageManager.FLAG_PERMISSION_SYSTEM_FIXED;
        flagMask &= ~PackageManager.FLAG_PERMISSION_GRANTED_BY_DEFAULT;
        flagValues &= ~PackageManager.FLAG_PERMISSION_GRANTED_BY_DEFAULT;
        flagValues &= ~PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED;
    }
    synchronized (mPackages) {
        final PackageParser.Package pkg = mPackages.get(packageName);
        if (pkg == null) {
            throw new IllegalArgumentException("Unknown package: " + packageName);
        }
        final BasePermission bp = mSettings.mPermissions.get(name);
        if (bp == null) {
            throw new IllegalArgumentException("Unknown permission: " + name);
        }
        SettingBase sb = (SettingBase) pkg.mExtras;
        if (sb == null) {
            throw new IllegalArgumentException("Unknown package: " + packageName);
        }
        PermissionsState permissionsState = sb.getPermissionsState();
        boolean hadState = permissionsState.getRuntimePermissionState(name, userId) != null;
        if (permissionsState.updatePermissionFlags(bp, userId, flagMask, flagValues)) {
            // so figure out what permission changed and persist the change.
            if (permissionsState.getInstallPermissionState(name) != null) {
                scheduleWriteSettingsLocked();
            } else if (permissionsState.getRuntimePermissionState(name, userId) != null || hadState) {
                mSettings.writeRuntimePermissionsForUserLPr(userId, false);
            }
        }
    }
}
#end_block

#method_before
@Override
public void updatePermissionFlagsForAllApps(int flagMask, int flagValues, int userId) {
    if (!sUserManager.exists(userId)) {
        return;
    }
    enforceGrantRevokeRuntimePermissionPermissions("updatePermissionFlagsForAllApps");
    enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "updatePermissionFlagsForAllApps");
    // Only the system can change system fixed flags.
    if (getCallingUid() != Process.SYSTEM_UID) {
        flagMask &= ~PackageManager.FLAG_PERMISSION_SYSTEM_FIXED;
        flagValues &= ~PackageManager.FLAG_PERMISSION_SYSTEM_FIXED;
    }
    synchronized (mPackages) {
        boolean changed = false;
        final int packageCount = mPackages.size();
        for (int pkgIndex = 0; pkgIndex < packageCount; pkgIndex++) {
            final PackageParser.Package pkg = mPackages.valueAt(pkgIndex);
            SettingBase sb = (SettingBase) pkg.mExtras;
            if (sb == null) {
                continue;
            }
            PermissionsState permissionsState = sb.getPermissionsState();
            changed |= permissionsState.updatePermissionFlagsForAllPermissions(userId, flagMask, flagValues);
        }
        if (changed) {
            mSettings.writeRuntimePermissionsForUserLPr(userId, false);
        }
    }
}
#method_after
@Override
public void updatePermissionFlagsForAllApps(int flagMask, int flagValues, int userId) {
    if (!sUserManager.exists(userId)) {
        return;
    }
    enforceGrantRevokeRuntimePermissionPermissions("updatePermissionFlagsForAllApps");
    enforceCrossUserPermission(Binder.getCallingUid(), userId, true, /* requireFullPermission */
    true, /* checkShell */
    "updatePermissionFlagsForAllApps");
    // Only the system can change system fixed flags.
    if (getCallingUid() != Process.SYSTEM_UID) {
        flagMask &= ~PackageManager.FLAG_PERMISSION_SYSTEM_FIXED;
        flagValues &= ~PackageManager.FLAG_PERMISSION_SYSTEM_FIXED;
    }
    synchronized (mPackages) {
        boolean changed = false;
        final int packageCount = mPackages.size();
        for (int pkgIndex = 0; pkgIndex < packageCount; pkgIndex++) {
            final PackageParser.Package pkg = mPackages.valueAt(pkgIndex);
            SettingBase sb = (SettingBase) pkg.mExtras;
            if (sb == null) {
                continue;
            }
            PermissionsState permissionsState = sb.getPermissionsState();
            changed |= permissionsState.updatePermissionFlagsForAllPermissions(userId, flagMask, flagValues);
        }
        if (changed) {
            mSettings.writeRuntimePermissionsForUserLPr(userId, false);
        }
    }
}
#end_block

#method_before
@Override
public boolean shouldShowRequestPermissionRationale(String permissionName, String packageName, int userId) {
    if (UserHandle.getCallingUserId() != userId) {
        mContext.enforceCallingPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL, "canShowRequestPermissionRationale for user " + userId);
    }
    final int uid = getPackageUid(packageName, userId);
    if (UserHandle.getAppId(getCallingUid()) != UserHandle.getAppId(uid)) {
        return false;
    }
    if (checkPermission(permissionName, packageName, userId) == PackageManager.PERMISSION_GRANTED) {
        return false;
    }
    final int flags;
    final long identity = Binder.clearCallingIdentity();
    try {
        flags = getPermissionFlags(permissionName, packageName, userId);
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
    final int fixedFlags = PackageManager.FLAG_PERMISSION_SYSTEM_FIXED | PackageManager.FLAG_PERMISSION_POLICY_FIXED | PackageManager.FLAG_PERMISSION_USER_FIXED;
    if ((flags & fixedFlags) != 0) {
        return false;
    }
    return (flags & PackageManager.FLAG_PERMISSION_USER_SET) != 0;
}
#method_after
@Override
public boolean shouldShowRequestPermissionRationale(String permissionName, String packageName, int userId) {
    if (UserHandle.getCallingUserId() != userId) {
        mContext.enforceCallingPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL, "canShowRequestPermissionRationale for user " + userId);
    }
    final int uid = getPackageUid(packageName, MATCH_DEBUG_TRIAGED_MISSING, userId);
    if (UserHandle.getAppId(getCallingUid()) != UserHandle.getAppId(uid)) {
        return false;
    }
    if (checkPermission(permissionName, packageName, userId) == PackageManager.PERMISSION_GRANTED) {
        return false;
    }
    final int flags;
    final long identity = Binder.clearCallingIdentity();
    try {
        flags = getPermissionFlags(permissionName, packageName, userId);
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
    final int fixedFlags = PackageManager.FLAG_PERMISSION_SYSTEM_FIXED | PackageManager.FLAG_PERMISSION_POLICY_FIXED | PackageManager.FLAG_PERMISSION_USER_FIXED;
    if ((flags & fixedFlags) != 0) {
        return false;
    }
    return (flags & PackageManager.FLAG_PERMISSION_USER_SET) != 0;
}
#end_block

#method_before
@Override
public boolean isProtectedBroadcast(String actionName) {
    synchronized (mPackages) {
        return mProtectedBroadcasts.contains(actionName);
    }
}
#method_after
@Override
public boolean isProtectedBroadcast(String actionName) {
    synchronized (mPackages) {
        if (mProtectedBroadcasts.contains(actionName)) {
            return true;
        } else if (actionName != null) {
            // TODO: remove these terrible hacks
            if (actionName.startsWith("android.net.netmon.lingerExpired") || actionName.startsWith("com.android.server.sip.SipWakeupTimer") || actionName.startsWith("com.android.internal.telephony.data-reconnect") || actionName.startsWith("android.net.netmon.launchCaptivePortalApp")) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
@Override
public String[] getPackagesForUid(int uid) {
    final int userId = UserHandle.getUserId(uid);
    uid = UserHandle.getAppId(uid);
    // reader
    synchronized (mPackages) {
        Object obj = mSettings.getUserIdLPr(uid);
        if (obj instanceof SharedUserSetting) {
            final SharedUserSetting sus = (SharedUserSetting) obj;
            final List<String> pkgs = new ArrayList<String>();
            final Iterator<PackageSetting> it = sus.packages.iterator();
            while (it.hasNext()) {
                PackageSetting ps = it.next();
                if (ps.getInstalled(userId)) {
                    pkgs.add(ps.name);
                }
            }
            final String[] res = new String[pkgs.size()];
            return pkgs.toArray(res);
        } else if (obj instanceof PackageSetting) {
            final PackageSetting ps = (PackageSetting) obj;
            return new String[] { ps.name };
        }
    }
    return null;
}
#method_after
@Override
public String[] getPackagesForUid(int uid) {
    final int userId = UserHandle.getUserId(uid);
    uid = UserHandle.getAppId(uid);
    // reader
    synchronized (mPackages) {
        Object obj = mSettings.getUserIdLPr(uid);
        if (obj instanceof SharedUserSetting) {
            final SharedUserSetting sus = (SharedUserSetting) obj;
            final int N = sus.packages.size();
            String[] res = new String[N];
            final Iterator<PackageSetting> it = sus.packages.iterator();
            int i = 0;
            while (it.hasNext()) {
                PackageSetting ps = it.next();
                if (ps.getInstalled(userId)) {
                    res[i++] = ps.name;
                } else {
                    res = ArrayUtils.removeElement(String.class, res, res[i]);
                }
            }
            return res;
        } else if (obj instanceof PackageSetting) {
            final PackageSetting ps = (PackageSetting) obj;
            return new String[] { ps.name };
        }
    }
    return null;
}
#end_block

#method_before
@Override
public ResolveInfo resolveIntent(Intent intent, String resolvedType, int flags, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "resolve intent");
    List<ResolveInfo> query = queryIntentActivities(intent, resolvedType, flags, userId);
    return chooseBestActivity(intent, resolvedType, flags, query, userId);
}
#method_after
@Override
public ResolveInfo resolveIntent(Intent intent, String resolvedType, int flags, int userId) {
    try {
        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "resolveIntent");
        if (!sUserManager.exists(userId))
            return null;
        flags = updateFlagsForResolve(flags, userId, intent);
        enforceCrossUserPermission(Binder.getCallingUid(), userId, false, /*requireFullPermission*/
        false, /*checkShell*/
        "resolve intent");
        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "queryIntentActivities");
        final List<ResolveInfo> query = queryIntentActivitiesInternal(intent, resolvedType, flags, userId);
        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
        final ResolveInfo bestChoice = chooseBestActivity(intent, resolvedType, flags, query, userId);
        if (isEphemeralAllowed(intent, query, userId)) {
            Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "resolveEphemeral");
            final EphemeralResolveInfo ai = getEphemeralResolveInfo(intent, resolvedType, userId);
            if (ai != null) {
                if (DEBUG_EPHEMERAL) {
                    Slog.v(TAG, "Returning an EphemeralResolveInfo");
                }
                bestChoice.ephemeralInstaller = mEphemeralInstallerInfo;
                bestChoice.ephemeralResolveInfo = ai;
            }
            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
        }
        return bestChoice;
    } finally {
        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
    }
}
#end_block

#method_before
@Override
public void setLastChosenActivity(Intent intent, String resolvedType, int flags, IntentFilter filter, int match, ComponentName activity) {
    final int userId = UserHandle.getCallingUserId();
    if (DEBUG_PREFERRED) {
        Log.v(TAG, "setLastChosenActivity intent=" + intent + " resolvedType=" + resolvedType + " flags=" + flags + " filter=" + filter + " match=" + match + " activity=" + activity);
        filter.dump(new PrintStreamPrinter(System.out), "    ");
    }
    intent.setComponent(null);
    List<ResolveInfo> query = queryIntentActivities(intent, resolvedType, flags, userId);
    // Find any earlier preferred or last chosen entries and nuke them
    findPreferredActivity(intent, resolvedType, flags, query, 0, false, true, false, userId);
    // Add the new activity as the last chosen for this filter
    addPreferredActivityInternal(filter, match, null, activity, false, userId, "Setting last chosen");
}
#method_after
@Override
public void setLastChosenActivity(Intent intent, String resolvedType, int flags, IntentFilter filter, int match, ComponentName activity) {
    final int userId = UserHandle.getCallingUserId();
    if (DEBUG_PREFERRED) {
        Log.v(TAG, "setLastChosenActivity intent=" + intent + " resolvedType=" + resolvedType + " flags=" + flags + " filter=" + filter + " match=" + match + " activity=" + activity);
        filter.dump(new PrintStreamPrinter(System.out), "    ");
    }
    intent.setComponent(null);
    final List<ResolveInfo> query = queryIntentActivitiesInternal(intent, resolvedType, flags, userId);
    // Find any earlier preferred or last chosen entries and nuke them
    findPreferredActivity(intent, resolvedType, flags, query, 0, false, true, false, userId);
    // Add the new activity as the last chosen for this filter
    addPreferredActivityInternal(filter, match, null, activity, false, userId, "Setting last chosen");
}
#end_block

#method_before
@Override
public ResolveInfo getLastChosenActivity(Intent intent, String resolvedType, int flags) {
    final int userId = UserHandle.getCallingUserId();
    if (DEBUG_PREFERRED)
        Log.v(TAG, "Querying last chosen activity for " + intent);
    List<ResolveInfo> query = queryIntentActivities(intent, resolvedType, flags, userId);
    return findPreferredActivity(intent, resolvedType, flags, query, 0, false, false, false, userId);
}
#method_after
@Override
public ResolveInfo getLastChosenActivity(Intent intent, String resolvedType, int flags) {
    final int userId = UserHandle.getCallingUserId();
    if (DEBUG_PREFERRED)
        Log.v(TAG, "Querying last chosen activity for " + intent);
    final List<ResolveInfo> query = queryIntentActivitiesInternal(intent, resolvedType, flags, userId);
    return findPreferredActivity(intent, resolvedType, flags, query, 0, false, false, false, userId);
}
#end_block

#method_before
private ResolveInfo chooseBestActivity(Intent intent, String resolvedType, int flags, List<ResolveInfo> query, int userId) {
    if (query != null) {
        final int N = query.size();
        if (N == 1) {
            return query.get(0);
        } else if (N > 1) {
            final boolean debug = ((intent.getFlags() & Intent.FLAG_DEBUG_LOG_RESOLUTION) != 0);
            // If there is more than one activity with the same priority,
            // then let the user decide between them.
            ResolveInfo r0 = query.get(0);
            ResolveInfo r1 = query.get(1);
            if (DEBUG_INTENT_MATCHING || debug) {
                Slog.v(TAG, r0.activityInfo.name + "=" + r0.priority + " vs " + r1.activityInfo.name + "=" + r1.priority);
            }
            // default, then it is always desireable to pick it.
            if (r0.priority != r1.priority || r0.preferredOrder != r1.preferredOrder || r0.isDefault != r1.isDefault) {
                return query.get(0);
            }
            // If we have saved a preference for a preferred activity for
            // this Intent, use that.
            ResolveInfo ri = findPreferredActivity(intent, resolvedType, flags, query, r0.priority, true, false, debug, userId);
            if (ri != null) {
                return ri;
            }
            ri = new ResolveInfo(mResolveInfo);
            ri.activityInfo = new ActivityInfo(ri.activityInfo);
            ri.activityInfo.applicationInfo = new ApplicationInfo(ri.activityInfo.applicationInfo);
            if (userId != 0) {
                ri.activityInfo.applicationInfo.uid = UserHandle.getUid(userId, UserHandle.getAppId(ri.activityInfo.applicationInfo.uid));
            }
            // Make sure that the resolver is displayable in car mode
            if (ri.activityInfo.metaData == null)
                ri.activityInfo.metaData = new Bundle();
            ri.activityInfo.metaData.putBoolean(Intent.METADATA_DOCK_HOME, true);
            return ri;
        }
    }
    return null;
}
#method_after
private ResolveInfo chooseBestActivity(Intent intent, String resolvedType, int flags, List<ResolveInfo> query, int userId) {
    if (query != null) {
        final int N = query.size();
        if (N == 1) {
            return query.get(0);
        } else if (N > 1) {
            final boolean debug = ((intent.getFlags() & Intent.FLAG_DEBUG_LOG_RESOLUTION) != 0);
            // If there is more than one activity with the same priority,
            // then let the user decide between them.
            ResolveInfo r0 = query.get(0);
            ResolveInfo r1 = query.get(1);
            if (DEBUG_INTENT_MATCHING || debug) {
                Slog.v(TAG, r0.activityInfo.name + "=" + r0.priority + " vs " + r1.activityInfo.name + "=" + r1.priority);
            }
            // default, then it is always desirable to pick it.
            if (r0.priority != r1.priority || r0.preferredOrder != r1.preferredOrder || r0.isDefault != r1.isDefault) {
                return query.get(0);
            }
            // If we have saved a preference for a preferred activity for
            // this Intent, use that.
            ResolveInfo ri = findPreferredActivity(intent, resolvedType, flags, query, r0.priority, true, false, debug, userId);
            if (ri != null) {
                return ri;
            }
            ri = new ResolveInfo(mResolveInfo);
            ri.activityInfo = new ActivityInfo(ri.activityInfo);
            ri.activityInfo.labelRes = ResolverActivity.getLabelRes(intent.getAction());
            // If all of the options come from the same package, show the application's
            // label and icon instead of the generic resolver's.
            // Some calls like Intent.resolveActivityInfo query the ResolveInfo from here
            // and then throw away the ResolveInfo itself, meaning that the caller loses
            // the resolvePackageName. Therefore the activityInfo.labelRes above provides
            // a fallback for this case; we only set the target package's resources on
            // the ResolveInfo, not the ActivityInfo.
            final String intentPackage = intent.getPackage();
            if (!TextUtils.isEmpty(intentPackage) && allHavePackage(query, intentPackage)) {
                final ApplicationInfo appi = query.get(0).activityInfo.applicationInfo;
                ri.resolvePackageName = intentPackage;
                if (userNeedsBadging(userId)) {
                    ri.noResourceId = true;
                } else {
                    ri.icon = appi.icon;
                }
                ri.iconResourceId = appi.icon;
                ri.labelRes = appi.labelRes;
            }
            ri.activityInfo.applicationInfo = new ApplicationInfo(ri.activityInfo.applicationInfo);
            if (userId != 0) {
                ri.activityInfo.applicationInfo.uid = UserHandle.getUid(userId, UserHandle.getAppId(ri.activityInfo.applicationInfo.uid));
            }
            // Make sure that the resolver is displayable in car mode
            if (ri.activityInfo.metaData == null)
                ri.activityInfo.metaData = new Bundle();
            ri.activityInfo.metaData.putBoolean(Intent.METADATA_DOCK_HOME, true);
            return ri;
        }
    }
    return null;
}
#end_block

#method_before
private ResolveInfo findPersistentPreferredActivityLP(Intent intent, String resolvedType, int flags, List<ResolveInfo> query, boolean debug, int userId) {
    final int N = query.size();
    PersistentPreferredIntentResolver ppir = mSettings.mPersistentPreferredActivities.get(userId);
    // Get the list of persistent preferred activities that handle the intent
    if (DEBUG_PREFERRED || debug)
        Slog.v(TAG, "Looking for presistent preferred activities...");
    List<PersistentPreferredActivity> pprefs = ppir != null ? ppir.queryIntent(intent, resolvedType, (flags & PackageManager.MATCH_DEFAULT_ONLY) != 0, userId) : null;
    if (pprefs != null && pprefs.size() > 0) {
        final int M = pprefs.size();
        for (int i = 0; i < M; i++) {
            final PersistentPreferredActivity ppa = pprefs.get(i);
            if (DEBUG_PREFERRED || debug) {
                Slog.v(TAG, "Checking PersistentPreferredActivity ds=" + (ppa.countDataSchemes() > 0 ? ppa.getDataScheme(0) : "<none>") + "\n  component=" + ppa.mComponent);
                ppa.dump(new LogPrinter(Log.VERBOSE, TAG, Log.LOG_ID_SYSTEM), "  ");
            }
            final ActivityInfo ai = getActivityInfo(ppa.mComponent, flags | PackageManager.GET_DISABLED_COMPONENTS, userId);
            if (DEBUG_PREFERRED || debug) {
                Slog.v(TAG, "Found persistent preferred activity:");
                if (ai != null) {
                    ai.dump(new LogPrinter(Log.VERBOSE, TAG, Log.LOG_ID_SYSTEM), "  ");
                } else {
                    Slog.v(TAG, "  null");
                }
            }
            if (ai == null) {
                // component is no longer known. Ignore it and do NOT remove it.
                continue;
            }
            for (int j = 0; j < N; j++) {
                final ResolveInfo ri = query.get(j);
                if (!ri.activityInfo.applicationInfo.packageName.equals(ai.applicationInfo.packageName)) {
                    continue;
                }
                if (!ri.activityInfo.name.equals(ai.name)) {
                    continue;
                }
                // Found a persistent preference that can handle the intent.
                if (DEBUG_PREFERRED || debug) {
                    Slog.v(TAG, "Returning persistent preferred activity: " + ri.activityInfo.packageName + "/" + ri.activityInfo.name);
                }
                return ri;
            }
        }
    }
    return null;
}
#method_after
private ResolveInfo findPersistentPreferredActivityLP(Intent intent, String resolvedType, int flags, List<ResolveInfo> query, boolean debug, int userId) {
    final int N = query.size();
    PersistentPreferredIntentResolver ppir = mSettings.mPersistentPreferredActivities.get(userId);
    // Get the list of persistent preferred activities that handle the intent
    if (DEBUG_PREFERRED || debug)
        Slog.v(TAG, "Looking for presistent preferred activities...");
    List<PersistentPreferredActivity> pprefs = ppir != null ? ppir.queryIntent(intent, resolvedType, (flags & PackageManager.MATCH_DEFAULT_ONLY) != 0, userId) : null;
    if (pprefs != null && pprefs.size() > 0) {
        final int M = pprefs.size();
        for (int i = 0; i < M; i++) {
            final PersistentPreferredActivity ppa = pprefs.get(i);
            if (DEBUG_PREFERRED || debug) {
                Slog.v(TAG, "Checking PersistentPreferredActivity ds=" + (ppa.countDataSchemes() > 0 ? ppa.getDataScheme(0) : "<none>") + "\n  component=" + ppa.mComponent);
                ppa.dump(new LogPrinter(Log.VERBOSE, TAG, Log.LOG_ID_SYSTEM), "  ");
            }
            final ActivityInfo ai = getActivityInfo(ppa.mComponent, flags | MATCH_DISABLED_COMPONENTS, userId);
            if (DEBUG_PREFERRED || debug) {
                Slog.v(TAG, "Found persistent preferred activity:");
                if (ai != null) {
                    ai.dump(new LogPrinter(Log.VERBOSE, TAG, Log.LOG_ID_SYSTEM), "  ");
                } else {
                    Slog.v(TAG, "  null");
                }
            }
            if (ai == null) {
                // component is no longer known. Ignore it and do NOT remove it.
                continue;
            }
            for (int j = 0; j < N; j++) {
                final ResolveInfo ri = query.get(j);
                if (!ri.activityInfo.applicationInfo.packageName.equals(ai.applicationInfo.packageName)) {
                    continue;
                }
                if (!ri.activityInfo.name.equals(ai.name)) {
                    continue;
                }
                // Found a persistent preference that can handle the intent.
                if (DEBUG_PREFERRED || debug) {
                    Slog.v(TAG, "Returning persistent preferred activity: " + ri.activityInfo.packageName + "/" + ri.activityInfo.name);
                }
                return ri;
            }
        }
    }
    return null;
}
#end_block

#method_before
ResolveInfo findPreferredActivity(Intent intent, String resolvedType, int flags, List<ResolveInfo> query, int priority, boolean always, boolean removeMatches, boolean debug, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    // writer
    synchronized (mPackages) {
        if (intent.getSelector() != null) {
            intent = intent.getSelector();
        }
        if (DEBUG_PREFERRED)
            intent.addFlags(Intent.FLAG_DEBUG_LOG_RESOLUTION);
        // Try to find a matching persistent preferred activity.
        ResolveInfo pri = findPersistentPreferredActivityLP(intent, resolvedType, flags, query, debug, userId);
        // If a persistent preferred activity matched, use it.
        if (pri != null) {
            return pri;
        }
        PreferredIntentResolver pir = mSettings.mPreferredActivities.get(userId);
        // Get the list of preferred activities that handle the intent
        if (DEBUG_PREFERRED || debug)
            Slog.v(TAG, "Looking for preferred activities...");
        List<PreferredActivity> prefs = pir != null ? pir.queryIntent(intent, resolvedType, (flags & PackageManager.MATCH_DEFAULT_ONLY) != 0, userId) : null;
        if (prefs != null && prefs.size() > 0) {
            boolean changed = false;
            try {
                // First figure out how good the original match set is.
                // We will only allow preferred activities that came
                // from the same match quality.
                int match = 0;
                if (DEBUG_PREFERRED || debug)
                    Slog.v(TAG, "Figuring out best match...");
                final int N = query.size();
                for (int j = 0; j < N; j++) {
                    final ResolveInfo ri = query.get(j);
                    if (DEBUG_PREFERRED || debug)
                        Slog.v(TAG, "Match for " + ri.activityInfo + ": 0x" + Integer.toHexString(match));
                    if (ri.match > match) {
                        match = ri.match;
                    }
                }
                if (DEBUG_PREFERRED || debug)
                    Slog.v(TAG, "Best match: 0x" + Integer.toHexString(match));
                match &= IntentFilter.MATCH_CATEGORY_MASK;
                final int M = prefs.size();
                for (int i = 0; i < M; i++) {
                    final PreferredActivity pa = prefs.get(i);
                    if (DEBUG_PREFERRED || debug) {
                        Slog.v(TAG, "Checking PreferredActivity ds=" + (pa.countDataSchemes() > 0 ? pa.getDataScheme(0) : "<none>") + "\n  component=" + pa.mPref.mComponent);
                        pa.dump(new LogPrinter(Log.VERBOSE, TAG, Log.LOG_ID_SYSTEM), "  ");
                    }
                    if (pa.mPref.mMatch != match) {
                        if (DEBUG_PREFERRED || debug)
                            Slog.v(TAG, "Skipping bad match " + Integer.toHexString(pa.mPref.mMatch));
                        continue;
                    }
                    // looking for, skip it.
                    if (always && !pa.mPref.mAlways) {
                        if (DEBUG_PREFERRED || debug)
                            Slog.v(TAG, "Skipping mAlways=false entry");
                        continue;
                    }
                    final ActivityInfo ai = getActivityInfo(pa.mPref.mComponent, flags | PackageManager.GET_DISABLED_COMPONENTS, userId);
                    if (DEBUG_PREFERRED || debug) {
                        Slog.v(TAG, "Found preferred activity:");
                        if (ai != null) {
                            ai.dump(new LogPrinter(Log.VERBOSE, TAG, Log.LOG_ID_SYSTEM), "  ");
                        } else {
                            Slog.v(TAG, "  null");
                        }
                    }
                    if (ai == null) {
                        // This previously registered preferred activity
                        // component is no longer known.  Most likely an update
                        // to the app was installed and in the new version this
                        // component no longer exists.  Clean it up by removing
                        // it from the preferred activities list, and skip it.
                        Slog.w(TAG, "Removing dangling preferred activity: " + pa.mPref.mComponent);
                        pir.removeFilter(pa);
                        changed = true;
                        continue;
                    }
                    for (int j = 0; j < N; j++) {
                        final ResolveInfo ri = query.get(j);
                        if (!ri.activityInfo.applicationInfo.packageName.equals(ai.applicationInfo.packageName)) {
                            continue;
                        }
                        if (!ri.activityInfo.name.equals(ai.name)) {
                            continue;
                        }
                        if (removeMatches) {
                            pir.removeFilter(pa);
                            changed = true;
                            if (DEBUG_PREFERRED) {
                                Slog.v(TAG, "Removing match " + pa.mPref.mComponent);
                            }
                            break;
                        }
                        // user their preference, if we're looking for an "always" type entry.
                        if (always && !pa.mPref.sameSet(query)) {
                            Slog.i(TAG, "Result set changed, dropping preferred activity for " + intent + " type " + resolvedType);
                            if (DEBUG_PREFERRED) {
                                Slog.v(TAG, "Removing preferred activity since set changed " + pa.mPref.mComponent);
                            }
                            pir.removeFilter(pa);
                            // Re-add the filter as a "last chosen" entry (!always)
                            PreferredActivity lastChosen = new PreferredActivity(pa, pa.mPref.mMatch, null, pa.mPref.mComponent, false);
                            pir.addFilter(lastChosen);
                            changed = true;
                            return null;
                        }
                        // Yay! Either the set matched or we're looking for the last chosen
                        if (DEBUG_PREFERRED || debug)
                            Slog.v(TAG, "Returning preferred activity: " + ri.activityInfo.packageName + "/" + ri.activityInfo.name);
                        return ri;
                    }
                }
            } finally {
                if (changed) {
                    if (DEBUG_PREFERRED) {
                        Slog.v(TAG, "Preferred activity bookkeeping changed; writing restrictions");
                    }
                    scheduleWritePackageRestrictionsLocked(userId);
                }
            }
        }
    }
    if (DEBUG_PREFERRED || debug)
        Slog.v(TAG, "No preferred activity to return");
    return null;
}
#method_after
ResolveInfo findPreferredActivity(Intent intent, String resolvedType, int flags, List<ResolveInfo> query, int priority, boolean always, boolean removeMatches, boolean debug, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    flags = updateFlagsForResolve(flags, userId, intent);
    // writer
    synchronized (mPackages) {
        if (intent.getSelector() != null) {
            intent = intent.getSelector();
        }
        if (DEBUG_PREFERRED)
            intent.addFlags(Intent.FLAG_DEBUG_LOG_RESOLUTION);
        // Try to find a matching persistent preferred activity.
        ResolveInfo pri = findPersistentPreferredActivityLP(intent, resolvedType, flags, query, debug, userId);
        // If a persistent preferred activity matched, use it.
        if (pri != null) {
            return pri;
        }
        PreferredIntentResolver pir = mSettings.mPreferredActivities.get(userId);
        // Get the list of preferred activities that handle the intent
        if (DEBUG_PREFERRED || debug)
            Slog.v(TAG, "Looking for preferred activities...");
        List<PreferredActivity> prefs = pir != null ? pir.queryIntent(intent, resolvedType, (flags & PackageManager.MATCH_DEFAULT_ONLY) != 0, userId) : null;
        if (prefs != null && prefs.size() > 0) {
            boolean changed = false;
            try {
                // First figure out how good the original match set is.
                // We will only allow preferred activities that came
                // from the same match quality.
                int match = 0;
                if (DEBUG_PREFERRED || debug)
                    Slog.v(TAG, "Figuring out best match...");
                final int N = query.size();
                for (int j = 0; j < N; j++) {
                    final ResolveInfo ri = query.get(j);
                    if (DEBUG_PREFERRED || debug)
                        Slog.v(TAG, "Match for " + ri.activityInfo + ": 0x" + Integer.toHexString(match));
                    if (ri.match > match) {
                        match = ri.match;
                    }
                }
                if (DEBUG_PREFERRED || debug)
                    Slog.v(TAG, "Best match: 0x" + Integer.toHexString(match));
                match &= IntentFilter.MATCH_CATEGORY_MASK;
                final int M = prefs.size();
                for (int i = 0; i < M; i++) {
                    final PreferredActivity pa = prefs.get(i);
                    if (DEBUG_PREFERRED || debug) {
                        Slog.v(TAG, "Checking PreferredActivity ds=" + (pa.countDataSchemes() > 0 ? pa.getDataScheme(0) : "<none>") + "\n  component=" + pa.mPref.mComponent);
                        pa.dump(new LogPrinter(Log.VERBOSE, TAG, Log.LOG_ID_SYSTEM), "  ");
                    }
                    if (pa.mPref.mMatch != match) {
                        if (DEBUG_PREFERRED || debug)
                            Slog.v(TAG, "Skipping bad match " + Integer.toHexString(pa.mPref.mMatch));
                        continue;
                    }
                    // looking for, skip it.
                    if (always && !pa.mPref.mAlways) {
                        if (DEBUG_PREFERRED || debug)
                            Slog.v(TAG, "Skipping mAlways=false entry");
                        continue;
                    }
                    final ActivityInfo ai = getActivityInfo(pa.mPref.mComponent, flags | MATCH_DISABLED_COMPONENTS | MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE, userId);
                    if (DEBUG_PREFERRED || debug) {
                        Slog.v(TAG, "Found preferred activity:");
                        if (ai != null) {
                            ai.dump(new LogPrinter(Log.VERBOSE, TAG, Log.LOG_ID_SYSTEM), "  ");
                        } else {
                            Slog.v(TAG, "  null");
                        }
                    }
                    if (ai == null) {
                        // This previously registered preferred activity
                        // component is no longer known.  Most likely an update
                        // to the app was installed and in the new version this
                        // component no longer exists.  Clean it up by removing
                        // it from the preferred activities list, and skip it.
                        Slog.w(TAG, "Removing dangling preferred activity: " + pa.mPref.mComponent);
                        pir.removeFilter(pa);
                        changed = true;
                        continue;
                    }
                    for (int j = 0; j < N; j++) {
                        final ResolveInfo ri = query.get(j);
                        if (!ri.activityInfo.applicationInfo.packageName.equals(ai.applicationInfo.packageName)) {
                            continue;
                        }
                        if (!ri.activityInfo.name.equals(ai.name)) {
                            continue;
                        }
                        if (removeMatches) {
                            pir.removeFilter(pa);
                            changed = true;
                            if (DEBUG_PREFERRED) {
                                Slog.v(TAG, "Removing match " + pa.mPref.mComponent);
                            }
                            break;
                        }
                        // user their preference, if we're looking for an "always" type entry.
                        if (always && !pa.mPref.sameSet(query)) {
                            Slog.i(TAG, "Result set changed, dropping preferred activity for " + intent + " type " + resolvedType);
                            if (DEBUG_PREFERRED) {
                                Slog.v(TAG, "Removing preferred activity since set changed " + pa.mPref.mComponent);
                            }
                            pir.removeFilter(pa);
                            // Re-add the filter as a "last chosen" entry (!always)
                            PreferredActivity lastChosen = new PreferredActivity(pa, pa.mPref.mMatch, null, pa.mPref.mComponent, false);
                            pir.addFilter(lastChosen);
                            changed = true;
                            return null;
                        }
                        // Yay! Either the set matched or we're looking for the last chosen
                        if (DEBUG_PREFERRED || debug)
                            Slog.v(TAG, "Returning preferred activity: " + ri.activityInfo.packageName + "/" + ri.activityInfo.name);
                        return ri;
                    }
                }
            } finally {
                if (changed) {
                    if (DEBUG_PREFERRED) {
                        Slog.v(TAG, "Preferred activity bookkeeping changed; writing restrictions");
                    }
                    scheduleWritePackageRestrictionsLocked(userId);
                }
            }
        }
    }
    if (DEBUG_PREFERRED || debug)
        Slog.v(TAG, "No preferred activity to return");
    return null;
}
#end_block

#method_before
@Override
public boolean canForwardTo(Intent intent, String resolvedType, int sourceUserId, int targetUserId) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL, null);
    List<CrossProfileIntentFilter> matches = getMatchingCrossProfileIntentFilters(intent, resolvedType, sourceUserId);
    if (matches != null) {
        int size = matches.size();
        for (int i = 0; i < size; i++) {
            if (matches.get(i).getTargetUserId() == targetUserId)
                return true;
        }
    }
    if (hasWebURI(intent)) {
        // cross-profile app linking works only towards the parent.
        final UserInfo parent = getProfileParent(sourceUserId);
        synchronized (mPackages) {
            CrossProfileDomainInfo xpDomainInfo = getCrossProfileDomainPreferredLpr(intent, resolvedType, 0, sourceUserId, parent.id);
            return xpDomainInfo != null;
        }
    }
    return false;
}
#method_after
@Override
public boolean canForwardTo(Intent intent, String resolvedType, int sourceUserId, int targetUserId) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL, null);
    List<CrossProfileIntentFilter> matches = getMatchingCrossProfileIntentFilters(intent, resolvedType, sourceUserId);
    if (matches != null) {
        int size = matches.size();
        for (int i = 0; i < size; i++) {
            if (matches.get(i).getTargetUserId() == targetUserId)
                return true;
        }
    }
    if (hasWebURI(intent)) {
        // cross-profile app linking works only towards the parent.
        final UserInfo parent = getProfileParent(sourceUserId);
        synchronized (mPackages) {
            int flags = updateFlagsForResolve(0, parent.id, intent);
            CrossProfileDomainInfo xpDomainInfo = getCrossProfileDomainPreferredLpr(intent, resolvedType, flags, sourceUserId, parent.id);
            return xpDomainInfo != null;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public List<ResolveInfo> queryIntentActivities(Intent intent, String resolvedType, int flags, int userId) {
    if (!sUserManager.exists(userId))
        return Collections.emptyList();
    enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "query intent activities");
    ComponentName comp = intent.getComponent();
    if (comp == null) {
        if (intent.getSelector() != null) {
            intent = intent.getSelector();
            comp = intent.getComponent();
        }
    }
    if (comp != null) {
        final List<ResolveInfo> list = new ArrayList<ResolveInfo>(1);
        final ActivityInfo ai = getActivityInfo(comp, flags, userId);
        if (ai != null) {
            final ResolveInfo ri = new ResolveInfo();
            ri.activityInfo = ai;
            list.add(ri);
        }
        return list;
    }
    // reader
    synchronized (mPackages) {
        final String pkgName = intent.getPackage();
        if (pkgName == null) {
            List<CrossProfileIntentFilter> matchingFilters = getMatchingCrossProfileIntentFilters(intent, resolvedType, userId);
            // Check for results that need to skip the current profile.
            ResolveInfo xpResolveInfo = querySkipCurrentProfileIntents(matchingFilters, intent, resolvedType, flags, userId);
            if (xpResolveInfo != null && isUserEnabled(xpResolveInfo.targetUserId)) {
                List<ResolveInfo> result = new ArrayList<ResolveInfo>(1);
                result.add(xpResolveInfo);
                return filterIfNotPrimaryUser(result, userId);
            }
            // Check for results in the current profile.
            List<ResolveInfo> result = mActivities.queryIntent(intent, resolvedType, flags, userId);
            // Check for cross profile results.
            xpResolveInfo = queryCrossProfileIntents(matchingFilters, intent, resolvedType, flags, userId);
            if (xpResolveInfo != null && isUserEnabled(xpResolveInfo.targetUserId)) {
                result.add(xpResolveInfo);
                Collections.sort(result, mResolvePrioritySorter);
            }
            result = filterIfNotPrimaryUser(result, userId);
            if (hasWebURI(intent)) {
                CrossProfileDomainInfo xpDomainInfo = null;
                final UserInfo parent = getProfileParent(userId);
                if (parent != null) {
                    xpDomainInfo = getCrossProfileDomainPreferredLpr(intent, resolvedType, flags, userId, parent.id);
                }
                if (xpDomainInfo != null) {
                    if (xpResolveInfo != null) {
                        // If we didn't remove it, the cross-profile ResolveInfo would be twice
                        // in the result.
                        result.remove(xpResolveInfo);
                    }
                    if (result.size() == 0) {
                        result.add(xpDomainInfo.resolveInfo);
                        return result;
                    }
                } else if (result.size() <= 1) {
                    return result;
                }
                result = filterCandidatesWithDomainPreferredActivitiesLPr(intent, flags, result, xpDomainInfo, userId);
                Collections.sort(result, mResolvePrioritySorter);
            }
            return result;
        }
        final PackageParser.Package pkg = mPackages.get(pkgName);
        if (pkg != null) {
            return filterIfNotPrimaryUser(mActivities.queryIntentForPackage(intent, resolvedType, flags, pkg.activities, userId), userId);
        }
        return new ArrayList<ResolveInfo>();
    }
}
#method_after
@Override
@NonNull
public ParceledListSlice<ResolveInfo> queryIntentActivities(Intent intent, String resolvedType, int flags, int userId) {
    try {
        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "queryIntentActivities");
        return new ParceledListSlice<>(queryIntentActivitiesInternal(intent, resolvedType, flags, userId));
    } finally {
        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
    }
}
#end_block

#method_before
private CrossProfileDomainInfo getCrossProfileDomainPreferredLpr(Intent intent, String resolvedType, int flags, int sourceUserId, int parentUserId) {
    if (!sUserManager.hasUserRestriction(UserManager.ALLOW_PARENT_PROFILE_APP_LINKING, sourceUserId)) {
        return null;
    }
    List<ResolveInfo> resultTargetUser = mActivities.queryIntent(intent, resolvedType, flags, parentUserId);
    if (resultTargetUser == null || resultTargetUser.isEmpty()) {
        return null;
    }
    CrossProfileDomainInfo result = null;
    int size = resultTargetUser.size();
    for (int i = 0; i < size; i++) {
        ResolveInfo riTargetUser = resultTargetUser.get(i);
        // those that handle all web uris.
        if (riTargetUser.handleAllWebDataURI) {
            continue;
        }
        String packageName = riTargetUser.activityInfo.packageName;
        PackageSetting ps = mSettings.mPackages.get(packageName);
        if (ps == null) {
            continue;
        }
        long verificationState = getDomainVerificationStatusLPr(ps, parentUserId);
        int status = (int) (verificationState >> 32);
        if (result == null) {
            result = new CrossProfileDomainInfo();
            result.resolveInfo = createForwardingResolveInfo(new IntentFilter(), sourceUserId, parentUserId);
            result.bestDomainVerificationStatus = status;
        } else {
            result.bestDomainVerificationStatus = bestDomainVerificationStatus(status, result.bestDomainVerificationStatus);
        }
    }
    // Don't consider matches with status NEVER across profiles.
    if (result != null && result.bestDomainVerificationStatus == INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_NEVER) {
        return null;
    }
    return result;
}
#method_after
private CrossProfileDomainInfo getCrossProfileDomainPreferredLpr(Intent intent, String resolvedType, int flags, int sourceUserId, int parentUserId) {
    if (!sUserManager.hasUserRestriction(UserManager.ALLOW_PARENT_PROFILE_APP_LINKING, sourceUserId)) {
        return null;
    }
    List<ResolveInfo> resultTargetUser = mActivities.queryIntent(intent, resolvedType, flags, parentUserId);
    if (resultTargetUser == null || resultTargetUser.isEmpty()) {
        return null;
    }
    CrossProfileDomainInfo result = null;
    int size = resultTargetUser.size();
    for (int i = 0; i < size; i++) {
        ResolveInfo riTargetUser = resultTargetUser.get(i);
        // those that handle all web uris.
        if (riTargetUser.handleAllWebDataURI) {
            continue;
        }
        String packageName = riTargetUser.activityInfo.packageName;
        PackageSetting ps = mSettings.mPackages.get(packageName);
        if (ps == null) {
            continue;
        }
        long verificationState = getDomainVerificationStatusLPr(ps, parentUserId);
        int status = (int) (verificationState >> 32);
        if (result == null) {
            result = new CrossProfileDomainInfo();
            result.resolveInfo = createForwardingResolveInfoUnchecked(new IntentFilter(), sourceUserId, parentUserId);
            result.bestDomainVerificationStatus = status;
        } else {
            result.bestDomainVerificationStatus = bestDomainVerificationStatus(status, result.bestDomainVerificationStatus);
        }
    }
    // Don't consider matches with status NEVER across profiles.
    if (result != null && result.bestDomainVerificationStatus == INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_NEVER) {
        return null;
    }
    return result;
}
#end_block

#method_before
private ResolveInfo querySkipCurrentProfileIntents(List<CrossProfileIntentFilter> matchingFilters, Intent intent, String resolvedType, int flags, int sourceUserId) {
    if (matchingFilters != null) {
        int size = matchingFilters.size();
        for (int i = 0; i < size; i++) {
            CrossProfileIntentFilter filter = matchingFilters.get(i);
            if ((filter.getFlags() & PackageManager.SKIP_CURRENT_PROFILE) != 0) {
                // Checking if there are activities in the target user that can handle the
                // intent.
                ResolveInfo resolveInfo = checkTargetCanHandle(filter, intent, resolvedType, flags, sourceUserId);
                if (resolveInfo != null) {
                    return resolveInfo;
                }
            }
        }
    }
    return null;
}
#method_after
private ResolveInfo querySkipCurrentProfileIntents(List<CrossProfileIntentFilter> matchingFilters, Intent intent, String resolvedType, int flags, int sourceUserId) {
    if (matchingFilters != null) {
        int size = matchingFilters.size();
        for (int i = 0; i < size; i++) {
            CrossProfileIntentFilter filter = matchingFilters.get(i);
            if ((filter.getFlags() & PackageManager.SKIP_CURRENT_PROFILE) != 0) {
                // Checking if there are activities in the target user that can handle the
                // intent.
                ResolveInfo resolveInfo = createForwardingResolveInfo(filter, intent, resolvedType, flags, sourceUserId);
                if (resolveInfo != null) {
                    return resolveInfo;
                }
            }
        }
    }
    return null;
}
#end_block

#method_before
private ResolveInfo queryCrossProfileIntents(List<CrossProfileIntentFilter> matchingFilters, Intent intent, String resolvedType, int flags, int sourceUserId) {
    if (matchingFilters != null) {
        // Two {@link CrossProfileIntentFilter}s can have the same targetUserId and
        // match the same intent. For performance reasons, it is better not to
        // run queryIntent twice for the same userId
        SparseBooleanArray alreadyTriedUserIds = new SparseBooleanArray();
        int size = matchingFilters.size();
        for (int i = 0; i < size; i++) {
            CrossProfileIntentFilter filter = matchingFilters.get(i);
            int targetUserId = filter.getTargetUserId();
            if ((filter.getFlags() & PackageManager.SKIP_CURRENT_PROFILE) == 0 && !alreadyTriedUserIds.get(targetUserId)) {
                // Checking if there are activities in the target user that can handle the
                // intent.
                ResolveInfo resolveInfo = checkTargetCanHandle(filter, intent, resolvedType, flags, sourceUserId);
                if (resolveInfo != null)
                    return resolveInfo;
                alreadyTriedUserIds.put(targetUserId, true);
            }
        }
    }
    return null;
}
#method_after
private ResolveInfo queryCrossProfileIntents(List<CrossProfileIntentFilter> matchingFilters, Intent intent, String resolvedType, int flags, int sourceUserId, boolean matchInCurrentProfile) {
    if (matchingFilters != null) {
        // Two {@link CrossProfileIntentFilter}s can have the same targetUserId and
        // match the same intent. For performance reasons, it is better not to
        // run queryIntent twice for the same userId
        SparseBooleanArray alreadyTriedUserIds = new SparseBooleanArray();
        int size = matchingFilters.size();
        for (int i = 0; i < size; i++) {
            CrossProfileIntentFilter filter = matchingFilters.get(i);
            int targetUserId = filter.getTargetUserId();
            boolean skipCurrentProfile = (filter.getFlags() & PackageManager.SKIP_CURRENT_PROFILE) != 0;
            boolean skipCurrentProfileIfNoMatchFound = (filter.getFlags() & PackageManager.ONLY_IF_NO_MATCH_FOUND) != 0;
            if (!skipCurrentProfile && !alreadyTriedUserIds.get(targetUserId) && (!skipCurrentProfileIfNoMatchFound || !matchInCurrentProfile)) {
                // Checking if there are activities in the target user that can handle the
                // intent.
                ResolveInfo resolveInfo = createForwardingResolveInfo(filter, intent, resolvedType, flags, sourceUserId);
                if (resolveInfo != null)
                    return resolveInfo;
                alreadyTriedUserIds.put(targetUserId, true);
            }
        }
    }
    return null;
}
#end_block

#method_before
private ResolveInfo createForwardingResolveInfo(IntentFilter filter, int sourceUserId, int targetUserId) {
    ResolveInfo forwardingResolveInfo = new ResolveInfo();
    String className;
    if (targetUserId == UserHandle.USER_OWNER) {
        className = FORWARD_INTENT_TO_USER_OWNER;
    } else {
        className = FORWARD_INTENT_TO_MANAGED_PROFILE;
    }
    ComponentName forwardingActivityComponentName = new ComponentName(mAndroidApplication.packageName, className);
    ActivityInfo forwardingActivityInfo = getActivityInfo(forwardingActivityComponentName, 0, sourceUserId);
    if (targetUserId == UserHandle.USER_OWNER) {
        forwardingActivityInfo.showUserIcon = UserHandle.USER_OWNER;
        forwardingResolveInfo.noResourceId = true;
    }
    forwardingResolveInfo.activityInfo = forwardingActivityInfo;
    forwardingResolveInfo.priority = 0;
    forwardingResolveInfo.preferredOrder = 0;
    forwardingResolveInfo.match = 0;
    forwardingResolveInfo.isDefault = true;
    forwardingResolveInfo.filter = filter;
    forwardingResolveInfo.targetUserId = targetUserId;
    return forwardingResolveInfo;
}
#method_after
private ResolveInfo createForwardingResolveInfo(CrossProfileIntentFilter filter, Intent intent, String resolvedType, int flags, int sourceUserId) {
    int targetUserId = filter.getTargetUserId();
    List<ResolveInfo> resultTargetUser = mActivities.queryIntent(intent, resolvedType, flags, targetUserId);
    if (resultTargetUser != null && isUserEnabled(targetUserId)) {
        // If all the matches in the target profile are suspended, return null.
        for (int i = resultTargetUser.size() - 1; i >= 0; i--) {
            if ((resultTargetUser.get(i).activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_SUSPENDED) == 0) {
                return createForwardingResolveInfoUnchecked(filter, sourceUserId, targetUserId);
            }
        }
    }
    return null;
}
#end_block

#method_before
@Override
public List<ResolveInfo> queryIntentActivityOptions(ComponentName caller, Intent[] specifics, String[] specificTypes, Intent intent, String resolvedType, int flags, int userId) {
    if (!sUserManager.exists(userId))
        return Collections.emptyList();
    enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "query intent activity options");
    final String resultsAction = intent.getAction();
    List<ResolveInfo> results = queryIntentActivities(intent, resolvedType, flags | PackageManager.GET_RESOLVED_FILTER, userId);
    if (DEBUG_INTENT_MATCHING) {
        Log.v(TAG, "Query " + intent + ": " + results);
    }
    int specificsPos = 0;
    int N;
    // duplicate items in the generic resolve list.
    if (specifics != null) {
        for (int i = 0; i < specifics.length; i++) {
            final Intent sintent = specifics[i];
            if (sintent == null) {
                continue;
            }
            if (DEBUG_INTENT_MATCHING) {
                Log.v(TAG, "Specific #" + i + ": " + sintent);
            }
            String action = sintent.getAction();
            if (resultsAction != null && resultsAction.equals(action)) {
                // If this action was explicitly requested, then don't
                // remove things that have it.
                action = null;
            }
            ResolveInfo ri = null;
            ActivityInfo ai = null;
            ComponentName comp = sintent.getComponent();
            if (comp == null) {
                ri = resolveIntent(sintent, specificTypes != null ? specificTypes[i] : null, flags, userId);
                if (ri == null) {
                    continue;
                }
                if (ri == mResolveInfo) {
                // ACK!  Must do something better with this.
                }
                ai = ri.activityInfo;
                comp = new ComponentName(ai.applicationInfo.packageName, ai.name);
            } else {
                ai = getActivityInfo(comp, flags, userId);
                if (ai == null) {
                    continue;
                }
            }
            // of this specific one, and remove them from the results.
            if (DEBUG_INTENT_MATCHING)
                Log.v(TAG, "Specific #" + i + ": " + ai);
            N = results.size();
            int j;
            for (j = specificsPos; j < N; j++) {
                ResolveInfo sri = results.get(j);
                if ((sri.activityInfo.name.equals(comp.getClassName()) && sri.activityInfo.applicationInfo.packageName.equals(comp.getPackageName())) || (action != null && sri.filter.matchAction(action))) {
                    results.remove(j);
                    if (DEBUG_INTENT_MATCHING)
                        Log.v(TAG, "Removing duplicate item from " + j + " due to specific " + specificsPos);
                    if (ri == null) {
                        ri = sri;
                    }
                    j--;
                    N--;
                }
            }
            // Add this specific item to its proper place.
            if (ri == null) {
                ri = new ResolveInfo();
                ri.activityInfo = ai;
            }
            results.add(specificsPos, ri);
            ri.specificIndex = i;
            specificsPos++;
        }
    }
    // Now we go through the remaining generic results and remove any
    // duplicate actions that are found here.
    N = results.size();
    for (int i = specificsPos; i < N - 1; i++) {
        final ResolveInfo rii = results.get(i);
        if (rii.filter == null) {
            continue;
        }
        // Iterate over all of the actions of this result's intent
        // filter...  typically this should be just one.
        final Iterator<String> it = rii.filter.actionsIterator();
        if (it == null) {
            continue;
        }
        while (it.hasNext()) {
            final String action = it.next();
            if (resultsAction != null && resultsAction.equals(action)) {
                // remove things that have it.
                continue;
            }
            for (int j = i + 1; j < N; j++) {
                final ResolveInfo rij = results.get(j);
                if (rij.filter != null && rij.filter.hasAction(action)) {
                    results.remove(j);
                    if (DEBUG_INTENT_MATCHING)
                        Log.v(TAG, "Removing duplicate item from " + j + " due to action " + action + " at " + i);
                    j--;
                    N--;
                }
            }
        }
        // so we don't have to marshall/unmarshall it.
        if ((flags & PackageManager.GET_RESOLVED_FILTER) == 0) {
            rii.filter = null;
        }
    }
    // Filter out the caller activity if so requested.
    if (caller != null) {
        N = results.size();
        for (int i = 0; i < N; i++) {
            ActivityInfo ainfo = results.get(i).activityInfo;
            if (caller.getPackageName().equals(ainfo.applicationInfo.packageName) && caller.getClassName().equals(ainfo.name)) {
                results.remove(i);
                break;
            }
        }
    }
    // marshall/unmarshall it.
    if ((flags & PackageManager.GET_RESOLVED_FILTER) == 0) {
        N = results.size();
        for (int i = 0; i < N; i++) {
            results.get(i).filter = null;
        }
    }
    if (DEBUG_INTENT_MATCHING)
        Log.v(TAG, "Result: " + results);
    return results;
}
#method_after
@Override
@NonNull
public ParceledListSlice<ResolveInfo> queryIntentActivityOptions(ComponentName caller, Intent[] specifics, String[] specificTypes, Intent intent, String resolvedType, int flags, int userId) {
    return new ParceledListSlice<>(queryIntentActivityOptionsInternal(caller, specifics, specificTypes, intent, resolvedType, flags, userId));
}
#end_block

#method_before
@Override
public List<ResolveInfo> queryIntentReceivers(Intent intent, String resolvedType, int flags, int userId) {
    if (!sUserManager.exists(userId))
        return Collections.emptyList();
    ComponentName comp = intent.getComponent();
    if (comp == null) {
        if (intent.getSelector() != null) {
            intent = intent.getSelector();
            comp = intent.getComponent();
        }
    }
    if (comp != null) {
        List<ResolveInfo> list = new ArrayList<ResolveInfo>(1);
        ActivityInfo ai = getReceiverInfo(comp, flags, userId);
        if (ai != null) {
            ResolveInfo ri = new ResolveInfo();
            ri.activityInfo = ai;
            list.add(ri);
        }
        return list;
    }
    // reader
    synchronized (mPackages) {
        String pkgName = intent.getPackage();
        if (pkgName == null) {
            return mReceivers.queryIntent(intent, resolvedType, flags, userId);
        }
        final PackageParser.Package pkg = mPackages.get(pkgName);
        if (pkg != null) {
            return mReceivers.queryIntentForPackage(intent, resolvedType, flags, pkg.receivers, userId);
        }
        return null;
    }
}
#method_after
@Override
@NonNull
public ParceledListSlice<ResolveInfo> queryIntentReceivers(Intent intent, String resolvedType, int flags, int userId) {
    return new ParceledListSlice<>(queryIntentReceiversInternal(intent, resolvedType, flags, userId));
}
#end_block

#method_before
@Override
public ResolveInfo resolveService(Intent intent, String resolvedType, int flags, int userId) {
    List<ResolveInfo> query = queryIntentServices(intent, resolvedType, flags, userId);
    if (!sUserManager.exists(userId))
        return null;
    if (query != null) {
        if (query.size() >= 1) {
            // just arbitrarily pick the first one.
            return query.get(0);
        }
    }
    return null;
}
#method_after
@Override
public ResolveInfo resolveService(Intent intent, String resolvedType, int flags, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    flags = updateFlagsForResolve(flags, userId, intent);
    List<ResolveInfo> query = queryIntentServicesInternal(intent, resolvedType, flags, userId);
    if (query != null) {
        if (query.size() >= 1) {
            // just arbitrarily pick the first one.
            return query.get(0);
        }
    }
    return null;
}
#end_block

#method_before
@Override
public List<ResolveInfo> queryIntentServices(Intent intent, String resolvedType, int flags, int userId) {
    if (!sUserManager.exists(userId))
        return Collections.emptyList();
    ComponentName comp = intent.getComponent();
    if (comp == null) {
        if (intent.getSelector() != null) {
            intent = intent.getSelector();
            comp = intent.getComponent();
        }
    }
    if (comp != null) {
        final List<ResolveInfo> list = new ArrayList<ResolveInfo>(1);
        final ServiceInfo si = getServiceInfo(comp, flags, userId);
        if (si != null) {
            final ResolveInfo ri = new ResolveInfo();
            ri.serviceInfo = si;
            list.add(ri);
        }
        return list;
    }
    // reader
    synchronized (mPackages) {
        String pkgName = intent.getPackage();
        if (pkgName == null) {
            return mServices.queryIntent(intent, resolvedType, flags, userId);
        }
        final PackageParser.Package pkg = mPackages.get(pkgName);
        if (pkg != null) {
            return mServices.queryIntentForPackage(intent, resolvedType, flags, pkg.services, userId);
        }
        return null;
    }
}
#method_after
@Override
@NonNull
public ParceledListSlice<ResolveInfo> queryIntentServices(Intent intent, String resolvedType, int flags, int userId) {
    return new ParceledListSlice<>(queryIntentServicesInternal(intent, resolvedType, flags, userId));
}
#end_block

#method_before
@Override
public List<ResolveInfo> queryIntentContentProviders(Intent intent, String resolvedType, int flags, int userId) {
    if (!sUserManager.exists(userId))
        return Collections.emptyList();
    ComponentName comp = intent.getComponent();
    if (comp == null) {
        if (intent.getSelector() != null) {
            intent = intent.getSelector();
            comp = intent.getComponent();
        }
    }
    if (comp != null) {
        final List<ResolveInfo> list = new ArrayList<ResolveInfo>(1);
        final ProviderInfo pi = getProviderInfo(comp, flags, userId);
        if (pi != null) {
            final ResolveInfo ri = new ResolveInfo();
            ri.providerInfo = pi;
            list.add(ri);
        }
        return list;
    }
    // reader
    synchronized (mPackages) {
        String pkgName = intent.getPackage();
        if (pkgName == null) {
            return mProviders.queryIntent(intent, resolvedType, flags, userId);
        }
        final PackageParser.Package pkg = mPackages.get(pkgName);
        if (pkg != null) {
            return mProviders.queryIntentForPackage(intent, resolvedType, flags, pkg.providers, userId);
        }
        return null;
    }
}
#method_after
@Override
@NonNull
public ParceledListSlice<ResolveInfo> queryIntentContentProviders(Intent intent, String resolvedType, int flags, int userId) {
    return new ParceledListSlice<>(queryIntentContentProvidersInternal(intent, resolvedType, flags, userId));
}
#end_block

#method_before
@Override
public ParceledListSlice<PackageInfo> getInstalledPackages(int flags, int userId) {
    final boolean listUninstalled = (flags & PackageManager.GET_UNINSTALLED_PACKAGES) != 0;
    enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "get installed packages");
    // writer
    synchronized (mPackages) {
        ArrayList<PackageInfo> list;
        if (listUninstalled) {
            list = new ArrayList<PackageInfo>(mSettings.mPackages.size());
            for (PackageSetting ps : mSettings.mPackages.values()) {
                PackageInfo pi;
                if (ps.pkg != null) {
                    pi = generatePackageInfo(ps.pkg, flags, userId);
                } else {
                    pi = generatePackageInfoFromSettingsLPw(ps.name, flags, userId);
                }
                if (pi != null) {
                    list.add(pi);
                }
            }
        } else {
            list = new ArrayList<PackageInfo>(mPackages.size());
            for (PackageParser.Package p : mPackages.values()) {
                PackageInfo pi = generatePackageInfo(p, flags, userId);
                if (pi != null) {
                    list.add(pi);
                }
            }
        }
        return new ParceledListSlice<PackageInfo>(list);
    }
}
#method_after
@Override
public ParceledListSlice<PackageInfo> getInstalledPackages(int flags, int userId) {
    if (!sUserManager.exists(userId))
        return ParceledListSlice.emptyList();
    flags = updateFlagsForPackage(flags, userId, null);
    final boolean listUninstalled = (flags & MATCH_UNINSTALLED_PACKAGES) != 0;
    enforceCrossUserPermission(Binder.getCallingUid(), userId, true, /* requireFullPermission */
    false, /* checkShell */
    "get installed packages");
    // writer
    synchronized (mPackages) {
        ArrayList<PackageInfo> list;
        if (listUninstalled) {
            list = new ArrayList<PackageInfo>(mSettings.mPackages.size());
            for (PackageSetting ps : mSettings.mPackages.values()) {
                final PackageInfo pi;
                if (ps.pkg != null) {
                    pi = generatePackageInfo(ps, flags, userId);
                } else {
                    pi = generatePackageInfo(ps, flags, userId);
                }
                if (pi != null) {
                    list.add(pi);
                }
            }
        } else {
            list = new ArrayList<PackageInfo>(mPackages.size());
            for (PackageParser.Package p : mPackages.values()) {
                final PackageInfo pi = generatePackageInfo((PackageSetting) p.mExtras, flags, userId);
                if (pi != null) {
                    list.add(pi);
                }
            }
        }
        return new ParceledListSlice<PackageInfo>(list);
    }
}
#end_block

#method_before
private void addPackageHoldingPermissions(ArrayList<PackageInfo> list, PackageSetting ps, String[] permissions, boolean[] tmp, int flags, int userId) {
    int numMatch = 0;
    final PermissionsState permissionsState = ps.getPermissionsState();
    for (int i = 0; i < permissions.length; i++) {
        final String permission = permissions[i];
        if (permissionsState.hasPermission(permission, userId)) {
            tmp[i] = true;
            numMatch++;
        } else {
            tmp[i] = false;
        }
    }
    if (numMatch == 0) {
        return;
    }
    PackageInfo pi;
    if (ps.pkg != null) {
        pi = generatePackageInfo(ps.pkg, flags, userId);
    } else {
        pi = generatePackageInfoFromSettingsLPw(ps.name, flags, userId);
    }
    // skew across users/profiles.
    if (pi != null) {
        if ((flags & PackageManager.GET_PERMISSIONS) == 0) {
            if (numMatch == permissions.length) {
                pi.requestedPermissions = permissions;
            } else {
                pi.requestedPermissions = new String[numMatch];
                numMatch = 0;
                for (int i = 0; i < permissions.length; i++) {
                    if (tmp[i]) {
                        pi.requestedPermissions[numMatch] = permissions[i];
                        numMatch++;
                    }
                }
            }
        }
        list.add(pi);
    }
}
#method_after
private void addPackageHoldingPermissions(ArrayList<PackageInfo> list, PackageSetting ps, String[] permissions, boolean[] tmp, int flags, int userId) {
    int numMatch = 0;
    final PermissionsState permissionsState = ps.getPermissionsState();
    for (int i = 0; i < permissions.length; i++) {
        final String permission = permissions[i];
        if (permissionsState.hasPermission(permission, userId)) {
            tmp[i] = true;
            numMatch++;
        } else {
            tmp[i] = false;
        }
    }
    if (numMatch == 0) {
        return;
    }
    final PackageInfo pi;
    if (ps.pkg != null) {
        pi = generatePackageInfo(ps, flags, userId);
    } else {
        pi = generatePackageInfo(ps, flags, userId);
    }
    // skew across users/profiles.
    if (pi != null) {
        if ((flags & PackageManager.GET_PERMISSIONS) == 0) {
            if (numMatch == permissions.length) {
                pi.requestedPermissions = permissions;
            } else {
                pi.requestedPermissions = new String[numMatch];
                numMatch = 0;
                for (int i = 0; i < permissions.length; i++) {
                    if (tmp[i]) {
                        pi.requestedPermissions[numMatch] = permissions[i];
                        numMatch++;
                    }
                }
            }
        }
        list.add(pi);
    }
}
#end_block

#method_before
@Override
public ParceledListSlice<PackageInfo> getPackagesHoldingPermissions(String[] permissions, int flags, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    final boolean listUninstalled = (flags & PackageManager.GET_UNINSTALLED_PACKAGES) != 0;
    // writer
    synchronized (mPackages) {
        ArrayList<PackageInfo> list = new ArrayList<PackageInfo>();
        boolean[] tmpBools = new boolean[permissions.length];
        if (listUninstalled) {
            for (PackageSetting ps : mSettings.mPackages.values()) {
                addPackageHoldingPermissions(list, ps, permissions, tmpBools, flags, userId);
            }
        } else {
            for (PackageParser.Package pkg : mPackages.values()) {
                PackageSetting ps = (PackageSetting) pkg.mExtras;
                if (ps != null) {
                    addPackageHoldingPermissions(list, ps, permissions, tmpBools, flags, userId);
                }
            }
        }
        return new ParceledListSlice<PackageInfo>(list);
    }
}
#method_after
@Override
public ParceledListSlice<PackageInfo> getPackagesHoldingPermissions(String[] permissions, int flags, int userId) {
    if (!sUserManager.exists(userId))
        return ParceledListSlice.emptyList();
    flags = updateFlagsForPackage(flags, userId, permissions);
    final boolean listUninstalled = (flags & MATCH_UNINSTALLED_PACKAGES) != 0;
    // writer
    synchronized (mPackages) {
        ArrayList<PackageInfo> list = new ArrayList<PackageInfo>();
        boolean[] tmpBools = new boolean[permissions.length];
        if (listUninstalled) {
            for (PackageSetting ps : mSettings.mPackages.values()) {
                addPackageHoldingPermissions(list, ps, permissions, tmpBools, flags, userId);
            }
        } else {
            for (PackageParser.Package pkg : mPackages.values()) {
                PackageSetting ps = (PackageSetting) pkg.mExtras;
                if (ps != null) {
                    addPackageHoldingPermissions(list, ps, permissions, tmpBools, flags, userId);
                }
            }
        }
        return new ParceledListSlice<PackageInfo>(list);
    }
}
#end_block

#method_before
@Override
public ParceledListSlice<ApplicationInfo> getInstalledApplications(int flags, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    final boolean listUninstalled = (flags & PackageManager.GET_UNINSTALLED_PACKAGES) != 0;
    // writer
    synchronized (mPackages) {
        ArrayList<ApplicationInfo> list;
        if (listUninstalled) {
            list = new ArrayList<ApplicationInfo>(mSettings.mPackages.size());
            for (PackageSetting ps : mSettings.mPackages.values()) {
                ApplicationInfo ai;
                if (ps.pkg != null) {
                    ai = PackageParser.generateApplicationInfo(ps.pkg, flags, ps.readUserState(userId), userId);
                } else {
                    ai = generateApplicationInfoFromSettingsLPw(ps.name, flags, userId);
                }
                if (ai != null) {
                    list.add(ai);
                }
            }
        } else {
            list = new ArrayList<ApplicationInfo>(mPackages.size());
            for (PackageParser.Package p : mPackages.values()) {
                if (p.mExtras != null) {
                    ApplicationInfo ai = PackageParser.generateApplicationInfo(p, flags, ((PackageSetting) p.mExtras).readUserState(userId), userId);
                    if (ai != null) {
                        list.add(ai);
                    }
                }
            }
        }
        return new ParceledListSlice<ApplicationInfo>(list);
    }
}
#method_after
@Override
public ParceledListSlice<ApplicationInfo> getInstalledApplications(int flags, int userId) {
    if (!sUserManager.exists(userId))
        return ParceledListSlice.emptyList();
    flags = updateFlagsForApplication(flags, userId, null);
    final boolean listUninstalled = (flags & MATCH_UNINSTALLED_PACKAGES) != 0;
    // writer
    synchronized (mPackages) {
        ArrayList<ApplicationInfo> list;
        if (listUninstalled) {
            list = new ArrayList<ApplicationInfo>(mSettings.mPackages.size());
            for (PackageSetting ps : mSettings.mPackages.values()) {
                ApplicationInfo ai;
                if (ps.pkg != null) {
                    ai = PackageParser.generateApplicationInfo(ps.pkg, flags, ps.readUserState(userId), userId);
                } else {
                    ai = generateApplicationInfoFromSettingsLPw(ps.name, flags, userId);
                }
                if (ai != null) {
                    list.add(ai);
                }
            }
        } else {
            list = new ArrayList<ApplicationInfo>(mPackages.size());
            for (PackageParser.Package p : mPackages.values()) {
                if (p.mExtras != null) {
                    ApplicationInfo ai = PackageParser.generateApplicationInfo(p, flags, ((PackageSetting) p.mExtras).readUserState(userId), userId);
                    if (ai != null) {
                        list.add(ai);
                    }
                }
            }
        }
        return new ParceledListSlice<ApplicationInfo>(list);
    }
}
#end_block

#method_before
public List<ApplicationInfo> getPersistentApplications(int flags) {
    final ArrayList<ApplicationInfo> finalList = new ArrayList<ApplicationInfo>();
    // reader
    synchronized (mPackages) {
        final Iterator<PackageParser.Package> i = mPackages.values().iterator();
        final int userId = UserHandle.getCallingUserId();
        while (i.hasNext()) {
            final PackageParser.Package p = i.next();
            if (p.applicationInfo != null && (p.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) != 0 && (!mSafeMode || isSystemApp(p))) {
                PackageSetting ps = mSettings.mPackages.get(p.packageName);
                if (ps != null) {
                    ApplicationInfo ai = PackageParser.generateApplicationInfo(p, flags, ps.readUserState(userId), userId);
                    if (ai != null) {
                        finalList.add(ai);
                    }
                }
            }
        }
    }
    return finalList;
}
#method_after
@Override
@NonNull
public ParceledListSlice<ApplicationInfo> getPersistentApplications(int flags) {
    return new ParceledListSlice<>(getPersistentApplicationsInternal(flags));
}
#end_block

#method_before
@Override
public ProviderInfo resolveContentProvider(String name, int flags, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    // reader
    synchronized (mPackages) {
        final PackageParser.Provider provider = mProvidersByAuthority.get(name);
        PackageSetting ps = provider != null ? mSettings.mPackages.get(provider.owner.packageName) : null;
        return ps != null && mSettings.isEnabledLPr(provider.info, flags, userId) && (!mSafeMode || (provider.info.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) ? PackageParser.generateProviderInfo(provider, flags, ps.readUserState(userId), userId) : null;
    }
}
#method_after
@Override
public ProviderInfo resolveContentProvider(String name, int flags, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    flags = updateFlagsForComponent(flags, userId, name);
    // reader
    synchronized (mPackages) {
        final PackageParser.Provider provider = mProvidersByAuthority.get(name);
        PackageSetting ps = provider != null ? mSettings.mPackages.get(provider.owner.packageName) : null;
        return ps != null && mSettings.isEnabledAndMatchLPr(provider.info, flags, userId) ? PackageParser.generateProviderInfo(provider, flags, ps.readUserState(userId), userId) : null;
    }
}
#end_block

#method_before
@Override
public ParceledListSlice<ProviderInfo> queryContentProviders(String processName, int uid, int flags) {
    ArrayList<ProviderInfo> finalList = null;
    // reader
    synchronized (mPackages) {
        final Iterator<PackageParser.Provider> i = mProviders.mProviders.values().iterator();
        final int userId = processName != null ? UserHandle.getUserId(uid) : UserHandle.getCallingUserId();
        while (i.hasNext()) {
            final PackageParser.Provider p = i.next();
            PackageSetting ps = mSettings.mPackages.get(p.owner.packageName);
            if (ps != null && p.info.authority != null && (processName == null || (p.info.processName.equals(processName) && UserHandle.isSameApp(p.info.applicationInfo.uid, uid))) && mSettings.isEnabledLPr(p.info, flags, userId) && (!mSafeMode || (p.info.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0)) {
                if (finalList == null) {
                    finalList = new ArrayList<ProviderInfo>(3);
                }
                ProviderInfo info = PackageParser.generateProviderInfo(p, flags, ps.readUserState(userId), userId);
                if (info != null) {
                    finalList.add(info);
                }
            }
        }
    }
    if (finalList != null) {
        Collections.sort(finalList, mProviderInitOrderSorter);
        return new ParceledListSlice<ProviderInfo>(finalList);
    }
    return null;
}
#method_after
@Override
@NonNull
public ParceledListSlice<ProviderInfo> queryContentProviders(String processName, int uid, int flags) {
    final int userId = processName != null ? UserHandle.getUserId(uid) : UserHandle.getCallingUserId();
    if (!sUserManager.exists(userId))
        return ParceledListSlice.emptyList();
    flags = updateFlagsForComponent(flags, userId, processName);
    ArrayList<ProviderInfo> finalList = null;
    // reader
    synchronized (mPackages) {
        final Iterator<PackageParser.Provider> i = mProviders.mProviders.values().iterator();
        while (i.hasNext()) {
            final PackageParser.Provider p = i.next();
            PackageSetting ps = mSettings.mPackages.get(p.owner.packageName);
            if (ps != null && p.info.authority != null && (processName == null || (p.info.processName.equals(processName) && UserHandle.isSameApp(p.info.applicationInfo.uid, uid))) && mSettings.isEnabledAndMatchLPr(p.info, flags, userId)) {
                if (finalList == null) {
                    finalList = new ArrayList<ProviderInfo>(3);
                }
                ProviderInfo info = PackageParser.generateProviderInfo(p, flags, ps.readUserState(userId), userId);
                if (info != null) {
                    finalList.add(info);
                }
            }
        }
    }
    if (finalList != null) {
        Collections.sort(finalList, mProviderInitOrderSorter);
        return new ParceledListSlice<ProviderInfo>(finalList);
    }
    return ParceledListSlice.emptyList();
}
#end_block

#method_before
@Override
public List<InstrumentationInfo> queryInstrumentation(String targetPackage, int flags) {
    ArrayList<InstrumentationInfo> finalList = new ArrayList<InstrumentationInfo>();
    // reader
    synchronized (mPackages) {
        final Iterator<PackageParser.Instrumentation> i = mInstrumentation.values().iterator();
        while (i.hasNext()) {
            final PackageParser.Instrumentation p = i.next();
            if (targetPackage == null || targetPackage.equals(p.info.targetPackage)) {
                InstrumentationInfo ii = PackageParser.generateInstrumentationInfo(p, flags);
                if (ii != null) {
                    finalList.add(ii);
                }
            }
        }
    }
    return finalList;
}
#method_after
@Override
@NonNull
public ParceledListSlice<InstrumentationInfo> queryInstrumentation(String targetPackage, int flags) {
    return new ParceledListSlice<>(queryInstrumentationInternal(targetPackage, flags));
}
#end_block

#method_before
private boolean createIdmapForPackagePairLI(PackageParser.Package pkg, PackageParser.Package opkg) {
    if (!opkg.mTrustedOverlay) {
        Slog.w(TAG, "Skipping target and overlay pair " + pkg.baseCodePath + " and " + opkg.baseCodePath + ": overlay not trusted");
        return false;
    }
    ArrayMap<String, PackageParser.Package> overlaySet = mOverlays.get(pkg.packageName);
    if (overlaySet == null) {
        Slog.e(TAG, "was about to create idmap for " + pkg.baseCodePath + " and " + opkg.baseCodePath + " but target package has no known overlays");
        return false;
    }
    final int sharedGid = UserHandle.getSharedAppGid(pkg.applicationInfo.uid);
    // TODO: generate idmap for split APKs
    if (mInstaller.idmap(pkg.baseCodePath, opkg.baseCodePath, sharedGid) != 0) {
        Slog.e(TAG, "Failed to generate idmap for " + pkg.baseCodePath + " and " + opkg.baseCodePath);
        return false;
    }
    PackageParser.Package[] overlayArray = overlaySet.values().toArray(new PackageParser.Package[0]);
    Comparator<PackageParser.Package> cmp = new Comparator<PackageParser.Package>() {

        public int compare(PackageParser.Package p1, PackageParser.Package p2) {
            return p1.mOverlayPriority - p2.mOverlayPriority;
        }
    };
    Arrays.sort(overlayArray, cmp);
    pkg.applicationInfo.resourceDirs = new String[overlayArray.length];
    int i = 0;
    for (PackageParser.Package p : overlayArray) {
        pkg.applicationInfo.resourceDirs[i++] = p.baseCodePath;
    }
    return true;
}
#method_after
private boolean createIdmapForPackagePairLI(PackageParser.Package pkg, PackageParser.Package opkg) {
    if (!opkg.mTrustedOverlay) {
        Slog.w(TAG, "Skipping target and overlay pair " + pkg.baseCodePath + " and " + opkg.baseCodePath + ": overlay not trusted");
        return false;
    }
    ArrayMap<String, PackageParser.Package> overlaySet = mOverlays.get(pkg.packageName);
    if (overlaySet == null) {
        Slog.e(TAG, "was about to create idmap for " + pkg.baseCodePath + " and " + opkg.baseCodePath + " but target package has no known overlays");
        return false;
    }
    final int sharedGid = UserHandle.getSharedAppGid(pkg.applicationInfo.uid);
    // TODO: generate idmap for split APKs
    try {
        mInstaller.idmap(pkg.baseCodePath, opkg.baseCodePath, sharedGid);
    } catch (InstallerException e) {
        Slog.e(TAG, "Failed to generate idmap for " + pkg.baseCodePath + " and " + opkg.baseCodePath);
        return false;
    }
    PackageParser.Package[] overlayArray = overlaySet.values().toArray(new PackageParser.Package[0]);
    Comparator<PackageParser.Package> cmp = new Comparator<PackageParser.Package>() {

        public int compare(PackageParser.Package p1, PackageParser.Package p2) {
            return p1.mOverlayPriority - p2.mOverlayPriority;
        }
    };
    Arrays.sort(overlayArray, cmp);
    pkg.applicationInfo.resourceDirs = new String[overlayArray.length];
    int i = 0;
    for (PackageParser.Package p : overlayArray) {
        pkg.applicationInfo.resourceDirs[i++] = p.baseCodePath;
    }
    return true;
}
#end_block

#method_before
private void scanDirLI(File dir, int parseFlags, int scanFlags, long currentTime) {
    final File[] files = dir.listFiles();
    if (ArrayUtils.isEmpty(files)) {
        Log.d(TAG, "No files in app dir " + dir);
        return;
    }
    if (DEBUG_PACKAGE_SCANNING) {
        Log.d(TAG, "Scanning app dir " + dir + " scanFlags=" + scanFlags + " flags=0x" + Integer.toHexString(parseFlags));
    }
    for (File file : files) {
        final boolean isPackage = (isApkFile(file) || file.isDirectory()) && !PackageInstallerService.isStageName(file.getName());
        if (!isPackage) {
            // Ignore entries which are not packages
            continue;
        }
        try {
            scanPackageLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK, scanFlags, currentTime, null);
        } catch (PackageManagerException e) {
            Slog.w(TAG, "Failed to parse " + file + ": " + e.getMessage());
            // Delete invalid userdata apps
            if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) == 0 && e.error == PackageManager.INSTALL_FAILED_INVALID_APK) {
                logCriticalInfo(Log.WARN, "Deleting invalid package at " + file);
                if (file.isDirectory()) {
                    mInstaller.rmPackageDir(file.getAbsolutePath());
                } else {
                    file.delete();
                }
            }
        }
    }
}
#method_after
private void scanDirLI(File dir, final int parseFlags, int scanFlags, long currentTime) {
    final File[] files = dir.listFiles();
    if (ArrayUtils.isEmpty(files)) {
        Log.d(TAG, "No files in app dir " + dir);
        return;
    }
    if (DEBUG_PACKAGE_SCANNING) {
        Log.d(TAG, "Scanning app dir " + dir + " scanFlags=" + scanFlags + " flags=0x" + Integer.toHexString(parseFlags));
    }
    for (File file : files) {
        final boolean isPackage = (isApkFile(file) || file.isDirectory()) && !PackageInstallerService.isStageName(file.getName());
        if (!isPackage) {
            // Ignore entries which are not packages
            continue;
        }
        try {
            scanPackageTracedLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK, scanFlags, currentTime, null);
        } catch (PackageManagerException e) {
            Slog.w(TAG, "Failed to parse " + file + ": " + e.getMessage());
            // Delete invalid userdata apps
            if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) == 0 && e.error == PackageManager.INSTALL_FAILED_INVALID_APK) {
                logCriticalInfo(Log.WARN, "Deleting invalid package at " + file);
                removeCodePathLI(file);
            }
        }
    }
}
#end_block

#method_before
private void collectCertificatesLI(PackageParser pp, PackageSetting ps, PackageParser.Package pkg, File srcFile, int parseFlags) throws PackageManagerException {
    if (ps != null && ps.codePath.equals(srcFile) && ps.timeStamp == srcFile.lastModified() && !isCompatSignatureUpdateNeeded(pkg) && !isRecoverSignatureUpdateNeeded(pkg)) {
        long mSigningKeySetId = ps.keySetData.getProperSigningKeySet();
        KeySetManagerService ksms = mSettings.mKeySetManagerService;
        ArraySet<PublicKey> signingKs;
        synchronized (mPackages) {
            signingKs = ksms.getPublicKeysFromKeySetLPr(mSigningKeySetId);
        }
        if (ps.signatures.mSignatures != null && ps.signatures.mSignatures.length != 0 && signingKs != null) {
            // Optimization: reuse the existing cached certificates
            // if the package appears to be unchanged.
            pkg.mSignatures = ps.signatures.mSignatures;
            pkg.mSigningKeys = signingKs;
            return;
        }
        Slog.w(TAG, "PackageSetting for " + ps.name + " is missing signatures.  Collecting certs again to recover them.");
    } else {
        Log.i(TAG, srcFile.toString() + " changed; collecting certs");
    }
    try {
        pp.collectCertificates(pkg, parseFlags);
        pp.collectManifestDigest(pkg);
    } catch (PackageParserException e) {
        throw PackageManagerException.from(e);
    }
}
#method_after
private void collectCertificatesLI(PackageSetting ps, PackageParser.Package pkg, File srcFile, final int policyFlags) throws PackageManagerException {
    if (ps != null && ps.codePath.equals(srcFile) && ps.timeStamp == srcFile.lastModified() && !isCompatSignatureUpdateNeeded(pkg) && !isRecoverSignatureUpdateNeeded(pkg)) {
        long mSigningKeySetId = ps.keySetData.getProperSigningKeySet();
        KeySetManagerService ksms = mSettings.mKeySetManagerService;
        ArraySet<PublicKey> signingKs;
        synchronized (mPackages) {
            signingKs = ksms.getPublicKeysFromKeySetLPr(mSigningKeySetId);
        }
        if (ps.signatures.mSignatures != null && ps.signatures.mSignatures.length != 0 && signingKs != null) {
            // Optimization: reuse the existing cached certificates
            // if the package appears to be unchanged.
            pkg.mSignatures = ps.signatures.mSignatures;
            pkg.mSigningKeys = signingKs;
            return;
        }
        Slog.w(TAG, "PackageSetting for " + ps.name + " is missing signatures.  Collecting certs again to recover them.");
    } else {
        Log.i(TAG, srcFile.toString() + " changed; collecting certs");
    }
    try {
        PackageParser.collectCertificates(pkg, policyFlags);
    } catch (PackageParserException e) {
        throw PackageManagerException.from(e);
    }
}
#end_block

#method_before
private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
    if (DEBUG_INSTALL)
        Slog.d(TAG, "Parsing: " + scanFile);
    parseFlags |= mDefParseFlags;
    PackageParser pp = new PackageParser();
    pp.setSeparateProcesses(mSeparateProcesses);
    pp.setOnlyCoreApps(mOnlyCore);
    pp.setDisplayMetrics(mMetrics);
    if ((scanFlags & SCAN_TRUSTED_OVERLAY) != 0) {
        parseFlags |= PackageParser.PARSE_TRUSTED_OVERLAY;
    }
    final PackageParser.Package pkg;
    try {
        pkg = pp.parsePackage(scanFile, parseFlags);
    } catch (PackageParserException e) {
        throw PackageManagerException.from(e);
    }
    PackageSetting ps = null;
    PackageSetting updatedPkg;
    // reader
    synchronized (mPackages) {
        // Look to see if we already know about this package.
        String oldName = mSettings.mRenamedPackages.get(pkg.packageName);
        if (pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(oldName)) {
            // This package has been renamed to its original name.  Let's
            // use that.
            ps = mSettings.peekPackageLPr(oldName);
        }
        // If there was no original package, see one for the real package name.
        if (ps == null) {
            ps = mSettings.peekPackageLPr(pkg.packageName);
        }
        // Check to see if this package could be hiding/updating a system
        // package.  Must look for it either under the original or real
        // package name depending on our state.
        updatedPkg = mSettings.getDisabledSystemPkgLPr(ps != null ? ps.name : pkg.packageName);
        if (DEBUG_INSTALL && updatedPkg != null)
            Slog.d(TAG, "updatedPkg = " + updatedPkg);
    }
    boolean updatedPkgBetter = false;
    // First check if this is a system package that may involve an update
    if (updatedPkg != null && (parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
        // it needs to drop FLAG_PRIVILEGED.
        if (locationIsPrivileged(scanFile)) {
            updatedPkg.pkgPrivateFlags |= ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;
        } else {
            updatedPkg.pkgPrivateFlags &= ~ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;
        }
        if (ps != null && !ps.codePath.equals(scanFile)) {
            // what to do.
            if (DEBUG_INSTALL)
                Slog.d(TAG, "Path changing from " + ps.codePath);
            if (pkg.mVersionCode <= ps.versionCode) {
                // Ignore entry. Skip it.
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "Package " + ps.name + " at " + scanFile + " ignored: updated version " + ps.versionCode + " better than this " + pkg.mVersionCode);
                if (!updatedPkg.codePath.equals(scanFile)) {
                    Slog.w(PackageManagerService.TAG, "Code path for hidden system pkg : " + ps.name + " changing from " + updatedPkg.codePathString + " to " + scanFile);
                    updatedPkg.codePath = scanFile;
                    updatedPkg.codePathString = scanFile.toString();
                    updatedPkg.resourcePath = scanFile;
                    updatedPkg.resourcePathString = scanFile.toString();
                }
                updatedPkg.pkg = pkg;
                throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE, "Package " + ps.name + " at " + scanFile + " ignored: updated version " + ps.versionCode + " better than this " + pkg.mVersionCode);
            } else {
                // writer
                synchronized (mPackages) {
                    // Just remove the loaded entries from package lists.
                    mPackages.remove(ps.name);
                }
                logCriticalInfo(Log.WARN, "Package " + ps.name + " at " + scanFile + " reverting from " + ps.codePathString + ": new version " + pkg.mVersionCode + " better than installed " + ps.versionCode);
                InstallArgs args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps), ps.codePathString, ps.resourcePathString, getAppDexInstructionSets(ps));
                synchronized (mInstallLock) {
                    args.cleanUpResourcesLI();
                }
                synchronized (mPackages) {
                    mSettings.enableSystemPackageLPw(ps.name);
                }
                updatedPkgBetter = true;
            }
        }
    }
    if (updatedPkg != null) {
        // An updated system app will not have the PARSE_IS_SYSTEM flag set
        // initially
        parseFlags |= PackageParser.PARSE_IS_SYSTEM;
        // flag set initially
        if ((updatedPkg.pkgPrivateFlags & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) {
            parseFlags |= PackageParser.PARSE_IS_PRIVILEGED;
        }
    }
    // Verify certificates against what was last scanned
    collectCertificatesLI(pp, ps, pkg, scanFile, parseFlags);
    /*
         * A new system app appeared, but we already had a non-system one of the
         * same name installed earlier.
         */
    boolean shouldHideSystemApp = false;
    if (updatedPkg == null && ps != null && (parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) != 0 && !isSystemApp(ps)) {
        /*
             * Check to make sure the signatures match first. If they don't,
             * wipe the installed application and its data.
             */
        if (compareSignatures(ps.signatures.mSignatures, pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
            logCriticalInfo(Log.WARN, "Package " + ps.name + " appeared on system, but" + " signatures don't match existing userdata copy; removing");
            deletePackageLI(pkg.packageName, null, true, null, null, 0, null, false);
            ps = null;
        } else {
            /*
                 * If the newly-added system app is an older version than the
                 * already installed version, hide it. It will be scanned later
                 * and re-added like an update.
                 */
            if (pkg.mVersionCode <= ps.versionCode) {
                shouldHideSystemApp = true;
                logCriticalInfo(Log.INFO, "Package " + ps.name + " appeared at " + scanFile + " but new version " + pkg.mVersionCode + " better than installed " + ps.versionCode + "; hiding system");
            } else {
                /*
                     * The newly found system app is a newer version that the
                     * one previously installed. Simply remove the
                     * already-installed application and replace it with our own
                     * while keeping the application data.
                     */
                logCriticalInfo(Log.WARN, "Package " + ps.name + " at " + scanFile + " reverting from " + ps.codePathString + ": new version " + pkg.mVersionCode + " better than installed " + ps.versionCode);
                InstallArgs args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps), ps.codePathString, ps.resourcePathString, getAppDexInstructionSets(ps));
                synchronized (mInstallLock) {
                    args.cleanUpResourcesLI();
                }
            }
        }
    }
    // TODO grab this value from PackageSettings
    if ((parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
        if (ps != null && !ps.codePath.equals(ps.resourcePath)) {
            parseFlags |= PackageParser.PARSE_FORWARD_LOCK;
        }
    }
    // TODO: extend to support forward-locked splits
    String resourcePath = null;
    String baseResourcePath = null;
    if ((parseFlags & PackageParser.PARSE_FORWARD_LOCK) != 0 && !updatedPkgBetter) {
        if (ps != null && ps.resourcePathString != null) {
            resourcePath = ps.resourcePathString;
            baseResourcePath = ps.resourcePathString;
        } else {
            // Should not happen at all. Just log an error.
            Slog.e(TAG, "Resource path not set for pkg : " + pkg.packageName);
        }
    } else {
        resourcePath = pkg.codePath;
        baseResourcePath = pkg.baseCodePath;
    }
    // Set application objects path explicitly.
    pkg.applicationInfo.volumeUuid = pkg.volumeUuid;
    pkg.applicationInfo.setCodePath(pkg.codePath);
    pkg.applicationInfo.setBaseCodePath(pkg.baseCodePath);
    pkg.applicationInfo.setSplitCodePaths(pkg.splitCodePaths);
    pkg.applicationInfo.setResourcePath(resourcePath);
    pkg.applicationInfo.setBaseResourcePath(baseResourcePath);
    pkg.applicationInfo.setSplitResourcePaths(pkg.splitCodePaths);
    // Note that we invoke the following method only if we are about to unpack an application
    PackageParser.Package scannedPkg = scanPackageLI(pkg, parseFlags, scanFlags | SCAN_UPDATE_SIGNATURE, currentTime, user);
    /*
         * If the system app should be overridden by a previously installed
         * data, hide the system app now and let the /data/app scan pick it up
         * again.
         */
    if (shouldHideSystemApp) {
        synchronized (mPackages) {
            mSettings.disableSystemPackageLPw(pkg.packageName);
        }
    }
    return scannedPkg;
}
#method_after
private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
    if (DEBUG_INSTALL)
        Slog.d(TAG, "Parsing: " + scanFile);
    PackageParser pp = new PackageParser();
    pp.setSeparateProcesses(mSeparateProcesses);
    pp.setOnlyCoreApps(mOnlyCore);
    pp.setDisplayMetrics(mMetrics);
    if ((scanFlags & SCAN_TRUSTED_OVERLAY) != 0) {
        parseFlags |= PackageParser.PARSE_TRUSTED_OVERLAY;
    }
    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "parsePackage");
    final PackageParser.Package pkg;
    try {
        pkg = pp.parsePackage(scanFile, parseFlags);
    } catch (PackageParserException e) {
        throw PackageManagerException.from(e);
    } finally {
        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
    }
    return scanPackageLI(pkg, scanFile, parseFlags, scanFlags, currentTime, user);
}
#end_block

#method_before
private PackageParser.Package scanPackageLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
    boolean success = false;
    try {
        final PackageParser.Package res = scanPackageDirtyLI(pkg, parseFlags, scanFlags, currentTime, user);
        success = true;
        return res;
    } finally {
        if (!success && (scanFlags & SCAN_DELETE_DATA_ON_FAILURES) != 0) {
            removeDataDirsLI(pkg.volumeUuid, pkg.packageName);
        }
    }
}
#method_after
private PackageParser.Package scanPackageLI(PackageParser.Package pkg, File scanFile, final int policyFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
    // install the package and its children.
    if ((scanFlags & SCAN_CHECK_ONLY) == 0) {
        if (pkg.childPackages != null && pkg.childPackages.size() > 0) {
            scanFlags |= SCAN_CHECK_ONLY;
        }
    } else {
        scanFlags &= ~SCAN_CHECK_ONLY;
    }
    // Scan the parent
    PackageParser.Package scannedPkg = scanPackageInternalLI(pkg, scanFile, policyFlags, scanFlags, currentTime, user);
    // Scan the children
    final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0;
    for (int i = 0; i < childCount; i++) {
        PackageParser.Package childPackage = pkg.childPackages.get(i);
        scanPackageInternalLI(childPackage, scanFile, policyFlags, scanFlags, currentTime, user);
    }
    if ((scanFlags & SCAN_CHECK_ONLY) != 0) {
        return scanPackageLI(pkg, scanFile, policyFlags, scanFlags, currentTime, user);
    }
    return scannedPkg;
}
#end_block

#method_before
@Override
public boolean performDexOptIfNeeded(String packageName, String instructionSet) {
    return performDexOpt(packageName, instructionSet, false);
}
#method_after
@Override
public boolean performDexOptIfNeeded(String packageName) {
    int dexOptStatus = performDexOptTraced(packageName, false, /* checkProfiles */
    getFullCompilerFilter(), false);
    return dexOptStatus != PackageDexOptimizer.DEX_OPT_FAILED;
}
#end_block

#method_before
public boolean performDexOpt(String packageName, String instructionSet, boolean backgroundDexopt) {
    boolean dexopt = mLazyDexOpt || backgroundDexopt;
    // Don't update usage if this is just a backgroundDexopt
    boolean updateUsage = !backgroundDexopt;
    if (!dexopt && !updateUsage) {
        // We aren't going to dexopt or update usage, so bail early.
        return false;
    }
    PackageParser.Package p;
    final String targetInstructionSet;
    synchronized (mPackages) {
        p = mPackages.get(packageName);
        if (p == null) {
            return false;
        }
        if (updateUsage) {
            p.mLastPackageUsageTimeInMills = System.currentTimeMillis();
        }
        mPackageUsage.write(false);
        if (!dexopt) {
            // We aren't going to dexopt, so bail early.
            return false;
        }
        targetInstructionSet = instructionSet != null ? instructionSet : getPrimaryInstructionSet(p.applicationInfo);
        if (p.mDexOptPerformed.contains(targetInstructionSet)) {
            return false;
        }
    }
    long callingId = Binder.clearCallingIdentity();
    try {
        synchronized (mInstallLock) {
            final String[] instructionSets = new String[] { targetInstructionSet };
            int result = mPackageDexOptimizer.performDexOpt(p, instructionSets, false, /* forceDex */
            false, /* defer */
            true, /* inclDependencies */
            true, /* boot complete */
            false);
            return result == PackageDexOptimizer.DEX_OPT_PERFORMED;
        }
    } finally {
        Binder.restoreCallingIdentity(callingId);
    }
}
#method_after
@Override
public boolean performDexOpt(String packageName, boolean checkProfiles, int compileReason, boolean force) {
    int dexOptStatus = performDexOptTraced(packageName, checkProfiles, getCompilerFilterForReason(compileReason), force);
    return dexOptStatus != PackageDexOptimizer.DEX_OPT_FAILED;
}
#end_block

#method_before
PackageParser.Package findSharedNonSystemLibrary(String libName) {
    synchronized (mPackages) {
        PackageManagerService.SharedLibraryEntry lib = mSharedLibraries.get(libName);
        if (lib != null && lib.apk != null) {
            return mPackages.get(lib.apk);
        }
    }
    return null;
}
#method_after
private PackageParser.Package findSharedNonSystemLibrary(String libName) {
    synchronized (mPackages) {
        PackageManagerService.SharedLibraryEntry lib = mSharedLibraries.get(libName);
        if (lib != null && lib.apk != null) {
            return mPackages.get(lib.apk);
        }
    }
    return null;
}
#end_block

#method_before
public void shutdown() {
    mPackageUsage.write(true);
}
#method_after
public void shutdown() {
    mPackageUsage.writeNow(mPackages);
    mCompilerStats.writeNow();
}
#end_block

#method_before
@Override
public void forceDexOpt(String packageName) {
    enforceSystemOrRoot("forceDexOpt");
    PackageParser.Package pkg;
    synchronized (mPackages) {
        pkg = mPackages.get(packageName);
        if (pkg == null) {
            throw new IllegalArgumentException("Missing package: " + packageName);
        }
    }
    synchronized (mInstallLock) {
        final String[] instructionSets = new String[] { getPrimaryInstructionSet(pkg.applicationInfo) };
        final int res = mPackageDexOptimizer.performDexOpt(pkg, instructionSets, true, /*forceDex*/
        false, /* defer */
        true, /* inclDependencies */
        true, /* boot complete */
        false);
        if (res != PackageDexOptimizer.DEX_OPT_PERFORMED) {
            throw new IllegalStateException("Failed to dexopt: " + res);
        }
    }
}
#method_after
@Override
public void forceDexOpt(String packageName) {
    enforceSystemOrRoot("forceDexOpt");
    PackageParser.Package pkg;
    synchronized (mPackages) {
        pkg = mPackages.get(packageName);
        if (pkg == null) {
            throw new IllegalArgumentException("Unknown package: " + packageName);
        }
    }
    synchronized (mInstallLock) {
        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "dexopt");
        // Whoever is calling forceDexOpt wants a fully compiled package.
        // Don't use profiles since that may cause compilation to be skipped.
        final int res = performDexOptInternalWithDependenciesLI(pkg, false, /* checkProfiles */
        getCompilerFilterForReason(REASON_FORCED_DEXOPT), true);
        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
        if (res != PackageDexOptimizer.DEX_OPT_PERFORMED) {
            throw new IllegalStateException("Failed to dexopt: " + res);
        }
    }
}
#end_block

#method_before
private PackageParser.Package scanPackageLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
    boolean success = false;
    try {
        final PackageParser.Package res = scanPackageDirtyLI(pkg, parseFlags, scanFlags, currentTime, user);
        success = true;
        return res;
    } finally {
        if (!success && (scanFlags & SCAN_DELETE_DATA_ON_FAILURES) != 0) {
            removeDataDirsLI(pkg.volumeUuid, pkg.packageName);
        }
    }
}
#method_after
private PackageParser.Package scanPackageLI(PackageParser.Package pkg, final int policyFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
    boolean success = false;
    try {
        final PackageParser.Package res = scanPackageDirtyLI(pkg, policyFlags, scanFlags, currentTime, user);
        success = true;
        return res;
    } finally {
        if (!success && (scanFlags & SCAN_DELETE_DATA_ON_FAILURES) != 0) {
            // DELETE_DATA_ON_FAILURES is only used by frozen paths
            destroyAppDataLIF(pkg, UserHandle.USER_ALL, StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE);
            destroyAppProfilesLIF(pkg, UserHandle.USER_ALL);
        }
    }
}
#end_block

#method_before
private PackageParser.Package scanPackageDirtyLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
    final File scanFile = new File(pkg.codePath);
    if (pkg.applicationInfo.getCodePath() == null || pkg.applicationInfo.getResourcePath() == null) {
        // Bail out. The resource and code paths haven't been set.
        throw new PackageManagerException(INSTALL_FAILED_INVALID_APK, "Code and resource paths haven't been set correctly");
    }
    if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
        pkg.applicationInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
    } else {
        // Only allow system apps to be flagged as core apps.
        pkg.coreApp = false;
    }
    if ((parseFlags & PackageParser.PARSE_IS_PRIVILEGED) != 0) {
        pkg.applicationInfo.privateFlags |= ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;
    }
    if (mCustomResolverComponentName != null && mCustomResolverComponentName.getPackageName().equals(pkg.packageName)) {
        setUpCustomResolverActivity(pkg);
    }
    if (pkg.packageName.equals("android")) {
        synchronized (mPackages) {
            if (mAndroidApplication != null) {
                Slog.w(TAG, "*************************************************");
                Slog.w(TAG, "Core android package being redefined.  Skipping.");
                Slog.w(TAG, " file=" + scanFile);
                Slog.w(TAG, "*************************************************");
                throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE, "Core android package being redefined.  Skipping.");
            }
            // Set up information for our fall-back user intent resolution activity.
            mPlatformPackage = pkg;
            pkg.mVersionCode = mSdkVersion;
            mAndroidApplication = pkg.applicationInfo;
            if (!mResolverReplaced) {
                mResolveActivity.applicationInfo = mAndroidApplication;
                mResolveActivity.name = ResolverActivity.class.getName();
                mResolveActivity.packageName = mAndroidApplication.packageName;
                mResolveActivity.processName = "system:ui";
                mResolveActivity.launchMode = ActivityInfo.LAUNCH_MULTIPLE;
                mResolveActivity.documentLaunchMode = ActivityInfo.DOCUMENT_LAUNCH_NEVER;
                mResolveActivity.flags = ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
                mResolveActivity.theme = R.style.Theme_Holo_Dialog_Alert;
                mResolveActivity.exported = true;
                mResolveActivity.enabled = true;
                mResolveInfo.activityInfo = mResolveActivity;
                mResolveInfo.priority = 0;
                mResolveInfo.preferredOrder = 0;
                mResolveInfo.match = 0;
                mResolveComponentName = new ComponentName(mAndroidApplication.packageName, mResolveActivity.name);
            }
        }
    }
    if (DEBUG_PACKAGE_SCANNING) {
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0)
            Log.d(TAG, "Scanning package " + pkg.packageName);
    }
    if (mPackages.containsKey(pkg.packageName) || mSharedLibraries.containsKey(pkg.packageName)) {
        throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE, "Application package " + pkg.packageName + " already installed.  Skipping duplicate.");
    }
    // user-installed version of the application will be ignored.
    if ((scanFlags & SCAN_REQUIRE_KNOWN) != 0) {
        if (mExpectingBetter.containsKey(pkg.packageName)) {
            logCriticalInfo(Log.WARN, "Relax SCAN_REQUIRE_KNOWN requirement for package " + pkg.packageName);
        } else {
            PackageSetting known = mSettings.peekPackageLPr(pkg.packageName);
            if (known != null) {
                if (DEBUG_PACKAGE_SCANNING) {
                    Log.d(TAG, "Examining " + pkg.codePath + " and requiring known paths " + known.codePathString + " & " + known.resourcePathString);
                }
                if (!pkg.applicationInfo.getCodePath().equals(known.codePathString) || !pkg.applicationInfo.getResourcePath().equals(known.resourcePathString)) {
                    throw new PackageManagerException(INSTALL_FAILED_PACKAGE_CHANGED, "Application package " + pkg.packageName + " found at " + pkg.applicationInfo.getCodePath() + " but expected at " + known.codePathString + "; ignoring.");
                }
            }
        }
    }
    // Initialize package source and resource directories
    File destCodeFile = new File(pkg.applicationInfo.getCodePath());
    File destResourceFile = new File(pkg.applicationInfo.getResourcePath());
    SharedUserSetting suid = null;
    PackageSetting pkgSetting = null;
    if (!isSystemApp(pkg)) {
        // Only system apps can use these features.
        pkg.mOriginalPackages = null;
        pkg.mRealPackage = null;
        pkg.mAdoptPermissions = null;
    }
    // writer
    synchronized (mPackages) {
        if (pkg.mSharedUserId != null) {
            suid = mSettings.getSharedUserLPw(pkg.mSharedUserId, 0, 0, true);
            if (suid == null) {
                throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE, "Creating application package " + pkg.packageName + " for shared user failed");
            }
            if (DEBUG_PACKAGE_SCANNING) {
                if ((parseFlags & PackageParser.PARSE_CHATTY) != 0)
                    Log.d(TAG, "Shared UserID " + pkg.mSharedUserId + " (uid=" + suid.userId + "): packages=" + suid.packages);
            }
        }
        // Check if we are renaming from an original package name.
        PackageSetting origPackage = null;
        String realName = null;
        if (pkg.mOriginalPackages != null) {
            // This package may need to be renamed to a previously
            // installed name.  Let's check on that...
            final String renamed = mSettings.mRenamedPackages.get(pkg.mRealPackage);
            if (pkg.mOriginalPackages.contains(renamed)) {
                // This package had originally been installed as the
                // original name, and we have already taken care of
                // transitioning to the new one.  Just update the new
                // one to continue using the old name.
                realName = pkg.mRealPackage;
                if (!pkg.packageName.equals(renamed)) {
                    // Callers into this function may have already taken
                    // care of renaming the package; only do it here if
                    // it is not already done.
                    pkg.setPackageName(renamed);
                }
            } else {
                for (int i = pkg.mOriginalPackages.size() - 1; i >= 0; i--) {
                    if ((origPackage = mSettings.peekPackageLPr(pkg.mOriginalPackages.get(i))) != null) {
                        // original name...  should we use it?
                        if (!verifyPackageUpdateLPr(origPackage, pkg)) {
                            // New package is not compatible with original.
                            origPackage = null;
                            continue;
                        } else if (origPackage.sharedUser != null) {
                            // Make sure uid is compatible between packages.
                            if (!origPackage.sharedUser.name.equals(pkg.mSharedUserId)) {
                                Slog.w(TAG, "Unable to migrate data from " + origPackage.name + " to " + pkg.packageName + ": old uid " + origPackage.sharedUser.name + " differs from " + pkg.mSharedUserId);
                                origPackage = null;
                                continue;
                            }
                        } else {
                            if (DEBUG_UPGRADE)
                                Log.v(TAG, "Renaming new package " + pkg.packageName + " to old name " + origPackage.name);
                        }
                        break;
                    }
                }
            }
        }
        if (mTransferedPackages.contains(pkg.packageName)) {
            Slog.w(TAG, "Package " + pkg.packageName + " was transferred to another, but its .apk remains");
        }
        // Just create the setting, don't add it yet. For already existing packages
        // the PkgSetting exists already and doesn't have to be created.
        pkgSetting = mSettings.getPackageLPw(pkg, origPackage, realName, suid, destCodeFile, destResourceFile, pkg.applicationInfo.nativeLibraryRootDir, pkg.applicationInfo.primaryCpuAbi, pkg.applicationInfo.secondaryCpuAbi, pkg.applicationInfo.flags, pkg.applicationInfo.privateFlags, user, false);
        if (pkgSetting == null) {
            throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE, "Creating application package " + pkg.packageName + " failed");
        }
        if (pkgSetting.origPackage != null) {
            // If we are first transitioning from an original package,
            // fix up the new package's name now.  We need to do this after
            // looking up the package under its new name, so getPackageLP
            // can take care of fiddling things correctly.
            pkg.setPackageName(origPackage.name);
            // File a report about this.
            String msg = "New package " + pkgSetting.realName + " renamed to replace old package " + pkgSetting.name;
            reportSettingsProblem(Log.WARN, msg);
            // Make a note of it.
            mTransferedPackages.add(origPackage.name);
            // No longer need to retain this.
            pkgSetting.origPackage = null;
        }
        if (realName != null) {
            // Make a note of it.
            mTransferedPackages.add(pkg.packageName);
        }
        if (mSettings.isDisabledSystemPackageLPr(pkg.packageName)) {
            pkg.applicationInfo.flags |= ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
        }
        if ((parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
            // Check all shared libraries and map to their actual file path.
            // We only do this here for apps not on a system dir, because those
            // are the only ones that can fail an install due to this.  We
            // will take care of the system apps by updating all of their
            // library paths after the scan is done.
            updateSharedLibrariesLPw(pkg, null);
        }
        if (mFoundPolicyFile) {
            SELinuxMMAC.assignSeinfoValue(pkg);
        }
        pkg.applicationInfo.uid = pkgSetting.appId;
        pkg.mExtras = pkgSetting;
        if (shouldCheckUpgradeKeySetLP(pkgSetting, scanFlags)) {
            if (checkUpgradeKeySetLP(pkgSetting, pkg)) {
                // We just determined the app is signed correctly, so bring
                // over the latest parsed certs.
                pkgSetting.signatures.mSignatures = pkg.mSignatures;
            } else {
                if ((parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
                    throw new PackageManagerException(INSTALL_FAILED_UPDATE_INCOMPATIBLE, "Package " + pkg.packageName + " upgrade keys do not match the " + "previously installed version");
                } else {
                    pkgSetting.signatures.mSignatures = pkg.mSignatures;
                    String msg = "System package " + pkg.packageName + " signature changed; retaining data.";
                    reportSettingsProblem(Log.WARN, msg);
                }
            }
        } else {
            try {
                verifySignaturesLP(pkgSetting, pkg);
                // We just determined the app is signed correctly, so bring
                // over the latest parsed certs.
                pkgSetting.signatures.mSignatures = pkg.mSignatures;
            } catch (PackageManagerException e) {
                if ((parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
                    throw e;
                }
                // The signature has changed, but this package is in the system
                // image...  let's recover!
                pkgSetting.signatures.mSignatures = pkg.mSignatures;
                // that unreasonable.
                if (pkgSetting.sharedUser != null) {
                    if (compareSignatures(pkgSetting.sharedUser.signatures.mSignatures, pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
                        throw new PackageManagerException(INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES, "Signature mismatch for shared user : " + pkgSetting.sharedUser);
                    }
                }
                // File a report about this.
                String msg = "System package " + pkg.packageName + " signature changed; retaining data.";
                reportSettingsProblem(Log.WARN, msg);
            }
        }
        // things that are installed.
        if ((scanFlags & SCAN_NEW_INSTALL) != 0) {
            final int N = pkg.providers.size();
            int i;
            for (i = 0; i < N; i++) {
                PackageParser.Provider p = pkg.providers.get(i);
                if (p.info.authority != null) {
                    String[] names = p.info.authority.split(";");
                    for (int j = 0; j < names.length; j++) {
                        if (mProvidersByAuthority.containsKey(names[j])) {
                            PackageParser.Provider other = mProvidersByAuthority.get(names[j]);
                            final String otherPackageName = ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : "?");
                            throw new PackageManagerException(INSTALL_FAILED_CONFLICTING_PROVIDER, "Can't install because provider name " + names[j] + " (in package " + pkg.applicationInfo.packageName + ") is already used by " + otherPackageName);
                        }
                    }
                }
            }
        }
        if (pkg.mAdoptPermissions != null) {
            // another package.
            for (int i = pkg.mAdoptPermissions.size() - 1; i >= 0; i--) {
                final String origName = pkg.mAdoptPermissions.get(i);
                final PackageSetting orig = mSettings.peekPackageLPr(origName);
                if (orig != null) {
                    if (verifyPackageUpdateLPr(orig, pkg)) {
                        Slog.i(TAG, "Adopting permissions from " + origName + " to " + pkg.packageName);
                        mSettings.transferPermissionsLPw(origName, pkg.packageName);
                    }
                }
            }
        }
    }
    final String pkgName = pkg.packageName;
    final long scanFileTime = scanFile.lastModified();
    final boolean forceDex = (scanFlags & SCAN_FORCE_DEX) != 0;
    pkg.applicationInfo.processName = fixProcessName(pkg.applicationInfo.packageName, pkg.applicationInfo.processName, pkg.applicationInfo.uid);
    File dataPath;
    if (mPlatformPackage == pkg) {
        // The system package is special.
        dataPath = new File(Environment.getDataDirectory(), "system");
        pkg.applicationInfo.dataDir = dataPath.getPath();
    } else {
        // This is a normal package, need to make its data directory.
        dataPath = Environment.getDataUserPackageDirectory(pkg.volumeUuid, UserHandle.USER_OWNER, pkg.packageName);
        boolean uidError = false;
        if (dataPath.exists()) {
            int currentUid = 0;
            try {
                StructStat stat = Os.stat(dataPath.getPath());
                currentUid = stat.st_uid;
            } catch (ErrnoException e) {
                Slog.e(TAG, "Couldn't stat path " + dataPath.getPath(), e);
            }
            // If we have mismatched owners for the data path, we have a problem.
            if (currentUid != pkg.applicationInfo.uid) {
                boolean recovered = false;
                if (currentUid == 0) {
                    // The directory somehow became owned by root.  Wow.
                    // This is probably because the system was stopped while
                    // installd was in the middle of messing with its libs
                    // directory.  Ask installd to fix that.
                    int ret = mInstaller.fixUid(pkg.volumeUuid, pkgName, pkg.applicationInfo.uid, pkg.applicationInfo.uid);
                    if (ret >= 0) {
                        recovered = true;
                        String msg = "Package " + pkg.packageName + " unexpectedly changed to uid 0; recovered to " + +pkg.applicationInfo.uid;
                        reportSettingsProblem(Log.WARN, msg);
                    }
                }
                if (!recovered && ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0 || (scanFlags & SCAN_BOOTING) != 0)) {
                    // If this is a system app, we can at least delete its
                    // current data so the application will still work.
                    int ret = removeDataDirsLI(pkg.volumeUuid, pkgName);
                    if (ret >= 0) {
                        // TODO: Kill the processes first
                        // Old data gone!
                        String prefix = (parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0 ? "System package " : "Third party package ";
                        String msg = prefix + pkg.packageName + " has changed from uid: " + currentUid + " to " + pkg.applicationInfo.uid + "; old data erased";
                        reportSettingsProblem(Log.WARN, msg);
                        recovered = true;
                        // And now re-install the app.
                        ret = createDataDirsLI(pkg.volumeUuid, pkgName, pkg.applicationInfo.uid, pkg.applicationInfo.seinfo);
                        if (ret == -1) {
                            // Ack should not happen!
                            msg = prefix + pkg.packageName + " could not have data directory re-created after delete.";
                            reportSettingsProblem(Log.WARN, msg);
                            throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE, msg);
                        }
                    }
                    if (!recovered) {
                        mHasSystemUidErrors = true;
                    }
                } else if (!recovered) {
                    // Abort, abort!
                    throw new PackageManagerException(INSTALL_FAILED_UID_CHANGED, "scanPackageLI");
                }
                if (!recovered) {
                    pkg.applicationInfo.dataDir = "/mismatched_uid/settings_" + pkg.applicationInfo.uid + "/fs_" + currentUid;
                    pkg.applicationInfo.nativeLibraryDir = pkg.applicationInfo.dataDir;
                    pkg.applicationInfo.nativeLibraryRootDir = pkg.applicationInfo.dataDir;
                    String msg = "Package " + pkg.packageName + " has mismatched uid: " + currentUid + " on disk, " + pkg.applicationInfo.uid + " in settings";
                    // writer
                    synchronized (mPackages) {
                        mSettings.mReadMessages.append(msg);
                        mSettings.mReadMessages.append('\n');
                        uidError = true;
                        if (!pkgSetting.uidError) {
                            reportSettingsProblem(Log.ERROR, msg);
                        }
                    }
                }
            }
            pkg.applicationInfo.dataDir = dataPath.getPath();
            if (mShouldRestoreconData) {
                Slog.i(TAG, "SELinux relabeling of " + pkg.packageName + " issued.");
                mInstaller.restoreconData(pkg.volumeUuid, pkg.packageName, pkg.applicationInfo.seinfo, pkg.applicationInfo.uid);
            }
        } else {
            if (DEBUG_PACKAGE_SCANNING) {
                if ((parseFlags & PackageParser.PARSE_CHATTY) != 0)
                    Log.v(TAG, "Want this data dir: " + dataPath);
            }
            // invoke installer to do the actual installation
            int ret = createDataDirsLI(pkg.volumeUuid, pkgName, pkg.applicationInfo.uid, pkg.applicationInfo.seinfo);
            if (ret < 0) {
                // Error from installer
                throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE, "Unable to create data dirs [errorCode=" + ret + "]");
            }
            if (dataPath.exists()) {
                pkg.applicationInfo.dataDir = dataPath.getPath();
            } else {
                Slog.w(TAG, "Unable to create data directory: " + dataPath);
                pkg.applicationInfo.dataDir = null;
            }
        }
        pkgSetting.uidError = uidError;
    }
    final String path = scanFile.getPath();
    final String cpuAbiOverride = deriveAbiOverride(pkg.cpuAbiOverride, pkgSetting);
    if ((scanFlags & SCAN_NEW_INSTALL) == 0) {
        derivePackageAbi(pkg, scanFile, cpuAbiOverride, true);
        // structure. Try to detect abi based on directory structure.
        if (isSystemApp(pkg) && !pkg.isUpdatedSystemApp() && pkg.applicationInfo.primaryCpuAbi == null) {
            setBundledAppAbisAndRoots(pkg, pkgSetting);
            setNativeLibraryPaths(pkg);
        }
    } else {
        if ((scanFlags & SCAN_MOVE) != 0) {
            // We haven't run dex-opt for this move (since we've moved the compiled output too)
            // but we already have this packages package info in the PackageSetting. We just
            // use that and derive the native library path based on the new codepath.
            pkg.applicationInfo.primaryCpuAbi = pkgSetting.primaryCpuAbiString;
            pkg.applicationInfo.secondaryCpuAbi = pkgSetting.secondaryCpuAbiString;
        }
        // Set native library paths again. For moves, the path will be updated based on the
        // ABIs we've determined above. For non-moves, the path will be updated based on the
        // ABIs we determined during compilation, but the path will depend on the final
        // package path (after the rename away from the stage path).
        setNativeLibraryPaths(pkg);
    }
    if (DEBUG_INSTALL)
        Slog.i(TAG, "Linking native library dir for " + path);
    final int[] userIds = sUserManager.getUserIds();
    synchronized (mInstallLock) {
        // if they already exist
        if (!TextUtils.isEmpty(pkg.volumeUuid)) {
            for (int userId : userIds) {
                if (userId != 0) {
                    mInstaller.createUserData(pkg.volumeUuid, pkg.packageName, UserHandle.getUid(userId, pkg.applicationInfo.uid), userId, pkg.applicationInfo.seinfo);
                }
            }
        }
        // this symlink for 64 bit libraries.
        if (pkg.applicationInfo.primaryCpuAbi != null && !VMRuntime.is64BitAbi(pkg.applicationInfo.primaryCpuAbi)) {
            final String nativeLibPath = pkg.applicationInfo.nativeLibraryDir;
            for (int userId : userIds) {
                if (mInstaller.linkNativeLibraryDirectory(pkg.volumeUuid, pkg.packageName, nativeLibPath, userId) < 0) {
                    throw new PackageManagerException(INSTALL_FAILED_INTERNAL_ERROR, "Failed linking native library dir (user=" + userId + ")");
                }
            }
        }
    }
    // the same UID correctly.
    if (mPlatformPackage == pkg) {
        pkg.applicationInfo.primaryCpuAbi = VMRuntime.getRuntime().is64Bit() ? Build.SUPPORTED_64_BIT_ABIS[0] : Build.SUPPORTED_32_BIT_ABIS[0];
    }
    // account.
    if ((scanFlags & SCAN_NO_DEX) == 0 && (scanFlags & SCAN_NEW_INSTALL) != 0) {
        if (cpuAbiOverride == null && pkgSetting.cpuAbiOverrideString != null) {
            Slog.w(TAG, "Ignoring persisted ABI override " + cpuAbiOverride + " for package: " + pkg.packageName);
        }
    }
    pkgSetting.primaryCpuAbiString = pkg.applicationInfo.primaryCpuAbi;
    pkgSetting.secondaryCpuAbiString = pkg.applicationInfo.secondaryCpuAbi;
    pkgSetting.cpuAbiOverrideString = cpuAbiOverride;
    // Copy the derived override back to the parsed package, so that we can
    // update the package settings accordingly.
    pkg.cpuAbiOverride = cpuAbiOverride;
    if (DEBUG_ABI_SELECTION) {
        Slog.d(TAG, "Resolved nativeLibraryRoot for " + pkg.applicationInfo.packageName + " to root=" + pkg.applicationInfo.nativeLibraryRootDir + ", isa=" + pkg.applicationInfo.nativeLibraryRootRequiresIsa);
    }
    // Push the derived path down into PackageSettings so we know what to
    // clean up at uninstall time.
    pkgSetting.legacyNativeLibraryPathString = pkg.applicationInfo.nativeLibraryRootDir;
    if (DEBUG_ABI_SELECTION) {
        Log.d(TAG, "Abis for package[" + pkg.packageName + "] are" + " primary=" + pkg.applicationInfo.primaryCpuAbi + " secondary=" + pkg.applicationInfo.secondaryCpuAbi);
    }
    if ((scanFlags & SCAN_BOOTING) == 0 && pkgSetting.sharedUser != null) {
        // We don't do this here during boot because we can do it all
        // at once after scanning all existing packages.
        // 
        // We also do this *before* we perform dexopt on this package, so that
        // we can avoid redundant dexopts, and also to make sure we've got the
        // code and package path correct.
        adjustCpuAbisForSharedUserLPw(pkgSetting.sharedUser.packages, pkg, forceDex, (scanFlags & SCAN_DEFER_DEX) != 0, true);
    }
    if ((scanFlags & SCAN_NO_DEX) == 0) {
        int result = mPackageDexOptimizer.performDexOpt(pkg, null, /* instruction sets */
        forceDex, (scanFlags & SCAN_DEFER_DEX) != 0, false, /* inclDependencies */
        (scanFlags & SCAN_BOOTING) == 0, false);
        if (result == PackageDexOptimizer.DEX_OPT_FAILED) {
            throw new PackageManagerException(INSTALL_FAILED_DEXOPT, "scanPackageLI");
        }
    }
    if (mFactoryTest && pkg.requestedPermissions.contains(android.Manifest.permission.FACTORY_TEST)) {
        pkg.applicationInfo.flags |= ApplicationInfo.FLAG_FACTORY_TEST;
    }
    ArrayList<PackageParser.Package> clientLibPkgs = null;
    // writer
    synchronized (mPackages) {
        if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
            // Only system apps can add new shared libraries.
            if (pkg.libraryNames != null) {
                for (int i = 0; i < pkg.libraryNames.size(); i++) {
                    String name = pkg.libraryNames.get(i);
                    boolean allowed = false;
                    if (pkg.isUpdatedSystemApp()) {
                        // New library entries can only be added through the
                        // system image.  This is important to get rid of a lot
                        // of nasty edge cases: for example if we allowed a non-
                        // system update of the app to add a library, then uninstalling
                        // the update would make the library go away, and assumptions
                        // we made such as through app install filtering would now
                        // have allowed apps on the device which aren't compatible
                        // with it.  Better to just have the restriction here, be
                        // conservative, and create many fewer cases that can negatively
                        // impact the user experience.
                        final PackageSetting sysPs = mSettings.getDisabledSystemPkgLPr(pkg.packageName);
                        if (sysPs.pkg != null && sysPs.pkg.libraryNames != null) {
                            for (int j = 0; j < sysPs.pkg.libraryNames.size(); j++) {
                                if (name.equals(sysPs.pkg.libraryNames.get(j))) {
                                    allowed = true;
                                    allowed = true;
                                    break;
                                }
                            }
                        }
                    } else {
                        allowed = true;
                    }
                    if (allowed) {
                        if (!mSharedLibraries.containsKey(name)) {
                            mSharedLibraries.put(name, new SharedLibraryEntry(null, pkg.packageName));
                        } else if (!name.equals(pkg.packageName)) {
                            Slog.w(TAG, "Package " + pkg.packageName + " library " + name + " already exists; skipping");
                        }
                    } else {
                        Slog.w(TAG, "Package " + pkg.packageName + " declares lib " + name + " that is not declared on system image; skipping");
                    }
                }
                if ((scanFlags & SCAN_BOOTING) == 0) {
                    // If we are not booting, we need to update any applications
                    // that are clients of our shared library.  If we are booting,
                    // this will all be done once the scan is complete.
                    clientLibPkgs = updateAllSharedLibrariesLPw(pkg);
                }
            }
        }
    }
    // result in some apps being broken.
    if (clientLibPkgs != null) {
        if ((scanFlags & SCAN_NO_DEX) == 0) {
            for (int i = 0; i < clientLibPkgs.size(); i++) {
                PackageParser.Package clientPkg = clientLibPkgs.get(i);
                int result = mPackageDexOptimizer.performDexOpt(clientPkg, null, /* instruction sets */
                forceDex, (scanFlags & SCAN_DEFER_DEX) != 0, false, (scanFlags & SCAN_BOOTING) == 0, false);
                if (result == PackageDexOptimizer.DEX_OPT_FAILED) {
                    throw new PackageManagerException(INSTALL_FAILED_DEXOPT, "scanPackageLI failed to dexopt clientLibPkgs");
                }
            }
        }
    }
    // version of the application while the new one gets installed.
    if ((scanFlags & SCAN_REPLACING) != 0) {
        killApplication(pkg.applicationInfo.packageName, pkg.applicationInfo.uid, "replace pkg");
    }
    // Also need to kill any apps that are dependent on the library.
    if (clientLibPkgs != null) {
        for (int i = 0; i < clientLibPkgs.size(); i++) {
            PackageParser.Package clientPkg = clientLibPkgs.get(i);
            killApplication(clientPkg.applicationInfo.packageName, clientPkg.applicationInfo.uid, "update lib");
        }
    }
    // Make sure we're not adding any bogus keyset info
    KeySetManagerService ksms = mSettings.mKeySetManagerService;
    ksms.assertScannedPackageValid(pkg);
    // writer
    synchronized (mPackages) {
        // We don't expect installation to fail beyond this point
        // Add the new setting to mSettings
        mSettings.insertPackageSettingLPw(pkgSetting, pkg);
        // Add the new setting to mPackages
        mPackages.put(pkg.applicationInfo.packageName, pkg);
        // Make sure we don't accidentally delete its data.
        final Iterator<PackageCleanItem> iter = mSettings.mPackagesToBeCleaned.iterator();
        while (iter.hasNext()) {
            PackageCleanItem item = iter.next();
            if (pkgName.equals(item.packageName)) {
                iter.remove();
            }
        }
        // Take care of first install / last update times.
        if (currentTime != 0) {
            if (pkgSetting.firstInstallTime == 0) {
                pkgSetting.firstInstallTime = pkgSetting.lastUpdateTime = currentTime;
            } else if ((scanFlags & SCAN_UPDATE_TIME) != 0) {
                pkgSetting.lastUpdateTime = currentTime;
            }
        } else if (pkgSetting.firstInstallTime == 0) {
            // We need *something*.  Take time time stamp of the file.
            pkgSetting.firstInstallTime = pkgSetting.lastUpdateTime = scanFileTime;
        } else if ((parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) != 0) {
            if (scanFileTime != pkgSetting.timeStamp) {
                // A package on the system image has changed; consider this
                // to be an update.
                pkgSetting.lastUpdateTime = scanFileTime;
            }
        }
        // Add the package's KeySets to the global KeySetManagerService
        ksms.addScannedPackageLPw(pkg);
        int N = pkg.providers.size();
        StringBuilder r = null;
        int i;
        for (i = 0; i < N; i++) {
            PackageParser.Provider p = pkg.providers.get(i);
            p.info.processName = fixProcessName(pkg.applicationInfo.processName, p.info.processName, pkg.applicationInfo.uid);
            mProviders.addProvider(p);
            p.syncable = p.info.isSyncable;
            if (p.info.authority != null) {
                String[] names = p.info.authority.split(";");
                p.info.authority = null;
                for (int j = 0; j < names.length; j++) {
                    if (j == 1 && p.syncable) {
                        // We only want the first authority for a provider to possibly be
                        // syncable, so if we already added this provider using a different
                        // authority clear the syncable flag. We copy the provider before
                        // changing it because the mProviders object contains a reference
                        // to a provider that we don't want to change.
                        // Only do this for the second authority since the resulting provider
                        // object can be the same for all future authorities for this provider.
                        p = new PackageParser.Provider(p);
                        p.syncable = false;
                    }
                    if (!mProvidersByAuthority.containsKey(names[j])) {
                        mProvidersByAuthority.put(names[j], p);
                        if (p.info.authority == null) {
                            p.info.authority = names[j];
                        } else {
                            p.info.authority = p.info.authority + ";" + names[j];
                        }
                        if (DEBUG_PACKAGE_SCANNING) {
                            if ((parseFlags & PackageParser.PARSE_CHATTY) != 0)
                                Log.d(TAG, "Registered content provider: " + names[j] + ", className = " + p.info.name + ", isSyncable = " + p.info.isSyncable);
                        }
                    } else {
                        PackageParser.Provider other = mProvidersByAuthority.get(names[j]);
                        Slog.w(TAG, "Skipping provider name " + names[j] + " (in package " + pkg.applicationInfo.packageName + "): name already used by " + ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : "?"));
                    }
                }
            }
            if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(p.info.name);
            }
        }
        if (r != null) {
            if (DEBUG_PACKAGE_SCANNING)
                Log.d(TAG, "  Providers: " + r);
        }
        N = pkg.services.size();
        r = null;
        for (i = 0; i < N; i++) {
            PackageParser.Service s = pkg.services.get(i);
            s.info.processName = fixProcessName(pkg.applicationInfo.processName, s.info.processName, pkg.applicationInfo.uid);
            mServices.addService(s);
            if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(s.info.name);
            }
        }
        if (r != null) {
            if (DEBUG_PACKAGE_SCANNING)
                Log.d(TAG, "  Services: " + r);
        }
        N = pkg.receivers.size();
        r = null;
        for (i = 0; i < N; i++) {
            PackageParser.Activity a = pkg.receivers.get(i);
            a.info.processName = fixProcessName(pkg.applicationInfo.processName, a.info.processName, pkg.applicationInfo.uid);
            mReceivers.addActivity(a, "receiver");
            if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(a.info.name);
            }
        }
        if (r != null) {
            if (DEBUG_PACKAGE_SCANNING)
                Log.d(TAG, "  Receivers: " + r);
        }
        N = pkg.activities.size();
        r = null;
        for (i = 0; i < N; i++) {
            PackageParser.Activity a = pkg.activities.get(i);
            a.info.processName = fixProcessName(pkg.applicationInfo.processName, a.info.processName, pkg.applicationInfo.uid);
            mActivities.addActivity(a, "activity");
            if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(a.info.name);
            }
        }
        if (r != null) {
            if (DEBUG_PACKAGE_SCANNING)
                Log.d(TAG, "  Activities: " + r);
        }
        N = pkg.permissionGroups.size();
        r = null;
        for (i = 0; i < N; i++) {
            PackageParser.PermissionGroup pg = pkg.permissionGroups.get(i);
            PackageParser.PermissionGroup cur = mPermissionGroups.get(pg.info.name);
            if (cur == null) {
                mPermissionGroups.put(pg.info.name, pg);
                if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                    if (r == null) {
                        r = new StringBuilder(256);
                    } else {
                        r.append(' ');
                    }
                    r.append(pg.info.name);
                }
            } else {
                Slog.w(TAG, "Permission group " + pg.info.name + " from package " + pg.info.packageName + " ignored: original from " + cur.info.packageName);
                if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                    if (r == null) {
                        r = new StringBuilder(256);
                    } else {
                        r.append(' ');
                    }
                    r.append("DUP:");
                    r.append(pg.info.name);
                }
            }
        }
        if (r != null) {
            if (DEBUG_PACKAGE_SCANNING)
                Log.d(TAG, "  Permission Groups: " + r);
        }
        N = pkg.permissions.size();
        r = null;
        for (i = 0; i < N; i++) {
            PackageParser.Permission p = pkg.permissions.get(i);
            // Assume by default that we did not install this permission into the system.
            p.info.flags &= ~PermissionInfo.FLAG_INSTALLED;
            // to be in a group defined by another app (before this had no implications).
            if (pkg.applicationInfo.targetSdkVersion > Build.VERSION_CODES.LOLLIPOP_MR1) {
                p.group = mPermissionGroups.get(p.info.group);
                // Warn for a permission in an unknown group.
                if (p.info.group != null && p.group == null) {
                    Slog.w(TAG, "Permission " + p.info.name + " from package " + p.info.packageName + " in an unknown group " + p.info.group);
                }
            }
            ArrayMap<String, BasePermission> permissionMap = p.tree ? mSettings.mPermissionTrees : mSettings.mPermissions;
            BasePermission bp = permissionMap.get(p.info.name);
            // Allow system apps to redefine non-system permissions
            if (bp != null && !Objects.equals(bp.sourcePackage, p.info.packageName)) {
                final boolean currentOwnerIsSystem = (bp.perm != null && isSystemApp(bp.perm.owner));
                if (isSystemApp(p.owner)) {
                    if (bp.type == BasePermission.TYPE_BUILTIN && bp.perm == null) {
                        // It's a built-in permission and no owner, take ownership now
                        bp.packageSetting = pkgSetting;
                        bp.perm = p;
                        bp.uid = pkg.applicationInfo.uid;
                        bp.sourcePackage = p.info.packageName;
                        p.info.flags |= PermissionInfo.FLAG_INSTALLED;
                    } else if (!currentOwnerIsSystem) {
                        String msg = "New decl " + p.owner + " of permission  " + p.info.name + " is system; overriding " + bp.sourcePackage;
                        reportSettingsProblem(Log.WARN, msg);
                        bp = null;
                    }
                }
            }
            if (bp == null) {
                bp = new BasePermission(p.info.name, p.info.packageName, BasePermission.TYPE_NORMAL);
                permissionMap.put(p.info.name, bp);
            }
            if (bp.perm == null) {
                if (bp.sourcePackage == null || bp.sourcePackage.equals(p.info.packageName)) {
                    BasePermission tree = findPermissionTreeLP(p.info.name);
                    if (tree == null || tree.sourcePackage.equals(p.info.packageName)) {
                        bp.packageSetting = pkgSetting;
                        bp.perm = p;
                        bp.uid = pkg.applicationInfo.uid;
                        bp.sourcePackage = p.info.packageName;
                        p.info.flags |= PermissionInfo.FLAG_INSTALLED;
                        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                            if (r == null) {
                                r = new StringBuilder(256);
                            } else {
                                r.append(' ');
                            }
                            r.append(p.info.name);
                        }
                    } else {
                        Slog.w(TAG, "Permission " + p.info.name + " from package " + p.info.packageName + " ignored: base tree " + tree.name + " is from package " + tree.sourcePackage);
                    }
                } else {
                    Slog.w(TAG, "Permission " + p.info.name + " from package " + p.info.packageName + " ignored: original from " + bp.sourcePackage);
                }
            } else if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append("DUP:");
                r.append(p.info.name);
            }
            if (bp.perm == p) {
                bp.protectionLevel = p.info.protectionLevel;
            }
        }
        if (r != null) {
            if (DEBUG_PACKAGE_SCANNING)
                Log.d(TAG, "  Permissions: " + r);
        }
        N = pkg.instrumentation.size();
        r = null;
        for (i = 0; i < N; i++) {
            PackageParser.Instrumentation a = pkg.instrumentation.get(i);
            a.info.packageName = pkg.applicationInfo.packageName;
            a.info.sourceDir = pkg.applicationInfo.sourceDir;
            a.info.publicSourceDir = pkg.applicationInfo.publicSourceDir;
            a.info.splitSourceDirs = pkg.applicationInfo.splitSourceDirs;
            a.info.splitPublicSourceDirs = pkg.applicationInfo.splitPublicSourceDirs;
            a.info.dataDir = pkg.applicationInfo.dataDir;
            // TODO: Update instrumentation.nativeLibraryDir as well ? Does it
            // need other information about the application, like the ABI and what not ?
            a.info.nativeLibraryDir = pkg.applicationInfo.nativeLibraryDir;
            mInstrumentation.put(a.getComponentName(), a);
            if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(a.info.name);
            }
        }
        if (r != null) {
            if (DEBUG_PACKAGE_SCANNING)
                Log.d(TAG, "  Instrumentation: " + r);
        }
        if (pkg.protectedBroadcasts != null) {
            N = pkg.protectedBroadcasts.size();
            for (i = 0; i < N; i++) {
                mProtectedBroadcasts.add(pkg.protectedBroadcasts.get(i));
            }
        }
        pkgSetting.setTimeStamp(scanFileTime);
        // Note: "android", ie framework-res.apk, is handled by native layers.
        if (pkg.mOverlayTarget != null) {
            // This is an overlay package.
            if (pkg.mOverlayTarget != null && !pkg.mOverlayTarget.equals("android")) {
                if (!mOverlays.containsKey(pkg.mOverlayTarget)) {
                    mOverlays.put(pkg.mOverlayTarget, new ArrayMap<String, PackageParser.Package>());
                }
                ArrayMap<String, PackageParser.Package> map = mOverlays.get(pkg.mOverlayTarget);
                map.put(pkg.packageName, pkg);
                PackageParser.Package orig = mPackages.get(pkg.mOverlayTarget);
                if (orig != null && !createIdmapForPackagePairLI(orig, pkg)) {
                    throw new PackageManagerException(INSTALL_FAILED_UPDATE_INCOMPATIBLE, "scanPackageLI failed to createIdmap");
                }
            }
        } else if (mOverlays.containsKey(pkg.packageName) && !pkg.packageName.equals("android")) {
            // This is a regular package, with one or more known overlay packages.
            createIdmapsForPackageLI(pkg);
        }
    }
    return pkg;
}
#method_after
private PackageParser.Package scanPackageDirtyLI(PackageParser.Package pkg, final int policyFlags, final int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
    final File scanFile = new File(pkg.codePath);
    if (pkg.applicationInfo.getCodePath() == null || pkg.applicationInfo.getResourcePath() == null) {
        // Bail out. The resource and code paths haven't been set.
        throw new PackageManagerException(INSTALL_FAILED_INVALID_APK, "Code and resource paths haven't been set correctly");
    }
    // Apply policy
    if ((policyFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
        pkg.applicationInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
        if (pkg.applicationInfo.isDirectBootAware()) {
            // we're direct boot aware; set for all components
            for (PackageParser.Service s : pkg.services) {
                s.info.encryptionAware = s.info.directBootAware = true;
            }
            for (PackageParser.Provider p : pkg.providers) {
                p.info.encryptionAware = p.info.directBootAware = true;
            }
            for (PackageParser.Activity a : pkg.activities) {
                a.info.encryptionAware = a.info.directBootAware = true;
            }
            for (PackageParser.Activity r : pkg.receivers) {
                r.info.encryptionAware = r.info.directBootAware = true;
            }
        }
    } else {
        // Only allow system apps to be flagged as core apps.
        pkg.coreApp = false;
        // clear flags not applicable to regular apps
        pkg.applicationInfo.privateFlags &= ~ApplicationInfo.PRIVATE_FLAG_DEFAULT_TO_DEVICE_PROTECTED_STORAGE;
        pkg.applicationInfo.privateFlags &= ~ApplicationInfo.PRIVATE_FLAG_DIRECT_BOOT_AWARE;
    }
    pkg.mTrustedOverlay = (policyFlags & PackageParser.PARSE_TRUSTED_OVERLAY) != 0;
    if ((policyFlags & PackageParser.PARSE_IS_PRIVILEGED) != 0) {
        pkg.applicationInfo.privateFlags |= ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;
    }
    if ((policyFlags & PackageParser.PARSE_ENFORCE_CODE) != 0) {
        enforceCodePolicy(pkg);
    }
    if (mCustomResolverComponentName != null && mCustomResolverComponentName.getPackageName().equals(pkg.packageName)) {
        setUpCustomResolverActivity(pkg);
    }
    if (pkg.packageName.equals("android")) {
        synchronized (mPackages) {
            if (mAndroidApplication != null) {
                Slog.w(TAG, "*************************************************");
                Slog.w(TAG, "Core android package being redefined.  Skipping.");
                Slog.w(TAG, " file=" + scanFile);
                Slog.w(TAG, "*************************************************");
                throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE, "Core android package being redefined.  Skipping.");
            }
            if ((scanFlags & SCAN_CHECK_ONLY) == 0) {
                // Set up information for our fall-back user intent resolution activity.
                mPlatformPackage = pkg;
                pkg.mVersionCode = mSdkVersion;
                mAndroidApplication = pkg.applicationInfo;
                if (!mResolverReplaced) {
                    mResolveActivity.applicationInfo = mAndroidApplication;
                    mResolveActivity.name = ResolverActivity.class.getName();
                    mResolveActivity.packageName = mAndroidApplication.packageName;
                    mResolveActivity.processName = "system:ui";
                    mResolveActivity.launchMode = ActivityInfo.LAUNCH_MULTIPLE;
                    mResolveActivity.documentLaunchMode = ActivityInfo.DOCUMENT_LAUNCH_NEVER;
                    mResolveActivity.flags = ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
                    mResolveActivity.theme = R.style.Theme_Material_Dialog_Alert;
                    mResolveActivity.exported = true;
                    mResolveActivity.enabled = true;
                    mResolveActivity.resizeMode = ActivityInfo.RESIZE_MODE_RESIZEABLE;
                    mResolveActivity.configChanges = ActivityInfo.CONFIG_SCREEN_SIZE | ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE | ActivityInfo.CONFIG_SCREEN_LAYOUT | ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_KEYBOARD | ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
                    mResolveInfo.activityInfo = mResolveActivity;
                    mResolveInfo.priority = 0;
                    mResolveInfo.preferredOrder = 0;
                    mResolveInfo.match = 0;
                    mResolveComponentName = new ComponentName(mAndroidApplication.packageName, mResolveActivity.name);
                }
            }
        }
    }
    if (DEBUG_PACKAGE_SCANNING) {
        if ((policyFlags & PackageParser.PARSE_CHATTY) != 0)
            Log.d(TAG, "Scanning package " + pkg.packageName);
    }
    synchronized (mPackages) {
        if (mPackages.containsKey(pkg.packageName) || mSharedLibraries.containsKey(pkg.packageName)) {
            throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE, "Application package " + pkg.packageName + " already installed.  Skipping duplicate.");
        }
        // user-installed version of the application will be ignored.
        if ((scanFlags & SCAN_REQUIRE_KNOWN) != 0) {
            if (mExpectingBetter.containsKey(pkg.packageName)) {
                logCriticalInfo(Log.WARN, "Relax SCAN_REQUIRE_KNOWN requirement for package " + pkg.packageName);
            } else {
                PackageSetting known = mSettings.peekPackageLPr(pkg.packageName);
                if (known != null) {
                    if (DEBUG_PACKAGE_SCANNING) {
                        Log.d(TAG, "Examining " + pkg.codePath + " and requiring known paths " + known.codePathString + " & " + known.resourcePathString);
                    }
                    if (!pkg.applicationInfo.getCodePath().equals(known.codePathString) || !pkg.applicationInfo.getResourcePath().equals(known.resourcePathString)) {
                        throw new PackageManagerException(INSTALL_FAILED_PACKAGE_CHANGED, "Application package " + pkg.packageName + " found at " + pkg.applicationInfo.getCodePath() + " but expected at " + known.codePathString + "; ignoring.");
                    }
                }
            }
        }
    }
    // Initialize package source and resource directories
    File destCodeFile = new File(pkg.applicationInfo.getCodePath());
    File destResourceFile = new File(pkg.applicationInfo.getResourcePath());
    SharedUserSetting suid = null;
    PackageSetting pkgSetting = null;
    if (!isSystemApp(pkg)) {
        // Only system apps can use these features.
        pkg.mOriginalPackages = null;
        pkg.mRealPackage = null;
        pkg.mAdoptPermissions = null;
    }
    // Getting the package setting may have a side-effect, so if we
    // are only checking if scan would succeed, stash a copy of the
    // old setting to restore at the end.
    PackageSetting nonMutatedPs = null;
    // writer
    synchronized (mPackages) {
        if (pkg.mSharedUserId != null) {
            suid = mSettings.getSharedUserLPw(pkg.mSharedUserId, 0, 0, true);
            if (suid == null) {
                throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE, "Creating application package " + pkg.packageName + " for shared user failed");
            }
            if (DEBUG_PACKAGE_SCANNING) {
                if ((policyFlags & PackageParser.PARSE_CHATTY) != 0)
                    Log.d(TAG, "Shared UserID " + pkg.mSharedUserId + " (uid=" + suid.userId + "): packages=" + suid.packages);
            }
        }
        // Check if we are renaming from an original package name.
        PackageSetting origPackage = null;
        String realName = null;
        if (pkg.mOriginalPackages != null) {
            // This package may need to be renamed to a previously
            // installed name.  Let's check on that...
            final String renamed = mSettings.mRenamedPackages.get(pkg.mRealPackage);
            if (pkg.mOriginalPackages.contains(renamed)) {
                // This package had originally been installed as the
                // original name, and we have already taken care of
                // transitioning to the new one.  Just update the new
                // one to continue using the old name.
                realName = pkg.mRealPackage;
                if (!pkg.packageName.equals(renamed)) {
                    // Callers into this function may have already taken
                    // care of renaming the package; only do it here if
                    // it is not already done.
                    pkg.setPackageName(renamed);
                }
            } else {
                for (int i = pkg.mOriginalPackages.size() - 1; i >= 0; i--) {
                    if ((origPackage = mSettings.peekPackageLPr(pkg.mOriginalPackages.get(i))) != null) {
                        // original name...  should we use it?
                        if (!verifyPackageUpdateLPr(origPackage, pkg)) {
                            // New package is not compatible with original.
                            origPackage = null;
                            continue;
                        } else if (origPackage.sharedUser != null) {
                            // Make sure uid is compatible between packages.
                            if (!origPackage.sharedUser.name.equals(pkg.mSharedUserId)) {
                                Slog.w(TAG, "Unable to migrate data from " + origPackage.name + " to " + pkg.packageName + ": old uid " + origPackage.sharedUser.name + " differs from " + pkg.mSharedUserId);
                                origPackage = null;
                                continue;
                            }
                        // TODO: Add case when shared user id is added [b/28144775]
                        } else {
                            if (DEBUG_UPGRADE)
                                Log.v(TAG, "Renaming new package " + pkg.packageName + " to old name " + origPackage.name);
                        }
                        break;
                    }
                }
            }
        }
        if (mTransferedPackages.contains(pkg.packageName)) {
            Slog.w(TAG, "Package " + pkg.packageName + " was transferred to another, but its .apk remains");
        }
        // See comments in nonMutatedPs declaration
        if ((scanFlags & SCAN_CHECK_ONLY) != 0) {
            PackageSetting foundPs = mSettings.peekPackageLPr(pkg.packageName);
            if (foundPs != null) {
                nonMutatedPs = new PackageSetting(foundPs);
            }
        }
        // Just create the setting, don't add it yet. For already existing packages
        // the PkgSetting exists already and doesn't have to be created.
        pkgSetting = mSettings.getPackageLPw(pkg, origPackage, realName, suid, destCodeFile, destResourceFile, pkg.applicationInfo.nativeLibraryRootDir, pkg.applicationInfo.primaryCpuAbi, pkg.applicationInfo.secondaryCpuAbi, pkg.applicationInfo.flags, pkg.applicationInfo.privateFlags, user, false);
        if (pkgSetting == null) {
            throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE, "Creating application package " + pkg.packageName + " failed");
        }
        if (pkgSetting.origPackage != null) {
            // If we are first transitioning from an original package,
            // fix up the new package's name now.  We need to do this after
            // looking up the package under its new name, so getPackageLP
            // can take care of fiddling things correctly.
            pkg.setPackageName(origPackage.name);
            // File a report about this.
            String msg = "New package " + pkgSetting.realName + " renamed to replace old package " + pkgSetting.name;
            reportSettingsProblem(Log.WARN, msg);
            // Make a note of it.
            if ((scanFlags & SCAN_CHECK_ONLY) == 0) {
                mTransferedPackages.add(origPackage.name);
            }
            // No longer need to retain this.
            pkgSetting.origPackage = null;
        }
        if ((scanFlags & SCAN_CHECK_ONLY) == 0 && realName != null) {
            // Make a note of it.
            mTransferedPackages.add(pkg.packageName);
        }
        if (mSettings.isDisabledSystemPackageLPr(pkg.packageName)) {
            pkg.applicationInfo.flags |= ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
        }
        if ((policyFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
            // Check all shared libraries and map to their actual file path.
            // We only do this here for apps not on a system dir, because those
            // are the only ones that can fail an install due to this.  We
            // will take care of the system apps by updating all of their
            // library paths after the scan is done.
            updateSharedLibrariesLPw(pkg, null);
        }
        if (mFoundPolicyFile) {
            SELinuxMMAC.assignSeinfoValue(pkg);
        }
        pkg.applicationInfo.uid = pkgSetting.appId;
        pkg.mExtras = pkgSetting;
        if (shouldCheckUpgradeKeySetLP(pkgSetting, scanFlags)) {
            if (checkUpgradeKeySetLP(pkgSetting, pkg)) {
                // We just determined the app is signed correctly, so bring
                // over the latest parsed certs.
                pkgSetting.signatures.mSignatures = pkg.mSignatures;
            } else {
                if ((policyFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
                    throw new PackageManagerException(INSTALL_FAILED_UPDATE_INCOMPATIBLE, "Package " + pkg.packageName + " upgrade keys do not match the " + "previously installed version");
                } else {
                    pkgSetting.signatures.mSignatures = pkg.mSignatures;
                    String msg = "System package " + pkg.packageName + " signature changed; retaining data.";
                    reportSettingsProblem(Log.WARN, msg);
                }
            }
        } else {
            try {
                verifySignaturesLP(pkgSetting, pkg);
                // We just determined the app is signed correctly, so bring
                // over the latest parsed certs.
                pkgSetting.signatures.mSignatures = pkg.mSignatures;
            } catch (PackageManagerException e) {
                if ((policyFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
                    throw e;
                }
                // The signature has changed, but this package is in the system
                // image...  let's recover!
                pkgSetting.signatures.mSignatures = pkg.mSignatures;
                // that unreasonable.
                if (pkgSetting.sharedUser != null) {
                    if (compareSignatures(pkgSetting.sharedUser.signatures.mSignatures, pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
                        throw new PackageManagerException(INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES, "Signature mismatch for shared user: " + pkgSetting.sharedUser);
                    }
                }
                // File a report about this.
                String msg = "System package " + pkg.packageName + " signature changed; retaining data.";
                reportSettingsProblem(Log.WARN, msg);
            }
        }
        // things that are installed.
        if ((scanFlags & SCAN_NEW_INSTALL) != 0) {
            final int N = pkg.providers.size();
            int i;
            for (i = 0; i < N; i++) {
                PackageParser.Provider p = pkg.providers.get(i);
                if (p.info.authority != null) {
                    String[] names = p.info.authority.split(";");
                    for (int j = 0; j < names.length; j++) {
                        if (mProvidersByAuthority.containsKey(names[j])) {
                            PackageParser.Provider other = mProvidersByAuthority.get(names[j]);
                            final String otherPackageName = ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : "?");
                            throw new PackageManagerException(INSTALL_FAILED_CONFLICTING_PROVIDER, "Can't install because provider name " + names[j] + " (in package " + pkg.applicationInfo.packageName + ") is already used by " + otherPackageName);
                        }
                    }
                }
            }
        }
        if ((scanFlags & SCAN_CHECK_ONLY) == 0 && pkg.mAdoptPermissions != null) {
            // another package.
            for (int i = pkg.mAdoptPermissions.size() - 1; i >= 0; i--) {
                final String origName = pkg.mAdoptPermissions.get(i);
                final PackageSetting orig = mSettings.peekPackageLPr(origName);
                if (orig != null) {
                    if (verifyPackageUpdateLPr(orig, pkg)) {
                        Slog.i(TAG, "Adopting permissions from " + origName + " to " + pkg.packageName);
                        mSettings.transferPermissionsLPw(origName, pkg.packageName);
                    }
                }
            }
        }
    }
    final String pkgName = pkg.packageName;
    final long scanFileTime = scanFile.lastModified();
    final boolean forceDex = (scanFlags & SCAN_FORCE_DEX) != 0;
    pkg.applicationInfo.processName = fixProcessName(pkg.applicationInfo.packageName, pkg.applicationInfo.processName, pkg.applicationInfo.uid);
    if (pkg != mPlatformPackage) {
        // Get all of our default paths setup
        pkg.applicationInfo.initForUser(UserHandle.USER_SYSTEM);
    }
    final String path = scanFile.getPath();
    final String cpuAbiOverride = deriveAbiOverride(pkg.cpuAbiOverride, pkgSetting);
    if ((scanFlags & SCAN_NEW_INSTALL) == 0) {
        derivePackageAbi(pkg, scanFile, cpuAbiOverride, true);
        // structure. Try to detect abi based on directory structure.
        if (isSystemApp(pkg) && !pkg.isUpdatedSystemApp() && pkg.applicationInfo.primaryCpuAbi == null) {
            setBundledAppAbisAndRoots(pkg, pkgSetting);
            setNativeLibraryPaths(pkg);
        }
    } else {
        if ((scanFlags & SCAN_MOVE) != 0) {
            // We haven't run dex-opt for this move (since we've moved the compiled output too)
            // but we already have this packages package info in the PackageSetting. We just
            // use that and derive the native library path based on the new codepath.
            pkg.applicationInfo.primaryCpuAbi = pkgSetting.primaryCpuAbiString;
            pkg.applicationInfo.secondaryCpuAbi = pkgSetting.secondaryCpuAbiString;
        }
        // Set native library paths again. For moves, the path will be updated based on the
        // ABIs we've determined above. For non-moves, the path will be updated based on the
        // ABIs we determined during compilation, but the path will depend on the final
        // package path (after the rename away from the stage path).
        setNativeLibraryPaths(pkg);
    }
    // the same UID correctly.
    if (mPlatformPackage == pkg) {
        pkg.applicationInfo.primaryCpuAbi = VMRuntime.getRuntime().is64Bit() ? Build.SUPPORTED_64_BIT_ABIS[0] : Build.SUPPORTED_32_BIT_ABIS[0];
    }
    // account.
    if ((scanFlags & SCAN_NO_DEX) == 0 && (scanFlags & SCAN_NEW_INSTALL) != 0) {
        if (cpuAbiOverride == null && pkgSetting.cpuAbiOverrideString != null) {
            Slog.w(TAG, "Ignoring persisted ABI override " + cpuAbiOverride + " for package " + pkg.packageName);
        }
    }
    pkgSetting.primaryCpuAbiString = pkg.applicationInfo.primaryCpuAbi;
    pkgSetting.secondaryCpuAbiString = pkg.applicationInfo.secondaryCpuAbi;
    pkgSetting.cpuAbiOverrideString = cpuAbiOverride;
    // Copy the derived override back to the parsed package, so that we can
    // update the package settings accordingly.
    pkg.cpuAbiOverride = cpuAbiOverride;
    if (DEBUG_ABI_SELECTION) {
        Slog.d(TAG, "Resolved nativeLibraryRoot for " + pkg.applicationInfo.packageName + " to root=" + pkg.applicationInfo.nativeLibraryRootDir + ", isa=" + pkg.applicationInfo.nativeLibraryRootRequiresIsa);
    }
    // Push the derived path down into PackageSettings so we know what to
    // clean up at uninstall time.
    pkgSetting.legacyNativeLibraryPathString = pkg.applicationInfo.nativeLibraryRootDir;
    if (DEBUG_ABI_SELECTION) {
        Log.d(TAG, "Abis for package[" + pkg.packageName + "] are" + " primary=" + pkg.applicationInfo.primaryCpuAbi + " secondary=" + pkg.applicationInfo.secondaryCpuAbi);
    }
    if ((scanFlags & SCAN_BOOTING) == 0 && pkgSetting.sharedUser != null) {
        // We don't do this here during boot because we can do it all
        // at once after scanning all existing packages.
        // 
        // We also do this *before* we perform dexopt on this package, so that
        // we can avoid redundant dexopts, and also to make sure we've got the
        // code and package path correct.
        adjustCpuAbisForSharedUserLPw(pkgSetting.sharedUser.packages, pkg, true);
    }
    if (mFactoryTest && pkg.requestedPermissions.contains(android.Manifest.permission.FACTORY_TEST)) {
        pkg.applicationInfo.flags |= ApplicationInfo.FLAG_FACTORY_TEST;
    }
    ArrayList<PackageParser.Package> clientLibPkgs = null;
    if ((scanFlags & SCAN_CHECK_ONLY) != 0) {
        if (nonMutatedPs != null) {
            synchronized (mPackages) {
                mSettings.mPackages.put(nonMutatedPs.name, nonMutatedPs);
            }
        }
        return pkg;
    }
    // Only privileged apps and updated privileged apps can add child packages.
    if (pkg.childPackages != null && !pkg.childPackages.isEmpty()) {
        if ((policyFlags & PARSE_IS_PRIVILEGED) == 0) {
            throw new PackageManagerException("Only privileged apps and updated " + "privileged apps can add child packages. Ignoring package " + pkg.packageName);
        }
        final int childCount = pkg.childPackages.size();
        for (int i = 0; i < childCount; i++) {
            PackageParser.Package childPkg = pkg.childPackages.get(i);
            if (mSettings.hasOtherDisabledSystemPkgWithChildLPr(pkg.packageName, childPkg.packageName)) {
                throw new PackageManagerException("Cannot override a child package of " + "another disabled system app. Ignoring package " + pkg.packageName);
            }
        }
    }
    // writer
    synchronized (mPackages) {
        if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
            // Only system apps can add new shared libraries.
            if (pkg.libraryNames != null) {
                for (int i = 0; i < pkg.libraryNames.size(); i++) {
                    String name = pkg.libraryNames.get(i);
                    boolean allowed = false;
                    if (pkg.isUpdatedSystemApp()) {
                        // New library entries can only be added through the
                        // system image.  This is important to get rid of a lot
                        // of nasty edge cases: for example if we allowed a non-
                        // system update of the app to add a library, then uninstalling
                        // the update would make the library go away, and assumptions
                        // we made such as through app install filtering would now
                        // have allowed apps on the device which aren't compatible
                        // with it.  Better to just have the restriction here, be
                        // conservative, and create many fewer cases that can negatively
                        // impact the user experience.
                        final PackageSetting sysPs = mSettings.getDisabledSystemPkgLPr(pkg.packageName);
                        if (sysPs.pkg != null && sysPs.pkg.libraryNames != null) {
                            for (int j = 0; j < sysPs.pkg.libraryNames.size(); j++) {
                                if (name.equals(sysPs.pkg.libraryNames.get(j))) {
                                    allowed = true;
                                    break;
                                }
                            }
                        }
                    } else {
                        allowed = true;
                    }
                    if (allowed) {
                        if (!mSharedLibraries.containsKey(name)) {
                            mSharedLibraries.put(name, new SharedLibraryEntry(null, pkg.packageName));
                        } else if (!name.equals(pkg.packageName)) {
                            Slog.w(TAG, "Package " + pkg.packageName + " library " + name + " already exists; skipping");
                        }
                    } else {
                        Slog.w(TAG, "Package " + pkg.packageName + " declares lib " + name + " that is not declared on system image; skipping");
                    }
                }
                if ((scanFlags & SCAN_BOOTING) == 0) {
                    // If we are not booting, we need to update any applications
                    // that are clients of our shared library.  If we are booting,
                    // this will all be done once the scan is complete.
                    clientLibPkgs = updateAllSharedLibrariesLPw(pkg);
                }
            }
        }
    }
    if ((scanFlags & SCAN_BOOTING) != 0) {
    // No apps can run during boot scan, so they don't need to be frozen
    } else if ((scanFlags & SCAN_DONT_KILL_APP) != 0) {
    // Caller asked to not kill app, so it's probably not frozen
    } else if ((scanFlags & SCAN_IGNORE_FROZEN) != 0) {
    // Caller asked us to ignore frozen check for some reason; they
    // probably didn't know the package name
    } else {
        // We're doing major surgery on this package, so it better be frozen
        // right now to keep it from launching
        checkPackageFrozen(pkgName);
    }
    // Also need to kill any apps that are dependent on the library.
    if (clientLibPkgs != null) {
        for (int i = 0; i < clientLibPkgs.size(); i++) {
            PackageParser.Package clientPkg = clientLibPkgs.get(i);
            killApplication(clientPkg.applicationInfo.packageName, clientPkg.applicationInfo.uid, "update lib");
        }
    }
    // Make sure we're not adding any bogus keyset info
    KeySetManagerService ksms = mSettings.mKeySetManagerService;
    ksms.assertScannedPackageValid(pkg);
    // writer
    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "updateSettings");
    boolean createIdmapFailed = false;
    synchronized (mPackages) {
        if (pkgSetting.pkg != null) {
            // Note that |user| might be null during the initial boot scan. If a codePath
            // for an app has changed during a boot scan, it's due to an app update that's
            // part of the system partition and marker changes must be applied to all users.
            maybeRenameForeignDexMarkers(pkgSetting.pkg, pkg, (user != null) ? user : UserHandle.ALL);
        }
        // Add the new setting to mSettings
        mSettings.insertPackageSettingLPw(pkgSetting, pkg);
        // Add the new setting to mPackages
        mPackages.put(pkg.applicationInfo.packageName, pkg);
        // Make sure we don't accidentally delete its data.
        final Iterator<PackageCleanItem> iter = mSettings.mPackagesToBeCleaned.iterator();
        while (iter.hasNext()) {
            PackageCleanItem item = iter.next();
            if (pkgName.equals(item.packageName)) {
                iter.remove();
            }
        }
        // Take care of first install / last update times.
        if (currentTime != 0) {
            if (pkgSetting.firstInstallTime == 0) {
                pkgSetting.firstInstallTime = pkgSetting.lastUpdateTime = currentTime;
            } else if ((scanFlags & SCAN_UPDATE_TIME) != 0) {
                pkgSetting.lastUpdateTime = currentTime;
            }
        } else if (pkgSetting.firstInstallTime == 0) {
            // We need *something*.  Take time time stamp of the file.
            pkgSetting.firstInstallTime = pkgSetting.lastUpdateTime = scanFileTime;
        } else if ((policyFlags & PackageParser.PARSE_IS_SYSTEM_DIR) != 0) {
            if (scanFileTime != pkgSetting.timeStamp) {
                // A package on the system image has changed; consider this
                // to be an update.
                pkgSetting.lastUpdateTime = scanFileTime;
            }
        }
        // Add the package's KeySets to the global KeySetManagerService
        ksms.addScannedPackageLPw(pkg);
        int N = pkg.providers.size();
        StringBuilder r = null;
        int i;
        for (i = 0; i < N; i++) {
            PackageParser.Provider p = pkg.providers.get(i);
            p.info.processName = fixProcessName(pkg.applicationInfo.processName, p.info.processName, pkg.applicationInfo.uid);
            mProviders.addProvider(p);
            p.syncable = p.info.isSyncable;
            if (p.info.authority != null) {
                String[] names = p.info.authority.split(";");
                p.info.authority = null;
                for (int j = 0; j < names.length; j++) {
                    if (j == 1 && p.syncable) {
                        // We only want the first authority for a provider to possibly be
                        // syncable, so if we already added this provider using a different
                        // authority clear the syncable flag. We copy the provider before
                        // changing it because the mProviders object contains a reference
                        // to a provider that we don't want to change.
                        // Only do this for the second authority since the resulting provider
                        // object can be the same for all future authorities for this provider.
                        p = new PackageParser.Provider(p);
                        p.syncable = false;
                    }
                    if (!mProvidersByAuthority.containsKey(names[j])) {
                        mProvidersByAuthority.put(names[j], p);
                        if (p.info.authority == null) {
                            p.info.authority = names[j];
                        } else {
                            p.info.authority = p.info.authority + ";" + names[j];
                        }
                        if (DEBUG_PACKAGE_SCANNING) {
                            if ((policyFlags & PackageParser.PARSE_CHATTY) != 0)
                                Log.d(TAG, "Registered content provider: " + names[j] + ", className = " + p.info.name + ", isSyncable = " + p.info.isSyncable);
                        }
                    } else {
                        PackageParser.Provider other = mProvidersByAuthority.get(names[j]);
                        Slog.w(TAG, "Skipping provider name " + names[j] + " (in package " + pkg.applicationInfo.packageName + "): name already used by " + ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : "?"));
                    }
                }
            }
            if ((policyFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(p.info.name);
            }
        }
        if (r != null) {
            if (DEBUG_PACKAGE_SCANNING)
                Log.d(TAG, "  Providers: " + r);
        }
        N = pkg.services.size();
        r = null;
        for (i = 0; i < N; i++) {
            PackageParser.Service s = pkg.services.get(i);
            s.info.processName = fixProcessName(pkg.applicationInfo.processName, s.info.processName, pkg.applicationInfo.uid);
            mServices.addService(s);
            if ((policyFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(s.info.name);
            }
        }
        if (r != null) {
            if (DEBUG_PACKAGE_SCANNING)
                Log.d(TAG, "  Services: " + r);
        }
        N = pkg.receivers.size();
        r = null;
        for (i = 0; i < N; i++) {
            PackageParser.Activity a = pkg.receivers.get(i);
            a.info.processName = fixProcessName(pkg.applicationInfo.processName, a.info.processName, pkg.applicationInfo.uid);
            mReceivers.addActivity(a, "receiver");
            if ((policyFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(a.info.name);
            }
        }
        if (r != null) {
            if (DEBUG_PACKAGE_SCANNING)
                Log.d(TAG, "  Receivers: " + r);
        }
        N = pkg.activities.size();
        r = null;
        for (i = 0; i < N; i++) {
            PackageParser.Activity a = pkg.activities.get(i);
            a.info.processName = fixProcessName(pkg.applicationInfo.processName, a.info.processName, pkg.applicationInfo.uid);
            mActivities.addActivity(a, "activity");
            if ((policyFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(a.info.name);
            }
        }
        if (r != null) {
            if (DEBUG_PACKAGE_SCANNING)
                Log.d(TAG, "  Activities: " + r);
        }
        N = pkg.permissionGroups.size();
        r = null;
        for (i = 0; i < N; i++) {
            PackageParser.PermissionGroup pg = pkg.permissionGroups.get(i);
            PackageParser.PermissionGroup cur = mPermissionGroups.get(pg.info.name);
            if (cur == null) {
                mPermissionGroups.put(pg.info.name, pg);
                if ((policyFlags & PackageParser.PARSE_CHATTY) != 0) {
                    if (r == null) {
                        r = new StringBuilder(256);
                    } else {
                        r.append(' ');
                    }
                    r.append(pg.info.name);
                }
            } else {
                Slog.w(TAG, "Permission group " + pg.info.name + " from package " + pg.info.packageName + " ignored: original from " + cur.info.packageName);
                if ((policyFlags & PackageParser.PARSE_CHATTY) != 0) {
                    if (r == null) {
                        r = new StringBuilder(256);
                    } else {
                        r.append(' ');
                    }
                    r.append("DUP:");
                    r.append(pg.info.name);
                }
            }
        }
        if (r != null) {
            if (DEBUG_PACKAGE_SCANNING)
                Log.d(TAG, "  Permission Groups: " + r);
        }
        N = pkg.permissions.size();
        r = null;
        for (i = 0; i < N; i++) {
            PackageParser.Permission p = pkg.permissions.get(i);
            // Assume by default that we did not install this permission into the system.
            p.info.flags &= ~PermissionInfo.FLAG_INSTALLED;
            // to be in a group defined by another app (before this had no implications).
            if (pkg.applicationInfo.targetSdkVersion > Build.VERSION_CODES.LOLLIPOP_MR1) {
                p.group = mPermissionGroups.get(p.info.group);
                // Warn for a permission in an unknown group.
                if (p.info.group != null && p.group == null) {
                    Slog.w(TAG, "Permission " + p.info.name + " from package " + p.info.packageName + " in an unknown group " + p.info.group);
                }
            }
            ArrayMap<String, BasePermission> permissionMap = p.tree ? mSettings.mPermissionTrees : mSettings.mPermissions;
            BasePermission bp = permissionMap.get(p.info.name);
            // Allow system apps to redefine non-system permissions
            if (bp != null && !Objects.equals(bp.sourcePackage, p.info.packageName)) {
                final boolean currentOwnerIsSystem = (bp.perm != null && isSystemApp(bp.perm.owner));
                if (isSystemApp(p.owner)) {
                    if (bp.type == BasePermission.TYPE_BUILTIN && bp.perm == null) {
                        // It's a built-in permission and no owner, take ownership now
                        bp.packageSetting = pkgSetting;
                        bp.perm = p;
                        bp.uid = pkg.applicationInfo.uid;
                        bp.sourcePackage = p.info.packageName;
                        p.info.flags |= PermissionInfo.FLAG_INSTALLED;
                    } else if (!currentOwnerIsSystem) {
                        String msg = "New decl " + p.owner + " of permission  " + p.info.name + " is system; overriding " + bp.sourcePackage;
                        reportSettingsProblem(Log.WARN, msg);
                        bp = null;
                    }
                }
            }
            if (bp == null) {
                bp = new BasePermission(p.info.name, p.info.packageName, BasePermission.TYPE_NORMAL);
                permissionMap.put(p.info.name, bp);
            }
            if (bp.perm == null) {
                if (bp.sourcePackage == null || bp.sourcePackage.equals(p.info.packageName)) {
                    BasePermission tree = findPermissionTreeLP(p.info.name);
                    if (tree == null || tree.sourcePackage.equals(p.info.packageName)) {
                        bp.packageSetting = pkgSetting;
                        bp.perm = p;
                        bp.uid = pkg.applicationInfo.uid;
                        bp.sourcePackage = p.info.packageName;
                        p.info.flags |= PermissionInfo.FLAG_INSTALLED;
                        if ((policyFlags & PackageParser.PARSE_CHATTY) != 0) {
                            if (r == null) {
                                r = new StringBuilder(256);
                            } else {
                                r.append(' ');
                            }
                            r.append(p.info.name);
                        }
                    } else {
                        Slog.w(TAG, "Permission " + p.info.name + " from package " + p.info.packageName + " ignored: base tree " + tree.name + " is from package " + tree.sourcePackage);
                    }
                } else {
                    Slog.w(TAG, "Permission " + p.info.name + " from package " + p.info.packageName + " ignored: original from " + bp.sourcePackage);
                }
            } else if ((policyFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append("DUP:");
                r.append(p.info.name);
            }
            if (bp.perm == p) {
                bp.protectionLevel = p.info.protectionLevel;
            }
        }
        if (r != null) {
            if (DEBUG_PACKAGE_SCANNING)
                Log.d(TAG, "  Permissions: " + r);
        }
        N = pkg.instrumentation.size();
        r = null;
        for (i = 0; i < N; i++) {
            PackageParser.Instrumentation a = pkg.instrumentation.get(i);
            a.info.packageName = pkg.applicationInfo.packageName;
            a.info.sourceDir = pkg.applicationInfo.sourceDir;
            a.info.publicSourceDir = pkg.applicationInfo.publicSourceDir;
            a.info.splitSourceDirs = pkg.applicationInfo.splitSourceDirs;
            a.info.splitPublicSourceDirs = pkg.applicationInfo.splitPublicSourceDirs;
            a.info.dataDir = pkg.applicationInfo.dataDir;
            a.info.deviceProtectedDataDir = pkg.applicationInfo.deviceProtectedDataDir;
            a.info.credentialProtectedDataDir = pkg.applicationInfo.credentialProtectedDataDir;
            a.info.nativeLibraryDir = pkg.applicationInfo.nativeLibraryDir;
            a.info.secondaryNativeLibraryDir = pkg.applicationInfo.secondaryNativeLibraryDir;
            mInstrumentation.put(a.getComponentName(), a);
            if ((policyFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(a.info.name);
            }
        }
        if (r != null) {
            if (DEBUG_PACKAGE_SCANNING)
                Log.d(TAG, "  Instrumentation: " + r);
        }
        if (pkg.protectedBroadcasts != null) {
            N = pkg.protectedBroadcasts.size();
            for (i = 0; i < N; i++) {
                mProtectedBroadcasts.add(pkg.protectedBroadcasts.get(i));
            }
        }
        pkgSetting.setTimeStamp(scanFileTime);
        // Note: "android", ie framework-res.apk, is handled by native layers.
        if (pkg.mOverlayTarget != null) {
            // This is an overlay package.
            if (pkg.mOverlayTarget != null && !pkg.mOverlayTarget.equals("android")) {
                if (!mOverlays.containsKey(pkg.mOverlayTarget)) {
                    mOverlays.put(pkg.mOverlayTarget, new ArrayMap<String, PackageParser.Package>());
                }
                ArrayMap<String, PackageParser.Package> map = mOverlays.get(pkg.mOverlayTarget);
                map.put(pkg.packageName, pkg);
                PackageParser.Package orig = mPackages.get(pkg.mOverlayTarget);
                if (orig != null && !createIdmapForPackagePairLI(orig, pkg)) {
                    createIdmapFailed = true;
                }
            }
        } else if (mOverlays.containsKey(pkg.packageName) && !pkg.packageName.equals("android")) {
            // This is a regular package, with one or more known overlay packages.
            createIdmapsForPackageLI(pkg);
        }
    }
    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
    if (createIdmapFailed) {
        throw new PackageManagerException(INSTALL_FAILED_UPDATE_INCOMPATIBLE, "scanPackageLI failed to createIdmap");
    }
    return pkg;
}
#end_block

#method_before
public void derivePackageAbi(PackageParser.Package pkg, File scanFile, String cpuAbiOverride, boolean extractLibs) throws PackageManagerException {
    // TODO: We can probably be smarter about this stuff. For installed apps,
    // we can calculate this information at install time once and for all. For
    // system apps, we can probably assume that this information doesn't change
    // after the first boot scan. As things stand, we do lots of unnecessary work.
    // Give ourselves some initial paths; we'll come back for another
    // pass once we've determined ABI below.
    setNativeLibraryPaths(pkg);
    // extract libs from system app when it was not updated.
    if (pkg.isForwardLocked() || pkg.applicationInfo.isExternalAsec() || (isSystemApp(pkg) && !pkg.isUpdatedSystemApp())) {
        extractLibs = false;
    }
    final String nativeLibraryRootStr = pkg.applicationInfo.nativeLibraryRootDir;
    final boolean useIsaSpecificSubdirs = pkg.applicationInfo.nativeLibraryRootRequiresIsa;
    NativeLibraryHelper.Handle handle = null;
    try {
        handle = NativeLibraryHelper.Handle.create(scanFile);
        // TODO(multiArch): This can be null for apps that didn't go through the
        // usual installation process. We can calculate it again, like we
        // do during install time.
        // 
        // TODO(multiArch): Why do we need to rescan ASEC apps again ? It seems totally
        // unnecessary.
        final File nativeLibraryRoot = new File(nativeLibraryRootStr);
        // Null out the abis so that they can be recalculated.
        pkg.applicationInfo.primaryCpuAbi = null;
        pkg.applicationInfo.secondaryCpuAbi = null;
        if (isMultiArch(pkg.applicationInfo)) {
            // such packages.
            if (pkg.cpuAbiOverride != null && !NativeLibraryHelper.CLEAR_ABI_OVERRIDE.equals(pkg.cpuAbiOverride)) {
                Slog.w(TAG, "Ignoring abiOverride for multi arch application.");
            }
            int abi32 = PackageManager.NO_NATIVE_LIBRARIES;
            int abi64 = PackageManager.NO_NATIVE_LIBRARIES;
            if (Build.SUPPORTED_32_BIT_ABIS.length > 0) {
                if (extractLibs) {
                    abi32 = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle, nativeLibraryRoot, Build.SUPPORTED_32_BIT_ABIS, useIsaSpecificSubdirs);
                } else {
                    abi32 = NativeLibraryHelper.findSupportedAbi(handle, Build.SUPPORTED_32_BIT_ABIS);
                }
            }
            maybeThrowExceptionForMultiArchCopy("Error unpackaging 32 bit native libs for multiarch app.", abi32);
            if (Build.SUPPORTED_64_BIT_ABIS.length > 0) {
                if (extractLibs) {
                    abi64 = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle, nativeLibraryRoot, Build.SUPPORTED_64_BIT_ABIS, useIsaSpecificSubdirs);
                } else {
                    abi64 = NativeLibraryHelper.findSupportedAbi(handle, Build.SUPPORTED_64_BIT_ABIS);
                }
            }
            maybeThrowExceptionForMultiArchCopy("Error unpackaging 64 bit native libs for multiarch app.", abi64);
            if (abi64 >= 0) {
                pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[abi64];
            }
            if (abi32 >= 0) {
                final String abi = Build.SUPPORTED_32_BIT_ABIS[abi32];
                if (abi64 >= 0) {
                    pkg.applicationInfo.secondaryCpuAbi = abi;
                } else {
                    pkg.applicationInfo.primaryCpuAbi = abi;
                }
            }
        } else {
            String[] abiList = (cpuAbiOverride != null) ? new String[] { cpuAbiOverride } : Build.SUPPORTED_ABIS;
            // Enable gross and lame hacks for apps that are built with old
            // SDK tools. We must scan their APKs for renderscript bitcode and
            // not launch them if it's present. Don't bother checking on devices
            // that don't have 64 bit support.
            boolean needsRenderScriptOverride = false;
            if (Build.SUPPORTED_64_BIT_ABIS.length > 0 && cpuAbiOverride == null && NativeLibraryHelper.hasRenderscriptBitcode(handle)) {
                abiList = Build.SUPPORTED_32_BIT_ABIS;
                needsRenderScriptOverride = true;
            }
            final int copyRet;
            if (extractLibs) {
                copyRet = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle, nativeLibraryRoot, abiList, useIsaSpecificSubdirs);
            } else {
                copyRet = NativeLibraryHelper.findSupportedAbi(handle, abiList);
            }
            if (copyRet < 0 && copyRet != PackageManager.NO_NATIVE_LIBRARIES) {
                throw new PackageManagerException(INSTALL_FAILED_INTERNAL_ERROR, "Error unpackaging native libs for app, errorCode=" + copyRet);
            }
            if (copyRet >= 0) {
                pkg.applicationInfo.primaryCpuAbi = abiList[copyRet];
            } else if (copyRet == PackageManager.NO_NATIVE_LIBRARIES && cpuAbiOverride != null) {
                pkg.applicationInfo.primaryCpuAbi = cpuAbiOverride;
            } else if (needsRenderScriptOverride) {
                pkg.applicationInfo.primaryCpuAbi = abiList[0];
            }
        }
    } catch (IOException ioe) {
        Slog.e(TAG, "Unable to get canonical file " + ioe.toString());
    } finally {
        IoUtils.closeQuietly(handle);
    }
    // Now that we've calculated the ABIs and determined if it's an internal app,
    // we will go ahead and populate the nativeLibraryPath.
    setNativeLibraryPaths(pkg);
}
#method_after
private void derivePackageAbi(PackageParser.Package pkg, File scanFile, String cpuAbiOverride, boolean extractLibs) throws PackageManagerException {
    // TODO: We can probably be smarter about this stuff. For installed apps,
    // we can calculate this information at install time once and for all. For
    // system apps, we can probably assume that this information doesn't change
    // after the first boot scan. As things stand, we do lots of unnecessary work.
    // Give ourselves some initial paths; we'll come back for another
    // pass once we've determined ABI below.
    setNativeLibraryPaths(pkg);
    // extract libs from system app when it was not updated.
    if (pkg.isForwardLocked() || pkg.applicationInfo.isExternalAsec() || (isSystemApp(pkg) && !pkg.isUpdatedSystemApp())) {
        extractLibs = false;
    }
    final String nativeLibraryRootStr = pkg.applicationInfo.nativeLibraryRootDir;
    final boolean useIsaSpecificSubdirs = pkg.applicationInfo.nativeLibraryRootRequiresIsa;
    NativeLibraryHelper.Handle handle = null;
    try {
        handle = NativeLibraryHelper.Handle.create(pkg);
        // TODO(multiArch): This can be null for apps that didn't go through the
        // usual installation process. We can calculate it again, like we
        // do during install time.
        // 
        // TODO(multiArch): Why do we need to rescan ASEC apps again ? It seems totally
        // unnecessary.
        final File nativeLibraryRoot = new File(nativeLibraryRootStr);
        // Null out the abis so that they can be recalculated.
        pkg.applicationInfo.primaryCpuAbi = null;
        pkg.applicationInfo.secondaryCpuAbi = null;
        if (isMultiArch(pkg.applicationInfo)) {
            // such packages.
            if (pkg.cpuAbiOverride != null && !NativeLibraryHelper.CLEAR_ABI_OVERRIDE.equals(pkg.cpuAbiOverride)) {
                Slog.w(TAG, "Ignoring abiOverride for multi arch application.");
            }
            int abi32 = PackageManager.NO_NATIVE_LIBRARIES;
            int abi64 = PackageManager.NO_NATIVE_LIBRARIES;
            if (Build.SUPPORTED_32_BIT_ABIS.length > 0) {
                if (extractLibs) {
                    abi32 = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle, nativeLibraryRoot, Build.SUPPORTED_32_BIT_ABIS, useIsaSpecificSubdirs);
                } else {
                    abi32 = NativeLibraryHelper.findSupportedAbi(handle, Build.SUPPORTED_32_BIT_ABIS);
                }
            }
            maybeThrowExceptionForMultiArchCopy("Error unpackaging 32 bit native libs for multiarch app.", abi32);
            if (Build.SUPPORTED_64_BIT_ABIS.length > 0) {
                if (extractLibs) {
                    abi64 = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle, nativeLibraryRoot, Build.SUPPORTED_64_BIT_ABIS, useIsaSpecificSubdirs);
                } else {
                    abi64 = NativeLibraryHelper.findSupportedAbi(handle, Build.SUPPORTED_64_BIT_ABIS);
                }
            }
            maybeThrowExceptionForMultiArchCopy("Error unpackaging 64 bit native libs for multiarch app.", abi64);
            if (abi64 >= 0) {
                pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[abi64];
            }
            if (abi32 >= 0) {
                final String abi = Build.SUPPORTED_32_BIT_ABIS[abi32];
                if (abi64 >= 0) {
                    if (pkg.use32bitAbi) {
                        pkg.applicationInfo.secondaryCpuAbi = pkg.applicationInfo.primaryCpuAbi;
                        pkg.applicationInfo.primaryCpuAbi = abi;
                    } else {
                        pkg.applicationInfo.secondaryCpuAbi = abi;
                    }
                } else {
                    pkg.applicationInfo.primaryCpuAbi = abi;
                }
            }
        } else {
            String[] abiList = (cpuAbiOverride != null) ? new String[] { cpuAbiOverride } : Build.SUPPORTED_ABIS;
            // Enable gross and lame hacks for apps that are built with old
            // SDK tools. We must scan their APKs for renderscript bitcode and
            // not launch them if it's present. Don't bother checking on devices
            // that don't have 64 bit support.
            boolean needsRenderScriptOverride = false;
            if (Build.SUPPORTED_64_BIT_ABIS.length > 0 && cpuAbiOverride == null && NativeLibraryHelper.hasRenderscriptBitcode(handle)) {
                abiList = Build.SUPPORTED_32_BIT_ABIS;
                needsRenderScriptOverride = true;
            }
            final int copyRet;
            if (extractLibs) {
                copyRet = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle, nativeLibraryRoot, abiList, useIsaSpecificSubdirs);
            } else {
                copyRet = NativeLibraryHelper.findSupportedAbi(handle, abiList);
            }
            if (copyRet < 0 && copyRet != PackageManager.NO_NATIVE_LIBRARIES) {
                throw new PackageManagerException(INSTALL_FAILED_INTERNAL_ERROR, "Error unpackaging native libs for app, errorCode=" + copyRet);
            }
            if (copyRet >= 0) {
                pkg.applicationInfo.primaryCpuAbi = abiList[copyRet];
            } else if (copyRet == PackageManager.NO_NATIVE_LIBRARIES && cpuAbiOverride != null) {
                pkg.applicationInfo.primaryCpuAbi = cpuAbiOverride;
            } else if (needsRenderScriptOverride) {
                pkg.applicationInfo.primaryCpuAbi = abiList[0];
            }
        }
    } catch (IOException ioe) {
        Slog.e(TAG, "Unable to get canonical file " + ioe.toString());
    } finally {
        IoUtils.closeQuietly(handle);
    }
    // Now that we've calculated the ABIs and determined if it's an internal app,
    // we will go ahead and populate the nativeLibraryPath.
    setNativeLibraryPaths(pkg);
}
#end_block

#method_before
private void adjustCpuAbisForSharedUserLPw(Set<PackageSetting> packagesForUser, PackageParser.Package scannedPackage, boolean forceDexOpt, boolean deferDexOpt, boolean bootComplete) {
    String requiredInstructionSet = null;
    if (scannedPackage != null && scannedPackage.applicationInfo.primaryCpuAbi != null) {
        requiredInstructionSet = VMRuntime.getInstructionSet(scannedPackage.applicationInfo.primaryCpuAbi);
    }
    PackageSetting requirer = null;
    for (PackageSetting ps : packagesForUser) {
        // user, even if it's compatible with other packages.
        if (scannedPackage == null || !scannedPackage.packageName.equals(ps.name)) {
            if (ps.primaryCpuAbiString == null) {
                continue;
            }
            final String instructionSet = VMRuntime.getInstructionSet(ps.primaryCpuAbiString);
            if (requiredInstructionSet != null && !instructionSet.equals(requiredInstructionSet)) {
                // We have a mismatch between instruction sets (say arm vs arm64) warn about
                // this but there's not much we can do.
                String errorMessage = "Instruction set mismatch, " + ((requirer == null) ? "[caller]" : requirer) + " requires " + requiredInstructionSet + " whereas " + ps + " requires " + instructionSet;
                Slog.w(TAG, errorMessage);
            }
            if (requiredInstructionSet == null) {
                requiredInstructionSet = instructionSet;
                requirer = ps;
            }
        }
    }
    if (requiredInstructionSet != null) {
        String adjustedAbi;
        if (requirer != null) {
            // requirer != null implies that either scannedPackage was null or that scannedPackage
            // did not require an ABI, in which case we have to adjust scannedPackage to match
            // the ABI of the set (which is the same as requirer's ABI)
            adjustedAbi = requirer.primaryCpuAbiString;
            if (scannedPackage != null) {
                scannedPackage.applicationInfo.primaryCpuAbi = adjustedAbi;
            }
        } else {
            // requirer == null implies that we're updating all ABIs in the set to
            // match scannedPackage.
            adjustedAbi = scannedPackage.applicationInfo.primaryCpuAbi;
        }
        for (PackageSetting ps : packagesForUser) {
            if (scannedPackage == null || !scannedPackage.packageName.equals(ps.name)) {
                if (ps.primaryCpuAbiString != null) {
                    continue;
                }
                ps.primaryCpuAbiString = adjustedAbi;
                if (ps.pkg != null && ps.pkg.applicationInfo != null) {
                    ps.pkg.applicationInfo.primaryCpuAbi = adjustedAbi;
                    Slog.i(TAG, "Adjusting ABI for : " + ps.name + " to " + adjustedAbi);
                    int result = mPackageDexOptimizer.performDexOpt(ps.pkg, null, /* instruction sets */
                    forceDexOpt, deferDexOpt, true, bootComplete, false);
                    if (result == PackageDexOptimizer.DEX_OPT_FAILED) {
                        ps.primaryCpuAbiString = null;
                        ps.pkg.applicationInfo.primaryCpuAbi = null;
                        return;
                    } else {
                        mInstaller.rmdex(ps.codePathString, getDexCodeInstructionSet(getPreferredInstructionSet()));
                    }
                }
            }
        }
    }
}
#method_after
private void adjustCpuAbisForSharedUserLPw(Set<PackageSetting> packagesForUser, PackageParser.Package scannedPackage, boolean bootComplete) {
    String requiredInstructionSet = null;
    if (scannedPackage != null && scannedPackage.applicationInfo.primaryCpuAbi != null) {
        requiredInstructionSet = VMRuntime.getInstructionSet(scannedPackage.applicationInfo.primaryCpuAbi);
    }
    PackageSetting requirer = null;
    for (PackageSetting ps : packagesForUser) {
        // user, even if it's compatible with other packages.
        if (scannedPackage == null || !scannedPackage.packageName.equals(ps.name)) {
            if (ps.primaryCpuAbiString == null) {
                continue;
            }
            final String instructionSet = VMRuntime.getInstructionSet(ps.primaryCpuAbiString);
            if (requiredInstructionSet != null && !instructionSet.equals(requiredInstructionSet)) {
                // We have a mismatch between instruction sets (say arm vs arm64) warn about
                // this but there's not much we can do.
                String errorMessage = "Instruction set mismatch, " + ((requirer == null) ? "[caller]" : requirer) + " requires " + requiredInstructionSet + " whereas " + ps + " requires " + instructionSet;
                Slog.w(TAG, errorMessage);
            }
            if (requiredInstructionSet == null) {
                requiredInstructionSet = instructionSet;
                requirer = ps;
            }
        }
    }
    if (requiredInstructionSet != null) {
        String adjustedAbi;
        if (requirer != null) {
            // requirer != null implies that either scannedPackage was null or that scannedPackage
            // did not require an ABI, in which case we have to adjust scannedPackage to match
            // the ABI of the set (which is the same as requirer's ABI)
            adjustedAbi = requirer.primaryCpuAbiString;
            if (scannedPackage != null) {
                scannedPackage.applicationInfo.primaryCpuAbi = adjustedAbi;
            }
        } else {
            // requirer == null implies that we're updating all ABIs in the set to
            // match scannedPackage.
            adjustedAbi = scannedPackage.applicationInfo.primaryCpuAbi;
        }
        for (PackageSetting ps : packagesForUser) {
            if (scannedPackage == null || !scannedPackage.packageName.equals(ps.name)) {
                if (ps.primaryCpuAbiString != null) {
                    continue;
                }
                ps.primaryCpuAbiString = adjustedAbi;
                if (ps.pkg != null && ps.pkg.applicationInfo != null && !TextUtils.equals(adjustedAbi, ps.pkg.applicationInfo.primaryCpuAbi)) {
                    ps.pkg.applicationInfo.primaryCpuAbi = adjustedAbi;
                    Slog.i(TAG, "Adjusting ABI for " + ps.name + " to " + adjustedAbi + " (requirer=" + (requirer == null ? "null" : requirer.pkg.packageName) + ", scannedPackage=" + (scannedPackage != null ? scannedPackage.packageName : "null") + ")");
                    try {
                        mInstaller.rmdex(ps.codePathString, getDexCodeInstructionSet(getPreferredInstructionSet()));
                    } catch (InstallerException ignored) {
                    }
                }
            }
        }
    }
}
#end_block

#method_before
private static void setBundledAppAbi(PackageParser.Package pkg, String apkRoot, String apkName) {
    final File codeFile = new File(pkg.codePath);
    final boolean has64BitLibs;
    final boolean has32BitLibs;
    if (isApkFile(codeFile)) {
        // Monolithic install
        has64BitLibs = (new File(apkRoot, new File(LIB64_DIR_NAME, apkName).getPath())).exists();
        has32BitLibs = (new File(apkRoot, new File(LIB_DIR_NAME, apkName).getPath())).exists();
    } else {
        // Cluster install
        final File rootDir = new File(codeFile, LIB_DIR_NAME);
        if (!ArrayUtils.isEmpty(Build.SUPPORTED_64_BIT_ABIS) && !TextUtils.isEmpty(Build.SUPPORTED_64_BIT_ABIS[0])) {
            final String isa = VMRuntime.getInstructionSet(Build.SUPPORTED_64_BIT_ABIS[0]);
            has64BitLibs = (new File(rootDir, isa)).exists();
        } else {
            has64BitLibs = false;
        }
        if (!ArrayUtils.isEmpty(Build.SUPPORTED_32_BIT_ABIS) && !TextUtils.isEmpty(Build.SUPPORTED_32_BIT_ABIS[0])) {
            final String isa = VMRuntime.getInstructionSet(Build.SUPPORTED_32_BIT_ABIS[0]);
            has32BitLibs = (new File(rootDir, isa)).exists();
        } else {
            has32BitLibs = false;
        }
    }
    if (has64BitLibs && !has32BitLibs) {
        // The package has 64 bit libs, but not 32 bit libs. Its primary
        // ABI should be 64 bit. We can safely assume here that the bundled
        // native libraries correspond to the most preferred ABI in the list.
        pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[0];
        pkg.applicationInfo.secondaryCpuAbi = null;
    } else if (has32BitLibs && !has64BitLibs) {
        // The package has 32 bit libs but not 64 bit libs. Its primary
        // ABI should be 32 bit.
        pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_32_BIT_ABIS[0];
        pkg.applicationInfo.secondaryCpuAbi = null;
    } else if (has32BitLibs && has64BitLibs) {
        if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_MULTIARCH) == 0) {
            Slog.e(TAG, "Package: " + pkg + " has multiple bundled libs, but is not multiarch.");
        }
        if (VMRuntime.is64BitInstructionSet(getPreferredInstructionSet())) {
            pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[0];
            pkg.applicationInfo.secondaryCpuAbi = Build.SUPPORTED_32_BIT_ABIS[0];
        } else {
            pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_32_BIT_ABIS[0];
            pkg.applicationInfo.secondaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[0];
        }
    } else {
        pkg.applicationInfo.primaryCpuAbi = null;
        pkg.applicationInfo.secondaryCpuAbi = null;
    }
}
#method_after
private static void setBundledAppAbi(PackageParser.Package pkg, String apkRoot, String apkName) {
    final File codeFile = new File(pkg.codePath);
    final boolean has64BitLibs;
    final boolean has32BitLibs;
    if (isApkFile(codeFile)) {
        // Monolithic install
        has64BitLibs = (new File(apkRoot, new File(LIB64_DIR_NAME, apkName).getPath())).exists();
        has32BitLibs = (new File(apkRoot, new File(LIB_DIR_NAME, apkName).getPath())).exists();
    } else {
        // Cluster install
        final File rootDir = new File(codeFile, LIB_DIR_NAME);
        if (!ArrayUtils.isEmpty(Build.SUPPORTED_64_BIT_ABIS) && !TextUtils.isEmpty(Build.SUPPORTED_64_BIT_ABIS[0])) {
            final String isa = VMRuntime.getInstructionSet(Build.SUPPORTED_64_BIT_ABIS[0]);
            has64BitLibs = (new File(rootDir, isa)).exists();
        } else {
            has64BitLibs = false;
        }
        if (!ArrayUtils.isEmpty(Build.SUPPORTED_32_BIT_ABIS) && !TextUtils.isEmpty(Build.SUPPORTED_32_BIT_ABIS[0])) {
            final String isa = VMRuntime.getInstructionSet(Build.SUPPORTED_32_BIT_ABIS[0]);
            has32BitLibs = (new File(rootDir, isa)).exists();
        } else {
            has32BitLibs = false;
        }
    }
    if (has64BitLibs && !has32BitLibs) {
        // The package has 64 bit libs, but not 32 bit libs. Its primary
        // ABI should be 64 bit. We can safely assume here that the bundled
        // native libraries correspond to the most preferred ABI in the list.
        pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[0];
        pkg.applicationInfo.secondaryCpuAbi = null;
    } else if (has32BitLibs && !has64BitLibs) {
        // The package has 32 bit libs but not 64 bit libs. Its primary
        // ABI should be 32 bit.
        pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_32_BIT_ABIS[0];
        pkg.applicationInfo.secondaryCpuAbi = null;
    } else if (has32BitLibs && has64BitLibs) {
        if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_MULTIARCH) == 0) {
            Slog.e(TAG, "Package " + pkg + " has multiple bundled libs, but is not multiarch.");
        }
        if (VMRuntime.is64BitInstructionSet(getPreferredInstructionSet())) {
            pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[0];
            pkg.applicationInfo.secondaryCpuAbi = Build.SUPPORTED_32_BIT_ABIS[0];
        } else {
            pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_32_BIT_ABIS[0];
            pkg.applicationInfo.secondaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[0];
        }
    } else {
        pkg.applicationInfo.primaryCpuAbi = null;
        pkg.applicationInfo.secondaryCpuAbi = null;
    }
}
#end_block

#method_before
private void killApplication(String pkgName, int appId, String reason) {
    // Request the ActivityManager to kill the process(only for existing packages)
    // so that we do not end up in a confused state while the user is still using the older
    // version of the application while the new one gets installed.
    IActivityManager am = ActivityManagerNative.getDefault();
    if (am != null) {
        try {
            am.killApplicationWithAppId(pkgName, appId, reason);
        } catch (RemoteException e) {
        }
    }
}
#method_after
private void killApplication(String pkgName, int appId, String reason) {
    killApplication(pkgName, appId, UserHandle.USER_ALL, reason);
}
#end_block

#method_before
private void killApplication(String pkgName, int appId, String reason) {
    // Request the ActivityManager to kill the process(only for existing packages)
    // so that we do not end up in a confused state while the user is still using the older
    // version of the application while the new one gets installed.
    IActivityManager am = ActivityManagerNative.getDefault();
    if (am != null) {
        try {
            am.killApplicationWithAppId(pkgName, appId, reason);
        } catch (RemoteException e) {
        }
    }
}
#method_after
private void killApplication(String pkgName, int appId, int userId, String reason) {
    // Request the ActivityManager to kill the process(only for existing packages)
    // so that we do not end up in a confused state while the user is still using the older
    // version of the application while the new one gets installed.
    final long token = Binder.clearCallingIdentity();
    try {
        IActivityManager am = ActivityManagerNative.getDefault();
        if (am != null) {
            try {
                am.killApplication(pkgName, appId, userId, reason);
            } catch (RemoteException e) {
            }
        }
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
void removePackageLI(PackageSetting ps, boolean chatty) {
    if (DEBUG_INSTALL) {
        if (chatty)
            Log.d(TAG, "Removing package " + ps.name);
    }
    // writer
    synchronized (mPackages) {
        mPackages.remove(ps.name);
        final PackageParser.Package pkg = ps.pkg;
        if (pkg != null) {
            cleanPackageDataStructuresLILPw(pkg, chatty);
        }
    }
}
#method_after
private void removePackageLI(PackageParser.Package pkg, boolean chatty) {
    // Remove the parent package setting
    PackageSetting ps = (PackageSetting) pkg.mExtras;
    if (ps != null) {
        removePackageLI(ps, chatty);
    }
    // Remove the child package setting
    final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0;
    for (int i = 0; i < childCount; i++) {
        PackageParser.Package childPkg = pkg.childPackages.get(i);
        ps = (PackageSetting) childPkg.mExtras;
        if (ps != null) {
            removePackageLI(ps, chatty);
        }
    }
}
#end_block

#method_before
void removeInstalledPackageLI(PackageParser.Package pkg, boolean chatty) {
    if (DEBUG_INSTALL) {
        if (chatty)
            Log.d(TAG, "Removing package " + pkg.applicationInfo.packageName);
    }
    // writer
    synchronized (mPackages) {
        mPackages.remove(pkg.applicationInfo.packageName);
        cleanPackageDataStructuresLILPw(pkg, chatty);
    }
}
#method_after
void removeInstalledPackageLI(PackageParser.Package pkg, boolean chatty) {
    if (DEBUG_INSTALL) {
        if (chatty)
            Log.d(TAG, "Removing package " + pkg.applicationInfo.packageName);
    }
    // writer
    synchronized (mPackages) {
        // Remove the parent package
        mPackages.remove(pkg.applicationInfo.packageName);
        cleanPackageDataStructuresLILPw(pkg, chatty);
        // Remove the child packages
        final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            PackageParser.Package childPkg = pkg.childPackages.get(i);
            mPackages.remove(childPkg.applicationInfo.packageName);
            cleanPackageDataStructuresLILPw(childPkg, chatty);
        }
    }
}
#end_block

#method_before
private void updatePermissionsLPw(String changingPkg, PackageParser.Package pkgInfo, String replaceVolumeUuid, int flags) {
    // Make sure there are no dangling permission trees.
    Iterator<BasePermission> it = mSettings.mPermissionTrees.values().iterator();
    while (it.hasNext()) {
        final BasePermission bp = it.next();
        if (bp.packageSetting == null) {
            // We may not yet have parsed the package, so just see if
            // we still know about its settings.
            bp.packageSetting = mSettings.mPackages.get(bp.sourcePackage);
        }
        if (bp.packageSetting == null) {
            Slog.w(TAG, "Removing dangling permission tree: " + bp.name + " from package " + bp.sourcePackage);
            it.remove();
        } else if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
            if (pkgInfo == null || !hasPermission(pkgInfo, bp.name)) {
                Slog.i(TAG, "Removing old permission tree: " + bp.name + " from package " + bp.sourcePackage);
                flags |= UPDATE_PERMISSIONS_ALL;
                it.remove();
            }
        }
    }
    // Make sure all dynamic permissions have been assigned to a package,
    // and make sure there are no dangling permissions.
    it = mSettings.mPermissions.values().iterator();
    while (it.hasNext()) {
        final BasePermission bp = it.next();
        if (bp.type == BasePermission.TYPE_DYNAMIC) {
            if (DEBUG_SETTINGS)
                Log.v(TAG, "Dynamic permission: name=" + bp.name + " pkg=" + bp.sourcePackage + " info=" + bp.pendingInfo);
            if (bp.packageSetting == null && bp.pendingInfo != null) {
                final BasePermission tree = findPermissionTreeLP(bp.name);
                if (tree != null && tree.perm != null) {
                    bp.packageSetting = tree.packageSetting;
                    bp.perm = new PackageParser.Permission(tree.perm.owner, new PermissionInfo(bp.pendingInfo));
                    bp.perm.info.packageName = tree.perm.info.packageName;
                    bp.perm.info.name = bp.name;
                    bp.uid = tree.uid;
                }
            }
        }
        if (bp.packageSetting == null) {
            // We may not yet have parsed the package, so just see if
            // we still know about its settings.
            bp.packageSetting = mSettings.mPackages.get(bp.sourcePackage);
        }
        if (bp.packageSetting == null) {
            Slog.w(TAG, "Removing dangling permission: " + bp.name + " from package " + bp.sourcePackage);
            it.remove();
        } else if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
            if (pkgInfo == null || !hasPermission(pkgInfo, bp.name)) {
                Slog.i(TAG, "Removing old permission: " + bp.name + " from package " + bp.sourcePackage);
                flags |= UPDATE_PERMISSIONS_ALL;
                it.remove();
            }
        }
    }
    // replace the granted permissions of the system packages.
    if ((flags & UPDATE_PERMISSIONS_ALL) != 0) {
        for (PackageParser.Package pkg : mPackages.values()) {
            if (pkg != pkgInfo) {
                // Only replace for packages on requested volume
                final String volumeUuid = getVolumeUuidForPackage(pkg);
                final boolean replace = ((flags & UPDATE_PERMISSIONS_REPLACE_ALL) != 0) && Objects.equals(replaceVolumeUuid, volumeUuid);
                grantPermissionsLPw(pkg, replace, changingPkg);
            }
        }
    }
    if (pkgInfo != null) {
        // Only replace for packages on requested volume
        final String volumeUuid = getVolumeUuidForPackage(pkgInfo);
        final boolean replace = ((flags & UPDATE_PERMISSIONS_REPLACE_PKG) != 0) && Objects.equals(replaceVolumeUuid, volumeUuid);
        grantPermissionsLPw(pkgInfo, replace, changingPkg);
    }
}
#method_after
private void updatePermissionsLPw(PackageParser.Package pkg, int flags) {
    // Update the parent permissions
    updatePermissionsLPw(pkg.packageName, pkg, flags);
    // Update the child permissions
    final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0;
    for (int i = 0; i < childCount; i++) {
        PackageParser.Package childPkg = pkg.childPackages.get(i);
        updatePermissionsLPw(childPkg.packageName, childPkg, flags);
    }
}
#end_block

#method_before
private void grantPermissionsLPw(PackageParser.Package pkg, boolean replace, String packageOfInterest) {
    // IMPORTANT: There are two types of permissions: install and runtime.
    // Install time permissions are granted when the app is installed to
    // all device users and users added in the future. Runtime permissions
    // are granted at runtime explicitly to specific users. Normal and signature
    // protected permissions are install time permissions. Dangerous permissions
    // are install permissions if the app's target SDK is Lollipop MR1 or older,
    // otherwise they are runtime permissions. This function does not manage
    // runtime permissions except for the case an app targeting Lollipop MR1
    // being upgraded to target a newer SDK, in which case dangerous permissions
    // are transformed from install time to runtime ones.
    final PackageSetting ps = (PackageSetting) pkg.mExtras;
    if (ps == null) {
        return;
    }
    PermissionsState permissionsState = ps.getPermissionsState();
    PermissionsState origPermissions = permissionsState;
    final int[] currentUserIds = UserManagerService.getInstance().getUserIds();
    boolean runtimePermissionsRevoked = false;
    int[] changedRuntimePermissionUserIds = EMPTY_INT_ARRAY;
    boolean changedInstallPermission = false;
    if (replace) {
        ps.installPermissionsFixed = false;
        if (!ps.isSharedUser()) {
            origPermissions = new PermissionsState(permissionsState);
            permissionsState.reset();
        } else {
            // We need to know only about runtime permission changes since the
            // calling code always writes the install permissions state but
            // the runtime ones are written only if changed. The only cases of
            // changed runtime permissions here are promotion of an install to
            // runtime and revocation of a runtime from a shared user.
            changedRuntimePermissionUserIds = revokeUnusedSharedUserPermissionsLPw(ps.sharedUser, UserManagerService.getInstance().getUserIds());
            if (!ArrayUtils.isEmpty(changedRuntimePermissionUserIds)) {
                runtimePermissionsRevoked = true;
            }
        }
    }
    permissionsState.setGlobalGids(mGlobalGids);
    final int N = pkg.requestedPermissions.size();
    for (int i = 0; i < N; i++) {
        final String name = pkg.requestedPermissions.get(i);
        final BasePermission bp = mSettings.mPermissions.get(name);
        if (DEBUG_INSTALL) {
            Log.i(TAG, "Package " + pkg.packageName + " checking " + name + ": " + bp);
        }
        if (bp == null || bp.packageSetting == null) {
            if (packageOfInterest == null || packageOfInterest.equals(pkg.packageName)) {
                Slog.w(TAG, "Unknown permission " + name + " in package " + pkg.packageName);
            }
            continue;
        }
        final String perm = bp.name;
        boolean allowedSig = false;
        int grant = GRANT_DENIED;
        // Keep track of app op permissions.
        if ((bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_APPOP) != 0) {
            ArraySet<String> pkgs = mAppOpPermissionPackages.get(bp.name);
            if (pkgs == null) {
                pkgs = new ArraySet<>();
                mAppOpPermissionPackages.put(bp.name, pkgs);
            }
            pkgs.add(pkg.packageName);
        }
        final int level = bp.protectionLevel & PermissionInfo.PROTECTION_MASK_BASE;
        switch(level) {
            case PermissionInfo.PROTECTION_NORMAL:
                {
                    // For all apps normal permissions are install time ones.
                    grant = GRANT_INSTALL;
                }
                break;
            case PermissionInfo.PROTECTION_DANGEROUS:
                {
                    if (pkg.applicationInfo.targetSdkVersion <= Build.VERSION_CODES.LOLLIPOP_MR1) {
                        // For legacy apps dangerous permissions are install time ones.
                        grant = GRANT_INSTALL_LEGACY;
                    } else if (origPermissions.hasInstallPermission(bp.name)) {
                        // For legacy apps that became modern, install becomes runtime.
                        grant = GRANT_UPGRADE;
                    } else if (mPromoteSystemApps && isSystemApp(ps) && mExistingSystemPackages.contains(ps.name)) {
                        // For legacy system apps, install becomes runtime.
                        // We cannot check hasInstallPermission() for system apps since those
                        // permissions were granted implicitly and not persisted pre-M.
                        grant = GRANT_UPGRADE;
                    } else {
                        // For modern apps keep runtime permissions unchanged.
                        grant = GRANT_RUNTIME;
                    }
                }
                break;
            case PermissionInfo.PROTECTION_SIGNATURE:
                {
                    // For all apps signature permissions are install time ones.
                    allowedSig = grantSignaturePermission(perm, pkg, bp, origPermissions);
                    if (allowedSig) {
                        grant = GRANT_INSTALL;
                    }
                }
                break;
        }
        if (DEBUG_INSTALL) {
            Log.i(TAG, "Package " + pkg.packageName + " granting " + perm);
        }
        if (grant != GRANT_DENIED) {
            if (!isSystemApp(ps) && ps.installPermissionsFixed) {
                // we can't add any new permissions to it.
                if (!allowedSig && !origPermissions.hasInstallPermission(perm)) {
                    // updating the platform).
                    if (!isNewPlatformPermissionForPackage(perm, pkg)) {
                        grant = GRANT_DENIED;
                    }
                }
            }
            switch(grant) {
                case GRANT_INSTALL:
                    {
                        // a runtime permission being downgraded to an install one.
                        for (int userId : UserManagerService.getInstance().getUserIds()) {
                            if (origPermissions.getRuntimePermissionState(bp.name, userId) != null) {
                                // Revoke the runtime permission and clear the flags.
                                origPermissions.revokeRuntimePermission(bp, userId);
                                origPermissions.updatePermissionFlags(bp, userId, PackageManager.MASK_PERMISSION_FLAGS, 0);
                                // If we revoked a permission permission, we have to write.
                                changedRuntimePermissionUserIds = ArrayUtils.appendInt(changedRuntimePermissionUserIds, userId);
                            }
                        }
                        // Grant an install permission.
                        if (permissionsState.grantInstallPermission(bp) != PermissionsState.PERMISSION_OPERATION_FAILURE) {
                            changedInstallPermission = true;
                        }
                    }
                    break;
                case GRANT_INSTALL_LEGACY:
                    {
                        // Grant an install permission.
                        if (permissionsState.grantInstallPermission(bp) != PermissionsState.PERMISSION_OPERATION_FAILURE) {
                            changedInstallPermission = true;
                        }
                    }
                    break;
                case GRANT_RUNTIME:
                    {
                        // Grant previously granted runtime permissions.
                        for (int userId : UserManagerService.getInstance().getUserIds()) {
                            PermissionState permissionState = origPermissions.getRuntimePermissionState(bp.name, userId);
                            final int flags = permissionState != null ? permissionState.getFlags() : 0;
                            if (origPermissions.hasRuntimePermission(bp.name, userId)) {
                                if (permissionsState.grantRuntimePermission(bp, userId) == PermissionsState.PERMISSION_OPERATION_FAILURE) {
                                    // If we cannot put the permission as it was, we have to write.
                                    changedRuntimePermissionUserIds = ArrayUtils.appendInt(changedRuntimePermissionUserIds, userId);
                                }
                            }
                            // Propagate the permission flags.
                            permissionsState.updatePermissionFlags(bp, userId, flags, flags);
                        }
                    }
                    break;
                case GRANT_UPGRADE:
                    {
                        // Grant runtime permissions for a previously held install permission.
                        PermissionState permissionState = origPermissions.getInstallPermissionState(bp.name);
                        final int flags = permissionState != null ? permissionState.getFlags() : 0;
                        if (origPermissions.revokeInstallPermission(bp) != PermissionsState.PERMISSION_OPERATION_FAILURE) {
                            // We will be transferring the permission flags, so clear them.
                            origPermissions.updatePermissionFlags(bp, UserHandle.USER_ALL, PackageManager.MASK_PERMISSION_FLAGS, 0);
                            changedInstallPermission = true;
                        }
                        // also its other flags as they are not applicable to install permissions.
                        if ((flags & PackageManager.FLAG_PERMISSION_REVOKE_ON_UPGRADE) == 0) {
                            for (int userId : currentUserIds) {
                                if (permissionsState.grantRuntimePermission(bp, userId) != PermissionsState.PERMISSION_OPERATION_FAILURE) {
                                    // Transfer the permission flags.
                                    permissionsState.updatePermissionFlags(bp, userId, flags, flags);
                                    // If we granted the permission, we have to write.
                                    changedRuntimePermissionUserIds = ArrayUtils.appendInt(changedRuntimePermissionUserIds, userId);
                                }
                            }
                        }
                    }
                    break;
                default:
                    {
                        if (packageOfInterest == null || packageOfInterest.equals(pkg.packageName)) {
                            Slog.w(TAG, "Not granting permission " + perm + " to package " + pkg.packageName + " because it was previously installed without");
                        }
                    }
                    break;
            }
        } else {
            if (permissionsState.revokeInstallPermission(bp) != PermissionsState.PERMISSION_OPERATION_FAILURE) {
                // Also drop the permission flags.
                permissionsState.updatePermissionFlags(bp, UserHandle.USER_ALL, PackageManager.MASK_PERMISSION_FLAGS, 0);
                changedInstallPermission = true;
                Slog.i(TAG, "Un-granting permission " + perm + " from package " + pkg.packageName + " (protectionLevel=" + bp.protectionLevel + " flags=0x" + Integer.toHexString(pkg.applicationInfo.flags) + ")");
            } else if ((bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_APPOP) == 0) {
                // not to be granted, there is a UI for the user to decide.
                if (packageOfInterest == null || packageOfInterest.equals(pkg.packageName)) {
                    Slog.w(TAG, "Not granting permission " + perm + " to package " + pkg.packageName + " (protectionLevel=" + bp.protectionLevel + " flags=0x" + Integer.toHexString(pkg.applicationInfo.flags) + ")");
                }
            }
        }
    }
    if ((changedInstallPermission || replace) && !ps.installPermissionsFixed && !isSystemApp(ps) || isUpdatedSystemApp(ps)) {
        // This is the first that we have heard about this package, so the
        // permissions we have now selected are fixed until explicitly
        // changed.
        ps.installPermissionsFixed = true;
    }
    // write synchronously to avoid losing runtime permissions state.
    for (int userId : changedRuntimePermissionUserIds) {
        mSettings.writeRuntimePermissionsForUserLPr(userId, runtimePermissionsRevoked);
    }
}
#method_after
private void grantPermissionsLPw(PackageParser.Package pkg, boolean replace, String packageOfInterest) {
    // IMPORTANT: There are two types of permissions: install and runtime.
    // Install time permissions are granted when the app is installed to
    // all device users and users added in the future. Runtime permissions
    // are granted at runtime explicitly to specific users. Normal and signature
    // protected permissions are install time permissions. Dangerous permissions
    // are install permissions if the app's target SDK is Lollipop MR1 or older,
    // otherwise they are runtime permissions. This function does not manage
    // runtime permissions except for the case an app targeting Lollipop MR1
    // being upgraded to target a newer SDK, in which case dangerous permissions
    // are transformed from install time to runtime ones.
    final PackageSetting ps = (PackageSetting) pkg.mExtras;
    if (ps == null) {
        return;
    }
    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "grantPermissions");
    PermissionsState permissionsState = ps.getPermissionsState();
    PermissionsState origPermissions = permissionsState;
    final int[] currentUserIds = UserManagerService.getInstance().getUserIds();
    boolean runtimePermissionsRevoked = false;
    int[] changedRuntimePermissionUserIds = EMPTY_INT_ARRAY;
    boolean changedInstallPermission = false;
    if (replace) {
        ps.installPermissionsFixed = false;
        if (!ps.isSharedUser()) {
            origPermissions = new PermissionsState(permissionsState);
            permissionsState.reset();
        } else {
            // We need to know only about runtime permission changes since the
            // calling code always writes the install permissions state but
            // the runtime ones are written only if changed. The only cases of
            // changed runtime permissions here are promotion of an install to
            // runtime and revocation of a runtime from a shared user.
            changedRuntimePermissionUserIds = revokeUnusedSharedUserPermissionsLPw(ps.sharedUser, UserManagerService.getInstance().getUserIds());
            if (!ArrayUtils.isEmpty(changedRuntimePermissionUserIds)) {
                runtimePermissionsRevoked = true;
            }
        }
    }
    permissionsState.setGlobalGids(mGlobalGids);
    final int N = pkg.requestedPermissions.size();
    for (int i = 0; i < N; i++) {
        final String name = pkg.requestedPermissions.get(i);
        final BasePermission bp = mSettings.mPermissions.get(name);
        if (DEBUG_INSTALL) {
            Log.i(TAG, "Package " + pkg.packageName + " checking " + name + ": " + bp);
        }
        if (bp == null || bp.packageSetting == null) {
            if (packageOfInterest == null || packageOfInterest.equals(pkg.packageName)) {
                Slog.w(TAG, "Unknown permission " + name + " in package " + pkg.packageName);
            }
            continue;
        }
        final String perm = bp.name;
        boolean allowedSig = false;
        int grant = GRANT_DENIED;
        // Keep track of app op permissions.
        if ((bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_APPOP) != 0) {
            ArraySet<String> pkgs = mAppOpPermissionPackages.get(bp.name);
            if (pkgs == null) {
                pkgs = new ArraySet<>();
                mAppOpPermissionPackages.put(bp.name, pkgs);
            }
            pkgs.add(pkg.packageName);
        }
        final int level = bp.protectionLevel & PermissionInfo.PROTECTION_MASK_BASE;
        final boolean appSupportsRuntimePermissions = pkg.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.M;
        switch(level) {
            case PermissionInfo.PROTECTION_NORMAL:
                {
                    // For all apps normal permissions are install time ones.
                    grant = GRANT_INSTALL;
                }
                break;
            case PermissionInfo.PROTECTION_DANGEROUS:
                {
                    // install permission's state is shared across all users.
                    if (!appSupportsRuntimePermissions && !Build.PERMISSIONS_REVIEW_REQUIRED) {
                        // For legacy apps dangerous permissions are install time ones.
                        grant = GRANT_INSTALL;
                    } else if (origPermissions.hasInstallPermission(bp.name)) {
                        // For legacy apps that became modern, install becomes runtime.
                        grant = GRANT_UPGRADE;
                    } else if (mPromoteSystemApps && isSystemApp(ps) && mExistingSystemPackages.contains(ps.name)) {
                        // For legacy system apps, install becomes runtime.
                        // We cannot check hasInstallPermission() for system apps since those
                        // permissions were granted implicitly and not persisted pre-M.
                        grant = GRANT_UPGRADE;
                    } else {
                        // For modern apps keep runtime permissions unchanged.
                        grant = GRANT_RUNTIME;
                    }
                }
                break;
            case PermissionInfo.PROTECTION_SIGNATURE:
                {
                    // For all apps signature permissions are install time ones.
                    allowedSig = grantSignaturePermission(perm, pkg, bp, origPermissions);
                    if (allowedSig) {
                        grant = GRANT_INSTALL;
                    }
                }
                break;
        }
        if (DEBUG_INSTALL) {
            Log.i(TAG, "Package " + pkg.packageName + " granting " + perm);
        }
        if (grant != GRANT_DENIED) {
            if (!isSystemApp(ps) && ps.installPermissionsFixed) {
                // we can't add any new permissions to it.
                if (!allowedSig && !origPermissions.hasInstallPermission(perm)) {
                    // updating the platform).
                    if (!isNewPlatformPermissionForPackage(perm, pkg)) {
                        grant = GRANT_DENIED;
                    }
                }
            }
            switch(grant) {
                case GRANT_INSTALL:
                    {
                        // for legacy apps
                        for (int userId : UserManagerService.getInstance().getUserIds()) {
                            if (origPermissions.getRuntimePermissionState(bp.name, userId) != null) {
                                // Revoke the runtime permission and clear the flags.
                                origPermissions.revokeRuntimePermission(bp, userId);
                                origPermissions.updatePermissionFlags(bp, userId, PackageManager.MASK_PERMISSION_FLAGS, 0);
                                // If we revoked a permission permission, we have to write.
                                changedRuntimePermissionUserIds = ArrayUtils.appendInt(changedRuntimePermissionUserIds, userId);
                            }
                        }
                        // Grant an install permission.
                        if (permissionsState.grantInstallPermission(bp) != PermissionsState.PERMISSION_OPERATION_FAILURE) {
                            changedInstallPermission = true;
                        }
                    }
                    break;
                case GRANT_RUNTIME:
                    {
                        // Grant previously granted runtime permissions.
                        for (int userId : UserManagerService.getInstance().getUserIds()) {
                            PermissionState permissionState = origPermissions.getRuntimePermissionState(bp.name, userId);
                            int flags = permissionState != null ? permissionState.getFlags() : 0;
                            if (origPermissions.hasRuntimePermission(bp.name, userId)) {
                                if (permissionsState.grantRuntimePermission(bp, userId) == PermissionsState.PERMISSION_OPERATION_FAILURE) {
                                    // If we cannot put the permission as it was, we have to write.
                                    changedRuntimePermissionUserIds = ArrayUtils.appendInt(changedRuntimePermissionUserIds, userId);
                                }
                                // If the app supports runtime permissions no need for a review.
                                if (Build.PERMISSIONS_REVIEW_REQUIRED && appSupportsRuntimePermissions && (flags & PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED) != 0) {
                                    flags &= ~PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED;
                                    // Since we changed the flags, we have to write.
                                    changedRuntimePermissionUserIds = ArrayUtils.appendInt(changedRuntimePermissionUserIds, userId);
                                }
                            } else if (Build.PERMISSIONS_REVIEW_REQUIRED && !appSupportsRuntimePermissions) {
                                // apps don't expect to run with revoked permissions.
                                if (PLATFORM_PACKAGE_NAME.equals(bp.sourcePackage)) {
                                    if ((flags & FLAG_PERMISSION_REVIEW_REQUIRED) == 0) {
                                        flags |= FLAG_PERMISSION_REVIEW_REQUIRED;
                                        // We changed the flags, hence have to write.
                                        changedRuntimePermissionUserIds = ArrayUtils.appendInt(changedRuntimePermissionUserIds, userId);
                                    }
                                }
                                if (permissionsState.grantRuntimePermission(bp, userId) != PermissionsState.PERMISSION_OPERATION_FAILURE) {
                                    // We changed the permission, hence have to write.
                                    changedRuntimePermissionUserIds = ArrayUtils.appendInt(changedRuntimePermissionUserIds, userId);
                                }
                            }
                            // Propagate the permission flags.
                            permissionsState.updatePermissionFlags(bp, userId, flags, flags);
                        }
                    }
                    break;
                case GRANT_UPGRADE:
                    {
                        // Grant runtime permissions for a previously held install permission.
                        PermissionState permissionState = origPermissions.getInstallPermissionState(bp.name);
                        final int flags = permissionState != null ? permissionState.getFlags() : 0;
                        if (origPermissions.revokeInstallPermission(bp) != PermissionsState.PERMISSION_OPERATION_FAILURE) {
                            // We will be transferring the permission flags, so clear them.
                            origPermissions.updatePermissionFlags(bp, UserHandle.USER_ALL, PackageManager.MASK_PERMISSION_FLAGS, 0);
                            changedInstallPermission = true;
                        }
                        // also its other flags as they are not applicable to install permissions.
                        if ((flags & PackageManager.FLAG_PERMISSION_REVOKE_ON_UPGRADE) == 0) {
                            for (int userId : currentUserIds) {
                                if (permissionsState.grantRuntimePermission(bp, userId) != PermissionsState.PERMISSION_OPERATION_FAILURE) {
                                    // Transfer the permission flags.
                                    permissionsState.updatePermissionFlags(bp, userId, flags, flags);
                                    // If we granted the permission, we have to write.
                                    changedRuntimePermissionUserIds = ArrayUtils.appendInt(changedRuntimePermissionUserIds, userId);
                                }
                            }
                        }
                    }
                    break;
                default:
                    {
                        if (packageOfInterest == null || packageOfInterest.equals(pkg.packageName)) {
                            Slog.w(TAG, "Not granting permission " + perm + " to package " + pkg.packageName + " because it was previously installed without");
                        }
                    }
                    break;
            }
        } else {
            if (permissionsState.revokeInstallPermission(bp) != PermissionsState.PERMISSION_OPERATION_FAILURE) {
                // Also drop the permission flags.
                permissionsState.updatePermissionFlags(bp, UserHandle.USER_ALL, PackageManager.MASK_PERMISSION_FLAGS, 0);
                changedInstallPermission = true;
                Slog.i(TAG, "Un-granting permission " + perm + " from package " + pkg.packageName + " (protectionLevel=" + bp.protectionLevel + " flags=0x" + Integer.toHexString(pkg.applicationInfo.flags) + ")");
            } else if ((bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_APPOP) == 0) {
                // not to be granted, there is a UI for the user to decide.
                if (packageOfInterest == null || packageOfInterest.equals(pkg.packageName)) {
                    Slog.w(TAG, "Not granting permission " + perm + " to package " + pkg.packageName + " (protectionLevel=" + bp.protectionLevel + " flags=0x" + Integer.toHexString(pkg.applicationInfo.flags) + ")");
                }
            }
        }
    }
    if ((changedInstallPermission || replace) && !ps.installPermissionsFixed && !isSystemApp(ps) || isUpdatedSystemApp(ps)) {
        // This is the first that we have heard about this package, so the
        // permissions we have now selected are fixed until explicitly
        // changed.
        ps.installPermissionsFixed = true;
    }
    // write synchronously to avoid losing runtime permissions state.
    for (int userId : changedRuntimePermissionUserIds) {
        mSettings.writeRuntimePermissionsForUserLPr(userId, runtimePermissionsRevoked);
    }
    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
}
#end_block

#method_before
private boolean grantSignaturePermission(String perm, PackageParser.Package pkg, BasePermission bp, PermissionsState origPermissions) {
    boolean allowed;
    allowed = (compareSignatures(bp.packageSetting.signatures.mSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH) || (compareSignatures(mPlatformPackage.mSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH);
    if (!allowed && (bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_PRIVILEGED) != 0) {
        if (isSystemApp(pkg)) {
            // is granted only if it had been defined by the original application.
            if (pkg.isUpdatedSystemApp()) {
                final PackageSetting sysPs = mSettings.getDisabledSystemPkgLPr(pkg.packageName);
                if (sysPs.getPermissionsState().hasInstallPermission(perm)) {
                    // update.
                    if (sysPs.isPrivileged()) {
                        allowed = true;
                    }
                } else {
                    // privileged to get it.
                    if (sysPs.pkg != null && sysPs.isPrivileged()) {
                        for (int j = 0; j < sysPs.pkg.requestedPermissions.size(); j++) {
                            if (perm.equals(sysPs.pkg.requestedPermissions.get(j))) {
                                allowed = true;
                                break;
                            }
                        }
                    }
                }
            } else {
                allowed = isPrivilegedApp(pkg);
            }
        }
    }
    if (!allowed) {
        if (!allowed && (bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_PRE23) != 0 && pkg.applicationInfo.targetSdkVersion < Build.VERSION_CODES.M) {
            // If this was a previously normal/dangerous permission that got moved
            // to a system permission as part of the runtime permission redesign, then
            // we still want to blindly grant it to old apps.
            allowed = true;
        }
        if (!allowed && (bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_INSTALLER) != 0 && pkg.packageName.equals(mRequiredInstallerPackage)) {
            // If this permission is to be granted to the system installer and
            // this app is an installer, then it gets the permission.
            allowed = true;
        }
        if (!allowed && (bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_VERIFIER) != 0 && pkg.packageName.equals(mRequiredVerifierPackage)) {
            // If this permission is to be granted to the system verifier and
            // this app is a verifier, then it gets the permission.
            allowed = true;
        }
        if (!allowed && (bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_PREINSTALLED) != 0 && isSystemApp(pkg)) {
            // Any pre-installed system app is allowed to get this permission.
            allowed = true;
        }
        if (!allowed && (bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0) {
            // For development permissions, a development permission
            // is granted only if it was already granted.
            allowed = origPermissions.hasInstallPermission(perm);
        }
    }
    return allowed;
}
#method_after
private boolean grantSignaturePermission(String perm, PackageParser.Package pkg, BasePermission bp, PermissionsState origPermissions) {
    boolean allowed;
    allowed = (compareSignatures(bp.packageSetting.signatures.mSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH) || (compareSignatures(mPlatformPackage.mSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH);
    if (!allowed && (bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_PRIVILEGED) != 0) {
        if (isSystemApp(pkg)) {
            // is granted only if it had been defined by the original application.
            if (pkg.isUpdatedSystemApp()) {
                final PackageSetting sysPs = mSettings.getDisabledSystemPkgLPr(pkg.packageName);
                if (sysPs != null && sysPs.getPermissionsState().hasInstallPermission(perm)) {
                    // update.
                    if (sysPs.isPrivileged()) {
                        allowed = true;
                    }
                } else {
                    // privileged to get it.
                    if (sysPs != null && sysPs.pkg != null && sysPs.isPrivileged()) {
                        for (int j = 0; j < sysPs.pkg.requestedPermissions.size(); j++) {
                            if (perm.equals(sysPs.pkg.requestedPermissions.get(j))) {
                                allowed = true;
                                break;
                            }
                        }
                    }
                    // packages can also get the permission.
                    if (pkg.parentPackage != null) {
                        final PackageSetting disabledSysParentPs = mSettings.getDisabledSystemPkgLPr(pkg.parentPackage.packageName);
                        if (disabledSysParentPs != null && disabledSysParentPs.pkg != null && disabledSysParentPs.isPrivileged()) {
                            if (isPackageRequestingPermission(disabledSysParentPs.pkg, perm)) {
                                allowed = true;
                            } else if (disabledSysParentPs.pkg.childPackages != null) {
                                final int count = disabledSysParentPs.pkg.childPackages.size();
                                for (int i = 0; i < count; i++) {
                                    PackageParser.Package disabledSysChildPkg = disabledSysParentPs.pkg.childPackages.get(i);
                                    if (isPackageRequestingPermission(disabledSysChildPkg, perm)) {
                                        allowed = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                allowed = isPrivilegedApp(pkg);
            }
        }
    }
    if (!allowed) {
        if (!allowed && (bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_PRE23) != 0 && pkg.applicationInfo.targetSdkVersion < Build.VERSION_CODES.M) {
            // If this was a previously normal/dangerous permission that got moved
            // to a system permission as part of the runtime permission redesign, then
            // we still want to blindly grant it to old apps.
            allowed = true;
        }
        if (!allowed && (bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_INSTALLER) != 0 && pkg.packageName.equals(mRequiredInstallerPackage)) {
            // If this permission is to be granted to the system installer and
            // this app is an installer, then it gets the permission.
            allowed = true;
        }
        if (!allowed && (bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_VERIFIER) != 0 && pkg.packageName.equals(mRequiredVerifierPackage)) {
            // If this permission is to be granted to the system verifier and
            // this app is a verifier, then it gets the permission.
            allowed = true;
        }
        if (!allowed && (bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_PREINSTALLED) != 0 && isSystemApp(pkg)) {
            // Any pre-installed system app is allowed to get this permission.
            allowed = true;
        }
        if (!allowed && (bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0) {
            // For development permissions, a development permission
            // is granted only if it was already granted.
            allowed = origPermissions.hasInstallPermission(perm);
        }
        if (!allowed && (bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_SETUP) != 0 && pkg.packageName.equals(mSetupWizardPackage)) {
            // If this permission is to be granted to the system setup wizard and
            // this app is a setup wizard, then it gets the permission.
            allowed = true;
        }
    }
    return allowed;
}
#end_block

#method_before
public final void addActivity(PackageParser.Activity a, String type) {
    final boolean systemApp = a.info.applicationInfo.isSystemApp();
    mActivities.put(a.getComponentName(), a);
    if (DEBUG_SHOW_INFO)
        Log.v(TAG, "  " + type + " " + (a.info.nonLocalizedLabel != null ? a.info.nonLocalizedLabel : a.info.name) + ":");
    if (DEBUG_SHOW_INFO)
        Log.v(TAG, "    Class=" + a.info.name);
    final int NI = a.intents.size();
    for (int j = 0; j < NI; j++) {
        PackageParser.ActivityIntentInfo intent = a.intents.get(j);
        if (!systemApp && intent.getPriority() > 0 && "activity".equals(type)) {
            intent.setPriority(0);
            Log.w(TAG, "Package " + a.info.applicationInfo.packageName + " has activity " + a.className + " with priority > 0, forcing to 0");
        }
        if (DEBUG_SHOW_INFO) {
            Log.v(TAG, "    IntentFilter:");
            intent.dump(new LogPrinter(Log.VERBOSE, TAG), "      ");
        }
        if (!intent.debugCheck()) {
            Log.w(TAG, "==> For Activity " + a.info.name);
        }
        addFilter(intent);
    }
}
#method_after
public final void addActivity(PackageParser.Activity a, String type) {
    mActivities.put(a.getComponentName(), a);
    if (DEBUG_SHOW_INFO)
        Log.v(TAG, "  " + type + " " + (a.info.nonLocalizedLabel != null ? a.info.nonLocalizedLabel : a.info.name) + ":");
    if (DEBUG_SHOW_INFO)
        Log.v(TAG, "    Class=" + a.info.name);
    final int NI = a.intents.size();
    for (int j = 0; j < NI; j++) {
        PackageParser.ActivityIntentInfo intent = a.intents.get(j);
        if ("activity".equals(type)) {
            final PackageSetting ps = mSettings.getDisabledSystemPkgLPr(intent.activity.info.packageName);
            final List<PackageParser.Activity> systemActivities = ps != null && ps.pkg != null ? ps.pkg.activities : null;
            adjustPriority(systemActivities, intent);
        }
        if (DEBUG_SHOW_INFO) {
            Log.v(TAG, "    IntentFilter:");
            intent.dump(new LogPrinter(Log.VERBOSE, TAG), "      ");
        }
        if (!intent.debugCheck()) {
            Log.w(TAG, "==> For Activity " + a.info.name);
        }
        addFilter(intent);
    }
}
#end_block

#method_before
@Override
protected ResolveInfo newResult(PackageParser.ActivityIntentInfo info, int match, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    if (!mSettings.isEnabledLPr(info.activity.info, mFlags, userId)) {
        return null;
    }
    final PackageParser.Activity activity = info.activity;
    if (mSafeMode && (activity.info.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
        return null;
    }
    PackageSetting ps = (PackageSetting) activity.owner.mExtras;
    if (ps == null) {
        return null;
    }
    ActivityInfo ai = PackageParser.generateActivityInfo(activity, mFlags, ps.readUserState(userId), userId);
    if (ai == null) {
        return null;
    }
    final ResolveInfo res = new ResolveInfo();
    res.activityInfo = ai;
    if ((mFlags & PackageManager.GET_RESOLVED_FILTER) != 0) {
        res.filter = info;
    }
    if (info != null) {
        res.handleAllWebDataURI = info.handleAllWebDataURI();
    }
    res.priority = info.getPriority();
    res.preferredOrder = activity.owner.mPreferredOrder;
    // System.out.println("Result: " + res.activityInfo.className +
    // " = " + res.priority);
    res.match = match;
    res.isDefault = info.hasDefault;
    res.labelRes = info.labelRes;
    res.nonLocalizedLabel = info.nonLocalizedLabel;
    if (userNeedsBadging(userId)) {
        res.noResourceId = true;
    } else {
        res.icon = info.icon;
    }
    res.iconResourceId = info.icon;
    res.system = res.activityInfo.applicationInfo.isSystemApp();
    return res;
}
#method_after
@Override
protected ResolveInfo newResult(PackageParser.ActivityIntentInfo info, int match, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    if (!mSettings.isEnabledAndMatchLPr(info.activity.info, mFlags, userId)) {
        return null;
    }
    final PackageParser.Activity activity = info.activity;
    PackageSetting ps = (PackageSetting) activity.owner.mExtras;
    if (ps == null) {
        return null;
    }
    ActivityInfo ai = PackageParser.generateActivityInfo(activity, mFlags, ps.readUserState(userId), userId);
    if (ai == null) {
        return null;
    }
    final ResolveInfo res = new ResolveInfo();
    res.activityInfo = ai;
    if ((mFlags & PackageManager.GET_RESOLVED_FILTER) != 0) {
        res.filter = info;
    }
    if (info != null) {
        res.handleAllWebDataURI = info.handleAllWebDataURI();
    }
    res.priority = info.getPriority();
    res.preferredOrder = activity.owner.mPreferredOrder;
    // System.out.println("Result: " + res.activityInfo.className +
    // " = " + res.priority);
    res.match = match;
    res.isDefault = info.hasDefault;
    res.labelRes = info.labelRes;
    res.nonLocalizedLabel = info.nonLocalizedLabel;
    if (userNeedsBadging(userId)) {
        res.noResourceId = true;
    } else {
        res.icon = info.icon;
    }
    res.iconResourceId = info.icon;
    res.system = res.activityInfo.applicationInfo.isSystemApp();
    return res;
}
#end_block

#method_before
@Override
protected ResolveInfo newResult(PackageParser.ServiceIntentInfo filter, int match, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    final PackageParser.ServiceIntentInfo info = (PackageParser.ServiceIntentInfo) filter;
    if (!mSettings.isEnabledLPr(info.service.info, mFlags, userId)) {
        return null;
    }
    final PackageParser.Service service = info.service;
    if (mSafeMode && (service.info.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
        return null;
    }
    PackageSetting ps = (PackageSetting) service.owner.mExtras;
    if (ps == null) {
        return null;
    }
    ServiceInfo si = PackageParser.generateServiceInfo(service, mFlags, ps.readUserState(userId), userId);
    if (si == null) {
        return null;
    }
    final ResolveInfo res = new ResolveInfo();
    res.serviceInfo = si;
    if ((mFlags & PackageManager.GET_RESOLVED_FILTER) != 0) {
        res.filter = filter;
    }
    res.priority = info.getPriority();
    res.preferredOrder = service.owner.mPreferredOrder;
    res.match = match;
    res.isDefault = info.hasDefault;
    res.labelRes = info.labelRes;
    res.nonLocalizedLabel = info.nonLocalizedLabel;
    res.icon = info.icon;
    res.system = res.serviceInfo.applicationInfo.isSystemApp();
    return res;
}
#method_after
@Override
protected ResolveInfo newResult(PackageParser.ServiceIntentInfo filter, int match, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    final PackageParser.ServiceIntentInfo info = (PackageParser.ServiceIntentInfo) filter;
    if (!mSettings.isEnabledAndMatchLPr(info.service.info, mFlags, userId)) {
        return null;
    }
    final PackageParser.Service service = info.service;
    PackageSetting ps = (PackageSetting) service.owner.mExtras;
    if (ps == null) {
        return null;
    }
    ServiceInfo si = PackageParser.generateServiceInfo(service, mFlags, ps.readUserState(userId), userId);
    if (si == null) {
        return null;
    }
    final ResolveInfo res = new ResolveInfo();
    res.serviceInfo = si;
    if ((mFlags & PackageManager.GET_RESOLVED_FILTER) != 0) {
        res.filter = filter;
    }
    res.priority = info.getPriority();
    res.preferredOrder = service.owner.mPreferredOrder;
    res.match = match;
    res.isDefault = info.hasDefault;
    res.labelRes = info.labelRes;
    res.nonLocalizedLabel = info.nonLocalizedLabel;
    res.icon = info.icon;
    res.system = res.serviceInfo.applicationInfo.isSystemApp();
    return res;
}
#end_block

#method_before
@Override
protected ResolveInfo newResult(PackageParser.ProviderIntentInfo filter, int match, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    final PackageParser.ProviderIntentInfo info = filter;
    if (!mSettings.isEnabledLPr(info.provider.info, mFlags, userId)) {
        return null;
    }
    final PackageParser.Provider provider = info.provider;
    if (mSafeMode && (provider.info.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
        return null;
    }
    PackageSetting ps = (PackageSetting) provider.owner.mExtras;
    if (ps == null) {
        return null;
    }
    ProviderInfo pi = PackageParser.generateProviderInfo(provider, mFlags, ps.readUserState(userId), userId);
    if (pi == null) {
        return null;
    }
    final ResolveInfo res = new ResolveInfo();
    res.providerInfo = pi;
    if ((mFlags & PackageManager.GET_RESOLVED_FILTER) != 0) {
        res.filter = filter;
    }
    res.priority = info.getPriority();
    res.preferredOrder = provider.owner.mPreferredOrder;
    res.match = match;
    res.isDefault = info.hasDefault;
    res.labelRes = info.labelRes;
    res.nonLocalizedLabel = info.nonLocalizedLabel;
    res.icon = info.icon;
    res.system = res.providerInfo.applicationInfo.isSystemApp();
    return res;
}
#method_after
@Override
protected ResolveInfo newResult(PackageParser.ProviderIntentInfo filter, int match, int userId) {
    if (!sUserManager.exists(userId))
        return null;
    final PackageParser.ProviderIntentInfo info = filter;
    if (!mSettings.isEnabledAndMatchLPr(info.provider.info, mFlags, userId)) {
        return null;
    }
    final PackageParser.Provider provider = info.provider;
    PackageSetting ps = (PackageSetting) provider.owner.mExtras;
    if (ps == null) {
        return null;
    }
    ProviderInfo pi = PackageParser.generateProviderInfo(provider, mFlags, ps.readUserState(userId), userId);
    if (pi == null) {
        return null;
    }
    final ResolveInfo res = new ResolveInfo();
    res.providerInfo = pi;
    if ((mFlags & PackageManager.GET_RESOLVED_FILTER) != 0) {
        res.filter = filter;
    }
    res.priority = info.getPriority();
    res.preferredOrder = provider.owner.mPreferredOrder;
    res.match = match;
    res.isDefault = info.hasDefault;
    res.labelRes = info.labelRes;
    res.nonLocalizedLabel = info.nonLocalizedLabel;
    res.icon = info.icon;
    res.system = res.providerInfo.applicationInfo.isSystemApp();
    return res;
}
#end_block

#method_before
final void sendPackageBroadcast(final String action, final String pkg, final Bundle extras, final String targetPkg, final IIntentReceiver finishedReceiver, final int[] userIds) {
    mHandler.post(new Runnable() {

        @Override
        public void run() {
            try {
                final IActivityManager am = ActivityManagerNative.getDefault();
                if (am == null)
                    return;
                final int[] resolvedUserIds;
                if (userIds == null) {
                    resolvedUserIds = am.getRunningUserIds();
                } else {
                    resolvedUserIds = userIds;
                }
                for (int id : resolvedUserIds) {
                    final Intent intent = new Intent(action, pkg != null ? Uri.fromParts("package", pkg, null) : null);
                    if (extras != null) {
                        intent.putExtras(extras);
                    }
                    if (targetPkg != null) {
                        intent.setPackage(targetPkg);
                    }
                    // Modify the UID when posting to other users
                    int uid = intent.getIntExtra(Intent.EXTRA_UID, -1);
                    if (uid > 0 && UserHandle.getUserId(uid) != id) {
                        uid = UserHandle.getUid(id, UserHandle.getAppId(uid));
                        intent.putExtra(Intent.EXTRA_UID, uid);
                    }
                    intent.putExtra(Intent.EXTRA_USER_HANDLE, id);
                    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
                    if (DEBUG_BROADCASTS) {
                        RuntimeException here = new RuntimeException("here");
                        here.fillInStackTrace();
                        Slog.d(TAG, "Sending to user " + id + ": " + intent.toShortString(false, true, false, false) + " " + intent.getExtras(), here);
                    }
                    am.broadcastIntent(null, intent, null, finishedReceiver, 0, null, null, null, android.app.AppOpsManager.OP_NONE, null, finishedReceiver != null, false, id);
                }
            } catch (RemoteException ex) {
            }
        }
    });
}
#method_after
final void sendPackageBroadcast(final String action, final String pkg, final Bundle extras, final int flags, final String targetPkg, final IIntentReceiver finishedReceiver, final int[] userIds) {
    mHandler.post(new Runnable() {

        @Override
        public void run() {
            try {
                final IActivityManager am = ActivityManagerNative.getDefault();
                if (am == null)
                    return;
                final int[] resolvedUserIds;
                if (userIds == null) {
                    resolvedUserIds = am.getRunningUserIds();
                } else {
                    resolvedUserIds = userIds;
                }
                for (int id : resolvedUserIds) {
                    final Intent intent = new Intent(action, pkg != null ? Uri.fromParts("package", pkg, null) : null);
                    if (extras != null) {
                        intent.putExtras(extras);
                    }
                    if (targetPkg != null) {
                        intent.setPackage(targetPkg);
                    }
                    // Modify the UID when posting to other users
                    int uid = intent.getIntExtra(Intent.EXTRA_UID, -1);
                    if (uid > 0 && UserHandle.getUserId(uid) != id) {
                        uid = UserHandle.getUid(id, UserHandle.getAppId(uid));
                        intent.putExtra(Intent.EXTRA_UID, uid);
                    }
                    intent.putExtra(Intent.EXTRA_USER_HANDLE, id);
                    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT | flags);
                    if (DEBUG_BROADCASTS) {
                        RuntimeException here = new RuntimeException("here");
                        here.fillInStackTrace();
                        Slog.d(TAG, "Sending to user " + id + ": " + intent.toShortString(false, true, false, false) + " " + intent.getExtras(), here);
                    }
                    am.broadcastIntent(null, intent, null, finishedReceiver, 0, null, null, null, android.app.AppOpsManager.OP_NONE, null, finishedReceiver != null, false, id);
                }
            } catch (RemoteException ex) {
            }
        }
    });
}
#end_block

#method_before
void startCleaningPackages() {
    // reader
    synchronized (mPackages) {
        if (!isExternalMediaAvailable()) {
            return;
        }
        if (mSettings.mPackagesToBeCleaned.isEmpty()) {
            return;
        }
    }
    Intent intent = new Intent(PackageManager.ACTION_CLEAN_EXTERNAL_STORAGE);
    intent.setComponent(DEFAULT_CONTAINER_COMPONENT);
    IActivityManager am = ActivityManagerNative.getDefault();
    if (am != null) {
        try {
            am.startService(null, intent, null, mContext.getOpPackageName(), UserHandle.USER_OWNER);
        } catch (RemoteException e) {
        }
    }
}
#method_after
void startCleaningPackages() {
    // reader
    if (!isExternalMediaAvailable()) {
        return;
    }
    synchronized (mPackages) {
        if (mSettings.mPackagesToBeCleaned.isEmpty()) {
            return;
        }
    }
    Intent intent = new Intent(PackageManager.ACTION_CLEAN_EXTERNAL_STORAGE);
    intent.setComponent(DEFAULT_CONTAINER_COMPONENT);
    IActivityManager am = ActivityManagerNative.getDefault();
    if (am != null) {
        try {
            am.startService(null, intent, null, mContext.getOpPackageName(), UserHandle.USER_SYSTEM);
        } catch (RemoteException e) {
        }
    }
}
#end_block

#method_before
@Override
public void installPackageAsUser(String originPath, IPackageInstallObserver2 observer, int installFlags, String installerPackageName, VerificationParams verificationParams, String packageAbiOverride, int userId) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.INSTALL_PACKAGES, null);
    final int callingUid = Binder.getCallingUid();
    enforceCrossUserPermission(callingUid, userId, true, true, "installPackageAsUser");
    if (isUserRestricted(userId, UserManager.DISALLOW_INSTALL_APPS)) {
        try {
            if (observer != null) {
                observer.onPackageInstalled("", INSTALL_FAILED_USER_RESTRICTED, null, null);
            }
        } catch (RemoteException re) {
        }
        return;
    }
    if ((callingUid == Process.SHELL_UID) || (callingUid == Process.ROOT_UID)) {
        installFlags |= PackageManager.INSTALL_FROM_ADB;
    } else {
        // Caller holds INSTALL_PACKAGES permission, so we're less strict
        // about installerPackageName.
        installFlags &= ~PackageManager.INSTALL_FROM_ADB;
        installFlags &= ~PackageManager.INSTALL_ALL_USERS;
    }
    UserHandle user;
    if ((installFlags & PackageManager.INSTALL_ALL_USERS) != 0) {
        user = UserHandle.ALL;
    } else {
        user = new UserHandle(userId);
    }
    // Only system components can circumvent runtime permissions when installing.
    if ((installFlags & PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0 && mContext.checkCallingOrSelfPermission(Manifest.permission.INSTALL_GRANT_RUNTIME_PERMISSIONS) == PackageManager.PERMISSION_DENIED) {
        throw new SecurityException("You need the " + "android.permission.INSTALL_GRANT_RUNTIME_PERMISSIONS permission " + "to use the PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS flag");
    }
    verificationParams.setInstallerUid(callingUid);
    final File originFile = new File(originPath);
    final OriginInfo origin = OriginInfo.fromUntrustedFile(originFile);
    final Message msg = mHandler.obtainMessage(INIT_COPY);
    msg.obj = new InstallParams(origin, null, observer, installFlags, installerPackageName, null, verificationParams, user, packageAbiOverride, null);
    mHandler.sendMessage(msg);
}
#method_after
@Override
public void installPackageAsUser(String originPath, IPackageInstallObserver2 observer, int installFlags, String installerPackageName, int userId) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.INSTALL_PACKAGES, null);
    final int callingUid = Binder.getCallingUid();
    enforceCrossUserPermission(callingUid, userId, true, /* requireFullPermission */
    true, /* checkShell */
    "installPackageAsUser");
    if (isUserRestricted(userId, UserManager.DISALLOW_INSTALL_APPS)) {
        try {
            if (observer != null) {
                observer.onPackageInstalled("", INSTALL_FAILED_USER_RESTRICTED, null, null);
            }
        } catch (RemoteException re) {
        }
        return;
    }
    if ((callingUid == Process.SHELL_UID) || (callingUid == Process.ROOT_UID)) {
        installFlags |= PackageManager.INSTALL_FROM_ADB;
    } else {
        // Caller holds INSTALL_PACKAGES permission, so we're less strict
        // about installerPackageName.
        installFlags &= ~PackageManager.INSTALL_FROM_ADB;
        installFlags &= ~PackageManager.INSTALL_ALL_USERS;
    }
    UserHandle user;
    if ((installFlags & PackageManager.INSTALL_ALL_USERS) != 0) {
        user = UserHandle.ALL;
    } else {
        user = new UserHandle(userId);
    }
    // Only system components can circumvent runtime permissions when installing.
    if ((installFlags & PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0 && mContext.checkCallingOrSelfPermission(Manifest.permission.INSTALL_GRANT_RUNTIME_PERMISSIONS) == PackageManager.PERMISSION_DENIED) {
        throw new SecurityException("You need the " + "android.permission.INSTALL_GRANT_RUNTIME_PERMISSIONS permission " + "to use the PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS flag");
    }
    final File originFile = new File(originPath);
    final OriginInfo origin = OriginInfo.fromUntrustedFile(originFile);
    final Message msg = mHandler.obtainMessage(INIT_COPY);
    final VerificationInfo verificationInfo = new VerificationInfo(null, /*originatingUri*/
    null, /*referrer*/
    -1, /*originatingUid*/
    callingUid);
    final InstallParams params = new InstallParams(origin, null, /*moveInfo*/
    observer, installFlags, installerPackageName, null, /*volumeUuid*/
    verificationInfo, user, null, /*packageAbiOverride*/
    null, /*grantedPermissions*/
    null);
    params.setTraceMethod("installAsUser").setTraceCookie(System.identityHashCode(params));
    msg.obj = params;
    Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, "installAsUser", System.identityHashCode(msg.obj));
    Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, "queueInstall", System.identityHashCode(msg.obj));
    mHandler.sendMessage(msg);
}
#end_block

#method_before
void installStage(String packageName, File stagedDir, String stagedCid, IPackageInstallObserver2 observer, PackageInstaller.SessionParams params, String installerPackageName, int installerUid, UserHandle user) {
    final VerificationParams verifParams = new VerificationParams(null, params.originatingUri, params.referrerUri, params.originatingUid, null);
    verifParams.setInstallerUid(installerUid);
    final OriginInfo origin;
    if (stagedDir != null) {
        origin = OriginInfo.fromStagedFile(stagedDir);
    } else {
        origin = OriginInfo.fromStagedContainer(stagedCid);
    }
    final Message msg = mHandler.obtainMessage(INIT_COPY);
    msg.obj = new InstallParams(origin, null, observer, params.installFlags, installerPackageName, params.volumeUuid, verifParams, user, params.abiOverride, params.grantedRuntimePermissions);
    mHandler.sendMessage(msg);
}
#method_after
void installStage(String packageName, File stagedDir, String stagedCid, IPackageInstallObserver2 observer, PackageInstaller.SessionParams sessionParams, String installerPackageName, int installerUid, UserHandle user, Certificate[][] certificates) {
    if (DEBUG_EPHEMERAL) {
        if ((sessionParams.installFlags & PackageManager.INSTALL_EPHEMERAL) != 0) {
            Slog.d(TAG, "Ephemeral install of " + packageName);
        }
    }
    final VerificationInfo verificationInfo = new VerificationInfo(sessionParams.originatingUri, sessionParams.referrerUri, sessionParams.originatingUid, installerUid);
    final OriginInfo origin;
    if (stagedDir != null) {
        origin = OriginInfo.fromStagedFile(stagedDir);
    } else {
        origin = OriginInfo.fromStagedContainer(stagedCid);
    }
    final Message msg = mHandler.obtainMessage(INIT_COPY);
    final InstallParams params = new InstallParams(origin, null, observer, sessionParams.installFlags, installerPackageName, sessionParams.volumeUuid, verificationInfo, user, sessionParams.abiOverride, sessionParams.grantedRuntimePermissions, certificates);
    params.setTraceMethod("installStage").setTraceCookie(System.identityHashCode(params));
    msg.obj = params;
    Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, "installStage", System.identityHashCode(msg.obj));
    Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, "queueInstall", System.identityHashCode(msg.obj));
    mHandler.sendMessage(msg);
}
#end_block

#method_before
private void sendPackageAddedForUser(String packageName, PackageSetting pkgSetting, int userId) {
    Bundle extras = new Bundle(1);
    extras.putInt(Intent.EXTRA_UID, UserHandle.getUid(userId, pkgSetting.appId));
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, packageName, extras, null, null, new int[] { userId });
    try {
        IActivityManager am = ActivityManagerNative.getDefault();
        final boolean isSystem = isSystemApp(pkgSetting) || isUpdatedSystemApp(pkgSetting);
        if (isSystem && am.isUserRunning(userId, false)) {
            // The just-installed/enabled app is bundled on the system, so presumed
            // to be able to run automatically without needing an explicit launch.
            // Send it a BOOT_COMPLETED if it would ordinarily have gotten one.
            Intent bcIntent = new Intent(Intent.ACTION_BOOT_COMPLETED).addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES).setPackage(packageName);
            am.broadcastIntent(null, bcIntent, null, null, 0, null, null, null, android.app.AppOpsManager.OP_NONE, null, false, false, userId);
        }
    } catch (RemoteException e) {
        // shouldn't happen
        Slog.w(TAG, "Unable to bootstrap installed package", e);
    }
}
#method_after
private void sendPackageAddedForUser(String packageName, PackageSetting pkgSetting, int userId) {
    final boolean isSystem = isSystemApp(pkgSetting) || isUpdatedSystemApp(pkgSetting);
    sendPackageAddedForUser(packageName, isSystem, pkgSetting.appId, userId);
}
#end_block

#method_before
private void sendPackageAddedForUser(String packageName, PackageSetting pkgSetting, int userId) {
    Bundle extras = new Bundle(1);
    extras.putInt(Intent.EXTRA_UID, UserHandle.getUid(userId, pkgSetting.appId));
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, packageName, extras, null, null, new int[] { userId });
    try {
        IActivityManager am = ActivityManagerNative.getDefault();
        final boolean isSystem = isSystemApp(pkgSetting) || isUpdatedSystemApp(pkgSetting);
        if (isSystem && am.isUserRunning(userId, false)) {
            // The just-installed/enabled app is bundled on the system, so presumed
            // to be able to run automatically without needing an explicit launch.
            // Send it a BOOT_COMPLETED if it would ordinarily have gotten one.
            Intent bcIntent = new Intent(Intent.ACTION_BOOT_COMPLETED).addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES).setPackage(packageName);
            am.broadcastIntent(null, bcIntent, null, null, 0, null, null, null, android.app.AppOpsManager.OP_NONE, null, false, false, userId);
        }
    } catch (RemoteException e) {
        // shouldn't happen
        Slog.w(TAG, "Unable to bootstrap installed package", e);
    }
}
#method_after
private void sendPackageAddedForUser(String packageName, boolean isSystem, int appId, int userId) {
    Bundle extras = new Bundle(1);
    extras.putInt(Intent.EXTRA_UID, UserHandle.getUid(userId, appId));
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, packageName, extras, 0, null, null, new int[] { userId });
    try {
        IActivityManager am = ActivityManagerNative.getDefault();
        if (isSystem && am.isUserRunning(userId, 0)) {
            // The just-installed/enabled app is bundled on the system, so presumed
            // to be able to run automatically without needing an explicit launch.
            // Send it a BOOT_COMPLETED if it would ordinarily have gotten one.
            Intent bcIntent = new Intent(Intent.ACTION_BOOT_COMPLETED).addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES).setPackage(packageName);
            am.broadcastIntent(null, bcIntent, null, null, 0, null, null, null, android.app.AppOpsManager.OP_NONE, null, false, false, userId);
        }
    } catch (RemoteException e) {
        // shouldn't happen
        Slog.w(TAG, "Unable to bootstrap installed package", e);
    }
}
#end_block

#method_before
@Override
public boolean setApplicationHiddenSettingAsUser(String packageName, boolean hidden, int userId) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_USERS, null);
    PackageSetting pkgSetting;
    final int uid = Binder.getCallingUid();
    enforceCrossUserPermission(uid, userId, true, true, "setApplicationHiddenSetting for user " + userId);
    if (hidden && isPackageDeviceAdmin(packageName, userId)) {
        Slog.w(TAG, "Not hiding package " + packageName + ": has active device admin");
        return false;
    }
    long callingId = Binder.clearCallingIdentity();
    try {
        boolean sendAdded = false;
        boolean sendRemoved = false;
        // writer
        synchronized (mPackages) {
            pkgSetting = mSettings.mPackages.get(packageName);
            if (pkgSetting == null) {
                return false;
            }
            if (pkgSetting.getHidden(userId) != hidden) {
                pkgSetting.setHidden(hidden, userId);
                mSettings.writePackageRestrictionsLPr(userId);
                if (hidden) {
                    sendRemoved = true;
                } else {
                    sendAdded = true;
                }
            }
        }
        if (sendAdded) {
            sendPackageAddedForUser(packageName, pkgSetting, userId);
            return true;
        }
        if (sendRemoved) {
            killApplication(packageName, UserHandle.getUid(userId, pkgSetting.appId), "hiding pkg");
            sendApplicationHiddenForUser(packageName, pkgSetting, userId);
            return true;
        }
    } finally {
        Binder.restoreCallingIdentity(callingId);
    }
    return false;
}
#method_after
@Override
public boolean setApplicationHiddenSettingAsUser(String packageName, boolean hidden, int userId) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_USERS, null);
    PackageSetting pkgSetting;
    final int uid = Binder.getCallingUid();
    enforceCrossUserPermission(uid, userId, true, /* requireFullPermission */
    true, /* checkShell */
    "setApplicationHiddenSetting for user " + userId);
    if (hidden && isPackageDeviceAdmin(packageName, userId)) {
        Slog.w(TAG, "Not hiding package " + packageName + ": has active device admin");
        return false;
    }
    long callingId = Binder.clearCallingIdentity();
    try {
        boolean sendAdded = false;
        boolean sendRemoved = false;
        // writer
        synchronized (mPackages) {
            pkgSetting = mSettings.mPackages.get(packageName);
            if (pkgSetting == null) {
                return false;
            }
            if (pkgSetting.getHidden(userId) != hidden) {
                pkgSetting.setHidden(hidden, userId);
                mSettings.writePackageRestrictionsLPr(userId);
                if (hidden) {
                    sendRemoved = true;
                } else {
                    sendAdded = true;
                }
            }
        }
        if (sendAdded) {
            sendPackageAddedForUser(packageName, pkgSetting, userId);
            return true;
        }
        if (sendRemoved) {
            killApplication(packageName, UserHandle.getUid(userId, pkgSetting.appId), "hiding pkg");
            sendApplicationHiddenForUser(packageName, pkgSetting, userId);
            return true;
        }
    } finally {
        Binder.restoreCallingIdentity(callingId);
    }
    return false;
}
#end_block

#method_before
private void sendApplicationHiddenForUser(String packageName, PackageSetting pkgSetting, int userId) {
    final PackageRemovedInfo info = new PackageRemovedInfo();
    info.removedPackage = packageName;
    info.removedUsers = new int[] { userId };
    info.uid = UserHandle.getUid(userId, pkgSetting.appId);
    info.sendBroadcast(false, false, false);
}
#method_after
private void sendApplicationHiddenForUser(String packageName, PackageSetting pkgSetting, int userId) {
    final PackageRemovedInfo info = new PackageRemovedInfo();
    info.removedPackage = packageName;
    info.removedUsers = new int[] { userId };
    info.uid = UserHandle.getUid(userId, pkgSetting.appId);
    info.sendPackageRemovedBroadcasts(true);
}
#end_block

#method_before
@Override
public boolean getApplicationHiddenSettingAsUser(String packageName, int userId) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_USERS, null);
    enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "getApplicationHidden for user " + userId);
    PackageSetting pkgSetting;
    long callingId = Binder.clearCallingIdentity();
    try {
        // writer
        synchronized (mPackages) {
            pkgSetting = mSettings.mPackages.get(packageName);
            if (pkgSetting == null) {
                return true;
            }
            return pkgSetting.getHidden(userId);
        }
    } finally {
        Binder.restoreCallingIdentity(callingId);
    }
}
#method_after
@Override
public boolean getApplicationHiddenSettingAsUser(String packageName, int userId) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_USERS, null);
    enforceCrossUserPermission(Binder.getCallingUid(), userId, true, /* requireFullPermission */
    false, /* checkShell */
    "getApplicationHidden for user " + userId);
    PackageSetting pkgSetting;
    long callingId = Binder.clearCallingIdentity();
    try {
        // writer
        synchronized (mPackages) {
            pkgSetting = mSettings.mPackages.get(packageName);
            if (pkgSetting == null) {
                return true;
            }
            return pkgSetting.getHidden(userId);
        }
    } finally {
        Binder.restoreCallingIdentity(callingId);
    }
}
#end_block

#method_before
@Override
public int installExistingPackageAsUser(String packageName, int userId) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.INSTALL_PACKAGES, null);
    PackageSetting pkgSetting;
    final int uid = Binder.getCallingUid();
    enforceCrossUserPermission(uid, userId, true, true, "installExistingPackage for user " + userId);
    if (isUserRestricted(userId, UserManager.DISALLOW_INSTALL_APPS)) {
        return PackageManager.INSTALL_FAILED_USER_RESTRICTED;
    }
    long callingId = Binder.clearCallingIdentity();
    try {
        boolean sendAdded = false;
        // writer
        synchronized (mPackages) {
            pkgSetting = mSettings.mPackages.get(packageName);
            if (pkgSetting == null) {
                return PackageManager.INSTALL_FAILED_INVALID_URI;
            }
            if (!pkgSetting.getInstalled(userId)) {
                pkgSetting.setInstalled(true, userId);
                pkgSetting.setHidden(false, userId);
                mSettings.writePackageRestrictionsLPr(userId);
                sendAdded = true;
            }
        }
        if (sendAdded) {
            sendPackageAddedForUser(packageName, pkgSetting, userId);
        }
    } finally {
        Binder.restoreCallingIdentity(callingId);
    }
    return PackageManager.INSTALL_SUCCEEDED;
}
#method_after
@Override
public int installExistingPackageAsUser(String packageName, int userId) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.INSTALL_PACKAGES, null);
    PackageSetting pkgSetting;
    final int uid = Binder.getCallingUid();
    enforceCrossUserPermission(uid, userId, true, /* requireFullPermission */
    true, /* checkShell */
    "installExistingPackage for user " + userId);
    if (isUserRestricted(userId, UserManager.DISALLOW_INSTALL_APPS)) {
        return PackageManager.INSTALL_FAILED_USER_RESTRICTED;
    }
    long callingId = Binder.clearCallingIdentity();
    try {
        boolean installed = false;
        // writer
        synchronized (mPackages) {
            pkgSetting = mSettings.mPackages.get(packageName);
            if (pkgSetting == null) {
                return PackageManager.INSTALL_FAILED_INVALID_URI;
            }
            if (!pkgSetting.getInstalled(userId)) {
                pkgSetting.setInstalled(true, userId);
                pkgSetting.setHidden(false, userId);
                mSettings.writePackageRestrictionsLPr(userId);
                installed = true;
            }
        }
        if (installed) {
            if (pkgSetting.pkg != null) {
                synchronized (mInstallLock) {
                    // We don't need to freeze for a brand new install
                    prepareAppDataAfterInstallLIF(pkgSetting.pkg);
                }
            }
            sendPackageAddedForUser(packageName, pkgSetting, userId);
        }
    } finally {
        Binder.restoreCallingIdentity(callingId);
    }
    return PackageManager.INSTALL_SUCCEEDED;
}
#end_block

#method_before
@Override
public void finishPackageInstall(int token) {
    enforceSystemOrRoot("Only the system is allowed to finish installs");
    if (DEBUG_INSTALL) {
        Slog.v(TAG, "BM finishing package install for " + token);
    }
    final Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0);
    mHandler.sendMessage(msg);
}
#method_after
@Override
public void finishPackageInstall(int token, boolean didLaunch) {
    enforceSystemOrRoot("Only the system is allowed to finish installs");
    if (DEBUG_INSTALL) {
        Slog.v(TAG, "BM finishing package install for " + token);
    }
    Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, "restore", token);
    final Message msg = mHandler.obtainMessage(POST_INSTALL, token, didLaunch ? 1 : 0);
    mHandler.sendMessage(msg);
}
#end_block

#method_before
private boolean isVerificationEnabled(int userId, int installFlags) {
    if (!DEFAULT_VERIFY_ENABLE) {
        return false;
    }
    boolean ensureVerifyAppsEnabled = isUserRestricted(userId, UserManager.ENSURE_VERIFY_APPS);
    // Check if installing from ADB
    if ((installFlags & PackageManager.INSTALL_FROM_ADB) != 0) {
        // Do not run verification in a test harness environment
        if (ActivityManager.isRunningInTestHarness()) {
            return false;
        }
        if (ensureVerifyAppsEnabled) {
            return true;
        }
        // Check if the developer does not want package verification for ADB installs
        if (android.provider.Settings.Global.getInt(mContext.getContentResolver(), android.provider.Settings.Global.PACKAGE_VERIFIER_INCLUDE_ADB, 1) == 0) {
            return false;
        }
    }
    if (ensureVerifyAppsEnabled) {
        return true;
    }
    return android.provider.Settings.Global.getInt(mContext.getContentResolver(), android.provider.Settings.Global.PACKAGE_VERIFIER_ENABLE, 1) == 1;
}
#method_after
private boolean isVerificationEnabled(int userId, int installFlags) {
    if (!DEFAULT_VERIFY_ENABLE) {
        return false;
    }
    // Ephemeral apps don't get the full verification treatment
    if ((installFlags & PackageManager.INSTALL_EPHEMERAL) != 0) {
        if (DEBUG_EPHEMERAL) {
            Slog.d(TAG, "INSTALL_EPHEMERAL so skipping verification");
        }
        return false;
    }
    boolean ensureVerifyAppsEnabled = isUserRestricted(userId, UserManager.ENSURE_VERIFY_APPS);
    // Check if installing from ADB
    if ((installFlags & PackageManager.INSTALL_FROM_ADB) != 0) {
        // Do not run verification in a test harness environment
        if (ActivityManager.isRunningInTestHarness()) {
            return false;
        }
        if (ensureVerifyAppsEnabled) {
            return true;
        }
        // Check if the developer does not want package verification for ADB installs
        if (android.provider.Settings.Global.getInt(mContext.getContentResolver(), android.provider.Settings.Global.PACKAGE_VERIFIER_INCLUDE_ADB, 1) == 0) {
            return false;
        }
    }
    if (ensureVerifyAppsEnabled) {
        return true;
    }
    return android.provider.Settings.Global.getInt(mContext.getContentResolver(), android.provider.Settings.Global.PACKAGE_VERIFIER_ENABLE, 1) == 1;
}
#end_block

#method_before
@Override
public List<IntentFilterVerificationInfo> getIntentFilterVerifications(String packageName) {
    synchronized (mPackages) {
        return mSettings.getIntentFilterVerificationsLPr(packageName);
    }
}
#method_after
@Override
@NonNull
public ParceledListSlice<IntentFilterVerificationInfo> getIntentFilterVerifications(String packageName) {
    synchronized (mPackages) {
        return new ParceledListSlice<>(mSettings.getIntentFilterVerificationsLPr(packageName));
    }
}
#end_block

#method_before
@Override
public List<IntentFilter> getAllIntentFilters(String packageName) {
    if (TextUtils.isEmpty(packageName)) {
        return Collections.<IntentFilter>emptyList();
    }
    synchronized (mPackages) {
        PackageParser.Package pkg = mPackages.get(packageName);
        if (pkg == null || pkg.activities == null) {
            return Collections.<IntentFilter>emptyList();
        }
        final int count = pkg.activities.size();
        ArrayList<IntentFilter> result = new ArrayList<>();
        for (int n = 0; n < count; n++) {
            PackageParser.Activity activity = pkg.activities.get(n);
            if (activity.intents != null || activity.intents.size() > 0) {
                result.addAll(activity.intents);
            }
        }
        return result;
    }
}
#method_after
@Override
@NonNull
public ParceledListSlice<IntentFilter> getAllIntentFilters(String packageName) {
    if (TextUtils.isEmpty(packageName)) {
        return ParceledListSlice.emptyList();
    }
    synchronized (mPackages) {
        PackageParser.Package pkg = mPackages.get(packageName);
        if (pkg == null || pkg.activities == null) {
            return ParceledListSlice.emptyList();
        }
        final int count = pkg.activities.size();
        ArrayList<IntentFilter> result = new ArrayList<>();
        for (int n = 0; n < count; n++) {
            PackageParser.Activity activity = pkg.activities.get(n);
            if (activity.intents != null && activity.intents.size() > 0) {
                result.addAll(activity.intents);
            }
        }
        return new ParceledListSlice<>(result);
    }
}
#end_block

#method_before
private int getUnknownSourcesSettings() {
    return android.provider.Settings.Global.getInt(mContext.getContentResolver(), android.provider.Settings.Global.INSTALL_NON_MARKET_APPS, -1);
}
#method_after
private int getUnknownSourcesSettings() {
    return android.provider.Settings.Secure.getInt(mContext.getContentResolver(), android.provider.Settings.Secure.INSTALL_NON_MARKET_APPS, -1);
}
#end_block

#method_before
@Override
public void setInstallerPackageName(String targetPackage, String installerPackageName) {
    final int uid = Binder.getCallingUid();
    // writer
    synchronized (mPackages) {
        PackageSetting targetPackageSetting = mSettings.mPackages.get(targetPackage);
        if (targetPackageSetting == null) {
            throw new IllegalArgumentException("Unknown target package: " + targetPackage);
        }
        PackageSetting installerPackageSetting;
        if (installerPackageName != null) {
            installerPackageSetting = mSettings.mPackages.get(installerPackageName);
            if (installerPackageSetting == null) {
                throw new IllegalArgumentException("Unknown installer package: " + installerPackageName);
            }
        } else {
            installerPackageSetting = null;
        }
        Signature[] callerSignature;
        Object obj = mSettings.getUserIdLPr(uid);
        if (obj != null) {
            if (obj instanceof SharedUserSetting) {
                callerSignature = ((SharedUserSetting) obj).signatures.mSignatures;
            } else if (obj instanceof PackageSetting) {
                callerSignature = ((PackageSetting) obj).signatures.mSignatures;
            } else {
                throw new SecurityException("Bad object " + obj + " for uid " + uid);
            }
        } else {
            throw new SecurityException("Unknown calling uid " + uid);
        }
        // not signed with the same cert as the caller.
        if (installerPackageSetting != null) {
            if (compareSignatures(callerSignature, installerPackageSetting.signatures.mSignatures) != PackageManager.SIGNATURE_MATCH) {
                throw new SecurityException("Caller does not have same cert as new installer package " + installerPackageName);
            }
        }
        // be signed with the same cert as the caller.
        if (targetPackageSetting.installerPackageName != null) {
            PackageSetting setting = mSettings.mPackages.get(targetPackageSetting.installerPackageName);
            // okay to change it.
            if (setting != null) {
                if (compareSignatures(callerSignature, setting.signatures.mSignatures) != PackageManager.SIGNATURE_MATCH) {
                    throw new SecurityException("Caller does not have same cert as old installer package " + targetPackageSetting.installerPackageName);
                }
            }
        }
        // Okay!
        targetPackageSetting.installerPackageName = installerPackageName;
        scheduleWriteSettingsLocked();
    }
}
#method_after
@Override
public void setInstallerPackageName(String targetPackage, String installerPackageName) {
    final int uid = Binder.getCallingUid();
    // writer
    synchronized (mPackages) {
        PackageSetting targetPackageSetting = mSettings.mPackages.get(targetPackage);
        if (targetPackageSetting == null) {
            throw new IllegalArgumentException("Unknown target package: " + targetPackage);
        }
        PackageSetting installerPackageSetting;
        if (installerPackageName != null) {
            installerPackageSetting = mSettings.mPackages.get(installerPackageName);
            if (installerPackageSetting == null) {
                throw new IllegalArgumentException("Unknown installer package: " + installerPackageName);
            }
        } else {
            installerPackageSetting = null;
        }
        Signature[] callerSignature;
        Object obj = mSettings.getUserIdLPr(uid);
        if (obj != null) {
            if (obj instanceof SharedUserSetting) {
                callerSignature = ((SharedUserSetting) obj).signatures.mSignatures;
            } else if (obj instanceof PackageSetting) {
                callerSignature = ((PackageSetting) obj).signatures.mSignatures;
            } else {
                throw new SecurityException("Bad object " + obj + " for uid " + uid);
            }
        } else {
            throw new SecurityException("Unknown calling UID: " + uid);
        }
        // not signed with the same cert as the caller.
        if (installerPackageSetting != null) {
            if (compareSignatures(callerSignature, installerPackageSetting.signatures.mSignatures) != PackageManager.SIGNATURE_MATCH) {
                throw new SecurityException("Caller does not have same cert as new installer package " + installerPackageName);
            }
        }
        // be signed with the same cert as the caller.
        if (targetPackageSetting.installerPackageName != null) {
            PackageSetting setting = mSettings.mPackages.get(targetPackageSetting.installerPackageName);
            // okay to change it.
            if (setting != null) {
                if (compareSignatures(callerSignature, setting.signatures.mSignatures) != PackageManager.SIGNATURE_MATCH) {
                    throw new SecurityException("Caller does not have same cert as old installer package " + targetPackageSetting.installerPackageName);
                }
            }
        }
        // Okay!
        targetPackageSetting.installerPackageName = installerPackageName;
        if (installerPackageName != null) {
            mSettings.mInstallerPackages.add(installerPackageName);
        }
        scheduleWriteSettingsLocked();
    }
}
#end_block

#method_before
private void processPendingInstall(final InstallArgs args, final int currentStatus) {
    // Queue up an async operation since the package installation may take a little while.
    mHandler.post(new Runnable() {

        public void run() {
            mHandler.removeCallbacks(this);
            // Result object to be returned
            PackageInstalledInfo res = new PackageInstalledInfo();
            res.returnCode = currentStatus;
            res.uid = -1;
            res.pkg = null;
            res.removedInfo = new PackageRemovedInfo();
            if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
                args.doPreInstall(res.returnCode);
                synchronized (mInstallLock) {
                    installPackageLI(args, res);
                }
                args.doPostInstall(res.returnCode, res.uid);
            }
            // A restore should be performed at this point if (a) the install
            // succeeded, (b) the operation is not an update, and (c) the new
            // package has not opted out of backup participation.
            final boolean update = res.removedInfo.removedPackage != null;
            final int flags = (res.pkg == null) ? 0 : res.pkg.applicationInfo.flags;
            boolean doRestore = !update && ((flags & ApplicationInfo.FLAG_ALLOW_BACKUP) != 0);
            // Set up the post-install work request bookkeeping.  This will be used
            // and cleaned up by the post-install event handling regardless of whether
            // there's a restore pass performed.  Token values are >= 1.
            int token;
            if (mNextInstallToken < 0)
                mNextInstallToken = 1;
            token = mNextInstallToken++;
            PostInstallData data = new PostInstallData(args, res);
            mRunningInstalls.put(token, data);
            if (DEBUG_INSTALL)
                Log.v(TAG, "+ starting restore round-trip " + token);
            if (res.returnCode == PackageManager.INSTALL_SUCCEEDED && doRestore) {
                // Pass responsibility to the Backup Manager.  It will perform a
                // restore if appropriate, then pass responsibility back to the
                // Package Manager to run the post-install observer callbacks
                // and broadcasts.
                IBackupManager bm = IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
                if (bm != null) {
                    if (DEBUG_INSTALL)
                        Log.v(TAG, "token " + token + " to BM for possible restore");
                    try {
                        if (bm.isBackupServiceActive(UserHandle.USER_OWNER)) {
                            bm.restoreAtInstall(res.pkg.applicationInfo.packageName, token);
                        } else {
                            doRestore = false;
                        }
                    } catch (RemoteException e) {
                    // can't happen; the backup manager is local
                    } catch (Exception e) {
                        Slog.e(TAG, "Exception trying to enqueue restore", e);
                        doRestore = false;
                    }
                } else {
                    Slog.e(TAG, "Backup Manager not found!");
                    doRestore = false;
                }
            }
            if (!doRestore) {
                // available -- just fire the post-install work request directly.
                if (DEBUG_INSTALL)
                    Log.v(TAG, "No restore - queue post-install for " + token);
                Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0);
                mHandler.sendMessage(msg);
            }
        }
    });
}
#method_after
private void processPendingInstall(final InstallArgs args, final int currentStatus) {
    // Queue up an async operation since the package installation may take a little while.
    mHandler.post(new Runnable() {

        public void run() {
            mHandler.removeCallbacks(this);
            // Result object to be returned
            PackageInstalledInfo res = new PackageInstalledInfo();
            res.setReturnCode(currentStatus);
            res.uid = -1;
            res.pkg = null;
            res.removedInfo = null;
            if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
                args.doPreInstall(res.returnCode);
                synchronized (mInstallLock) {
                    installPackageTracedLI(args, res);
                }
                args.doPostInstall(res.returnCode, res.uid);
            }
            // A restore should be performed at this point if (a) the install
            // succeeded, (b) the operation is not an update, and (c) the new
            // package has not opted out of backup participation.
            final boolean update = res.removedInfo != null && res.removedInfo.removedPackage != null;
            final int flags = (res.pkg == null) ? 0 : res.pkg.applicationInfo.flags;
            boolean doRestore = !update && ((flags & ApplicationInfo.FLAG_ALLOW_BACKUP) != 0);
            // Set up the post-install work request bookkeeping.  This will be used
            // and cleaned up by the post-install event handling regardless of whether
            // there's a restore pass performed.  Token values are >= 1.
            int token;
            if (mNextInstallToken < 0)
                mNextInstallToken = 1;
            token = mNextInstallToken++;
            PostInstallData data = new PostInstallData(args, res);
            mRunningInstalls.put(token, data);
            if (DEBUG_INSTALL)
                Log.v(TAG, "+ starting restore round-trip " + token);
            if (res.returnCode == PackageManager.INSTALL_SUCCEEDED && doRestore) {
                // Pass responsibility to the Backup Manager.  It will perform a
                // restore if appropriate, then pass responsibility back to the
                // Package Manager to run the post-install observer callbacks
                // and broadcasts.
                IBackupManager bm = IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
                if (bm != null) {
                    if (DEBUG_INSTALL)
                        Log.v(TAG, "token " + token + " to BM for possible restore");
                    Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, "restore", token);
                    try {
                        // TODO: http://b/22388012
                        if (bm.isBackupServiceActive(UserHandle.USER_SYSTEM)) {
                            bm.restoreAtInstall(res.pkg.applicationInfo.packageName, token);
                        } else {
                            doRestore = false;
                        }
                    } catch (RemoteException e) {
                    // can't happen; the backup manager is local
                    } catch (Exception e) {
                        Slog.e(TAG, "Exception trying to enqueue restore", e);
                        doRestore = false;
                    }
                } else {
                    Slog.e(TAG, "Backup Manager not found!");
                    doRestore = false;
                }
            }
            if (!doRestore) {
                // available -- just fire the post-install work request directly.
                if (DEBUG_INSTALL)
                    Log.v(TAG, "No restore - queue post-install for " + token);
                Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, "postInstall", token);
                Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0);
                mHandler.sendMessage(msg);
            }
        }
    });
}
#end_block

#method_before
@Override
void handleStartCopy() throws RemoteException {
    synchronized (mInstallLock) {
        mSuccess = getPackageSizeInfoLI(mStats.packageName, mStats.userHandle, mStats);
    }
    if (mSuccess) {
        final boolean mounted;
        if (Environment.isExternalStorageEmulated()) {
            mounted = true;
        } else {
            final String status = Environment.getExternalStorageState();
            mounted = (Environment.MEDIA_MOUNTED.equals(status) || Environment.MEDIA_MOUNTED_READ_ONLY.equals(status));
        }
        if (mounted) {
            final UserEnvironment userEnv = new UserEnvironment(mStats.userHandle);
            mStats.externalCacheSize = calculateDirectorySize(mContainerService, userEnv.buildExternalStorageAppCacheDirs(mStats.packageName));
            mStats.externalDataSize = calculateDirectorySize(mContainerService, userEnv.buildExternalStorageAppDataDirs(mStats.packageName));
            // Always subtract cache size, since it's a subdirectory
            mStats.externalDataSize -= mStats.externalCacheSize;
            mStats.externalMediaSize = calculateDirectorySize(mContainerService, userEnv.buildExternalStorageAppMediaDirs(mStats.packageName));
            mStats.externalObbSize = calculateDirectorySize(mContainerService, userEnv.buildExternalStorageAppObbDirs(mStats.packageName));
        }
    }
}
#method_after
@Override
void handleStartCopy() throws RemoteException {
    synchronized (mInstallLock) {
        mSuccess = getPackageSizeInfoLI(mStats.packageName, mStats.userHandle, mStats);
    }
    if (mSuccess) {
        boolean mounted = false;
        try {
            final String status = Environment.getExternalStorageState();
            mounted = (Environment.MEDIA_MOUNTED.equals(status) || Environment.MEDIA_MOUNTED_READ_ONLY.equals(status));
        } catch (Exception e) {
        }
        if (mounted) {
            final UserEnvironment userEnv = new UserEnvironment(mStats.userHandle);
            mStats.externalCacheSize = calculateDirectorySize(mContainerService, userEnv.buildExternalStorageAppCacheDirs(mStats.packageName));
            mStats.externalDataSize = calculateDirectorySize(mContainerService, userEnv.buildExternalStorageAppDataDirs(mStats.packageName));
            // Always subtract cache size, since it's a subdirectory
            mStats.externalDataSize -= mStats.externalCacheSize;
            mStats.externalMediaSize = calculateDirectorySize(mContainerService, userEnv.buildExternalStorageAppMediaDirs(mStats.packageName));
            mStats.externalObbSize = calculateDirectorySize(mContainerService, userEnv.buildExternalStorageAppObbDirs(mStats.packageName));
        }
    }
}
#end_block

#method_before
private int installLocationPolicy(PackageInfoLite pkgLite) {
    String packageName = pkgLite.packageName;
    int installLocation = pkgLite.installLocation;
    boolean onSd = (installFlags & PackageManager.INSTALL_EXTERNAL) != 0;
    // reader
    synchronized (mPackages) {
        PackageParser.Package pkg = mPackages.get(packageName);
        if (pkg != null) {
            if ((installFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
                // Check for downgrading.
                if ((installFlags & PackageManager.INSTALL_ALLOW_DOWNGRADE) == 0) {
                    try {
                        checkDowngrade(pkg, pkgLite);
                    } catch (PackageManagerException e) {
                        Slog.w(TAG, "Downgrade detected: " + e.getMessage());
                        return PackageHelper.RECOMMEND_FAILED_VERSION_DOWNGRADE;
                    }
                }
                // Check for updated system application.
                if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
                    if (onSd) {
                        Slog.w(TAG, "Cannot install update to system app on sdcard");
                        return PackageHelper.RECOMMEND_FAILED_INVALID_LOCATION;
                    }
                    return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
                } else {
                    if (onSd) {
                        // Install flag overrides everything.
                        return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
                    }
                    // If current upgrade specifies particular preference
                    if (installLocation == PackageInfo.INSTALL_LOCATION_INTERNAL_ONLY) {
                        // Application explicitly specified internal.
                        return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
                    } else if (installLocation == PackageInfo.INSTALL_LOCATION_PREFER_EXTERNAL) {
                    // App explictly prefers external. Let policy decide
                    } else {
                        // Prefer previous location
                        if (isExternal(pkg)) {
                            return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
                        }
                        return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
                    }
                }
            } else {
                // Invalid install. Return error code
                return PackageHelper.RECOMMEND_FAILED_ALREADY_EXISTS;
            }
        }
    }
    // Return result based on recommended install location.
    if (onSd) {
        return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
    return pkgLite.recommendedInstallLocation;
}
#method_after
private int installLocationPolicy(PackageInfoLite pkgLite) {
    String packageName = pkgLite.packageName;
    int installLocation = pkgLite.installLocation;
    boolean onSd = (installFlags & PackageManager.INSTALL_EXTERNAL) != 0;
    // reader
    synchronized (mPackages) {
        // Currently installed package which the new package is attempting to replace or
        // null if no such package is installed.
        PackageParser.Package installedPkg = mPackages.get(packageName);
        // Package which currently owns the data which the new package will own if installed.
        // If an app is unstalled while keeping data (e.g., adb uninstall -k), installedPkg
        // will be null whereas dataOwnerPkg will contain information about the package
        // which was uninstalled while keeping its data.
        PackageParser.Package dataOwnerPkg = installedPkg;
        if (dataOwnerPkg == null) {
            PackageSetting ps = mSettings.mPackages.get(packageName);
            if (ps != null) {
                dataOwnerPkg = ps.pkg;
            }
        }
        if (dataOwnerPkg != null) {
            // If installed, the package will get access to data left on the device by its
            // predecessor. As a security measure, this is permited only if this is not a
            // version downgrade or if the predecessor package is marked as debuggable and
            // a downgrade is explicitly requested.
            // 
            // On debuggable platform builds, downgrades are permitted even for
            // non-debuggable packages to make testing easier. Debuggable platform builds do
            // not offer security guarantees and thus it's OK to disable some security
            // mechanisms to make debugging/testing easier on those builds. However, even on
            // debuggable builds downgrades of packages are permitted only if requested via
            // installFlags. This is because we aim to keep the behavior of debuggable
            // platform builds as close as possible to the behavior of non-debuggable
            // platform builds.
            final boolean downgradeRequested = (installFlags & PackageManager.INSTALL_ALLOW_DOWNGRADE) != 0;
            final boolean packageDebuggable = (dataOwnerPkg.applicationInfo.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
            final boolean downgradePermitted = (downgradeRequested) && ((Build.IS_DEBUGGABLE) || (packageDebuggable));
            if (!downgradePermitted) {
                try {
                    checkDowngrade(dataOwnerPkg, pkgLite);
                } catch (PackageManagerException e) {
                    Slog.w(TAG, "Downgrade detected: " + e.getMessage());
                    return PackageHelper.RECOMMEND_FAILED_VERSION_DOWNGRADE;
                }
            }
        }
        if (installedPkg != null) {
            if ((installFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
                // Check for updated system application.
                if ((installedPkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
                    if (onSd) {
                        Slog.w(TAG, "Cannot install update to system app on sdcard");
                        return PackageHelper.RECOMMEND_FAILED_INVALID_LOCATION;
                    }
                    return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
                } else {
                    if (onSd) {
                        // Install flag overrides everything.
                        return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
                    }
                    // If current upgrade specifies particular preference
                    if (installLocation == PackageInfo.INSTALL_LOCATION_INTERNAL_ONLY) {
                        // Application explicitly specified internal.
                        return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
                    } else if (installLocation == PackageInfo.INSTALL_LOCATION_PREFER_EXTERNAL) {
                    // App explictly prefers external. Let policy decide
                    } else {
                        // Prefer previous location
                        if (isExternal(installedPkg)) {
                            return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
                        }
                        return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
                    }
                }
            } else {
                // Invalid install. Return error code
                return PackageHelper.RECOMMEND_FAILED_ALREADY_EXISTS;
            }
        }
    }
    // Return result based on recommended install location.
    if (onSd) {
        return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
    }
    return pkgLite.recommendedInstallLocation;
}
#end_block

#method_before
public void handleStartCopy() throws RemoteException {
    int ret = PackageManager.INSTALL_SUCCEEDED;
    // If we're already staged, we've firmly committed to an install location
    if (origin.staged) {
        if (origin.file != null) {
            installFlags |= PackageManager.INSTALL_INTERNAL;
            installFlags &= ~PackageManager.INSTALL_EXTERNAL;
        } else if (origin.cid != null) {
            installFlags |= PackageManager.INSTALL_EXTERNAL;
            installFlags &= ~PackageManager.INSTALL_INTERNAL;
        } else {
            throw new IllegalStateException("Invalid stage location");
        }
    }
    final boolean onSd = (installFlags & PackageManager.INSTALL_EXTERNAL) != 0;
    final boolean onInt = (installFlags & PackageManager.INSTALL_INTERNAL) != 0;
    PackageInfoLite pkgLite = null;
    if (onInt && onSd) {
        // Check if both bits are set.
        Slog.w(TAG, "Conflicting flags specified for installing on both internal and external");
        ret = PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION;
    } else {
        pkgLite = mContainerService.getMinimalPackageInfo(origin.resolvedPath, installFlags, packageAbiOverride);
        /*
                 * If we have too little free space, try to free cache
                 * before giving up.
                 */
        if (!origin.staged && pkgLite.recommendedInstallLocation == PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE) {
            // TODO: focus freeing disk space on the target device
            final StorageManager storage = StorageManager.from(mContext);
            final long lowThreshold = storage.getStorageLowBytes(Environment.getDataDirectory());
            final long sizeBytes = mContainerService.calculateInstalledSize(origin.resolvedPath, isForwardLocked(), packageAbiOverride);
            if (mInstaller.freeCache(null, sizeBytes + lowThreshold) >= 0) {
                pkgLite = mContainerService.getMinimalPackageInfo(origin.resolvedPath, installFlags, packageAbiOverride);
            }
            /*
                     * The cache free must have deleted the file we
                     * downloaded to install.
                     *
                     * TODO: fix the "freeCache" call to not delete
                     *       the file we care about.
                     */
            if (pkgLite.recommendedInstallLocation == PackageHelper.RECOMMEND_FAILED_INVALID_URI) {
                pkgLite.recommendedInstallLocation = PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE;
            }
        }
    }
    if (ret == PackageManager.INSTALL_SUCCEEDED) {
        int loc = pkgLite.recommendedInstallLocation;
        if (loc == PackageHelper.RECOMMEND_FAILED_INVALID_LOCATION) {
            ret = PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION;
        } else if (loc == PackageHelper.RECOMMEND_FAILED_ALREADY_EXISTS) {
            ret = PackageManager.INSTALL_FAILED_ALREADY_EXISTS;
        } else if (loc == PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE) {
            ret = PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
        } else if (loc == PackageHelper.RECOMMEND_FAILED_INVALID_APK) {
            ret = PackageManager.INSTALL_FAILED_INVALID_APK;
        } else if (loc == PackageHelper.RECOMMEND_FAILED_INVALID_URI) {
            ret = PackageManager.INSTALL_FAILED_INVALID_URI;
        } else if (loc == PackageHelper.RECOMMEND_MEDIA_UNAVAILABLE) {
            ret = PackageManager.INSTALL_FAILED_MEDIA_UNAVAILABLE;
        } else {
            // Override with defaults if needed.
            loc = installLocationPolicy(pkgLite);
            if (loc == PackageHelper.RECOMMEND_FAILED_VERSION_DOWNGRADE) {
                ret = PackageManager.INSTALL_FAILED_VERSION_DOWNGRADE;
            } else if (!onSd && !onInt) {
                // Override install location with flags
                if (loc == PackageHelper.RECOMMEND_INSTALL_EXTERNAL) {
                    // Set the flag to install on external media.
                    installFlags |= PackageManager.INSTALL_EXTERNAL;
                    installFlags &= ~PackageManager.INSTALL_INTERNAL;
                } else {
                    // Make sure the flag for installing on external
                    // media is unset
                    installFlags |= PackageManager.INSTALL_INTERNAL;
                    installFlags &= ~PackageManager.INSTALL_EXTERNAL;
                }
            }
        }
    }
    final InstallArgs args = createInstallArgs(this);
    mArgs = args;
    if (ret == PackageManager.INSTALL_SUCCEEDED) {
        /*
                 * ADB installs appear as UserHandle.USER_ALL, and can only be performed by
                 * UserHandle.USER_OWNER, so use the package verifier for UserHandle.USER_OWNER.
                 */
        int userIdentifier = getUser().getIdentifier();
        if (userIdentifier == UserHandle.USER_ALL && ((installFlags & PackageManager.INSTALL_FROM_ADB) != 0)) {
            userIdentifier = UserHandle.USER_OWNER;
        }
        /*
                 * Determine if we have any installed package verifiers. If we
                 * do, then we'll defer to them to verify the packages.
                 */
        final int requiredUid = mRequiredVerifierPackage == null ? -1 : getPackageUid(mRequiredVerifierPackage, userIdentifier);
        if (!origin.existing && requiredUid != -1 && isVerificationEnabled(userIdentifier, installFlags)) {
            final Intent verification = new Intent(Intent.ACTION_PACKAGE_NEEDS_VERIFICATION);
            verification.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
            verification.setDataAndType(Uri.fromFile(new File(origin.resolvedPath)), PACKAGE_MIME_TYPE);
            verification.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
            final List<ResolveInfo> receivers = queryIntentReceivers(verification, PACKAGE_MIME_TYPE, PackageManager.GET_DISABLED_COMPONENTS, 0);
            if (DEBUG_VERIFY) {
                Slog.d(TAG, "Found " + receivers.size() + " verifiers for intent " + verification.toString() + " with " + pkgLite.verifiers.length + " optional verifiers");
            }
            final int verificationId = mPendingVerificationToken++;
            verification.putExtra(PackageManager.EXTRA_VERIFICATION_ID, verificationId);
            verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_PACKAGE, installerPackageName);
            verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALL_FLAGS, installFlags);
            verification.putExtra(PackageManager.EXTRA_VERIFICATION_PACKAGE_NAME, pkgLite.packageName);
            verification.putExtra(PackageManager.EXTRA_VERIFICATION_VERSION_CODE, pkgLite.versionCode);
            if (verificationParams != null) {
                if (verificationParams.getVerificationURI() != null) {
                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_URI, verificationParams.getVerificationURI());
                }
                if (verificationParams.getOriginatingURI() != null) {
                    verification.putExtra(Intent.EXTRA_ORIGINATING_URI, verificationParams.getOriginatingURI());
                }
                if (verificationParams.getReferrer() != null) {
                    verification.putExtra(Intent.EXTRA_REFERRER, verificationParams.getReferrer());
                }
                if (verificationParams.getOriginatingUid() >= 0) {
                    verification.putExtra(Intent.EXTRA_ORIGINATING_UID, verificationParams.getOriginatingUid());
                }
                if (verificationParams.getInstallerUid() >= 0) {
                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_UID, verificationParams.getInstallerUid());
                }
            }
            final PackageVerificationState verificationState = new PackageVerificationState(requiredUid, args);
            mPendingVerification.append(verificationId, verificationState);
            final List<ComponentName> sufficientVerifiers = matchVerifiers(pkgLite, receivers, verificationState);
            // Apps installed for "all" users use the device owner to verify the app
            UserHandle verifierUser = getUser();
            if (verifierUser == UserHandle.ALL) {
                verifierUser = UserHandle.OWNER;
            }
            /*
                     * If any sufficient verifiers were listed in the package
                     * manifest, attempt to ask them.
                     */
            if (sufficientVerifiers != null) {
                final int N = sufficientVerifiers.size();
                if (N == 0) {
                    Slog.i(TAG, "Additional verifiers required, but none installed.");
                    ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
                } else {
                    for (int i = 0; i < N; i++) {
                        final ComponentName verifierComponent = sufficientVerifiers.get(i);
                        final Intent sufficientIntent = new Intent(verification);
                        sufficientIntent.setComponent(verifierComponent);
                        mContext.sendBroadcastAsUser(sufficientIntent, verifierUser);
                    }
                }
            }
            final ComponentName requiredVerifierComponent = matchComponentForVerifier(mRequiredVerifierPackage, receivers);
            if (ret == PackageManager.INSTALL_SUCCEEDED && mRequiredVerifierPackage != null) {
                /*
                         * Send the intent to the required verification agent,
                         * but only start the verification timeout after the
                         * target BroadcastReceivers have run.
                         */
                verification.setComponent(requiredVerifierComponent);
                mContext.sendOrderedBroadcastAsUser(verification, verifierUser, android.Manifest.permission.PACKAGE_VERIFICATION_AGENT, new BroadcastReceiver() {

                    @Override
                    public void onReceive(Context context, Intent intent) {
                        final Message msg = mHandler.obtainMessage(CHECK_PENDING_VERIFICATION);
                        msg.arg1 = verificationId;
                        mHandler.sendMessageDelayed(msg, getVerificationTimeout());
                    }
                }, null, 0, null, null);
                /*
                         * We don't want the copy to proceed until verification
                         * succeeds, so null out this field.
                         */
                mArgs = null;
            }
        } else {
            /*
                     * No package verification is enabled, so immediately start
                     * the remote call to initiate copy using temporary file.
                     */
            ret = args.copyApk(mContainerService, true);
        }
    }
    mRet = ret;
}
#method_after
public void handleStartCopy() throws RemoteException {
    int ret = PackageManager.INSTALL_SUCCEEDED;
    // If we're already staged, we've firmly committed to an install location
    if (origin.staged) {
        if (origin.file != null) {
            installFlags |= PackageManager.INSTALL_INTERNAL;
            installFlags &= ~PackageManager.INSTALL_EXTERNAL;
        } else if (origin.cid != null) {
            installFlags |= PackageManager.INSTALL_EXTERNAL;
            installFlags &= ~PackageManager.INSTALL_INTERNAL;
        } else {
            throw new IllegalStateException("Invalid stage location");
        }
    }
    final boolean onSd = (installFlags & PackageManager.INSTALL_EXTERNAL) != 0;
    final boolean onInt = (installFlags & PackageManager.INSTALL_INTERNAL) != 0;
    final boolean ephemeral = (installFlags & PackageManager.INSTALL_EPHEMERAL) != 0;
    PackageInfoLite pkgLite = null;
    if (onInt && onSd) {
        // Check if both bits are set.
        Slog.w(TAG, "Conflicting flags specified for installing on both internal and external");
        ret = PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION;
    } else if (onSd && ephemeral) {
        Slog.w(TAG, "Conflicting flags specified for installing ephemeral on external");
        ret = PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION;
    } else {
        pkgLite = mContainerService.getMinimalPackageInfo(origin.resolvedPath, installFlags, packageAbiOverride);
        if (DEBUG_EPHEMERAL && ephemeral) {
            Slog.v(TAG, "pkgLite for install: " + pkgLite);
        }
        /*
                 * If we have too little free space, try to free cache
                 * before giving up.
                 */
        if (!origin.staged && pkgLite.recommendedInstallLocation == PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE) {
            // TODO: focus freeing disk space on the target device
            final StorageManager storage = StorageManager.from(mContext);
            final long lowThreshold = storage.getStorageLowBytes(Environment.getDataDirectory());
            final long sizeBytes = mContainerService.calculateInstalledSize(origin.resolvedPath, isForwardLocked(), packageAbiOverride);
            try {
                mInstaller.freeCache(null, sizeBytes + lowThreshold);
                pkgLite = mContainerService.getMinimalPackageInfo(origin.resolvedPath, installFlags, packageAbiOverride);
            } catch (InstallerException e) {
                Slog.w(TAG, "Failed to free cache", e);
            }
            /*
                     * The cache free must have deleted the file we
                     * downloaded to install.
                     *
                     * TODO: fix the "freeCache" call to not delete
                     *       the file we care about.
                     */
            if (pkgLite.recommendedInstallLocation == PackageHelper.RECOMMEND_FAILED_INVALID_URI) {
                pkgLite.recommendedInstallLocation = PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE;
            }
        }
    }
    if (ret == PackageManager.INSTALL_SUCCEEDED) {
        int loc = pkgLite.recommendedInstallLocation;
        if (loc == PackageHelper.RECOMMEND_FAILED_INVALID_LOCATION) {
            ret = PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION;
        } else if (loc == PackageHelper.RECOMMEND_FAILED_ALREADY_EXISTS) {
            ret = PackageManager.INSTALL_FAILED_ALREADY_EXISTS;
        } else if (loc == PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE) {
            ret = PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
        } else if (loc == PackageHelper.RECOMMEND_FAILED_INVALID_APK) {
            ret = PackageManager.INSTALL_FAILED_INVALID_APK;
        } else if (loc == PackageHelper.RECOMMEND_FAILED_INVALID_URI) {
            ret = PackageManager.INSTALL_FAILED_INVALID_URI;
        } else if (loc == PackageHelper.RECOMMEND_MEDIA_UNAVAILABLE) {
            ret = PackageManager.INSTALL_FAILED_MEDIA_UNAVAILABLE;
        } else {
            // Override with defaults if needed.
            loc = installLocationPolicy(pkgLite);
            if (loc == PackageHelper.RECOMMEND_FAILED_VERSION_DOWNGRADE) {
                ret = PackageManager.INSTALL_FAILED_VERSION_DOWNGRADE;
            } else if (!onSd && !onInt) {
                // Override install location with flags
                if (loc == PackageHelper.RECOMMEND_INSTALL_EXTERNAL) {
                    // Set the flag to install on external media.
                    installFlags |= PackageManager.INSTALL_EXTERNAL;
                    installFlags &= ~PackageManager.INSTALL_INTERNAL;
                } else if (loc == PackageHelper.RECOMMEND_INSTALL_EPHEMERAL) {
                    if (DEBUG_EPHEMERAL) {
                        Slog.v(TAG, "...setting INSTALL_EPHEMERAL install flag");
                    }
                    installFlags |= PackageManager.INSTALL_EPHEMERAL;
                    installFlags &= ~(PackageManager.INSTALL_EXTERNAL | PackageManager.INSTALL_INTERNAL);
                } else {
                    // Make sure the flag for installing on external
                    // media is unset
                    installFlags |= PackageManager.INSTALL_INTERNAL;
                    installFlags &= ~PackageManager.INSTALL_EXTERNAL;
                }
            }
        }
    }
    final InstallArgs args = createInstallArgs(this);
    mArgs = args;
    if (ret == PackageManager.INSTALL_SUCCEEDED) {
        // TODO: http://b/22976637
        // Apps installed for "all" users use the device owner to verify the app
        UserHandle verifierUser = getUser();
        if (verifierUser == UserHandle.ALL) {
            verifierUser = UserHandle.SYSTEM;
        }
        /*
                 * Determine if we have any installed package verifiers. If we
                 * do, then we'll defer to them to verify the packages.
                 */
        final int requiredUid = mRequiredVerifierPackage == null ? -1 : getPackageUid(mRequiredVerifierPackage, MATCH_DEBUG_TRIAGED_MISSING, verifierUser.getIdentifier());
        if (!origin.existing && requiredUid != -1 && isVerificationEnabled(verifierUser.getIdentifier(), installFlags)) {
            final Intent verification = new Intent(Intent.ACTION_PACKAGE_NEEDS_VERIFICATION);
            verification.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
            verification.setDataAndType(Uri.fromFile(new File(origin.resolvedPath)), PACKAGE_MIME_TYPE);
            verification.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
            // Query all live verifiers based on current user state
            final List<ResolveInfo> receivers = queryIntentReceiversInternal(verification, PACKAGE_MIME_TYPE, 0, verifierUser.getIdentifier());
            if (DEBUG_VERIFY) {
                Slog.d(TAG, "Found " + receivers.size() + " verifiers for intent " + verification.toString() + " with " + pkgLite.verifiers.length + " optional verifiers");
            }
            final int verificationId = mPendingVerificationToken++;
            verification.putExtra(PackageManager.EXTRA_VERIFICATION_ID, verificationId);
            verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_PACKAGE, installerPackageName);
            verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALL_FLAGS, installFlags);
            verification.putExtra(PackageManager.EXTRA_VERIFICATION_PACKAGE_NAME, pkgLite.packageName);
            verification.putExtra(PackageManager.EXTRA_VERIFICATION_VERSION_CODE, pkgLite.versionCode);
            if (verificationInfo != null) {
                if (verificationInfo.originatingUri != null) {
                    verification.putExtra(Intent.EXTRA_ORIGINATING_URI, verificationInfo.originatingUri);
                }
                if (verificationInfo.referrer != null) {
                    verification.putExtra(Intent.EXTRA_REFERRER, verificationInfo.referrer);
                }
                if (verificationInfo.originatingUid >= 0) {
                    verification.putExtra(Intent.EXTRA_ORIGINATING_UID, verificationInfo.originatingUid);
                }
                if (verificationInfo.installerUid >= 0) {
                    verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_UID, verificationInfo.installerUid);
                }
            }
            final PackageVerificationState verificationState = new PackageVerificationState(requiredUid, args);
            mPendingVerification.append(verificationId, verificationState);
            final List<ComponentName> sufficientVerifiers = matchVerifiers(pkgLite, receivers, verificationState);
            /*
                     * If any sufficient verifiers were listed in the package
                     * manifest, attempt to ask them.
                     */
            if (sufficientVerifiers != null) {
                final int N = sufficientVerifiers.size();
                if (N == 0) {
                    Slog.i(TAG, "Additional verifiers required, but none installed.");
                    ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
                } else {
                    for (int i = 0; i < N; i++) {
                        final ComponentName verifierComponent = sufficientVerifiers.get(i);
                        final Intent sufficientIntent = new Intent(verification);
                        sufficientIntent.setComponent(verifierComponent);
                        mContext.sendBroadcastAsUser(sufficientIntent, verifierUser);
                    }
                }
            }
            final ComponentName requiredVerifierComponent = matchComponentForVerifier(mRequiredVerifierPackage, receivers);
            if (ret == PackageManager.INSTALL_SUCCEEDED && mRequiredVerifierPackage != null) {
                Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, "verification", verificationId);
                /*
                         * Send the intent to the required verification agent,
                         * but only start the verification timeout after the
                         * target BroadcastReceivers have run.
                         */
                verification.setComponent(requiredVerifierComponent);
                mContext.sendOrderedBroadcastAsUser(verification, verifierUser, android.Manifest.permission.PACKAGE_VERIFICATION_AGENT, new BroadcastReceiver() {

                    @Override
                    public void onReceive(Context context, Intent intent) {
                        final Message msg = mHandler.obtainMessage(CHECK_PENDING_VERIFICATION);
                        msg.arg1 = verificationId;
                        mHandler.sendMessageDelayed(msg, getVerificationTimeout());
                    }
                }, null, 0, null, null);
                /*
                         * We don't want the copy to proceed until verification
                         * succeeds, so null out this field.
                         */
                mArgs = null;
            }
        } else {
            /*
                     * No package verification is enabled, so immediately start
                     * the remote call to initiate copy using temporary file.
                     */
            ret = args.copyApk(mContainerService, true);
        }
    }
    mRet = ret;
}
#end_block

#method_before
private void removeDexFiles(List<String> allCodePaths, String[] instructionSets) {
    if (!allCodePaths.isEmpty()) {
        if (instructionSets == null) {
            throw new IllegalStateException("instructionSet == null");
        }
        String[] dexCodeInstructionSets = getDexCodeInstructionSets(instructionSets);
        for (String codePath : allCodePaths) {
            for (String dexCodeInstructionSet : dexCodeInstructionSets) {
                int retCode = mInstaller.rmdex(codePath, dexCodeInstructionSet);
                if (retCode < 0) {
                    Slog.w(TAG, "Couldn't remove dex file for package: " + " at location " + codePath + ", retcode=" + retCode);
                // we don't consider this to be a failure of the core package deletion
                }
            }
        }
    }
}
#method_after
private void removeDexFiles(List<String> allCodePaths, String[] instructionSets) {
    if (!allCodePaths.isEmpty()) {
        if (instructionSets == null) {
            throw new IllegalStateException("instructionSet == null");
        }
        String[] dexCodeInstructionSets = getDexCodeInstructionSets(instructionSets);
        for (String codePath : allCodePaths) {
            for (String dexCodeInstructionSet : dexCodeInstructionSets) {
                try {
                    mInstaller.rmdex(codePath, dexCodeInstructionSet);
                } catch (InstallerException ignored) {
                }
            }
        }
    }
}
#end_block

#method_before
int copyApk(IMediaContainerService imcs, boolean temp) throws RemoteException {
    if (origin.staged) {
        if (DEBUG_INSTALL)
            Slog.d(TAG, origin.file + " already staged; skipping copy");
        codeFile = origin.file;
        resourceFile = origin.file;
        return PackageManager.INSTALL_SUCCEEDED;
    }
    try {
        final File tempDir = mInstallerService.allocateStageDirLegacy(volumeUuid);
        codeFile = tempDir;
        resourceFile = tempDir;
    } catch (IOException e) {
        Slog.w(TAG, "Failed to create copy file: " + e);
        return PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
    }
    final IParcelFileDescriptorFactory target = new IParcelFileDescriptorFactory.Stub() {

        @Override
        public ParcelFileDescriptor open(String name, int mode) throws RemoteException {
            if (!FileUtils.isValidExtFilename(name)) {
                throw new IllegalArgumentException("Invalid filename: " + name);
            }
            try {
                final File file = new File(codeFile, name);
                final FileDescriptor fd = Os.open(file.getAbsolutePath(), O_RDWR | O_CREAT, 0644);
                Os.chmod(file.getAbsolutePath(), 0644);
                return new ParcelFileDescriptor(fd);
            } catch (ErrnoException e) {
                throw new RemoteException("Failed to open: " + e.getMessage());
            }
        }
    };
    int ret = PackageManager.INSTALL_SUCCEEDED;
    ret = imcs.copyPackage(origin.file.getAbsolutePath(), target);
    if (ret != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG, "Failed to copy package");
        return ret;
    }
    final File libraryRoot = new File(codeFile, LIB_DIR_NAME);
    NativeLibraryHelper.Handle handle = null;
    try {
        handle = NativeLibraryHelper.Handle.create(codeFile);
        ret = NativeLibraryHelper.copyNativeBinariesWithOverride(handle, libraryRoot, abiOverride);
    } catch (IOException e) {
        Slog.e(TAG, "Copying native libraries failed", e);
        ret = PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
    } finally {
        IoUtils.closeQuietly(handle);
    }
    return ret;
}
#method_after
int copyApk(IMediaContainerService imcs, boolean temp) throws RemoteException {
    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "copyApk");
    try {
        return doCopyApk(imcs, temp);
    } finally {
        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
    }
}
#end_block

#method_before
boolean doRename(int status, PackageParser.Package pkg, String oldCodePath) {
    if (status != PackageManager.INSTALL_SUCCEEDED) {
        cleanUp();
        return false;
    }
    final File targetDir = codeFile.getParentFile();
    final File beforeCodeFile = codeFile;
    final File afterCodeFile = getNextCodePath(targetDir, pkg.packageName);
    if (DEBUG_INSTALL)
        Slog.d(TAG, "Renaming " + beforeCodeFile + " to " + afterCodeFile);
    try {
        Os.rename(beforeCodeFile.getAbsolutePath(), afterCodeFile.getAbsolutePath());
    } catch (ErrnoException e) {
        Slog.w(TAG, "Failed to rename", e);
        return false;
    }
    if (!SELinux.restoreconRecursive(afterCodeFile)) {
        Slog.w(TAG, "Failed to restorecon");
        return false;
    }
    // Reflect the rename internally
    codeFile = afterCodeFile;
    resourceFile = afterCodeFile;
    // Reflect the rename in scanned details
    pkg.codePath = afterCodeFile.getAbsolutePath();
    pkg.baseCodePath = FileUtils.rewriteAfterRename(beforeCodeFile, afterCodeFile, pkg.baseCodePath);
    pkg.splitCodePaths = FileUtils.rewriteAfterRename(beforeCodeFile, afterCodeFile, pkg.splitCodePaths);
    // Reflect the rename in app info
    pkg.applicationInfo.volumeUuid = pkg.volumeUuid;
    pkg.applicationInfo.setCodePath(pkg.codePath);
    pkg.applicationInfo.setBaseCodePath(pkg.baseCodePath);
    pkg.applicationInfo.setSplitCodePaths(pkg.splitCodePaths);
    pkg.applicationInfo.setResourcePath(pkg.codePath);
    pkg.applicationInfo.setBaseResourcePath(pkg.baseCodePath);
    pkg.applicationInfo.setSplitResourcePaths(pkg.splitCodePaths);
    return true;
}
#method_after
boolean doRename(int status, PackageParser.Package pkg, String oldCodePath) {
    if (status != PackageManager.INSTALL_SUCCEEDED) {
        cleanUp();
        return false;
    }
    final File targetDir = codeFile.getParentFile();
    final File beforeCodeFile = codeFile;
    final File afterCodeFile = getNextCodePath(targetDir, pkg.packageName);
    if (DEBUG_INSTALL)
        Slog.d(TAG, "Renaming " + beforeCodeFile + " to " + afterCodeFile);
    try {
        Os.rename(beforeCodeFile.getAbsolutePath(), afterCodeFile.getAbsolutePath());
    } catch (ErrnoException e) {
        Slog.w(TAG, "Failed to rename", e);
        return false;
    }
    if (!SELinux.restoreconRecursive(afterCodeFile)) {
        Slog.w(TAG, "Failed to restorecon");
        return false;
    }
    // Reflect the rename internally
    codeFile = afterCodeFile;
    resourceFile = afterCodeFile;
    // Reflect the rename in scanned details
    pkg.setCodePath(afterCodeFile.getAbsolutePath());
    pkg.setBaseCodePath(FileUtils.rewriteAfterRename(beforeCodeFile, afterCodeFile, pkg.baseCodePath));
    pkg.setSplitCodePaths(FileUtils.rewriteAfterRename(beforeCodeFile, afterCodeFile, pkg.splitCodePaths));
    // Reflect the rename in app info
    pkg.setApplicationVolumeUuid(pkg.volumeUuid);
    pkg.setApplicationInfoCodePath(pkg.codePath);
    pkg.setApplicationInfoBaseCodePath(pkg.baseCodePath);
    pkg.setApplicationInfoSplitCodePaths(pkg.splitCodePaths);
    pkg.setApplicationInfoResourcePath(pkg.codePath);
    pkg.setApplicationInfoBaseResourcePath(pkg.baseCodePath);
    pkg.setApplicationInfoSplitResourcePaths(pkg.splitCodePaths);
    return true;
}
#end_block

#method_before
private boolean cleanUp() {
    if (codeFile == null || !codeFile.exists()) {
        return false;
    }
    if (codeFile.isDirectory()) {
        mInstaller.rmPackageDir(codeFile.getAbsolutePath());
    } else {
        codeFile.delete();
    }
    if (resourceFile != null && !FileUtils.contains(codeFile, resourceFile)) {
        resourceFile.delete();
    }
    return true;
}
#method_after
private boolean cleanUp() {
    if (codeFile == null || !codeFile.exists()) {
        return false;
    }
    removeCodePathLI(codeFile);
    if (resourceFile != null && !FileUtils.contains(codeFile, resourceFile)) {
        resourceFile.delete();
    }
    return true;
}
#end_block

#method_before
int copyApk(IMediaContainerService imcs, boolean temp) throws RemoteException {
    if (origin.staged) {
        if (DEBUG_INSTALL)
            Slog.d(TAG, origin.cid + " already staged; skipping copy");
        cid = origin.cid;
        setMountPath(PackageHelper.getSdDir(cid));
        return PackageManager.INSTALL_SUCCEEDED;
    }
    if (temp) {
        createCopyFile();
    } else {
        /*
                 * Pre-emptively destroy the container since it's destroyed if
                 * copying fails due to it existing anyway.
                 */
        PackageHelper.destroySdDir(cid);
    }
    final String newMountPath = imcs.copyPackageToContainer(origin.file.getAbsolutePath(), cid, getEncryptKey(), isExternalAsec(), isFwdLocked(), deriveAbiOverride(abiOverride, null));
    if (newMountPath != null) {
        setMountPath(newMountPath);
        return PackageManager.INSTALL_SUCCEEDED;
    } else {
        return PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    }
}
#method_after
int copyApk(IMediaContainerService imcs, boolean temp) throws RemoteException {
    if (origin.staged && origin.cid != null) {
        if (DEBUG_INSTALL)
            Slog.d(TAG, origin.cid + " already staged; skipping copy");
        cid = origin.cid;
        setMountPath(PackageHelper.getSdDir(cid));
        return PackageManager.INSTALL_SUCCEEDED;
    }
    if (temp) {
        createCopyFile();
    } else {
        /*
                 * Pre-emptively destroy the container since it's destroyed if
                 * copying fails due to it existing anyway.
                 */
        PackageHelper.destroySdDir(cid);
    }
    final String newMountPath = imcs.copyPackageToContainer(origin.file.getAbsolutePath(), cid, getEncryptKey(), isExternalAsec(), isFwdLocked(), deriveAbiOverride(abiOverride, null));
    if (newMountPath != null) {
        setMountPath(newMountPath);
        return PackageManager.INSTALL_SUCCEEDED;
    } else {
        return PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    }
}
#end_block

#method_before
boolean doRename(int status, PackageParser.Package pkg, String oldCodePath) {
    String newCacheId = getNextCodePath(oldCodePath, pkg.packageName, "/" + RES_FILE_NAME);
    String newMountPath = null;
    if (PackageHelper.isContainerMounted(cid)) {
        // Unmount the container
        if (!PackageHelper.unMountSdDir(cid)) {
            Slog.i(TAG, "Failed to unmount " + cid + " before renaming");
            return false;
        }
    }
    if (!PackageHelper.renameSdDir(cid, newCacheId)) {
        Slog.e(TAG, "Failed to rename " + cid + " to " + newCacheId + " which might be stale. Will try to clean up.");
        // Clean up the stale container and proceed to recreate.
        if (!PackageHelper.destroySdDir(newCacheId)) {
            Slog.e(TAG, "Very strange. Cannot clean up stale container " + newCacheId);
            return false;
        }
        // Successfully cleaned up stale container. Try to rename again.
        if (!PackageHelper.renameSdDir(cid, newCacheId)) {
            Slog.e(TAG, "Failed to rename " + cid + " to " + newCacheId + " inspite of cleaning it up.");
            return false;
        }
    }
    if (!PackageHelper.isContainerMounted(newCacheId)) {
        Slog.w(TAG, "Mounting container " + newCacheId);
        newMountPath = PackageHelper.mountSdDir(newCacheId, getEncryptKey(), Process.SYSTEM_UID);
    } else {
        newMountPath = PackageHelper.getSdDir(newCacheId);
    }
    if (newMountPath == null) {
        Slog.w(TAG, "Failed to get cache path for  " + newCacheId);
        return false;
    }
    Log.i(TAG, "Succesfully renamed " + cid + " to " + newCacheId + " at new path: " + newMountPath);
    cid = newCacheId;
    final File beforeCodeFile = new File(packagePath);
    setMountPath(newMountPath);
    final File afterCodeFile = new File(packagePath);
    // Reflect the rename in scanned details
    pkg.codePath = afterCodeFile.getAbsolutePath();
    pkg.baseCodePath = FileUtils.rewriteAfterRename(beforeCodeFile, afterCodeFile, pkg.baseCodePath);
    pkg.splitCodePaths = FileUtils.rewriteAfterRename(beforeCodeFile, afterCodeFile, pkg.splitCodePaths);
    // Reflect the rename in app info
    pkg.applicationInfo.volumeUuid = pkg.volumeUuid;
    pkg.applicationInfo.setCodePath(pkg.codePath);
    pkg.applicationInfo.setBaseCodePath(pkg.baseCodePath);
    pkg.applicationInfo.setSplitCodePaths(pkg.splitCodePaths);
    pkg.applicationInfo.setResourcePath(pkg.codePath);
    pkg.applicationInfo.setBaseResourcePath(pkg.baseCodePath);
    pkg.applicationInfo.setSplitResourcePaths(pkg.splitCodePaths);
    return true;
}
#method_after
boolean doRename(int status, PackageParser.Package pkg, String oldCodePath) {
    String newCacheId = getNextCodePath(oldCodePath, pkg.packageName, "/" + RES_FILE_NAME);
    String newMountPath = null;
    if (PackageHelper.isContainerMounted(cid)) {
        // Unmount the container
        if (!PackageHelper.unMountSdDir(cid)) {
            Slog.i(TAG, "Failed to unmount " + cid + " before renaming");
            return false;
        }
    }
    if (!PackageHelper.renameSdDir(cid, newCacheId)) {
        Slog.e(TAG, "Failed to rename " + cid + " to " + newCacheId + " which might be stale. Will try to clean up.");
        // Clean up the stale container and proceed to recreate.
        if (!PackageHelper.destroySdDir(newCacheId)) {
            Slog.e(TAG, "Very strange. Cannot clean up stale container " + newCacheId);
            return false;
        }
        // Successfully cleaned up stale container. Try to rename again.
        if (!PackageHelper.renameSdDir(cid, newCacheId)) {
            Slog.e(TAG, "Failed to rename " + cid + " to " + newCacheId + " inspite of cleaning it up.");
            return false;
        }
    }
    if (!PackageHelper.isContainerMounted(newCacheId)) {
        Slog.w(TAG, "Mounting container " + newCacheId);
        newMountPath = PackageHelper.mountSdDir(newCacheId, getEncryptKey(), Process.SYSTEM_UID);
    } else {
        newMountPath = PackageHelper.getSdDir(newCacheId);
    }
    if (newMountPath == null) {
        Slog.w(TAG, "Failed to get cache path for  " + newCacheId);
        return false;
    }
    Log.i(TAG, "Succesfully renamed " + cid + " to " + newCacheId + " at new path: " + newMountPath);
    cid = newCacheId;
    final File beforeCodeFile = new File(packagePath);
    setMountPath(newMountPath);
    final File afterCodeFile = new File(packagePath);
    // Reflect the rename in scanned details
    pkg.setCodePath(afterCodeFile.getAbsolutePath());
    pkg.setBaseCodePath(FileUtils.rewriteAfterRename(beforeCodeFile, afterCodeFile, pkg.baseCodePath));
    pkg.setSplitCodePaths(FileUtils.rewriteAfterRename(beforeCodeFile, afterCodeFile, pkg.splitCodePaths));
    // Reflect the rename in app info
    pkg.setApplicationVolumeUuid(pkg.volumeUuid);
    pkg.setApplicationInfoCodePath(pkg.codePath);
    pkg.setApplicationInfoBaseCodePath(pkg.baseCodePath);
    pkg.setApplicationInfoSplitCodePaths(pkg.splitCodePaths);
    pkg.setApplicationInfoResourcePath(pkg.codePath);
    pkg.setApplicationInfoBaseResourcePath(pkg.baseCodePath);
    pkg.setApplicationInfoSplitResourcePaths(pkg.splitCodePaths);
    return true;
}
#end_block

#method_before
@Override
int doPreCopy() {
    if (isFwdLocked()) {
        if (!PackageHelper.fixSdPermissions(cid, getPackageUid(DEFAULT_CONTAINER_PACKAGE, 0), RES_FILE_NAME)) {
            return PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
        }
    }
    return PackageManager.INSTALL_SUCCEEDED;
}
#method_after
@Override
int doPreCopy() {
    if (isFwdLocked()) {
        if (!PackageHelper.fixSdPermissions(cid, getPackageUid(DEFAULT_CONTAINER_PACKAGE, MATCH_SYSTEM_ONLY, UserHandle.USER_SYSTEM), RES_FILE_NAME)) {
            return PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
        }
    }
    return PackageManager.INSTALL_SUCCEEDED;
}
#end_block

#method_before
int copyApk(IMediaContainerService imcs, boolean temp) {
    if (DEBUG_INSTALL)
        Slog.d(TAG, "Moving " + move.packageName + " from " + move.fromUuid + " to " + move.toUuid);
    synchronized (mInstaller) {
        if (mInstaller.copyCompleteApp(move.fromUuid, move.toUuid, move.packageName, move.dataAppName, move.appId, move.seinfo) != 0) {
            return PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
        }
    }
    codeFile = new File(Environment.getDataAppDirectory(move.toUuid), move.dataAppName);
    resourceFile = codeFile;
    if (DEBUG_INSTALL)
        Slog.d(TAG, "codeFile after move is " + codeFile);
    return PackageManager.INSTALL_SUCCEEDED;
}
#method_after
int copyApk(IMediaContainerService imcs, boolean temp) {
    if (DEBUG_INSTALL)
        Slog.d(TAG, "Moving " + move.packageName + " from " + move.fromUuid + " to " + move.toUuid);
    synchronized (mInstaller) {
        try {
            mInstaller.moveCompleteApp(move.fromUuid, move.toUuid, move.packageName, move.dataAppName, move.appId, move.seinfo, move.targetSdkVersion);
        } catch (InstallerException e) {
            Slog.w(TAG, "Failed to move app", e);
            return PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
        }
    }
    codeFile = new File(Environment.getDataAppDirectory(move.toUuid), move.dataAppName);
    resourceFile = codeFile;
    if (DEBUG_INSTALL)
        Slog.d(TAG, "codeFile after move is " + codeFile);
    return PackageManager.INSTALL_SUCCEEDED;
}
#end_block

#method_before
boolean doRename(int status, PackageParser.Package pkg, String oldCodePath) {
    if (status != PackageManager.INSTALL_SUCCEEDED) {
        cleanUp(move.toUuid);
        return false;
    }
    // Reflect the move in app info
    pkg.applicationInfo.volumeUuid = pkg.volumeUuid;
    pkg.applicationInfo.setCodePath(pkg.codePath);
    pkg.applicationInfo.setBaseCodePath(pkg.baseCodePath);
    pkg.applicationInfo.setSplitCodePaths(pkg.splitCodePaths);
    pkg.applicationInfo.setResourcePath(pkg.codePath);
    pkg.applicationInfo.setBaseResourcePath(pkg.baseCodePath);
    pkg.applicationInfo.setSplitResourcePaths(pkg.splitCodePaths);
    return true;
}
#method_after
boolean doRename(int status, PackageParser.Package pkg, String oldCodePath) {
    if (status != PackageManager.INSTALL_SUCCEEDED) {
        cleanUp(move.toUuid);
        return false;
    }
    // Reflect the move in app info
    pkg.setApplicationVolumeUuid(pkg.volumeUuid);
    pkg.setApplicationInfoCodePath(pkg.codePath);
    pkg.setApplicationInfoBaseCodePath(pkg.baseCodePath);
    pkg.setApplicationInfoSplitCodePaths(pkg.splitCodePaths);
    pkg.setApplicationInfoResourcePath(pkg.codePath);
    pkg.setApplicationInfoBaseResourcePath(pkg.baseCodePath);
    pkg.setApplicationInfoSplitResourcePaths(pkg.splitCodePaths);
    return true;
}
#end_block

#method_before
private boolean cleanUp(String volumeUuid) {
    final File codeFile = new File(Environment.getDataAppDirectory(volumeUuid), move.dataAppName);
    Slog.d(TAG, "Cleaning up " + move.packageName + " on " + volumeUuid);
    synchronized (mInstallLock) {
        // Clean up both app data and code
        removeDataDirsLI(volumeUuid, move.packageName);
        if (codeFile.isDirectory()) {
            mInstaller.rmPackageDir(codeFile.getAbsolutePath());
        } else {
            codeFile.delete();
        }
    }
    return true;
}
#method_after
private boolean cleanUp(String volumeUuid) {
    final File codeFile = new File(Environment.getDataAppDirectory(volumeUuid), move.dataAppName);
    Slog.d(TAG, "Cleaning up " + move.packageName + " on " + volumeUuid);
    final int[] userIds = sUserManager.getUserIds();
    synchronized (mInstallLock) {
        // All package moves are frozen until finished
        for (int userId : userIds) {
            try {
                mInstaller.destroyAppData(volumeUuid, move.packageName, userId, StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE, 0);
            } catch (InstallerException e) {
                Slog.w(TAG, String.valueOf(e));
            }
        }
        removeCodePathLI(codeFile);
    }
    return true;
}
#end_block

#method_before
public void setError(int code, String msg) {
    returnCode = code;
    returnMsg = msg;
    Slog.w(TAG, msg);
}
#method_after
public void setError(int code, String msg) {
    setReturnCode(code);
    setReturnMessage(msg);
    Slog.w(TAG, msg);
}
#end_block

#method_before
public void setError(String msg, PackageParserException e) {
    returnCode = e.error;
    returnMsg = ExceptionUtils.getCompleteMessage(msg, e);
    Slog.w(TAG, msg, e);
}
#method_after
public void setError(String msg, PackageParserException e) {
    setReturnCode(e.error);
    setReturnMessage(ExceptionUtils.getCompleteMessage(msg, e));
    Slog.w(TAG, msg, e);
}
#end_block

#method_before
public void setError(String msg, PackageManagerException e) {
    returnCode = e.error;
    returnMsg = ExceptionUtils.getCompleteMessage(msg, e);
    Slog.w(TAG, msg, e);
}
#method_after
public void setError(String msg, PackageManagerException e) {
    returnCode = e.error;
    setReturnMessage(ExceptionUtils.getCompleteMessage(msg, e));
    Slog.w(TAG, msg, e);
}
#end_block

#method_before
private void updateSettingsLI(PackageParser.Package newPackage, String installerPackageName, String volumeUuid, int[] allUsers, boolean[] perUserInstalled, PackageInstalledInfo res, UserHandle user) {
    String pkgName = newPackage.packageName;
    synchronized (mPackages) {
        // write settings. the installStatus will be incomplete at this stage.
        // note that the new package setting would have already been
        // added to mPackages. It hasn't been persisted yet.
        mSettings.setInstallStatus(pkgName, PackageSettingBase.PKG_INSTALL_INCOMPLETE);
        mSettings.writeLPr();
    }
    if (DEBUG_INSTALL)
        Slog.d(TAG, "New package installed in " + newPackage.codePath);
    synchronized (mPackages) {
        updatePermissionsLPw(newPackage.packageName, newPackage, UPDATE_PERMISSIONS_REPLACE_PKG | (newPackage.permissions.size() > 0 ? UPDATE_PERMISSIONS_ALL : 0));
        // For system-bundled packages, we assume that installing an upgraded version
        // of the package implies that the user actually wants to run that new code,
        // so we enable the package.
        PackageSetting ps = mSettings.mPackages.get(pkgName);
        if (ps != null) {
            if (isSystemApp(newPackage)) {
                // NB: implicit assumption that system package upgrades apply to all users
                if (DEBUG_INSTALL) {
                    Slog.d(TAG, "Implicitly enabling system package on upgrade: " + pkgName);
                }
                if (res.origUsers != null) {
                    for (int userHandle : res.origUsers) {
                        ps.setEnabled(COMPONENT_ENABLED_STATE_DEFAULT, userHandle, installerPackageName);
                    }
                }
                // Also convey the prior install/uninstall state
                if (allUsers != null && perUserInstalled != null) {
                    for (int i = 0; i < allUsers.length; i++) {
                        if (DEBUG_INSTALL) {
                            Slog.d(TAG, "    user " + allUsers[i] + " => " + perUserInstalled[i]);
                        }
                        ps.setInstalled(perUserInstalled[i], allUsers[i]);
                    }
                // these install state changes will be persisted in the
                // upcoming call to mSettings.writeLPr().
                }
            }
            // It's implied that when a user requests installation, they want the app to be
            // installed and enabled.
            int userId = user.getIdentifier();
            if (userId != UserHandle.USER_ALL) {
                ps.setInstalled(true, userId);
                ps.setEnabled(COMPONENT_ENABLED_STATE_DEFAULT, userId, installerPackageName);
            }
        }
        res.name = pkgName;
        res.uid = newPackage.applicationInfo.uid;
        res.pkg = newPackage;
        mSettings.setInstallStatus(pkgName, PackageSettingBase.PKG_INSTALL_COMPLETE);
        mSettings.setInstallerPackageName(pkgName, installerPackageName);
        res.returnCode = PackageManager.INSTALL_SUCCEEDED;
        // to update install status
        mSettings.writeLPr();
    }
}
#method_after
private void updateSettingsLI(PackageParser.Package newPackage, String installerPackageName, int[] allUsers, PackageInstalledInfo res, UserHandle user) {
    // Update the parent package setting
    updateSettingsInternalLI(newPackage, installerPackageName, allUsers, res.origUsers, res, user);
    // Update the child packages setting
    final int childCount = (newPackage.childPackages != null) ? newPackage.childPackages.size() : 0;
    for (int i = 0; i < childCount; i++) {
        PackageParser.Package childPackage = newPackage.childPackages.get(i);
        PackageInstalledInfo childRes = res.addedChildPackages.get(childPackage.packageName);
        updateSettingsInternalLI(childPackage, installerPackageName, allUsers, childRes.origUsers, childRes, user);
    }
}
#end_block

#method_before
private void installPackageLI(InstallArgs args, PackageInstalledInfo res) {
    final int installFlags = args.installFlags;
    final String installerPackageName = args.installerPackageName;
    final String volumeUuid = args.volumeUuid;
    final File tmpPackageFile = new File(args.getCodePath());
    final boolean forwardLocked = ((installFlags & PackageManager.INSTALL_FORWARD_LOCK) != 0);
    final boolean onExternal = (((installFlags & PackageManager.INSTALL_EXTERNAL) != 0) || (args.volumeUuid != null));
    boolean replace = false;
    int scanFlags = SCAN_NEW_INSTALL | SCAN_UPDATE_SIGNATURE;
    if (args.move != null) {
        // moving a complete application; perfom an initial scan on the new install location
        scanFlags |= SCAN_INITIAL;
    }
    // Result object to be returned
    res.returnCode = PackageManager.INSTALL_SUCCEEDED;
    if (DEBUG_INSTALL)
        Slog.d(TAG, "installPackageLI: path=" + tmpPackageFile);
    // Retrieve PackageSettings and parse package
    final int parseFlags = mDefParseFlags | PackageParser.PARSE_CHATTY | (forwardLocked ? PackageParser.PARSE_FORWARD_LOCK : 0) | (onExternal ? PackageParser.PARSE_EXTERNAL_STORAGE : 0);
    PackageParser pp = new PackageParser();
    pp.setSeparateProcesses(mSeparateProcesses);
    pp.setDisplayMetrics(mMetrics);
    final PackageParser.Package pkg;
    try {
        pkg = pp.parsePackage(tmpPackageFile, parseFlags);
    } catch (PackageParserException e) {
        res.setError("Failed parse during installPackageLI", e);
        return;
    }
    // Mark that we have an install time CPU ABI override.
    pkg.cpuAbiOverride = args.abiOverride;
    String pkgName = res.name = pkg.packageName;
    if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_TEST_ONLY) != 0) {
        if ((installFlags & PackageManager.INSTALL_ALLOW_TEST) == 0) {
            res.setError(INSTALL_FAILED_TEST_ONLY, "installPackageLI");
            return;
        }
    }
    try {
        pp.collectCertificates(pkg, parseFlags);
        pp.collectManifestDigest(pkg);
    } catch (PackageParserException e) {
        res.setError("Failed collect during installPackageLI", e);
        return;
    }
    /* If the installer passed in a manifest digest, compare it now. */
    if (args.manifestDigest != null) {
        if (DEBUG_INSTALL) {
            final String parsedManifest = pkg.manifestDigest == null ? "null" : pkg.manifestDigest.toString();
            Slog.d(TAG, "Comparing manifests: " + args.manifestDigest.toString() + " vs. " + parsedManifest);
        }
        if (!args.manifestDigest.equals(pkg.manifestDigest)) {
            res.setError(INSTALL_FAILED_PACKAGE_CHANGED, "Manifest digest changed");
            return;
        }
    } else if (DEBUG_INSTALL) {
        final String parsedManifest = pkg.manifestDigest == null ? "null" : pkg.manifestDigest.toString();
        Slog.d(TAG, "manifestDigest was not present, but parser got: " + parsedManifest);
    }
    // Get rid of all references to package scan path via parser.
    pp = null;
    String oldCodePath = null;
    boolean systemApp = false;
    synchronized (mPackages) {
        // Check if installing already existing package
        if ((installFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
            String oldName = mSettings.mRenamedPackages.get(pkgName);
            if (pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(oldName) && mPackages.containsKey(oldName)) {
                // This package is derived from an original package,
                // and this device has been updating from that original
                // name.  We must continue using the original name, so
                // rename the new package here.
                pkg.setPackageName(oldName);
                pkgName = pkg.packageName;
                replace = true;
                if (DEBUG_INSTALL)
                    Slog.d(TAG, "Replacing existing renamed package: oldName=" + oldName + " pkgName=" + pkgName);
            } else if (mPackages.containsKey(pkgName)) {
                // This package, under its official name, already exists
                // on the device; we should replace it.
                replace = true;
                if (DEBUG_INSTALL)
                    Slog.d(TAG, "Replace existing pacakge: " + pkgName);
            }
            // Prevent apps opting out from runtime permissions
            if (replace) {
                PackageParser.Package oldPackage = mPackages.get(pkgName);
                final int oldTargetSdk = oldPackage.applicationInfo.targetSdkVersion;
                final int newTargetSdk = pkg.applicationInfo.targetSdkVersion;
                if (oldTargetSdk > Build.VERSION_CODES.LOLLIPOP_MR1 && newTargetSdk <= Build.VERSION_CODES.LOLLIPOP_MR1) {
                    res.setError(PackageManager.INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE, "Package " + pkg.packageName + " new target SDK " + newTargetSdk + " doesn't support runtime permissions but the old" + " target SDK " + oldTargetSdk + " does.");
                    return;
                }
            }
        }
        PackageSetting ps = mSettings.mPackages.get(pkgName);
        if (ps != null) {
            if (DEBUG_INSTALL)
                Slog.d(TAG, "Existing package: " + ps);
            // bail early here before tripping over redefined permissions.
            if (shouldCheckUpgradeKeySetLP(ps, scanFlags)) {
                if (!checkUpgradeKeySetLP(ps, pkg)) {
                    res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE, "Package " + pkg.packageName + " upgrade keys do not match the " + "previously installed version");
                    return;
                }
            } else {
                try {
                    verifySignaturesLP(ps, pkg);
                } catch (PackageManagerException e) {
                    res.setError(e.error, e.getMessage());
                    return;
                }
            }
            oldCodePath = mSettings.mPackages.get(pkgName).codePathString;
            if (ps.pkg != null && ps.pkg.applicationInfo != null) {
                systemApp = (ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0;
            }
            res.origUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
        }
        // Check whether the newly-scanned package wants to define an already-defined perm
        int N = pkg.permissions.size();
        for (int i = N - 1; i >= 0; i--) {
            PackageParser.Permission perm = pkg.permissions.get(i);
            BasePermission bp = mSettings.mPermissions.get(perm.info.name);
            if (bp != null) {
                // If the defining package is signed with our cert, it's okay.  This
                // also includes the "updating the same package" case, of course.
                // "updating same package" could also involve key-rotation.
                final boolean sigsOk;
                if (bp.sourcePackage.equals(pkg.packageName) && (bp.packageSetting instanceof PackageSetting) && (shouldCheckUpgradeKeySetLP((PackageSetting) bp.packageSetting, scanFlags))) {
                    sigsOk = checkUpgradeKeySetLP((PackageSetting) bp.packageSetting, pkg);
                } else {
                    sigsOk = compareSignatures(bp.packageSetting.signatures.mSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH;
                }
                if (!sigsOk) {
                    // redefinitions.
                    if (!bp.sourcePackage.equals("android")) {
                        res.setError(INSTALL_FAILED_DUPLICATE_PERMISSION, "Package " + pkg.packageName + " attempting to redeclare permission " + perm.info.name + " already owned by " + bp.sourcePackage);
                        res.origPermission = perm.info.name;
                        res.origPackage = bp.sourcePackage;
                        return;
                    } else {
                        Slog.w(TAG, "Package " + pkg.packageName + " attempting to redeclare system permission " + perm.info.name + "; ignoring new declaration");
                        pkg.permissions.remove(i);
                    }
                }
            }
        }
    }
    if (systemApp && onExternal) {
        // Disable updates to system apps on sdcard
        res.setError(INSTALL_FAILED_INVALID_INSTALL_LOCATION, "Cannot install updates to system apps on sdcard");
        return;
    }
    if (args.move != null) {
        // We did an in-place move, so dex is ready to roll
        scanFlags |= SCAN_NO_DEX;
        scanFlags |= SCAN_MOVE;
        synchronized (mPackages) {
            final PackageSetting ps = mSettings.mPackages.get(pkgName);
            if (ps == null) {
                res.setError(INSTALL_FAILED_INTERNAL_ERROR, "Missing settings for moved package " + pkgName);
            }
            // We moved the entire application as-is, so bring over the
            // previously derived ABI information.
            pkg.applicationInfo.primaryCpuAbi = ps.primaryCpuAbiString;
            pkg.applicationInfo.secondaryCpuAbi = ps.secondaryCpuAbiString;
        }
    } else if (!forwardLocked && !pkg.applicationInfo.isExternalAsec()) {
        // Enable SCAN_NO_DEX flag to skip dexopt at a later stage
        scanFlags |= SCAN_NO_DEX;
        try {
            derivePackageAbi(pkg, new File(pkg.codePath), args.abiOverride, true);
        } catch (PackageManagerException pme) {
            Slog.e(TAG, "Error deriving application ABI", pme);
            res.setError(INSTALL_FAILED_INTERNAL_ERROR, "Error deriving application ABI");
            return;
        }
        // Run dexopt before old package gets removed, to minimize time when app is unavailable
        int result = mPackageDexOptimizer.performDexOpt(pkg, null, /* instruction sets */
        false, /* forceDex */
        false, /* defer */
        false, /* inclDependencies */
        true, /*bootComplete*/
        false);
        if (result == PackageDexOptimizer.DEX_OPT_FAILED) {
            res.setError(INSTALL_FAILED_DEXOPT, "Dexopt failed for " + pkg.codePath);
            return;
        }
    }
    if (!args.doRename(res.returnCode, pkg, oldCodePath)) {
        res.setError(INSTALL_FAILED_INSUFFICIENT_STORAGE, "Failed rename");
        return;
    }
    startIntentFilterVerifications(args.user.getIdentifier(), replace, pkg);
    if (replace) {
        replacePackageLI(pkg, parseFlags, scanFlags | SCAN_REPLACING, args.user, installerPackageName, volumeUuid, res);
    } else {
        installNewPackageLI(pkg, parseFlags, scanFlags | SCAN_DELETE_DATA_ON_FAILURES, args.user, installerPackageName, volumeUuid, res);
    }
    synchronized (mPackages) {
        final PackageSetting ps = mSettings.mPackages.get(pkgName);
        if (ps != null) {
            res.newUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
        }
    }
}
#method_after
private void installPackageLI(InstallArgs args, PackageInstalledInfo res) {
    final int installFlags = args.installFlags;
    final String installerPackageName = args.installerPackageName;
    final String volumeUuid = args.volumeUuid;
    final File tmpPackageFile = new File(args.getCodePath());
    final boolean forwardLocked = ((installFlags & PackageManager.INSTALL_FORWARD_LOCK) != 0);
    final boolean onExternal = (((installFlags & PackageManager.INSTALL_EXTERNAL) != 0) || (args.volumeUuid != null));
    final boolean ephemeral = ((installFlags & PackageManager.INSTALL_EPHEMERAL) != 0);
    final boolean forceSdk = ((installFlags & PackageManager.INSTALL_FORCE_SDK) != 0);
    boolean replace = false;
    int scanFlags = SCAN_NEW_INSTALL | SCAN_UPDATE_SIGNATURE;
    if (args.move != null) {
        // moving a complete application; perform an initial scan on the new install location
        scanFlags |= SCAN_INITIAL;
    }
    if ((installFlags & PackageManager.INSTALL_DONT_KILL_APP) != 0) {
        scanFlags |= SCAN_DONT_KILL_APP;
    }
    // Result object to be returned
    res.setReturnCode(PackageManager.INSTALL_SUCCEEDED);
    if (DEBUG_INSTALL)
        Slog.d(TAG, "installPackageLI: path=" + tmpPackageFile);
    // Sanity check
    if (ephemeral && (forwardLocked || onExternal)) {
        Slog.i(TAG, "Incompatible ephemeral install; fwdLocked=" + forwardLocked + " external=" + onExternal);
        res.setReturnCode(PackageManager.INSTALL_FAILED_EPHEMERAL_INVALID);
        return;
    }
    // Retrieve PackageSettings and parse package
    final int parseFlags = mDefParseFlags | PackageParser.PARSE_CHATTY | PackageParser.PARSE_ENFORCE_CODE | (forwardLocked ? PackageParser.PARSE_FORWARD_LOCK : 0) | (onExternal ? PackageParser.PARSE_EXTERNAL_STORAGE : 0) | (ephemeral ? PackageParser.PARSE_IS_EPHEMERAL : 0) | (forceSdk ? PackageParser.PARSE_FORCE_SDK : 0);
    PackageParser pp = new PackageParser();
    pp.setSeparateProcesses(mSeparateProcesses);
    pp.setDisplayMetrics(mMetrics);
    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "parsePackage");
    final PackageParser.Package pkg;
    try {
        pkg = pp.parsePackage(tmpPackageFile, parseFlags);
    } catch (PackageParserException e) {
        res.setError("Failed parse during installPackageLI", e);
        return;
    } finally {
        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
    }
    // If we are installing a clustered package add results for the children
    if (pkg.childPackages != null) {
        synchronized (mPackages) {
            final int childCount = pkg.childPackages.size();
            for (int i = 0; i < childCount; i++) {
                PackageParser.Package childPkg = pkg.childPackages.get(i);
                PackageInstalledInfo childRes = new PackageInstalledInfo();
                childRes.setReturnCode(PackageManager.INSTALL_SUCCEEDED);
                childRes.pkg = childPkg;
                childRes.name = childPkg.packageName;
                PackageSetting childPs = mSettings.peekPackageLPr(childPkg.packageName);
                if (childPs != null) {
                    childRes.origUsers = childPs.queryInstalledUsers(sUserManager.getUserIds(), true);
                }
                if ((mPackages.containsKey(childPkg.packageName))) {
                    childRes.removedInfo = new PackageRemovedInfo();
                    childRes.removedInfo.removedPackage = childPkg.packageName;
                }
                if (res.addedChildPackages == null) {
                    res.addedChildPackages = new ArrayMap<>();
                }
                res.addedChildPackages.put(childPkg.packageName, childRes);
            }
        }
    }
    // time CPU ABI override.
    if (TextUtils.isEmpty(pkg.cpuAbiOverride)) {
        pkg.cpuAbiOverride = args.abiOverride;
    }
    String pkgName = res.name = pkg.packageName;
    if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_TEST_ONLY) != 0) {
        if ((installFlags & PackageManager.INSTALL_ALLOW_TEST) == 0) {
            res.setError(INSTALL_FAILED_TEST_ONLY, "installPackageLI");
            return;
        }
    }
    try {
        // either use what we've been given or parse directly from the APK
        if (args.certificates != null) {
            try {
                PackageParser.populateCertificates(pkg, args.certificates);
            } catch (PackageParserException e) {
                // there was something wrong with the certificates we were given;
                // try to pull them from the APK
                PackageParser.collectCertificates(pkg, parseFlags);
            }
        } else {
            PackageParser.collectCertificates(pkg, parseFlags);
        }
    } catch (PackageParserException e) {
        res.setError("Failed collect during installPackageLI", e);
        return;
    }
    // Get rid of all references to package scan path via parser.
    pp = null;
    String oldCodePath = null;
    boolean systemApp = false;
    synchronized (mPackages) {
        // Check if installing already existing package
        if ((installFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
            String oldName = mSettings.mRenamedPackages.get(pkgName);
            if (pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(oldName) && mPackages.containsKey(oldName)) {
                // This package is derived from an original package,
                // and this device has been updating from that original
                // name.  We must continue using the original name, so
                // rename the new package here.
                pkg.setPackageName(oldName);
                pkgName = pkg.packageName;
                replace = true;
                if (DEBUG_INSTALL)
                    Slog.d(TAG, "Replacing existing renamed package: oldName=" + oldName + " pkgName=" + pkgName);
            } else if (mPackages.containsKey(pkgName)) {
                // This package, under its official name, already exists
                // on the device; we should replace it.
                replace = true;
                if (DEBUG_INSTALL)
                    Slog.d(TAG, "Replace existing pacakge: " + pkgName);
            }
            // Child packages are installed through the parent package
            if (pkg.parentPackage != null) {
                res.setError(PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME, "Package " + pkg.packageName + " is child of package " + pkg.parentPackage.parentPackage + ". Child packages " + "can be updated only through the parent package.");
                return;
            }
            if (replace) {
                // Prevent apps opting out from runtime permissions
                PackageParser.Package oldPackage = mPackages.get(pkgName);
                final int oldTargetSdk = oldPackage.applicationInfo.targetSdkVersion;
                final int newTargetSdk = pkg.applicationInfo.targetSdkVersion;
                if (oldTargetSdk > Build.VERSION_CODES.LOLLIPOP_MR1 && newTargetSdk <= Build.VERSION_CODES.LOLLIPOP_MR1) {
                    res.setError(PackageManager.INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE, "Package " + pkg.packageName + " new target SDK " + newTargetSdk + " doesn't support runtime permissions but the old" + " target SDK " + oldTargetSdk + " does.");
                    return;
                }
                // Prevent installing of child packages
                if (oldPackage.parentPackage != null) {
                    res.setError(PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME, "Package " + pkg.packageName + " is child of package " + oldPackage.parentPackage + ". Child packages " + "can be updated only through the parent package.");
                    return;
                }
            }
        }
        PackageSetting ps = mSettings.mPackages.get(pkgName);
        if (ps != null) {
            if (DEBUG_INSTALL)
                Slog.d(TAG, "Existing package: " + ps);
            // bail early here before tripping over redefined permissions.
            if (shouldCheckUpgradeKeySetLP(ps, scanFlags)) {
                if (!checkUpgradeKeySetLP(ps, pkg)) {
                    res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE, "Package " + pkg.packageName + " upgrade keys do not match the " + "previously installed version");
                    return;
                }
            } else {
                try {
                    verifySignaturesLP(ps, pkg);
                } catch (PackageManagerException e) {
                    res.setError(e.error, e.getMessage());
                    return;
                }
            }
            oldCodePath = mSettings.mPackages.get(pkgName).codePathString;
            if (ps.pkg != null && ps.pkg.applicationInfo != null) {
                systemApp = (ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0;
            }
            res.origUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
        }
        // Check whether the newly-scanned package wants to define an already-defined perm
        int N = pkg.permissions.size();
        for (int i = N - 1; i >= 0; i--) {
            PackageParser.Permission perm = pkg.permissions.get(i);
            BasePermission bp = mSettings.mPermissions.get(perm.info.name);
            if (bp != null) {
                // If the defining package is signed with our cert, it's okay.  This
                // also includes the "updating the same package" case, of course.
                // "updating same package" could also involve key-rotation.
                final boolean sigsOk;
                if (bp.sourcePackage.equals(pkg.packageName) && (bp.packageSetting instanceof PackageSetting) && (shouldCheckUpgradeKeySetLP((PackageSetting) bp.packageSetting, scanFlags))) {
                    sigsOk = checkUpgradeKeySetLP((PackageSetting) bp.packageSetting, pkg);
                } else {
                    sigsOk = compareSignatures(bp.packageSetting.signatures.mSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH;
                }
                if (!sigsOk) {
                    // redefinitions.
                    if (!bp.sourcePackage.equals("android")) {
                        res.setError(INSTALL_FAILED_DUPLICATE_PERMISSION, "Package " + pkg.packageName + " attempting to redeclare permission " + perm.info.name + " already owned by " + bp.sourcePackage);
                        res.origPermission = perm.info.name;
                        res.origPackage = bp.sourcePackage;
                        return;
                    } else {
                        Slog.w(TAG, "Package " + pkg.packageName + " attempting to redeclare system permission " + perm.info.name + "; ignoring new declaration");
                        pkg.permissions.remove(i);
                    }
                }
            }
        }
    }
    if (systemApp) {
        if (onExternal) {
            // Abort update; system app can't be replaced with app on sdcard
            res.setError(INSTALL_FAILED_INVALID_INSTALL_LOCATION, "Cannot install updates to system apps on sdcard");
            return;
        } else if (ephemeral) {
            // Abort update; system app can't be replaced with an ephemeral app
            res.setError(INSTALL_FAILED_EPHEMERAL_INVALID, "Cannot update a system app with an ephemeral app");
            return;
        }
    }
    if (args.move != null) {
        // We did an in-place move, so dex is ready to roll
        scanFlags |= SCAN_NO_DEX;
        scanFlags |= SCAN_MOVE;
        synchronized (mPackages) {
            final PackageSetting ps = mSettings.mPackages.get(pkgName);
            if (ps == null) {
                res.setError(INSTALL_FAILED_INTERNAL_ERROR, "Missing settings for moved package " + pkgName);
            }
            // We moved the entire application as-is, so bring over the
            // previously derived ABI information.
            pkg.applicationInfo.primaryCpuAbi = ps.primaryCpuAbiString;
            pkg.applicationInfo.secondaryCpuAbi = ps.secondaryCpuAbiString;
        }
    } else if (!forwardLocked && !pkg.applicationInfo.isExternalAsec()) {
        // Enable SCAN_NO_DEX flag to skip dexopt at a later stage
        scanFlags |= SCAN_NO_DEX;
        try {
            String abiOverride = (TextUtils.isEmpty(pkg.cpuAbiOverride) ? args.abiOverride : pkg.cpuAbiOverride);
            derivePackageAbi(pkg, new File(pkg.codePath), abiOverride, true);
        } catch (PackageManagerException pme) {
            Slog.e(TAG, "Error deriving application ABI", pme);
            res.setError(INSTALL_FAILED_INTERNAL_ERROR, "Error deriving application ABI");
            return;
        }
        // Shared libraries for the package need to be updated.
        synchronized (mPackages) {
            try {
                updateSharedLibrariesLPw(pkg, null);
            } catch (PackageManagerException e) {
                Slog.e(TAG, "updateSharedLibrariesLPw failed: " + e.getMessage());
            }
        }
        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "dexopt");
        // Do not run PackageDexOptimizer through the local performDexOpt
        // method because `pkg` may not be in `mPackages` yet.
        // 
        // Also, don't fail application installs if the dexopt step fails.
        mPackageDexOptimizer.performDexOpt(pkg, pkg.usesLibraryFiles, null, /* instructionSets */
        false, /* checkProfiles */
        getCompilerFilterForReason(REASON_INSTALL), getOrCreateCompilerPackageStats(pkg));
        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
        // Notify BackgroundDexOptService that the package has been changed.
        // If this is an update of a package which used to fail to compile,
        // BDOS will remove it from its blacklist.
        BackgroundDexOptService.notifyPackageChanged(pkg.packageName);
    }
    if (!args.doRename(res.returnCode, pkg, oldCodePath)) {
        res.setError(INSTALL_FAILED_INSUFFICIENT_STORAGE, "Failed rename");
        return;
    }
    startIntentFilterVerifications(args.user.getIdentifier(), replace, pkg);
    try (PackageFreezer freezer = freezePackageForInstall(pkgName, installFlags, "installPackageLI")) {
        if (replace) {
            replacePackageLIF(pkg, parseFlags, scanFlags | SCAN_REPLACING, args.user, installerPackageName, res);
        } else {
            installNewPackageLIF(pkg, parseFlags, scanFlags | SCAN_DELETE_DATA_ON_FAILURES, args.user, installerPackageName, volumeUuid, res);
        }
    }
    synchronized (mPackages) {
        final PackageSetting ps = mSettings.mPackages.get(pkgName);
        if (ps != null) {
            res.newUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
        }
        final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            PackageParser.Package childPkg = pkg.childPackages.get(i);
            PackageInstalledInfo childRes = res.addedChildPackages.get(childPkg.packageName);
            PackageSetting childPs = mSettings.peekPackageLPr(childPkg.packageName);
            if (childPs != null) {
                childRes.newUsers = childPs.queryInstalledUsers(sUserManager.getUserIds(), true);
            }
        }
    }
}
#end_block

#method_before
private void startIntentFilterVerifications(int userId, boolean replacing, PackageParser.Package pkg) {
    if (mIntentFilterVerifierComponent == null) {
        Slog.w(TAG, "No IntentFilter verification will not be done as " + "there is no IntentFilterVerifier available!");
        return;
    }
    final int verifierUid = getPackageUid(mIntentFilterVerifierComponent.getPackageName(), (userId == UserHandle.USER_ALL) ? UserHandle.USER_OWNER : userId);
    mHandler.removeMessages(START_INTENT_FILTER_VERIFICATIONS);
    final Message msg = mHandler.obtainMessage(START_INTENT_FILTER_VERIFICATIONS);
    msg.obj = new IFVerificationParams(pkg, replacing, userId, verifierUid);
    mHandler.sendMessage(msg);
}
#method_after
private void startIntentFilterVerifications(int userId, boolean replacing, PackageParser.Package pkg) {
    if (mIntentFilterVerifierComponent == null) {
        Slog.w(TAG, "No IntentFilter verification will not be done as " + "there is no IntentFilterVerifier available!");
        return;
    }
    final int verifierUid = getPackageUid(mIntentFilterVerifierComponent.getPackageName(), MATCH_DEBUG_TRIAGED_MISSING, (userId == UserHandle.USER_ALL) ? UserHandle.USER_SYSTEM : userId);
    Message msg = mHandler.obtainMessage(START_INTENT_FILTER_VERIFICATIONS);
    msg.obj = new IFVerificationParams(pkg, replacing, userId, verifierUid);
    mHandler.sendMessage(msg);
    final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0;
    for (int i = 0; i < childCount; i++) {
        PackageParser.Package childPkg = pkg.childPackages.get(i);
        msg = mHandler.obtainMessage(START_INTENT_FILTER_VERIFICATIONS);
        msg.obj = new IFVerificationParams(childPkg, replacing, userId, verifierUid);
        mHandler.sendMessage(msg);
    }
}
#end_block

#method_before
private int packageFlagsToInstallFlags(PackageSetting ps) {
    int installFlags = 0;
    if (isExternal(ps) && TextUtils.isEmpty(ps.volumeUuid)) {
        // This existing package was an external ASEC install when we have
        // the external flag without a UUID
        installFlags |= PackageManager.INSTALL_EXTERNAL;
    }
    if (ps.isForwardLocked()) {
        installFlags |= PackageManager.INSTALL_FORWARD_LOCK;
    }
    return installFlags;
}
#method_after
private int packageFlagsToInstallFlags(PackageSetting ps) {
    int installFlags = 0;
    if (isEphemeral(ps)) {
        installFlags |= PackageManager.INSTALL_EPHEMERAL;
    }
    if (isExternal(ps) && TextUtils.isEmpty(ps.volumeUuid)) {
        // This existing package was an external ASEC install when we have
        // the external flag without a UUID
        installFlags |= PackageManager.INSTALL_EXTERNAL;
    }
    if (ps.isForwardLocked()) {
        installFlags |= PackageManager.INSTALL_FORWARD_LOCK;
    }
    return installFlags;
}
#end_block

#method_before
@Override
public void deletePackage(final String packageName, final IPackageDeleteObserver2 observer, final int userId, final int flags) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.DELETE_PACKAGES, null);
    Preconditions.checkNotNull(packageName);
    Preconditions.checkNotNull(observer);
    final int uid = Binder.getCallingUid();
    if (UserHandle.getUserId(uid) != userId) {
        mContext.enforceCallingPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL, "deletePackage for user " + userId);
    }
    if (isUserRestricted(userId, UserManager.DISALLOW_UNINSTALL_APPS)) {
        try {
            observer.onPackageDeleted(packageName, PackageManager.DELETE_FAILED_USER_RESTRICTED, null);
        } catch (RemoteException re) {
        }
        return;
    }
    boolean uninstallBlocked = false;
    if ((flags & PackageManager.DELETE_ALL_USERS) != 0) {
        int[] users = sUserManager.getUserIds();
        for (int i = 0; i < users.length; ++i) {
            if (getBlockUninstallForUser(packageName, users[i])) {
                uninstallBlocked = true;
                break;
            }
        }
    } else {
        uninstallBlocked = getBlockUninstallForUser(packageName, userId);
    }
    if (uninstallBlocked) {
        try {
            observer.onPackageDeleted(packageName, PackageManager.DELETE_FAILED_OWNER_BLOCKED, null);
        } catch (RemoteException re) {
        }
        return;
    }
    if (DEBUG_REMOVE) {
        Slog.d(TAG, "deletePackageAsUser: pkg=" + packageName + " user=" + userId);
    }
    // Queue up an async operation since the package deletion may take a little while.
    mHandler.post(new Runnable() {

        public void run() {
            mHandler.removeCallbacks(this);
            final int returnCode = deletePackageX(packageName, userId, flags);
            if (observer != null) {
                try {
                    observer.onPackageDeleted(packageName, returnCode, null);
                } catch (RemoteException e) {
                    Log.i(TAG, "Observer no longer exists.");
                }
            // end catch
            }
        // end if
        }
    });
}
#method_after
@Override
public void deletePackage(final String packageName, final IPackageDeleteObserver2 observer, final int userId, final int deleteFlags) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.DELETE_PACKAGES, null);
    Preconditions.checkNotNull(packageName);
    Preconditions.checkNotNull(observer);
    final int uid = Binder.getCallingUid();
    final boolean deleteAllUsers = (deleteFlags & PackageManager.DELETE_ALL_USERS) != 0;
    final int[] users = deleteAllUsers ? sUserManager.getUserIds() : new int[] { userId };
    if (UserHandle.getUserId(uid) != userId || (deleteAllUsers && users.length > 1)) {
        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL, "deletePackage for user " + userId);
    }
    if (isUserRestricted(userId, UserManager.DISALLOW_UNINSTALL_APPS)) {
        try {
            observer.onPackageDeleted(packageName, PackageManager.DELETE_FAILED_USER_RESTRICTED, null);
        } catch (RemoteException re) {
        }
        return;
    }
    if (!deleteAllUsers && getBlockUninstallForUser(packageName, userId)) {
        try {
            observer.onPackageDeleted(packageName, PackageManager.DELETE_FAILED_OWNER_BLOCKED, null);
        } catch (RemoteException re) {
        }
        return;
    }
    if (DEBUG_REMOVE) {
        Slog.d(TAG, "deletePackageAsUser: pkg=" + packageName + " user=" + userId + " deleteAllUsers: " + deleteAllUsers);
    }
    // Queue up an async operation since the package deletion may take a little while.
    mHandler.post(new Runnable() {

        public void run() {
            mHandler.removeCallbacks(this);
            int returnCode;
            if (!deleteAllUsers) {
                returnCode = deletePackageX(packageName, userId, deleteFlags);
            } else {
                int[] blockUninstallUserIds = getBlockUninstallForUsers(packageName, users);
                // If nobody is blocking uninstall, proceed with delete for all users
                if (ArrayUtils.isEmpty(blockUninstallUserIds)) {
                    returnCode = deletePackageX(packageName, userId, deleteFlags);
                } else {
                    // Otherwise uninstall individually for users with blockUninstalls=false
                    final int userFlags = deleteFlags & ~PackageManager.DELETE_ALL_USERS;
                    for (int userId : users) {
                        if (!ArrayUtils.contains(blockUninstallUserIds, userId)) {
                            returnCode = deletePackageX(packageName, userId, userFlags);
                            if (returnCode != PackageManager.DELETE_SUCCEEDED) {
                                Slog.w(TAG, "Package delete failed for user " + userId + ", returnCode " + returnCode);
                            }
                        }
                    }
                    // The app has only been marked uninstalled for certain users.
                    // We still need to report that delete was blocked
                    returnCode = PackageManager.DELETE_FAILED_OWNER_BLOCKED;
                }
            }
            try {
                observer.onPackageDeleted(packageName, returnCode, null);
            } catch (RemoteException e) {
                Log.i(TAG, "Observer no longer exists.");
            }
        // end catch
        }
    });
}
#end_block

#method_before
private boolean isPackageDeviceAdmin(String packageName, int userId) {
    IDevicePolicyManager dpm = IDevicePolicyManager.Stub.asInterface(ServiceManager.getService(Context.DEVICE_POLICY_SERVICE));
    try {
        if (dpm != null) {
            if (dpm.isDeviceOwner(packageName)) {
                return true;
            }
            int[] users;
            if (userId == UserHandle.USER_ALL) {
                users = sUserManager.getUserIds();
            } else {
                users = new int[] { userId };
            }
            for (int i = 0; i < users.length; ++i) {
                if (dpm.packageHasActiveAdmins(packageName, users[i])) {
                    return true;
                }
            }
        }
    } catch (RemoteException e) {
    }
    return false;
}
#method_after
private boolean isPackageDeviceAdmin(String packageName, int userId) {
    IDevicePolicyManager dpm = IDevicePolicyManager.Stub.asInterface(ServiceManager.getService(Context.DEVICE_POLICY_SERVICE));
    try {
        if (dpm != null) {
            final ComponentName deviceOwnerComponentName = dpm.getDeviceOwnerComponent(/* callingUserOnly =*/
            false);
            final String deviceOwnerPackageName = deviceOwnerComponentName == null ? null : deviceOwnerComponentName.getPackageName();
            // admin on some user too. (Original bug for this: b/17657954)
            if (packageName.equals(deviceOwnerPackageName)) {
                return true;
            }
            // Does it contain a device admin for any user?
            int[] users;
            if (userId == UserHandle.USER_ALL) {
                users = sUserManager.getUserIds();
            } else {
                users = new int[] { userId };
            }
            for (int i = 0; i < users.length; ++i) {
                if (dpm.packageHasActiveAdmins(packageName, users[i])) {
                    return true;
                }
            }
        }
    } catch (RemoteException e) {
    }
    return false;
}
#end_block

#method_before
private int deletePackageX(String packageName, int userId, int flags) {
    final PackageRemovedInfo info = new PackageRemovedInfo();
    final boolean res;
    final UserHandle removeForUser = (flags & PackageManager.DELETE_ALL_USERS) != 0 ? UserHandle.ALL : new UserHandle(userId);
    if (isPackageDeviceAdmin(packageName, removeForUser.getIdentifier())) {
        Slog.w(TAG, "Not removing package " + packageName + ": has active device admin");
        return PackageManager.DELETE_FAILED_DEVICE_POLICY_MANAGER;
    }
    boolean removedForAllUsers = false;
    boolean systemUpdate = false;
    // for the uninstall-updates case and restricted profiles, remember the per-
    // userhandle installed state
    int[] allUsers;
    boolean[] perUserInstalled;
    synchronized (mPackages) {
        PackageSetting ps = mSettings.mPackages.get(packageName);
        allUsers = sUserManager.getUserIds();
        perUserInstalled = new boolean[allUsers.length];
        for (int i = 0; i < allUsers.length; i++) {
            perUserInstalled[i] = ps != null ? ps.getInstalled(allUsers[i]) : false;
        }
    }
    synchronized (mInstallLock) {
        if (DEBUG_REMOVE)
            Slog.d(TAG, "deletePackageX: pkg=" + packageName + " user=" + userId);
        res = deletePackageLI(packageName, removeForUser, true, allUsers, perUserInstalled, flags | REMOVE_CHATTY, info, true);
        systemUpdate = info.isRemovedPackageSystemUpdate;
        if (res && !systemUpdate && mPackages.get(packageName) == null) {
            removedForAllUsers = true;
        }
        if (DEBUG_REMOVE)
            Slog.d(TAG, "delete res: systemUpdate=" + systemUpdate + " removedForAllUsers=" + removedForAllUsers);
    }
    if (res) {
        info.sendBroadcast(true, systemUpdate, removedForAllUsers);
        // was re-enabled; we need to broadcast this information
        if (systemUpdate) {
            Bundle extras = new Bundle(1);
            extras.putInt(Intent.EXTRA_UID, info.removedAppId >= 0 ? info.removedAppId : info.uid);
            extras.putBoolean(Intent.EXTRA_REPLACING, true);
            sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, packageName, extras, null, null, null);
            sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED, packageName, extras, null, null, null);
            sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED, null, null, packageName, null, null);
        }
    }
    // Force a gc here.
    Runtime.getRuntime().gc();
    // other processes clean up before deleting resources.
    if (info.args != null) {
        synchronized (mInstallLock) {
            info.args.doPostDeleteLI(true);
        }
    }
    return res ? PackageManager.DELETE_SUCCEEDED : PackageManager.DELETE_FAILED_INTERNAL_ERROR;
}
#method_after
private int deletePackageX(String packageName, int userId, int deleteFlags) {
    final PackageRemovedInfo info = new PackageRemovedInfo();
    final boolean res;
    final int removeUser = (deleteFlags & PackageManager.DELETE_ALL_USERS) != 0 ? UserHandle.USER_ALL : userId;
    if (isPackageDeviceAdmin(packageName, removeUser)) {
        Slog.w(TAG, "Not removing package " + packageName + ": has active device admin");
        return PackageManager.DELETE_FAILED_DEVICE_POLICY_MANAGER;
    }
    PackageSetting uninstalledPs = null;
    // for the uninstall-updates case and restricted profiles, remember the per-
    // user handle installed state
    int[] allUsers;
    synchronized (mPackages) {
        uninstalledPs = mSettings.mPackages.get(packageName);
        if (uninstalledPs == null) {
            Slog.w(TAG, "Not removing non-existent package " + packageName);
            return PackageManager.DELETE_FAILED_INTERNAL_ERROR;
        }
        allUsers = sUserManager.getUserIds();
        info.origUsers = uninstalledPs.queryInstalledUsers(allUsers, true);
    }
    final int freezeUser;
    if (isUpdatedSystemApp(uninstalledPs) && ((deleteFlags & PackageManager.DELETE_SYSTEM_APP) == 0)) {
        // We're downgrading a system app, which will apply to all users, so
        // freeze them all during the downgrade
        freezeUser = UserHandle.USER_ALL;
    } else {
        freezeUser = removeUser;
    }
    synchronized (mInstallLock) {
        if (DEBUG_REMOVE)
            Slog.d(TAG, "deletePackageX: pkg=" + packageName + " user=" + userId);
        try (PackageFreezer freezer = freezePackageForDelete(packageName, freezeUser, deleteFlags, "deletePackageX")) {
            res = deletePackageLIF(packageName, UserHandle.of(removeUser), true, allUsers, deleteFlags | REMOVE_CHATTY, info, true, null);
        }
        synchronized (mPackages) {
            if (res) {
                mEphemeralApplicationRegistry.onPackageUninstalledLPw(uninstalledPs.pkg);
            }
        }
    }
    if (res) {
        final boolean killApp = (deleteFlags & PackageManager.DELETE_DONT_KILL_APP) == 0;
        info.sendPackageRemovedBroadcasts(killApp);
        info.sendSystemPackageUpdatedBroadcasts();
        info.sendSystemPackageAppearedBroadcasts();
    }
    // Force a gc here.
    Runtime.getRuntime().gc();
    // other processes clean up before deleting resources.
    if (info.args != null) {
        synchronized (mInstallLock) {
            info.args.doPostDeleteLI(true);
        }
    }
    return res ? PackageManager.DELETE_SUCCEEDED : PackageManager.DELETE_FAILED_INTERNAL_ERROR;
}
#end_block

#method_before
static boolean locationIsPrivileged(File path) {
    try {
        final String privilegedAppDir = new File(Environment.getRootDirectory(), "priv-app").getCanonicalPath();
        final String privilegedAppVendorDir = new File(Environment.getVendorDirectory(), "priv-app").getCanonicalPath();
        return (path.getCanonicalPath().startsWith(privilegedAppDir) || path.getCanonicalPath().startsWith(privilegedAppVendorDir));
    } catch (IOException e) {
        Slog.e(TAG, "Unable to access code path " + path);
    }
    return false;
}
#method_after
static boolean locationIsPrivileged(File path) {
    try {
        final String privilegedAppDir = new File(Environment.getRootDirectory(), "priv-app").getCanonicalPath();
        return path.getCanonicalPath().startsWith(privilegedAppDir);
    } catch (IOException e) {
        Slog.e(TAG, "Unable to access code path " + path);
    }
    return false;
}
#end_block

#method_before
private void clearExternalStorageDataSync(String packageName, int userId, boolean allData) {
    final boolean mounted;
    if (Environment.isExternalStorageEmulated()) {
        mounted = true;
    } else {
        final String status = Environment.getExternalStorageState();
        mounted = status.equals(Environment.MEDIA_MOUNTED) || status.equals(Environment.MEDIA_MOUNTED_READ_ONLY);
    }
    if (!mounted) {
        return;
    }
    final Intent containerIntent = new Intent().setComponent(DEFAULT_CONTAINER_COMPONENT);
    int[] users;
    if (userId == UserHandle.USER_ALL) {
        users = sUserManager.getUserIds();
    } else {
        users = new int[] { userId };
    }
    final ClearStorageConnection conn = new ClearStorageConnection();
    if (mContext.bindServiceAsUser(containerIntent, conn, Context.BIND_AUTO_CREATE, UserHandle.OWNER)) {
        try {
            for (int curUser : users) {
                long timeout = SystemClock.uptimeMillis() + 5000;
                synchronized (conn) {
                    long now = SystemClock.uptimeMillis();
                    while (conn.mContainerService == null && now < timeout) {
                        try {
                            conn.wait(timeout - now);
                        } catch (InterruptedException e) {
                        }
                    }
                }
                if (conn.mContainerService == null) {
                    return;
                }
                final UserEnvironment userEnv = new UserEnvironment(curUser);
                clearDirectory(conn.mContainerService, userEnv.buildExternalStorageAppCacheDirs(packageName));
                if (allData) {
                    clearDirectory(conn.mContainerService, userEnv.buildExternalStorageAppDataDirs(packageName));
                    clearDirectory(conn.mContainerService, userEnv.buildExternalStorageAppMediaDirs(packageName));
                }
            }
        } finally {
            mContext.unbindService(conn);
        }
    }
}
#method_after
private void clearExternalStorageDataSync(String packageName, int userId, boolean allData) {
    if (DEFAULT_CONTAINER_PACKAGE.equals(packageName))
        return;
    final boolean mounted;
    if (Environment.isExternalStorageEmulated()) {
        mounted = true;
    } else {
        final String status = Environment.getExternalStorageState();
        mounted = status.equals(Environment.MEDIA_MOUNTED) || status.equals(Environment.MEDIA_MOUNTED_READ_ONLY);
    }
    if (!mounted) {
        return;
    }
    final Intent containerIntent = new Intent().setComponent(DEFAULT_CONTAINER_COMPONENT);
    int[] users;
    if (userId == UserHandle.USER_ALL) {
        users = sUserManager.getUserIds();
    } else {
        users = new int[] { userId };
    }
    final ClearStorageConnection conn = new ClearStorageConnection();
    if (mContext.bindServiceAsUser(containerIntent, conn, Context.BIND_AUTO_CREATE, UserHandle.SYSTEM)) {
        try {
            for (int curUser : users) {
                long timeout = SystemClock.uptimeMillis() + 5000;
                synchronized (conn) {
                    long now;
                    while (conn.mContainerService == null && (now = SystemClock.uptimeMillis()) < timeout) {
                        try {
                            conn.wait(timeout - now);
                        } catch (InterruptedException e) {
                        }
                    }
                }
                if (conn.mContainerService == null) {
                    return;
                }
                final UserEnvironment userEnv = new UserEnvironment(curUser);
                clearDirectory(conn.mContainerService, userEnv.buildExternalStorageAppCacheDirs(packageName));
                if (allData) {
                    clearDirectory(conn.mContainerService, userEnv.buildExternalStorageAppDataDirs(packageName));
                    clearDirectory(conn.mContainerService, userEnv.buildExternalStorageAppMediaDirs(packageName));
                }
            }
        } finally {
            mContext.unbindService(conn);
        }
    }
}
#end_block

#method_before
@Override
public void clearApplicationUserData(final String packageName, final IPackageDataObserver observer, final int userId) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.CLEAR_APP_USER_DATA, null);
    enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "clear application data");
    // Queue up an async operation since the package deletion may take a little while.
    mHandler.post(new Runnable() {

        public void run() {
            mHandler.removeCallbacks(this);
            final boolean succeeded;
            synchronized (mInstallLock) {
                succeeded = clearApplicationUserDataLI(packageName, userId);
            }
            clearExternalStorageDataSync(packageName, userId, true);
            if (succeeded) {
                // invoke DeviceStorageMonitor's update method to clear any notifications
                DeviceStorageMonitorInternal dsm = LocalServices.getService(DeviceStorageMonitorInternal.class);
                if (dsm != null) {
                    dsm.checkMemory();
                }
            }
            if (observer != null) {
                try {
                    observer.onRemoveCompleted(packageName, succeeded);
                } catch (RemoteException e) {
                    Log.i(TAG, "Observer no longer exists.");
                }
            }
        // end if observer
        }
    });
}
#method_after
@Override
public void clearApplicationUserData(final String packageName, final IPackageDataObserver observer, final int userId) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.CLEAR_APP_USER_DATA, null);
    enforceCrossUserPermission(Binder.getCallingUid(), userId, true, /* requireFullPermission */
    false, /* checkShell */
    "clear application data");
    if (mProtectedPackages.canPackageBeWiped(userId, packageName)) {
        throw new SecurityException("Cannot clear data for a device owner or a profile owner");
    }
    // Queue up an async operation since the package deletion may take a little while.
    mHandler.post(new Runnable() {

        public void run() {
            mHandler.removeCallbacks(this);
            final boolean succeeded;
            try (PackageFreezer freezer = freezePackage(packageName, "clearApplicationUserData")) {
                synchronized (mInstallLock) {
                    succeeded = clearApplicationUserDataLIF(packageName, userId);
                }
                clearExternalStorageDataSync(packageName, userId, true);
            }
            if (succeeded) {
                // invoke DeviceStorageMonitor's update method to clear any notifications
                DeviceStorageMonitorInternal dsm = LocalServices.getService(DeviceStorageMonitorInternal.class);
                if (dsm != null) {
                    dsm.checkMemory();
                }
            }
            if (observer != null) {
                try {
                    observer.onRemoveCompleted(packageName, succeeded);
                } catch (RemoteException e) {
                    Log.i(TAG, "Observer no longer exists.");
                }
            }
        // end if observer
        }
    });
}
#end_block

#method_before
private void resetUserChangesToRuntimePermissionsAndFlagsLPw(final PackageSetting ps, final int userId) {
    if (ps.pkg == null) {
        return;
    }
    final int userSettableFlags = FLAG_PERMISSION_USER_SET | FLAG_PERMISSION_USER_FIXED | FLAG_PERMISSION_REVOKE_ON_UPGRADE;
    final int policyOrSystemFlags = FLAG_PERMISSION_SYSTEM_FIXED | FLAG_PERMISSION_POLICY_FIXED;
    boolean writeInstallPermissions = false;
    boolean writeRuntimePermissions = false;
    final int permissionCount = ps.pkg.requestedPermissions.size();
    for (int i = 0; i < permissionCount; i++) {
        String permission = ps.pkg.requestedPermissions.get(i);
        BasePermission bp = mSettings.mPermissions.get(permission);
        if (bp == null) {
            continue;
        }
        // If shared user we just reset the state to which only this app contributed.
        if (ps.sharedUser != null) {
            boolean used = false;
            final int packageCount = ps.sharedUser.packages.size();
            for (int j = 0; j < packageCount; j++) {
                PackageSetting pkg = ps.sharedUser.packages.valueAt(j);
                if (pkg.pkg != null && !pkg.pkg.packageName.equals(ps.pkg.packageName) && pkg.pkg.requestedPermissions.contains(permission)) {
                    used = true;
                    break;
                }
            }
            if (used) {
                continue;
            }
        }
        PermissionsState permissionsState = ps.getPermissionsState();
        final int oldFlags = permissionsState.getPermissionFlags(bp.name, userId);
        // Always clear the user settable flags.
        final boolean hasInstallState = permissionsState.getInstallPermissionState(bp.name) != null;
        if (permissionsState.updatePermissionFlags(bp, userId, userSettableFlags, 0)) {
            if (hasInstallState) {
                writeInstallPermissions = true;
            } else {
                writeRuntimePermissions = true;
            }
        }
        // Below is only runtime permission handling.
        if (!bp.isRuntime()) {
            continue;
        }
        // Never clobber system or policy.
        if ((oldFlags & policyOrSystemFlags) != 0) {
            continue;
        }
        // If this permission was granted by default, make sure it is.
        if ((oldFlags & FLAG_PERMISSION_GRANTED_BY_DEFAULT) != 0) {
            if (permissionsState.grantRuntimePermission(bp, userId) != PERMISSION_OPERATION_FAILURE) {
                writeRuntimePermissions = true;
            }
        } else {
            // Otherwise, reset the permission.
            final int revokeResult = permissionsState.revokeRuntimePermission(bp, userId);
            switch(revokeResult) {
                case PERMISSION_OPERATION_SUCCESS:
                    {
                        writeRuntimePermissions = true;
                    }
                    break;
                case PERMISSION_OPERATION_SUCCESS_GIDS_CHANGED:
                    {
                        writeRuntimePermissions = true;
                        final int appId = ps.appId;
                        mHandler.post(new Runnable() {

                            @Override
                            public void run() {
                                killUid(appId, userId, KILL_APP_REASON_GIDS_CHANGED);
                            }
                        });
                    }
                    break;
            }
        }
    }
    // Synchronously write as we are taking permissions away.
    if (writeRuntimePermissions) {
        mSettings.writeRuntimePermissionsForUserLPr(userId, true);
    }
    // Synchronously write as we are taking permissions away.
    if (writeInstallPermissions) {
        mSettings.writeLPr();
    }
}
#method_after
private void resetUserChangesToRuntimePermissionsAndFlagsLPw(final PackageSetting ps, final int userId) {
    if (ps.pkg == null) {
        return;
    }
    // These are flags that can change base on user actions.
    final int userSettableMask = FLAG_PERMISSION_USER_SET | FLAG_PERMISSION_USER_FIXED | FLAG_PERMISSION_REVOKE_ON_UPGRADE | FLAG_PERMISSION_REVIEW_REQUIRED;
    final int policyOrSystemFlags = FLAG_PERMISSION_SYSTEM_FIXED | FLAG_PERMISSION_POLICY_FIXED;
    boolean writeInstallPermissions = false;
    boolean writeRuntimePermissions = false;
    final int permissionCount = ps.pkg.requestedPermissions.size();
    for (int i = 0; i < permissionCount; i++) {
        String permission = ps.pkg.requestedPermissions.get(i);
        BasePermission bp = mSettings.mPermissions.get(permission);
        if (bp == null) {
            continue;
        }
        // If shared user we just reset the state to which only this app contributed.
        if (ps.sharedUser != null) {
            boolean used = false;
            final int packageCount = ps.sharedUser.packages.size();
            for (int j = 0; j < packageCount; j++) {
                PackageSetting pkg = ps.sharedUser.packages.valueAt(j);
                if (pkg.pkg != null && !pkg.pkg.packageName.equals(ps.pkg.packageName) && pkg.pkg.requestedPermissions.contains(permission)) {
                    used = true;
                    break;
                }
            }
            if (used) {
                continue;
            }
        }
        PermissionsState permissionsState = ps.getPermissionsState();
        final int oldFlags = permissionsState.getPermissionFlags(bp.name, userId);
        // Always clear the user settable flags.
        final boolean hasInstallState = permissionsState.getInstallPermissionState(bp.name) != null;
        // If permission review is enabled and this is a legacy app, mark the
        // permission as requiring a review as this is the initial state.
        int flags = 0;
        if (Build.PERMISSIONS_REVIEW_REQUIRED && ps.pkg.applicationInfo.targetSdkVersion < Build.VERSION_CODES.M) {
            flags |= FLAG_PERMISSION_REVIEW_REQUIRED;
        }
        if (permissionsState.updatePermissionFlags(bp, userId, userSettableMask, flags)) {
            if (hasInstallState) {
                writeInstallPermissions = true;
            } else {
                writeRuntimePermissions = true;
            }
        }
        // Below is only runtime permission handling.
        if (!bp.isRuntime()) {
            continue;
        }
        // Never clobber system or policy.
        if ((oldFlags & policyOrSystemFlags) != 0) {
            continue;
        }
        // If this permission was granted by default, make sure it is.
        if ((oldFlags & FLAG_PERMISSION_GRANTED_BY_DEFAULT) != 0) {
            if (permissionsState.grantRuntimePermission(bp, userId) != PERMISSION_OPERATION_FAILURE) {
                writeRuntimePermissions = true;
            }
        // If permission review is enabled the permissions for a legacy apps
        // are represented as constantly granted runtime ones, so don't revoke.
        } else if ((flags & FLAG_PERMISSION_REVIEW_REQUIRED) == 0) {
            // Otherwise, reset the permission.
            final int revokeResult = permissionsState.revokeRuntimePermission(bp, userId);
            switch(revokeResult) {
                case PERMISSION_OPERATION_SUCCESS:
                case PERMISSION_OPERATION_SUCCESS_GIDS_CHANGED:
                    {
                        writeRuntimePermissions = true;
                        final int appId = ps.appId;
                        mHandler.post(new Runnable() {

                            @Override
                            public void run() {
                                killUid(appId, userId, KILL_APP_REASON_PERMISSIONS_REVOKED);
                            }
                        });
                    }
                    break;
            }
        }
    }
    // Synchronously write as we are taking permissions away.
    if (writeRuntimePermissions) {
        mSettings.writeRuntimePermissionsForUserLPr(userId, true);
    }
    // Synchronously write as we are taking permissions away.
    if (writeInstallPermissions) {
        mSettings.writeLPr();
    }
}
#end_block

#method_before
@Override
public void deleteApplicationCacheFiles(final String packageName, final IPackageDataObserver observer) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.DELETE_CACHE_FILES, null);
    // Queue up an async operation since the package deletion may take a little while.
    final int userId = UserHandle.getCallingUserId();
    mHandler.post(new Runnable() {

        public void run() {
            mHandler.removeCallbacks(this);
            final boolean succeded;
            synchronized (mInstallLock) {
                succeded = deleteApplicationCacheFilesLI(packageName, userId);
            }
            clearExternalStorageDataSync(packageName, userId, false);
            if (observer != null) {
                try {
                    observer.onRemoveCompleted(packageName, succeded);
                } catch (RemoteException e) {
                    Log.i(TAG, "Observer no longer exists.");
                }
            }
        // end if observer
        }
    });
}
#method_after
@Override
public void deleteApplicationCacheFiles(final String packageName, final IPackageDataObserver observer) {
    final int userId = UserHandle.getCallingUserId();
    deleteApplicationCacheFilesAsUser(packageName, userId, observer);
}
#end_block

#method_before
private boolean getPackageSizeInfoLI(String packageName, int userHandle, PackageStats pStats) {
    if (packageName == null) {
        Slog.w(TAG, "Attempt to get size of null packageName.");
        return false;
    }
    PackageParser.Package p;
    boolean dataOnly = false;
    String libDirRoot = null;
    String asecPath = null;
    PackageSetting ps = null;
    synchronized (mPackages) {
        p = mPackages.get(packageName);
        ps = mSettings.mPackages.get(packageName);
        if (p == null) {
            dataOnly = true;
            if ((ps == null) || (ps.pkg == null)) {
                Slog.w(TAG, "Package named '" + packageName + "' doesn't exist.");
                return false;
            }
            p = ps.pkg;
        }
        if (ps != null) {
            libDirRoot = ps.legacyNativeLibraryPathString;
        }
        if (p != null && (p.isForwardLocked() || p.applicationInfo.isExternalAsec())) {
            final long token = Binder.clearCallingIdentity();
            try {
                String secureContainerId = cidFromCodePath(p.applicationInfo.getBaseCodePath());
                if (secureContainerId != null) {
                    asecPath = PackageHelper.getSdFilesystem(secureContainerId);
                }
            } finally {
                Binder.restoreCallingIdentity(token);
            }
        }
    }
    String publicSrcDir = null;
    if (!dataOnly) {
        final ApplicationInfo applicationInfo = p.applicationInfo;
        if (applicationInfo == null) {
            Slog.w(TAG, "Package " + packageName + " has no applicationInfo.");
            return false;
        }
        if (p.isForwardLocked()) {
            publicSrcDir = applicationInfo.getBaseResourcePath();
        }
    }
    // TODO: extend to measure size of split APKs
    // TODO(multiArch): Extend getSizeInfo to look at the full subdirectory tree,
    // not just the first level.
    // TODO(multiArch): Extend getSizeInfo to look at *all* instruction sets, not
    // just the primary.
    String[] dexCodeInstructionSets = getDexCodeInstructionSets(getAppDexInstructionSets(ps));
    String apkPath;
    File packageDir = new File(p.codePath);
    if (packageDir.isDirectory() && p.canHaveOatDir()) {
        apkPath = packageDir.getAbsolutePath();
        // If libDirRoot is inside a package dir, set it to null to avoid it being counted twice
        if (libDirRoot != null && libDirRoot.startsWith(apkPath)) {
            libDirRoot = null;
        }
    } else {
        apkPath = p.baseCodePath;
    }
    int res = mInstaller.getSizeInfo(p.volumeUuid, packageName, userHandle, apkPath, libDirRoot, publicSrcDir, asecPath, dexCodeInstructionSets, pStats);
    if (res < 0) {
        return false;
    }
    // Fix-up for forward-locked applications in ASEC containers.
    if (!isExternal(p)) {
        pStats.codeSize += pStats.externalCodeSize;
        pStats.externalCodeSize = 0L;
    }
    return true;
}
#method_after
private boolean getPackageSizeInfoLI(String packageName, int userId, PackageStats stats) {
    final PackageSetting ps;
    synchronized (mPackages) {
        ps = mSettings.mPackages.get(packageName);
        if (ps == null) {
            Slog.w(TAG, "Failed to find settings for " + packageName);
            return false;
        }
    }
    try {
        mInstaller.getAppSize(ps.volumeUuid, packageName, userId, StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE, ps.getCeDataInode(userId), ps.codePathString, stats);
    } catch (InstallerException e) {
        Slog.w(TAG, String.valueOf(e));
        return false;
    }
    // For now, ignore code size of packages on system partition
    if (isSystemApp(ps) && !isUpdatedSystemApp(ps)) {
        stats.codeSize = 0;
    }
    return true;
}
#end_block

#method_before
private void addPreferredActivityInternal(IntentFilter filter, int match, ComponentName[] set, ComponentName activity, boolean always, int userId, String opname) {
    // writer
    int callingUid = Binder.getCallingUid();
    enforceCrossUserPermission(callingUid, userId, true, false, "add preferred activity");
    if (filter.countActions() == 0) {
        Slog.w(TAG, "Cannot set a preferred activity with no filter actions");
        return;
    }
    synchronized (mPackages) {
        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.SET_PREFERRED_APPLICATIONS) != PackageManager.PERMISSION_GRANTED) {
            if (getUidTargetSdkVersionLockedLPr(callingUid) < Build.VERSION_CODES.FROYO) {
                Slog.w(TAG, "Ignoring addPreferredActivity() from uid " + callingUid);
                return;
            }
            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.SET_PREFERRED_APPLICATIONS, null);
        }
        PreferredIntentResolver pir = mSettings.editPreferredActivitiesLPw(userId);
        Slog.i(TAG, opname + " activity " + activity.flattenToShortString() + " for user " + userId + ":");
        filter.dump(new LogPrinter(Log.INFO, TAG), "  ");
        pir.addFilter(new PreferredActivity(filter, match, set, activity, always));
        scheduleWritePackageRestrictionsLocked(userId);
    }
}
#method_after
private void addPreferredActivityInternal(IntentFilter filter, int match, ComponentName[] set, ComponentName activity, boolean always, int userId, String opname) {
    // writer
    int callingUid = Binder.getCallingUid();
    enforceCrossUserPermission(callingUid, userId, true, /* requireFullPermission */
    false, /* checkShell */
    "add preferred activity");
    if (filter.countActions() == 0) {
        Slog.w(TAG, "Cannot set a preferred activity with no filter actions");
        return;
    }
    synchronized (mPackages) {
        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.SET_PREFERRED_APPLICATIONS) != PackageManager.PERMISSION_GRANTED) {
            if (getUidTargetSdkVersionLockedLPr(callingUid) < Build.VERSION_CODES.FROYO) {
                Slog.w(TAG, "Ignoring addPreferredActivity() from uid " + callingUid);
                return;
            }
            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.SET_PREFERRED_APPLICATIONS, null);
        }
        PreferredIntentResolver pir = mSettings.editPreferredActivitiesLPw(userId);
        Slog.i(TAG, opname + " activity " + activity.flattenToShortString() + " for user " + userId + ":");
        filter.dump(new LogPrinter(Log.INFO, TAG), "  ");
        pir.addFilter(new PreferredActivity(filter, match, set, activity, always));
        scheduleWritePackageRestrictionsLocked(userId);
    }
}
#end_block

#method_before
@Override
public void replacePreferredActivity(IntentFilter filter, int match, ComponentName[] set, ComponentName activity, int userId) {
    if (filter.countActions() != 1) {
        throw new IllegalArgumentException("replacePreferredActivity expects filter to have only 1 action.");
    }
    if (filter.countDataAuthorities() != 0 || filter.countDataPaths() != 0 || filter.countDataSchemes() > 1 || filter.countDataTypes() != 0) {
        throw new IllegalArgumentException("replacePreferredActivity expects filter to have no data authorities, " + "paths, or types; and at most one scheme.");
    }
    final int callingUid = Binder.getCallingUid();
    enforceCrossUserPermission(callingUid, userId, true, false, "replace preferred activity");
    synchronized (mPackages) {
        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.SET_PREFERRED_APPLICATIONS) != PackageManager.PERMISSION_GRANTED) {
            if (getUidTargetSdkVersionLockedLPr(callingUid) < Build.VERSION_CODES.FROYO) {
                Slog.w(TAG, "Ignoring replacePreferredActivity() from uid " + Binder.getCallingUid());
                return;
            }
            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.SET_PREFERRED_APPLICATIONS, null);
        }
        PreferredIntentResolver pir = mSettings.mPreferredActivities.get(userId);
        if (pir != null) {
            // Get all of the existing entries that exactly match this filter.
            ArrayList<PreferredActivity> existing = pir.findFilters(filter);
            if (existing != null && existing.size() == 1) {
                PreferredActivity cur = existing.get(0);
                if (DEBUG_PREFERRED) {
                    Slog.i(TAG, "Checking replace of preferred:");
                    filter.dump(new LogPrinter(Log.INFO, TAG), "  ");
                    if (!cur.mPref.mAlways) {
                        Slog.i(TAG, "  -- CUR; not mAlways!");
                    } else {
                        Slog.i(TAG, "  -- CUR: mMatch=" + cur.mPref.mMatch);
                        Slog.i(TAG, "  -- CUR: mSet=" + Arrays.toString(cur.mPref.mSetComponents));
                        Slog.i(TAG, "  -- CUR: mComponent=" + cur.mPref.mShortComponent);
                        Slog.i(TAG, "  -- NEW: mMatch=" + (match & IntentFilter.MATCH_CATEGORY_MASK));
                        Slog.i(TAG, "  -- CUR: mSet=" + Arrays.toString(set));
                        Slog.i(TAG, "  -- CUR: mComponent=" + activity.flattenToShortString());
                    }
                }
                if (cur.mPref.mAlways && cur.mPref.mComponent.equals(activity) && cur.mPref.mMatch == (match & IntentFilter.MATCH_CATEGORY_MASK) && cur.mPref.sameSet(set)) {
                    // Setting the preferred activity to what it happens to be already
                    if (DEBUG_PREFERRED) {
                        Slog.i(TAG, "Replacing with same preferred activity " + cur.mPref.mShortComponent + " for user " + userId + ":");
                        filter.dump(new LogPrinter(Log.INFO, TAG), "  ");
                    }
                    return;
                }
            }
            if (existing != null) {
                if (DEBUG_PREFERRED) {
                    Slog.i(TAG, existing.size() + " existing preferred matches for:");
                    filter.dump(new LogPrinter(Log.INFO, TAG), "  ");
                }
                for (int i = 0; i < existing.size(); i++) {
                    PreferredActivity pa = existing.get(i);
                    if (DEBUG_PREFERRED) {
                        Slog.i(TAG, "Removing existing preferred activity " + pa.mPref.mComponent + ":");
                        pa.dump(new LogPrinter(Log.INFO, TAG), "  ");
                    }
                    pir.removeFilter(pa);
                }
            }
        }
        addPreferredActivityInternal(filter, match, set, activity, true, userId, "Replacing preferred");
    }
}
#method_after
@Override
public void replacePreferredActivity(IntentFilter filter, int match, ComponentName[] set, ComponentName activity, int userId) {
    if (filter.countActions() != 1) {
        throw new IllegalArgumentException("replacePreferredActivity expects filter to have only 1 action.");
    }
    if (filter.countDataAuthorities() != 0 || filter.countDataPaths() != 0 || filter.countDataSchemes() > 1 || filter.countDataTypes() != 0) {
        throw new IllegalArgumentException("replacePreferredActivity expects filter to have no data authorities, " + "paths, or types; and at most one scheme.");
    }
    final int callingUid = Binder.getCallingUid();
    enforceCrossUserPermission(callingUid, userId, true, /* requireFullPermission */
    false, /* checkShell */
    "replace preferred activity");
    synchronized (mPackages) {
        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.SET_PREFERRED_APPLICATIONS) != PackageManager.PERMISSION_GRANTED) {
            if (getUidTargetSdkVersionLockedLPr(callingUid) < Build.VERSION_CODES.FROYO) {
                Slog.w(TAG, "Ignoring replacePreferredActivity() from uid " + Binder.getCallingUid());
                return;
            }
            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.SET_PREFERRED_APPLICATIONS, null);
        }
        PreferredIntentResolver pir = mSettings.mPreferredActivities.get(userId);
        if (pir != null) {
            // Get all of the existing entries that exactly match this filter.
            ArrayList<PreferredActivity> existing = pir.findFilters(filter);
            if (existing != null && existing.size() == 1) {
                PreferredActivity cur = existing.get(0);
                if (DEBUG_PREFERRED) {
                    Slog.i(TAG, "Checking replace of preferred:");
                    filter.dump(new LogPrinter(Log.INFO, TAG), "  ");
                    if (!cur.mPref.mAlways) {
                        Slog.i(TAG, "  -- CUR; not mAlways!");
                    } else {
                        Slog.i(TAG, "  -- CUR: mMatch=" + cur.mPref.mMatch);
                        Slog.i(TAG, "  -- CUR: mSet=" + Arrays.toString(cur.mPref.mSetComponents));
                        Slog.i(TAG, "  -- CUR: mComponent=" + cur.mPref.mShortComponent);
                        Slog.i(TAG, "  -- NEW: mMatch=" + (match & IntentFilter.MATCH_CATEGORY_MASK));
                        Slog.i(TAG, "  -- CUR: mSet=" + Arrays.toString(set));
                        Slog.i(TAG, "  -- CUR: mComponent=" + activity.flattenToShortString());
                    }
                }
                if (cur.mPref.mAlways && cur.mPref.mComponent.equals(activity) && cur.mPref.mMatch == (match & IntentFilter.MATCH_CATEGORY_MASK) && cur.mPref.sameSet(set)) {
                    // Setting the preferred activity to what it happens to be already
                    if (DEBUG_PREFERRED) {
                        Slog.i(TAG, "Replacing with same preferred activity " + cur.mPref.mShortComponent + " for user " + userId + ":");
                        filter.dump(new LogPrinter(Log.INFO, TAG), "  ");
                    }
                    return;
                }
            }
            if (existing != null) {
                if (DEBUG_PREFERRED) {
                    Slog.i(TAG, existing.size() + " existing preferred matches for:");
                    filter.dump(new LogPrinter(Log.INFO, TAG), "  ");
                }
                for (int i = 0; i < existing.size(); i++) {
                    PreferredActivity pa = existing.get(i);
                    if (DEBUG_PREFERRED) {
                        Slog.i(TAG, "Removing existing preferred activity " + pa.mPref.mComponent + ":");
                        pa.dump(new LogPrinter(Log.INFO, TAG), "  ");
                    }
                    pir.removeFilter(pa);
                }
            }
        }
        addPreferredActivityInternal(filter, match, set, activity, true, userId, "Replacing preferred");
    }
}
#end_block

#method_before
@Override
public void resetApplicationPreferences(int userId) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.SET_PREFERRED_APPLICATIONS, null);
    // writer
    synchronized (mPackages) {
        final long identity = Binder.clearCallingIdentity();
        try {
            clearPackagePreferredActivitiesLPw(null, userId);
            mSettings.applyDefaultPreferredAppsLPw(this, userId);
            // TODO: We have to reset the default SMS and Phone. This requires
            // significant refactoring to keep all default apps in the package
            // manager (cleaner but more work) or have the services provide
            // callbacks to the package manager to request a default app reset.
            applyFactoryDefaultBrowserLPw(userId);
            clearIntentFilterVerificationsLPw(userId);
            primeDomainVerificationsLPw(userId);
            resetUserChangesToRuntimePermissionsAndFlagsLPw(userId);
            scheduleWritePackageRestrictionsLocked(userId);
        } finally {
            Binder.restoreCallingIdentity(identity);
        }
    }
}
#method_after
@Override
public void resetApplicationPreferences(int userId) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.SET_PREFERRED_APPLICATIONS, null);
    final long identity = Binder.clearCallingIdentity();
    // writer
    try {
        synchronized (mPackages) {
            clearPackagePreferredActivitiesLPw(null, userId);
            mSettings.applyDefaultPreferredAppsLPw(this, userId);
            // TODO: We have to reset the default SMS and Phone. This requires
            // significant refactoring to keep all default apps in the package
            // manager (cleaner but more work) or have the services provide
            // callbacks to the package manager to request a default app reset.
            applyFactoryDefaultBrowserLPw(userId);
            clearIntentFilterVerificationsLPw(userId);
            primeDomainVerificationsLPw(userId);
            resetUserChangesToRuntimePermissionsAndFlagsLPw(userId);
            scheduleWritePackageRestrictionsLocked(userId);
        }
        resetNetworkPolicies(userId);
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
}
#end_block

#method_before
@Override
public void addPersistentPreferredActivity(IntentFilter filter, ComponentName activity, int userId) {
    int callingUid = Binder.getCallingUid();
    if (callingUid != Process.SYSTEM_UID) {
        throw new SecurityException("addPersistentPreferredActivity can only be run by the system");
    }
    if (filter.countActions() == 0) {
        Slog.w(TAG, "Cannot set a preferred activity with no filter actions");
        return;
    }
    synchronized (mPackages) {
        Slog.i(TAG, "Adding persistent preferred activity " + activity + " for user " + userId + " :");
        filter.dump(new LogPrinter(Log.INFO, TAG), "  ");
        mSettings.editPersistentPreferredActivitiesLPw(userId).addFilter(new PersistentPreferredActivity(filter, activity));
        scheduleWritePackageRestrictionsLocked(userId);
    }
}
#method_after
@Override
public void addPersistentPreferredActivity(IntentFilter filter, ComponentName activity, int userId) {
    int callingUid = Binder.getCallingUid();
    if (callingUid != Process.SYSTEM_UID) {
        throw new SecurityException("addPersistentPreferredActivity can only be run by the system");
    }
    if (filter.countActions() == 0) {
        Slog.w(TAG, "Cannot set a preferred activity with no filter actions");
        return;
    }
    synchronized (mPackages) {
        Slog.i(TAG, "Adding persistent preferred activity " + activity + " for user " + userId + ":");
        filter.dump(new LogPrinter(Log.INFO, TAG), "  ");
        mSettings.editPersistentPreferredActivitiesLPw(userId).addFilter(new PersistentPreferredActivity(filter, activity));
        scheduleWritePackageRestrictionsLocked(userId);
    }
}
#end_block

#method_before
private void restoreFromXml(XmlPullParser parser, int userId, String expectedStartTag, BlobXmlRestorer functor) throws IOException, XmlPullParserException {
    int type;
    while ((type = parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
    }
    if (type != XmlPullParser.START_TAG) {
        // oops didn't find a start tag?!
        if (DEBUG_BACKUP) {
            Slog.e(TAG, "Didn't find start tag during restore");
        }
        return;
    }
    // this is supposed to be TAG_PREFERRED_BACKUP
    if (!expectedStartTag.equals(parser.getName())) {
        if (DEBUG_BACKUP) {
            Slog.e(TAG, "Found unexpected tag " + parser.getName());
        }
        return;
    }
    // skip interfering stuff, then we're aligned with the backing implementation
    while ((type = parser.next()) == XmlPullParser.TEXT) {
    }
    functor.apply(parser, userId);
}
#method_after
private void restoreFromXml(XmlPullParser parser, int userId, String expectedStartTag, BlobXmlRestorer functor) throws IOException, XmlPullParserException {
    int type;
    while ((type = parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
    }
    if (type != XmlPullParser.START_TAG) {
        // oops didn't find a start tag?!
        if (DEBUG_BACKUP) {
            Slog.e(TAG, "Didn't find start tag during restore");
        }
        return;
    }
    Slog.v(TAG, ":: restoreFromXml() : got to tag " + parser.getName());
    // this is supposed to be TAG_PREFERRED_BACKUP
    if (!expectedStartTag.equals(parser.getName())) {
        if (DEBUG_BACKUP) {
            Slog.e(TAG, "Found unexpected tag " + parser.getName());
        }
        return;
    }
    // skip interfering stuff, then we're aligned with the backing implementation
    while ((type = parser.next()) == XmlPullParser.TEXT) {
    }
    Slog.v(TAG, ":: stepped forward, applying functor at tag " + parser.getName());
    functor.apply(parser, userId);
}
#end_block

#method_before
@Override
public ComponentName getHomeActivities(List<ResolveInfo> allHomeCandidates) {
    Intent intent = new Intent(Intent.ACTION_MAIN);
    intent.addCategory(Intent.CATEGORY_HOME);
    final int callingUserId = UserHandle.getCallingUserId();
    List<ResolveInfo> list = queryIntentActivities(intent, null, PackageManager.GET_META_DATA, callingUserId);
    ResolveInfo preferred = findPreferredActivity(intent, null, 0, list, 0, true, false, false, callingUserId);
    allHomeCandidates.clear();
    if (list != null) {
        for (ResolveInfo ri : list) {
            allHomeCandidates.add(ri);
        }
    }
    return (preferred == null || preferred.activityInfo == null) ? null : new ComponentName(preferred.activityInfo.packageName, preferred.activityInfo.name);
}
#method_after
@Override
public ComponentName getHomeActivities(List<ResolveInfo> allHomeCandidates) {
    return getHomeActivitiesAsUser(allHomeCandidates, UserHandle.getCallingUserId());
}
#end_block

#method_before
private void setEnabledSetting(final String packageName, String className, int newState, final int flags, int userId, String callingPackage) {
    if (!(newState == COMPONENT_ENABLED_STATE_DEFAULT || newState == COMPONENT_ENABLED_STATE_ENABLED || newState == COMPONENT_ENABLED_STATE_DISABLED || newState == COMPONENT_ENABLED_STATE_DISABLED_USER || newState == COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED)) {
        throw new IllegalArgumentException("Invalid new component state: " + newState);
    }
    PackageSetting pkgSetting;
    final int uid = Binder.getCallingUid();
    final int permission = mContext.checkCallingOrSelfPermission(android.Manifest.permission.CHANGE_COMPONENT_ENABLED_STATE);
    enforceCrossUserPermission(uid, userId, false, true, "set enabled");
    final boolean allowedByPermission = (permission == PackageManager.PERMISSION_GRANTED);
    boolean sendNow = false;
    boolean isApp = (className == null);
    String componentName = isApp ? packageName : className;
    int packageUid = -1;
    ArrayList<String> components;
    // writer
    synchronized (mPackages) {
        pkgSetting = mSettings.mPackages.get(packageName);
        if (pkgSetting == null) {
            if (className == null) {
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
            throw new IllegalArgumentException("Unknown component: " + packageName + "/" + className);
        }
        // Allow root and verify that userId is not being specified by a different user
        if (!allowedByPermission && !UserHandle.isSameApp(uid, pkgSetting.appId)) {
            throw new SecurityException("Permission Denial: attempt to change component state from pid=" + Binder.getCallingPid() + ", uid=" + uid + ", package uid=" + pkgSetting.appId);
        }
        if (className == null) {
            // We're dealing with an application/package level state change
            if (pkgSetting.getEnabled(userId) == newState) {
                // Nothing to do
                return;
            }
            if (newState == PackageManager.COMPONENT_ENABLED_STATE_DEFAULT || newState == PackageManager.COMPONENT_ENABLED_STATE_ENABLED) {
                // Don't care about who enables an app.
                callingPackage = null;
            }
            pkgSetting.setEnabled(newState, userId, callingPackage);
        // pkgSetting.pkg.mSetEnabled = newState;
        } else {
            // We're dealing with a component level state change
            // First, verify that this is a valid class name.
            PackageParser.Package pkg = pkgSetting.pkg;
            if (pkg == null || !pkg.hasComponentClassName(className)) {
                if (pkg.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.JELLY_BEAN) {
                    throw new IllegalArgumentException("Component class " + className + " does not exist in " + packageName);
                } else {
                    Slog.w(TAG, "Failed setComponentEnabledSetting: component class " + className + " does not exist in " + packageName);
                }
            }
            switch(newState) {
                case COMPONENT_ENABLED_STATE_ENABLED:
                    if (!pkgSetting.enableComponentLPw(className, userId)) {
                        return;
                    }
                    break;
                case COMPONENT_ENABLED_STATE_DISABLED:
                    if (!pkgSetting.disableComponentLPw(className, userId)) {
                        return;
                    }
                    break;
                case COMPONENT_ENABLED_STATE_DEFAULT:
                    if (!pkgSetting.restoreComponentLPw(className, userId)) {
                        return;
                    }
                    break;
                default:
                    Slog.e(TAG, "Invalid new component state: " + newState);
                    return;
            }
        }
        scheduleWritePackageRestrictionsLocked(userId);
        components = mPendingBroadcasts.get(userId, packageName);
        final boolean newPackage = components == null;
        if (newPackage) {
            components = new ArrayList<String>();
        }
        if (!components.contains(componentName)) {
            components.add(componentName);
        }
        if ((flags & PackageManager.DONT_KILL_APP) == 0) {
            sendNow = true;
            // Purge entry from pending broadcast list if another one exists already
            // since we are sending one right away.
            mPendingBroadcasts.remove(userId, packageName);
        } else {
            if (newPackage) {
                mPendingBroadcasts.put(userId, packageName, components);
            }
            if (!mHandler.hasMessages(SEND_PENDING_BROADCAST)) {
                // Schedule a message
                mHandler.sendEmptyMessageDelayed(SEND_PENDING_BROADCAST, BROADCAST_DELAY);
            }
        }
    }
    long callingId = Binder.clearCallingIdentity();
    try {
        if (sendNow) {
            packageUid = UserHandle.getUid(userId, pkgSetting.appId);
            sendPackageChangedBroadcast(packageName, (flags & PackageManager.DONT_KILL_APP) != 0, components, packageUid);
        }
    } finally {
        Binder.restoreCallingIdentity(callingId);
    }
}
#method_after
private void setEnabledSetting(final String packageName, String className, int newState, final int flags, int userId, String callingPackage) {
    if (!(newState == COMPONENT_ENABLED_STATE_DEFAULT || newState == COMPONENT_ENABLED_STATE_ENABLED || newState == COMPONENT_ENABLED_STATE_DISABLED || newState == COMPONENT_ENABLED_STATE_DISABLED_USER || newState == COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED)) {
        throw new IllegalArgumentException("Invalid new component state: " + newState);
    }
    PackageSetting pkgSetting;
    final int uid = Binder.getCallingUid();
    final int permission;
    if (uid == Process.SYSTEM_UID) {
        permission = PackageManager.PERMISSION_GRANTED;
    } else {
        permission = mContext.checkCallingOrSelfPermission(android.Manifest.permission.CHANGE_COMPONENT_ENABLED_STATE);
    }
    enforceCrossUserPermission(uid, userId, false, /* requireFullPermission */
    true, /* checkShell */
    "set enabled");
    final boolean allowedByPermission = (permission == PackageManager.PERMISSION_GRANTED);
    boolean sendNow = false;
    boolean isApp = (className == null);
    String componentName = isApp ? packageName : className;
    int packageUid = -1;
    ArrayList<String> components;
    // writer
    synchronized (mPackages) {
        pkgSetting = mSettings.mPackages.get(packageName);
        if (pkgSetting == null) {
            if (className == null) {
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
            throw new IllegalArgumentException("Unknown component: " + packageName + "/" + className);
        }
    }
    // Limit who can change which apps
    if (!UserHandle.isSameApp(uid, pkgSetting.appId)) {
        // Don't allow apps that don't have permission to modify other apps
        if (!allowedByPermission) {
            throw new SecurityException("Permission Denial: attempt to change component state from pid=" + Binder.getCallingPid() + ", uid=" + uid + ", package uid=" + pkgSetting.appId);
        }
        // Don't allow changing profile and device owners.
        if (mProtectedPackages.canPackageStateBeChanged(userId, packageName)) {
            throw new SecurityException("Cannot disable a device owner or a profile owner");
        }
    }
    synchronized (mPackages) {
        if (uid == Process.SHELL_UID) {
            // Shell can only change whole packages between ENABLED and DISABLED_USER states
            int oldState = pkgSetting.getEnabled(userId);
            if (className == null && (oldState == COMPONENT_ENABLED_STATE_DISABLED_USER || oldState == COMPONENT_ENABLED_STATE_DEFAULT || oldState == COMPONENT_ENABLED_STATE_ENABLED) && (newState == COMPONENT_ENABLED_STATE_DISABLED_USER || newState == COMPONENT_ENABLED_STATE_DEFAULT || newState == COMPONENT_ENABLED_STATE_ENABLED)) {
            // ok
            } else {
                throw new SecurityException("Shell cannot change component state for " + packageName + "/" + className + " to " + newState);
            }
        }
        if (className == null) {
            // We're dealing with an application/package level state change
            if (pkgSetting.getEnabled(userId) == newState) {
                // Nothing to do
                return;
            }
            if (newState == PackageManager.COMPONENT_ENABLED_STATE_DEFAULT || newState == PackageManager.COMPONENT_ENABLED_STATE_ENABLED) {
                // Don't care about who enables an app.
                callingPackage = null;
            }
            pkgSetting.setEnabled(newState, userId, callingPackage);
        // pkgSetting.pkg.mSetEnabled = newState;
        } else {
            // We're dealing with a component level state change
            // First, verify that this is a valid class name.
            PackageParser.Package pkg = pkgSetting.pkg;
            if (pkg == null || !pkg.hasComponentClassName(className)) {
                if (pkg != null && pkg.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.JELLY_BEAN) {
                    throw new IllegalArgumentException("Component class " + className + " does not exist in " + packageName);
                } else {
                    Slog.w(TAG, "Failed setComponentEnabledSetting: component class " + className + " does not exist in " + packageName);
                }
            }
            switch(newState) {
                case COMPONENT_ENABLED_STATE_ENABLED:
                    if (!pkgSetting.enableComponentLPw(className, userId)) {
                        return;
                    }
                    break;
                case COMPONENT_ENABLED_STATE_DISABLED:
                    if (!pkgSetting.disableComponentLPw(className, userId)) {
                        return;
                    }
                    break;
                case COMPONENT_ENABLED_STATE_DEFAULT:
                    if (!pkgSetting.restoreComponentLPw(className, userId)) {
                        return;
                    }
                    break;
                default:
                    Slog.e(TAG, "Invalid new component state: " + newState);
                    return;
            }
        }
        scheduleWritePackageRestrictionsLocked(userId);
        components = mPendingBroadcasts.get(userId, packageName);
        final boolean newPackage = components == null;
        if (newPackage) {
            components = new ArrayList<String>();
        }
        if (!components.contains(componentName)) {
            components.add(componentName);
        }
        if ((flags & PackageManager.DONT_KILL_APP) == 0) {
            sendNow = true;
            // Purge entry from pending broadcast list if another one exists already
            // since we are sending one right away.
            mPendingBroadcasts.remove(userId, packageName);
        } else {
            if (newPackage) {
                mPendingBroadcasts.put(userId, packageName, components);
            }
            if (!mHandler.hasMessages(SEND_PENDING_BROADCAST)) {
                // Schedule a message
                mHandler.sendEmptyMessageDelayed(SEND_PENDING_BROADCAST, BROADCAST_DELAY);
            }
        }
    }
    long callingId = Binder.clearCallingIdentity();
    try {
        if (sendNow) {
            packageUid = UserHandle.getUid(userId, pkgSetting.appId);
            sendPackageChangedBroadcast(packageName, (flags & PackageManager.DONT_KILL_APP) != 0, components, packageUid);
        }
    } finally {
        Binder.restoreCallingIdentity(callingId);
    }
}
#end_block

#method_before
private void sendPackageChangedBroadcast(String packageName, boolean killFlag, ArrayList<String> componentNames, int packageUid) {
    if (DEBUG_INSTALL)
        Log.v(TAG, "Sending package changed: package=" + packageName + " components=" + componentNames);
    Bundle extras = new Bundle(4);
    extras.putString(Intent.EXTRA_CHANGED_COMPONENT_NAME, componentNames.get(0));
    String[] nameList = new String[componentNames.size()];
    componentNames.toArray(nameList);
    extras.putStringArray(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST, nameList);
    extras.putBoolean(Intent.EXTRA_DONT_KILL_APP, killFlag);
    extras.putInt(Intent.EXTRA_UID, packageUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_CHANGED, packageName, extras, null, null, new int[] { UserHandle.getUserId(packageUid) });
}
#method_after
private void sendPackageChangedBroadcast(String packageName, boolean killFlag, ArrayList<String> componentNames, int packageUid) {
    if (DEBUG_INSTALL)
        Log.v(TAG, "Sending package changed: package=" + packageName + " components=" + componentNames);
    Bundle extras = new Bundle(4);
    extras.putString(Intent.EXTRA_CHANGED_COMPONENT_NAME, componentNames.get(0));
    String[] nameList = new String[componentNames.size()];
    componentNames.toArray(nameList);
    extras.putStringArray(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST, nameList);
    extras.putBoolean(Intent.EXTRA_DONT_KILL_APP, killFlag);
    extras.putInt(Intent.EXTRA_UID, packageUid);
    // If this is not reporting a change of the overall package, then only send it
    // to registered receivers.  We don't want to launch a swath of apps for every
    // little component state change.
    final int flags = !componentNames.contains(packageName) ? Intent.FLAG_RECEIVER_REGISTERED_ONLY : 0;
    sendPackageBroadcast(Intent.ACTION_PACKAGE_CHANGED, packageName, extras, flags, null, null, new int[] { UserHandle.getUserId(packageUid) });
}
#end_block

#method_before
@Override
public void setPackageStoppedState(String packageName, boolean stopped, int userId) {
    if (!sUserManager.exists(userId))
        return;
    final int uid = Binder.getCallingUid();
    final int permission = mContext.checkCallingOrSelfPermission(android.Manifest.permission.CHANGE_COMPONENT_ENABLED_STATE);
    final boolean allowedByPermission = (permission == PackageManager.PERMISSION_GRANTED);
    enforceCrossUserPermission(uid, userId, true, true, "stop package");
    // writer
    synchronized (mPackages) {
        if (mSettings.setPackageStoppedStateLPw(this, packageName, stopped, allowedByPermission, uid, userId)) {
            scheduleWritePackageRestrictionsLocked(userId);
        }
    }
}
#method_after
@Override
public void setPackageStoppedState(String packageName, boolean stopped, int userId) {
    if (!sUserManager.exists(userId))
        return;
    final int uid = Binder.getCallingUid();
    final int permission = mContext.checkCallingOrSelfPermission(android.Manifest.permission.CHANGE_COMPONENT_ENABLED_STATE);
    final boolean allowedByPermission = (permission == PackageManager.PERMISSION_GRANTED);
    enforceCrossUserPermission(uid, userId, true, /* requireFullPermission */
    true, /* checkShell */
    "stop package");
    // writer
    synchronized (mPackages) {
        if (mSettings.setPackageStoppedStateLPw(this, packageName, stopped, allowedByPermission, uid, userId)) {
            scheduleWritePackageRestrictionsLocked(userId);
        }
    }
}
#end_block

#method_before
@Override
public int getApplicationEnabledSetting(String packageName, int userId) {
    if (!sUserManager.exists(userId))
        return COMPONENT_ENABLED_STATE_DISABLED;
    int uid = Binder.getCallingUid();
    enforceCrossUserPermission(uid, userId, false, false, "get enabled");
    // reader
    synchronized (mPackages) {
        return mSettings.getApplicationEnabledSettingLPr(packageName, userId);
    }
}
#method_after
@Override
public int getApplicationEnabledSetting(String packageName, int userId) {
    if (!sUserManager.exists(userId))
        return COMPONENT_ENABLED_STATE_DISABLED;
    int uid = Binder.getCallingUid();
    enforceCrossUserPermission(uid, userId, false, /* requireFullPermission */
    false, /* checkShell */
    "get enabled");
    // reader
    synchronized (mPackages) {
        return mSettings.getApplicationEnabledSettingLPr(packageName, userId);
    }
}
#end_block

#method_before
@Override
public int getComponentEnabledSetting(ComponentName componentName, int userId) {
    if (!sUserManager.exists(userId))
        return COMPONENT_ENABLED_STATE_DISABLED;
    int uid = Binder.getCallingUid();
    enforceCrossUserPermission(uid, userId, false, false, "get component enabled");
    // reader
    synchronized (mPackages) {
        return mSettings.getComponentEnabledSettingLPr(componentName, userId);
    }
}
#method_after
@Override
public int getComponentEnabledSetting(ComponentName componentName, int userId) {
    if (!sUserManager.exists(userId))
        return COMPONENT_ENABLED_STATE_DISABLED;
    int uid = Binder.getCallingUid();
    enforceCrossUserPermission(uid, userId, false, /* requireFullPermission */
    false, /* checkShell */
    "get component enabled");
    // reader
    synchronized (mPackages) {
        return mSettings.getComponentEnabledSettingLPr(componentName, userId);
    }
}
#end_block

#method_before
@Override
public void systemReady() {
    mSystemReady = true;
    // Read the compatibilty setting when the system is ready.
    boolean compatibilityModeEnabled = android.provider.Settings.Global.getInt(mContext.getContentResolver(), android.provider.Settings.Global.COMPATIBILITY_MODE, 1) == 1;
    PackageParser.setCompatibilityModeEnabled(compatibilityModeEnabled);
    if (DEBUG_SETTINGS) {
        Log.d(TAG, "compatibility mode:" + compatibilityModeEnabled);
    }
    int[] grantPermissionsUserIds = EMPTY_INT_ARRAY;
    synchronized (mPackages) {
        // Verify that all of the preferred activity components actually
        // exist.  It is possible for applications to be updated and at
        // that point remove a previously declared activity component that
        // had been set as a preferred activity.  We try to clean this up
        // the next time we encounter that preferred activity, but it is
        // possible for the user flow to never be able to return to that
        // situation so here we do a sanity check to make sure we haven't
        // left any junk around.
        ArrayList<PreferredActivity> removed = new ArrayList<PreferredActivity>();
        for (int i = 0; i < mSettings.mPreferredActivities.size(); i++) {
            PreferredIntentResolver pir = mSettings.mPreferredActivities.valueAt(i);
            removed.clear();
            for (PreferredActivity pa : pir.filterSet()) {
                if (mActivities.mActivities.get(pa.mPref.mComponent) == null) {
                    removed.add(pa);
                }
            }
            if (removed.size() > 0) {
                for (int r = 0; r < removed.size(); r++) {
                    PreferredActivity pa = removed.get(r);
                    Slog.w(TAG, "Removing dangling preferred activity: " + pa.mPref.mComponent);
                    pir.removeFilter(pa);
                }
                mSettings.writePackageRestrictionsLPr(mSettings.mPreferredActivities.keyAt(i));
            }
        }
        for (int userId : UserManagerService.getInstance().getUserIds()) {
            if (!mSettings.areDefaultRuntimePermissionsGrantedLPr(userId)) {
                grantPermissionsUserIds = ArrayUtils.appendInt(grantPermissionsUserIds, userId);
            }
        }
    }
    sUserManager.systemReady();
    // If we upgraded grant all default permissions before kicking off.
    for (int userId : grantPermissionsUserIds) {
        mDefaultPermissionPolicy.grantDefaultPermissions(userId);
    }
    // Kick off any messages waiting for system ready
    if (mPostSystemReadyMessages != null) {
        for (Message msg : mPostSystemReadyMessages) {
            msg.sendToTarget();
        }
        mPostSystemReadyMessages = null;
    }
    // Watch for external volumes that come and go over time
    final StorageManager storage = mContext.getSystemService(StorageManager.class);
    storage.registerListener(mStorageListener);
    mInstallerService.systemReady();
    mPackageDexOptimizer.systemReady();
    MountServiceInternal mountServiceInternal = LocalServices.getService(MountServiceInternal.class);
    mountServiceInternal.addExternalStoragePolicy(new MountServiceInternal.ExternalStorageMountPolicy() {

        @Override
        public int getMountMode(int uid, String packageName) {
            if (Process.isIsolated(uid)) {
                return Zygote.MOUNT_EXTERNAL_NONE;
            }
            if (checkUidPermission(WRITE_MEDIA_STORAGE, uid) == PERMISSION_GRANTED) {
                return Zygote.MOUNT_EXTERNAL_DEFAULT;
            }
            if (checkUidPermission(READ_EXTERNAL_STORAGE, uid) == PERMISSION_DENIED) {
                return Zygote.MOUNT_EXTERNAL_DEFAULT;
            }
            if (checkUidPermission(WRITE_EXTERNAL_STORAGE, uid) == PERMISSION_DENIED) {
                return Zygote.MOUNT_EXTERNAL_READ;
            }
            return Zygote.MOUNT_EXTERNAL_WRITE;
        }

        @Override
        public boolean hasExternalStorage(int uid, String packageName) {
            return true;
        }
    });
}
#method_after
@Override
public void systemReady() {
    mSystemReady = true;
    // Read the compatibilty setting when the system is ready.
    boolean compatibilityModeEnabled = android.provider.Settings.Global.getInt(mContext.getContentResolver(), android.provider.Settings.Global.COMPATIBILITY_MODE, 1) == 1;
    PackageParser.setCompatibilityModeEnabled(compatibilityModeEnabled);
    if (DEBUG_SETTINGS) {
        Log.d(TAG, "compatibility mode:" + compatibilityModeEnabled);
    }
    int[] grantPermissionsUserIds = EMPTY_INT_ARRAY;
    synchronized (mPackages) {
        // Verify that all of the preferred activity components actually
        // exist.  It is possible for applications to be updated and at
        // that point remove a previously declared activity component that
        // had been set as a preferred activity.  We try to clean this up
        // the next time we encounter that preferred activity, but it is
        // possible for the user flow to never be able to return to that
        // situation so here we do a sanity check to make sure we haven't
        // left any junk around.
        ArrayList<PreferredActivity> removed = new ArrayList<PreferredActivity>();
        for (int i = 0; i < mSettings.mPreferredActivities.size(); i++) {
            PreferredIntentResolver pir = mSettings.mPreferredActivities.valueAt(i);
            removed.clear();
            for (PreferredActivity pa : pir.filterSet()) {
                if (mActivities.mActivities.get(pa.mPref.mComponent) == null) {
                    removed.add(pa);
                }
            }
            if (removed.size() > 0) {
                for (int r = 0; r < removed.size(); r++) {
                    PreferredActivity pa = removed.get(r);
                    Slog.w(TAG, "Removing dangling preferred activity: " + pa.mPref.mComponent);
                    pir.removeFilter(pa);
                }
                mSettings.writePackageRestrictionsLPr(mSettings.mPreferredActivities.keyAt(i));
            }
        }
        for (int userId : UserManagerService.getInstance().getUserIds()) {
            if (!mSettings.areDefaultRuntimePermissionsGrantedLPr(userId)) {
                grantPermissionsUserIds = ArrayUtils.appendInt(grantPermissionsUserIds, userId);
            }
        }
    }
    sUserManager.systemReady();
    // If we upgraded grant all default permissions before kicking off.
    for (int userId : grantPermissionsUserIds) {
        mDefaultPermissionPolicy.grantDefaultPermissions(userId);
    }
    // Kick off any messages waiting for system ready
    if (mPostSystemReadyMessages != null) {
        for (Message msg : mPostSystemReadyMessages) {
            msg.sendToTarget();
        }
        mPostSystemReadyMessages = null;
    }
    // Watch for external volumes that come and go over time
    final StorageManager storage = mContext.getSystemService(StorageManager.class);
    storage.registerListener(mStorageListener);
    mInstallerService.systemReady();
    mPackageDexOptimizer.systemReady();
    MountServiceInternal mountServiceInternal = LocalServices.getService(MountServiceInternal.class);
    mountServiceInternal.addExternalStoragePolicy(new MountServiceInternal.ExternalStorageMountPolicy() {

        @Override
        public int getMountMode(int uid, String packageName) {
            if (Process.isIsolated(uid)) {
                return Zygote.MOUNT_EXTERNAL_NONE;
            }
            if (checkUidPermission(WRITE_MEDIA_STORAGE, uid) == PERMISSION_GRANTED) {
                return Zygote.MOUNT_EXTERNAL_DEFAULT;
            }
            if (checkUidPermission(READ_EXTERNAL_STORAGE, uid) == PERMISSION_DENIED) {
                return Zygote.MOUNT_EXTERNAL_DEFAULT;
            }
            if (checkUidPermission(WRITE_EXTERNAL_STORAGE, uid) == PERMISSION_DENIED) {
                return Zygote.MOUNT_EXTERNAL_READ;
            }
            return Zygote.MOUNT_EXTERNAL_WRITE;
        }

        @Override
        public boolean hasExternalStorage(int uid, String packageName) {
            return true;
        }
    });
    // Now that we're mostly running, clean up stale users and apps
    reconcileUsers(StorageManager.UUID_PRIVATE_INTERNAL);
    reconcileApps(StorageManager.UUID_PRIVATE_INTERNAL);
}
#end_block

#method_before
@Override
protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
        pw.println("Permission Denial: can't dump ActivityManager from from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " without permission " + android.Manifest.permission.DUMP);
        return;
    }
    DumpState dumpState = new DumpState();
    boolean fullPreferred = false;
    boolean checkin = false;
    String packageName = null;
    ArraySet<String> permissionNames = null;
    int opti = 0;
    while (opti < args.length) {
        String opt = args[opti];
        if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
            break;
        }
        opti++;
        if ("-a".equals(opt)) {
        // Right now we only know how to print all.
        } else if ("-h".equals(opt)) {
            pw.println("Package manager dump options:");
            pw.println("  [-h] [-f] [--checkin] [cmd] ...");
            pw.println("    --checkin: dump for a checkin");
            pw.println("    -f: print details of intent filters");
            pw.println("    -h: print this help");
            pw.println("  cmd may be one of:");
            pw.println("    l[ibraries]: list known shared libraries");
            pw.println("    f[ibraries]: list device features");
            pw.println("    k[eysets]: print known keysets");
            pw.println("    r[esolvers]: dump intent resolvers");
            pw.println("    perm[issions]: dump permissions");
            pw.println("    permission [name ...]: dump declaration and use of given permission");
            pw.println("    pref[erred]: print preferred package settings");
            pw.println("    preferred-xml [--full]: print preferred package settings as xml");
            pw.println("    prov[iders]: dump content providers");
            pw.println("    p[ackages]: dump installed packages");
            pw.println("    s[hared-users]: dump shared user IDs");
            pw.println("    m[essages]: print collected runtime messages");
            pw.println("    v[erifiers]: print package verifier info");
            pw.println("    d[omain-preferred-apps]: print domains preferred apps");
            pw.println("    i[ntent-filter-verifiers]|ifv: print intent filter verifier info");
            pw.println("    version: print database version info");
            pw.println("    write: write current settings now");
            pw.println("    installs: details about install sessions");
            pw.println("    check-permission <permission> <package> [<user>]: does pkg hold perm?");
            pw.println("    <package.name>: info about given package");
            return;
        } else if ("--checkin".equals(opt)) {
            checkin = true;
        } else if ("-f".equals(opt)) {
            dumpState.setOptionEnabled(DumpState.OPTION_SHOW_FILTERS);
        } else {
            pw.println("Unknown argument: " + opt + "; use -h for help");
        }
    }
    // Is the caller requesting to dump a particular piece of data?
    if (opti < args.length) {
        String cmd = args[opti];
        opti++;
        // Is this a package name?
        if ("android".equals(cmd) || cmd.contains(".")) {
            packageName = cmd;
            // When dumping a single package, we always dump all of its
            // filter information since the amount of data will be reasonable.
            dumpState.setOptionEnabled(DumpState.OPTION_SHOW_FILTERS);
        } else if ("check-permission".equals(cmd)) {
            if (opti >= args.length) {
                pw.println("Error: check-permission missing permission argument");
                return;
            }
            String perm = args[opti];
            opti++;
            if (opti >= args.length) {
                pw.println("Error: check-permission missing package argument");
                return;
            }
            String pkg = args[opti];
            opti++;
            int user = UserHandle.getUserId(Binder.getCallingUid());
            if (opti < args.length) {
                try {
                    user = Integer.parseInt(args[opti]);
                } catch (NumberFormatException e) {
                    pw.println("Error: check-permission user argument is not a number: " + args[opti]);
                    return;
                }
            }
            pw.println(checkPermission(perm, pkg, user));
            return;
        } else if ("l".equals(cmd) || "libraries".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_LIBS);
        } else if ("f".equals(cmd) || "features".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_FEATURES);
        } else if ("r".equals(cmd) || "resolvers".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_RESOLVERS);
        } else if ("perm".equals(cmd) || "permissions".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_PERMISSIONS);
        } else if ("permission".equals(cmd)) {
            if (opti >= args.length) {
                pw.println("Error: permission requires permission name");
                return;
            }
            permissionNames = new ArraySet<>();
            while (opti < args.length) {
                permissionNames.add(args[opti]);
                opti++;
            }
            dumpState.setDump(DumpState.DUMP_PERMISSIONS | DumpState.DUMP_PACKAGES | DumpState.DUMP_SHARED_USERS);
        } else if ("pref".equals(cmd) || "preferred".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_PREFERRED);
        } else if ("preferred-xml".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_PREFERRED_XML);
            if (opti < args.length && "--full".equals(args[opti])) {
                fullPreferred = true;
                opti++;
            }
        } else if ("d".equals(cmd) || "domain-preferred-apps".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_DOMAIN_PREFERRED);
        } else if ("p".equals(cmd) || "packages".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_PACKAGES);
        } else if ("s".equals(cmd) || "shared-users".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_SHARED_USERS);
        } else if ("prov".equals(cmd) || "providers".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_PROVIDERS);
        } else if ("m".equals(cmd) || "messages".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_MESSAGES);
        } else if ("v".equals(cmd) || "verifiers".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_VERIFIERS);
        } else if ("i".equals(cmd) || "ifv".equals(cmd) || "intent-filter-verifiers".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_INTENT_FILTER_VERIFIERS);
        } else if ("version".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_VERSION);
        } else if ("k".equals(cmd) || "keysets".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_KEYSETS);
        } else if ("installs".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_INSTALLS);
        } else if ("write".equals(cmd)) {
            synchronized (mPackages) {
                mSettings.writeLPr();
                pw.println("Settings written.");
                return;
            }
        }
    }
    if (checkin) {
        pw.println("vers,1");
    }
    // reader
    synchronized (mPackages) {
        if (dumpState.isDumping(DumpState.DUMP_VERSION) && packageName == null) {
            if (!checkin) {
                if (dumpState.onTitlePrinted())
                    pw.println();
                pw.println("Database versions:");
                mSettings.dumpVersionLPr(new IndentingPrintWriter(pw, "  "));
            }
        }
        if (dumpState.isDumping(DumpState.DUMP_VERIFIERS) && packageName == null) {
            if (!checkin) {
                if (dumpState.onTitlePrinted())
                    pw.println();
                pw.println("Verifiers:");
                pw.print("  Required: ");
                pw.print(mRequiredVerifierPackage);
                pw.print(" (uid=");
                pw.print(getPackageUid(mRequiredVerifierPackage, 0));
                pw.println(")");
            } else if (mRequiredVerifierPackage != null) {
                pw.print("vrfy,");
                pw.print(mRequiredVerifierPackage);
                pw.print(",");
                pw.println(getPackageUid(mRequiredVerifierPackage, 0));
            }
        }
        if (dumpState.isDumping(DumpState.DUMP_INTENT_FILTER_VERIFIERS) && packageName == null) {
            if (mIntentFilterVerifierComponent != null) {
                String verifierPackageName = mIntentFilterVerifierComponent.getPackageName();
                if (!checkin) {
                    if (dumpState.onTitlePrinted())
                        pw.println();
                    pw.println("Intent Filter Verifier:");
                    pw.print("  Using: ");
                    pw.print(verifierPackageName);
                    pw.print(" (uid=");
                    pw.print(getPackageUid(verifierPackageName, 0));
                    pw.println(")");
                } else if (verifierPackageName != null) {
                    pw.print("ifv,");
                    pw.print(verifierPackageName);
                    pw.print(",");
                    pw.println(getPackageUid(verifierPackageName, 0));
                }
            } else {
                pw.println();
                pw.println("No Intent Filter Verifier available!");
            }
        }
        if (dumpState.isDumping(DumpState.DUMP_LIBS) && packageName == null) {
            boolean printedHeader = false;
            final Iterator<String> it = mSharedLibraries.keySet().iterator();
            while (it.hasNext()) {
                String name = it.next();
                SharedLibraryEntry ent = mSharedLibraries.get(name);
                if (!checkin) {
                    if (!printedHeader) {
                        if (dumpState.onTitlePrinted())
                            pw.println();
                        pw.println("Libraries:");
                        printedHeader = true;
                    }
                    pw.print("  ");
                } else {
                    pw.print("lib,");
                }
                pw.print(name);
                if (!checkin) {
                    pw.print(" -> ");
                }
                if (ent.path != null) {
                    if (!checkin) {
                        pw.print("(jar) ");
                        pw.print(ent.path);
                    } else {
                        pw.print(",jar,");
                        pw.print(ent.path);
                    }
                } else {
                    if (!checkin) {
                        pw.print("(apk) ");
                        pw.print(ent.apk);
                    } else {
                        pw.print(",apk,");
                        pw.print(ent.apk);
                    }
                }
                pw.println();
            }
        }
        if (dumpState.isDumping(DumpState.DUMP_FEATURES) && packageName == null) {
            if (dumpState.onTitlePrinted())
                pw.println();
            if (!checkin) {
                pw.println("Features:");
            }
            Iterator<String> it = mAvailableFeatures.keySet().iterator();
            while (it.hasNext()) {
                String name = it.next();
                if (!checkin) {
                    pw.print("  ");
                } else {
                    pw.print("feat,");
                }
                pw.println(name);
            }
        }
        if (!checkin && dumpState.isDumping(DumpState.DUMP_RESOLVERS)) {
            if (mActivities.dump(pw, dumpState.getTitlePrinted() ? "\nActivity Resolver Table:" : "Activity Resolver Table:", "  ", packageName, dumpState.isOptionEnabled(DumpState.OPTION_SHOW_FILTERS), true)) {
                dumpState.setTitlePrinted(true);
            }
            if (mReceivers.dump(pw, dumpState.getTitlePrinted() ? "\nReceiver Resolver Table:" : "Receiver Resolver Table:", "  ", packageName, dumpState.isOptionEnabled(DumpState.OPTION_SHOW_FILTERS), true)) {
                dumpState.setTitlePrinted(true);
            }
            if (mServices.dump(pw, dumpState.getTitlePrinted() ? "\nService Resolver Table:" : "Service Resolver Table:", "  ", packageName, dumpState.isOptionEnabled(DumpState.OPTION_SHOW_FILTERS), true)) {
                dumpState.setTitlePrinted(true);
            }
            if (mProviders.dump(pw, dumpState.getTitlePrinted() ? "\nProvider Resolver Table:" : "Provider Resolver Table:", "  ", packageName, dumpState.isOptionEnabled(DumpState.OPTION_SHOW_FILTERS), true)) {
                dumpState.setTitlePrinted(true);
            }
        }
        if (!checkin && dumpState.isDumping(DumpState.DUMP_PREFERRED)) {
            for (int i = 0; i < mSettings.mPreferredActivities.size(); i++) {
                PreferredIntentResolver pir = mSettings.mPreferredActivities.valueAt(i);
                int user = mSettings.mPreferredActivities.keyAt(i);
                if (pir.dump(pw, dumpState.getTitlePrinted() ? "\nPreferred Activities User " + user + ":" : "Preferred Activities User " + user + ":", "  ", packageName, true, false)) {
                    dumpState.setTitlePrinted(true);
                }
            }
        }
        if (!checkin && dumpState.isDumping(DumpState.DUMP_PREFERRED_XML)) {
            pw.flush();
            FileOutputStream fout = new FileOutputStream(fd);
            BufferedOutputStream str = new BufferedOutputStream(fout);
            XmlSerializer serializer = new FastXmlSerializer();
            try {
                serializer.setOutput(str, StandardCharsets.UTF_8.name());
                serializer.startDocument(null, true);
                serializer.setFeature("http://xmlpull.org/v1/doc/features.html#indent-output", true);
                mSettings.writePreferredActivitiesLPr(serializer, 0, fullPreferred);
                serializer.endDocument();
                serializer.flush();
            } catch (IllegalArgumentException e) {
                pw.println("Failed writing: " + e);
            } catch (IllegalStateException e) {
                pw.println("Failed writing: " + e);
            } catch (IOException e) {
                pw.println("Failed writing: " + e);
            }
        }
        if (!checkin && dumpState.isDumping(DumpState.DUMP_DOMAIN_PREFERRED) && packageName == null) {
            pw.println();
            int count = mSettings.mPackages.size();
            if (count == 0) {
                pw.println("No applications!");
                pw.println();
            } else {
                final String prefix = "  ";
                Collection<PackageSetting> allPackageSettings = mSettings.mPackages.values();
                if (allPackageSettings.size() == 0) {
                    pw.println("No domain preferred apps!");
                    pw.println();
                } else {
                    pw.println("App verification status:");
                    pw.println();
                    count = 0;
                    for (PackageSetting ps : allPackageSettings) {
                        IntentFilterVerificationInfo ivi = ps.getIntentFilterVerificationInfo();
                        if (ivi == null || ivi.getPackageName() == null)
                            continue;
                        pw.println(prefix + "Package: " + ivi.getPackageName());
                        pw.println(prefix + "Domains: " + ivi.getDomainsString());
                        pw.println(prefix + "Status:  " + ivi.getStatusString());
                        pw.println();
                        count++;
                    }
                    if (count == 0) {
                        pw.println(prefix + "No app verification established.");
                        pw.println();
                    }
                    for (int userId : sUserManager.getUserIds()) {
                        pw.println("App linkages for user " + userId + ":");
                        pw.println();
                        count = 0;
                        for (PackageSetting ps : allPackageSettings) {
                            final long status = ps.getDomainVerificationStatusForUser(userId);
                            if (status >> 32 == INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_UNDEFINED) {
                                continue;
                            }
                            pw.println(prefix + "Package: " + ps.name);
                            pw.println(prefix + "Domains: " + dumpDomainString(ps.name));
                            String statusStr = IntentFilterVerificationInfo.getStatusStringFromValue(status);
                            pw.println(prefix + "Status:  " + statusStr);
                            pw.println();
                            count++;
                        }
                        if (count == 0) {
                            pw.println(prefix + "No configured app linkages.");
                            pw.println();
                        }
                    }
                }
            }
        }
        if (!checkin && dumpState.isDumping(DumpState.DUMP_PERMISSIONS)) {
            mSettings.dumpPermissionsLPr(pw, packageName, permissionNames, dumpState);
            if (packageName == null && permissionNames == null) {
                for (int iperm = 0; iperm < mAppOpPermissionPackages.size(); iperm++) {
                    if (iperm == 0) {
                        if (dumpState.onTitlePrinted())
                            pw.println();
                        pw.println("AppOp Permissions:");
                    }
                    pw.print("  AppOp Permission ");
                    pw.print(mAppOpPermissionPackages.keyAt(iperm));
                    pw.println(":");
                    ArraySet<String> pkgs = mAppOpPermissionPackages.valueAt(iperm);
                    for (int ipkg = 0; ipkg < pkgs.size(); ipkg++) {
                        pw.print("    ");
                        pw.println(pkgs.valueAt(ipkg));
                    }
                }
            }
        }
        if (!checkin && dumpState.isDumping(DumpState.DUMP_PROVIDERS)) {
            boolean printedSomething = false;
            for (PackageParser.Provider p : mProviders.mProviders.values()) {
                if (packageName != null && !packageName.equals(p.info.packageName)) {
                    continue;
                }
                if (!printedSomething) {
                    if (dumpState.onTitlePrinted())
                        pw.println();
                    pw.println("Registered ContentProviders:");
                    printedSomething = true;
                }
                pw.print("  ");
                p.printComponentShortName(pw);
                pw.println(":");
                pw.print("    ");
                pw.println(p.toString());
            }
            printedSomething = false;
            for (Map.Entry<String, PackageParser.Provider> entry : mProvidersByAuthority.entrySet()) {
                PackageParser.Provider p = entry.getValue();
                if (packageName != null && !packageName.equals(p.info.packageName)) {
                    continue;
                }
                if (!printedSomething) {
                    if (dumpState.onTitlePrinted())
                        pw.println();
                    pw.println("ContentProvider Authorities:");
                    printedSomething = true;
                }
                pw.print("  [");
                pw.print(entry.getKey());
                pw.println("]:");
                pw.print("    ");
                pw.println(p.toString());
                if (p.info != null && p.info.applicationInfo != null) {
                    final String appInfo = p.info.applicationInfo.toString();
                    pw.print("      applicationInfo=");
                    pw.println(appInfo);
                }
            }
        }
        if (!checkin && dumpState.isDumping(DumpState.DUMP_KEYSETS)) {
            mSettings.mKeySetManagerService.dumpLPr(pw, packageName, dumpState);
        }
        if (dumpState.isDumping(DumpState.DUMP_PACKAGES)) {
            mSettings.dumpPackagesLPr(pw, packageName, permissionNames, dumpState, checkin);
        }
        if (dumpState.isDumping(DumpState.DUMP_SHARED_USERS)) {
            mSettings.dumpSharedUsersLPr(pw, packageName, permissionNames, dumpState, checkin);
        }
        if (!checkin && dumpState.isDumping(DumpState.DUMP_INSTALLS) && packageName == null) {
            // the given package is involved with.
            if (dumpState.onTitlePrinted())
                pw.println();
            mInstallerService.dump(new IndentingPrintWriter(pw, "  ", 120));
        }
        if (!checkin && dumpState.isDumping(DumpState.DUMP_MESSAGES) && packageName == null) {
            if (dumpState.onTitlePrinted())
                pw.println();
            mSettings.dumpReadMessagesLPr(pw, dumpState);
            pw.println();
            pw.println("Package warning messages:");
            BufferedReader in = null;
            String line = null;
            try {
                in = new BufferedReader(new FileReader(getSettingsProblemFile()));
                while ((line = in.readLine()) != null) {
                    if (line.contains("ignored: updated version"))
                        continue;
                    pw.println(line);
                }
            } catch (IOException ignored) {
            } finally {
                IoUtils.closeQuietly(in);
            }
        }
        if (checkin && dumpState.isDumping(DumpState.DUMP_MESSAGES)) {
            BufferedReader in = null;
            String line = null;
            try {
                in = new BufferedReader(new FileReader(getSettingsProblemFile()));
                while ((line = in.readLine()) != null) {
                    if (line.contains("ignored: updated version"))
                        continue;
                    pw.print("msg,");
                    pw.println(line);
                }
            } catch (IOException ignored) {
            } finally {
                IoUtils.closeQuietly(in);
            }
        }
    }
}
#method_after
@Override
protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
        pw.println("Permission Denial: can't dump ActivityManager from from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " without permission " + android.Manifest.permission.DUMP);
        return;
    }
    DumpState dumpState = new DumpState();
    boolean fullPreferred = false;
    boolean checkin = false;
    String packageName = null;
    ArraySet<String> permissionNames = null;
    int opti = 0;
    while (opti < args.length) {
        String opt = args[opti];
        if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
            break;
        }
        opti++;
        if ("-a".equals(opt)) {
        // Right now we only know how to print all.
        } else if ("-h".equals(opt)) {
            pw.println("Package manager dump options:");
            pw.println("  [-h] [-f] [--checkin] [cmd] ...");
            pw.println("    --checkin: dump for a checkin");
            pw.println("    -f: print details of intent filters");
            pw.println("    -h: print this help");
            pw.println("  cmd may be one of:");
            pw.println("    l[ibraries]: list known shared libraries");
            pw.println("    f[eatures]: list device features");
            pw.println("    k[eysets]: print known keysets");
            pw.println("    r[esolvers] [activity|service|receiver|content]: dump intent resolvers");
            pw.println("    perm[issions]: dump permissions");
            pw.println("    permission [name ...]: dump declaration and use of given permission");
            pw.println("    pref[erred]: print preferred package settings");
            pw.println("    preferred-xml [--full]: print preferred package settings as xml");
            pw.println("    prov[iders]: dump content providers");
            pw.println("    p[ackages]: dump installed packages");
            pw.println("    s[hared-users]: dump shared user IDs");
            pw.println("    m[essages]: print collected runtime messages");
            pw.println("    v[erifiers]: print package verifier info");
            pw.println("    d[omain-preferred-apps]: print domains preferred apps");
            pw.println("    i[ntent-filter-verifiers]|ifv: print intent filter verifier info");
            pw.println("    version: print database version info");
            pw.println("    write: write current settings now");
            pw.println("    installs: details about install sessions");
            pw.println("    check-permission <permission> <package> [<user>]: does pkg hold perm?");
            pw.println("    dexopt: dump dexopt state");
            pw.println("    compiler-stats: dump compiler statistics");
            pw.println("    <package.name>: info about given package");
            return;
        } else if ("--checkin".equals(opt)) {
            checkin = true;
        } else if ("-f".equals(opt)) {
            dumpState.setOptionEnabled(DumpState.OPTION_SHOW_FILTERS);
        } else {
            pw.println("Unknown argument: " + opt + "; use -h for help");
        }
    }
    // Is the caller requesting to dump a particular piece of data?
    if (opti < args.length) {
        String cmd = args[opti];
        opti++;
        // Is this a package name?
        if ("android".equals(cmd) || cmd.contains(".")) {
            packageName = cmd;
            // When dumping a single package, we always dump all of its
            // filter information since the amount of data will be reasonable.
            dumpState.setOptionEnabled(DumpState.OPTION_SHOW_FILTERS);
        } else if ("check-permission".equals(cmd)) {
            if (opti >= args.length) {
                pw.println("Error: check-permission missing permission argument");
                return;
            }
            String perm = args[opti];
            opti++;
            if (opti >= args.length) {
                pw.println("Error: check-permission missing package argument");
                return;
            }
            String pkg = args[opti];
            opti++;
            int user = UserHandle.getUserId(Binder.getCallingUid());
            if (opti < args.length) {
                try {
                    user = Integer.parseInt(args[opti]);
                } catch (NumberFormatException e) {
                    pw.println("Error: check-permission user argument is not a number: " + args[opti]);
                    return;
                }
            }
            pw.println(checkPermission(perm, pkg, user));
            return;
        } else if ("l".equals(cmd) || "libraries".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_LIBS);
        } else if ("f".equals(cmd) || "features".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_FEATURES);
        } else if ("r".equals(cmd) || "resolvers".equals(cmd)) {
            if (opti >= args.length) {
                dumpState.setDump(DumpState.DUMP_ACTIVITY_RESOLVERS | DumpState.DUMP_SERVICE_RESOLVERS | DumpState.DUMP_RECEIVER_RESOLVERS | DumpState.DUMP_CONTENT_RESOLVERS);
            } else {
                while (opti < args.length) {
                    String name = args[opti];
                    if ("a".equals(name) || "activity".equals(name)) {
                        dumpState.setDump(DumpState.DUMP_ACTIVITY_RESOLVERS);
                    } else if ("s".equals(name) || "service".equals(name)) {
                        dumpState.setDump(DumpState.DUMP_SERVICE_RESOLVERS);
                    } else if ("r".equals(name) || "receiver".equals(name)) {
                        dumpState.setDump(DumpState.DUMP_RECEIVER_RESOLVERS);
                    } else if ("c".equals(name) || "content".equals(name)) {
                        dumpState.setDump(DumpState.DUMP_CONTENT_RESOLVERS);
                    } else {
                        pw.println("Error: unknown resolver table type: " + name);
                        return;
                    }
                    opti++;
                }
            }
        } else if ("perm".equals(cmd) || "permissions".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_PERMISSIONS);
        } else if ("permission".equals(cmd)) {
            if (opti >= args.length) {
                pw.println("Error: permission requires permission name");
                return;
            }
            permissionNames = new ArraySet<>();
            while (opti < args.length) {
                permissionNames.add(args[opti]);
                opti++;
            }
            dumpState.setDump(DumpState.DUMP_PERMISSIONS | DumpState.DUMP_PACKAGES | DumpState.DUMP_SHARED_USERS);
        } else if ("pref".equals(cmd) || "preferred".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_PREFERRED);
        } else if ("preferred-xml".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_PREFERRED_XML);
            if (opti < args.length && "--full".equals(args[opti])) {
                fullPreferred = true;
                opti++;
            }
        } else if ("d".equals(cmd) || "domain-preferred-apps".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_DOMAIN_PREFERRED);
        } else if ("p".equals(cmd) || "packages".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_PACKAGES);
        } else if ("s".equals(cmd) || "shared-users".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_SHARED_USERS);
        } else if ("prov".equals(cmd) || "providers".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_PROVIDERS);
        } else if ("m".equals(cmd) || "messages".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_MESSAGES);
        } else if ("v".equals(cmd) || "verifiers".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_VERIFIERS);
        } else if ("i".equals(cmd) || "ifv".equals(cmd) || "intent-filter-verifiers".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_INTENT_FILTER_VERIFIERS);
        } else if ("version".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_VERSION);
        } else if ("k".equals(cmd) || "keysets".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_KEYSETS);
        } else if ("installs".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_INSTALLS);
        } else if ("frozen".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_FROZEN);
        } else if ("dexopt".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_DEXOPT);
        } else if ("compiler-stats".equals(cmd)) {
            dumpState.setDump(DumpState.DUMP_COMPILER_STATS);
        } else if ("write".equals(cmd)) {
            synchronized (mPackages) {
                mSettings.writeLPr();
                pw.println("Settings written.");
                return;
            }
        }
    }
    if (checkin) {
        pw.println("vers,1");
    }
    // reader
    synchronized (mPackages) {
        if (dumpState.isDumping(DumpState.DUMP_VERSION) && packageName == null) {
            if (!checkin) {
                if (dumpState.onTitlePrinted())
                    pw.println();
                pw.println("Database versions:");
                mSettings.dumpVersionLPr(new IndentingPrintWriter(pw, "  "));
            }
        }
        if (dumpState.isDumping(DumpState.DUMP_VERIFIERS) && packageName == null) {
            if (!checkin) {
                if (dumpState.onTitlePrinted())
                    pw.println();
                pw.println("Verifiers:");
                pw.print("  Required: ");
                pw.print(mRequiredVerifierPackage);
                pw.print(" (uid=");
                pw.print(getPackageUid(mRequiredVerifierPackage, MATCH_DEBUG_TRIAGED_MISSING, UserHandle.USER_SYSTEM));
                pw.println(")");
            } else if (mRequiredVerifierPackage != null) {
                pw.print("vrfy,");
                pw.print(mRequiredVerifierPackage);
                pw.print(",");
                pw.println(getPackageUid(mRequiredVerifierPackage, MATCH_DEBUG_TRIAGED_MISSING, UserHandle.USER_SYSTEM));
            }
        }
        if (dumpState.isDumping(DumpState.DUMP_INTENT_FILTER_VERIFIERS) && packageName == null) {
            if (mIntentFilterVerifierComponent != null) {
                String verifierPackageName = mIntentFilterVerifierComponent.getPackageName();
                if (!checkin) {
                    if (dumpState.onTitlePrinted())
                        pw.println();
                    pw.println("Intent Filter Verifier:");
                    pw.print("  Using: ");
                    pw.print(verifierPackageName);
                    pw.print(" (uid=");
                    pw.print(getPackageUid(verifierPackageName, MATCH_DEBUG_TRIAGED_MISSING, UserHandle.USER_SYSTEM));
                    pw.println(")");
                } else if (verifierPackageName != null) {
                    pw.print("ifv,");
                    pw.print(verifierPackageName);
                    pw.print(",");
                    pw.println(getPackageUid(verifierPackageName, MATCH_DEBUG_TRIAGED_MISSING, UserHandle.USER_SYSTEM));
                }
            } else {
                pw.println();
                pw.println("No Intent Filter Verifier available!");
            }
        }
        if (dumpState.isDumping(DumpState.DUMP_LIBS) && packageName == null) {
            boolean printedHeader = false;
            final Iterator<String> it = mSharedLibraries.keySet().iterator();
            while (it.hasNext()) {
                String name = it.next();
                SharedLibraryEntry ent = mSharedLibraries.get(name);
                if (!checkin) {
                    if (!printedHeader) {
                        if (dumpState.onTitlePrinted())
                            pw.println();
                        pw.println("Libraries:");
                        printedHeader = true;
                    }
                    pw.print("  ");
                } else {
                    pw.print("lib,");
                }
                pw.print(name);
                if (!checkin) {
                    pw.print(" -> ");
                }
                if (ent.path != null) {
                    if (!checkin) {
                        pw.print("(jar) ");
                        pw.print(ent.path);
                    } else {
                        pw.print(",jar,");
                        pw.print(ent.path);
                    }
                } else {
                    if (!checkin) {
                        pw.print("(apk) ");
                        pw.print(ent.apk);
                    } else {
                        pw.print(",apk,");
                        pw.print(ent.apk);
                    }
                }
                pw.println();
            }
        }
        if (dumpState.isDumping(DumpState.DUMP_FEATURES) && packageName == null) {
            if (dumpState.onTitlePrinted())
                pw.println();
            if (!checkin) {
                pw.println("Features:");
            }
            for (FeatureInfo feat : mAvailableFeatures.values()) {
                if (checkin) {
                    pw.print("feat,");
                    pw.print(feat.name);
                    pw.print(",");
                    pw.println(feat.version);
                } else {
                    pw.print("  ");
                    pw.print(feat.name);
                    if (feat.version > 0) {
                        pw.print(" version=");
                        pw.print(feat.version);
                    }
                    pw.println();
                }
            }
        }
        if (!checkin && dumpState.isDumping(DumpState.DUMP_ACTIVITY_RESOLVERS)) {
            if (mActivities.dump(pw, dumpState.getTitlePrinted() ? "\nActivity Resolver Table:" : "Activity Resolver Table:", "  ", packageName, dumpState.isOptionEnabled(DumpState.OPTION_SHOW_FILTERS), true)) {
                dumpState.setTitlePrinted(true);
            }
        }
        if (!checkin && dumpState.isDumping(DumpState.DUMP_RECEIVER_RESOLVERS)) {
            if (mReceivers.dump(pw, dumpState.getTitlePrinted() ? "\nReceiver Resolver Table:" : "Receiver Resolver Table:", "  ", packageName, dumpState.isOptionEnabled(DumpState.OPTION_SHOW_FILTERS), true)) {
                dumpState.setTitlePrinted(true);
            }
        }
        if (!checkin && dumpState.isDumping(DumpState.DUMP_SERVICE_RESOLVERS)) {
            if (mServices.dump(pw, dumpState.getTitlePrinted() ? "\nService Resolver Table:" : "Service Resolver Table:", "  ", packageName, dumpState.isOptionEnabled(DumpState.OPTION_SHOW_FILTERS), true)) {
                dumpState.setTitlePrinted(true);
            }
        }
        if (!checkin && dumpState.isDumping(DumpState.DUMP_CONTENT_RESOLVERS)) {
            if (mProviders.dump(pw, dumpState.getTitlePrinted() ? "\nProvider Resolver Table:" : "Provider Resolver Table:", "  ", packageName, dumpState.isOptionEnabled(DumpState.OPTION_SHOW_FILTERS), true)) {
                dumpState.setTitlePrinted(true);
            }
        }
        if (!checkin && dumpState.isDumping(DumpState.DUMP_PREFERRED)) {
            for (int i = 0; i < mSettings.mPreferredActivities.size(); i++) {
                PreferredIntentResolver pir = mSettings.mPreferredActivities.valueAt(i);
                int user = mSettings.mPreferredActivities.keyAt(i);
                if (pir.dump(pw, dumpState.getTitlePrinted() ? "\nPreferred Activities User " + user + ":" : "Preferred Activities User " + user + ":", "  ", packageName, true, false)) {
                    dumpState.setTitlePrinted(true);
                }
            }
        }
        if (!checkin && dumpState.isDumping(DumpState.DUMP_PREFERRED_XML)) {
            pw.flush();
            FileOutputStream fout = new FileOutputStream(fd);
            BufferedOutputStream str = new BufferedOutputStream(fout);
            XmlSerializer serializer = new FastXmlSerializer();
            try {
                serializer.setOutput(str, StandardCharsets.UTF_8.name());
                serializer.startDocument(null, true);
                serializer.setFeature("http://xmlpull.org/v1/doc/features.html#indent-output", true);
                mSettings.writePreferredActivitiesLPr(serializer, 0, fullPreferred);
                serializer.endDocument();
                serializer.flush();
            } catch (IllegalArgumentException e) {
                pw.println("Failed writing: " + e);
            } catch (IllegalStateException e) {
                pw.println("Failed writing: " + e);
            } catch (IOException e) {
                pw.println("Failed writing: " + e);
            }
        }
        if (!checkin && dumpState.isDumping(DumpState.DUMP_DOMAIN_PREFERRED) && packageName == null) {
            pw.println();
            int count = mSettings.mPackages.size();
            if (count == 0) {
                pw.println("No applications!");
                pw.println();
            } else {
                final String prefix = "  ";
                Collection<PackageSetting> allPackageSettings = mSettings.mPackages.values();
                if (allPackageSettings.size() == 0) {
                    pw.println("No domain preferred apps!");
                    pw.println();
                } else {
                    pw.println("App verification status:");
                    pw.println();
                    count = 0;
                    for (PackageSetting ps : allPackageSettings) {
                        IntentFilterVerificationInfo ivi = ps.getIntentFilterVerificationInfo();
                        if (ivi == null || ivi.getPackageName() == null)
                            continue;
                        pw.println(prefix + "Package: " + ivi.getPackageName());
                        pw.println(prefix + "Domains: " + ivi.getDomainsString());
                        pw.println(prefix + "Status:  " + ivi.getStatusString());
                        pw.println();
                        count++;
                    }
                    if (count == 0) {
                        pw.println(prefix + "No app verification established.");
                        pw.println();
                    }
                    for (int userId : sUserManager.getUserIds()) {
                        pw.println("App linkages for user " + userId + ":");
                        pw.println();
                        count = 0;
                        for (PackageSetting ps : allPackageSettings) {
                            final long status = ps.getDomainVerificationStatusForUser(userId);
                            if (status >> 32 == INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_UNDEFINED) {
                                continue;
                            }
                            pw.println(prefix + "Package: " + ps.name);
                            pw.println(prefix + "Domains: " + dumpDomainString(ps.name));
                            String statusStr = IntentFilterVerificationInfo.getStatusStringFromValue(status);
                            pw.println(prefix + "Status:  " + statusStr);
                            pw.println();
                            count++;
                        }
                        if (count == 0) {
                            pw.println(prefix + "No configured app linkages.");
                            pw.println();
                        }
                    }
                }
            }
        }
        if (!checkin && dumpState.isDumping(DumpState.DUMP_PERMISSIONS)) {
            mSettings.dumpPermissionsLPr(pw, packageName, permissionNames, dumpState);
            if (packageName == null && permissionNames == null) {
                for (int iperm = 0; iperm < mAppOpPermissionPackages.size(); iperm++) {
                    if (iperm == 0) {
                        if (dumpState.onTitlePrinted())
                            pw.println();
                        pw.println("AppOp Permissions:");
                    }
                    pw.print("  AppOp Permission ");
                    pw.print(mAppOpPermissionPackages.keyAt(iperm));
                    pw.println(":");
                    ArraySet<String> pkgs = mAppOpPermissionPackages.valueAt(iperm);
                    for (int ipkg = 0; ipkg < pkgs.size(); ipkg++) {
                        pw.print("    ");
                        pw.println(pkgs.valueAt(ipkg));
                    }
                }
            }
        }
        if (!checkin && dumpState.isDumping(DumpState.DUMP_PROVIDERS)) {
            boolean printedSomething = false;
            for (PackageParser.Provider p : mProviders.mProviders.values()) {
                if (packageName != null && !packageName.equals(p.info.packageName)) {
                    continue;
                }
                if (!printedSomething) {
                    if (dumpState.onTitlePrinted())
                        pw.println();
                    pw.println("Registered ContentProviders:");
                    printedSomething = true;
                }
                pw.print("  ");
                p.printComponentShortName(pw);
                pw.println(":");
                pw.print("    ");
                pw.println(p.toString());
            }
            printedSomething = false;
            for (Map.Entry<String, PackageParser.Provider> entry : mProvidersByAuthority.entrySet()) {
                PackageParser.Provider p = entry.getValue();
                if (packageName != null && !packageName.equals(p.info.packageName)) {
                    continue;
                }
                if (!printedSomething) {
                    if (dumpState.onTitlePrinted())
                        pw.println();
                    pw.println("ContentProvider Authorities:");
                    printedSomething = true;
                }
                pw.print("  [");
                pw.print(entry.getKey());
                pw.println("]:");
                pw.print("    ");
                pw.println(p.toString());
                if (p.info != null && p.info.applicationInfo != null) {
                    final String appInfo = p.info.applicationInfo.toString();
                    pw.print("      applicationInfo=");
                    pw.println(appInfo);
                }
            }
        }
        if (!checkin && dumpState.isDumping(DumpState.DUMP_KEYSETS)) {
            mSettings.mKeySetManagerService.dumpLPr(pw, packageName, dumpState);
        }
        if (dumpState.isDumping(DumpState.DUMP_PACKAGES)) {
            mSettings.dumpPackagesLPr(pw, packageName, permissionNames, dumpState, checkin);
        }
        if (dumpState.isDumping(DumpState.DUMP_SHARED_USERS)) {
            mSettings.dumpSharedUsersLPr(pw, packageName, permissionNames, dumpState, checkin);
        }
        if (!checkin && dumpState.isDumping(DumpState.DUMP_PERMISSIONS) && packageName == null) {
            mSettings.dumpRestoredPermissionGrantsLPr(pw, dumpState);
        }
        if (!checkin && dumpState.isDumping(DumpState.DUMP_INSTALLS) && packageName == null) {
            // the given package is involved with.
            if (dumpState.onTitlePrinted())
                pw.println();
            mInstallerService.dump(new IndentingPrintWriter(pw, "  ", 120));
        }
        if (!checkin && dumpState.isDumping(DumpState.DUMP_FROZEN) && packageName == null) {
            // the given package is involved with.
            if (dumpState.onTitlePrinted())
                pw.println();
            final IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ", 120);
            ipw.println();
            ipw.println("Frozen packages:");
            ipw.increaseIndent();
            if (mFrozenPackages.size() == 0) {
                ipw.println("(none)");
            } else {
                for (int i = 0; i < mFrozenPackages.size(); i++) {
                    ipw.println(mFrozenPackages.valueAt(i));
                }
            }
            ipw.decreaseIndent();
        }
        if (!checkin && dumpState.isDumping(DumpState.DUMP_DEXOPT)) {
            if (dumpState.onTitlePrinted())
                pw.println();
            dumpDexoptStateLPr(pw, packageName);
        }
        if (!checkin && dumpState.isDumping(DumpState.DUMP_COMPILER_STATS)) {
            if (dumpState.onTitlePrinted())
                pw.println();
            dumpCompilerStatsLPr(pw, packageName);
        }
        if (!checkin && dumpState.isDumping(DumpState.DUMP_MESSAGES) && packageName == null) {
            if (dumpState.onTitlePrinted())
                pw.println();
            mSettings.dumpReadMessagesLPr(pw, dumpState);
            pw.println();
            pw.println("Package warning messages:");
            BufferedReader in = null;
            String line = null;
            try {
                in = new BufferedReader(new FileReader(getSettingsProblemFile()));
                while ((line = in.readLine()) != null) {
                    if (line.contains("ignored: updated version"))
                        continue;
                    pw.println(line);
                }
            } catch (IOException ignored) {
            } finally {
                IoUtils.closeQuietly(in);
            }
        }
        if (checkin && dumpState.isDumping(DumpState.DUMP_MESSAGES)) {
            BufferedReader in = null;
            String line = null;
            try {
                in = new BufferedReader(new FileReader(getSettingsProblemFile()));
                while ((line = in.readLine()) != null) {
                    if (line.contains("ignored: updated version"))
                        continue;
                    pw.print("msg,");
                    pw.println(line);
                }
            } catch (IOException ignored) {
            } finally {
                IoUtils.closeQuietly(in);
            }
        }
    }
}
#end_block

#method_before
private String dumpDomainString(String packageName) {
    List<IntentFilterVerificationInfo> iviList = getIntentFilterVerifications(packageName);
    List<IntentFilter> filters = getAllIntentFilters(packageName);
    ArraySet<String> result = new ArraySet<>();
    if (iviList.size() > 0) {
        for (IntentFilterVerificationInfo ivi : iviList) {
            for (String host : ivi.getDomains()) {
                result.add(host);
            }
        }
    }
    if (filters != null && filters.size() > 0) {
        for (IntentFilter filter : filters) {
            if (filter.hasCategory(Intent.CATEGORY_BROWSABLE) && (filter.hasDataScheme(IntentFilter.SCHEME_HTTP) || filter.hasDataScheme(IntentFilter.SCHEME_HTTPS))) {
                result.addAll(filter.getHostsList());
            }
        }
    }
    StringBuilder sb = new StringBuilder(result.size() * 16);
    for (String domain : result) {
        if (sb.length() > 0)
            sb.append(" ");
        sb.append(domain);
    }
    return sb.toString();
}
#method_after
private String dumpDomainString(String packageName) {
    List<IntentFilterVerificationInfo> iviList = getIntentFilterVerifications(packageName).getList();
    List<IntentFilter> filters = getAllIntentFilters(packageName).getList();
    ArraySet<String> result = new ArraySet<>();
    if (iviList.size() > 0) {
        for (IntentFilterVerificationInfo ivi : iviList) {
            for (String host : ivi.getDomains()) {
                result.add(host);
            }
        }
    }
    if (filters != null && filters.size() > 0) {
        for (IntentFilter filter : filters) {
            if (filter.hasCategory(Intent.CATEGORY_BROWSABLE) && (filter.hasDataScheme(IntentFilter.SCHEME_HTTP) || filter.hasDataScheme(IntentFilter.SCHEME_HTTPS))) {
                result.addAll(filter.getHostsList());
            }
        }
    }
    StringBuilder sb = new StringBuilder(result.size() * 16);
    for (String domain : result) {
        if (sb.length() > 0)
            sb.append(" ");
        sb.append(domain);
    }
    return sb.toString();
}
#end_block

#method_before
public void scanAvailableAsecs() {
    updateExternalMediaStatusInner(true, false, false);
    if (mShouldRestoreconData) {
        SELinuxMMAC.setRestoreconDone();
        mShouldRestoreconData = false;
    }
}
#method_after
public void scanAvailableAsecs() {
    updateExternalMediaStatusInner(true, false, false);
}
#end_block

#method_before
private void sendResourcesChangedBroadcast(boolean mediaStatus, boolean replacing, String[] pkgList, int[] uidArr, IIntentReceiver finishedReceiver) {
    int size = pkgList.length;
    if (size > 0) {
        // Send broadcasts here
        Bundle extras = new Bundle();
        extras.putStringArray(Intent.EXTRA_CHANGED_PACKAGE_LIST, pkgList);
        if (uidArr != null) {
            extras.putIntArray(Intent.EXTRA_CHANGED_UID_LIST, uidArr);
        }
        if (replacing) {
            extras.putBoolean(Intent.EXTRA_REPLACING, replacing);
        }
        String action = mediaStatus ? Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE : Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE;
        sendPackageBroadcast(action, null, extras, null, finishedReceiver, null);
    }
}
#method_after
private void sendResourcesChangedBroadcast(boolean mediaStatus, boolean replacing, String[] pkgList, int[] uidArr, IIntentReceiver finishedReceiver) {
    int size = pkgList.length;
    if (size > 0) {
        // Send broadcasts here
        Bundle extras = new Bundle();
        extras.putStringArray(Intent.EXTRA_CHANGED_PACKAGE_LIST, pkgList);
        if (uidArr != null) {
            extras.putIntArray(Intent.EXTRA_CHANGED_UID_LIST, uidArr);
        }
        if (replacing) {
            extras.putBoolean(Intent.EXTRA_REPLACING, replacing);
        }
        String action = mediaStatus ? Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE : Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE;
        sendPackageBroadcast(action, null, extras, 0, null, finishedReceiver, null);
    }
}
#end_block

#method_before
private void loadMediaPackages(ArrayMap<AsecInstallArgs, String> processCids, int[] uidArr, boolean externalStorage) {
    ArrayList<String> pkgList = new ArrayList<String>();
    Set<AsecInstallArgs> keys = processCids.keySet();
    for (AsecInstallArgs args : keys) {
        String codePath = processCids.get(args);
        if (DEBUG_SD_INSTALL)
            Log.i(TAG, "Loading container : " + args.cid);
        int retCode = PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
        try {
            // Make sure there are no container errors first.
            if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
                Slog.e(TAG, "Failed to mount cid : " + args.cid + " when installing from sdcard");
                continue;
            }
            // Check code path here.
            if (codePath == null || !codePath.startsWith(args.getCodePath())) {
                Slog.e(TAG, "Container " + args.cid + " cachepath " + args.getCodePath() + " does not match one in settings " + codePath);
                continue;
            }
            // Parse package
            int parseFlags = mDefParseFlags;
            if (args.isExternalAsec()) {
                parseFlags |= PackageParser.PARSE_EXTERNAL_STORAGE;
            }
            if (args.isFwdLocked()) {
                parseFlags |= PackageParser.PARSE_FORWARD_LOCK;
            }
            synchronized (mInstallLock) {
                PackageParser.Package pkg = null;
                try {
                    pkg = scanPackageLI(new File(codePath), parseFlags, 0, 0, null);
                } catch (PackageManagerException e) {
                    Slog.w(TAG, "Failed to scan " + codePath + ": " + e.getMessage());
                }
                // Scan the package
                if (pkg != null) {
                    // writer
                    synchronized (mPackages) {
                        retCode = PackageManager.INSTALL_SUCCEEDED;
                        pkgList.add(pkg.packageName);
                        // Post process args
                        args.doPostInstall(PackageManager.INSTALL_SUCCEEDED, pkg.applicationInfo.uid);
                    }
                } else {
                    Slog.i(TAG, "Failed to install pkg from  " + codePath + " from sdcard");
                }
            }
        } finally {
            if (retCode != PackageManager.INSTALL_SUCCEEDED) {
                Log.w(TAG, "Container " + args.cid + " is stale, retCode=" + retCode);
            }
        }
    }
    // writer
    synchronized (mPackages) {
        // If the platform SDK has changed since the last time we booted,
        // we need to re-grant app permission to catch any new ones that
        // appear. This is really a hack, and means that apps can in some
        // cases get permissions that the user didn't initially explicitly
        // allow... it would be nice to have some better way to handle
        // this situation.
        final VersionInfo ver = externalStorage ? mSettings.getExternalVersion() : mSettings.getInternalVersion();
        final String volumeUuid = externalStorage ? StorageManager.UUID_PRIMARY_PHYSICAL : StorageManager.UUID_PRIVATE_INTERNAL;
        int updateFlags = UPDATE_PERMISSIONS_ALL;
        if (ver.sdkVersion != mSdkVersion) {
            logCriticalInfo(Log.INFO, "Platform changed from " + ver.sdkVersion + " to " + mSdkVersion + "; regranting permissions for external");
            updateFlags |= UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;
        }
        updatePermissionsLPw(null, null, volumeUuid, updateFlags);
        // Yay, everything is now upgraded
        ver.forceCurrent();
        // can downgrade to reader
        // Persist settings
        mSettings.writeLPr();
    }
    // Send a broadcast to let everyone know we are done processing
    if (pkgList.size() > 0) {
        sendResourcesChangedBroadcast(true, false, pkgList, uidArr, null);
    }
}
#method_after
private void loadMediaPackages(ArrayMap<AsecInstallArgs, String> processCids, int[] uidArr, boolean externalStorage) {
    ArrayList<String> pkgList = new ArrayList<String>();
    Set<AsecInstallArgs> keys = processCids.keySet();
    for (AsecInstallArgs args : keys) {
        String codePath = processCids.get(args);
        if (DEBUG_SD_INSTALL)
            Log.i(TAG, "Loading container : " + args.cid);
        int retCode = PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
        try {
            // Make sure there are no container errors first.
            if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
                Slog.e(TAG, "Failed to mount cid : " + args.cid + " when installing from sdcard");
                continue;
            }
            // Check code path here.
            if (codePath == null || !codePath.startsWith(args.getCodePath())) {
                Slog.e(TAG, "Container " + args.cid + " cachepath " + args.getCodePath() + " does not match one in settings " + codePath);
                continue;
            }
            // Parse package
            int parseFlags = mDefParseFlags;
            if (args.isExternalAsec()) {
                parseFlags |= PackageParser.PARSE_EXTERNAL_STORAGE;
            }
            if (args.isFwdLocked()) {
                parseFlags |= PackageParser.PARSE_FORWARD_LOCK;
            }
            synchronized (mInstallLock) {
                PackageParser.Package pkg = null;
                try {
                    // Sadly we don't know the package name yet to freeze it
                    pkg = scanPackageTracedLI(new File(codePath), parseFlags, SCAN_IGNORE_FROZEN, 0, null);
                } catch (PackageManagerException e) {
                    Slog.w(TAG, "Failed to scan " + codePath + ": " + e.getMessage());
                }
                // Scan the package
                if (pkg != null) {
                    // writer
                    synchronized (mPackages) {
                        retCode = PackageManager.INSTALL_SUCCEEDED;
                        pkgList.add(pkg.packageName);
                        // Post process args
                        args.doPostInstall(PackageManager.INSTALL_SUCCEEDED, pkg.applicationInfo.uid);
                    }
                } else {
                    Slog.i(TAG, "Failed to install pkg from  " + codePath + " from sdcard");
                }
            }
        } finally {
            if (retCode != PackageManager.INSTALL_SUCCEEDED) {
                Log.w(TAG, "Container " + args.cid + " is stale, retCode=" + retCode);
            }
        }
    }
    // writer
    synchronized (mPackages) {
        // If the platform SDK has changed since the last time we booted,
        // we need to re-grant app permission to catch any new ones that
        // appear. This is really a hack, and means that apps can in some
        // cases get permissions that the user didn't initially explicitly
        // allow... it would be nice to have some better way to handle
        // this situation.
        final VersionInfo ver = externalStorage ? mSettings.getExternalVersion() : mSettings.getInternalVersion();
        final String volumeUuid = externalStorage ? StorageManager.UUID_PRIMARY_PHYSICAL : StorageManager.UUID_PRIVATE_INTERNAL;
        int updateFlags = UPDATE_PERMISSIONS_ALL;
        if (ver.sdkVersion != mSdkVersion) {
            logCriticalInfo(Log.INFO, "Platform changed from " + ver.sdkVersion + " to " + mSdkVersion + "; regranting permissions for external");
            updateFlags |= UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;
        }
        updatePermissionsLPw(null, null, volumeUuid, updateFlags);
        // Yay, everything is now upgraded
        ver.forceCurrent();
        // can downgrade to reader
        // Persist settings
        mSettings.writeLPr();
    }
    // Send a broadcast to let everyone know we are done processing
    if (pkgList.size() > 0) {
        sendResourcesChangedBroadcast(true, false, pkgList, uidArr, null);
    }
}
#end_block

#method_before
private void unloadMediaPackages(ArrayMap<AsecInstallArgs, String> processCids, int[] uidArr, final boolean reportStatus) {
    if (DEBUG_SD_INSTALL)
        Log.i(TAG, "unloading media packages");
    ArrayList<String> pkgList = new ArrayList<String>();
    ArrayList<AsecInstallArgs> failedList = new ArrayList<AsecInstallArgs>();
    final Set<AsecInstallArgs> keys = processCids.keySet();
    for (AsecInstallArgs args : keys) {
        String pkgName = args.getPackageName();
        if (DEBUG_SD_INSTALL)
            Log.i(TAG, "Trying to unload pkg : " + pkgName);
        // Delete package internally
        PackageRemovedInfo outInfo = new PackageRemovedInfo();
        synchronized (mInstallLock) {
            boolean res = deletePackageLI(pkgName, null, false, null, null, PackageManager.DELETE_KEEP_DATA, outInfo, false);
            if (res) {
                pkgList.add(pkgName);
            } else {
                Slog.e(TAG, "Failed to delete pkg from sdcard : " + pkgName);
                failedList.add(args);
            }
        }
    }
    // reader
    synchronized (mPackages) {
        // We didn't update the settings after removing each package;
        // write them now for all packages.
        mSettings.writeLPr();
    }
    // and unload all the containers.
    if (pkgList.size() > 0) {
        sendResourcesChangedBroadcast(false, false, pkgList, uidArr, new IIntentReceiver.Stub() {

            public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) throws RemoteException {
                Message msg = mHandler.obtainMessage(UPDATED_MEDIA_STATUS, reportStatus ? 1 : 0, 1, keys);
                mHandler.sendMessage(msg);
            }
        });
    } else {
        Message msg = mHandler.obtainMessage(UPDATED_MEDIA_STATUS, reportStatus ? 1 : 0, -1, keys);
        mHandler.sendMessage(msg);
    }
}
#method_after
private void unloadMediaPackages(ArrayMap<AsecInstallArgs, String> processCids, int[] uidArr, final boolean reportStatus) {
    if (DEBUG_SD_INSTALL)
        Log.i(TAG, "unloading media packages");
    ArrayList<String> pkgList = new ArrayList<String>();
    ArrayList<AsecInstallArgs> failedList = new ArrayList<AsecInstallArgs>();
    final Set<AsecInstallArgs> keys = processCids.keySet();
    for (AsecInstallArgs args : keys) {
        String pkgName = args.getPackageName();
        if (DEBUG_SD_INSTALL)
            Log.i(TAG, "Trying to unload pkg : " + pkgName);
        // Delete package internally
        PackageRemovedInfo outInfo = new PackageRemovedInfo();
        synchronized (mInstallLock) {
            final int deleteFlags = PackageManager.DELETE_KEEP_DATA;
            final boolean res;
            try (PackageFreezer freezer = freezePackageForDelete(pkgName, deleteFlags, "unloadMediaPackages")) {
                res = deletePackageLIF(pkgName, null, false, null, deleteFlags, outInfo, false, null);
            }
            if (res) {
                pkgList.add(pkgName);
            } else {
                Slog.e(TAG, "Failed to delete pkg from sdcard : " + pkgName);
                failedList.add(args);
            }
        }
    }
    // reader
    synchronized (mPackages) {
        // We didn't update the settings after removing each package;
        // write them now for all packages.
        mSettings.writeLPr();
    }
    // and unload all the containers.
    if (pkgList.size() > 0) {
        sendResourcesChangedBroadcast(false, false, pkgList, uidArr, new IIntentReceiver.Stub() {

            public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) throws RemoteException {
                Message msg = mHandler.obtainMessage(UPDATED_MEDIA_STATUS, reportStatus ? 1 : 0, 1, keys);
                mHandler.sendMessage(msg);
            }
        });
    } else {
        Message msg = mHandler.obtainMessage(UPDATED_MEDIA_STATUS, reportStatus ? 1 : 0, -1, keys);
        mHandler.sendMessage(msg);
    }
}
#end_block

#method_before
private void loadPrivatePackagesInner(VolumeInfo vol) {
    final ArrayList<ApplicationInfo> loaded = new ArrayList<>();
    final int parseFlags = mDefParseFlags | PackageParser.PARSE_EXTERNAL_STORAGE;
    final VersionInfo ver;
    final List<PackageSetting> packages;
    synchronized (mPackages) {
        ver = mSettings.findOrCreateVersion(vol.fsUuid);
        packages = mSettings.getVolumePackagesLPr(vol.fsUuid);
    }
    for (PackageSetting ps : packages) {
        synchronized (mInstallLock) {
            final PackageParser.Package pkg;
            try {
                pkg = scanPackageLI(ps.codePath, parseFlags, SCAN_INITIAL, 0L, null);
                loaded.add(pkg.applicationInfo);
            } catch (PackageManagerException e) {
                Slog.w(TAG, "Failed to scan " + ps.codePath + ": " + e.getMessage());
            }
            if (!Build.FINGERPRINT.equals(ver.fingerprint)) {
                deleteCodeCacheDirsLI(ps.volumeUuid, ps.name);
            }
        }
    }
    synchronized (mPackages) {
        int updateFlags = UPDATE_PERMISSIONS_ALL;
        if (ver.sdkVersion != mSdkVersion) {
            logCriticalInfo(Log.INFO, "Platform changed from " + ver.sdkVersion + " to " + mSdkVersion + "; regranting permissions for " + vol.fsUuid);
            updateFlags |= UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;
        }
        updatePermissionsLPw(null, null, vol.fsUuid, updateFlags);
        // Yay, everything is now upgraded
        ver.forceCurrent();
        mSettings.writeLPr();
    }
    if (DEBUG_INSTALL)
        Slog.d(TAG, "Loaded packages " + loaded);
    sendResourcesChangedBroadcast(true, false, loaded, null);
}
#method_after
private void loadPrivatePackagesInner(VolumeInfo vol) {
    final String volumeUuid = vol.fsUuid;
    if (TextUtils.isEmpty(volumeUuid)) {
        Slog.e(TAG, "Loading internal storage is probably a mistake; ignoring");
        return;
    }
    final ArrayList<PackageFreezer> freezers = new ArrayList<>();
    final ArrayList<ApplicationInfo> loaded = new ArrayList<>();
    final int parseFlags = mDefParseFlags | PackageParser.PARSE_EXTERNAL_STORAGE;
    final VersionInfo ver;
    final List<PackageSetting> packages;
    synchronized (mPackages) {
        ver = mSettings.findOrCreateVersion(volumeUuid);
        packages = mSettings.getVolumePackagesLPr(volumeUuid);
    }
    for (PackageSetting ps : packages) {
        freezers.add(freezePackage(ps.name, "loadPrivatePackagesInner"));
        synchronized (mInstallLock) {
            final PackageParser.Package pkg;
            try {
                pkg = scanPackageTracedLI(ps.codePath, parseFlags, SCAN_INITIAL, 0, null);
                loaded.add(pkg.applicationInfo);
            } catch (PackageManagerException e) {
                Slog.w(TAG, "Failed to scan " + ps.codePath + ": " + e.getMessage());
            }
            if (!Build.FINGERPRINT.equals(ver.fingerprint)) {
                clearAppDataLIF(ps.pkg, UserHandle.USER_ALL, StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE | Installer.FLAG_CLEAR_CODE_CACHE_ONLY);
            }
        }
    }
    // Reconcile app data for all started/unlocked users
    final StorageManager sm = mContext.getSystemService(StorageManager.class);
    final UserManager um = mContext.getSystemService(UserManager.class);
    UserManagerInternal umInternal = getUserManagerInternal();
    for (UserInfo user : um.getUsers()) {
        final int flags;
        if (umInternal.isUserUnlockingOrUnlocked(user.id)) {
            flags = StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE;
        } else if (umInternal.isUserRunning(user.id)) {
            flags = StorageManager.FLAG_STORAGE_DE;
        } else {
            continue;
        }
        try {
            sm.prepareUserStorage(volumeUuid, user.id, user.serialNumber, flags);
            synchronized (mInstallLock) {
                reconcileAppsDataLI(volumeUuid, user.id, flags);
            }
        } catch (IllegalStateException e) {
            // Device was probably ejected, and we'll process that event momentarily
            Slog.w(TAG, "Failed to prepare storage: " + e);
        }
    }
    synchronized (mPackages) {
        int updateFlags = UPDATE_PERMISSIONS_ALL;
        if (ver.sdkVersion != mSdkVersion) {
            logCriticalInfo(Log.INFO, "Platform changed from " + ver.sdkVersion + " to " + mSdkVersion + "; regranting permissions for " + volumeUuid);
            updateFlags |= UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;
        }
        updatePermissionsLPw(null, null, volumeUuid, updateFlags);
        // Yay, everything is now upgraded
        ver.forceCurrent();
        mSettings.writeLPr();
    }
    for (PackageFreezer freezer : freezers) {
        freezer.close();
    }
    if (DEBUG_INSTALL)
        Slog.d(TAG, "Loaded packages " + loaded);
    sendResourcesChangedBroadcast(true, false, loaded, null);
}
#end_block

#method_before
private void unloadPrivatePackagesInner(VolumeInfo vol) {
    final ArrayList<ApplicationInfo> unloaded = new ArrayList<>();
    synchronized (mInstallLock) {
        synchronized (mPackages) {
            final List<PackageSetting> packages = mSettings.getVolumePackagesLPr(vol.fsUuid);
            for (PackageSetting ps : packages) {
                if (ps.pkg == null)
                    continue;
                final ApplicationInfo info = ps.pkg.applicationInfo;
                final PackageRemovedInfo outInfo = new PackageRemovedInfo();
                if (deletePackageLI(ps.name, null, false, null, null, PackageManager.DELETE_KEEP_DATA, outInfo, false)) {
                    unloaded.add(info);
                } else {
                    Slog.w(TAG, "Failed to unload " + ps.codePath);
                }
            }
            mSettings.writeLPr();
        }
    }
    if (DEBUG_INSTALL)
        Slog.d(TAG, "Unloaded packages " + unloaded);
    sendResourcesChangedBroadcast(false, false, unloaded, null);
}
#method_after
private void unloadPrivatePackagesInner(VolumeInfo vol) {
    final String volumeUuid = vol.fsUuid;
    if (TextUtils.isEmpty(volumeUuid)) {
        Slog.e(TAG, "Unloading internal storage is probably a mistake; ignoring");
        return;
    }
    final ArrayList<ApplicationInfo> unloaded = new ArrayList<>();
    synchronized (mInstallLock) {
        synchronized (mPackages) {
            final List<PackageSetting> packages = mSettings.getVolumePackagesLPr(volumeUuid);
            for (PackageSetting ps : packages) {
                if (ps.pkg == null)
                    continue;
                final ApplicationInfo info = ps.pkg.applicationInfo;
                final int deleteFlags = PackageManager.DELETE_KEEP_DATA;
                final PackageRemovedInfo outInfo = new PackageRemovedInfo();
                try (PackageFreezer freezer = freezePackageForDelete(ps.name, deleteFlags, "unloadPrivatePackagesInner")) {
                    if (deletePackageLIF(ps.name, null, false, null, deleteFlags, outInfo, false, null)) {
                        unloaded.add(info);
                    } else {
                        Slog.w(TAG, "Failed to unload " + ps.codePath);
                    }
                }
                // Try very hard to release any references to this package
                // so we don't risk the system server being killed due to
                // open FDs
                AttributeCache.instance().removePackage(ps.name);
            }
            mSettings.writeLPr();
        }
    }
    if (DEBUG_INSTALL)
        Slog.d(TAG, "Unloaded packages " + unloaded);
    sendResourcesChangedBroadcast(false, false, unloaded, null);
    // Try very hard to release any references to this path so we don't risk
    // the system server being killed due to open FDs
    ResourcesManager.getInstance().invalidatePath(vol.getPath().getAbsolutePath());
    for (int i = 0; i < 3; i++) {
        System.gc();
        System.runFinalization();
    }
}
#end_block

#method_before
private void reconcileUsers(String volumeUuid) {
    final File[] files = FileUtils.listFilesOrEmpty(Environment.getDataUserDirectory(volumeUuid));
    for (File file : files) {
        if (!file.isDirectory())
            continue;
        final int userId;
        final UserInfo info;
        try {
            userId = Integer.parseInt(file.getName());
            info = sUserManager.getUserInfo(userId);
        } catch (NumberFormatException e) {
            Slog.w(TAG, "Invalid user directory " + file);
            continue;
        }
        boolean destroyUser = false;
        if (info == null) {
            logCriticalInfo(Log.WARN, "Destroying user directory " + file + " because no matching user was found");
            destroyUser = true;
        } else {
            try {
                UserManagerService.enforceSerialNumber(file, info.serialNumber);
            } catch (IOException e) {
                logCriticalInfo(Log.WARN, "Destroying user directory " + file + " because we failed to enforce serial number: " + e);
                destroyUser = true;
            }
        }
        if (destroyUser) {
            synchronized (mInstallLock) {
                mInstaller.removeUserDataDirs(volumeUuid, userId);
            }
        }
    }
    final UserManager um = mContext.getSystemService(UserManager.class);
    for (UserInfo user : um.getUsers()) {
        final File userDir = Environment.getDataUserDirectory(volumeUuid, user.id);
        if (userDir.exists())
            continue;
        try {
            UserManagerService.prepareUserDirectory(mContext, volumeUuid, user.id);
            UserManagerService.enforceSerialNumber(userDir, user.serialNumber);
        } catch (IOException e) {
            Log.wtf(TAG, "Failed to create user directory on " + volumeUuid, e);
        }
    }
}
#method_after
private void reconcileUsers(String volumeUuid) {
    final List<File> files = new ArrayList<>();
    Collections.addAll(files, FileUtils.listFilesOrEmpty(Environment.getDataUserDeDirectory(volumeUuid)));
    Collections.addAll(files, FileUtils.listFilesOrEmpty(Environment.getDataUserCeDirectory(volumeUuid)));
    Collections.addAll(files, FileUtils.listFilesOrEmpty(Environment.getDataSystemDeDirectory()));
    Collections.addAll(files, FileUtils.listFilesOrEmpty(Environment.getDataSystemCeDirectory()));
    for (File file : files) {
        if (!file.isDirectory())
            continue;
        final int userId;
        final UserInfo info;
        try {
            userId = Integer.parseInt(file.getName());
            info = sUserManager.getUserInfo(userId);
        } catch (NumberFormatException e) {
            Slog.w(TAG, "Invalid user directory " + file);
            continue;
        }
        boolean destroyUser = false;
        if (info == null) {
            logCriticalInfo(Log.WARN, "Destroying user directory " + file + " because no matching user was found");
            destroyUser = true;
        } else if (!mOnlyCore) {
            try {
                UserManagerService.enforceSerialNumber(file, info.serialNumber);
            } catch (IOException e) {
                logCriticalInfo(Log.WARN, "Destroying user directory " + file + " because we failed to enforce serial number: " + e);
                destroyUser = true;
            }
        }
        if (destroyUser) {
            synchronized (mInstallLock) {
                destroyUserDataLI(volumeUuid, userId, StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE);
            }
        }
    }
}
#end_block

#method_before
private void reconcileApps(String volumeUuid) {
    final File[] files = FileUtils.listFilesOrEmpty(Environment.getDataAppDirectory(volumeUuid));
    for (File file : files) {
        final boolean isPackage = (isApkFile(file) || file.isDirectory()) && !PackageInstallerService.isStageName(file.getName());
        if (!isPackage) {
            // Ignore entries which are not packages
            continue;
        }
        boolean destroyApp = false;
        String packageName = null;
        try {
            final PackageLite pkg = PackageParser.parsePackageLite(file, PackageParser.PARSE_MUST_BE_APK);
            packageName = pkg.packageName;
            synchronized (mPackages) {
                final PackageSetting ps = mSettings.mPackages.get(packageName);
                if (ps == null) {
                    logCriticalInfo(Log.WARN, "Destroying " + packageName + " on + " + volumeUuid + " because we found no install record");
                    destroyApp = true;
                } else if (!TextUtils.equals(volumeUuid, ps.volumeUuid)) {
                    logCriticalInfo(Log.WARN, "Destroying " + packageName + " on " + volumeUuid + " because we expected it on " + ps.volumeUuid);
                    destroyApp = true;
                }
            }
        } catch (PackageParserException e) {
            logCriticalInfo(Log.WARN, "Destroying " + file + " due to parse failure: " + e);
            destroyApp = true;
        }
        if (destroyApp) {
            synchronized (mInstallLock) {
                if (packageName != null) {
                    removeDataDirsLI(volumeUuid, packageName);
                }
                if (file.isDirectory()) {
                    mInstaller.rmPackageDir(file.getAbsolutePath());
                } else {
                    file.delete();
                }
            }
        }
    }
}
#method_after
private void reconcileApps(String volumeUuid) {
    final File[] files = FileUtils.listFilesOrEmpty(Environment.getDataAppDirectory(volumeUuid));
    for (File file : files) {
        final boolean isPackage = (isApkFile(file) || file.isDirectory()) && !PackageInstallerService.isStageName(file.getName());
        if (!isPackage) {
            // Ignore entries which are not packages
            continue;
        }
        try {
            final PackageLite pkg = PackageParser.parsePackageLite(file, PackageParser.PARSE_MUST_BE_APK);
            assertPackageKnown(volumeUuid, pkg.packageName);
        } catch (PackageParserException | PackageManagerException e) {
            logCriticalInfo(Log.WARN, "Destroying " + file + " due to: " + e);
            synchronized (mInstallLock) {
                removeCodePathLI(file);
            }
        }
    }
}
#end_block

#method_before
@Override
public int movePackage(final String packageName, final String volumeUuid) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MOVE_PACKAGE, null);
    final int moveId = mNextMoveId.getAndIncrement();
    mHandler.post(new Runnable() {

        @Override
        public void run() {
            try {
                movePackageInternal(packageName, volumeUuid, moveId);
            } catch (PackageManagerException e) {
                Slog.w(TAG, "Failed to move " + packageName, e);
                mMoveCallbacks.notifyStatusChanged(moveId, PackageManager.MOVE_FAILED_INTERNAL_ERROR);
            }
        }
    });
    return moveId;
}
#method_after
@Override
public int movePackage(final String packageName, final String volumeUuid) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MOVE_PACKAGE, null);
    final UserHandle user = new UserHandle(UserHandle.getCallingUserId());
    final int moveId = mNextMoveId.getAndIncrement();
    mHandler.post(new Runnable() {

        @Override
        public void run() {
            try {
                movePackageInternal(packageName, volumeUuid, moveId, user);
            } catch (PackageManagerException e) {
                Slog.w(TAG, "Failed to move " + packageName, e);
                mMoveCallbacks.notifyStatusChanged(moveId, PackageManager.MOVE_FAILED_INTERNAL_ERROR);
            }
        }
    });
    return moveId;
}
#end_block

#method_before
private void movePackageInternal(final String packageName, final String volumeUuid, final int moveId) throws PackageManagerException {
    final UserHandle user = new UserHandle(UserHandle.getCallingUserId());
    final StorageManager storage = mContext.getSystemService(StorageManager.class);
    final PackageManager pm = mContext.getPackageManager();
    final boolean currentAsec;
    final String currentVolumeUuid;
    final File codeFile;
    final String installerPackageName;
    final String packageAbiOverride;
    final int appId;
    final String seinfo;
    final String label;
    // reader
    synchronized (mPackages) {
        final PackageParser.Package pkg = mPackages.get(packageName);
        final PackageSetting ps = mSettings.mPackages.get(packageName);
        if (pkg == null || ps == null) {
            throw new PackageManagerException(MOVE_FAILED_DOESNT_EXIST, "Missing package");
        }
        if (pkg.applicationInfo.isSystemApp()) {
            throw new PackageManagerException(MOVE_FAILED_SYSTEM_PACKAGE, "Cannot move system application");
        }
        if (pkg.applicationInfo.isExternalAsec()) {
            currentAsec = true;
            currentVolumeUuid = StorageManager.UUID_PRIMARY_PHYSICAL;
        } else if (pkg.applicationInfo.isForwardLocked()) {
            currentAsec = true;
            currentVolumeUuid = "forward_locked";
        } else {
            currentAsec = false;
            currentVolumeUuid = ps.volumeUuid;
            final File probe = new File(pkg.codePath);
            final File probeOat = new File(probe, "oat");
            if (!probe.isDirectory() || !probeOat.isDirectory()) {
                throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR, "Move only supported for modern cluster style installs");
            }
        }
        if (Objects.equals(currentVolumeUuid, volumeUuid)) {
            throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR, "Package already moved to " + volumeUuid);
        }
        if (ps.frozen) {
            throw new PackageManagerException(MOVE_FAILED_OPERATION_PENDING, "Failed to move already frozen package");
        }
        ps.frozen = true;
        codeFile = new File(pkg.codePath);
        installerPackageName = ps.installerPackageName;
        packageAbiOverride = ps.cpuAbiOverrideString;
        appId = UserHandle.getAppId(pkg.applicationInfo.uid);
        seinfo = pkg.applicationInfo.seinfo;
        label = String.valueOf(pm.getApplicationLabel(pkg.applicationInfo));
    }
    // Now that we're guarded by frozen state, kill app during move
    final long token = Binder.clearCallingIdentity();
    try {
        killApplication(packageName, appId, "move pkg");
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    final Bundle extras = new Bundle();
    extras.putString(Intent.EXTRA_PACKAGE_NAME, packageName);
    extras.putString(Intent.EXTRA_TITLE, label);
    mMoveCallbacks.notifyCreated(moveId, extras);
    int installFlags;
    final boolean moveCompleteApp;
    final File measurePath;
    if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, volumeUuid)) {
        installFlags = INSTALL_INTERNAL;
        moveCompleteApp = !currentAsec;
        measurePath = Environment.getDataAppDirectory(volumeUuid);
    } else if (Objects.equals(StorageManager.UUID_PRIMARY_PHYSICAL, volumeUuid)) {
        installFlags = INSTALL_EXTERNAL;
        moveCompleteApp = false;
        measurePath = storage.getPrimaryPhysicalVolume().getPath();
    } else {
        final VolumeInfo volume = storage.findVolumeByUuid(volumeUuid);
        if (volume == null || volume.getType() != VolumeInfo.TYPE_PRIVATE || !volume.isMountedWritable()) {
            unfreezePackage(packageName);
            throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR, "Move location not mounted private volume");
        }
        Preconditions.checkState(!currentAsec);
        installFlags = INSTALL_INTERNAL;
        moveCompleteApp = true;
        measurePath = Environment.getDataAppDirectory(volumeUuid);
    }
    final PackageStats stats = new PackageStats(null, -1);
    synchronized (mInstaller) {
        if (!getPackageSizeInfoLI(packageName, -1, stats)) {
            unfreezePackage(packageName);
            throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR, "Failed to measure package size");
        }
    }
    if (DEBUG_INSTALL)
        Slog.d(TAG, "Measured code size " + stats.codeSize + ", data size " + stats.dataSize);
    final long startFreeBytes = measurePath.getFreeSpace();
    final long sizeBytes;
    if (moveCompleteApp) {
        sizeBytes = stats.codeSize + stats.dataSize;
    } else {
        sizeBytes = stats.codeSize;
    }
    if (sizeBytes > storage.getStorageBytesUntilLow(measurePath)) {
        unfreezePackage(packageName);
        throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR, "Not enough free space to move");
    }
    mMoveCallbacks.notifyStatusChanged(moveId, 10);
    final CountDownLatch installedLatch = new CountDownLatch(1);
    final IPackageInstallObserver2 installObserver = new IPackageInstallObserver2.Stub() {

        @Override
        public void onUserActionRequired(Intent intent) throws RemoteException {
            throw new IllegalStateException();
        }

        @Override
        public void onPackageInstalled(String basePackageName, int returnCode, String msg, Bundle extras) throws RemoteException {
            if (DEBUG_INSTALL)
                Slog.d(TAG, "Install result for move: " + PackageManager.installStatusToString(returnCode, msg));
            installedLatch.countDown();
            // Regardless of success or failure of the move operation,
            // always unfreeze the package
            unfreezePackage(packageName);
            final int status = PackageManager.installStatusToPublicStatus(returnCode);
            switch(status) {
                case PackageInstaller.STATUS_SUCCESS:
                    mMoveCallbacks.notifyStatusChanged(moveId, PackageManager.MOVE_SUCCEEDED);
                    break;
                case PackageInstaller.STATUS_FAILURE_STORAGE:
                    mMoveCallbacks.notifyStatusChanged(moveId, PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE);
                    break;
                default:
                    mMoveCallbacks.notifyStatusChanged(moveId, PackageManager.MOVE_FAILED_INTERNAL_ERROR);
                    break;
            }
        }
    };
    final MoveInfo move;
    if (moveCompleteApp) {
        // Kick off a thread to report progress estimates
        new Thread() {

            @Override
            public void run() {
                while (true) {
                    try {
                        if (installedLatch.await(1, TimeUnit.SECONDS)) {
                            break;
                        }
                    } catch (InterruptedException ignored) {
                    }
                    final long deltaFreeBytes = startFreeBytes - measurePath.getFreeSpace();
                    final int progress = 10 + (int) MathUtils.constrain(((deltaFreeBytes * 80) / sizeBytes), 0, 80);
                    mMoveCallbacks.notifyStatusChanged(moveId, progress);
                }
            }
        }.start();
        final String dataAppName = codeFile.getName();
        move = new MoveInfo(moveId, currentVolumeUuid, volumeUuid, packageName, dataAppName, appId, seinfo);
    } else {
        move = null;
    }
    installFlags |= PackageManager.INSTALL_REPLACE_EXISTING;
    final Message msg = mHandler.obtainMessage(INIT_COPY);
    final OriginInfo origin = OriginInfo.fromExistingFile(codeFile);
    msg.obj = new InstallParams(origin, move, installObserver, installFlags, installerPackageName, volumeUuid, null, user, packageAbiOverride, null);
    mHandler.sendMessage(msg);
}
#method_after
private void movePackageInternal(final String packageName, final String volumeUuid, final int moveId, UserHandle user) throws PackageManagerException {
    final StorageManager storage = mContext.getSystemService(StorageManager.class);
    final PackageManager pm = mContext.getPackageManager();
    final boolean currentAsec;
    final String currentVolumeUuid;
    final File codeFile;
    final String installerPackageName;
    final String packageAbiOverride;
    final int appId;
    final String seinfo;
    final String label;
    final int targetSdkVersion;
    final PackageFreezer freezer;
    final int[] installedUserIds;
    // reader
    synchronized (mPackages) {
        final PackageParser.Package pkg = mPackages.get(packageName);
        final PackageSetting ps = mSettings.mPackages.get(packageName);
        if (pkg == null || ps == null) {
            throw new PackageManagerException(MOVE_FAILED_DOESNT_EXIST, "Missing package");
        }
        if (pkg.applicationInfo.isSystemApp()) {
            throw new PackageManagerException(MOVE_FAILED_SYSTEM_PACKAGE, "Cannot move system application");
        }
        if (pkg.applicationInfo.isExternalAsec()) {
            currentAsec = true;
            currentVolumeUuid = StorageManager.UUID_PRIMARY_PHYSICAL;
        } else if (pkg.applicationInfo.isForwardLocked()) {
            currentAsec = true;
            currentVolumeUuid = "forward_locked";
        } else {
            currentAsec = false;
            currentVolumeUuid = ps.volumeUuid;
            final File probe = new File(pkg.codePath);
            final File probeOat = new File(probe, "oat");
            if (!probe.isDirectory() || !probeOat.isDirectory()) {
                throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR, "Move only supported for modern cluster style installs");
            }
        }
        if (Objects.equals(currentVolumeUuid, volumeUuid)) {
            throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR, "Package already moved to " + volumeUuid);
        }
        if (pkg.applicationInfo.isInternal() && isPackageDeviceAdminOnAnyUser(packageName)) {
            throw new PackageManagerException(MOVE_FAILED_DEVICE_ADMIN, "Device admin cannot be moved");
        }
        if (mFrozenPackages.contains(packageName)) {
            throw new PackageManagerException(MOVE_FAILED_OPERATION_PENDING, "Failed to move already frozen package");
        }
        codeFile = new File(pkg.codePath);
        installerPackageName = ps.installerPackageName;
        packageAbiOverride = ps.cpuAbiOverrideString;
        appId = UserHandle.getAppId(pkg.applicationInfo.uid);
        seinfo = pkg.applicationInfo.seinfo;
        label = String.valueOf(pm.getApplicationLabel(pkg.applicationInfo));
        targetSdkVersion = pkg.applicationInfo.targetSdkVersion;
        freezer = freezePackage(packageName, "movePackageInternal");
        installedUserIds = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
    }
    final Bundle extras = new Bundle();
    extras.putString(Intent.EXTRA_PACKAGE_NAME, packageName);
    extras.putString(Intent.EXTRA_TITLE, label);
    mMoveCallbacks.notifyCreated(moveId, extras);
    int installFlags;
    final boolean moveCompleteApp;
    final File measurePath;
    if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, volumeUuid)) {
        installFlags = INSTALL_INTERNAL;
        moveCompleteApp = !currentAsec;
        measurePath = Environment.getDataAppDirectory(volumeUuid);
    } else if (Objects.equals(StorageManager.UUID_PRIMARY_PHYSICAL, volumeUuid)) {
        installFlags = INSTALL_EXTERNAL;
        moveCompleteApp = false;
        measurePath = storage.getPrimaryPhysicalVolume().getPath();
    } else {
        final VolumeInfo volume = storage.findVolumeByUuid(volumeUuid);
        if (volume == null || volume.getType() != VolumeInfo.TYPE_PRIVATE || !volume.isMountedWritable()) {
            freezer.close();
            throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR, "Move location not mounted private volume");
        }
        Preconditions.checkState(!currentAsec);
        installFlags = INSTALL_INTERNAL;
        moveCompleteApp = true;
        measurePath = Environment.getDataAppDirectory(volumeUuid);
    }
    final PackageStats stats = new PackageStats(null, -1);
    synchronized (mInstaller) {
        for (int userId : installedUserIds) {
            if (!getPackageSizeInfoLI(packageName, userId, stats)) {
                freezer.close();
                throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR, "Failed to measure package size");
            }
        }
    }
    if (DEBUG_INSTALL)
        Slog.d(TAG, "Measured code size " + stats.codeSize + ", data size " + stats.dataSize);
    final long startFreeBytes = measurePath.getFreeSpace();
    final long sizeBytes;
    if (moveCompleteApp) {
        sizeBytes = stats.codeSize + stats.dataSize;
    } else {
        sizeBytes = stats.codeSize;
    }
    if (sizeBytes > storage.getStorageBytesUntilLow(measurePath)) {
        freezer.close();
        throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR, "Not enough free space to move");
    }
    mMoveCallbacks.notifyStatusChanged(moveId, 10);
    final CountDownLatch installedLatch = new CountDownLatch(1);
    final IPackageInstallObserver2 installObserver = new IPackageInstallObserver2.Stub() {

        @Override
        public void onUserActionRequired(Intent intent) throws RemoteException {
            throw new IllegalStateException();
        }

        @Override
        public void onPackageInstalled(String basePackageName, int returnCode, String msg, Bundle extras) throws RemoteException {
            if (DEBUG_INSTALL)
                Slog.d(TAG, "Install result for move: " + PackageManager.installStatusToString(returnCode, msg));
            installedLatch.countDown();
            freezer.close();
            final int status = PackageManager.installStatusToPublicStatus(returnCode);
            switch(status) {
                case PackageInstaller.STATUS_SUCCESS:
                    mMoveCallbacks.notifyStatusChanged(moveId, PackageManager.MOVE_SUCCEEDED);
                    break;
                case PackageInstaller.STATUS_FAILURE_STORAGE:
                    mMoveCallbacks.notifyStatusChanged(moveId, PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE);
                    break;
                default:
                    mMoveCallbacks.notifyStatusChanged(moveId, PackageManager.MOVE_FAILED_INTERNAL_ERROR);
                    break;
            }
        }
    };
    final MoveInfo move;
    if (moveCompleteApp) {
        // Kick off a thread to report progress estimates
        new Thread() {

            @Override
            public void run() {
                while (true) {
                    try {
                        if (installedLatch.await(1, TimeUnit.SECONDS)) {
                            break;
                        }
                    } catch (InterruptedException ignored) {
                    }
                    final long deltaFreeBytes = startFreeBytes - measurePath.getFreeSpace();
                    final int progress = 10 + (int) MathUtils.constrain(((deltaFreeBytes * 80) / sizeBytes), 0, 80);
                    mMoveCallbacks.notifyStatusChanged(moveId, progress);
                }
            }
        }.start();
        final String dataAppName = codeFile.getName();
        move = new MoveInfo(moveId, currentVolumeUuid, volumeUuid, packageName, dataAppName, appId, seinfo, targetSdkVersion);
    } else {
        move = null;
    }
    installFlags |= PackageManager.INSTALL_REPLACE_EXISTING;
    final Message msg = mHandler.obtainMessage(INIT_COPY);
    final OriginInfo origin = OriginInfo.fromExistingFile(codeFile);
    final InstallParams params = new InstallParams(origin, move, installObserver, installFlags, installerPackageName, volumeUuid, null, /*verificationInfo*/
    user, packageAbiOverride, null, /*grantedPermissions*/
    null);
    params.setTraceMethod("movePackage").setTraceCookie(System.identityHashCode(params));
    msg.obj = params;
    Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, "movePackage", System.identityHashCode(msg.obj));
    Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, "queueInstall", System.identityHashCode(msg.obj));
    mHandler.sendMessage(msg);
}
#end_block

#method_before
@Override
public KeySet getKeySetByAlias(String packageName, String alias) {
    if (packageName == null || alias == null) {
        return null;
    }
    synchronized (mPackages) {
        final PackageParser.Package pkg = mPackages.get(packageName);
        if (pkg == null) {
            Slog.w(TAG, "KeySet requested for unknown package:" + packageName);
            throw new IllegalArgumentException("Unknown package: " + packageName);
        }
        KeySetManagerService ksms = mSettings.mKeySetManagerService;
        return new KeySet(ksms.getKeySetByAliasAndPackageNameLPr(packageName, alias));
    }
}
#method_after
@Override
public KeySet getKeySetByAlias(String packageName, String alias) {
    if (packageName == null || alias == null) {
        return null;
    }
    synchronized (mPackages) {
        final PackageParser.Package pkg = mPackages.get(packageName);
        if (pkg == null) {
            Slog.w(TAG, "KeySet requested for unknown package: " + packageName);
            throw new IllegalArgumentException("Unknown package: " + packageName);
        }
        KeySetManagerService ksms = mSettings.mKeySetManagerService;
        return new KeySet(ksms.getKeySetByAliasAndPackageNameLPr(packageName, alias));
    }
}
#end_block

#method_before
@Override
public KeySet getSigningKeySet(String packageName) {
    if (packageName == null) {
        return null;
    }
    synchronized (mPackages) {
        final PackageParser.Package pkg = mPackages.get(packageName);
        if (pkg == null) {
            Slog.w(TAG, "KeySet requested for unknown package:" + packageName);
            throw new IllegalArgumentException("Unknown package: " + packageName);
        }
        if (pkg.applicationInfo.uid != Binder.getCallingUid() && Process.SYSTEM_UID != Binder.getCallingUid()) {
            throw new SecurityException("May not access signing KeySet of other apps.");
        }
        KeySetManagerService ksms = mSettings.mKeySetManagerService;
        return new KeySet(ksms.getSigningKeySetByPackageNameLPr(packageName));
    }
}
#method_after
@Override
public KeySet getSigningKeySet(String packageName) {
    if (packageName == null) {
        return null;
    }
    synchronized (mPackages) {
        final PackageParser.Package pkg = mPackages.get(packageName);
        if (pkg == null) {
            Slog.w(TAG, "KeySet requested for unknown package: " + packageName);
            throw new IllegalArgumentException("Unknown package: " + packageName);
        }
        if (pkg.applicationInfo.uid != Binder.getCallingUid() && Process.SYSTEM_UID != Binder.getCallingUid()) {
            throw new SecurityException("May not access signing KeySet of other apps.");
        }
        KeySetManagerService ksms = mSettings.mKeySetManagerService;
        return new KeySet(ksms.getSigningKeySetByPackageNameLPr(packageName));
    }
}
#end_block

#method_before
@Override
public boolean isPackageSignedByKeySet(String packageName, KeySet ks) {
    if (packageName == null || ks == null) {
        return false;
    }
    synchronized (mPackages) {
        final PackageParser.Package pkg = mPackages.get(packageName);
        if (pkg == null) {
            Slog.w(TAG, "KeySet requested for unknown package:" + packageName);
            throw new IllegalArgumentException("Unknown package: " + packageName);
        }
        IBinder ksh = ks.getToken();
        if (ksh instanceof KeySetHandle) {
            KeySetManagerService ksms = mSettings.mKeySetManagerService;
            return ksms.packageIsSignedByLPr(packageName, (KeySetHandle) ksh);
        }
        return false;
    }
}
#method_after
@Override
public boolean isPackageSignedByKeySet(String packageName, KeySet ks) {
    if (packageName == null || ks == null) {
        return false;
    }
    synchronized (mPackages) {
        final PackageParser.Package pkg = mPackages.get(packageName);
        if (pkg == null) {
            Slog.w(TAG, "KeySet requested for unknown package: " + packageName);
            throw new IllegalArgumentException("Unknown package: " + packageName);
        }
        IBinder ksh = ks.getToken();
        if (ksh instanceof KeySetHandle) {
            KeySetManagerService ksms = mSettings.mKeySetManagerService;
            return ksms.packageIsSignedByLPr(packageName, (KeySetHandle) ksh);
        }
        return false;
    }
}
#end_block

#method_before
@Override
public boolean isPackageSignedByKeySetExactly(String packageName, KeySet ks) {
    if (packageName == null || ks == null) {
        return false;
    }
    synchronized (mPackages) {
        final PackageParser.Package pkg = mPackages.get(packageName);
        if (pkg == null) {
            Slog.w(TAG, "KeySet requested for unknown package:" + packageName);
            throw new IllegalArgumentException("Unknown package: " + packageName);
        }
        IBinder ksh = ks.getToken();
        if (ksh instanceof KeySetHandle) {
            KeySetManagerService ksms = mSettings.mKeySetManagerService;
            return ksms.packageIsSignedByExactlyLPr(packageName, (KeySetHandle) ksh);
        }
        return false;
    }
}
#method_after
@Override
public boolean isPackageSignedByKeySetExactly(String packageName, KeySet ks) {
    if (packageName == null || ks == null) {
        return false;
    }
    synchronized (mPackages) {
        final PackageParser.Package pkg = mPackages.get(packageName);
        if (pkg == null) {
            Slog.w(TAG, "KeySet requested for unknown package: " + packageName);
            throw new IllegalArgumentException("Unknown package: " + packageName);
        }
        IBinder ksh = ks.getToken();
        if (ksh instanceof KeySetHandle) {
            KeySetManagerService ksms = mSettings.mKeySetManagerService;
            return ksms.packageIsSignedByExactlyLPr(packageName, (KeySetHandle) ksh);
        }
        return false;
    }
}
#end_block

#method_before
@Override
public void grantDefaultPermissionsToDefaultDialerApp(String packageName, int userId) {
    synchronized (mPackages) {
        mDefaultPermissionPolicy.grantDefaultPermissionsToDefaultDialerAppLPr(packageName, userId);
    }
}
#method_after
@Override
public void grantDefaultPermissionsToDefaultDialerApp(String packageName, int userId) {
    synchronized (mPackages) {
        mSettings.setDefaultDialerPackageNameLPw(packageName, userId);
        mDefaultPermissionPolicy.grantDefaultPermissionsToDefaultDialerAppLPr(packageName, userId);
    }
}
#end_block

#method_before
@Override
protected void checkSupportedKeySize(int keyLength) throws InvalidKeyException {
    switch(keyLength) {
        // AES 128
        case 16:
        case // AES 256
        32:
            return;
        default:
            throw new InvalidKeyException("Unsupported key size: " + keyLength + " bytes (must be 16 or 32)");
    }
}
#method_after
@Override
protected void checkSupportedKeySize(int keyLength) throws InvalidKeyException {
    switch(keyLength) {
        // AES 128
        case 16:
        // AES 192
        case 24:
        case // AES 256
        32:
            return;
        default:
            throw new InvalidKeyException("Unsupported key size: " + keyLength + " bytes");
    }
}
#end_block

#method_before
@Test
@TestInfo(id = "14578823")
public void installAppAndLaunch() throws Exception {
    Instrumentation instrumentation = testFramework.getInstrumentation();
    // Disable test for API 18. Enable when bug 30437951 is fixed.
    if (SystemUtil.getApiLevel() > 18) {
        AppLauncher.launch(instrumentation, "RsHelloCompute");
        assertTrue(testFramework.getDevice().findObject(new UiSelector().resourceId(Res.APP_IMAGE_VIEW_ID)).exists());
    }
}
#method_after
@Test
@TestInfo(id = "14578823")
public void installAppAndLaunch() throws Exception {
    Instrumentation instrumentation = testFramework.getInstrumentation();
    // Disable test for API 18. Enable when bug 30437951 is fixed.
    if (SystemUtil.getApiLevel() == 18) {
        return;
    }
    AppLauncher.launch(instrumentation, "RsHelloCompute");
    assertTrue(testFramework.getDevice().findObject(new UiSelector().resourceId(Res.APP_IMAGE_VIEW_ID)).exists());
}
#end_block

#method_before
@Test
@TestInfo(id = "14578822")
public void testVpn() throws Exception {
    Instrumentation instrumentation = testFramework.getInstrumentation();
    UiDevice device = testFramework.getDevice();
    // Disable test for API 19. Enable when bug 30376641 is fixed.
    if (SystemUtil.getApiLevel() != 19) {
        // Check if VPN is on. If true, skip.
        if (!verifyVpnStatus(device)) {
            AppLauncher.launch(instrumentation, "TestVPN");
            device.findObject(new UiSelector().resourceId(Res.START_VPN_BUTTON_RES)).clickAndWaitForNewWindow();
            new VpnPopupWatcher(device).checkForCondition();
            Assert.assertTrue("Failed to find the VPN lock icon after starting VPN!", verifyVpnStatus(device));
        }
    }
}
#method_after
@Test
@TestInfo(id = "14578822")
public void testVpn() throws Exception {
    Instrumentation instrumentation = testFramework.getInstrumentation();
    UiDevice device = testFramework.getDevice();
    // Disable test for API 19. Enable when bug 30376641 is fixed.
    if (SystemUtil.getApiLevel() == 19) {
        return;
    }
    // Check if VPN is on. If true, skip.
    if (!verifyVpnStatus(device)) {
        AppLauncher.launch(instrumentation, "TestVPN");
        device.findObject(new UiSelector().resourceId(Res.START_VPN_BUTTON_RES)).clickAndWaitForNewWindow();
        new VpnPopupWatcher(device).checkForCondition();
        Assert.assertTrue("Failed to find the VPN lock icon after starting VPN!", verifyVpnStatus(device));
    }
}
#end_block

#method_before
private void verifyScan(int band, int reportEvents, Set<Integer> configuredNetworkIds) {
    ArgumentCaptor<WifiScanner.ScanSettings> scanSettingsCaptor = ArgumentCaptor.forClass(WifiScanner.ScanSettings.class);
    ArgumentCaptor<WifiScanner.ScanListener> scanListenerCaptor = ArgumentCaptor.forClass(WifiScanner.ScanListener.class);
    verify(mWifiScanner).startScan(scanSettingsCaptor.capture(), scanListenerCaptor.capture(), eq(null));
    WifiScanner.ScanSettings actualSettings = scanSettingsCaptor.getValue();
    assertEquals("band", band, actualSettings.band);
    assertEquals("reportEvents", reportEvents, actualSettings.reportEvents);
    if (configuredNetworkIds == null) {
        configuredNetworkIds = new HashSet<>();
    }
    Set<Integer> actualConfiguredNetworkIds = new HashSet<>();
    if (actualSettings.hiddenNetworkIds != null) {
        for (int i = 0; i < actualSettings.hiddenNetworkIds.length; ++i) {
            actualConfiguredNetworkIds.add(actualSettings.hiddenNetworkIds[i]);
        }
    }
    assertEquals("configured networks", configuredNetworkIds, actualConfiguredNetworkIds);
    when(mWifiNative.getScanResults()).thenReturn(getMockScanResults());
    mWsm.sendMessage(WifiMonitor.SCAN_RESULTS_EVENT);
    mLooper.dispatchAll();
    List<ScanResult> reportedResults = mWsm.syncGetScanResultsList();
    assertEquals(8, reportedResults.size());
}
#method_after
private void verifyScan(int band, int reportEvents, Set<String> hiddenNetworkSSIDSet) {
    ArgumentCaptor<WifiScanner.ScanSettings> scanSettingsCaptor = ArgumentCaptor.forClass(WifiScanner.ScanSettings.class);
    ArgumentCaptor<WifiScanner.ScanListener> scanListenerCaptor = ArgumentCaptor.forClass(WifiScanner.ScanListener.class);
    verify(mWifiScanner).startScan(scanSettingsCaptor.capture(), scanListenerCaptor.capture(), eq(null));
    WifiScanner.ScanSettings actualSettings = scanSettingsCaptor.getValue();
    assertEquals("band", band, actualSettings.band);
    assertEquals("reportEvents", reportEvents, actualSettings.reportEvents);
    if (hiddenNetworkSSIDSet == null) {
        hiddenNetworkSSIDSet = new HashSet<>();
    }
    Set<String> actualHiddenNetworkSSIDSet = new HashSet<>();
    if (actualSettings.hiddenNetworks != null) {
        for (int i = 0; i < actualSettings.hiddenNetworks.length; ++i) {
            actualHiddenNetworkSSIDSet.add(actualSettings.hiddenNetworks[i].ssid);
        }
    }
    assertEquals("hidden networks", hiddenNetworkSSIDSet, actualHiddenNetworkSSIDSet);
    when(mWifiNative.getScanResults()).thenReturn(getMockScanResults());
    mWsm.sendMessage(WifiMonitor.SCAN_RESULTS_EVENT);
    mLooper.dispatchAll();
    List<ScanResult> reportedResults = mWsm.syncGetScanResultsList();
    assertEquals(8, reportedResults.size());
}
#end_block

#method_before
@Test
public void scanWithHiddenNetwork() throws Exception {
    addNetworkAndVerifySuccess(true);
    mWsm.setOperationalMode(WifiStateMachine.CONNECT_MODE);
    mWsm.startScan(-1, 0, null, null);
    mLooper.dispatchAll();
    // TODO(b/29503772): Retrieve the list of hidden networks to scan for.
    verifyScan(WifiScanner.WIFI_BAND_BOTH_WITH_DFS, WifiScanner.REPORT_EVENT_AFTER_EACH_SCAN | WifiScanner.REPORT_EVENT_FULL_SCAN_RESULT, null);
}
#method_after
@Test
public void scanWithHiddenNetwork() throws Exception {
    addNetworkAndVerifySuccess(true);
    Set<String> hiddenNetworkSet = new HashSet<>();
    hiddenNetworkSet.add(sSSID);
    List<WifiScanner.ScanSettings.HiddenNetwork> hiddenNetworkList = new ArrayList<>();
    hiddenNetworkList.add(new WifiScanner.ScanSettings.HiddenNetwork(sSSID));
    when(mWifiConfigManager.retrieveHiddenNetworkList()).thenReturn(hiddenNetworkList);
    mWsm.setOperationalMode(WifiStateMachine.CONNECT_MODE);
    mWsm.startScan(-1, 0, null, null);
    mLooper.dispatchAll();
    verifyScan(WifiScanner.WIFI_BAND_BOTH_WITH_DFS, WifiScanner.REPORT_EVENT_AFTER_EACH_SCAN | WifiScanner.REPORT_EVENT_FULL_SCAN_RESULT, hiddenNetworkSet);
}
#end_block

#method_before
private void handleScanRequest(Message message) {
    ScanSettings settings = null;
    WorkSource workSource = null;
    // unbundle parameters
    Bundle bundle = (Bundle) message.obj;
    if (bundle != null) {
        settings = bundle.getParcelable(CUSTOMIZED_SCAN_SETTING);
        workSource = bundle.getParcelable(CUSTOMIZED_SCAN_WORKSOURCE);
    }
    Set<Integer> freqs = null;
    if (settings != null && settings.channelSet != null) {
        freqs = new HashSet<>();
        for (WifiChannel channel : settings.channelSet) {
            freqs.add(channel.freqMHz);
        }
    }
    // Retrieve the list of hidden networkId's to scan for.
    // TODO(b/29503772)
    Set<Integer> hiddenNetworkIds = new HashSet<>();
    // call wifi native to start the scan
    if (startScanNative(freqs, hiddenNetworkIds, workSource)) {
        // a full scan covers everything, clearing scan request buffer
        if (freqs == null)
            mBufferedScanMsg.clear();
        messageHandlingStatus = MESSAGE_HANDLING_STATUS_OK;
        if (workSource != null) {
            // External worksource was passed along the scan request,
            // hence always send a broadcast
            mSendScanResultsBroadcast = true;
        }
        return;
    }
    if (!mIsScanOngoing) {
        // discard this request and pop up the next one
        if (mBufferedScanMsg.size() > 0) {
            sendMessage(mBufferedScanMsg.remove());
        }
        messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
    } else if (!mIsFullScanOngoing) {
        // buffer the scan request to make sure specified channels will be scanned eventually
        if (freqs == null)
            mBufferedScanMsg.clear();
        if (mBufferedScanMsg.size() < SCAN_REQUEST_BUFFER_MAX_SIZE) {
            Message msg = obtainMessage(CMD_START_SCAN, message.arg1, message.arg2, bundle);
            mBufferedScanMsg.add(msg);
        } else {
            // if too many requests in buffer, combine them into a single full scan
            bundle = new Bundle();
            bundle.putParcelable(CUSTOMIZED_SCAN_SETTING, null);
            bundle.putParcelable(CUSTOMIZED_SCAN_WORKSOURCE, workSource);
            Message msg = obtainMessage(CMD_START_SCAN, message.arg1, message.arg2, bundle);
            mBufferedScanMsg.clear();
            mBufferedScanMsg.add(msg);
        }
        messageHandlingStatus = MESSAGE_HANDLING_STATUS_LOOPED;
    } else {
        // mIsScanOngoing and mIsFullScanOngoing
        messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
    }
}
#method_after
private void handleScanRequest(Message message) {
    ScanSettings settings = null;
    WorkSource workSource = null;
    // unbundle parameters
    Bundle bundle = (Bundle) message.obj;
    if (bundle != null) {
        settings = bundle.getParcelable(CUSTOMIZED_SCAN_SETTING);
        workSource = bundle.getParcelable(CUSTOMIZED_SCAN_WORKSOURCE);
    }
    Set<Integer> freqs = null;
    if (settings != null && settings.channelSet != null) {
        freqs = new HashSet<>();
        for (WifiChannel channel : settings.channelSet) {
            freqs.add(channel.freqMHz);
        }
    }
    // Retrieve the list of hidden network SSIDs to scan for.
    List<WifiScanner.ScanSettings.HiddenNetwork> hiddenNetworks = mWifiConfigManager.retrieveHiddenNetworkList();
    // call wifi native to start the scan
    if (startScanNative(freqs, hiddenNetworks, workSource)) {
        // a full scan covers everything, clearing scan request buffer
        if (freqs == null)
            mBufferedScanMsg.clear();
        messageHandlingStatus = MESSAGE_HANDLING_STATUS_OK;
        return;
    }
    if (!mIsScanOngoing) {
        // discard this request and pop up the next one
        if (mBufferedScanMsg.size() > 0) {
            sendMessage(mBufferedScanMsg.remove());
        }
        messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
    } else if (!mIsFullScanOngoing) {
        // buffer the scan request to make sure specified channels will be scanned eventually
        if (freqs == null)
            mBufferedScanMsg.clear();
        if (mBufferedScanMsg.size() < SCAN_REQUEST_BUFFER_MAX_SIZE) {
            Message msg = obtainMessage(CMD_START_SCAN, message.arg1, message.arg2, bundle);
            mBufferedScanMsg.add(msg);
        } else {
            // if too many requests in buffer, combine them into a single full scan
            bundle = new Bundle();
            bundle.putParcelable(CUSTOMIZED_SCAN_SETTING, null);
            bundle.putParcelable(CUSTOMIZED_SCAN_WORKSOURCE, workSource);
            Message msg = obtainMessage(CMD_START_SCAN, message.arg1, message.arg2, bundle);
            mBufferedScanMsg.clear();
            mBufferedScanMsg.add(msg);
        }
        messageHandlingStatus = MESSAGE_HANDLING_STATUS_LOOPED;
    } else {
        // mIsScanOngoing and mIsFullScanOngoing
        messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
    }
}
#end_block

#method_before
// TODO this is a temporary measure to bridge between WifiScanner and WifiStateMachine until
// scan functionality is refactored out of WifiStateMachine.
private boolean startScanNative(final Set<Integer> freqs, Set<Integer> hiddenNetworkIds, WorkSource workSource) {
    WifiScanner.ScanSettings settings = new WifiScanner.ScanSettings();
    if (freqs == null) {
        settings.band = WifiScanner.WIFI_BAND_BOTH_WITH_DFS;
    } else {
        settings.band = WifiScanner.WIFI_BAND_UNSPECIFIED;
        int index = 0;
        settings.channels = new WifiScanner.ChannelSpec[freqs.size()];
        for (Integer freq : freqs) {
            settings.channels[index++] = new WifiScanner.ChannelSpec(freq);
        }
    }
    settings.reportEvents = WifiScanner.REPORT_EVENT_AFTER_EACH_SCAN | WifiScanner.REPORT_EVENT_FULL_SCAN_RESULT;
    if (hiddenNetworkIds != null && hiddenNetworkIds.size() > 0) {
        int i = 0;
        settings.hiddenNetworkIds = new int[hiddenNetworkIds.size()];
        for (Integer netId : hiddenNetworkIds) {
            settings.hiddenNetworkIds[i++] = netId;
        }
    }
    WifiScanner.ScanListener nativeScanListener = new WifiScanner.ScanListener() {

        // ignore all events since WifiStateMachine is registered for the supplicant events
        @Override
        public void onSuccess() {
        }

        @Override
        public void onFailure(int reason, String description) {
            mIsScanOngoing = false;
            mIsFullScanOngoing = false;
        }

        @Override
        public void onResults(WifiScanner.ScanData[] results) {
        }

        @Override
        public void onFullResult(ScanResult fullScanResult) {
        }

        @Override
        public void onPeriodChanged(int periodInMs) {
        }
    };
    mWifiScanner.startScan(settings, nativeScanListener, workSource);
    mIsScanOngoing = true;
    mIsFullScanOngoing = (freqs == null);
    lastScanFreqs = freqs;
    return true;
}
#method_after
// TODO this is a temporary measure to bridge between WifiScanner and WifiStateMachine until
// scan functionality is refactored out of WifiStateMachine.
private boolean startScanNative(final Set<Integer> freqs, List<WifiScanner.ScanSettings.HiddenNetwork> hiddenNetworkList, WorkSource workSource) {
    WifiScanner.ScanSettings settings = new WifiScanner.ScanSettings();
    if (freqs == null) {
        settings.band = WifiScanner.WIFI_BAND_BOTH_WITH_DFS;
    } else {
        settings.band = WifiScanner.WIFI_BAND_UNSPECIFIED;
        int index = 0;
        settings.channels = new WifiScanner.ChannelSpec[freqs.size()];
        for (Integer freq : freqs) {
            settings.channels[index++] = new WifiScanner.ChannelSpec(freq);
        }
    }
    settings.reportEvents = WifiScanner.REPORT_EVENT_AFTER_EACH_SCAN | WifiScanner.REPORT_EVENT_FULL_SCAN_RESULT;
    settings.hiddenNetworks = hiddenNetworkList.toArray(new WifiScanner.ScanSettings.HiddenNetwork[hiddenNetworkList.size()]);
    WifiScanner.ScanListener nativeScanListener = new WifiScanner.ScanListener() {

        // ignore all events since WifiStateMachine is registered for the supplicant events
        @Override
        public void onSuccess() {
        }

        @Override
        public void onFailure(int reason, String description) {
            mIsScanOngoing = false;
            mIsFullScanOngoing = false;
        }

        @Override
        public void onResults(WifiScanner.ScanData[] results) {
        }

        @Override
        public void onFullResult(ScanResult fullScanResult) {
        }

        @Override
        public void onPeriodChanged(int periodInMs) {
        }
    };
    mWifiScanner.startScan(settings, nativeScanListener, workSource);
    mIsScanOngoing = true;
    mIsFullScanOngoing = (freqs == null);
    lastScanFreqs = freqs;
    return true;
}
#end_block

#method_before
private void fetchPktcntNative(RssiPacketCountInfo info) {
    String pktcntPoll = mWifiNative.pktcntPoll();
    if (pktcntPoll != null) {
        String[] lines = pktcntPoll.split("\n");
        for (String line : lines) {
            String[] prop = line.split("=");
            if (prop.length < 2)
                continue;
            try {
                if (prop[0].equals("TXGOOD")) {
                    info.txgood = Integer.parseInt(prop[1]);
                } else if (prop[0].equals("TXBAD")) {
                    info.txbad = Integer.parseInt(prop[1]);
                }
            } catch (NumberFormatException e) {
            // Ignore
            }
        }
    }
}
#method_after
private void fetchPktcntNative(RssiPacketCountInfo info) {
    int[] counters = null;
    try {
        counters = mClientInterface.getPacketCounters();
        if (counters == null || counters.length != 2) {
            return;
        }
    } catch (RemoteException e1) {
    }
    info.txgood = counters[0];
    info.txbad = counters[1];
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_STOP_SUPPLICANT:
            /* Supplicant stopped by user */
            if (mP2pSupported) {
                transitionTo(mWaitForP2pDisableState);
            } else {
                transitionTo(mSupplicantStoppingState);
            }
            break;
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
            /* Supplicant connection lost */
            loge("Connection lost, restart supplicant");
            handleSupplicantConnectionLoss(true);
            handleNetworkDisconnect();
            mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);
            if (mP2pSupported) {
                transitionTo(mWaitForP2pDisableState);
            } else {
                transitionTo(mInitialState);
            }
            sendMessageDelayed(CMD_START_SUPPLICANT, SUPPLICANT_RESTART_INTERVAL_MSECS);
            break;
        case CMD_START_SCAN:
            handleScanRequest(message);
            break;
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SCAN_FAILED_EVENT:
            // Make sure our NetworkFactory is registered
            maybeRegisterNetworkFactory();
            setScanResults();
            if (mIsFullScanOngoing || mSendScanResultsBroadcast) {
                /* Just updated results from full scan, let apps know about this */
                boolean scanSucceeded = message.what == WifiMonitor.SCAN_RESULTS_EVENT;
                sendScanResultsAvailableBroadcast(scanSucceeded);
            }
            mSendScanResultsBroadcast = false;
            mIsScanOngoing = false;
            mIsFullScanOngoing = false;
            if (mBufferedScanMsg.size() > 0)
                sendMessage(mBufferedScanMsg.remove());
            break;
        case CMD_PING_SUPPLICANT:
            boolean ok = mWifiNative.ping();
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_SET_FREQUENCY_BAND:
            int band = message.arg1;
            if (mVerboseLoggingEnabled)
                log("set frequency band " + band);
            if (mWifiNative.setBand(band)) {
                if (mVerboseLoggingEnabled)
                    logd("did set frequency band " + band);
                mFrequencyBand.set(band);
                // Flush old data - like scan results
                mWifiNative.bssFlush();
                if (mVerboseLoggingEnabled)
                    logd("done set frequency band " + band);
            } else {
                loge("Failed to set frequency band " + band);
            }
            break;
        case CMD_GET_CAPABILITY_FREQ:
            String freqs = mWifiNative.getFreqCapability();
            replyToMessage(message, message.what, freqs);
            break;
        case CMD_START_AP:
            /* Cannot start soft AP while in client mode */
            loge("Failed to start soft AP with a running supplicant");
            setWifiApState(WIFI_AP_STATE_FAILED, WifiManager.SAP_START_FAILURE_GENERAL);
            break;
        case CMD_SET_OPERATIONAL_MODE:
            mOperationalMode = message.arg1;
            if (mOperationalMode == DISABLED_MODE) {
                transitionTo(mSupplicantStoppingState);
            }
            break;
        case CMD_TARGET_BSSID:
            // Trying to associate to this BSSID
            if (message.obj != null) {
                mTargetRoamBSSID = (String) message.obj;
            }
            break;
        case CMD_GET_LINK_LAYER_STATS:
            WifiLinkLayerStats stats = getWifiLinkLayerStats();
            replyToMessage(message, message.what, stats);
            break;
        case CMD_RESET_SIM_NETWORKS:
            log("resetting EAP-SIM/AKA/AKA' networks since SIM was changed");
            mWifiConfigManager.resetSimNetworks();
            break;
        case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
            mBluetoothConnectionActive = (message.arg1 != BluetoothAdapter.STATE_DISCONNECTED);
            mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
            break;
        case CMD_SET_SUSPEND_OPT_ENABLED:
            if (message.arg1 == 1) {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_SCREEN, true);
                if (message.arg2 == 1) {
                    mSuspendWakeLock.release();
                }
            } else {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_SCREEN, false);
            }
            break;
        case CMD_SET_HIGH_PERF_MODE:
            if (message.arg1 == 1) {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_HIGH_PERF, false);
            } else {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_HIGH_PERF, true);
            }
            break;
        case CMD_ENABLE_TDLS:
            if (message.obj != null) {
                String remoteAddress = (String) message.obj;
                boolean enable = (message.arg1 == 1);
                mWifiNative.startTdls(remoteAddress, enable);
            }
            break;
        case WifiMonitor.ANQP_DONE_EVENT:
            // TODO(b/31065385)
            break;
        case CMD_STOP_IP_PACKET_OFFLOAD:
            {
                int slot = message.arg1;
                int ret = stopWifiIPPacketOffload(slot);
                if (mNetworkAgent != null) {
                    mNetworkAgent.onPacketKeepaliveEvent(slot, ret);
                }
                break;
            }
        case WifiMonitor.RX_HS20_ANQP_ICON_EVENT:
            // TODO(b/31065385)
            break;
        case WifiMonitor.HS20_REMEDIATION_EVENT:
            // TODO(b/31065385)
            break;
        case CMD_CONFIG_ND_OFFLOAD:
            final boolean enabled = (message.arg1 > 0);
            mWifiNative.configureNeighborDiscoveryOffload(enabled);
            break;
        case CMD_ENABLE_WIFI_CONNECTIVITY_MANAGER:
            if (mWifiConnectivityManager != null) {
                mWifiConnectivityManager.enable(message.arg1 == 1 ? true : false);
            }
            break;
        case CMD_ENABLE_AUTOJOIN_WHEN_ASSOCIATED:
            final boolean allowed = (message.arg1 > 0);
            boolean old_state = mEnableAutoJoinWhenAssociated;
            mEnableAutoJoinWhenAssociated = allowed;
            if (!old_state && allowed && mScreenOn && getCurrentState() == mConnectedState) {
                if (mWifiConnectivityManager != null) {
                    mWifiConnectivityManager.forceConnectivityScan();
                }
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_STOP_SUPPLICANT:
            /* Supplicant stopped by user */
            if (mP2pSupported) {
                transitionTo(mWaitForP2pDisableState);
            } else {
                transitionTo(mSupplicantStoppingState);
            }
            break;
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
            /* Supplicant connection lost */
            loge("Connection lost, restart supplicant");
            handleSupplicantConnectionLoss(true);
            handleNetworkDisconnect();
            mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);
            if (mP2pSupported) {
                transitionTo(mWaitForP2pDisableState);
            } else {
                transitionTo(mInitialState);
            }
            sendMessageDelayed(CMD_START_SUPPLICANT, SUPPLICANT_RESTART_INTERVAL_MSECS);
            break;
        case CMD_START_SCAN:
            // TODO: remove scan request path (b/31445200)
            handleScanRequest(message);
            break;
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SCAN_FAILED_EVENT:
            // TODO: remove handing of SCAN_RESULTS_EVENT and SCAN_FAILED_EVENT when scan
            // results are retrieved from WifiScanner (b/31444878)
            // Make sure our NetworkFactory is registered
            maybeRegisterNetworkFactory();
            setScanResults();
            mIsScanOngoing = false;
            mIsFullScanOngoing = false;
            if (mBufferedScanMsg.size() > 0)
                sendMessage(mBufferedScanMsg.remove());
            break;
        case CMD_PING_SUPPLICANT:
            boolean ok = mWifiNative.ping();
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_SET_FREQUENCY_BAND:
            int band = message.arg1;
            if (mVerboseLoggingEnabled)
                log("set frequency band " + band);
            if (mWifiNative.setBand(band)) {
                if (mVerboseLoggingEnabled)
                    logd("did set frequency band " + band);
                mFrequencyBand.set(band);
                // Flush old data - like scan results
                mWifiNative.bssFlush();
                if (mVerboseLoggingEnabled)
                    logd("done set frequency band " + band);
            } else {
                loge("Failed to set frequency band " + band);
            }
            break;
        case CMD_GET_CAPABILITY_FREQ:
            String freqs = mWifiNative.getFreqCapability();
            replyToMessage(message, message.what, freqs);
            break;
        case CMD_START_AP:
            /* Cannot start soft AP while in client mode */
            loge("Failed to start soft AP with a running supplicant");
            setWifiApState(WIFI_AP_STATE_FAILED, WifiManager.SAP_START_FAILURE_GENERAL);
            break;
        case CMD_SET_OPERATIONAL_MODE:
            mOperationalMode = message.arg1;
            if (mOperationalMode == DISABLED_MODE) {
                transitionTo(mSupplicantStoppingState);
            }
            break;
        case CMD_TARGET_BSSID:
            // Trying to associate to this BSSID
            if (message.obj != null) {
                mTargetRoamBSSID = (String) message.obj;
            }
            break;
        case CMD_GET_LINK_LAYER_STATS:
            WifiLinkLayerStats stats = getWifiLinkLayerStats();
            replyToMessage(message, message.what, stats);
            break;
        case CMD_RESET_SIM_NETWORKS:
            log("resetting EAP-SIM/AKA/AKA' networks since SIM was changed");
            mWifiConfigManager.resetSimNetworks();
            break;
        case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
            mBluetoothConnectionActive = (message.arg1 != BluetoothAdapter.STATE_DISCONNECTED);
            mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
            break;
        case CMD_SET_SUSPEND_OPT_ENABLED:
            if (message.arg1 == 1) {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_SCREEN, true);
                if (message.arg2 == 1) {
                    mSuspendWakeLock.release();
                }
            } else {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_SCREEN, false);
            }
            break;
        case CMD_SET_HIGH_PERF_MODE:
            if (message.arg1 == 1) {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_HIGH_PERF, false);
            } else {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_HIGH_PERF, true);
            }
            break;
        case CMD_ENABLE_TDLS:
            if (message.obj != null) {
                String remoteAddress = (String) message.obj;
                boolean enable = (message.arg1 == 1);
                mWifiNative.startTdls(remoteAddress, enable);
            }
            break;
        case WifiMonitor.ANQP_DONE_EVENT:
            // TODO(b/31065385)
            break;
        case CMD_STOP_IP_PACKET_OFFLOAD:
            {
                int slot = message.arg1;
                int ret = stopWifiIPPacketOffload(slot);
                if (mNetworkAgent != null) {
                    mNetworkAgent.onPacketKeepaliveEvent(slot, ret);
                }
                break;
            }
        case WifiMonitor.RX_HS20_ANQP_ICON_EVENT:
            // TODO(b/31065385)
            break;
        case WifiMonitor.HS20_REMEDIATION_EVENT:
            // TODO(b/31065385)
            break;
        case CMD_CONFIG_ND_OFFLOAD:
            final boolean enabled = (message.arg1 > 0);
            mWifiNative.configureNeighborDiscoveryOffload(enabled);
            break;
        case CMD_ENABLE_WIFI_CONNECTIVITY_MANAGER:
            if (mWifiConnectivityManager != null) {
                mWifiConnectivityManager.enable(message.arg1 == 1 ? true : false);
            }
            break;
        case CMD_ENABLE_AUTOJOIN_WHEN_ASSOCIATED:
            final boolean allowed = (message.arg1 > 0);
            boolean old_state = mEnableAutoJoinWhenAssociated;
            mEnableAutoJoinWhenAssociated = allowed;
            if (!old_state && allowed && mScreenOn && getCurrentState() == mConnectedState) {
                if (mWifiConnectivityManager != null) {
                    mWifiConnectivityManager.forceConnectivityScan();
                }
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
boolean startScanForConfiguration(WifiConfiguration config) {
    if (config == null)
        return false;
    // We are still seeing a fairly high power consumption triggered by autojoin scans
    // Hence do partial scans only for PSK configuration that are roamable since the
    // primary purpose of the partial scans is roaming.
    // Full badn scans with exponential backoff for the purpose or extended roaming and
    // network switching are performed unconditionally.
    ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(config.networkId);
    if (scanDetailCache == null || !config.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_PSK) || scanDetailCache.size() > 6) {
        // return true but to not trigger the scan
        return true;
    }
    Set<Integer> freqs = mWifiConfigManager.fetchChannelSetForNetworkForPartialScan(config.networkId, ONE_HOUR_MILLI);
    if (freqs != null && freqs.size() != 0) {
        // if (mVerboseLoggingEnabled) {
        logd("starting scan for " + config.configKey() + " with " + freqs);
        // }
        Set<Integer> hiddenNetworkIds = new HashSet<>();
        if (config.hiddenSSID) {
            hiddenNetworkIds.add(config.networkId);
        }
        // Call wifi native to start the scan
        if (startScanNative(freqs, hiddenNetworkIds, WIFI_WORK_SOURCE)) {
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_OK;
        } else {
            // used for debug only, mark scan as failed
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_HANDLING_ERROR;
        }
        return true;
    } else {
        if (mVerboseLoggingEnabled)
            logd("no channels for " + config.configKey());
        return false;
    }
}
#method_after
boolean startScanForConfiguration(WifiConfiguration config) {
    if (config == null)
        return false;
    // We are still seeing a fairly high power consumption triggered by autojoin scans
    // Hence do partial scans only for PSK configuration that are roamable since the
    // primary purpose of the partial scans is roaming.
    // Full badn scans with exponential backoff for the purpose or extended roaming and
    // network switching are performed unconditionally.
    ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(config.networkId);
    if (scanDetailCache == null || !config.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_PSK) || scanDetailCache.size() > 6) {
        // return true but to not trigger the scan
        return true;
    }
    Set<Integer> freqs = mWifiConfigManager.fetchChannelSetForNetworkForPartialScan(config.networkId, ONE_HOUR_MILLI);
    if (freqs != null && freqs.size() != 0) {
        // if (mVerboseLoggingEnabled) {
        logd("starting scan for " + config.configKey() + " with " + freqs);
        // }
        List<WifiScanner.ScanSettings.HiddenNetwork> hiddenNetworks = new ArrayList<>();
        if (config.hiddenSSID) {
            hiddenNetworks.add(new WifiScanner.ScanSettings.HiddenNetwork(config.SSID));
        }
        // Call wifi native to start the scan
        if (startScanNative(freqs, hiddenNetworks, WIFI_WORK_SOURCE)) {
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_OK;
        } else {
            // used for debug only, mark scan as failed
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_HANDLING_ERROR;
        }
        return true;
    } else {
        if (mVerboseLoggingEnabled)
            logd("no channels for " + config.configKey());
        return false;
    }
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case DhcpClient.CMD_PRE_DHCP_ACTION:
            handlePreDhcpSetup();
            break;
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
            mIpManager.completedPreDhcpAction();
            break;
        case DhcpClient.CMD_POST_DHCP_ACTION:
            handlePostDhcpSetup();
            // similarly--via messages sent back from IpManager.
            break;
        case CMD_IPV4_PROVISIONING_SUCCESS:
            {
                handleIPv4Success((DhcpResults) message.obj);
                sendNetworkStateChangeBroadcast(mLastBssid);
                break;
            }
        case CMD_IPV4_PROVISIONING_FAILURE:
            {
                handleIPv4Failure();
                break;
            }
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
            handleSuccessfulIpConfiguration();
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_NONE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            sendConnectedState();
            transitionTo(mConnectedState);
            break;
        case CMD_IP_CONFIGURATION_LOST:
            // Get Link layer stats so that we get fresh tx packet counters.
            getWifiLinkLayerStats();
            handleIpConfigurationLost();
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_DHCP, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            transitionTo(mDisconnectingState);
            break;
        case CMD_IP_REACHABILITY_LOST:
            if (mVerboseLoggingEnabled && message.obj != null)
                log((String) message.obj);
            handleIpReachabilityLost();
            transitionTo(mDisconnectingState);
            break;
        case CMD_DISCONNECT:
            mWifiNative.disconnect();
            transitionTo(mDisconnectingState);
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
                transitionTo(mDisconnectingState);
            }
            break;
        case CMD_SET_OPERATIONAL_MODE:
            if (message.arg1 != CONNECT_MODE) {
                sendMessage(CMD_DISCONNECT);
                deferMessage(message);
                if (message.arg1 == SCAN_ONLY_WITH_WIFI_OFF_MODE || message.arg1 == DISABLED_MODE) {
                    noteWifiDisabledWhileAssociated();
                }
            }
            break;
        /* Ignore connection to same network */
        case WifiManager.CONNECT_NETWORK:
            int netId = message.arg1;
            if (mWifiInfo.getNetworkId() == netId) {
                break;
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            mWifiInfo.setBSSID((String) message.obj);
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mWifiInfo.setNetworkId(mLastNetworkId);
            if (!mLastBssid.equals(message.obj)) {
                mLastBssid = (String) message.obj;
                sendNetworkStateChangeBroadcast(mLastBssid);
            }
            break;
        case CMD_RSSI_POLL:
            if (message.arg1 == mRssiPollToken) {
                if (mEnableChipWakeUpWhenAssociated) {
                    if (mVerboseLoggingEnabled) {
                        log(" get link layer stats " + mWifiLinkLayerStatsSupported);
                    }
                    WifiLinkLayerStats stats = getWifiLinkLayerStats();
                    if (stats != null) {
                        // Sanity check the results provided by driver
                        if (mWifiInfo.getRssi() != WifiInfo.INVALID_RSSI && (stats.rssi_mgmt == 0 || stats.beacon_rx == 0)) {
                            stats = null;
                        }
                    }
                    // Get Info and continue polling
                    fetchRssiLinkSpeedAndFrequencyNative();
                    // Send the update score to network agent.
                    mWifiScoreReport.calculateAndReportScore(mWifiInfo, mNetworkAgent, mAggressiveHandover);
                }
                sendMessageDelayed(obtainMessage(CMD_RSSI_POLL, mRssiPollToken, 0), POLL_RSSI_INTERVAL_MSECS);
                if (mVerboseLoggingEnabled)
                    sendRssiChangeBroadcast(mWifiInfo.getRssi());
            } else {
            // Polling has completed
            }
            break;
        case CMD_ENABLE_RSSI_POLL:
            cleanWifiScore();
            if (mEnableRssiPollWhenAssociated) {
                mEnableRssiPolling = (message.arg1 == 1);
            } else {
                mEnableRssiPolling = false;
            }
            mRssiPollToken++;
            if (mEnableRssiPolling) {
                // First poll
                fetchRssiLinkSpeedAndFrequencyNative();
                sendMessageDelayed(obtainMessage(CMD_RSSI_POLL, mRssiPollToken, 0), POLL_RSSI_INTERVAL_MSECS);
            }
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            RssiPacketCountInfo info = new RssiPacketCountInfo();
            fetchRssiLinkSpeedAndFrequencyNative();
            info.rssi = mWifiInfo.getRssi();
            fetchPktcntNative(info);
            replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_SUCCEEDED, info);
            break;
        case CMD_DELAYED_NETWORK_DISCONNECT:
            if (!isLinkDebouncing()) {
                // Ignore if we are not debouncing
                logd("CMD_DELAYED_NETWORK_DISCONNECT and not debouncing - ignore " + message.arg1);
                return HANDLED;
            } else {
                logd("CMD_DELAYED_NETWORK_DISCONNECT and debouncing - disconnect " + message.arg1);
                mIsLinkDebouncing = false;
                // If we are still debouncing while this message comes,
                // it means we were not able to reconnect within the alloted time
                // = LINK_FLAPPING_DEBOUNCE_MSEC
                // and thus, trigger a real disconnect
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            if ((String) message.obj == null) {
                logw("Associated command w/o BSSID");
                break;
            }
            mLastBssid = (String) message.obj;
            if (mLastBssid != null && (mWifiInfo.getBSSID() == null || !mLastBssid.equals(mWifiInfo.getBSSID()))) {
                mWifiInfo.setBSSID((String) message.obj);
                sendNetworkStateChangeBroadcast(mLastBssid);
            }
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
        case CMD_RSSI_THRESHOLD_BREACH:
            byte currRssi = (byte) message.arg1;
            processRssiThreshold(currRssi, message.what);
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            stopRssiMonitoringOffload();
            break;
        case CMD_RESET_SIM_NETWORKS:
            if (// sim was removed
            message.arg1 == 0 && mLastNetworkId != WifiConfiguration.INVALID_NETWORK_ID) {
                WifiConfiguration config = mWifiConfigManager.getConfiguredNetwork(mLastNetworkId);
                if (TelephonyUtil.isSimConfig(config)) {
                    mWifiNative.disconnect();
                    transitionTo(mDisconnectingState);
                }
            }
            /* allow parent state to reset data for other networks */
            return NOT_HANDLED;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case DhcpClient.CMD_PRE_DHCP_ACTION:
            handlePreDhcpSetup();
            break;
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
            mIpManager.completedPreDhcpAction();
            break;
        case DhcpClient.CMD_POST_DHCP_ACTION:
            handlePostDhcpSetup();
            // similarly--via messages sent back from IpManager.
            break;
        case CMD_IPV4_PROVISIONING_SUCCESS:
            {
                handleIPv4Success((DhcpResults) message.obj);
                sendNetworkStateChangeBroadcast(mLastBssid);
                break;
            }
        case CMD_IPV4_PROVISIONING_FAILURE:
            {
                handleIPv4Failure();
                break;
            }
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
            handleSuccessfulIpConfiguration();
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_NONE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            sendConnectedState();
            transitionTo(mConnectedState);
            break;
        case CMD_IP_CONFIGURATION_LOST:
            // Get Link layer stats so that we get fresh tx packet counters.
            getWifiLinkLayerStats();
            handleIpConfigurationLost();
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_DHCP, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            transitionTo(mDisconnectingState);
            break;
        case CMD_IP_REACHABILITY_LOST:
            if (mVerboseLoggingEnabled && message.obj != null)
                log((String) message.obj);
            handleIpReachabilityLost();
            transitionTo(mDisconnectingState);
            break;
        case CMD_DISCONNECT:
            mWifiNative.disconnect();
            transitionTo(mDisconnectingState);
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
                transitionTo(mDisconnectingState);
            }
            break;
        case CMD_SET_OPERATIONAL_MODE:
            if (message.arg1 != CONNECT_MODE) {
                sendMessage(CMD_DISCONNECT);
                deferMessage(message);
                if (message.arg1 == SCAN_ONLY_WITH_WIFI_OFF_MODE || message.arg1 == DISABLED_MODE) {
                    noteWifiDisabledWhileAssociated();
                }
            }
            break;
        /* Ignore connection to same network */
        case WifiManager.CONNECT_NETWORK:
            int netId = message.arg1;
            if (mWifiInfo.getNetworkId() == netId) {
                break;
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            mWifiInfo.setBSSID((String) message.obj);
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mWifiInfo.setNetworkId(mLastNetworkId);
            if (!mLastBssid.equals(message.obj)) {
                mLastBssid = (String) message.obj;
                sendNetworkStateChangeBroadcast(mLastBssid);
            }
            break;
        case CMD_RSSI_POLL:
            if (message.arg1 == mRssiPollToken) {
                if (mEnableChipWakeUpWhenAssociated) {
                    if (mVerboseLoggingEnabled) {
                        log(" get link layer stats " + mWifiLinkLayerStatsSupported);
                    }
                    WifiLinkLayerStats stats = getWifiLinkLayerStats();
                    if (stats != null) {
                        // Sanity check the results provided by driver
                        if (mWifiInfo.getRssi() != WifiInfo.INVALID_RSSI && (stats.rssi_mgmt == 0 || stats.beacon_rx == 0)) {
                            stats = null;
                        }
                    }
                    // Get Info and continue polling
                    fetchRssiLinkSpeedAndFrequencyNative();
                    // Send the update score to network agent.
                    mWifiScoreReport.calculateAndReportScore(mWifiInfo, mNetworkAgent, mAggressiveHandover, mWifiMetrics);
                }
                sendMessageDelayed(obtainMessage(CMD_RSSI_POLL, mRssiPollToken, 0), POLL_RSSI_INTERVAL_MSECS);
                if (mVerboseLoggingEnabled)
                    sendRssiChangeBroadcast(mWifiInfo.getRssi());
            } else {
            // Polling has completed
            }
            break;
        case CMD_ENABLE_RSSI_POLL:
            cleanWifiScore();
            if (mEnableRssiPollWhenAssociated) {
                mEnableRssiPolling = (message.arg1 == 1);
            } else {
                mEnableRssiPolling = false;
            }
            mRssiPollToken++;
            if (mEnableRssiPolling) {
                // First poll
                fetchRssiLinkSpeedAndFrequencyNative();
                sendMessageDelayed(obtainMessage(CMD_RSSI_POLL, mRssiPollToken, 0), POLL_RSSI_INTERVAL_MSECS);
            }
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            RssiPacketCountInfo info = new RssiPacketCountInfo();
            fetchRssiLinkSpeedAndFrequencyNative();
            info.rssi = mWifiInfo.getRssi();
            fetchPktcntNative(info);
            replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_SUCCEEDED, info);
            break;
        case CMD_DELAYED_NETWORK_DISCONNECT:
            if (!isLinkDebouncing()) {
                // Ignore if we are not debouncing
                logd("CMD_DELAYED_NETWORK_DISCONNECT and not debouncing - ignore " + message.arg1);
                return HANDLED;
            } else {
                logd("CMD_DELAYED_NETWORK_DISCONNECT and debouncing - disconnect " + message.arg1);
                mIsLinkDebouncing = false;
                // If we are still debouncing while this message comes,
                // it means we were not able to reconnect within the alloted time
                // = LINK_FLAPPING_DEBOUNCE_MSEC
                // and thus, trigger a real disconnect
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            if ((String) message.obj == null) {
                logw("Associated command w/o BSSID");
                break;
            }
            mLastBssid = (String) message.obj;
            if (mLastBssid != null && (mWifiInfo.getBSSID() == null || !mLastBssid.equals(mWifiInfo.getBSSID()))) {
                mWifiInfo.setBSSID((String) message.obj);
                sendNetworkStateChangeBroadcast(mLastBssid);
            }
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
        case CMD_RSSI_THRESHOLD_BREACH:
            byte currRssi = (byte) message.arg1;
            processRssiThreshold(currRssi, message.what);
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            stopRssiMonitoringOffload();
            break;
        case CMD_RESET_SIM_NETWORKS:
            if (// sim was removed
            message.arg1 == 0 && mLastNetworkId != WifiConfiguration.INVALID_NETWORK_ID) {
                WifiConfiguration config = mWifiConfigManager.getConfiguredNetwork(mLastNetworkId);
                if (TelephonyUtil.isSimConfig(config)) {
                    mWifiNative.disconnect();
                    transitionTo(mDisconnectingState);
                }
            }
            /* allow parent state to reset data for other networks */
            return NOT_HANDLED;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
public static junit.framework.Test suite() {
    junit.framework.TestSuite suite = new junit.framework.TestSuite();
    // 
    // "TODO".
    // 
    // I haven't yet found an IDE that will use these, but we might want to implement them anyway.
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.MonitorContendedEnteredTest.class);
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.MonitorContendedEnterTest.class);
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.MonitorWaitedTest.class);
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.MonitorWaitTest.class);
    // I don't know when these are ever used, but they're not obviously useless.
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.DebuggerOnDemand.OnthrowDebuggerLaunchTest.class);
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.NestedTypesTest.class);
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.HoldEventsTest.class);
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.ReleaseEventsTest.class);
    // 
    // "Will not fix".
    // 
    // It's not obvious how to translate this into our world, or what debuggers would do with it.
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.ClassFileVersionTest.class);
    // We don't implement Thread.stop at all, so it doesn't make sense for us to implement the JDWP.
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.StopTest.class);
    // We don't implement class unloading.
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.ClassUnloadTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ArrayReference.GetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ArrayReference.LengthTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ArrayReference.SetValues002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ArrayReference.SetValues003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ArrayReference.SetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ArrayType.NewInstanceTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassLoaderReference.VisibleClassesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassObjectReference.ReflectedType002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassObjectReference.ReflectedTypeTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.InvokeMethod002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.InvokeMethod003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.InvokeMethodAfterMultipleThreadSuspensionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.InvokeMethodWithSuspensionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.InvokeMethodTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.NewInstance002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.NewInstanceTagTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.NewInstanceAfterMultipleThreadSuspensionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.NewInstanceStringTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.NewInstanceTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.NewInstanceWithSuspensionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.SetValues002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.SetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.SuperClassTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Deoptimization.DeoptimizationWithExceptionHandlingTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.EventModifiers.CountModifierTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.EventModifiers.InstanceOnlyModifierTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.EventModifiers.ThreadOnlyModifierTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.Breakpoint002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.BreakpointMultipleTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.BreakpointOnCatchTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.BreakpointTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.ClassPrepareTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.CombinedEvents002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.CombinedEvents003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.CombinedEventsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.CombinedExceptionEventsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.EventWithExceptionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.ExceptionCaughtTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.ExceptionUncaughtTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.ExceptionWithLocationTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.FieldAccessTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.FieldModification002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.FieldModificationTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.FieldWithLocationTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.MethodEntryTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.MethodExitTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.MethodExitWithReturnValueTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.SingleStepTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.SingleStepThroughReflectionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.SingleStepWithLocationTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.SingleStepWithPendingExceptionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.ThreadEndTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.ThreadStartTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.VMDeath002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.VMDeathTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.InterfaceType.InvokeMethodTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Method.BytecodesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Method.IsObsoleteTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Method.LineTableTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Method.VariableTableTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Method.VariableTableWithGenericTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.AttachConnectorTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.BreakpointTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.ClassObjectIDTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.ClassPrepareTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.EnableCollectionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.ExceptionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.FieldAccessTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.FieldModificationTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.ListenConnectorTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.MethodEntryExitTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.RefTypeIDTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.ResumeTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.SingleStepTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.VMDeathTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.DisableCollectionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.EnableCollectionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.GetValues002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.GetValues003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.GetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethod002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethod003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethodTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethodAfterMultipleThreadSuspensionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethodDefault002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethodDefaultTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethodWithSuspensionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.IsCollectedTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.MonitorInfoTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.ReferenceTypeTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.ReferringObjectsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.SetValues002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.SetValues003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.SetValues004Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.SetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.ClassLoaderTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.ClassObjectTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.ConstantPoolTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.FieldsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.FieldsWithGenericTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.GetValues002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.GetValues003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.GetValues004Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.GetValues005Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.GetValues006Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.GetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.InstancesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.InterfacesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.MethodsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.MethodsWithGenericTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.ModifiersTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.Signature002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.SignatureTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.SignatureWithGenericTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.SourceDebugExtensionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.SourceFileTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.StatusTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.GetValues002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.GetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.PopFrames002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.PopFramesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.ProxyThisObjectTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.SetValues002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.SetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.ThisObjectTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StringReference.ValueTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadGroupReference.ChildrenTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadGroupReference.NameTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadGroupReference.ParentTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.CurrentContendedMonitorTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ForceEarlyReturn002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ForceEarlyReturn003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ForceEarlyReturn004Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ForceEarlyReturn005Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ForceEarlyReturn006Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ForceEarlyReturnTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.FrameCountTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.FramesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.InterruptTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.NameTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.OwnedMonitorsStackDepthInfoTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.OwnedMonitorsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ResumeTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.Status002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.Status003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.Status004Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.Status005Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.Status006Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.StatusTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.SuspendCountTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.SuspendTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ThreadGroup002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ThreadGroupTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.AllClassesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.AllClassesWithGenericTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.AllThreadsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.CapabilitiesNewTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.CapabilitiesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.ClassesBySignatureTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.ClassPathsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.CreateStringTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.DisposeDuringInvokeTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.DisposeTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.DisposeObjectsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.ExitTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.IDSizesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.InstanceCountsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.RedefineClassesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.Resume002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.ResumeTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.SetDefaultStratumTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.SuspendTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.TopLevelThreadGroupsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.VersionTest.class);
    return suite;
}
#method_after
public static junit.framework.Test suite() {
    junit.framework.TestSuite suite = new junit.framework.TestSuite();
    // 
    // "TODO".
    // 
    // I haven't yet found an IDE that will use these, but we might want to implement them anyway.
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.MonitorContendedEnteredTest.class);
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.MonitorContendedEnterTest.class);
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.MonitorWaitedTest.class);
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.MonitorWaitTest.class);
    // I don't know when these are ever used, but they're not obviously useless.
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.DebuggerOnDemand.OnthrowDebuggerLaunchTest.class);
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.NestedTypesTest.class);
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.HoldEventsTest.class);
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.ReleaseEventsTest.class);
    // 
    // "Will not fix".
    // 
    // It's not obvious how to translate this into our world, or what debuggers would do with it.
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.ClassFileVersionTest.class);
    // We don't implement Thread.stop at all, so it doesn't make sense for us to implement the JDWP.
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.StopTest.class);
    // We don't implement class unloading.
    // suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.ClassUnloadTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ArrayReference.GetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ArrayReference.LengthTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ArrayReference.SetValues002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ArrayReference.SetValues003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ArrayReference.SetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ArrayType.NewInstanceTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassLoaderReference.VisibleClassesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassObjectReference.ReflectedType002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassObjectReference.ReflectedTypeTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.InvokeMethod002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.InvokeMethod003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.InvokeMethodAfterMultipleThreadSuspensionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.InvokeMethodWithSuspensionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.InvokeMethodTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.NewInstance002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.NewInstanceTagTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.NewInstanceAfterMultipleThreadSuspensionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.NewInstanceStringTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.NewInstanceTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.NewInstanceWithSuspensionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.SetValues002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.SetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ClassType.SuperClassTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Deoptimization.DeoptimizationWithExceptionHandlingTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.EventModifiers.CountModifierTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.EventModifiers.InstanceOnlyModifierTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.EventModifiers.ThreadOnlyModifierTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.Breakpoint002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.BreakpointMultipleTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.BreakpointOnCatchTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.BreakpointTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.ClassPrepareTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.CombinedEvents002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.CombinedEvents003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.CombinedEventsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.CombinedExceptionEventsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.EventWithExceptionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.ExceptionCaughtTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.ExceptionUncaughtTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.ExceptionWithLocationTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.FieldAccessTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.FieldModification002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.FieldModificationTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.FieldWithLocationTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.MethodEntryTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.MethodExitTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.MethodExitWithReturnValueTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.SingleStepTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.SingleStepThroughReflectionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.SingleStepWithLocationTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.SingleStepWithPendingExceptionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.ThreadEndTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.ThreadStartTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.VMDeath002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Events.VMDeathTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.InterfaceType.InvokeMethodTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Method.BytecodesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Method.IsObsoleteTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Method.LineTableTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Method.VariableTableTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.Method.VariableTableWithGenericTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.AttachConnectorTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.BreakpointTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.ClassObjectIDTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.ClassPrepareTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.EnableCollectionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.ExceptionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.FieldAccessTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.FieldModificationTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.ListenConnectorTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.MethodEntryExitTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.RefTypeIDTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.ResumeTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.SingleStepTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.MultiSession.VMDeathTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.DisableCollectionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.EnableCollectionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.GetValues002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.GetValues003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.GetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethod002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethod003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethodTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethodAfterMultipleThreadSuspensionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethodDefault002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethodDefaultTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethodWithSuspensionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.IsCollectedTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.MonitorInfoTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.ReferenceTypeTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.ReferringObjectsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.SetValues002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.SetValues003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.SetValues004Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ObjectReference.SetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.ClassLoaderTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.ClassObjectTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.ConstantPoolTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.FieldsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.FieldsWithGenericTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.GetValues002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.GetValues003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.GetValues004Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.GetValues005Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.GetValues006Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.GetValues007Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.GetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.InstancesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.InterfacesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.MethodsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.MethodsWithGenericTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.ModifiersTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.Signature002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.SignatureTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.SignatureWithGenericTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.SourceDebugExtensionTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.SourceFileTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ReferenceType.StatusTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.GetValues002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.GetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.PopFrames002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.PopFramesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.ProxyThisObjectTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.SetValues002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.SetValuesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StackFrame.ThisObjectTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.StringReference.ValueTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadGroupReference.ChildrenTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadGroupReference.NameTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadGroupReference.ParentTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.CurrentContendedMonitorTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ForceEarlyReturn002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ForceEarlyReturn003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ForceEarlyReturn004Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ForceEarlyReturn005Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ForceEarlyReturn006Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ForceEarlyReturnTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.FrameCountTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.FramesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.InterruptTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.NameTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.OwnedMonitorsStackDepthInfoTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.OwnedMonitorsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ResumeTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.Status002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.Status003Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.Status004Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.Status005Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.Status006Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.StatusTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.SuspendCountTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.SuspendTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ThreadGroup002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.ThreadReference.ThreadGroupTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.AllClassesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.AllClassesWithGenericTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.AllThreadsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.CapabilitiesNewTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.CapabilitiesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.ClassesBySignatureTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.ClassPathsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.CreateStringTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.DisposeDuringInvokeTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.DisposeTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.DisposeObjectsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.ExitTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.IDSizesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.InstanceCountsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.RedefineClassesTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.Resume002Test.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.ResumeTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.SetDefaultStratumTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.SuspendTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.TopLevelThreadGroupsTest.class);
    suite.addTestSuite(org.apache.harmony.jpda.tests.jdwp.VirtualMachine.VersionTest.class);
    return suite;
}
#end_block

#method_before
public void run() {
    logWriter.println("--> Debuggee: GetValues006Debuggee: START");
    GetValues006Interface instance = new GetValues006Implementer();
    synchronizer.sendMessage(JPDADebuggeeSynchronizer.SGNL_READY);
    synchronizer.receiveMessage(JPDADebuggeeSynchronizer.SGNL_CONTINUE);
    logWriter.println("--> Debuggee: GetValues006Debuggee: FINISH");
}
#method_after
@Override
public void run() {
    logWriter.println("--> Debuggee: GetValues006Debuggee: START");
    GetValues006Interface instance = new GetValues006Implementer();
    synchronizer.sendMessage(JPDADebuggeeSynchronizer.SGNL_READY);
    synchronizer.receiveMessage(JPDADebuggeeSynchronizer.SGNL_CONTINUE);
    logWriter.println("--> Debuggee: GetValues006Debuggee: FINISH");
}
#end_block

#method_before
protected String getDebuggeeClassName() {
    return "org.apache.harmony.jpda.tests.jdwp.ReferenceType.GetValues006Debuggee";
}
#method_after
@Override
protected String getDebuggeeClassName() {
    return GetValues006Debuggee.class.getName();
}
#end_block

#method_before
public void testGetValues006() {
    String thisTestName = "testGetValues006";
    logWriter.println("==> " + thisTestName + " for ReferenceType.GetValues command: START...");
    synchronizer.receiveMessage(JPDADebuggeeSynchronizer.SGNL_READY);
    logWriter.println("\n=> Get debuggeeRefTypeID for debuggee class = " + getDebuggeeClassName() + "...");
    long debuggeeRefTypeID = 0;
    try {
        debuggeeRefTypeID = debuggeeWrapper.vmMirror.getClassID(debuggeeSignature);
    } catch (Throwable thrown) {
        logWriter.println("## FAILURE: Can not get debuggeeRefTypeID:");
        logWriter.println("## Exception: " + thrown);
        fail("Can not get debuggeeRefTypeID, Exception: " + thrown);
    }
    if (debuggeeRefTypeID == -1) {
        logWriter.println("## FAILURE: Can not get debuggeeRefTypeID for given signature!");
        logWriter.println("## Signature = |" + debuggeeSignature + "|");
        fail("Can not get debuggeeRefTypeID for given signature:<" + debuggeeSignature + ">");
    }
    logWriter.println("=> debuggeeRefTypeID = " + debuggeeRefTypeID);
    logWriter.println("\n=> Get implementerRefTypeID for implementer = GetValues006Implementer...");
    long implementerRefTypeID = 0;
    try {
        implementerRefTypeID = debuggeeWrapper.vmMirror.getInterfaceID(implementerSignature);
    } catch (Throwable thrown) {
        logWriter.println("## FAILURE: Can not get implementerRefTypeID:");
        logWriter.println("## Exception: " + thrown);
        fail(" Can not get implementerRefTypeID, Exception: " + thrown);
    }
    if (implementerRefTypeID == -1) {
        logWriter.println("## FAILURE: Can not get implementerRefTypeID for given signature!");
        logWriter.println("## Signature = |" + implementerSignature + "|");
        fail("Can not get implementerRefTypeID for given signature:<" + implementerSignature + ">");
    }
    logWriter.println("=> implementerRefTypeID = " + implementerRefTypeID);
    logWriter.println("\n=> Get interfaceFieldID for field of interface class...");
    String interfaceFieldName = "interfaceStaticIntVar";
    long interfaceFieldID = 0;
    try {
        interfaceFieldID = debuggeeWrapper.vmMirror.getFieldID(implementerRefTypeID, interfaceFieldName);
    } catch (Throwable thrown) {
        logWriter.println("## FAILURE: Can not get interfaceFieldID:");
        logWriter.println("## Exception: " + thrown);
        fail("Can not get interfaceFieldID, Exception: " + thrown);
    }
    logWriter.println("=> interfaceFieldID = " + interfaceFieldID);
    logWriter.println("\n=> CHECK ReferenceType::GetValues command for implementerRefTypeID," + " interfaceFieldID...");
    CommandPacket getValuesCommand = new CommandPacket(JDWPCommands.ReferenceTypeCommandSet.CommandSetID, JDWPCommands.ReferenceTypeCommandSet.GetValuesCommand);
    getValuesCommand.setNextValueAsReferenceTypeID(implementerRefTypeID);
    getValuesCommand.setNextValueAsInt(1);
    getValuesCommand.setNextValueAsFieldID(interfaceFieldID);
    ReplyPacket getValuesReply = debuggeeWrapper.vmMirror.performCommand(getValuesCommand);
    checkReplyPacket(getValuesReply, "ReferenceType::GetValues command");
    // int returnedValuesNumber =
    getValuesReply.getNextValueAsInt();
    Value fieldValue = getValuesReply.getNextValueAsValue();
    byte fieldTag = fieldValue.getTag();
    logWriter.println("=> Returned value tag = " + fieldTag + "(" + JDWPConstants.Tag.getName(fieldTag) + ")");
    assertEquals("Invalid value tag is returned,", JDWPConstants.Tag.INT_TAG, fieldTag, JDWPConstants.Tag.getName(JDWPConstants.Tag.INT_TAG), JDWPConstants.Tag.getName(fieldTag));
    int intValue = fieldValue.getIntValue();
    logWriter.println("=> Returned value = " + intValue);
    // here expected value = 1 (staticIntField)
    int expectedIntValue = 1;
    assertEquals("Invalid int value,", expectedIntValue, intValue);
    assertAllDataRead(getValuesReply);
    logWriter.println("=> CHECK PASSED: Expected value is returned!");
    synchronizer.sendMessage(JPDADebuggeeSynchronizer.SGNL_CONTINUE);
    logWriter.println("==> " + thisTestName + " for ReferenceType::GetValues command: FINISH");
}
#method_after
public void testGetValues006() {
    String thisTestName = "testGetValues006";
    logWriter.println("==> " + thisTestName + " for ReferenceType.GetValues command: START...");
    synchronizer.receiveMessage(JPDADebuggeeSynchronizer.SGNL_READY);
    logWriter.println("\n=> Get debuggeeRefTypeID for debuggee class = " + getDebuggeeClassName() + "...");
    long debuggeeRefTypeID = getClassIDBySignature(getDebuggeeClassSignature());
    logWriter.println("=> debuggeeRefTypeID = " + debuggeeRefTypeID);
    logWriter.println("\n=> Get implementerRefTypeID for implementer = GetValues006Implementer...");
    long implementerRefTypeID = getClassIDBySignature(getClassSignature(GetValues006Interface.class));
    logWriter.println("=> implementerRefTypeID = " + implementerRefTypeID);
    logWriter.println("\n=> Get interfaceFieldID for field of interface class...");
    String interfaceFieldName = "interfaceStaticIntVar";
    long interfaceFieldID = checkField(implementerRefTypeID, interfaceFieldName);
    logWriter.println("=> interfaceFieldID = " + interfaceFieldID);
    logWriter.println("\n=> CHECK ReferenceType::GetValues command for implementerRefTypeID," + " interfaceFieldID...");
    CommandPacket getValuesCommand = new CommandPacket(JDWPCommands.ReferenceTypeCommandSet.CommandSetID, JDWPCommands.ReferenceTypeCommandSet.GetValuesCommand);
    getValuesCommand.setNextValueAsReferenceTypeID(implementerRefTypeID);
    getValuesCommand.setNextValueAsInt(1);
    getValuesCommand.setNextValueAsFieldID(interfaceFieldID);
    ReplyPacket getValuesReply = debuggeeWrapper.vmMirror.performCommand(getValuesCommand);
    checkReplyPacket(getValuesReply, "ReferenceType::GetValues command");
    getValuesReply.getNextValueAsInt();
    Value fieldValue = getValuesReply.getNextValueAsValue();
    byte fieldTag = fieldValue.getTag();
    logWriter.println("=> Returned value tag = " + fieldTag + "(" + JDWPConstants.Tag.getName(fieldTag) + ")");
    assertTagEquals("Invalid value tag is returned,", JDWPConstants.Tag.INT_TAG, fieldTag);
    int intValue = fieldValue.getIntValue();
    logWriter.println("=> Returned value = " + intValue);
    // here expected value = 1 (staticIntField)
    int expectedIntValue = 1;
    assertEquals("Invalid int value,", expectedIntValue, intValue);
    assertAllDataRead(getValuesReply);
    logWriter.println("=> CHECK PASSED: Expected value is returned!");
    synchronizer.sendMessage(JPDADebuggeeSynchronizer.SGNL_CONTINUE);
    logWriter.println("==> " + thisTestName + " for ReferenceType::GetValues command: FINISH");
}
#end_block

#method_before
final void appNotResponding(ProcessRecord app, ActivityRecord activity, ActivityRecord parent, boolean aboveSystem, final String annotation) {
    ArrayList<Integer> firstPids = new ArrayList<Integer>(5);
    SparseArray<Boolean> lastPids = new SparseArray<Boolean>(20);
    if (mService.mController != null) {
        try {
            // 0 == continue, -1 = kill process immediately
            int res = mService.mController.appEarlyNotResponding(app.processName, app.pid, annotation);
            if (res < 0 && app.pid != MY_PID) {
                app.kill("anr", true);
            }
        } catch (RemoteException e) {
            mService.mController = null;
            Watchdog.getInstance().setActivityController(null);
        }
    }
    long anrTime = SystemClock.uptimeMillis();
    if (ActivityManagerService.MONITOR_CPU_USAGE) {
        mService.updateCpuStatsNow();
    }
    synchronized (mService) {
        // PowerManager.reboot() can block for a long time, so ignore ANRs while shutting down.
        if (mService.mShuttingDown) {
            Slog.i(TAG, "During shutdown skipping ANR: " + app + " " + annotation);
            return;
        } else if (app.notResponding) {
            Slog.i(TAG, "Skipping duplicate ANR: " + app + " " + annotation);
            return;
        } else if (app.crashing) {
            Slog.i(TAG, "Crashing app skipping ANR: " + app + " " + annotation);
            return;
        } else if (app.pid == 0) {
            Slog.i(TAG, "Skipping died app ANR: " + app + " " + annotation);
            return;
        }
        // In case we come through here for the same app before completing
        // this one, mark as anring now so we will bail out.
        app.notResponding = true;
        // Log the ANR to the event log.
        EventLog.writeEvent(EventLogTags.AM_ANR, app.userId, app.pid, app.processName, app.info.flags, annotation);
        // Dump thread traces as quickly as we can, starting with "interesting" processes.
        firstPids.add(app.pid);
        int parentPid = app.pid;
        if (parent != null && parent.app != null && parent.app.pid > 0) {
            parentPid = parent.app.pid;
        }
        if (parentPid != app.pid)
            firstPids.add(parentPid);
        if (MY_PID != app.pid && MY_PID != parentPid)
            firstPids.add(MY_PID);
        for (int i = mService.mLruProcesses.size() - 1; i >= 0; i--) {
            ProcessRecord r = mService.mLruProcesses.get(i);
            if (r != null && r.thread != null) {
                int pid = r.pid;
                if (pid > 0 && pid != app.pid && pid != parentPid && pid != MY_PID) {
                    if (r.persistent) {
                        firstPids.add(pid);
                        if (DEBUG_ANR)
                            Slog.i(TAG, "Adding persistent proc: " + r);
                    } else {
                        lastPids.put(pid, Boolean.TRUE);
                        if (DEBUG_ANR)
                            Slog.i(TAG, "Adding ANR proc: " + r);
                    }
                }
            }
        }
    }
    // Log the ANR to the main log.
    StringBuilder info = new StringBuilder();
    info.setLength(0);
    info.append("ANR in ").append(app.processName);
    if (activity != null && activity.shortComponentName != null) {
        info.append(" (").append(activity.shortComponentName).append(")");
    }
    info.append("\n");
    info.append("PID: ").append(app.pid).append("\n");
    if (annotation != null) {
        info.append("Reason: ").append(annotation).append("\n");
    }
    if (parent != null && parent != activity) {
        info.append("Parent: ").append(parent.shortComponentName).append("\n");
    }
    final ProcessCpuTracker processCpuTracker = new ProcessCpuTracker(true);
    File tracesFile = mService.dumpStackTraces(true, firstPids, processCpuTracker, lastPids, NATIVE_STACKS_OF_INTEREST);
    String cpuInfo = null;
    if (ActivityManagerService.MONITOR_CPU_USAGE) {
        mService.updateCpuStatsNow();
        synchronized (mService.mProcessCpuTracker) {
            cpuInfo = mService.mProcessCpuTracker.printCurrentState(anrTime);
        }
        info.append(processCpuTracker.printCurrentLoad());
        info.append(cpuInfo);
    }
    info.append(processCpuTracker.printCurrentState(anrTime));
    Slog.e(TAG, info.toString());
    if (tracesFile == null) {
        // There is no trace file, so dump (only) the alleged culprit's threads to the log
        Process.sendSignal(app.pid, Process.SIGNAL_QUIT);
    }
    mService.addErrorToDropBox("anr", app, app.processName, activity, parent, annotation, cpuInfo, tracesFile, null);
    if (mService.mController != null) {
        try {
            // 0 == show dialog, 1 = keep waiting, -1 = kill process immediately
            int res = mService.mController.appNotResponding(app.processName, app.pid, info.toString());
            if (res != 0) {
                if (res < 0 && app.pid != MY_PID) {
                    app.kill("anr", true);
                } else {
                    synchronized (mService) {
                        mService.mServices.scheduleServiceTimeoutLocked(app);
                    }
                }
                return;
            }
        } catch (RemoteException e) {
            mService.mController = null;
            Watchdog.getInstance().setActivityController(null);
        }
    }
    // Unless configured otherwise, swallow ANRs in background processes & kill the process.
    boolean showBackground = Settings.Secure.getInt(mContext.getContentResolver(), Settings.Secure.ANR_SHOW_BACKGROUND, 0) != 0;
    synchronized (mService) {
        mService.mBatteryStatsService.noteProcessAnr(app.processName, app.uid);
        if (!showBackground && !app.isInterestingToUserLocked() && app.pid != MY_PID) {
            app.kill("bg anr", true);
            return;
        }
        // Set the app's notResponding state, and look up the errorReportReceiver
        makeAppNotRespondingLocked(app, activity != null ? activity.shortComponentName : null, annotation != null ? "ANR " + annotation : "ANR", info.toString());
        // Bring up the infamous App Not Responding dialog
        Message msg = Message.obtain();
        HashMap<String, Object> map = new HashMap<String, Object>();
        msg.what = ActivityManagerService.SHOW_NOT_RESPONDING_UI_MSG;
        msg.obj = map;
        msg.arg1 = aboveSystem ? 1 : 0;
        map.put("app", app);
        if (activity != null) {
            map.put("activity", activity);
        }
        mService.mUiHandler.sendMessage(msg);
    }
}
#method_after
final void appNotResponding(ProcessRecord app, ActivityRecord activity, ActivityRecord parent, boolean aboveSystem, final String annotation) {
    ArrayList<Integer> firstPids = new ArrayList<Integer>(5);
    SparseArray<Boolean> lastPids = new SparseArray<Boolean>(20);
    if (mService.mController != null) {
        try {
            // 0 == continue, -1 = kill process immediately
            int res = mService.mController.appEarlyNotResponding(app.processName, app.pid, annotation);
            if (res < 0 && app.pid != MY_PID) {
                app.kill("anr", true);
            }
        } catch (RemoteException e) {
            mService.mController = null;
            Watchdog.getInstance().setActivityController(null);
        }
    }
    long anrTime = SystemClock.uptimeMillis();
    if (ActivityManagerService.MONITOR_CPU_USAGE) {
        mService.updateCpuStatsNow();
    }
    synchronized (mService) {
        // PowerManager.reboot() can block for a long time, so ignore ANRs while shutting down.
        if (mService.mShuttingDown) {
            Slog.i(TAG, "During shutdown skipping ANR: " + app + " " + annotation);
            return;
        } else if (app.notResponding) {
            Slog.i(TAG, "Skipping duplicate ANR: " + app + " " + annotation);
            return;
        } else if (app.crashing) {
            Slog.i(TAG, "Crashing app skipping ANR: " + app + " " + annotation);
            return;
        } else if (app.killedByAm) {
            Slog.i(TAG, "App already killed by AM skipping ANR: " + app + " " + annotation);
            return;
        } else if (app.killed) {
            Slog.i(TAG, "Skipping died app ANR: " + app + " " + annotation);
            return;
        }
        // In case we come through here for the same app before completing
        // this one, mark as anring now so we will bail out.
        app.notResponding = true;
        // Log the ANR to the event log.
        EventLog.writeEvent(EventLogTags.AM_ANR, app.userId, app.pid, app.processName, app.info.flags, annotation);
        // Dump thread traces as quickly as we can, starting with "interesting" processes.
        firstPids.add(app.pid);
        int parentPid = app.pid;
        if (parent != null && parent.app != null && parent.app.pid > 0) {
            parentPid = parent.app.pid;
        }
        if (parentPid != app.pid)
            firstPids.add(parentPid);
        if (MY_PID != app.pid && MY_PID != parentPid)
            firstPids.add(MY_PID);
        for (int i = mService.mLruProcesses.size() - 1; i >= 0; i--) {
            ProcessRecord r = mService.mLruProcesses.get(i);
            if (r != null && r.thread != null) {
                int pid = r.pid;
                if (pid > 0 && pid != app.pid && pid != parentPid && pid != MY_PID) {
                    if (r.persistent) {
                        firstPids.add(pid);
                        if (DEBUG_ANR)
                            Slog.i(TAG, "Adding persistent proc: " + r);
                    } else {
                        lastPids.put(pid, Boolean.TRUE);
                        if (DEBUG_ANR)
                            Slog.i(TAG, "Adding ANR proc: " + r);
                    }
                }
            }
        }
    }
    // Log the ANR to the main log.
    StringBuilder info = new StringBuilder();
    info.setLength(0);
    info.append("ANR in ").append(app.processName);
    if (activity != null && activity.shortComponentName != null) {
        info.append(" (").append(activity.shortComponentName).append(")");
    }
    info.append("\n");
    info.append("PID: ").append(app.pid).append("\n");
    if (annotation != null) {
        info.append("Reason: ").append(annotation).append("\n");
    }
    if (parent != null && parent != activity) {
        info.append("Parent: ").append(parent.shortComponentName).append("\n");
    }
    final ProcessCpuTracker processCpuTracker = new ProcessCpuTracker(true);
    File tracesFile = mService.dumpStackTraces(true, firstPids, processCpuTracker, lastPids, NATIVE_STACKS_OF_INTEREST);
    String cpuInfo = null;
    if (ActivityManagerService.MONITOR_CPU_USAGE) {
        mService.updateCpuStatsNow();
        synchronized (mService.mProcessCpuTracker) {
            cpuInfo = mService.mProcessCpuTracker.printCurrentState(anrTime);
        }
        info.append(processCpuTracker.printCurrentLoad());
        info.append(cpuInfo);
    }
    info.append(processCpuTracker.printCurrentState(anrTime));
    Slog.e(TAG, info.toString());
    if (tracesFile == null) {
        // There is no trace file, so dump (only) the alleged culprit's threads to the log
        Process.sendSignal(app.pid, Process.SIGNAL_QUIT);
    }
    mService.addErrorToDropBox("anr", app, app.processName, activity, parent, annotation, cpuInfo, tracesFile, null);
    if (mService.mController != null) {
        try {
            // 0 == show dialog, 1 = keep waiting, -1 = kill process immediately
            int res = mService.mController.appNotResponding(app.processName, app.pid, info.toString());
            if (res != 0) {
                if (res < 0 && app.pid != MY_PID) {
                    app.kill("anr", true);
                } else {
                    synchronized (mService) {
                        mService.mServices.scheduleServiceTimeoutLocked(app);
                    }
                }
                return;
            }
        } catch (RemoteException e) {
            mService.mController = null;
            Watchdog.getInstance().setActivityController(null);
        }
    }
    // Unless configured otherwise, swallow ANRs in background processes & kill the process.
    boolean showBackground = Settings.Secure.getInt(mContext.getContentResolver(), Settings.Secure.ANR_SHOW_BACKGROUND, 0) != 0;
    synchronized (mService) {
        mService.mBatteryStatsService.noteProcessAnr(app.processName, app.uid);
        if (!showBackground && !app.isInterestingToUserLocked() && app.pid != MY_PID) {
            app.kill("bg anr", true);
            return;
        }
        // Set the app's notResponding state, and look up the errorReportReceiver
        makeAppNotRespondingLocked(app, activity != null ? activity.shortComponentName : null, annotation != null ? "ANR " + annotation : "ANR", info.toString());
        // Bring up the infamous App Not Responding dialog
        Message msg = Message.obtain();
        HashMap<String, Object> map = new HashMap<String, Object>();
        msg.what = ActivityManagerService.SHOW_NOT_RESPONDING_UI_MSG;
        msg.obj = map;
        msg.arg1 = aboveSystem ? 1 : 0;
        map.put("app", app);
        if (activity != null) {
            map.put("activity", activity);
        }
        mService.mUiHandler.sendMessage(msg);
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_DUMP:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    doDump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println("Exception: " + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case MSG_BIND:
            {
                final InputBindResult res = (InputBindResult) msg.obj;
                if (DEBUG) {
                    Log.i(TAG, "handleMessage: MSG_BIND " + res.sequence + "," + res.id);
                }
                synchronized (mH) {
                    if (mBindSequence < 0 || mBindSequence != res.sequence) {
                        Log.w(TAG, "Ignoring onBind: cur seq=" + mBindSequence + ", given seq=" + res.sequence);
                        if (res.channel != null && res.channel != mCurChannel) {
                            res.channel.dispose();
                        }
                        return;
                    }
                    mRequestUpdateCursorAnchorInfoMonitorMode = REQUEST_UPDATE_CURSOR_ANCHOR_INFO_NONE;
                    setInputChannelLocked(res.channel);
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mBindSequence = res.sequence;
                }
                startInputInner(null, 0, 0, 0);
                return;
            }
        case MSG_UNBIND:
            {
                final int sequence = msg.arg1;
                if (DEBUG) {
                    Log.i(TAG, "handleMessage: MSG_UNBIND " + sequence);
                }
                boolean startInput = false;
                synchronized (mH) {
                    if (mBindSequence == sequence) {
                        if (false) {
                            // XXX the server has already unbound!
                            if (mCurMethod != null && mCurrentTextBoxAttribute != null) {
                                try {
                                    mCurMethod.finishInput();
                                } catch (RemoteException e) {
                                    Log.w(TAG, "IME died: " + mCurId, e);
                                }
                            }
                        }
                        clearBindingLocked();
                        // we would like to re-connect to the next input method.
                        if (mServedView != null && mServedView.isFocused()) {
                            mServedConnecting = true;
                        }
                        if (mActive) {
                            startInput = true;
                        }
                    }
                }
                if (startInput) {
                    startInputInner(null, 0, 0, 0);
                }
                return;
            }
        case MSG_SET_ACTIVE:
            {
                final boolean active = msg.arg1 != 0;
                if (DEBUG) {
                    Log.i(TAG, "handleMessage: MSG_SET_ACTIVE " + active + ", was " + mActive);
                }
                synchronized (mH) {
                    mActive = active;
                    mFullscreenMode = false;
                    if (!active) {
                        // Some other client has starting using the IME, so note
                        // that this happened and make sure our own editor's
                        // state is reset.
                        mHasBeenInactive = true;
                        try {
                            // Note that finishComposingText() is allowed to run
                            // even when we are not active.
                            mIInputContext.finishComposingText();
                        } catch (RemoteException e) {
                        }
                    }
                    // handling this message.
                    if (mServedView != null && mServedView.hasWindowFocus()) {
                        // mServedInputConnection.finishComposingText.
                        if (checkFocusNoStartInput(mHasBeenInactive, false)) {
                            startInputInner(null, 0, 0, 0);
                        }
                    }
                }
                return;
            }
        case MSG_SEND_INPUT_EVENT:
            {
                sendInputEventAndReportResultOnMainLooper((PendingEvent) msg.obj);
                return;
            }
        case MSG_TIMEOUT_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, true);
                return;
            }
        case MSG_FLUSH_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, false);
                return;
            }
        case MSG_SET_USER_ACTION_NOTIFICATION_SEQUENCE_NUMBER:
            {
                synchronized (mH) {
                    mNextUserActionNotificationSequenceNumber = msg.arg1;
                }
            }
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_DUMP:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    doDump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println("Exception: " + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case MSG_BIND:
            {
                final InputBindResult res = (InputBindResult) msg.obj;
                if (DEBUG) {
                    Log.i(TAG, "handleMessage: MSG_BIND " + res.sequence + "," + res.id);
                }
                synchronized (mH) {
                    if (mBindSequence < 0 || mBindSequence != res.sequence) {
                        Log.w(TAG, "Ignoring onBind: cur seq=" + mBindSequence + ", given seq=" + res.sequence);
                        if (res.channel != null && res.channel != mCurChannel) {
                            res.channel.dispose();
                        }
                        return;
                    }
                    mRequestUpdateCursorAnchorInfoMonitorMode = REQUEST_UPDATE_CURSOR_ANCHOR_INFO_NONE;
                    setInputChannelLocked(res.channel);
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mBindSequence = res.sequence;
                }
                startInputInner(InputMethodClient.START_INPUT_REASON_BOUND_TO_IMMS, null, 0, 0, 0);
                return;
            }
        case MSG_UNBIND:
            {
                final int sequence = msg.arg1;
                @InputMethodClient.UnbindReason
                final int reason = msg.arg2;
                if (DEBUG) {
                    Log.i(TAG, "handleMessage: MSG_UNBIND " + sequence + " reason=" + InputMethodClient.getUnbindReason(reason));
                }
                final boolean startInput;
                synchronized (mH) {
                    if (mBindSequence != sequence) {
                        return;
                    }
                    clearBindingLocked();
                    // we would like to re-connect to the next input method.
                    if (mServedView != null && mServedView.isFocused()) {
                        mServedConnecting = true;
                    }
                    startInput = mActive;
                }
                if (startInput) {
                    startInputInner(InputMethodClient.START_INPUT_REASON_UNBOUND_FROM_IMMS, null, 0, 0, 0);
                }
                return;
            }
        case MSG_SET_ACTIVE:
            {
                final boolean active = msg.arg1 != 0;
                if (DEBUG) {
                    Log.i(TAG, "handleMessage: MSG_SET_ACTIVE " + active + ", was " + mActive);
                }
                synchronized (mH) {
                    mActive = active;
                    mFullscreenMode = false;
                    if (!active) {
                        // Some other client has starting using the IME, so note
                        // that this happened and make sure our own editor's
                        // state is reset.
                        mHasBeenInactive = true;
                        try {
                            // Note that finishComposingText() is allowed to run
                            // even when we are not active.
                            mIInputContext.finishComposingText();
                        } catch (RemoteException e) {
                        }
                    }
                    // handling this message.
                    if (mServedView != null && mServedView.hasWindowFocus()) {
                        if (checkFocusNoStartInput(mHasBeenInactive)) {
                            final int reason = active ? InputMethodClient.START_INPUT_REASON_ACTIVATED_BY_IMMS : InputMethodClient.START_INPUT_REASON_DEACTIVATED_BY_IMMS;
                            startInputInner(reason, null, 0, 0, 0);
                        }
                    }
                }
                return;
            }
        case MSG_SEND_INPUT_EVENT:
            {
                sendInputEventAndReportResultOnMainLooper((PendingEvent) msg.obj);
                return;
            }
        case MSG_TIMEOUT_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, true);
                return;
            }
        case MSG_FLUSH_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, false);
                return;
            }
        case MSG_SET_USER_ACTION_NOTIFICATION_SEQUENCE_NUMBER:
            {
                synchronized (mH) {
                    mNextUserActionNotificationSequenceNumber = msg.arg1;
                }
            }
    }
}
#end_block

#method_before
@Override
public boolean isActive() {
    return mParentInputMethodManager.mActive && mActive;
}
#method_after
@Override
public boolean isActive() {
    return mParentInputMethodManager.mActive && !isFinished();
}
#end_block

#method_before
void deactivate() {
    mActive = false;
}
#method_after
void deactivate() {
    if (isFinished()) {
        // reportFinish() will take effect.
        return;
    }
    closeConnection();
}
#end_block

#method_before
public List<InputMethodInfo> getInputMethodList() {
    try {
        return mService.getInputMethodList();
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
#method_after
public List<InputMethodInfo> getInputMethodList() {
    try {
        return mService.getInputMethodList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public List<InputMethodInfo> getEnabledInputMethodList() {
    try {
        return mService.getEnabledInputMethodList();
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
#method_after
public List<InputMethodInfo> getEnabledInputMethodList() {
    try {
        return mService.getEnabledInputMethodList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public List<InputMethodSubtype> getEnabledInputMethodSubtypeList(InputMethodInfo imi, boolean allowsImplicitlySelectedSubtypes) {
    try {
        return mService.getEnabledInputMethodSubtypeList(imi == null ? null : imi.getId(), allowsImplicitlySelectedSubtypes);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
#method_after
public List<InputMethodSubtype> getEnabledInputMethodSubtypeList(InputMethodInfo imi, boolean allowsImplicitlySelectedSubtypes) {
    try {
        return mService.getEnabledInputMethodSubtypeList(imi == null ? null : imi.getId(), allowsImplicitlySelectedSubtypes);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public void showStatusIcon(IBinder imeToken, String packageName, int iconId) {
    try {
        mService.updateStatusIcon(imeToken, packageName, iconId);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
#method_after
public void showStatusIcon(IBinder imeToken, String packageName, int iconId) {
    try {
        mService.updateStatusIcon(imeToken, packageName, iconId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public void hideStatusIcon(IBinder imeToken) {
    try {
        mService.updateStatusIcon(imeToken, null, 0);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
#method_after
public void hideStatusIcon(IBinder imeToken) {
    try {
        mService.updateStatusIcon(imeToken, null, 0);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public void setImeWindowStatus(IBinder imeToken, int vis, int backDisposition) {
    try {
        mService.setImeWindowStatus(imeToken, vis, backDisposition);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
#method_after
public void setImeWindowStatus(IBinder imeToken, int vis, int backDisposition) {
    try {
        mService.setImeWindowStatus(imeToken, vis, backDisposition);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public void registerSuggestionSpansForNotification(SuggestionSpan[] spans) {
    try {
        mService.registerSuggestionSpansForNotification(spans);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
#method_after
public void registerSuggestionSpansForNotification(SuggestionSpan[] spans) {
    try {
        mService.registerSuggestionSpansForNotification(spans);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public void notifySuggestionPicked(SuggestionSpan span, String originalString, int index) {
    try {
        mService.notifySuggestionPicked(span, originalString, index);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
#method_after
public void notifySuggestionPicked(SuggestionSpan span, String originalString, int index) {
    try {
        mService.notifySuggestionPicked(span, originalString, index);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public boolean isFullscreenMode() {
    return mFullscreenMode;
}
#method_after
public boolean isFullscreenMode() {
    synchronized (mH) {
        return mFullscreenMode;
    }
}
#end_block

#method_before
public boolean isAcceptingText() {
    checkFocus();
    return mServedInputConnection != null;
}
#method_after
public boolean isAcceptingText() {
    checkFocus();
    return mServedInputConnectionWrapper != null && mServedInputConnectionWrapper.getInputConnection() != null;
}
#end_block

#method_before
void clearConnectionLocked() {
    mCurrentTextBoxAttribute = null;
    mServedInputConnection = null;
    if (mServedInputConnectionWrapper != null) {
        mServedInputConnectionWrapper.deactivate();
        mServedInputConnectionWrapper = null;
    }
}
#method_after
void clearConnectionLocked() {
    mCurrentTextBoxAttribute = null;
    if (mServedInputConnectionWrapper != null) {
        mServedInputConnectionWrapper.deactivate();
        mServedInputConnectionWrapper = null;
    }
}
#end_block

#method_before
void finishInputLocked() {
    mNextServedView = null;
    if (mServedView != null) {
        if (DEBUG)
            Log.v(TAG, "FINISH INPUT: " + mServedView);
        if (mCurrentTextBoxAttribute != null) {
            try {
                mService.finishInput(mClient);
            } catch (RemoteException e) {
            }
        }
        notifyInputConnectionFinished();
        mServedView = null;
        mCompletions = null;
        mServedConnecting = false;
        clearConnectionLocked();
    }
}
#method_after
void finishInputLocked() {
    mNextServedView = null;
    if (mServedView != null) {
        if (DEBUG)
            Log.v(TAG, "FINISH INPUT: mServedView=" + dumpViewInfo(mServedView));
        if (mCurrentTextBoxAttribute != null) {
            try {
                mService.finishInput(mClient);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
        mServedView = null;
        mCompletions = null;
        mServedConnecting = false;
        clearConnectionLocked();
    }
}
#end_block

#method_before
public boolean showSoftInput(View view, int flags, ResultReceiver resultReceiver) {
    checkFocus();
    synchronized (mH) {
        if (mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) {
            return false;
        }
        try {
            return mService.showSoftInput(mClient, flags, resultReceiver);
        } catch (RemoteException e) {
        }
        return false;
    }
}
#method_after
public boolean showSoftInput(View view, int flags, ResultReceiver resultReceiver) {
    checkFocus();
    synchronized (mH) {
        if (mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) {
            return false;
        }
        try {
            return mService.showSoftInput(mClient, flags, resultReceiver);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}
#end_block

#method_before
public void showSoftInputUnchecked(int flags, ResultReceiver resultReceiver) {
    try {
        mService.showSoftInput(mClient, flags, resultReceiver);
    } catch (RemoteException e) {
    }
}
#method_after
public void showSoftInputUnchecked(int flags, ResultReceiver resultReceiver) {
    try {
        mService.showSoftInput(mClient, flags, resultReceiver);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public boolean hideSoftInputFromWindow(IBinder windowToken, int flags, ResultReceiver resultReceiver) {
    checkFocus();
    synchronized (mH) {
        if (mServedView == null || mServedView.getWindowToken() != windowToken) {
            return false;
        }
        try {
            return mService.hideSoftInput(mClient, flags, resultReceiver);
        } catch (RemoteException e) {
        }
        return false;
    }
}
#method_after
public boolean hideSoftInputFromWindow(IBinder windowToken, int flags, ResultReceiver resultReceiver) {
    checkFocus();
    synchronized (mH) {
        if (mServedView == null || mServedView.getWindowToken() != windowToken) {
            return false;
        }
        try {
            return mService.hideSoftInput(mClient, flags, resultReceiver);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}
#end_block

#method_before
public void restartInput(View view) {
    checkFocus();
    synchronized (mH) {
        if (mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) {
            return;
        }
        mServedConnecting = true;
    }
    startInputInner(null, 0, 0, 0);
}
#method_after
public void restartInput(View view) {
    checkFocus();
    synchronized (mH) {
        if (mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) {
            return;
        }
        mServedConnecting = true;
    }
    startInputInner(InputMethodClient.START_INPUT_REASON_APP_CALLED_RESTART_INPUT_API, null, 0, 0, 0);
}
#end_block

#method_before
boolean startInputInner(IBinder windowGainingFocus, int controlFlags, int softInputMode, int windowFlags) {
    final View view;
    synchronized (mH) {
        view = mServedView;
        // Make sure we have a window token for the served view.
        if (DEBUG)
            Log.v(TAG, "Starting input: view=" + view);
        if (view == null) {
            if (DEBUG)
                Log.v(TAG, "ABORT input: no served view!");
            return false;
        }
    }
    // Now we need to get an input connection from the served view.
    // This is complicated in a couple ways: we can't be holding our lock
    // when calling out to the view, and we need to make sure we call into
    // the view on the same thread that is driving its view hierarchy.
    Handler vh = view.getHandler();
    if (vh == null) {
        // screen without a connection.
        if (DEBUG)
            Log.v(TAG, "ABORT input: no handler for view! Close current input.");
        closeCurrentInput();
        return false;
    }
    if (vh.getLooper() != Looper.myLooper()) {
        // we need to reschedule our work for over there.
        if (DEBUG)
            Log.v(TAG, "Starting input: reschedule to view thread");
        vh.post(new Runnable() {

            @Override
            public void run() {
                startInputInner(null, 0, 0, 0);
            }
        });
        return false;
    }
    // Okay we are now ready to call into the served view and have it
    // do its stuff.
    // Life is good: let's hook everything up!
    EditorInfo tba = new EditorInfo();
    // Note: Use Context#getOpPackageName() rather than Context#getPackageName() so that the
    // system can verify the consistency between the uid of this process and package name passed
    // from here. See comment of Context#getOpPackageName() for details.
    tba.packageName = view.getContext().getOpPackageName();
    tba.fieldId = view.getId();
    InputConnection ic = view.onCreateInputConnection(tba);
    if (DEBUG)
        Log.v(TAG, "Starting input: tba=" + tba + " ic=" + ic);
    synchronized (mH) {
        // changed.
        if (mServedView != view || !mServedConnecting) {
            // Something else happened, so abort.
            if (DEBUG)
                Log.v(TAG, "Starting input: finished by someone else (view=" + mServedView + " conn=" + mServedConnecting + ")");
            return false;
        }
        // connected so we want to restart it.
        if (mCurrentTextBoxAttribute == null) {
            controlFlags |= CONTROL_START_INITIAL;
        }
        // Hook 'em up and let 'er rip.
        mCurrentTextBoxAttribute = tba;
        mServedConnecting = false;
        // Notify the served view that its previous input connection is finished
        notifyInputConnectionFinished();
        mServedInputConnection = ic;
        ControlledInputConnectionWrapper servedContext;
        if (ic != null) {
            mCursorSelStart = tba.initialSelStart;
            mCursorSelEnd = tba.initialSelEnd;
            mCursorCandStart = -1;
            mCursorCandEnd = -1;
            mCursorRect.setEmpty();
            mCursorAnchorInfo = null;
            servedContext = new ControlledInputConnectionWrapper(vh.getLooper(), ic, this);
        } else {
            servedContext = null;
        }
        if (mServedInputConnectionWrapper != null) {
            mServedInputConnectionWrapper.deactivate();
        }
        mServedInputConnectionWrapper = servedContext;
        try {
            if (DEBUG)
                Log.v(TAG, "START INPUT: " + view + " ic=" + ic + " tba=" + tba + " controlFlags=#" + Integer.toHexString(controlFlags));
            InputBindResult res;
            if (windowGainingFocus != null) {
                res = mService.windowGainedFocus(mClient, windowGainingFocus, controlFlags, softInputMode, windowFlags, tba, servedContext);
            } else {
                res = mService.startInput(mClient, servedContext, tba, controlFlags);
            }
            if (DEBUG)
                Log.v(TAG, "Starting input: Bind result=" + res);
            if (res != null) {
                if (res.id != null) {
                    setInputChannelLocked(res.channel);
                    mBindSequence = res.sequence;
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mNextUserActionNotificationSequenceNumber = res.userActionNotificationSequenceNumber;
                } else {
                    if (res.channel != null && res.channel != mCurChannel) {
                        res.channel.dispose();
                    }
                    if (mCurMethod == null) {
                        // This means there is no input method available.
                        if (DEBUG)
                            Log.v(TAG, "ABORT input: no input method!");
                        return true;
                    }
                }
            }
            if (mCurMethod != null && mCompletions != null) {
                try {
                    mCurMethod.displayCompletions(mCompletions);
                } catch (RemoteException e) {
                }
            }
        } catch (RemoteException e) {
            Log.w(TAG, "IME died: " + mCurId, e);
        }
    }
    return true;
}
#method_after
boolean startInputInner(@InputMethodClient.StartInputReason final int startInputReason, IBinder windowGainingFocus, int controlFlags, int softInputMode, int windowFlags) {
    final View view;
    synchronized (mH) {
        view = mServedView;
        // Make sure we have a window token for the served view.
        if (DEBUG) {
            Log.v(TAG, "Starting input: view=" + dumpViewInfo(view) + " reason=" + InputMethodClient.getStartInputReason(startInputReason));
        }
        if (view == null) {
            if (DEBUG)
                Log.v(TAG, "ABORT input: no served view!");
            return false;
        }
    }
    // Now we need to get an input connection from the served view.
    // This is complicated in a couple ways: we can't be holding our lock
    // when calling out to the view, and we need to make sure we call into
    // the view on the same thread that is driving its view hierarchy.
    Handler vh = view.getHandler();
    if (vh == null) {
        // screen without a connection.
        if (DEBUG)
            Log.v(TAG, "ABORT input: no handler for view! Close current input.");
        closeCurrentInput();
        return false;
    }
    if (vh.getLooper() != Looper.myLooper()) {
        // we need to reschedule our work for over there.
        if (DEBUG)
            Log.v(TAG, "Starting input: reschedule to view thread");
        vh.post(new Runnable() {

            @Override
            public void run() {
                startInputInner(startInputReason, null, 0, 0, 0);
            }
        });
        return false;
    }
    // Okay we are now ready to call into the served view and have it
    // do its stuff.
    // Life is good: let's hook everything up!
    EditorInfo tba = new EditorInfo();
    // Note: Use Context#getOpPackageName() rather than Context#getPackageName() so that the
    // system can verify the consistency between the uid of this process and package name passed
    // from here. See comment of Context#getOpPackageName() for details.
    tba.packageName = view.getContext().getOpPackageName();
    tba.fieldId = view.getId();
    InputConnection ic = view.onCreateInputConnection(tba);
    if (DEBUG)
        Log.v(TAG, "Starting input: tba=" + tba + " ic=" + ic);
    synchronized (mH) {
        // changed.
        if (mServedView != view || !mServedConnecting) {
            // Something else happened, so abort.
            if (DEBUG)
                Log.v(TAG, "Starting input: finished by someone else. view=" + dumpViewInfo(view) + " mServedView=" + dumpViewInfo(mServedView) + " mServedConnecting=" + mServedConnecting);
            return false;
        }
        // connected so we want to restart it.
        if (mCurrentTextBoxAttribute == null) {
            controlFlags |= CONTROL_START_INITIAL;
        }
        // Hook 'em up and let 'er rip.
        mCurrentTextBoxAttribute = tba;
        mServedConnecting = false;
        if (mServedInputConnectionWrapper != null) {
            mServedInputConnectionWrapper.deactivate();
            mServedInputConnectionWrapper = null;
        }
        ControlledInputConnectionWrapper servedContext;
        final int missingMethodFlags;
        if (ic != null) {
            mCursorSelStart = tba.initialSelStart;
            mCursorSelEnd = tba.initialSelEnd;
            mCursorCandStart = -1;
            mCursorCandEnd = -1;
            mCursorRect.setEmpty();
            mCursorAnchorInfo = null;
            final Handler icHandler;
            missingMethodFlags = InputConnectionInspector.getMissingMethodFlags(ic);
            if ((missingMethodFlags & InputConnectionInspector.MissingMethodFlags.GET_HANDLER) != 0) {
                // InputConnection#getHandler() is not implemented.
                icHandler = null;
            } else {
                icHandler = ic.getHandler();
            }
            servedContext = new ControlledInputConnectionWrapper(icHandler != null ? icHandler.getLooper() : vh.getLooper(), ic, this);
        } else {
            servedContext = null;
            missingMethodFlags = 0;
        }
        mServedInputConnectionWrapper = servedContext;
        try {
            if (DEBUG)
                Log.v(TAG, "START INPUT: view=" + dumpViewInfo(view) + " ic=" + ic + " tba=" + tba + " controlFlags=#" + Integer.toHexString(controlFlags));
            final InputBindResult res = mService.startInputOrWindowGainedFocus(startInputReason, mClient, windowGainingFocus, controlFlags, softInputMode, windowFlags, tba, servedContext, missingMethodFlags);
            if (DEBUG)
                Log.v(TAG, "Starting input: Bind result=" + res);
            if (res != null) {
                if (res.id != null) {
                    setInputChannelLocked(res.channel);
                    mBindSequence = res.sequence;
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mNextUserActionNotificationSequenceNumber = res.userActionNotificationSequenceNumber;
                    if (mServedInputConnectionWrapper != null) {
                        mServedInputConnectionWrapper.setInputMethodId(mCurId);
                    }
                } else {
                    if (res.channel != null && res.channel != mCurChannel) {
                        res.channel.dispose();
                    }
                    if (mCurMethod == null) {
                        // This means there is no input method available.
                        if (DEBUG)
                            Log.v(TAG, "ABORT input: no input method!");
                        return true;
                    }
                }
            } else {
                if (startInputReason == InputMethodClient.START_INPUT_REASON_WINDOW_FOCUS_GAIN) {
                    // TODO: InputBindResult should have the error code.
                    if (DEBUG)
                        Log.w(TAG, "startInputOrWindowGainedFocus failed. " + "Window focus may have already been lost. " + "win=" + windowGainingFocus + " view=" + dumpViewInfo(view));
                    if (!mActive) {
                        // mHasBeenInactive is a latch switch to forcefully refresh IME focus
                        // state when an inactive (mActive == false) client is gaining window
                        // focus. In case we have unnecessary disable the latch due to this
                        // spurious wakeup, we re-enable the latch here.
                        // TODO: Come up with more robust solution.
                        mHasBeenInactive = true;
                    }
                }
            }
            if (mCurMethod != null && mCompletions != null) {
                try {
                    mCurMethod.displayCompletions(mCompletions);
                } catch (RemoteException e) {
                }
            }
        } catch (RemoteException e) {
            Log.w(TAG, "IME died: " + mCurId, e);
        }
    }
    return true;
}
#end_block

#method_before
void focusInLocked(View view) {
    if (DEBUG)
        Log.v(TAG, "focusIn: " + view);
    if (mCurRootView != view.getRootView()) {
        // IME focus, so ignore it.
        if (DEBUG)
            Log.v(TAG, "Not IME target window, ignoring");
        return;
    }
    mNextServedView = view;
    scheduleCheckFocusLocked(view);
}
#method_after
void focusInLocked(View view) {
    if (DEBUG)
        Log.v(TAG, "focusIn: " + dumpViewInfo(view));
    if (view != null && view.isTemporarilyDetached()) {
        // This is a request from a view that is temporarily detached from a window.
        if (DEBUG)
            Log.v(TAG, "Temporarily detached view, ignoring");
        return;
    }
    if (mCurRootView != view.getRootView()) {
        // IME focus, so ignore it.
        if (DEBUG)
            Log.v(TAG, "Not IME target window, ignoring");
        return;
    }
    mNextServedView = view;
    scheduleCheckFocusLocked(view);
}
#end_block

#method_before
public void focusOut(View view) {
    synchronized (mH) {
        if (DEBUG)
            Log.v(TAG, "focusOut: " + view + " mServedView=" + mServedView + " winFocus=" + view.hasWindowFocus());
        if (mServedView != view) {
            // seems better to just turn it all off.
            if (false && view.hasWindowFocus()) {
                mNextServedView = null;
                scheduleCheckFocusLocked(view);
            }
        }
    }
}
#method_after
public void focusOut(View view) {
    synchronized (mH) {
        if (DEBUG)
            Log.v(TAG, "focusOut: view=" + dumpViewInfo(view) + " mServedView=" + dumpViewInfo(mServedView));
        if (mServedView != view) {
            // TODO: Check view.isTemporarilyDetached() when re-enable the following code.
            if (false && view.hasWindowFocus()) {
                mNextServedView = null;
                scheduleCheckFocusLocked(view);
            }
        }
    }
}
#end_block

#method_before
public void onViewDetachedFromWindow(View view) {
    synchronized (mH) {
        if (DEBUG)
            Log.v(TAG, "onViewDetachedFromWindow: " + view + " mServedView=" + mServedView + " hasWindowFocus=" + view.hasWindowFocus());
        if (mServedView == view && view.hasWindowFocus()) {
            mNextServedView = null;
            scheduleCheckFocusLocked(view);
        }
    }
}
#method_after
public void onViewDetachedFromWindow(View view) {
    synchronized (mH) {
        if (DEBUG)
            Log.v(TAG, "onViewDetachedFromWindow: view=" + dumpViewInfo(view) + " mServedView=" + dumpViewInfo(mServedView));
        if (mServedView == view) {
            mNextServedView = null;
            scheduleCheckFocusLocked(view);
        }
    }
}
#end_block

#method_before
public void checkFocus() {
    if (checkFocusNoStartInput(false, true)) {
        startInputInner(null, 0, 0, 0);
    }
}
#method_after
public void checkFocus() {
    if (checkFocusNoStartInput(false)) {
        startInputInner(InputMethodClient.START_INPUT_REASON_CHECK_FOCUS, null, 0, 0, 0);
    }
}
#end_block

#method_before
private boolean checkFocusNoStartInput(boolean forceNewFocus, boolean finishComposingText) {
    // This is called a lot, so short-circuit before locking.
    if (mServedView == mNextServedView && !forceNewFocus) {
        return false;
    }
    InputConnection ic = null;
    synchronized (mH) {
        if (mServedView == mNextServedView && !forceNewFocus) {
            return false;
        }
        if (DEBUG)
            Log.v(TAG, "checkFocus: view=" + mServedView + " next=" + mNextServedView + " forceNewFocus=" + forceNewFocus + " package=" + (mServedView != null ? mServedView.getContext().getPackageName() : "<none>"));
        if (mNextServedView == null) {
            finishInputLocked();
            // In this case, we used to have a focused view on the window,
            // but no longer do.  We should make sure the input method is
            // no longer shown, since it serves no purpose.
            closeCurrentInput();
            return false;
        }
        ic = mServedInputConnection;
        mServedView = mNextServedView;
        mCurrentTextBoxAttribute = null;
        mCompletions = null;
        mServedConnecting = true;
    }
    if (finishComposingText && ic != null) {
        ic.finishComposingText();
    }
    return true;
}
#method_after
private boolean checkFocusNoStartInput(boolean forceNewFocus) {
    // This is called a lot, so short-circuit before locking.
    if (mServedView == mNextServedView && !forceNewFocus) {
        return false;
    }
    final ControlledInputConnectionWrapper ic;
    synchronized (mH) {
        if (mServedView == mNextServedView && !forceNewFocus) {
            return false;
        }
        if (DEBUG)
            Log.v(TAG, "checkFocus: view=" + mServedView + " next=" + mNextServedView + " forceNewFocus=" + forceNewFocus + " package=" + (mServedView != null ? mServedView.getContext().getPackageName() : "<none>"));
        if (mNextServedView == null) {
            finishInputLocked();
            // In this case, we used to have a focused view on the window,
            // but no longer do.  We should make sure the input method is
            // no longer shown, since it serves no purpose.
            closeCurrentInput();
            return false;
        }
        ic = mServedInputConnectionWrapper;
        mServedView = mNextServedView;
        mCurrentTextBoxAttribute = null;
        mCompletions = null;
        mServedConnecting = true;
    }
    if (ic != null) {
        ic.finishComposingText();
    }
    return true;
}
#end_block

#method_before
void closeCurrentInput() {
    try {
        mService.hideSoftInput(mClient, HIDE_NOT_ALWAYS, null);
    } catch (RemoteException e) {
    }
}
#method_after
void closeCurrentInput() {
    try {
        mService.hideSoftInput(mClient, HIDE_NOT_ALWAYS, null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public void onPostWindowFocus(View rootView, View focusedView, int softInputMode, boolean first, int windowFlags) {
    boolean forceNewFocus = false;
    synchronized (mH) {
        if (DEBUG)
            Log.v(TAG, "onWindowFocus: " + focusedView + " softInputMode=" + softInputMode + " first=" + first + " flags=#" + Integer.toHexString(windowFlags));
        if (mHasBeenInactive) {
            if (DEBUG)
                Log.v(TAG, "Has been inactive!  Starting fresh");
            mHasBeenInactive = false;
            forceNewFocus = true;
        }
        focusInLocked(focusedView != null ? focusedView : rootView);
    }
    int controlFlags = 0;
    if (focusedView != null) {
        controlFlags |= CONTROL_WINDOW_VIEW_HAS_FOCUS;
        if (focusedView.onCheckIsTextEditor()) {
            controlFlags |= CONTROL_WINDOW_IS_TEXT_EDITOR;
        }
    }
    if (first) {
        controlFlags |= CONTROL_WINDOW_FIRST;
    }
    if (checkFocusNoStartInput(forceNewFocus, true)) {
        // smooth.
        if (startInputInner(rootView.getWindowToken(), controlFlags, softInputMode, windowFlags)) {
            return;
        }
    }
    // we'll just do a window focus gain and call it a day.
    synchronized (mH) {
        try {
            if (DEBUG)
                Log.v(TAG, "Reporting focus gain, without startInput");
            mService.windowGainedFocus(mClient, rootView.getWindowToken(), controlFlags, softInputMode, windowFlags, null, null);
        } catch (RemoteException e) {
        }
    }
}
#method_after
public void onPostWindowFocus(View rootView, View focusedView, int softInputMode, boolean first, int windowFlags) {
    boolean forceNewFocus = false;
    synchronized (mH) {
        if (DEBUG)
            Log.v(TAG, "onWindowFocus: " + focusedView + " softInputMode=" + softInputMode + " first=" + first + " flags=#" + Integer.toHexString(windowFlags));
        if (mHasBeenInactive) {
            if (DEBUG)
                Log.v(TAG, "Has been inactive!  Starting fresh");
            mHasBeenInactive = false;
            forceNewFocus = true;
        }
        focusInLocked(focusedView != null ? focusedView : rootView);
    }
    int controlFlags = 0;
    if (focusedView != null) {
        controlFlags |= CONTROL_WINDOW_VIEW_HAS_FOCUS;
        if (focusedView.onCheckIsTextEditor()) {
            controlFlags |= CONTROL_WINDOW_IS_TEXT_EDITOR;
        }
    }
    if (first) {
        controlFlags |= CONTROL_WINDOW_FIRST;
    }
    if (checkFocusNoStartInput(forceNewFocus)) {
        // smooth.
        if (startInputInner(InputMethodClient.START_INPUT_REASON_WINDOW_FOCUS_GAIN, rootView.getWindowToken(), controlFlags, softInputMode, windowFlags)) {
            return;
        }
    }
    // we'll just do a window focus gain and call it a day.
    synchronized (mH) {
        try {
            if (DEBUG)
                Log.v(TAG, "Reporting focus gain, without startInput");
            mService.startInputOrWindowGainedFocus(InputMethodClient.START_INPUT_REASON_WINDOW_FOCUS_GAIN_REPORT_ONLY, mClient, rootView.getWindowToken(), controlFlags, softInputMode, windowFlags, null, null, 0);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}
#end_block

#method_before
public void setInputMethod(IBinder token, String id) {
    try {
        mService.setInputMethod(token, id);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
#method_after
public void setInputMethod(IBinder token, String id) {
    try {
        mService.setInputMethod(token, id);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public void setInputMethodAndSubtype(IBinder token, String id, InputMethodSubtype subtype) {
    try {
        mService.setInputMethodAndSubtype(token, id, subtype);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
#method_after
public void setInputMethodAndSubtype(IBinder token, String id, InputMethodSubtype subtype) {
    try {
        mService.setInputMethodAndSubtype(token, id, subtype);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public void hideSoftInputFromInputMethod(IBinder token, int flags) {
    try {
        mService.hideMySoftInput(token, flags);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
#method_after
public void hideSoftInputFromInputMethod(IBinder token, int flags) {
    try {
        mService.hideMySoftInput(token, flags);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public void showSoftInputFromInputMethod(IBinder token, int flags) {
    try {
        mService.showMySoftInput(token, flags);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
#method_after
public void showSoftInputFromInputMethod(IBinder token, int flags) {
    try {
        mService.showMySoftInput(token, flags);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public void showInputMethodPicker(boolean showAuxiliarySubtypes) {
    synchronized (mH) {
        try {
            final int mode = showAuxiliarySubtypes ? SHOW_IM_PICKER_MODE_INCLUDE_AUXILIARY_SUBTYPES : SHOW_IM_PICKER_MODE_EXCLUDE_AUXILIARY_SUBTYPES;
            mService.showInputMethodPickerFromClient(mClient, mode);
        } catch (RemoteException e) {
            Log.w(TAG, "IME died: " + mCurId, e);
        }
    }
}
#method_after
public void showInputMethodPicker(boolean showAuxiliarySubtypes) {
    synchronized (mH) {
        try {
            final int mode = showAuxiliarySubtypes ? SHOW_IM_PICKER_MODE_INCLUDE_AUXILIARY_SUBTYPES : SHOW_IM_PICKER_MODE_EXCLUDE_AUXILIARY_SUBTYPES;
            mService.showInputMethodPickerFromClient(mClient, mode);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}
#end_block

#method_before
private void showInputMethodPickerLocked() {
    try {
        mService.showInputMethodPickerFromClient(mClient, SHOW_IM_PICKER_MODE_AUTO);
    } catch (RemoteException e) {
        Log.w(TAG, "IME died: " + mCurId, e);
    }
}
#method_after
private void showInputMethodPickerLocked() {
    try {
        mService.showInputMethodPickerFromClient(mClient, SHOW_IM_PICKER_MODE_AUTO);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public void showInputMethodAndSubtypeEnabler(String imiId) {
    synchronized (mH) {
        try {
            mService.showInputMethodAndSubtypeEnablerFromClient(mClient, imiId);
        } catch (RemoteException e) {
            Log.w(TAG, "IME died: " + mCurId, e);
        }
    }
}
#method_after
public void showInputMethodAndSubtypeEnabler(String imiId) {
    synchronized (mH) {
        try {
            mService.showInputMethodAndSubtypeEnablerFromClient(mClient, imiId);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}
#end_block

#method_before
public InputMethodSubtype getCurrentInputMethodSubtype() {
    try {
        return mService.getCurrentInputMethodSubtype();
    } catch (RemoteException e) {
        Log.w(TAG, "IME died: " + mCurId, e);
        return null;
    }
}
#method_after
public InputMethodSubtype getCurrentInputMethodSubtype() {
    try {
        return mService.getCurrentInputMethodSubtype();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@RequiresPermission(WRITE_SECURE_SETTINGS)
public boolean setCurrentInputMethodSubtype(InputMethodSubtype subtype) {
    synchronized (mH) {
        try {
            return mService.setCurrentInputMethodSubtype(subtype);
        } catch (RemoteException e) {
            Log.w(TAG, "IME died: " + mCurId, e);
            return false;
        }
    }
}
#method_after
@RequiresPermission(WRITE_SECURE_SETTINGS)
public boolean setCurrentInputMethodSubtype(InputMethodSubtype subtype) {
    synchronized (mH) {
        try {
            return mService.setCurrentInputMethodSubtype(subtype);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}
#end_block

#method_before
public void notifyUserAction() {
    synchronized (mH) {
        if (mLastSentUserActionNotificationSequenceNumber == mNextUserActionNotificationSequenceNumber) {
            if (DEBUG) {
                Log.w(TAG, "Ignoring notifyUserAction as it has already been sent." + " mLastSentUserActionNotificationSequenceNumber: " + mLastSentUserActionNotificationSequenceNumber + " mNextUserActionNotificationSequenceNumber: " + mNextUserActionNotificationSequenceNumber);
            }
            return;
        }
        try {
            if (DEBUG) {
                Log.w(TAG, "notifyUserAction: " + " mLastSentUserActionNotificationSequenceNumber: " + mLastSentUserActionNotificationSequenceNumber + " mNextUserActionNotificationSequenceNumber: " + mNextUserActionNotificationSequenceNumber);
            }
            mService.notifyUserAction(mNextUserActionNotificationSequenceNumber);
            mLastSentUserActionNotificationSequenceNumber = mNextUserActionNotificationSequenceNumber;
        } catch (RemoteException e) {
            Log.w(TAG, "IME died: " + mCurId, e);
        }
    }
}
#method_after
public void notifyUserAction() {
    synchronized (mH) {
        if (mLastSentUserActionNotificationSequenceNumber == mNextUserActionNotificationSequenceNumber) {
            if (DEBUG) {
                Log.w(TAG, "Ignoring notifyUserAction as it has already been sent." + " mLastSentUserActionNotificationSequenceNumber: " + mLastSentUserActionNotificationSequenceNumber + " mNextUserActionNotificationSequenceNumber: " + mNextUserActionNotificationSequenceNumber);
            }
            return;
        }
        try {
            if (DEBUG) {
                Log.w(TAG, "notifyUserAction: " + " mLastSentUserActionNotificationSequenceNumber: " + mLastSentUserActionNotificationSequenceNumber + " mNextUserActionNotificationSequenceNumber: " + mNextUserActionNotificationSequenceNumber);
            }
            mService.notifyUserAction(mNextUserActionNotificationSequenceNumber);
            mLastSentUserActionNotificationSequenceNumber = mNextUserActionNotificationSequenceNumber;
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}
#end_block

#method_before
public Map<InputMethodInfo, List<InputMethodSubtype>> getShortcutInputMethodsAndSubtypes() {
    synchronized (mH) {
        HashMap<InputMethodInfo, List<InputMethodSubtype>> ret = new HashMap<InputMethodInfo, List<InputMethodSubtype>>();
        try {
            // TODO: We should change the return type from List<Object> to List<Parcelable>
            List<Object> info = mService.getShortcutInputMethodsAndSubtypes();
            // "info" has imi1, subtype1, subtype2, imi2, subtype2, imi3, subtype3..in the list
            ArrayList<InputMethodSubtype> subtypes = null;
            if (info != null && !info.isEmpty()) {
                final int N = info.size();
                for (int i = 0; i < N; ++i) {
                    Object o = info.get(i);
                    if (o instanceof InputMethodInfo) {
                        if (ret.containsKey(o)) {
                            Log.e(TAG, "IMI list already contains the same InputMethod.");
                            break;
                        }
                        subtypes = new ArrayList<InputMethodSubtype>();
                        ret.put((InputMethodInfo) o, subtypes);
                    } else if (subtypes != null && o instanceof InputMethodSubtype) {
                        subtypes.add((InputMethodSubtype) o);
                    }
                }
            }
        } catch (RemoteException e) {
            Log.w(TAG, "IME died: " + mCurId, e);
        }
        return ret;
    }
}
#method_after
public Map<InputMethodInfo, List<InputMethodSubtype>> getShortcutInputMethodsAndSubtypes() {
    synchronized (mH) {
        HashMap<InputMethodInfo, List<InputMethodSubtype>> ret = new HashMap<>();
        try {
            // TODO: We should change the return type from List<Object> to List<Parcelable>
            List<Object> info = mService.getShortcutInputMethodsAndSubtypes();
            // "info" has imi1, subtype1, subtype2, imi2, subtype2, imi3, subtype3..in the list
            ArrayList<InputMethodSubtype> subtypes = null;
            if (info != null && !info.isEmpty()) {
                final int N = info.size();
                for (int i = 0; i < N; ++i) {
                    Object o = info.get(i);
                    if (o instanceof InputMethodInfo) {
                        if (ret.containsKey(o)) {
                            Log.e(TAG, "IMI list already contains the same InputMethod.");
                            break;
                        }
                        subtypes = new ArrayList<>();
                        ret.put((InputMethodInfo) o, subtypes);
                    } else if (subtypes != null && o instanceof InputMethodSubtype) {
                        subtypes.add((InputMethodSubtype) o);
                    }
                }
            }
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
        return ret;
    }
}
#end_block

#method_before
public int getInputMethodWindowVisibleHeight() {
    synchronized (mH) {
        try {
            return mService.getInputMethodWindowVisibleHeight();
        } catch (RemoteException e) {
            Log.w(TAG, "IME died: " + mCurId, e);
            return 0;
        }
    }
}
#method_after
public int getInputMethodWindowVisibleHeight() {
    synchronized (mH) {
        try {
            return mService.getInputMethodWindowVisibleHeight();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}
#end_block

#method_before
public boolean switchToLastInputMethod(IBinder imeToken) {
    synchronized (mH) {
        try {
            return mService.switchToLastInputMethod(imeToken);
        } catch (RemoteException e) {
            Log.w(TAG, "IME died: " + mCurId, e);
            return false;
        }
    }
}
#method_after
public boolean switchToLastInputMethod(IBinder imeToken) {
    synchronized (mH) {
        try {
            return mService.switchToLastInputMethod(imeToken);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}
#end_block

#method_before
public boolean switchToNextInputMethod(IBinder imeToken, boolean onlyCurrentIme) {
    synchronized (mH) {
        try {
            return mService.switchToNextInputMethod(imeToken, onlyCurrentIme);
        } catch (RemoteException e) {
            Log.w(TAG, "IME died: " + mCurId, e);
            return false;
        }
    }
}
#method_after
public boolean switchToNextInputMethod(IBinder imeToken, boolean onlyCurrentIme) {
    synchronized (mH) {
        try {
            return mService.switchToNextInputMethod(imeToken, onlyCurrentIme);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}
#end_block

#method_before
public boolean shouldOfferSwitchingToNextInputMethod(IBinder imeToken) {
    synchronized (mH) {
        try {
            return mService.shouldOfferSwitchingToNextInputMethod(imeToken);
        } catch (RemoteException e) {
            Log.w(TAG, "IME died: " + mCurId, e);
            return false;
        }
    }
}
#method_after
public boolean shouldOfferSwitchingToNextInputMethod(IBinder imeToken) {
    synchronized (mH) {
        try {
            return mService.shouldOfferSwitchingToNextInputMethod(imeToken);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}
#end_block

#method_before
public void setAdditionalInputMethodSubtypes(String imiId, InputMethodSubtype[] subtypes) {
    synchronized (mH) {
        try {
            mService.setAdditionalInputMethodSubtypes(imiId, subtypes);
        } catch (RemoteException e) {
            Log.w(TAG, "IME died: " + mCurId, e);
        }
    }
}
#method_after
public void setAdditionalInputMethodSubtypes(String imiId, InputMethodSubtype[] subtypes) {
    synchronized (mH) {
        try {
            mService.setAdditionalInputMethodSubtypes(imiId, subtypes);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}
#end_block

#method_before
public InputMethodSubtype getLastInputMethodSubtype() {
    synchronized (mH) {
        try {
            return mService.getLastInputMethodSubtype();
        } catch (RemoteException e) {
            Log.w(TAG, "IME died: " + mCurId, e);
            return null;
        }
    }
}
#method_after
public InputMethodSubtype getLastInputMethodSubtype() {
    synchronized (mH) {
        try {
            return mService.getLastInputMethodSubtype();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}
#end_block

#method_before
void doDump(FileDescriptor fd, PrintWriter fout, String[] args) {
    final Printer p = new PrintWriterPrinter(fout);
    p.println("Input method client state for " + this + ":");
    p.println("  mService=" + mService);
    p.println("  mMainLooper=" + mMainLooper);
    p.println("  mIInputContext=" + mIInputContext);
    p.println("  mActive=" + mActive + " mHasBeenInactive=" + mHasBeenInactive + " mBindSequence=" + mBindSequence + " mCurId=" + mCurId);
    p.println("  mCurMethod=" + mCurMethod);
    p.println("  mCurRootView=" + mCurRootView);
    p.println("  mServedView=" + mServedView);
    p.println("  mNextServedView=" + mNextServedView);
    p.println("  mServedConnecting=" + mServedConnecting);
    if (mCurrentTextBoxAttribute != null) {
        p.println("  mCurrentTextBoxAttribute:");
        mCurrentTextBoxAttribute.dump(p, "    ");
    } else {
        p.println("  mCurrentTextBoxAttribute: null");
    }
    p.println("  mServedInputConnection=" + mServedInputConnection);
    p.println("  mCompletions=" + mCompletions);
    p.println("  mCursorRect=" + mCursorRect);
    p.println("  mCursorSelStart=" + mCursorSelStart + " mCursorSelEnd=" + mCursorSelEnd + " mCursorCandStart=" + mCursorCandStart + " mCursorCandEnd=" + mCursorCandEnd);
    p.println("  mNextUserActionNotificationSequenceNumber=" + mNextUserActionNotificationSequenceNumber + " mLastSentUserActionNotificationSequenceNumber=" + mLastSentUserActionNotificationSequenceNumber);
}
#method_after
void doDump(FileDescriptor fd, PrintWriter fout, String[] args) {
    final Printer p = new PrintWriterPrinter(fout);
    p.println("Input method client state for " + this + ":");
    p.println("  mService=" + mService);
    p.println("  mMainLooper=" + mMainLooper);
    p.println("  mIInputContext=" + mIInputContext);
    p.println("  mActive=" + mActive + " mHasBeenInactive=" + mHasBeenInactive + " mBindSequence=" + mBindSequence + " mCurId=" + mCurId);
    p.println("  mCurMethod=" + mCurMethod);
    p.println("  mCurRootView=" + mCurRootView);
    p.println("  mServedView=" + mServedView);
    p.println("  mNextServedView=" + mNextServedView);
    p.println("  mServedConnecting=" + mServedConnecting);
    if (mCurrentTextBoxAttribute != null) {
        p.println("  mCurrentTextBoxAttribute:");
        mCurrentTextBoxAttribute.dump(p, "    ");
    } else {
        p.println("  mCurrentTextBoxAttribute: null");
    }
    p.println("  mServedInputConnectionWrapper=" + mServedInputConnectionWrapper);
    p.println("  mCompletions=" + Arrays.toString(mCompletions));
    p.println("  mCursorRect=" + mCursorRect);
    p.println("  mCursorSelStart=" + mCursorSelStart + " mCursorSelEnd=" + mCursorSelEnd + " mCursorCandStart=" + mCursorCandStart + " mCursorCandEnd=" + mCursorCandEnd);
    p.println("  mNextUserActionNotificationSequenceNumber=" + mNextUserActionNotificationSequenceNumber + " mLastSentUserActionNotificationSequenceNumber=" + mLastSentUserActionNotificationSequenceNumber);
}
#end_block

#method_before
public void test_xattr_Errno() throws Exception {
    File file = File.createTempFile("xattr", "test");
    final String path = file.getAbsolutePath();
    final String NAME_TEST = "user.meow";
    final byte[] VALUE_CAKE = "cake cake cake".getBytes(StandardCharsets.UTF_8);
    // ENOENT, No such file or directory.
    try {
        Libcore.os.getxattr("", NAME_TEST);
        fail();
    } catch (ErrnoException e) {
        assertEquals(ENOENT, e.errno);
    }
    try {
        Libcore.os.listxattr("");
        fail();
    } catch (ErrnoException e) {
        assertEquals(ENOENT, e.errno);
    }
    try {
        Libcore.os.removexattr("", NAME_TEST);
        fail();
    } catch (ErrnoException e) {
        assertEquals(ENOENT, e.errno);
    }
    try {
        Libcore.os.setxattr("", NAME_TEST, VALUE_CAKE, OsConstants.XATTR_CREATE);
        fail();
    } catch (ErrnoException e) {
        assertEquals(ENOENT, e.errno);
    }
    // Also accept EACCES since we might not have access permissions to proc filesystem.
    try {
        Libcore.os.getxattr("/proc/version", NAME_TEST);
        fail();
    } catch (ErrnoException e) {
        assertTrue(e.errno == EACCES || e.errno == ENOTSUP);
    }
    try {
        // Linux listxattr does not set errno.
        Libcore.os.listxattr("/proc/version");
    } catch (ErrnoException e) {
        fail();
    }
    try {
        Libcore.os.removexattr("/proc/version", "security.selinux");
        fail();
    } catch (ErrnoException e) {
        assertTrue(e.errno == EACCES || e.errno == ENOTSUP);
    }
    try {
        Libcore.os.setxattr("/proc/version", NAME_TEST, VALUE_CAKE, OsConstants.XATTR_CREATE);
        fail();
    } catch (ErrnoException e) {
        assertTrue(e.errno == EACCES || e.errno == ENOTSUP);
    }
}
#method_after
public void test_xattr_Errno() throws Exception {
    final String NAME_TEST = "user.meow";
    final byte[] VALUE_CAKE = "cake cake cake".getBytes(StandardCharsets.UTF_8);
    // ENOENT, No such file or directory.
    try {
        Libcore.os.getxattr("", NAME_TEST);
        fail();
    } catch (ErrnoException e) {
        assertEquals(ENOENT, e.errno);
    }
    try {
        Libcore.os.listxattr("");
        fail();
    } catch (ErrnoException e) {
        assertEquals(ENOENT, e.errno);
    }
    try {
        Libcore.os.removexattr("", NAME_TEST);
        fail();
    } catch (ErrnoException e) {
        assertEquals(ENOENT, e.errno);
    }
    try {
        Libcore.os.setxattr("", NAME_TEST, VALUE_CAKE, OsConstants.XATTR_CREATE);
        fail();
    } catch (ErrnoException e) {
        assertEquals(ENOENT, e.errno);
    }
    // ENOTSUP, Extended attributes are not supported by the filesystem, or are disabled.
    final boolean root = (Libcore.os.getuid() == 0);
    final String path = "/proc/self/stat";
    try {
        Libcore.os.setxattr(path, NAME_TEST, VALUE_CAKE, OsConstants.XATTR_CREATE);
        fail();
    } catch (ErrnoException e) {
        // setxattr(2) requires root permission for writing to this file, will get EACCES otherwise.
        assertEquals(root ? ENOTSUP : EACCES, e.errno);
    }
    try {
        Libcore.os.getxattr(path, NAME_TEST);
        fail();
    } catch (ErrnoException e) {
        assertEquals(ENOTSUP, e.errno);
    }
    try {
        // Linux listxattr does not set errno.
        Libcore.os.listxattr(path);
    } catch (ErrnoException e) {
        fail();
    }
    try {
        Libcore.os.removexattr(path, NAME_TEST);
        fail();
    } catch (ErrnoException e) {
        assertEquals(ENOTSUP, e.errno);
    }
}
#end_block

#method_before
@Test
@TestInfo(id = "14578831")
public void bookmarkWebSiteInBrowser() throws Exception {
    Instrumentation instrumentation = testFramework.getInstrumentation();
    UiDevice device = UiDevice.getInstance(instrumentation);
    if (testFramework.getApi() >= 24) {
        AppLauncher.launch(instrumentation, "Chrome");
        // If this is the first launch, dismiss the "Welcome to Chrome" screen.
        UiObject acceptButton = device.findObject(new UiSelector().resourceId(Res.CHROME_TERMS_ACCEPT_BUTTON_RES));
        if (device.hasObject(By.res(Res.CHROME_WELCOME_TITLE_RES))) {
            if (acceptButton.exists()) {
                acceptButton.clickAndWaitForNewWindow();
            }
        }
        // Dismiss the "Sign in to Chrome" screen if it's there.
        if (device.hasObject(By.res(Res.CHROME_SIGN_IN_TITLE_RES))) {
            device.findObject(new UiSelector().resourceId(Res.CHROME_NEGATIVE_BUTTON_RES)).clickAndWaitForNewWindow();
        }
        // Dismiss the "Browse more for less" screen if it's there.
        UiObject noThanksButton = device.findObject(new UiSelector().resourceId(Res.CHROME_NO_THANKS_BUTTON));
        if (noThanksButton.exists()) {
            noThanksButton.clickAndWaitForNewWindow();
        }
        // Click the search box if it's there.
        UiObject searchBox = device.findObject(new UiSelector().resourceId(Res.CHROME_SEARCH_BOX_RES));
        if (searchBox.exists()) {
            searchBox.clickAndWaitForNewWindow();
        }
        UiObject textField = device.findObject(new UiSelector().resourceId(Res.CHROME_URL_BAR_RES));
        textField.click();
        textField.clearTextField();
        // Include a timestamp in the URL so it's not already bookmarked. (On Chrome, the UI
        // changes in that case.)
        textField.setText("https://httpbin.org/?d=" + new Date().getTime());
        device.pressEnter();
        device.pressMenu();
        device.findObject(new UiSelector().description("Bookmark this page")).click();
        device.pressMenu();
        // After bookmarking, the button description changes.
        assertTrue("Bookmark was not set", device.findObject(new UiSelector().description("Edit bookmark")).exists());
        // Verify the new bookmark is in the list.
        device.findObject(new UiSelector().text("Bookmarks")).clickAndWaitForNewWindow();
        assertTrue("Cannot find bookmark", device.findObject(new UiSelector().text("Bookmarks")).exists() && device.findObject(new UiSelector().textContains("httpbin").resourceId(Res.CHROME_BOOKMARKS_LABEL_RES)).exists());
        device.findObject(new UiSelector().resourceId(Res.CHROME_CLOSE_MENU_BUTTON_RES)).clickAndWaitForNewWindow();
        // Delete the bookmark.
        device.pressMenu();
        device.findObject(new UiSelector().description("Edit bookmark")).clickAndWaitForNewWindow();
        device.findObject(new UiSelector().description("Delete bookmarks")).click();
    } else {
        AppLauncher.launch(instrumentation, "Browser");
        UiObject textField = device.findObject(new UiSelector().resourceId(Res.BROWSER_URL_TEXT_FIELD_RES));
        textField.click();
        textField.clearTextField();
        textField.setText("espn.com");
        device.pressEnter();
        device.pressMenu();
        device.findObject(new UiSelector().text("Save to bookmarks")).click();
        device.findObject(new UiSelector().text("OK")).click();
        device.pressMenu();
        device.findObject(new UiSelector().text("Bookmarks")).click();
        assertTrue("Cannot find ESPN bookmark", device.findObject(new UiSelector().text("Bookmarks")).exists() && device.findObject(new UiSelector().textContains("ESPN").resourceId(Res.BROWSER_BOOKMARKS_LABEL_RES)).exists());
    }
}
#method_after
@Test
@TestInfo(id = "14578831")
public void bookmarkWebSiteInBrowser() throws Exception {
    Instrumentation instrumentation = testFramework.getInstrumentation();
    UiDevice device = UiDevice.getInstance(instrumentation);
    if (testFramework.getApi() >= 24) {
        AppLauncher.launch(instrumentation, "Chrome");
        // If this is the first launch, dismiss the "Welcome to Chrome" screen.
        UiObject acceptButton = device.findObject(new UiSelector().resourceId(Res.CHROME_TERMS_ACCEPT_BUTTON_RES));
        if (device.hasObject(By.res(Res.CHROME_WELCOME_TITLE_RES)) && acceptButton.exists()) {
            acceptButton.clickAndWaitForNewWindow();
        }
        // Dismiss the "Sign in to Chrome" screen if it's there.
        if (device.hasObject(By.res(Res.CHROME_SIGN_IN_TITLE_RES))) {
            device.findObject(new UiSelector().resourceId(Res.CHROME_NEGATIVE_BUTTON_RES)).clickAndWaitForNewWindow();
        }
        // Dismiss the "Browse more for less" screen if it's there.
        UiObject noThanksButton = device.findObject(new UiSelector().resourceId(Res.CHROME_NO_THANKS_BUTTON));
        if (noThanksButton.exists()) {
            noThanksButton.clickAndWaitForNewWindow();
        }
        // Click the search box if it's there.
        UiObject searchBox = device.findObject(new UiSelector().resourceId(Res.CHROME_SEARCH_BOX_RES));
        if (searchBox.exists()) {
            searchBox.clickAndWaitForNewWindow();
        }
        UiObject textField = device.findObject(new UiSelector().resourceId(Res.CHROME_URL_BAR_RES));
        textField.click();
        textField.clearTextField();
        // Include a timestamp in the URL so it's not already bookmarked. (On Chrome, the UI
        // changes in that case.)
        textField.setText("https://httpbin.org/?d=" + new Date().getTime());
        device.pressEnter();
        device.pressMenu();
        device.findObject(new UiSelector().description("Bookmark this page")).click();
        device.pressMenu();
        // After bookmarking, the button description changes.
        assertTrue("Bookmark was not set", device.findObject(new UiSelector().description("Edit bookmark")).exists());
        // Verify the new bookmark is in the list.
        device.findObject(new UiSelector().text("Bookmarks")).clickAndWaitForNewWindow();
        assertTrue("Cannot find bookmark", device.findObject(new UiSelector().text("Bookmarks")).exists() && device.findObject(new UiSelector().textContains("httpbin").resourceId(Res.CHROME_BOOKMARKS_LABEL_RES)).exists());
        device.findObject(new UiSelector().resourceId(Res.CHROME_CLOSE_MENU_BUTTON_RES)).clickAndWaitForNewWindow();
        // Delete the bookmark.
        device.pressMenu();
        device.findObject(new UiSelector().description("Edit bookmark")).clickAndWaitForNewWindow();
        device.findObject(new UiSelector().description("Delete bookmarks")).click();
    } else {
        AppLauncher.launch(instrumentation, "Browser");
        UiObject textField = device.findObject(new UiSelector().resourceId(Res.BROWSER_URL_TEXT_FIELD_RES));
        textField.click();
        textField.clearTextField();
        textField.setText("espn.com");
        device.pressEnter();
        device.pressMenu();
        device.findObject(new UiSelector().text("Save to bookmarks")).click();
        device.findObject(new UiSelector().text("OK")).click();
        device.pressMenu();
        device.findObject(new UiSelector().text("Bookmarks")).click();
        assertTrue("Cannot find ESPN bookmark", device.findObject(new UiSelector().text("Bookmarks")).exists() && device.findObject(new UiSelector().textContains("ESPN").resourceId(Res.BROWSER_BOOKMARKS_LABEL_RES)).exists());
    }
}
#end_block

#method_before
@Override
protected void parseData() throws IOException {
    byte[] ellipticCurvesListBytes = IoUtils.readTlsVariableLengthByteVector(new DataInputStream(new ByteArrayInputStream(data)), 0xffff);
    ByteArrayInputStream ellipticCurvesListIn = new ByteArrayInputStream(ellipticCurvesListBytes);
    DataInputStream in = new DataInputStream(ellipticCurvesListIn);
    supported = new ArrayList<EllipticCurve>(ellipticCurvesListIn.available() / 2);
    while (ellipticCurvesListIn.available() >= 2) {
        int curve_id = in.readUnsignedShort();
        supported.add(EllipticCurve.valueOf(curve_id));
    }
}
#method_after
@Override
protected void parseData() throws IOException {
    byte[] ellipticCurvesListBytes = IoUtils.readTlsVariableLengthByteVector(new DataInputStream(new ByteArrayInputStream(data)), 0xffff);
    ByteArrayInputStream ellipticCurvesListIn = new ByteArrayInputStream(ellipticCurvesListBytes);
    DataInputStream in = new DataInputStream(ellipticCurvesListIn);
    wellFormed = (ellipticCurvesListIn.available() % 2) == 0;
    supported = new ArrayList<EllipticCurve>(ellipticCurvesListIn.available() / 2);
    while (ellipticCurvesListIn.available() >= 2) {
        int curve_id = in.readUnsignedShort();
        supported.add(EllipticCurve.fromIdentifier(curve_id));
    }
}
#end_block

#method_before
@Override
public String toString() {
    return "HelloExtension{type: elliptic_curves, supported: " + supported + "}";
}
#method_after
@Override
public String toString() {
    StringBuilder sb = new StringBuilder("HelloExtension{type: elliptic_curves, wellFormed: ");
    sb.append(wellFormed);
    sb.append(", supported: ");
    sb.append(supported);
    sb.append('}');
    return sb.toString();
}
#end_block

#method_before
public void test_SSLSocket_ClientHello_supportedCurves() throws Exception {
    ForEachRunner.runNamed(new ForEachRunner.Callback<SSLSocketFactory>() {

        @Override
        public void run(SSLSocketFactory sslSocketFactory) throws Exception {
            ClientHello clientHello = captureTlsHandshakeClientHello(sslSocketFactory);
            EllipticCurvesHelloExtension ecExtension = (EllipticCurvesHelloExtension) clientHello.findExtensionByType(HelloExtension.TYPE_ELLIPTIC_CURVES);
            final String[] supportedCurves;
            if (ecExtension == null) {
                supportedCurves = new String[0];
            } else {
                supportedCurves = new String[ecExtension.supported.size()];
            }
            for (int i = 0; i < ecExtension.supported.size(); i++) {
                EllipticCurve curve = ecExtension.supported.get(i);
                supportedCurves[i] = curve.toString();
            }
            StandardNames.assertDefaultEllipticCurves(supportedCurves);
        }
    }, getSSLSocketFactoriesToTest());
}
#method_after
public void test_SSLSocket_ClientHello_supportedCurves() throws Exception {
    ForEachRunner.runNamed(new ForEachRunner.Callback<SSLSocketFactory>() {

        @Override
        public void run(SSLSocketFactory sslSocketFactory) throws Exception {
            ClientHello clientHello = captureTlsHandshakeClientHello(sslSocketFactory);
            EllipticCurvesHelloExtension ecExtension = (EllipticCurvesHelloExtension) clientHello.findExtensionByType(HelloExtension.TYPE_ELLIPTIC_CURVES);
            final String[] supportedCurves;
            if (ecExtension == null) {
                supportedCurves = new String[0];
            } else {
                assertTrue(ecExtension.wellFormed);
                supportedCurves = new String[ecExtension.supported.size()];
                for (int i = 0; i < ecExtension.supported.size(); i++) {
                    EllipticCurve curve = ecExtension.supported.get(i);
                    supportedCurves[i] = curve.toString();
                }
            }
            StandardNames.assertDefaultEllipticCurves(supportedCurves);
        }
    }, getSSLSocketFactoriesToTest());
}
#end_block

#method_before
@org.junit.Test
public void test() {
    Exception e = new Exception();
    PrivilegedActionException pae = new PrivilegedActionException(e);
    assertSame(e, pae.getException());
    assertSame(e, pae.getCause());
}
#method_after
@Test
public void test() {
    Exception e = new Exception();
    PrivilegedActionException pae = new PrivilegedActionException(e);
    assertSame(e, pae.getException());
    assertSame(e, pae.getCause());
}
#end_block

#method_before
public void test_setTrafficClass() throws Exception {
    Socket s = new Socket();
    // Linux does not set ECN bits for STREAM sockets.
    for (int i = 0; i <= 255; ++i) {
        s.setTrafficClass(i);
        assertEquals(i & ~INET_ECN_MASK, s.getTrafficClass());
    }
}
#method_after
public void test_setTrafficClass() throws Exception {
    Socket s = new Socket();
    for (int i = 0; i <= 255; ++i) {
        s.setTrafficClass(i);
        // b/30909505
        // Linux does not set ECN bits for STREAM sockets, so these bits should be zero.
        assertEquals(i & ~INET_ECN_MASK, s.getTrafficClass());
    }
}
#end_block

#method_before
public void notifyANQPDone(Long bssid, boolean success) {
    Map<Constants.ANQPElementType, ANQPElement> elements = null;
    if (success) {
        String bssData = mSupplicantHook.scanResult(Utils.macToString(bssid));
        try {
            elements = parseWPSData(bssData);
            Log.d(Utils.hs2LogTag(getClass()), String.format("Successful ANQP response for %012x: %s", bssid, elements));
        } catch (IOException ioe) {
            Log.e(Utils.hs2LogTag(getClass()), "Failed to parse ANQP: " + ioe.toString() + ": " + bssData);
        } catch (RuntimeException rte) {
            Log.e(Utils.hs2LogTag(getClass()), "Failed to parse ANQP: " + rte.toString() + ": " + bssData, rte);
        }
    }
    mCallbacks.onANQPResponse(bssid, elements);
}
#method_after
public void notifyANQPDone(long bssid, boolean success) {
    Map<Constants.ANQPElementType, ANQPElement> elements = null;
    if (success) {
        String bssData = mSupplicantHook.scanResult(Utils.macToString(bssid));
        try {
            elements = parseWPSData(bssData);
            Log.d(Utils.hs2LogTag(getClass()), String.format("Successful ANQP response for %012x: %s", bssid, elements));
        } catch (IOException ioe) {
            Log.e(Utils.hs2LogTag(getClass()), "Failed to parse ANQP: " + ioe.toString() + ": " + bssData);
        } catch (RuntimeException rte) {
            Log.e(Utils.hs2LogTag(getClass()), "Failed to parse ANQP: " + rte.toString() + ": " + bssData, rte);
        }
    }
    mCallbacks.onANQPResponse(bssid, elements);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    initMocks(this);
    mHandler = new PasspointEventHandler(mSupplicantHook, mCallbacks);
}
#method_after
@Before
public void setUp() throws Exception {
    initMocks(this);
    mHandler = new PasspointEventHandler(mWifiNative, mCallbacks);
}
#end_block

#method_before
@Test
public void requestR1AnqpElement() {
    List<Constants.ANQPElementType> elementToRequest = Arrays.asList(Constants.ANQPElementType.ANQPRoamingConsortium);
    String expectedCommand = "ANQP_GET " + BSSID_STR + " " + Constants.getANQPElementID(Constants.ANQPElementType.ANQPRoamingConsortium);
    // wpa_supplicant succeeded the request.
    when(mSupplicantHook.doCustomSupplicantCommand(expectedCommand)).thenReturn("OK");
    assertTrue(mHandler.requestANQP(BSSID, elementToRequest));
    // wpa_supplicant failed the request.
    when(mSupplicantHook.doCustomSupplicantCommand(expectedCommand)).thenReturn("FAILED");
    assertFalse(mHandler.requestANQP(BSSID, elementToRequest));
}
#method_after
@Test
public void requestR1AnqpElement() {
    List<Constants.ANQPElementType> elementToRequest = Arrays.asList(Constants.ANQPElementType.ANQPRoamingConsortium);
    String expectedCommand = "ANQP_GET " + BSSID_STR + " " + Constants.getANQPElementID(Constants.ANQPElementType.ANQPRoamingConsortium);
    // wpa_supplicant succeeded the request.
    when(mWifiNative.doCustomSupplicantCommand(expectedCommand)).thenReturn("OK");
    assertTrue(mHandler.requestANQP(BSSID, elementToRequest));
    // wpa_supplicant failed the request.
    when(mWifiNative.doCustomSupplicantCommand(expectedCommand)).thenReturn("FAILED");
    assertFalse(mHandler.requestANQP(BSSID, elementToRequest));
}
#end_block

#method_before
@Test
public void requestR2AnqpElement() {
    List<Constants.ANQPElementType> elementToRequest = Arrays.asList(Constants.ANQPElementType.HSFriendlyName);
    String expectedCommand = "HS20_ANQP_GET " + BSSID_STR + " " + Constants.getHS20ElementID(Constants.ANQPElementType.HSFriendlyName);
    // wpa_supplicant succeeded the request.
    when(mSupplicantHook.doCustomSupplicantCommand(expectedCommand)).thenReturn("OK");
    assertTrue(mHandler.requestANQP(BSSID, elementToRequest));
    // wpa_supplicant failed the request.
    when(mSupplicantHook.doCustomSupplicantCommand(expectedCommand)).thenReturn("FAILED");
    assertFalse(mHandler.requestANQP(BSSID, elementToRequest));
}
#method_after
@Test
public void requestR2AnqpElement() {
    List<Constants.ANQPElementType> elementToRequest = Arrays.asList(Constants.ANQPElementType.HSFriendlyName);
    String expectedCommand = "HS20_ANQP_GET " + BSSID_STR + " " + Constants.getHS20ElementID(Constants.ANQPElementType.HSFriendlyName);
    // wpa_supplicant succeeded the request.
    when(mWifiNative.doCustomSupplicantCommand(expectedCommand)).thenReturn("OK");
    assertTrue(mHandler.requestANQP(BSSID, elementToRequest));
    // wpa_supplicant failed the request.
    when(mWifiNative.doCustomSupplicantCommand(expectedCommand)).thenReturn("FAILED");
    assertFalse(mHandler.requestANQP(BSSID, elementToRequest));
}
#end_block

#method_before
@Test
public void requestMixAnqpElements() {
    List<Constants.ANQPElementType> elementToRequest = Arrays.asList(Constants.ANQPElementType.ANQPRoamingConsortium, Constants.ANQPElementType.HSFriendlyName);
    // ANQP_GET command is used when both R1 and R2 elements are present.
    // |hs20:| prefix for R2 elements are needed when using ANQP_GET command
    String expectedCommand = "ANQP_GET " + BSSID_STR + " " + Constants.getANQPElementID(Constants.ANQPElementType.ANQPRoamingConsortium) + ",hs20:" + Constants.getHS20ElementID(Constants.ANQPElementType.HSFriendlyName);
    // wpa_supplicant succeeded the request.
    when(mSupplicantHook.doCustomSupplicantCommand(expectedCommand)).thenReturn("OK");
    assertTrue(mHandler.requestANQP(BSSID, elementToRequest));
    // wpa_supplicant failed the request.
    when(mSupplicantHook.doCustomSupplicantCommand(expectedCommand)).thenReturn("FAILED");
    assertFalse(mHandler.requestANQP(BSSID, elementToRequest));
}
#method_after
@Test
public void requestMixAnqpElements() {
    List<Constants.ANQPElementType> elementToRequest = Arrays.asList(Constants.ANQPElementType.ANQPRoamingConsortium, Constants.ANQPElementType.HSFriendlyName);
    // ANQP_GET command is used when both R1 and R2 elements are present.
    // |hs20:| prefix for R2 elements are needed when using ANQP_GET command
    String expectedCommand = "ANQP_GET " + BSSID_STR + " " + Constants.getANQPElementID(Constants.ANQPElementType.ANQPRoamingConsortium) + ",hs20:" + Constants.getHS20ElementID(Constants.ANQPElementType.HSFriendlyName);
    // wpa_supplicant succeeded the request.
    when(mWifiNative.doCustomSupplicantCommand(expectedCommand)).thenReturn("OK");
    assertTrue(mHandler.requestANQP(BSSID, elementToRequest));
    // wpa_supplicant failed the request.
    when(mWifiNative.doCustomSupplicantCommand(expectedCommand)).thenReturn("FAILED");
    assertFalse(mHandler.requestANQP(BSSID, elementToRequest));
}
#end_block

#method_before
@Test
public void requestIconFile() {
    String expectedCommand = "REQ_HS20_ICON " + BSSID_STR + " " + ICON_FILENAME;
    // wpa_supplicant succeeded the request.
    when(mSupplicantHook.doCustomSupplicantCommand(expectedCommand)).thenReturn("OK");
    assertTrue(mHandler.requestIcon(BSSID, ICON_FILENAME));
    // wpa_supplicant failed the request.
    when(mSupplicantHook.doCustomSupplicantCommand(expectedCommand)).thenReturn("FAILED");
    assertFalse(mHandler.requestIcon(BSSID, ICON_FILENAME));
}
#method_after
@Test
public void requestIconFile() {
    String expectedCommand = "REQ_HS20_ICON " + BSSID_STR + " " + ICON_FILENAME;
    // wpa_supplicant succeeded the request.
    when(mWifiNative.doCustomSupplicantCommand(expectedCommand)).thenReturn("OK");
    assertTrue(mHandler.requestIcon(BSSID, ICON_FILENAME));
    // wpa_supplicant failed the request.
    when(mWifiNative.doCustomSupplicantCommand(expectedCommand)).thenReturn("FAILED");
    assertFalse(mHandler.requestIcon(BSSID, ICON_FILENAME));
}
#end_block

#method_before
@Test
public void anqpRequestCompletedWithError() {
    mHandler.notifyANQPDone(BSSID, false);
    verify(mSupplicantHook, never()).scanResult(anyString());
    verify(mCallbacks).onANQPResponse(BSSID, null);
}
#method_after
@Test
public void anqpRequestCompletedWithError() {
    mHandler.notifyANQPDone(BSSID, false);
    verify(mWifiNative, never()).scanResult(anyString());
    verify(mCallbacks).onANQPResponse(BSSID, null);
}
#end_block

#method_before
private boolean connectToUserSelectNetwork(int netId, int uid) {
    if (!setUserSelectNetwork(netId, uid)) {
        return false;
    }
    if (!mWifiConfigManager.checkAndUpdateLastConnectUid(netId, uid)) {
        loge("connectToUserSelectNetwork uid " + uid + " did not have the permissions to connect=" + netId);
        return false;
    }
    startConnectToNetwork(netId, SUPPLICANT_BSSID_ANY);
    return true;
}
#method_after
private boolean connectToUserSelectNetwork(int netId, int uid) {
    if (!mWifiConfigManager.enableNetwork(netId, true, uid)) {
        loge("connectToUserSelectNetwork uid " + uid + " did not have the permissions to enable=" + netId);
        return false;
    }
    if (!mWifiConfigManager.checkAndUpdateLastConnectUid(netId, uid)) {
        loge("connectToUserSelectNetwork uid " + uid + " did not have the permissions to connect=" + netId);
        // App does not have the permission to force a connection. But, we should still
        // reconsider this newly enabled network for network selection.
        mWifiConnectivityManager.forceConnectivityScan();
    } else {
        // Trigger an immediate connection to the specified network. We're also noting the user
        // connect choice here, so that it will be considered in the next network selection.
        mWifiConnectivityManager.setUserConnectChoice(netId);
        startConnectToNetwork(netId, SUPPLICANT_BSSID_ANY);
    }
    return true;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config;
    int netId;
    boolean ok;
    boolean didDisconnect;
    String bssid;
    String ssid;
    NetworkUpdateResult result;
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_ASSOC_FAILURE);
            didBlackListBSSID = false;
            bssid = (String) message.obj;
            if (bssid == null || TextUtils.isEmpty(bssid)) {
                // If BSSID is null, use the target roam BSSID
                bssid = mTargetRoamBSSID;
            }
            if (bssid != null) {
                // If we have a BSSID, tell configStore to black list it
                if (mWifiConnectivityManager != null) {
                    didBlackListBSSID = mWifiConnectivityManager.trackBssid(bssid, false);
                }
            }
            mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_ASSOCIATION_REJECTION);
            mSupplicantStateTracker.sendMessage(WifiMonitor.ASSOCIATION_REJECTION_EVENT);
            // If rejection occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_ASSOCIATION_REJECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), bssid, WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            break;
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTH_FAILURE);
            mSupplicantStateTracker.sendMessage(WifiMonitor.AUTHENTICATION_FAILURE_EVENT);
            if (mTargetNetworkId != WifiConfiguration.INVALID_NETWORK_ID) {
                mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            }
            // If failure occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_AUTHENTICATION_FAILURE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.e(TAG, "Supplicant SSID temporary disabled:" + mWifiConfigManager.getConfiguredNetwork(netId));
            mWifiConfigManager.updateNetworkSelectionStatus(netId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_SSID_TEMP_DISABLED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_REENABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.d(TAG, "Supplicant SSID reenable:" + mWifiConfigManager.getConfiguredNetwork(netId));
            // Algorithm of disable/enable
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            SupplicantState state = handleSupplicantStateChange(message);
            // We detect the interface going down and recover from it
            if (!SupplicantState.isDriverActive(state)) {
                if (mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                    handleNetworkDisconnect();
                }
                log("Detected an interface down, restart driver");
                // Rely on the fact that this will force us into killing supplicant and then
                // restart supplicant from a clean state.
                transitionTo(mSupplicantStoppingState);
                sendMessage(CMD_START_SUPPLICANT);
                break;
            }
            // disconnected, we need to handle a disconnection
            if (!isLinkDebouncing() && state == SupplicantState.DISCONNECTED && mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                if (mVerboseLoggingEnabled) {
                    log("Missed CTRL-EVENT-DISCONNECTED, disconnect");
                }
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            // interest (e.g. routers); harmless if none are configured.
            if (state == SupplicantState.COMPLETED) {
                mIpManager.confirmConfiguration();
            }
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
            } else {
                mWifiNative.reconnect();
                mTemporarilyDisconnectWifi = false;
            }
            break;
        case CMD_ADD_OR_UPDATE_NETWORK:
            config = (WifiConfiguration) message.obj;
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, result.getNetworkId());
            break;
        case CMD_REMOVE_NETWORK:
            netId = message.arg1;
            ok = mWifiConfigManager.removeNetwork(message.arg1, message.sendingUid);
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            } else if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_ENABLE_NETWORK:
            boolean disableOthers = message.arg2 == 1;
            netId = message.arg1;
            if (disableOthers) {
                // If the app has all the necessary permissions, this will trigger a connect
                // attempt.
                ok = connectToUserSelectNetwork(netId, message.sendingUid);
            } else {
                ok = mWifiConfigManager.enableNetwork(netId, false, message.sendingUid);
            }
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case WifiManager.DISABLE_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.disableNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.DISABLE_NETWORK_SUCCEEDED);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to remove network");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            config = mWifiConfigManager.disableEphemeralNetwork((String) message.obj);
            if (config != null) {
                if (config.networkId == mTargetNetworkId || config.networkId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            }
            break;
        case CMD_SAVE_CONFIG:
            ok = mWifiConfigManager.saveToStore(true);
            replyToMessage(message, CMD_SAVE_CONFIG, ok ? SUCCESS : FAILURE);
            // Inform the backup manager about a data change
            mBackupManagerProxy.notifyDataChanged();
            break;
        case CMD_GET_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getSavedNetworks());
            break;
        case WifiMonitor.SUP_REQUEST_IDENTITY:
            int supplicantNetworkId = message.arg2;
            netId = lookupFrameworkNetworkId(supplicantNetworkId);
            boolean identitySent = false;
            int eapMethod = WifiEnterpriseConfig.Eap.NONE;
            if (targetWificonfiguration != null && targetWificonfiguration.enterpriseConfig != null) {
                eapMethod = targetWificonfiguration.enterpriseConfig.getEapMethod();
            }
            // For SIM & AKA/AKA' EAP method Only, get identity from ICC
            if (targetWificonfiguration != null && targetWificonfiguration.networkId == netId && (targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_EAP) || targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.IEEE8021X)) && TelephonyUtil.isSimEapMethod(eapMethod)) {
                String identity = TelephonyUtil.getSimIdentity(getTelephonyManager(), eapMethod);
                if (identity != null) {
                    mWifiNative.simIdentityResponse(supplicantNetworkId, identity);
                    identitySent = true;
                }
            }
            if (!identitySent) {
                // Supplicant lacks credentials to connect to that network, hence black list
                ssid = (String) message.obj;
                if (targetWificonfiguration != null && ssid != null && targetWificonfiguration.SSID != null && targetWificonfiguration.SSID.equals("\"" + ssid + "\"")) {
                    mWifiConfigManager.updateNetworkSelectionStatus(targetWificonfiguration.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_NO_CREDENTIALS);
                }
                mWifiNative.disconnect();
            }
            break;
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
            logd("Received SUP_REQUEST_SIM_AUTH");
            SimAuthRequestData requestData = (SimAuthRequestData) message.obj;
            if (requestData != null) {
                if (requestData.protocol == WifiEnterpriseConfig.Eap.SIM) {
                    handleGsmAuthRequest(requestData);
                } else if (requestData.protocol == WifiEnterpriseConfig.Eap.AKA || requestData.protocol == WifiEnterpriseConfig.Eap.AKA_PRIME) {
                    handle3GAuthRequest(requestData);
                }
            } else {
                loge("Invalid sim auth request");
            }
            break;
        case CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getConfiguredNetworksWithPasswords());
            break;
        case CMD_GET_MATCHING_CONFIG:
            // TODO(b/31065385)
            replyToMessage(message, message.what, null);
            break;
        case CMD_RECONNECT:
            if (mWifiConnectivityManager != null) {
                mWifiConnectivityManager.forceConnectivityScan();
            }
            break;
        case CMD_REASSOCIATE:
            lastConnectAttemptTimestamp = mClock.getWallClockMillis();
            mWifiNative.reassociate();
            break;
        case CMD_RELOAD_TLS_AND_RECONNECT:
            if (mWifiConfigManager.needsUnlockedKeyStore()) {
                logd("Reconnecting to give a chance to un-connected TLS networks");
                mWifiNative.disconnect();
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                mWifiNative.reconnect();
            }
            break;
        case CMD_START_ROAM:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            return HANDLED;
        case CMD_START_CONNECT:
            /* connect command coming from auto-join */
            netId = message.arg1;
            bssid = (String) message.obj;
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            logd("CMD_START_CONNECT sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " roam=" + Boolean.toString(mAutoRoaming));
            if (config == null) {
                loge("CMD_START_CONNECT and no config, bail out...");
                break;
            }
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            mWifiMetrics.startConnectionEvent(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_UNRELATED);
            boolean shouldDisconnect = (getCurrentState() != mDisconnectedState);
            if (mWifiSupplicantControl.connectToNetwork(config, shouldDisconnect)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = false;
                if (isRoaming() || isLinkDebouncing()) {
                    transitionTo(mRoamingState);
                } else if (shouldDisconnect) {
                    transitionTo(mDisconnectingState);
                } else {
                    transitionTo(mDisconnectedState);
                }
            } else {
                loge("CMD_START_CONNECT Failed to start connection to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            mWifiConfigManager.removeNetworksForApp((ApplicationInfo) message.obj);
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            mWifiConfigManager.removeNetworksForUser(message.arg1);
            break;
        case WifiManager.CONNECT_NETWORK:
            /**
             * The connect message can contain a network id passed as arg1 on message or
             * or a config passed as obj on message.
             * For a new network, a config is passed to create and connect.
             * For an existing network, a network id is passed
             */
            netId = message.arg1;
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            // New network addition.
            if (config != null) {
                result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
                if (!result.isSuccess()) {
                    loge("CONNECT_NETWORK adding/updating config=" + config + " failed");
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                    break;
                }
                netId = result.getNetworkId();
            }
            if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                break;
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.CONNECT_NETWORK_SUCCEEDED);
            break;
        case WifiManager.SAVE_NETWORK:
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            if (config == null) {
                loge("SAVE_NETWORK with null configuration" + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName());
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                loge("SAVE_NETWORK adding/updating config=" + config + " failed");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            netId = result.getNetworkId();
            if (mWifiInfo.getNetworkId() == netId) {
                if (result.hasIpChanged()) {
                    // The currently connection configuration was changed
                    // We switched from DHCP to static or from static to DHCP, or the
                    // static IP address has changed.
                    log("Reconfiguring IP on connection");
                    // TODO: clear addresses and disable IPv6
                    // to simplify obtainingIpState.
                    transitionTo(mObtainingIpState);
                }
                if (result.hasProxyChanged()) {
                    log("Reconfiguring proxy on connection");
                    mIpManager.setHttpProxy(getCurrentWifiConfiguration().getHttpProxy());
                }
                if (!setUserSelectNetwork(netId, message.sendingUid)) {
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                    break;
                }
            } else {
                if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                    break;
                }
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.SAVE_NETWORK_SUCCEEDED);
            break;
        case WifiManager.FORGET_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.removeNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.FORGET_NETWORK_SUCCEEDED);
                broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_FORGOT, (WifiConfiguration) message.obj);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to forget network");
                replyToMessage(message, WifiManager.FORGET_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case WifiManager.START_WPS:
            WpsInfo wpsInfo = (WpsInfo) message.obj;
            WpsResult wpsResult;
            switch(wpsInfo.setup) {
                case WpsInfo.PBC:
                    wpsResult = mWifiSupplicantControl.startWpsPbc(wpsInfo);
                    break;
                case WpsInfo.KEYPAD:
                    wpsResult = mWifiSupplicantControl.startWpsWithPinFromAccessPoint(wpsInfo);
                    break;
                case WpsInfo.DISPLAY:
                    wpsResult = mWifiSupplicantControl.startWpsWithPinFromDevice(wpsInfo);
                    break;
                default:
                    wpsResult = new WpsResult(Status.FAILURE);
                    loge("Invalid setup for WPS");
                    break;
            }
            if (wpsResult.status == Status.SUCCESS) {
                replyToMessage(message, WifiManager.START_WPS_SUCCEEDED, wpsResult);
                transitionTo(mWpsRunningState);
            } else {
                loge("Failed to start WPS with config " + wpsInfo.toString());
                replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // This is where we can confirm the connection BSSID. Use it to find the
            // right ScanDetail to populate metrics.
            String someBssid = (String) message.obj;
            if (someBssid != null) {
                // Get the ScanDetail associated with this BSSID.
                ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(mTargetNetworkId);
                if (scanDetailCache != null) {
                    mWifiMetrics.setConnectionScanDetail(scanDetailCache.getScanDetail(someBssid));
                }
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Network connection established");
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mLastBssid = (String) message.obj;
            mWifiInfo.setBSSID(mLastBssid);
            mWifiInfo.setNetworkId(mLastNetworkId);
            if (mWifiConnectivityManager != null) {
                mWifiConnectivityManager.trackBssid(mLastBssid, true);
            }
            sendNetworkStateChangeBroadcast(mLastBssid);
            transitionTo(mObtainingIpState);
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // at the chip etc...
            if (mVerboseLoggingEnabled)
                log("ConnectModeState: Network connection lost ");
            handleNetworkDisconnect();
            transitionTo(mDisconnectedState);
            break;
        case CMD_ADD_PASSPOINT_MO:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        case CMD_MODIFY_PASSPOINT_MO:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        case CMD_QUERY_OSU_ICON:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        case CMD_MATCH_PROVIDER_NETWORK:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config;
    int netId;
    boolean ok;
    boolean didDisconnect;
    String bssid;
    String ssid;
    NetworkUpdateResult result;
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_ASSOC_FAILURE);
            didBlackListBSSID = false;
            bssid = (String) message.obj;
            if (bssid == null || TextUtils.isEmpty(bssid)) {
                // If BSSID is null, use the target roam BSSID
                bssid = mTargetRoamBSSID;
            }
            if (bssid != null) {
                // If we have a BSSID, tell configStore to black list it
                if (mWifiConnectivityManager != null) {
                    didBlackListBSSID = mWifiConnectivityManager.trackBssid(bssid, false);
                }
            }
            mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_ASSOCIATION_REJECTION);
            mSupplicantStateTracker.sendMessage(WifiMonitor.ASSOCIATION_REJECTION_EVENT);
            // If rejection occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_ASSOCIATION_REJECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), bssid, WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            break;
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTH_FAILURE);
            mSupplicantStateTracker.sendMessage(WifiMonitor.AUTHENTICATION_FAILURE_EVENT);
            if (mTargetNetworkId != WifiConfiguration.INVALID_NETWORK_ID) {
                mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            }
            // If failure occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_AUTHENTICATION_FAILURE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.e(TAG, "Supplicant SSID temporary disabled:" + mWifiConfigManager.getConfiguredNetwork(netId));
            mWifiConfigManager.updateNetworkSelectionStatus(netId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_SSID_TEMP_DISABLED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_REENABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.d(TAG, "Supplicant SSID reenable:" + mWifiConfigManager.getConfiguredNetwork(netId));
            // Algorithm of disable/enable
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            SupplicantState state = handleSupplicantStateChange(message);
            // We detect the interface going down and recover from it
            if (!SupplicantState.isDriverActive(state)) {
                if (mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                    handleNetworkDisconnect();
                }
                log("Detected an interface down, restart driver");
                // Rely on the fact that this will force us into killing supplicant and then
                // restart supplicant from a clean state.
                transitionTo(mSupplicantStoppingState);
                sendMessage(CMD_START_SUPPLICANT);
                break;
            }
            // disconnected, we need to handle a disconnection
            if (!isLinkDebouncing() && state == SupplicantState.DISCONNECTED && mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                if (mVerboseLoggingEnabled) {
                    log("Missed CTRL-EVENT-DISCONNECTED, disconnect");
                }
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            // interest (e.g. routers); harmless if none are configured.
            if (state == SupplicantState.COMPLETED) {
                mIpManager.confirmConfiguration();
            }
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
            } else {
                mWifiNative.reconnect();
                mTemporarilyDisconnectWifi = false;
            }
            break;
        case CMD_ADD_OR_UPDATE_NETWORK:
            config = (WifiConfiguration) message.obj;
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, result.getNetworkId());
            break;
        case CMD_REMOVE_NETWORK:
            netId = message.arg1;
            ok = mWifiConfigManager.removeNetwork(message.arg1, message.sendingUid);
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            } else if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_ENABLE_NETWORK:
            boolean disableOthers = message.arg2 == 1;
            netId = message.arg1;
            if (disableOthers) {
                // If the app has all the necessary permissions, this will trigger a connect
                // attempt.
                ok = connectToUserSelectNetwork(netId, message.sendingUid);
            } else {
                ok = mWifiConfigManager.enableNetwork(netId, false, message.sendingUid);
            }
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case WifiManager.DISABLE_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.disableNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.DISABLE_NETWORK_SUCCEEDED);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to remove network");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            config = mWifiConfigManager.disableEphemeralNetwork((String) message.obj);
            if (config != null) {
                if (config.networkId == mTargetNetworkId || config.networkId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            }
            break;
        case CMD_SAVE_CONFIG:
            ok = mWifiConfigManager.saveToStore(true);
            replyToMessage(message, CMD_SAVE_CONFIG, ok ? SUCCESS : FAILURE);
            // Inform the backup manager about a data change
            mBackupManagerProxy.notifyDataChanged();
            break;
        case CMD_GET_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getSavedNetworks());
            break;
        case WifiMonitor.SUP_REQUEST_IDENTITY:
            int supplicantNetworkId = message.arg2;
            netId = lookupFrameworkNetworkId(supplicantNetworkId);
            boolean identitySent = false;
            int eapMethod = WifiEnterpriseConfig.Eap.NONE;
            if (targetWificonfiguration != null && targetWificonfiguration.enterpriseConfig != null) {
                eapMethod = targetWificonfiguration.enterpriseConfig.getEapMethod();
            }
            // For SIM & AKA/AKA' EAP method Only, get identity from ICC
            if (targetWificonfiguration != null && targetWificonfiguration.networkId == netId && (targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_EAP) || targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.IEEE8021X)) && TelephonyUtil.isSimEapMethod(eapMethod)) {
                String identity = TelephonyUtil.getSimIdentity(getTelephonyManager(), eapMethod);
                if (identity != null) {
                    mWifiNative.simIdentityResponse(supplicantNetworkId, identity);
                    identitySent = true;
                }
            }
            if (!identitySent) {
                // Supplicant lacks credentials to connect to that network, hence black list
                ssid = (String) message.obj;
                if (targetWificonfiguration != null && ssid != null && targetWificonfiguration.SSID != null && targetWificonfiguration.SSID.equals("\"" + ssid + "\"")) {
                    mWifiConfigManager.updateNetworkSelectionStatus(targetWificonfiguration.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_NO_CREDENTIALS);
                }
                mWifiNative.disconnect();
            }
            break;
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
            logd("Received SUP_REQUEST_SIM_AUTH");
            SimAuthRequestData requestData = (SimAuthRequestData) message.obj;
            if (requestData != null) {
                if (requestData.protocol == WifiEnterpriseConfig.Eap.SIM) {
                    handleGsmAuthRequest(requestData);
                } else if (requestData.protocol == WifiEnterpriseConfig.Eap.AKA || requestData.protocol == WifiEnterpriseConfig.Eap.AKA_PRIME) {
                    handle3GAuthRequest(requestData);
                }
            } else {
                loge("Invalid sim auth request");
            }
            break;
        case CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getConfiguredNetworksWithPasswords());
            break;
        case CMD_GET_MATCHING_CONFIG:
            // TODO(b/31065385)
            replyToMessage(message, message.what, null);
            break;
        case CMD_RECONNECT:
            if (mWifiConnectivityManager != null) {
                mWifiConnectivityManager.forceConnectivityScan();
            }
            break;
        case CMD_REASSOCIATE:
            lastConnectAttemptTimestamp = mClock.getWallClockMillis();
            mWifiNative.reassociate();
            break;
        case CMD_RELOAD_TLS_AND_RECONNECT:
            if (mWifiConfigManager.needsUnlockedKeyStore()) {
                logd("Reconnecting to give a chance to un-connected TLS networks");
                mWifiNative.disconnect();
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                mWifiNative.reconnect();
            }
            break;
        case CMD_START_ROAM:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            return HANDLED;
        case CMD_START_CONNECT:
            /* connect command coming from auto-join */
            netId = message.arg1;
            bssid = (String) message.obj;
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            logd("CMD_START_CONNECT sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " roam=" + Boolean.toString(mAutoRoaming));
            if (config == null) {
                loge("CMD_START_CONNECT and no config, bail out...");
                break;
            }
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            mWifiMetrics.startConnectionEvent(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_UNRELATED);
            boolean shouldDisconnect = (getCurrentState() != mDisconnectedState);
            if (mWifiSupplicantControl.connectToNetwork(config, shouldDisconnect)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = false;
                if (isRoaming() || isLinkDebouncing()) {
                    transitionTo(mRoamingState);
                } else if (shouldDisconnect) {
                    transitionTo(mDisconnectingState);
                } else {
                    transitionTo(mDisconnectedState);
                }
            } else {
                loge("CMD_START_CONNECT Failed to start connection to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            mWifiConfigManager.removeNetworksForApp((ApplicationInfo) message.obj);
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            mWifiConfigManager.removeNetworksForUser(message.arg1);
            break;
        case WifiManager.CONNECT_NETWORK:
            /**
             * The connect message can contain a network id passed as arg1 on message or
             * or a config passed as obj on message.
             * For a new network, a config is passed to create and connect.
             * For an existing network, a network id is passed
             */
            netId = message.arg1;
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            // New network addition.
            if (config != null) {
                result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
                if (!result.isSuccess()) {
                    loge("CONNECT_NETWORK adding/updating config=" + config + " failed");
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                    break;
                }
                netId = result.getNetworkId();
            }
            if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                break;
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.CONNECT_NETWORK_SUCCEEDED);
            break;
        case WifiManager.SAVE_NETWORK:
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            if (config == null) {
                loge("SAVE_NETWORK with null configuration" + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName());
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                loge("SAVE_NETWORK adding/updating config=" + config + " failed");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            netId = result.getNetworkId();
            if (mWifiInfo.getNetworkId() == netId) {
                if (result.hasIpChanged()) {
                    // The currently connection configuration was changed
                    // We switched from DHCP to static or from static to DHCP, or the
                    // static IP address has changed.
                    log("Reconfiguring IP on connection");
                    // TODO: clear addresses and disable IPv6
                    // to simplify obtainingIpState.
                    transitionTo(mObtainingIpState);
                }
                if (result.hasProxyChanged()) {
                    log("Reconfiguring proxy on connection");
                    mIpManager.setHttpProxy(getCurrentWifiConfiguration().getHttpProxy());
                }
            } else {
                if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                    break;
                }
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.SAVE_NETWORK_SUCCEEDED);
            break;
        case WifiManager.FORGET_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.removeNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.FORGET_NETWORK_SUCCEEDED);
                broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_FORGOT, (WifiConfiguration) message.obj);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to forget network");
                replyToMessage(message, WifiManager.FORGET_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case WifiManager.START_WPS:
            WpsInfo wpsInfo = (WpsInfo) message.obj;
            WpsResult wpsResult;
            switch(wpsInfo.setup) {
                case WpsInfo.PBC:
                    wpsResult = mWifiSupplicantControl.startWpsPbc(wpsInfo);
                    break;
                case WpsInfo.KEYPAD:
                    wpsResult = mWifiSupplicantControl.startWpsWithPinFromAccessPoint(wpsInfo);
                    break;
                case WpsInfo.DISPLAY:
                    wpsResult = mWifiSupplicantControl.startWpsWithPinFromDevice(wpsInfo);
                    break;
                default:
                    wpsResult = new WpsResult(Status.FAILURE);
                    loge("Invalid setup for WPS");
                    break;
            }
            if (wpsResult.status == Status.SUCCESS) {
                replyToMessage(message, WifiManager.START_WPS_SUCCEEDED, wpsResult);
                transitionTo(mWpsRunningState);
            } else {
                loge("Failed to start WPS with config " + wpsInfo.toString());
                replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // This is where we can confirm the connection BSSID. Use it to find the
            // right ScanDetail to populate metrics.
            String someBssid = (String) message.obj;
            if (someBssid != null) {
                // Get the ScanDetail associated with this BSSID.
                ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(mTargetNetworkId);
                if (scanDetailCache != null) {
                    mWifiMetrics.setConnectionScanDetail(scanDetailCache.getScanDetail(someBssid));
                }
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Network connection established");
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mLastBssid = (String) message.obj;
            mWifiInfo.setBSSID(mLastBssid);
            mWifiInfo.setNetworkId(mLastNetworkId);
            if (mWifiConnectivityManager != null) {
                mWifiConnectivityManager.trackBssid(mLastBssid, true);
            }
            sendNetworkStateChangeBroadcast(mLastBssid);
            transitionTo(mObtainingIpState);
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // at the chip etc...
            if (mVerboseLoggingEnabled)
                log("ConnectModeState: Network connection lost ");
            handleNetworkDisconnect();
            transitionTo(mDisconnectedState);
            break;
        case CMD_ADD_PASSPOINT_MO:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        case CMD_MODIFY_PASSPOINT_MO:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        case CMD_QUERY_OSU_ICON:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        case CMD_MATCH_PROVIDER_NETWORK:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
private boolean connectToUserSelectNetwork(int netId, int uid) {
    if (!mWifiConfigManager.enableNetwork(netId, true, uid)) {
        loge("connectToUserSelectNetwork uid " + uid + " did not have the permissions to enable=" + netId);
        return false;
    }
    if (!mWifiConfigManager.checkAndUpdateLastConnectUid(netId, uid)) {
        loge("connectToUserSelectNetwork uid " + uid + " did not have the permissions to connect=" + netId);
        mWifiConnectivityManager.forceConnectivityScan();
    } else {
        mWifiConnectivityManager.setUserConnectChoice(netId);
        startConnectToNetwork(netId, SUPPLICANT_BSSID_ANY);
    }
    return true;
}
#method_after
private boolean connectToUserSelectNetwork(int netId, int uid) {
    if (!mWifiConfigManager.enableNetwork(netId, true, uid)) {
        loge("connectToUserSelectNetwork uid " + uid + " did not have the permissions to enable=" + netId);
        return false;
    }
    if (!mWifiConfigManager.checkAndUpdateLastConnectUid(netId, uid)) {
        loge("connectToUserSelectNetwork uid " + uid + " did not have the permissions to connect=" + netId);
        // App does not have the permission to force a connection. But, we should still
        // reconsider this newly enabled network for network selection.
        mWifiConnectivityManager.forceConnectivityScan();
    } else {
        // Trigger an immediate connection to the specified network. We're also noting the user
        // connect choice here, so that it will be considered in the next network selection.
        mWifiConnectivityManager.setUserConnectChoice(netId);
        startConnectToNetwork(netId, SUPPLICANT_BSSID_ANY);
    }
    return true;
}
#end_block

#method_before
public void test_CheckedMap_computeIfAbsent() {
    Map<Integer, Double> map = new HashMap<>();
    Map checkedMap = Collections.checkedMap(map, Integer.class, Double.class);
    MapDefaultMethodTester.test_computeIfAbsent(checkedMap, true, /* acceptsNullKey */
    true);
    // Without generics to check the typeCheck implementation
    Map checkedMap2 = Collections.checkedMap(new HashMap<>(), Integer.class, String.class);
    checkedMap2.put(1, A_STRING);
    // When key is present
    assertSame(A_STRING, checkedMap2.computeIfAbsent(1, k -> NOT_A_STRING));
    // When key is absent
    checkedMap2.clear();
    try {
        checkedMap2.computeIfAbsent(1, k -> NOT_A_STRING);
        fail();
    } catch (ClassCastException expected) {
    }
}
#method_after
public void test_CheckedMap_computeIfAbsent() {
    Map<Integer, Double> map = new HashMap<>();
    Map checkedMap = Collections.checkedMap(map, Integer.class, Double.class);
    MapDefaultMethodTester.test_computeIfAbsent(checkedMap, true, /* acceptsNullKey */
    true);
    // Without generics to check the typeCheck implementation
    Map checkedMap2 = Collections.checkedMap(new HashMap<>(), Integer.class, String.class);
    checkedMap2.put(1, A_STRING);
    // When key is present, function should not be invoked
    assertSame(A_STRING, checkedMap2.computeIfAbsent(1, k -> {
        throw new AssertionFailedError("key present: function should not be invoked");
    }));
    // When key is absent, computed value's type should be checked
    checkedMap2.clear();
    try {
        checkedMap2.computeIfAbsent(1, k -> NOT_A_STRING);
        fail();
    } catch (ClassCastException expected) {
    }
}
#end_block

#method_before
@Override
public void onStart() {
    mMountService = new MountService(getContext());
    publishBinderService("mount", mMountService);
}
#method_after
@Override
public void onStart() {
    mMountService = new MountService(getContext());
    publishBinderService("mount", mMountService);
    mMountService.start();
}
#end_block

#method_before
@Override
public void onBootPhase(int phase) {
    if (phase == SystemService.PHASE_ACTIVITY_MANAGER_READY) {
        mMountService.systemReady();
    }
}
#method_after
@Override
public void onBootPhase(int phase) {
    if (phase == SystemService.PHASE_ACTIVITY_MANAGER_READY) {
        mMountService.systemReady();
    } else if (phase == SystemService.PHASE_BOOT_COMPLETED) {
        mMountService.bootCompleted();
    }
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder sb = new StringBuilder("ObbState{");
    sb.append("rawPath=").append(rawPath);
    sb.append(",canonicalPath=").append(canonicalPath);
    sb.append(",ownerPath=").append(ownerPath);
    sb.append(",voldPath=").append(voldPath);
    sb.append(",ownerGid=").append(ownerGid);
    sb.append(",token=").append(token);
    sb.append(",binder=").append(getBinder());
    sb.append('}');
    return sb.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder sb = new StringBuilder("ObbState{");
    sb.append("rawPath=").append(rawPath);
    sb.append(",canonicalPath=").append(canonicalPath);
    sb.append(",ownerGid=").append(ownerGid);
    sb.append(",token=").append(token);
    sb.append(",binder=").append(getBinder());
    sb.append('}');
    return sb.toString();
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case H_SYSTEM_READY:
            {
                handleSystemReady();
                break;
            }
        case H_DAEMON_CONNECTED:
            {
                handleDaemonConnected();
                break;
            }
        case H_FSTRIM:
            {
                if (!isReady()) {
                    Slog.i(TAG, "fstrim requested, but no daemon connection yet; trying again");
                    sendMessageDelayed(obtainMessage(H_FSTRIM, msg.obj), DateUtils.SECOND_IN_MILLIS);
                    break;
                }
                Slog.i(TAG, "Running fstrim idle maintenance");
                // Remember when we kicked it off
                try {
                    mLastMaintenance = System.currentTimeMillis();
                    mLastMaintenanceFile.setLastModified(mLastMaintenance);
                } catch (Exception e) {
                    Slog.e(TAG, "Unable to record last fstrim!");
                }
                final boolean shouldBenchmark = shouldBenchmark();
                try {
                    // This method must be run on the main (handler) thread,
                    // so it is safe to directly call into vold.
                    mConnector.execute("fstrim", shouldBenchmark ? "dotrimbench" : "dotrim");
                } catch (NativeDaemonConnectorException ndce) {
                    Slog.e(TAG, "Failed to run fstrim!");
                }
                // invoke the completion callback, if any
                // TODO: fstrim is non-blocking, so remove this useless callback
                Runnable callback = (Runnable) msg.obj;
                if (callback != null) {
                    callback.run();
                }
                break;
            }
        case H_SHUTDOWN:
            {
                final IMountShutdownObserver obs = (IMountShutdownObserver) msg.obj;
                boolean success = false;
                try {
                    success = mConnector.execute("volume", "shutdown").isClassOk();
                } catch (NativeDaemonConnectorException ignored) {
                }
                if (obs != null) {
                    try {
                        obs.onShutDownComplete(success ? 0 : -1);
                    } catch (RemoteException ignored) {
                    }
                }
                break;
            }
        case H_VOLUME_MOUNT:
            {
                final VolumeInfo vol = (VolumeInfo) msg.obj;
                if (isMountDisallowed(vol)) {
                    Slog.i(TAG, "Ignoring mount " + vol.getId() + " due to policy");
                    break;
                }
                try {
                    mConnector.execute("volume", "mount", vol.id, vol.mountFlags, vol.mountUserId);
                } catch (NativeDaemonConnectorException ignored) {
                }
                break;
            }
        case H_VOLUME_BROADCAST:
            {
                final StorageVolume userVol = (StorageVolume) msg.obj;
                final String envState = userVol.getState();
                Slog.d(TAG, "Volume " + userVol.getId() + " broadcasting " + envState + " to " + userVol.getOwner());
                final String action = VolumeInfo.getBroadcastForEnvironment(envState);
                if (action != null) {
                    final Intent intent = new Intent(action, Uri.fromFile(userVol.getPathFile()));
                    intent.putExtra(StorageVolume.EXTRA_STORAGE_VOLUME, userVol);
                    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
                    mContext.sendBroadcastAsUser(intent, userVol.getOwner());
                }
                break;
            }
        case H_INTERNAL_BROADCAST:
            {
                // Internal broadcasts aimed at system components, not for
                // third-party apps.
                final Intent intent = (Intent) msg.obj;
                mContext.sendBroadcastAsUser(intent, UserHandle.ALL, android.Manifest.permission.WRITE_MEDIA_STORAGE);
            }
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case H_SYSTEM_READY:
            {
                handleSystemReady();
                break;
            }
        case H_DAEMON_CONNECTED:
            {
                handleDaemonConnected();
                break;
            }
        case H_FSTRIM:
            {
                if (!isReady()) {
                    Slog.i(TAG, "fstrim requested, but no daemon connection yet; trying again");
                    sendMessageDelayed(obtainMessage(H_FSTRIM, msg.obj), DateUtils.SECOND_IN_MILLIS);
                    break;
                }
                Slog.i(TAG, "Running fstrim idle maintenance");
                // Remember when we kicked it off
                try {
                    mLastMaintenance = System.currentTimeMillis();
                    mLastMaintenanceFile.setLastModified(mLastMaintenance);
                } catch (Exception e) {
                    Slog.e(TAG, "Unable to record last fstrim!");
                }
                final boolean shouldBenchmark = shouldBenchmark();
                try {
                    // This method must be run on the main (handler) thread,
                    // so it is safe to directly call into vold.
                    mConnector.execute("fstrim", shouldBenchmark ? "dotrimbench" : "dotrim");
                } catch (NativeDaemonConnectorException ndce) {
                    Slog.e(TAG, "Failed to run fstrim!");
                }
                // invoke the completion callback, if any
                // TODO: fstrim is non-blocking, so remove this useless callback
                Runnable callback = (Runnable) msg.obj;
                if (callback != null) {
                    callback.run();
                }
                break;
            }
        case H_SHUTDOWN:
            {
                final IMountShutdownObserver obs = (IMountShutdownObserver) msg.obj;
                boolean success = false;
                try {
                    success = mConnector.execute("volume", "shutdown").isClassOk();
                } catch (NativeDaemonConnectorException ignored) {
                }
                if (obs != null) {
                    try {
                        obs.onShutDownComplete(success ? 0 : -1);
                    } catch (RemoteException ignored) {
                    }
                }
                break;
            }
        case H_VOLUME_MOUNT:
            {
                final VolumeInfo vol = (VolumeInfo) msg.obj;
                if (isMountDisallowed(vol)) {
                    Slog.i(TAG, "Ignoring mount " + vol.getId() + " due to policy");
                    break;
                }
                try {
                    mConnector.execute("volume", "mount", vol.id, vol.mountFlags, vol.mountUserId);
                } catch (NativeDaemonConnectorException ignored) {
                }
                break;
            }
        case H_VOLUME_UNMOUNT:
            {
                final VolumeInfo vol = (VolumeInfo) msg.obj;
                unmount(vol.getId());
                break;
            }
        case H_VOLUME_BROADCAST:
            {
                final StorageVolume userVol = (StorageVolume) msg.obj;
                final String envState = userVol.getState();
                Slog.d(TAG, "Volume " + userVol.getId() + " broadcasting " + envState + " to " + userVol.getOwner());
                final String action = VolumeInfo.getBroadcastForEnvironment(envState);
                if (action != null) {
                    final Intent intent = new Intent(action, Uri.fromFile(userVol.getPathFile()));
                    intent.putExtra(StorageVolume.EXTRA_STORAGE_VOLUME, userVol);
                    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
                    mContext.sendBroadcastAsUser(intent, userVol.getOwner());
                }
                break;
            }
        case H_INTERNAL_BROADCAST:
            {
                // Internal broadcasts aimed at system components, not for
                // third-party apps.
                final Intent intent = (Intent) msg.obj;
                mContext.sendBroadcastAsUser(intent, UserHandle.ALL, android.Manifest.permission.WRITE_MEDIA_STORAGE);
                break;
            }
        case H_PARTITION_FORGET:
            {
                final String partGuid = (String) msg.obj;
                forgetPartition(partGuid);
                break;
            }
        case H_RESET:
            {
                resetIfReadyAndConnected();
                break;
            }
    }
}
#end_block

#method_before
private void handleSystemReady() {
    synchronized (mLock) {
        resetIfReadyAndConnectedLocked();
    }
    // Start scheduling nominally-daily fstrim operations
    MountServiceIdler.scheduleIdlePass(mContext);
}
#method_after
private void handleSystemReady() {
    initIfReadyAndConnected();
    resetIfReadyAndConnected();
    // Start scheduling nominally-daily fstrim operations
    MountServiceIdler.scheduleIdlePass(mContext);
}
#end_block

#method_before
@Deprecated
private void killMediaProvider() {
    final long token = Binder.clearCallingIdentity();
    try {
        final ProviderInfo provider = mPms.resolveContentProvider(MediaStore.AUTHORITY, 0, UserHandle.USER_OWNER);
        if (provider != null) {
            final IActivityManager am = ActivityManagerNative.getDefault();
            try {
                am.killApplicationWithAppId(provider.applicationInfo.packageName, UserHandle.getAppId(provider.applicationInfo.uid), "vold reset");
            } catch (RemoteException e) {
            }
        }
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#method_after
@Deprecated
private void killMediaProvider(List<UserInfo> users) {
    if (users == null)
        return;
    final long token = Binder.clearCallingIdentity();
    try {
        for (UserInfo user : users) {
            // System user does not have media provider, so skip.
            if (user.isSystemOnly())
                continue;
            final ProviderInfo provider = mPms.resolveContentProvider(MediaStore.AUTHORITY, PackageManager.MATCH_DIRECT_BOOT_AWARE | PackageManager.MATCH_DIRECT_BOOT_UNAWARE, user.id);
            if (provider != null) {
                final IActivityManager am = ActivityManagerNative.getDefault();
                try {
                    am.killApplication(provider.applicationInfo.packageName, UserHandle.getAppId(provider.applicationInfo.uid), UserHandle.USER_ALL, "vold reset");
                    // We only need to run this once. It will kill all users' media processes.
                    break;
                } catch (RemoteException e) {
                }
            }
        }
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
private void onCleanupUser(int userId) {
    Slog.d(TAG, "onCleanupUser " + userId);
    try {
        mConnector.execute("volume", "user_stopped", userId);
    } catch (NativeDaemonConnectorException ignored) {
    }
    synchronized (mLock) {
        mStartedUsers = ArrayUtils.removeInt(mStartedUsers, userId);
    }
}
#method_after
private void onCleanupUser(int userId) {
    Slog.d(TAG, "onCleanupUser " + userId);
    try {
        mConnector.execute("volume", "user_stopped", userId);
    } catch (NativeDaemonConnectorException ignored) {
    }
    synchronized (mLock) {
        mSystemUnlockedUsers = ArrayUtils.removeInt(mSystemUnlockedUsers, userId);
    }
}
#end_block

#method_before
private void handleDaemonConnected() {
    synchronized (mLock) {
        resetIfReadyAndConnectedLocked();
    }
    /*
         * Now that we've done our initialization, release
         * the hounds!
         */
    mConnectedSignal.countDown();
    if (mConnectedSignal.getCount() != 0) {
        // More daemons need to connect
        return;
    }
    // the system locale out of the mount service.
    if ("".equals(SystemProperties.get("vold.encrypt_progress"))) {
        copyLocaleFromMountService();
    }
    // Let package manager load internal ASECs.
    mPms.scanAvailableAsecs();
    // Notify people waiting for ASECs to be scanned that it's done.
    mAsecsScanned.countDown();
}
#method_after
private void handleDaemonConnected() {
    initIfReadyAndConnected();
    resetIfReadyAndConnected();
    /*
         * Now that we've done our initialization, release
         * the hounds!
         */
    mConnectedSignal.countDown();
    if (mConnectedSignal.getCount() != 0) {
        // More daemons need to connect
        return;
    }
    // the system locale out of the mount service.
    if ("".equals(SystemProperties.get("vold.encrypt_progress"))) {
        copyLocaleFromMountService();
    }
    // Let package manager load internal ASECs.
    mPms.scanAvailableAsecs();
    // Notify people waiting for ASECs to be scanned that it's done.
    mAsecsScanned.countDown();
}
#end_block

#method_before
private void copyLocaleFromMountService() {
    String systemLocale;
    try {
        systemLocale = getField(StorageManager.SYSTEM_LOCALE_KEY);
    } catch (RemoteException e) {
        return;
    }
    if (TextUtils.isEmpty(systemLocale)) {
        return;
    }
    Slog.d(TAG, "Got locale " + systemLocale + " from mount service");
    Locale locale = Locale.forLanguageTag(systemLocale);
    Configuration config = new Configuration();
    config.setLocale(locale);
    try {
        ActivityManagerNative.getDefault().updateConfiguration(config);
    } catch (RemoteException e) {
        Slog.e(TAG, "Error setting system locale from mount service", e);
    }
    // Temporary workaround for http://b/17945169.
    Slog.d(TAG, "Setting system properties to " + systemLocale + " from mount service");
    SystemProperties.set("persist.sys.locale", locale.toLanguageTag());
}
#method_after
private void copyLocaleFromMountService() {
    String systemLocale;
    try {
        systemLocale = getField(StorageManager.SYSTEM_LOCALE_KEY);
    } catch (RemoteException e) {
        return;
    }
    if (TextUtils.isEmpty(systemLocale)) {
        return;
    }
    Slog.d(TAG, "Got locale " + systemLocale + " from mount service");
    Locale locale = Locale.forLanguageTag(systemLocale);
    Configuration config = new Configuration();
    config.setLocale(locale);
    try {
        ActivityManagerNative.getDefault().updatePersistentConfiguration(config);
    } catch (RemoteException e) {
        Slog.e(TAG, "Error setting system locale from mount service", e);
    }
    // Temporary workaround for http://b/17945169.
    Slog.d(TAG, "Setting system properties to " + systemLocale + " from mount service");
    SystemProperties.set("persist.sys.locale", locale.toLanguageTag());
}
#end_block

#method_before
private void onDiskScannedLocked(DiskInfo disk) {
    int volumeCount = 0;
    for (int i = 0; i < mVolumes.size(); i++) {
        final VolumeInfo vol = mVolumes.valueAt(i);
        if (Objects.equals(disk.id, vol.getDiskId())) {
            volumeCount++;
        }
    }
    final Intent intent = new Intent(DiskInfo.ACTION_DISK_SCANNED);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(DiskInfo.EXTRA_DISK_ID, disk.id);
    intent.putExtra(DiskInfo.EXTRA_VOLUME_COUNT, volumeCount);
    mHandler.obtainMessage(H_INTERNAL_BROADCAST, intent).sendToTarget();
    final CountDownLatch latch = mDiskScanLatches.remove(disk.id);
    if (latch != null) {
        latch.countDown();
    }
    disk.volumeCount = volumeCount;
    mCallbacks.notifyDiskScanned(disk, volumeCount);
}
#method_after
private void onDiskScannedLocked(DiskInfo disk) {
    int volumeCount = 0;
    for (int i = 0; i < mVolumes.size(); i++) {
        final VolumeInfo vol = mVolumes.valueAt(i);
        if (Objects.equals(disk.id, vol.getDiskId())) {
            volumeCount++;
        }
    }
    final Intent intent = new Intent(DiskInfo.ACTION_DISK_SCANNED);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
    intent.putExtra(DiskInfo.EXTRA_DISK_ID, disk.id);
    intent.putExtra(DiskInfo.EXTRA_VOLUME_COUNT, volumeCount);
    mHandler.obtainMessage(H_INTERNAL_BROADCAST, intent).sendToTarget();
    final CountDownLatch latch = mDiskScanLatches.remove(disk.id);
    if (latch != null) {
        latch.countDown();
    }
    disk.volumeCount = volumeCount;
    mCallbacks.notifyDiskScanned(disk, volumeCount);
}
#end_block

#method_before
private void onVolumeCreatedLocked(VolumeInfo vol) {
    if (vol.type == VolumeInfo.TYPE_EMULATED) {
        final StorageManager storage = mContext.getSystemService(StorageManager.class);
        final VolumeInfo privateVol = storage.findPrivateForEmulated(vol);
        if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, mPrimaryStorageUuid) && VolumeInfo.ID_PRIVATE_INTERNAL.equals(privateVol.id)) {
            Slog.v(TAG, "Found primary storage at " + vol);
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_PRIMARY;
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_VISIBLE;
            mHandler.obtainMessage(H_VOLUME_MOUNT, vol).sendToTarget();
        } else if (Objects.equals(privateVol.fsUuid, mPrimaryStorageUuid)) {
            Slog.v(TAG, "Found primary storage at " + vol);
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_PRIMARY;
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_VISIBLE;
            mHandler.obtainMessage(H_VOLUME_MOUNT, vol).sendToTarget();
        }
    } else if (vol.type == VolumeInfo.TYPE_PUBLIC) {
        // TODO: only look at first public partition
        if (Objects.equals(StorageManager.UUID_PRIMARY_PHYSICAL, mPrimaryStorageUuid) && vol.disk.isDefaultPrimary()) {
            Slog.v(TAG, "Found primary storage at " + vol);
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_PRIMARY;
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_VISIBLE;
        }
        // public API requirement of being in a stable location.
        if (vol.disk.isAdoptable()) {
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_VISIBLE;
        }
        vol.mountUserId = UserHandle.USER_OWNER;
        mHandler.obtainMessage(H_VOLUME_MOUNT, vol).sendToTarget();
    } else if (vol.type == VolumeInfo.TYPE_PRIVATE) {
        mHandler.obtainMessage(H_VOLUME_MOUNT, vol).sendToTarget();
    } else {
        Slog.d(TAG, "Skipping automatic mounting of " + vol);
    }
}
#method_after
private void onVolumeCreatedLocked(VolumeInfo vol) {
    if (mPms.isOnlyCoreApps()) {
        Slog.d(TAG, "System booted in core-only mode; ignoring volume " + vol.getId());
        return;
    }
    if (vol.type == VolumeInfo.TYPE_EMULATED) {
        final StorageManager storage = mContext.getSystemService(StorageManager.class);
        final VolumeInfo privateVol = storage.findPrivateForEmulated(vol);
        if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, mPrimaryStorageUuid) && VolumeInfo.ID_PRIVATE_INTERNAL.equals(privateVol.id)) {
            Slog.v(TAG, "Found primary storage at " + vol);
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_PRIMARY;
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_VISIBLE;
            mHandler.obtainMessage(H_VOLUME_MOUNT, vol).sendToTarget();
        } else if (Objects.equals(privateVol.fsUuid, mPrimaryStorageUuid)) {
            Slog.v(TAG, "Found primary storage at " + vol);
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_PRIMARY;
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_VISIBLE;
            mHandler.obtainMessage(H_VOLUME_MOUNT, vol).sendToTarget();
        }
    } else if (vol.type == VolumeInfo.TYPE_PUBLIC) {
        // TODO: only look at first public partition
        if (Objects.equals(StorageManager.UUID_PRIMARY_PHYSICAL, mPrimaryStorageUuid) && vol.disk.isDefaultPrimary()) {
            Slog.v(TAG, "Found primary storage at " + vol);
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_PRIMARY;
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_VISIBLE;
        }
        // public API requirement of being in a stable location.
        if (vol.disk.isAdoptable()) {
            vol.mountFlags |= VolumeInfo.MOUNT_FLAG_VISIBLE;
        }
        vol.mountUserId = mCurrentUserId;
        mHandler.obtainMessage(H_VOLUME_MOUNT, vol).sendToTarget();
    } else if (vol.type == VolumeInfo.TYPE_PRIVATE) {
        mHandler.obtainMessage(H_VOLUME_MOUNT, vol).sendToTarget();
    } else {
        Slog.d(TAG, "Skipping automatic mounting of " + vol);
    }
}
#end_block

#method_before
private void onVolumeStateChangedLocked(VolumeInfo vol, int oldState, int newState) {
    // metadata, or so we can annoy them when a private volume is ejected
    if (vol.isMountedReadable() && !TextUtils.isEmpty(vol.fsUuid)) {
        VolumeRecord rec = mRecords.get(vol.fsUuid);
        if (rec == null) {
            rec = new VolumeRecord(vol.type, vol.fsUuid);
            rec.partGuid = vol.partGuid;
            rec.createdMillis = System.currentTimeMillis();
            if (vol.type == VolumeInfo.TYPE_PRIVATE) {
                rec.nickname = vol.disk.getDescription();
            }
            mRecords.put(rec.fsUuid, rec);
            writeSettingsLocked();
        } else {
            // Handle upgrade case where we didn't store partition GUID
            if (TextUtils.isEmpty(rec.partGuid)) {
                rec.partGuid = vol.partGuid;
                writeSettingsLocked();
            }
        }
    }
    mCallbacks.notifyVolumeStateChanged(vol, oldState, newState);
    if (isBroadcastWorthy(vol)) {
        final Intent intent = new Intent(VolumeInfo.ACTION_VOLUME_STATE_CHANGED);
        intent.putExtra(VolumeInfo.EXTRA_VOLUME_ID, vol.id);
        intent.putExtra(VolumeInfo.EXTRA_VOLUME_STATE, newState);
        intent.putExtra(VolumeRecord.EXTRA_FS_UUID, vol.fsUuid);
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
        mHandler.obtainMessage(H_INTERNAL_BROADCAST, intent).sendToTarget();
    }
    final String oldStateEnv = VolumeInfo.getEnvironmentForState(oldState);
    final String newStateEnv = VolumeInfo.getEnvironmentForState(newState);
    if (!Objects.equals(oldStateEnv, newStateEnv)) {
        // user-specific broadcasts.
        for (int userId : mStartedUsers) {
            if (vol.isVisibleForRead(userId)) {
                final StorageVolume userVol = vol.buildStorageVolume(mContext, userId, false);
                mHandler.obtainMessage(H_VOLUME_BROADCAST, userVol).sendToTarget();
                mCallbacks.notifyStorageStateChanged(userVol.getPath(), oldStateEnv, newStateEnv);
            }
        }
    }
    if (vol.type == VolumeInfo.TYPE_PUBLIC && vol.state == VolumeInfo.STATE_EJECTING) {
        // TODO: this should eventually be handled by new ObbVolume state changes
        /*
             * Some OBBs might have been unmounted when this volume was
             * unmounted, so send a message to the handler to let it know to
             * remove those from the list of mounted OBBS.
             */
        mObbActionHandler.sendMessage(mObbActionHandler.obtainMessage(OBB_FLUSH_MOUNT_STATE, vol.path));
    }
}
#method_after
private void onVolumeStateChangedLocked(VolumeInfo vol, int oldState, int newState) {
    // metadata, or so we can annoy them when a private volume is ejected
    if (vol.isMountedReadable() && !TextUtils.isEmpty(vol.fsUuid)) {
        VolumeRecord rec = mRecords.get(vol.fsUuid);
        if (rec == null) {
            rec = new VolumeRecord(vol.type, vol.fsUuid);
            rec.partGuid = vol.partGuid;
            rec.createdMillis = System.currentTimeMillis();
            if (vol.type == VolumeInfo.TYPE_PRIVATE) {
                rec.nickname = vol.disk.getDescription();
            }
            mRecords.put(rec.fsUuid, rec);
            writeSettingsLocked();
        } else {
            // Handle upgrade case where we didn't store partition GUID
            if (TextUtils.isEmpty(rec.partGuid)) {
                rec.partGuid = vol.partGuid;
                writeSettingsLocked();
            }
        }
    }
    mCallbacks.notifyVolumeStateChanged(vol, oldState, newState);
    // processes that receive the intent unnecessarily.
    if (mBootCompleted && isBroadcastWorthy(vol)) {
        final Intent intent = new Intent(VolumeInfo.ACTION_VOLUME_STATE_CHANGED);
        intent.putExtra(VolumeInfo.EXTRA_VOLUME_ID, vol.id);
        intent.putExtra(VolumeInfo.EXTRA_VOLUME_STATE, newState);
        intent.putExtra(VolumeRecord.EXTRA_FS_UUID, vol.fsUuid);
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
        mHandler.obtainMessage(H_INTERNAL_BROADCAST, intent).sendToTarget();
    }
    final String oldStateEnv = VolumeInfo.getEnvironmentForState(oldState);
    final String newStateEnv = VolumeInfo.getEnvironmentForState(newState);
    if (!Objects.equals(oldStateEnv, newStateEnv)) {
        // user-specific broadcasts.
        for (int userId : mSystemUnlockedUsers) {
            if (vol.isVisibleForRead(userId)) {
                final StorageVolume userVol = vol.buildStorageVolume(mContext, userId, false);
                mHandler.obtainMessage(H_VOLUME_BROADCAST, userVol).sendToTarget();
                mCallbacks.notifyStorageStateChanged(userVol.getPath(), oldStateEnv, newStateEnv);
            }
        }
    }
    if (vol.type == VolumeInfo.TYPE_PUBLIC && vol.state == VolumeInfo.STATE_EJECTING) {
        // TODO: this should eventually be handled by new ObbVolume state changes
        /*
             * Some OBBs might have been unmounted when this volume was
             * unmounted, so send a message to the handler to let it know to
             * remove those from the list of mounted OBBS.
             */
        mObbActionHandler.sendMessage(mObbActionHandler.obtainMessage(OBB_FLUSH_MOUNT_STATE, vol.path));
    }
}
#end_block

#method_before
@Override
public void forgetVolume(String fsUuid) {
    enforcePermission(android.Manifest.permission.MOUNT_UNMOUNT_FILESYSTEMS);
    waitForReady();
    Preconditions.checkNotNull(fsUuid);
    synchronized (mLock) {
        final VolumeRecord rec = mRecords.remove(fsUuid);
        if (rec != null && !TextUtils.isEmpty(rec.partGuid)) {
            forgetPartition(rec.partGuid);
        }
        mCallbacks.notifyVolumeForgotten(fsUuid);
        // reset vold so we bind into new volume into place.
        if (Objects.equals(mPrimaryStorageUuid, fsUuid)) {
            mPrimaryStorageUuid = getDefaultPrimaryStorageUuid();
            resetIfReadyAndConnectedLocked();
        }
        writeSettingsLocked();
    }
}
#method_after
@Override
public void forgetVolume(String fsUuid) {
    enforcePermission(android.Manifest.permission.MOUNT_UNMOUNT_FILESYSTEMS);
    waitForReady();
    Preconditions.checkNotNull(fsUuid);
    synchronized (mLock) {
        final VolumeRecord rec = mRecords.remove(fsUuid);
        if (rec != null && !TextUtils.isEmpty(rec.partGuid)) {
            mHandler.obtainMessage(H_PARTITION_FORGET, rec.partGuid).sendToTarget();
        }
        mCallbacks.notifyVolumeForgotten(fsUuid);
        // reset vold so we bind into new volume into place.
        if (Objects.equals(mPrimaryStorageUuid, fsUuid)) {
            mPrimaryStorageUuid = getDefaultPrimaryStorageUuid();
            mHandler.obtainMessage(H_RESET).sendToTarget();
        }
        writeSettingsLocked();
    }
}
#end_block

#method_before
@Override
public void forgetAllVolumes() {
    enforcePermission(android.Manifest.permission.MOUNT_UNMOUNT_FILESYSTEMS);
    waitForReady();
    synchronized (mLock) {
        for (int i = 0; i < mRecords.size(); i++) {
            final String fsUuid = mRecords.keyAt(i);
            final VolumeRecord rec = mRecords.valueAt(i);
            if (!TextUtils.isEmpty(rec.partGuid)) {
                forgetPartition(rec.partGuid);
            }
            mCallbacks.notifyVolumeForgotten(fsUuid);
        }
        mRecords.clear();
        if (!Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, mPrimaryStorageUuid)) {
            mPrimaryStorageUuid = getDefaultPrimaryStorageUuid();
        }
        writeSettingsLocked();
        resetIfReadyAndConnectedLocked();
    }
}
#method_after
@Override
public void forgetAllVolumes() {
    enforcePermission(android.Manifest.permission.MOUNT_UNMOUNT_FILESYSTEMS);
    waitForReady();
    synchronized (mLock) {
        for (int i = 0; i < mRecords.size(); i++) {
            final String fsUuid = mRecords.keyAt(i);
            final VolumeRecord rec = mRecords.valueAt(i);
            if (!TextUtils.isEmpty(rec.partGuid)) {
                mHandler.obtainMessage(H_PARTITION_FORGET, rec.partGuid).sendToTarget();
            }
            mCallbacks.notifyVolumeForgotten(fsUuid);
        }
        mRecords.clear();
        if (!Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, mPrimaryStorageUuid)) {
            mPrimaryStorageUuid = getDefaultPrimaryStorageUuid();
        }
        writeSettingsLocked();
        mHandler.obtainMessage(H_RESET).sendToTarget();
    }
}
#end_block

#method_before
@Override
public void setDebugFlags(int flags, int mask) {
    enforcePermission(android.Manifest.permission.MOUNT_UNMOUNT_FILESYSTEMS);
    waitForReady();
    synchronized (mLock) {
        if ((mask & StorageManager.DEBUG_FORCE_ADOPTABLE) != 0) {
            mForceAdoptable = (flags & StorageManager.DEBUG_FORCE_ADOPTABLE) != 0;
        }
        writeSettingsLocked();
        resetIfReadyAndConnectedLocked();
    }
}
#method_after
@Override
public void setDebugFlags(int flags, int mask) {
    enforcePermission(android.Manifest.permission.MOUNT_UNMOUNT_FILESYSTEMS);
    waitForReady();
    if ((mask & StorageManager.DEBUG_EMULATE_FBE) != 0) {
        if (StorageManager.isFileEncryptedNativeOnly()) {
            throw new IllegalStateException("Emulation not available on device with native FBE");
        }
        if (mLockPatternUtils.isCredentialRequiredToDecrypt(false)) {
            throw new IllegalStateException("Emulation requires disabling 'Secure start-up' in Settings > Security");
        }
        final long token = Binder.clearCallingIdentity();
        try {
            final boolean emulateFbe = (flags & StorageManager.DEBUG_EMULATE_FBE) != 0;
            SystemProperties.set(StorageManager.PROP_EMULATE_FBE, Boolean.toString(emulateFbe));
            // Perform hard reboot to kick policy into place
            mContext.getSystemService(PowerManager.class).reboot(null);
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }
    if ((mask & StorageManager.DEBUG_FORCE_ADOPTABLE) != 0) {
        synchronized (mLock) {
            mForceAdoptable = (flags & StorageManager.DEBUG_FORCE_ADOPTABLE) != 0;
            writeSettingsLocked();
            mHandler.obtainMessage(H_RESET).sendToTarget();
        }
    }
    if ((mask & (StorageManager.DEBUG_SDCARDFS_FORCE_ON | StorageManager.DEBUG_SDCARDFS_FORCE_OFF)) != 0) {
        final String value;
        if ((flags & StorageManager.DEBUG_SDCARDFS_FORCE_ON) != 0) {
            value = "force_on";
        } else if ((flags & StorageManager.DEBUG_SDCARDFS_FORCE_OFF) != 0) {
            value = "force_off";
        } else {
            value = "";
        }
        final long token = Binder.clearCallingIdentity();
        try {
            SystemProperties.set(StorageManager.PROP_SDCARDFS, value);
            // Reset storage to kick new setting into place
            mHandler.obtainMessage(H_RESET).sendToTarget();
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }
}
#end_block

#method_before
@Override
public void setPrimaryStorageUuid(String volumeUuid, IPackageMoveObserver callback) {
    enforcePermission(android.Manifest.permission.MOUNT_UNMOUNT_FILESYSTEMS);
    waitForReady();
    synchronized (mLock) {
        if (Objects.equals(mPrimaryStorageUuid, volumeUuid)) {
            throw new IllegalArgumentException("Primary storage already at " + volumeUuid);
        }
        if (mMoveCallback != null) {
            throw new IllegalStateException("Move already in progress");
        }
        mMoveCallback = callback;
        mMoveTargetUuid = volumeUuid;
        // the current storage location, so we have nothing to move.
        if (Objects.equals(StorageManager.UUID_PRIMARY_PHYSICAL, mPrimaryStorageUuid) || Objects.equals(StorageManager.UUID_PRIMARY_PHYSICAL, volumeUuid)) {
            Slog.d(TAG, "Skipping move to/from primary physical");
            onMoveStatusLocked(MOVE_STATUS_COPY_FINISHED);
            onMoveStatusLocked(PackageManager.MOVE_SUCCEEDED);
            resetIfReadyAndConnectedLocked();
        } else {
            final VolumeInfo from = findStorageForUuid(mPrimaryStorageUuid);
            final VolumeInfo to = findStorageForUuid(volumeUuid);
            if (from == null) {
                Slog.w(TAG, "Failing move due to missing from volume " + mPrimaryStorageUuid);
                onMoveStatusLocked(PackageManager.MOVE_FAILED_INTERNAL_ERROR);
                return;
            } else if (to == null) {
                Slog.w(TAG, "Failing move due to missing to volume " + volumeUuid);
                onMoveStatusLocked(PackageManager.MOVE_FAILED_INTERNAL_ERROR);
                return;
            }
            try {
                mConnector.execute("volume", "move_storage", from.id, to.id);
            } catch (NativeDaemonConnectorException e) {
                throw e.rethrowAsParcelableException();
            }
        }
    }
}
#method_after
@Override
public void setPrimaryStorageUuid(String volumeUuid, IPackageMoveObserver callback) {
    enforcePermission(android.Manifest.permission.MOUNT_UNMOUNT_FILESYSTEMS);
    waitForReady();
    final VolumeInfo from;
    final VolumeInfo to;
    synchronized (mLock) {
        if (Objects.equals(mPrimaryStorageUuid, volumeUuid)) {
            throw new IllegalArgumentException("Primary storage already at " + volumeUuid);
        }
        if (mMoveCallback != null) {
            throw new IllegalStateException("Move already in progress");
        }
        mMoveCallback = callback;
        mMoveTargetUuid = volumeUuid;
        // the current storage location, so we have nothing to move.
        if (Objects.equals(StorageManager.UUID_PRIMARY_PHYSICAL, mPrimaryStorageUuid) || Objects.equals(StorageManager.UUID_PRIMARY_PHYSICAL, volumeUuid)) {
            Slog.d(TAG, "Skipping move to/from primary physical");
            onMoveStatusLocked(MOVE_STATUS_COPY_FINISHED);
            onMoveStatusLocked(PackageManager.MOVE_SUCCEEDED);
            mHandler.obtainMessage(H_RESET).sendToTarget();
            return;
        } else {
            from = findStorageForUuid(mPrimaryStorageUuid);
            to = findStorageForUuid(volumeUuid);
            if (from == null) {
                Slog.w(TAG, "Failing move due to missing from volume " + mPrimaryStorageUuid);
                onMoveStatusLocked(PackageManager.MOVE_FAILED_INTERNAL_ERROR);
                return;
            } else if (to == null) {
                Slog.w(TAG, "Failing move due to missing to volume " + volumeUuid);
                onMoveStatusLocked(PackageManager.MOVE_FAILED_INTERNAL_ERROR);
                return;
            }
        }
    }
    try {
        mConnector.execute("volume", "move_storage", from.id, to.id);
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#end_block

#method_before
private boolean isUidOwnerOfPackageOrSystem(String packageName, int callerUid) {
    if (callerUid == android.os.Process.SYSTEM_UID) {
        return true;
    }
    if (packageName == null) {
        return false;
    }
    final int packageUid = mPms.getPackageUid(packageName, UserHandle.getUserId(callerUid));
    if (DEBUG_OBB) {
        Slog.d(TAG, "packageName = " + packageName + ", packageUid = " + packageUid + ", callerUid = " + callerUid);
    }
    return callerUid == packageUid;
}
#method_after
private boolean isUidOwnerOfPackageOrSystem(String packageName, int callerUid) {
    if (callerUid == android.os.Process.SYSTEM_UID) {
        return true;
    }
    if (packageName == null) {
        return false;
    }
    final int packageUid = mPms.getPackageUid(packageName, PackageManager.MATCH_DEBUG_TRIAGED_MISSING, UserHandle.getUserId(callerUid));
    if (DEBUG_OBB) {
        Slog.d(TAG, "packageName = " + packageName + ", packageUid = " + packageUid + ", callerUid = " + callerUid);
    }
    return callerUid == packageUid;
}
#end_block

#method_before
public String getMountedObbPath(String rawPath) {
    Preconditions.checkNotNull(rawPath, "rawPath cannot be null");
    waitForReady();
    warnOnNotMounted();
    final ObbState state;
    synchronized (mObbMounts) {
        state = mObbPathToStateMap.get(rawPath);
    }
    if (state == null) {
        Slog.w(TAG, "Failed to find OBB mounted at " + rawPath);
        return null;
    }
    final NativeDaemonEvent event;
    try {
        event = mConnector.execute("obb", "path", state.voldPath);
        event.checkCode(VoldResponseCode.AsecPathResult);
        return event.getMessage();
    } catch (NativeDaemonConnectorException e) {
        int code = e.getCode();
        if (code == VoldResponseCode.OpFailedStorageNotFound) {
            return null;
        } else {
            throw new IllegalStateException(String.format("Unexpected response code %d", code));
        }
    }
}
#method_after
public String getMountedObbPath(String rawPath) {
    Preconditions.checkNotNull(rawPath, "rawPath cannot be null");
    waitForReady();
    warnOnNotMounted();
    final ObbState state;
    synchronized (mObbMounts) {
        state = mObbPathToStateMap.get(rawPath);
    }
    if (state == null) {
        Slog.w(TAG, "Failed to find OBB mounted at " + rawPath);
        return null;
    }
    final NativeDaemonEvent event;
    try {
        event = mConnector.execute("obb", "path", state.canonicalPath);
        event.checkCode(VoldResponseCode.AsecPathResult);
        return event.getMessage();
    } catch (NativeDaemonConnectorException e) {
        int code = e.getCode();
        if (code == VoldResponseCode.OpFailedStorageNotFound) {
            return null;
        } else {
            throw new IllegalStateException(String.format("Unexpected response code %d", code));
        }
    }
}
#end_block

#method_before
@Override
public int getPasswordType() {
    waitForReady();
    final NativeDaemonEvent event;
    try {
        event = mCryptConnector.execute("cryptfs", "getpwtype");
        for (int i = 0; i < CRYPTO_TYPES.length; ++i) {
            if (CRYPTO_TYPES[i].equals(event.getMessage()))
                return i;
        }
        throw new IllegalStateException("unexpected return from cryptfs");
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
@Override
public int getPasswordType() {
    mContext.enforceCallingOrSelfPermission(Manifest.permission.STORAGE_INTERNAL, "no permission to access the crypt keeper");
    waitForReady();
    final NativeDaemonEvent event;
    try {
        event = mCryptConnector.execute("cryptfs", "getpwtype");
        for (int i = 0; i < CRYPTO_TYPES.length; ++i) {
            if (CRYPTO_TYPES[i].equals(event.getMessage()))
                return i;
        }
        throw new IllegalStateException("unexpected return from cryptfs");
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#end_block

#method_before
@Override
public void setField(String field, String contents) throws RemoteException {
    waitForReady();
    final NativeDaemonEvent event;
    try {
        event = mCryptConnector.execute("cryptfs", "setfield", field, contents);
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
@Override
public void setField(String field, String contents) throws RemoteException {
    mContext.enforceCallingOrSelfPermission(Manifest.permission.STORAGE_INTERNAL, "no permission to access the crypt keeper");
    waitForReady();
    final NativeDaemonEvent event;
    try {
        event = mCryptConnector.execute("cryptfs", "setfield", field, contents);
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#end_block

#method_before
@Override
public String getField(String field) throws RemoteException {
    waitForReady();
    final NativeDaemonEvent event;
    try {
        final String[] contents = NativeDaemonEvent.filterMessageList(mCryptConnector.executeForList("cryptfs", "getfield", field), VoldResponseCode.CryptfsGetfieldResult);
        String result = new String();
        for (String content : contents) {
            result += content;
        }
        return result;
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
@Override
public String getField(String field) throws RemoteException {
    mContext.enforceCallingOrSelfPermission(Manifest.permission.STORAGE_INTERNAL, "no permission to access the crypt keeper");
    waitForReady();
    final NativeDaemonEvent event;
    try {
        final String[] contents = NativeDaemonEvent.filterMessageList(mCryptConnector.executeForList("cryptfs", "getfield", field), VoldResponseCode.CryptfsGetfieldResult);
        String result = new String();
        for (String content : contents) {
            result += content;
        }
        return result;
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#end_block

#method_before
@Override
public String getPassword() throws RemoteException {
    mContext.enforceCallingOrSelfPermission(Manifest.permission.ACCESS_KEYGUARD_SECURE_STORAGE, "only keyguard can retrieve password");
    if (!isReady()) {
        return new String();
    }
    final NativeDaemonEvent event;
    try {
        event = mCryptConnector.execute("cryptfs", "getpw");
        if ("-1".equals(event.getMessage())) {
            // -1 equals no password
            return null;
        }
        return event.getMessage();
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    } catch (IllegalArgumentException e) {
        Slog.e(TAG, "Invalid response to getPassword");
        return null;
    }
}
#method_after
@Override
public String getPassword() throws RemoteException {
    mContext.enforceCallingOrSelfPermission(Manifest.permission.STORAGE_INTERNAL, "only keyguard can retrieve password");
    if (!isReady()) {
        return new String();
    }
    final NativeDaemonEvent event;
    try {
        event = mCryptConnector.execute("cryptfs", "getpw");
        if ("-1".equals(event.getMessage())) {
            // -1 equals no password
            return null;
        }
        return event.getMessage();
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    } catch (IllegalArgumentException e) {
        Slog.e(TAG, "Invalid response to getPassword");
        return null;
    }
}
#end_block

#method_before
@Override
public void clearPassword() throws RemoteException {
    if (!isReady()) {
        return;
    }
    final NativeDaemonEvent event;
    try {
        event = mCryptConnector.execute("cryptfs", "clearpw");
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
@Override
public void clearPassword() throws RemoteException {
    mContext.enforceCallingOrSelfPermission(Manifest.permission.STORAGE_INTERNAL, "only keyguard can clear password");
    if (!isReady()) {
        return;
    }
    final NativeDaemonEvent event;
    try {
        event = mCryptConnector.execute("cryptfs", "clearpw");
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#end_block

#method_before
@Override
public StorageVolume[] getVolumeList(int uid, String packageName, int flags) {
    final boolean forWrite = (flags & StorageManager.FLAG_FOR_WRITE) != 0;
    final ArrayList<StorageVolume> res = new ArrayList<>();
    boolean foundPrimary = false;
    final int userId = UserHandle.getUserId(uid);
    final boolean reportUnmounted;
    final long identity = Binder.clearCallingIdentity();
    try {
        reportUnmounted = !mMountServiceInternal.hasExternalStorage(uid, packageName);
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
    synchronized (mLock) {
        for (int i = 0; i < mVolumes.size(); i++) {
            final VolumeInfo vol = mVolumes.valueAt(i);
            if (forWrite ? vol.isVisibleForWrite(userId) : vol.isVisibleForRead(userId)) {
                final StorageVolume userVol = vol.buildStorageVolume(mContext, userId, reportUnmounted);
                if (vol.isPrimary()) {
                    res.add(0, userVol);
                    foundPrimary = true;
                } else {
                    res.add(userVol);
                }
            }
        }
    }
    if (!foundPrimary) {
        Log.w(TAG, "No primary storage defined yet; hacking together a stub");
        final boolean primaryPhysical = SystemProperties.getBoolean(StorageManager.PROP_PRIMARY_PHYSICAL, false);
        final String id = "stub_primary";
        final File path = Environment.getLegacyExternalStorageDirectory();
        final String description = mContext.getString(android.R.string.unknownName);
        final boolean primary = true;
        final boolean removable = primaryPhysical;
        final boolean emulated = !primaryPhysical;
        final long mtpReserveSize = 0L;
        final boolean allowMassStorage = false;
        final long maxFileSize = 0L;
        final UserHandle owner = new UserHandle(userId);
        final String uuid = null;
        final String state = Environment.MEDIA_REMOVED;
        res.add(0, new StorageVolume(id, StorageVolume.STORAGE_ID_INVALID, path, description, primary, removable, emulated, mtpReserveSize, allowMassStorage, maxFileSize, owner, uuid, state));
    }
    return res.toArray(new StorageVolume[res.size()]);
}
#method_after
@Override
public StorageVolume[] getVolumeList(int uid, String packageName, int flags) {
    final int userId = UserHandle.getUserId(uid);
    final boolean forWrite = (flags & StorageManager.FLAG_FOR_WRITE) != 0;
    final boolean realState = (flags & StorageManager.FLAG_REAL_STATE) != 0;
    final boolean includeInvisible = (flags & StorageManager.FLAG_INCLUDE_INVISIBLE) != 0;
    final boolean userKeyUnlocked;
    final boolean storagePermission;
    final long token = Binder.clearCallingIdentity();
    try {
        userKeyUnlocked = isUserKeyUnlocked(userId);
        storagePermission = mMountServiceInternal.hasExternalStorage(uid, packageName);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    boolean foundPrimary = false;
    final ArrayList<StorageVolume> res = new ArrayList<>();
    synchronized (mLock) {
        for (int i = 0; i < mVolumes.size(); i++) {
            final VolumeInfo vol = mVolumes.valueAt(i);
            switch(vol.getType()) {
                case VolumeInfo.TYPE_PUBLIC:
                case VolumeInfo.TYPE_EMULATED:
                    break;
                default:
                    continue;
            }
            boolean match = false;
            if (forWrite) {
                match = vol.isVisibleForWrite(userId);
            } else {
                match = vol.isVisibleForRead(userId) || (includeInvisible && vol.getPath() != null);
            }
            if (!match)
                continue;
            boolean reportUnmounted = false;
            if ((vol.getType() == VolumeInfo.TYPE_EMULATED) && !userKeyUnlocked) {
                reportUnmounted = true;
            } else if (!storagePermission && !realState) {
                reportUnmounted = true;
            }
            final StorageVolume userVol = vol.buildStorageVolume(mContext, userId, reportUnmounted);
            if (vol.isPrimary()) {
                res.add(0, userVol);
                foundPrimary = true;
            } else {
                res.add(userVol);
            }
        }
    }
    if (!foundPrimary) {
        Log.w(TAG, "No primary storage defined yet; hacking together a stub");
        final boolean primaryPhysical = SystemProperties.getBoolean(StorageManager.PROP_PRIMARY_PHYSICAL, false);
        final String id = "stub_primary";
        final File path = Environment.getLegacyExternalStorageDirectory();
        final String description = mContext.getString(android.R.string.unknownName);
        final boolean primary = true;
        final boolean removable = primaryPhysical;
        final boolean emulated = !primaryPhysical;
        final long mtpReserveSize = 0L;
        final boolean allowMassStorage = false;
        final long maxFileSize = 0L;
        final UserHandle owner = new UserHandle(userId);
        final String uuid = null;
        final String state = Environment.MEDIA_REMOVED;
        res.add(0, new StorageVolume(id, StorageVolume.STORAGE_ID_INVALID, path, description, primary, removable, emulated, mtpReserveSize, allowMassStorage, maxFileSize, owner, uuid, state));
    }
    return res.toArray(new StorageVolume[res.size()]);
}
#end_block

#method_before
private boolean connectToService() {
    if (DEBUG_OBB)
        Slog.i(TAG, "Trying to bind to DefaultContainerService");
    Intent service = new Intent().setComponent(DEFAULT_CONTAINER_COMPONENT);
    if (mContext.bindServiceAsUser(service, mDefContainerConn, Context.BIND_AUTO_CREATE, UserHandle.OWNER)) {
        mBound = true;
        return true;
    }
    return false;
}
#method_after
private boolean connectToService() {
    if (DEBUG_OBB)
        Slog.i(TAG, "Trying to bind to DefaultContainerService");
    Intent service = new Intent().setComponent(DEFAULT_CONTAINER_COMPONENT);
    if (mContext.bindServiceAsUser(service, mDefContainerConn, Context.BIND_AUTO_CREATE, UserHandle.SYSTEM)) {
        mBound = true;
        return true;
    }
    return false;
}
#end_block

#method_before
public void execute(ObbActionHandler handler) {
    try {
        if (DEBUG_OBB)
            Slog.i(TAG, "Starting to execute action: " + toString());
        mRetries++;
        if (mRetries > MAX_RETRIES) {
            Slog.w(TAG, "Failed to invoke remote methods on default container service. Giving up");
            mObbActionHandler.sendEmptyMessage(OBB_MCS_UNBIND);
            handleError();
            return;
        } else {
            handleExecute();
            if (DEBUG_OBB)
                Slog.i(TAG, "Posting install MCS_UNBIND");
            mObbActionHandler.sendEmptyMessage(OBB_MCS_UNBIND);
        }
    } catch (RemoteException e) {
        if (DEBUG_OBB)
            Slog.i(TAG, "Posting install MCS_RECONNECT");
        mObbActionHandler.sendEmptyMessage(OBB_MCS_RECONNECT);
    } catch (Exception e) {
        if (DEBUG_OBB)
            Slog.d(TAG, "Error handling OBB action", e);
        handleError();
        mObbActionHandler.sendEmptyMessage(OBB_MCS_UNBIND);
    }
}
#method_after
public void execute(ObbActionHandler handler) {
    try {
        if (DEBUG_OBB)
            Slog.i(TAG, "Starting to execute action: " + toString());
        mRetries++;
        if (mRetries > MAX_RETRIES) {
            Slog.w(TAG, "Failed to invoke remote methods on default container service. Giving up");
            mObbActionHandler.sendEmptyMessage(OBB_MCS_UNBIND);
            handleError();
        } else {
            handleExecute();
            if (DEBUG_OBB)
                Slog.i(TAG, "Posting install MCS_UNBIND");
            mObbActionHandler.sendEmptyMessage(OBB_MCS_UNBIND);
        }
    } catch (RemoteException e) {
        if (DEBUG_OBB)
            Slog.i(TAG, "Posting install MCS_RECONNECT");
        mObbActionHandler.sendEmptyMessage(OBB_MCS_RECONNECT);
    } catch (Exception e) {
        if (DEBUG_OBB)
            Slog.d(TAG, "Error handling OBB action", e);
        handleError();
        mObbActionHandler.sendEmptyMessage(OBB_MCS_UNBIND);
    }
}
#end_block

#method_before
protected ObbInfo getObbInfo() throws IOException {
    ObbInfo obbInfo;
    try {
        obbInfo = mContainerService.getObbInfo(mObbState.ownerPath);
    } catch (RemoteException e) {
        Slog.d(TAG, "Couldn't call DefaultContainerService to fetch OBB info for " + mObbState.ownerPath);
        obbInfo = null;
    }
    if (obbInfo == null) {
        throw new IOException("Couldn't read OBB file: " + mObbState.ownerPath);
    }
    return obbInfo;
}
#method_after
protected ObbInfo getObbInfo() throws IOException {
    ObbInfo obbInfo;
    try {
        obbInfo = mContainerService.getObbInfo(mObbState.canonicalPath);
    } catch (RemoteException e) {
        Slog.d(TAG, "Couldn't call DefaultContainerService to fetch OBB info for " + mObbState.canonicalPath);
        obbInfo = null;
    }
    if (obbInfo == null) {
        throw new IOException("Couldn't read OBB file: " + mObbState.canonicalPath);
    }
    return obbInfo;
}
#end_block

#method_before
@Override
public void handleExecute() throws IOException, RemoteException {
    waitForReady();
    warnOnNotMounted();
    final ObbInfo obbInfo = getObbInfo();
    if (!isUidOwnerOfPackageOrSystem(obbInfo.packageName, mCallingUid)) {
        Slog.w(TAG, "Denied attempt to mount OBB " + obbInfo.filename + " which is owned by " + obbInfo.packageName);
        sendNewStatusOrIgnore(OnObbStateChangeListener.ERROR_PERMISSION_DENIED);
        return;
    }
    final boolean isMounted;
    synchronized (mObbMounts) {
        isMounted = mObbPathToStateMap.containsKey(mObbState.rawPath);
    }
    if (isMounted) {
        Slog.w(TAG, "Attempt to mount OBB which is already mounted: " + obbInfo.filename);
        sendNewStatusOrIgnore(OnObbStateChangeListener.ERROR_ALREADY_MOUNTED);
        return;
    }
    final String hashedKey;
    if (mKey == null) {
        hashedKey = "none";
    } else {
        try {
            SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1");
            KeySpec ks = new PBEKeySpec(mKey.toCharArray(), obbInfo.salt, PBKDF2_HASH_ROUNDS, CRYPTO_ALGORITHM_KEY_SIZE);
            SecretKey key = factory.generateSecret(ks);
            BigInteger bi = new BigInteger(key.getEncoded());
            hashedKey = bi.toString(16);
        } catch (NoSuchAlgorithmException e) {
            Slog.e(TAG, "Could not load PBKDF2 algorithm", e);
            sendNewStatusOrIgnore(OnObbStateChangeListener.ERROR_INTERNAL);
            return;
        } catch (InvalidKeySpecException e) {
            Slog.e(TAG, "Invalid key spec when loading PBKDF2 algorithm", e);
            sendNewStatusOrIgnore(OnObbStateChangeListener.ERROR_INTERNAL);
            return;
        }
    }
    int rc = StorageResultCode.OperationSucceeded;
    try {
        mConnector.execute("obb", "mount", mObbState.voldPath, new SensitiveArg(hashedKey), mObbState.ownerGid);
    } catch (NativeDaemonConnectorException e) {
        int code = e.getCode();
        if (code != VoldResponseCode.OpFailedStorageBusy) {
            rc = StorageResultCode.OperationFailedInternalError;
        }
    }
    if (rc == StorageResultCode.OperationSucceeded) {
        if (DEBUG_OBB)
            Slog.d(TAG, "Successfully mounted OBB " + mObbState.voldPath);
        synchronized (mObbMounts) {
            addObbStateLocked(mObbState);
        }
        sendNewStatusOrIgnore(OnObbStateChangeListener.MOUNTED);
    } else {
        Slog.e(TAG, "Couldn't mount OBB file: " + rc);
        sendNewStatusOrIgnore(OnObbStateChangeListener.ERROR_COULD_NOT_MOUNT);
    }
}
#method_after
@Override
public void handleExecute() throws IOException, RemoteException {
    waitForReady();
    warnOnNotMounted();
    final ObbInfo obbInfo = getObbInfo();
    if (!isUidOwnerOfPackageOrSystem(obbInfo.packageName, mCallingUid)) {
        Slog.w(TAG, "Denied attempt to mount OBB " + obbInfo.filename + " which is owned by " + obbInfo.packageName);
        sendNewStatusOrIgnore(OnObbStateChangeListener.ERROR_PERMISSION_DENIED);
        return;
    }
    final boolean isMounted;
    synchronized (mObbMounts) {
        isMounted = mObbPathToStateMap.containsKey(mObbState.rawPath);
    }
    if (isMounted) {
        Slog.w(TAG, "Attempt to mount OBB which is already mounted: " + obbInfo.filename);
        sendNewStatusOrIgnore(OnObbStateChangeListener.ERROR_ALREADY_MOUNTED);
        return;
    }
    final String hashedKey;
    if (mKey == null) {
        hashedKey = "none";
    } else {
        try {
            SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1");
            KeySpec ks = new PBEKeySpec(mKey.toCharArray(), obbInfo.salt, PBKDF2_HASH_ROUNDS, CRYPTO_ALGORITHM_KEY_SIZE);
            SecretKey key = factory.generateSecret(ks);
            BigInteger bi = new BigInteger(key.getEncoded());
            hashedKey = bi.toString(16);
        } catch (NoSuchAlgorithmException e) {
            Slog.e(TAG, "Could not load PBKDF2 algorithm", e);
            sendNewStatusOrIgnore(OnObbStateChangeListener.ERROR_INTERNAL);
            return;
        } catch (InvalidKeySpecException e) {
            Slog.e(TAG, "Invalid key spec when loading PBKDF2 algorithm", e);
            sendNewStatusOrIgnore(OnObbStateChangeListener.ERROR_INTERNAL);
            return;
        }
    }
    int rc = StorageResultCode.OperationSucceeded;
    try {
        mConnector.execute("obb", "mount", mObbState.canonicalPath, new SensitiveArg(hashedKey), mObbState.ownerGid);
    } catch (NativeDaemonConnectorException e) {
        int code = e.getCode();
        if (code != VoldResponseCode.OpFailedStorageBusy) {
            rc = StorageResultCode.OperationFailedInternalError;
        }
    }
    if (rc == StorageResultCode.OperationSucceeded) {
        if (DEBUG_OBB)
            Slog.d(TAG, "Successfully mounted OBB " + mObbState.canonicalPath);
        synchronized (mObbMounts) {
            addObbStateLocked(mObbState);
        }
        sendNewStatusOrIgnore(OnObbStateChangeListener.MOUNTED);
    } else {
        Slog.e(TAG, "Couldn't mount OBB file: " + rc);
        sendNewStatusOrIgnore(OnObbStateChangeListener.ERROR_COULD_NOT_MOUNT);
    }
}
#end_block

#method_before
@Override
public void handleExecute() throws IOException {
    waitForReady();
    warnOnNotMounted();
    final ObbInfo obbInfo = getObbInfo();
    final ObbState existingState;
    synchronized (mObbMounts) {
        existingState = mObbPathToStateMap.get(mObbState.rawPath);
    }
    if (existingState == null) {
        sendNewStatusOrIgnore(OnObbStateChangeListener.ERROR_NOT_MOUNTED);
        return;
    }
    if (existingState.ownerGid != mObbState.ownerGid) {
        Slog.w(TAG, "Permission denied attempting to unmount OBB " + existingState.rawPath + " (owned by GID " + existingState.ownerGid + ")");
        sendNewStatusOrIgnore(OnObbStateChangeListener.ERROR_PERMISSION_DENIED);
        return;
    }
    int rc = StorageResultCode.OperationSucceeded;
    try {
        final Command cmd = new Command("obb", "unmount", mObbState.voldPath);
        if (mForceUnmount) {
            cmd.appendArg("force");
        }
        mConnector.execute(cmd);
    } catch (NativeDaemonConnectorException e) {
        int code = e.getCode();
        if (code == VoldResponseCode.OpFailedStorageBusy) {
            rc = StorageResultCode.OperationFailedStorageBusy;
        } else if (code == VoldResponseCode.OpFailedStorageNotFound) {
            // If it's not mounted then we've already won.
            rc = StorageResultCode.OperationSucceeded;
        } else {
            rc = StorageResultCode.OperationFailedInternalError;
        }
    }
    if (rc == StorageResultCode.OperationSucceeded) {
        synchronized (mObbMounts) {
            removeObbStateLocked(existingState);
        }
        sendNewStatusOrIgnore(OnObbStateChangeListener.UNMOUNTED);
    } else {
        Slog.w(TAG, "Could not unmount OBB: " + existingState);
        sendNewStatusOrIgnore(OnObbStateChangeListener.ERROR_COULD_NOT_UNMOUNT);
    }
}
#method_after
@Override
public void handleExecute() throws IOException {
    waitForReady();
    warnOnNotMounted();
    final ObbState existingState;
    synchronized (mObbMounts) {
        existingState = mObbPathToStateMap.get(mObbState.rawPath);
    }
    if (existingState == null) {
        sendNewStatusOrIgnore(OnObbStateChangeListener.ERROR_NOT_MOUNTED);
        return;
    }
    if (existingState.ownerGid != mObbState.ownerGid) {
        Slog.w(TAG, "Permission denied attempting to unmount OBB " + existingState.rawPath + " (owned by GID " + existingState.ownerGid + ")");
        sendNewStatusOrIgnore(OnObbStateChangeListener.ERROR_PERMISSION_DENIED);
        return;
    }
    int rc = StorageResultCode.OperationSucceeded;
    try {
        final Command cmd = new Command("obb", "unmount", mObbState.canonicalPath);
        if (mForceUnmount) {
            cmd.appendArg("force");
        }
        mConnector.execute(cmd);
    } catch (NativeDaemonConnectorException e) {
        int code = e.getCode();
        if (code == VoldResponseCode.OpFailedStorageBusy) {
            rc = StorageResultCode.OperationFailedStorageBusy;
        } else if (code == VoldResponseCode.OpFailedStorageNotFound) {
            // If it's not mounted then we've already won.
            rc = StorageResultCode.OperationSucceeded;
        } else {
            rc = StorageResultCode.OperationFailedInternalError;
        }
    }
    if (rc == StorageResultCode.OperationSucceeded) {
        synchronized (mObbMounts) {
            removeObbStateLocked(existingState);
        }
        sendNewStatusOrIgnore(OnObbStateChangeListener.UNMOUNTED);
    } else {
        Slog.w(TAG, "Could not unmount OBB: " + existingState);
        sendNewStatusOrIgnore(OnObbStateChangeListener.ERROR_COULD_NOT_UNMOUNT);
    }
}
#end_block

#method_before
@Override
protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.DUMP, TAG);
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ", 160);
    synchronized (mLock) {
        pw.println("Disks:");
        pw.increaseIndent();
        for (int i = 0; i < mDisks.size(); i++) {
            final DiskInfo disk = mDisks.valueAt(i);
            disk.dump(pw);
        }
        pw.decreaseIndent();
        pw.println();
        pw.println("Volumes:");
        pw.increaseIndent();
        for (int i = 0; i < mVolumes.size(); i++) {
            final VolumeInfo vol = mVolumes.valueAt(i);
            if (VolumeInfo.ID_PRIVATE_INTERNAL.equals(vol.id))
                continue;
            vol.dump(pw);
        }
        pw.decreaseIndent();
        pw.println();
        pw.println("Records:");
        pw.increaseIndent();
        for (int i = 0; i < mRecords.size(); i++) {
            final VolumeRecord note = mRecords.valueAt(i);
            note.dump(pw);
        }
        pw.decreaseIndent();
        pw.println();
        pw.println("Primary storage UUID: " + mPrimaryStorageUuid);
        pw.println("Force adoptable: " + mForceAdoptable);
    }
    synchronized (mObbMounts) {
        pw.println();
        pw.println("mObbMounts:");
        pw.increaseIndent();
        final Iterator<Entry<IBinder, List<ObbState>>> binders = mObbMounts.entrySet().iterator();
        while (binders.hasNext()) {
            Entry<IBinder, List<ObbState>> e = binders.next();
            pw.println(e.getKey() + ":");
            pw.increaseIndent();
            final List<ObbState> obbStates = e.getValue();
            for (final ObbState obbState : obbStates) {
                pw.println(obbState);
            }
            pw.decreaseIndent();
        }
        pw.decreaseIndent();
        pw.println();
        pw.println("mObbPathToStateMap:");
        pw.increaseIndent();
        final Iterator<Entry<String, ObbState>> maps = mObbPathToStateMap.entrySet().iterator();
        while (maps.hasNext()) {
            final Entry<String, ObbState> e = maps.next();
            pw.print(e.getKey());
            pw.print(" -> ");
            pw.println(e.getValue());
        }
        pw.decreaseIndent();
    }
    pw.println();
    pw.println("mConnection:");
    pw.increaseIndent();
    mConnector.dump(fd, pw, args);
    pw.decreaseIndent();
    pw.println();
    pw.print("Last maintenance: ");
    pw.println(TimeUtils.formatForLogging(mLastMaintenance));
}
#method_after
@Override
protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.DUMP, TAG);
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ", 160);
    synchronized (mLock) {
        pw.println("Disks:");
        pw.increaseIndent();
        for (int i = 0; i < mDisks.size(); i++) {
            final DiskInfo disk = mDisks.valueAt(i);
            disk.dump(pw);
        }
        pw.decreaseIndent();
        pw.println();
        pw.println("Volumes:");
        pw.increaseIndent();
        for (int i = 0; i < mVolumes.size(); i++) {
            final VolumeInfo vol = mVolumes.valueAt(i);
            if (VolumeInfo.ID_PRIVATE_INTERNAL.equals(vol.id))
                continue;
            vol.dump(pw);
        }
        pw.decreaseIndent();
        pw.println();
        pw.println("Records:");
        pw.increaseIndent();
        for (int i = 0; i < mRecords.size(); i++) {
            final VolumeRecord note = mRecords.valueAt(i);
            note.dump(pw);
        }
        pw.decreaseIndent();
        pw.println();
        pw.println("Primary storage UUID: " + mPrimaryStorageUuid);
        pw.println("Force adoptable: " + mForceAdoptable);
        pw.println();
        pw.println("Local unlocked users: " + Arrays.toString(mLocalUnlockedUsers));
        pw.println("System unlocked users: " + Arrays.toString(mSystemUnlockedUsers));
    }
    synchronized (mObbMounts) {
        pw.println();
        pw.println("mObbMounts:");
        pw.increaseIndent();
        final Iterator<Entry<IBinder, List<ObbState>>> binders = mObbMounts.entrySet().iterator();
        while (binders.hasNext()) {
            Entry<IBinder, List<ObbState>> e = binders.next();
            pw.println(e.getKey() + ":");
            pw.increaseIndent();
            final List<ObbState> obbStates = e.getValue();
            for (final ObbState obbState : obbStates) {
                pw.println(obbState);
            }
            pw.decreaseIndent();
        }
        pw.decreaseIndent();
        pw.println();
        pw.println("mObbPathToStateMap:");
        pw.increaseIndent();
        final Iterator<Entry<String, ObbState>> maps = mObbPathToStateMap.entrySet().iterator();
        while (maps.hasNext()) {
            final Entry<String, ObbState> e = maps.next();
            pw.print(e.getKey());
            pw.print(" -> ");
            pw.println(e.getValue());
        }
        pw.decreaseIndent();
    }
    pw.println();
    pw.println("mConnector:");
    pw.increaseIndent();
    mConnector.dump(fd, pw, args);
    pw.decreaseIndent();
    pw.println();
    pw.println("mCryptConnector:");
    pw.increaseIndent();
    mCryptConnector.dump(fd, pw, args);
    pw.decreaseIndent();
    pw.println();
    pw.print("Last maintenance: ");
    pw.println(TimeUtils.formatForLogging(mLastMaintenance));
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config = null;
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_UNWANTED_NETWORK:
            if (message.arg1 == NETWORK_STATUS_UNWANTED_DISCONNECT) {
                mWifiNative.disconnect();
                transitionTo(mDisconnectingState);
            } else if (message.arg1 == NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN || message.arg1 == NETWORK_STATUS_UNWANTED_VALIDATION_FAILED) {
                Log.d(TAG, (message.arg1 == NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN ? "NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN" : "NETWORK_STATUS_UNWANTED_VALIDATION_FAILED"));
                config = getCurrentWifiConfiguration();
                if (config != null) {
                    // Disable autojoin
                    if (message.arg1 == NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN) {
                        mWifiConfigManager.setNetworkValidatedInternetAccess(config.networkId, false);
                        mWifiConfigManager.updateNetworkSelectionStatus(config.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_NO_INTERNET);
                    }
                    mWifiConfigManager.incrementNetworkNoInternetAccessReports(config.networkId);
                }
            }
            return HANDLED;
        case CMD_NETWORK_STATUS:
            if (message.arg1 == NetworkAgent.VALID_NETWORK) {
                config = getCurrentWifiConfiguration();
                if (config != null) {
                    // re-enable autojoin
                    mWifiConfigManager.setNetworkValidatedInternetAccess(config.networkId, true);
                }
            }
            return HANDLED;
        case CMD_ACCEPT_UNVALIDATED:
            boolean accept = (message.arg1 != 0);
            mWifiConfigManager.setNetworkNoInternetAccessExpected(mLastNetworkId, accept);
            return HANDLED;
        case CMD_TEST_NETWORK_DISCONNECT:
            // Force a disconnect
            if (message.arg1 == testNetworkDisconnectCounter) {
                mWifiNative.disconnect();
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // ASSOCIATING to a new BSSID while already connected, indicates
            // that driver is roaming
            mLastDriverRoamAttempt = mClock.getWallClockMillis();
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            long lastRoam = 0;
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_NETWORK_DISCONNECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            if (mLastDriverRoamAttempt != 0) {
                // Calculate time since last driver roam attempt
                lastRoam = mClock.getWallClockMillis() - mLastDriverRoamAttempt;
                mLastDriverRoamAttempt = 0;
            }
            if (unexpectedDisconnectedReason(message.arg2)) {
                mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_UNEXPECTED_DISCONNECT);
            }
            config = getCurrentWifiConfiguration();
            if (mEnableLinkDebouncing && mScreenOn && !isLinkDebouncing() && config != null && config.getNetworkSelectionStatus().isNetworkEnabled() && config.networkId != mWifiConfigManager.getLastSelectedNetwork() && (message.arg2 != 3 || /* reason cannot be 3, i.e. locally generated */
            (lastRoam > 0 && lastRoam < 2000)) && ((ScanResult.is24GHz(mWifiInfo.getFrequency()) && mWifiInfo.getRssi() > WifiQualifiedNetworkSelector.QUALIFIED_RSSI_24G_BAND) || (ScanResult.is5GHz(mWifiInfo.getFrequency()) && mWifiInfo.getRssi() > mThresholdQualifiedRssi5))) {
                // Start de-bouncing the L2 disconnection:
                // this L2 disconnection might be spurious.
                // Hence we allow 4 seconds for the state machine to try
                // to reconnect, go thru the
                // roaming cycle and enter Obtaining IP address
                // before signalling the disconnect to ConnectivityService and L3
                startScanForConfiguration(getCurrentWifiConfiguration());
                mIsLinkDebouncing = true;
                sendMessageDelayed(obtainMessage(CMD_DELAYED_NETWORK_DISCONNECT, 0, mLastNetworkId), LINK_FLAPPING_DEBOUNCE_MSEC);
                if (mVerboseLoggingEnabled) {
                    log("NETWORK_DISCONNECTION_EVENT in connected state" + " BSSID=" + mWifiInfo.getBSSID() + " RSSI=" + mWifiInfo.getRssi() + " freq=" + mWifiInfo.getFrequency() + " reason=" + message.arg2 + " -> debounce");
                }
                return HANDLED;
            } else {
                if (mVerboseLoggingEnabled) {
                    log("NETWORK_DISCONNECTION_EVENT in connected state" + " BSSID=" + mWifiInfo.getBSSID() + " RSSI=" + mWifiInfo.getRssi() + " freq=" + mWifiInfo.getFrequency() + " was debouncing=" + isLinkDebouncing() + " reason=" + message.arg2 + " Network Selection Status=" + (config == null ? "Unavailable" : config.getNetworkSelectionStatus().getNetworkStatusString()));
                }
            }
            break;
        case CMD_START_ROAM:
            // Clear the driver roam indication since we are attempting a framework roam
            mLastDriverRoamAttempt = 0;
            /* Connect command coming from auto-join */
            int netId = message.arg1;
            ScanResult candidate = (ScanResult) message.obj;
            String bssid = SUPPLICANT_BSSID_ANY;
            if (candidate != null) {
                bssid = candidate.BSSID;
            }
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            if (config == null) {
                loge("AUTO_CONNECT and no config, bail out...");
                break;
            }
            logd("CMD_START_ROAM sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " config " + config.configKey() + " roam=" + Integer.toString(message.arg2) + " to " + bssid + " targetRoamBSSID " + mTargetRoamBSSID);
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            mWifiMetrics.startConnectionEvent(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_ENTERPRISE);
            if (mWifiSupplicantControl.roamToNetwork(config)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = true;
                transitionTo(mRoamingState);
            } else {
                loge("CMD_START_ROAM Failed to start roaming to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                break;
            }
            break;
        case CMD_START_IP_PACKET_OFFLOAD:
            {
                int slot = message.arg1;
                int intervalSeconds = message.arg2;
                KeepalivePacketData pkt = (KeepalivePacketData) message.obj;
                byte[] dstMac;
                try {
                    InetAddress gateway = RouteInfo.selectBestRoute(mLinkProperties.getRoutes(), pkt.dstAddress).getGateway();
                    String dstMacStr = macAddressFromRoute(gateway.getHostAddress());
                    dstMac = macAddressFromString(dstMacStr);
                } catch (NullPointerException | IllegalArgumentException e) {
                    loge("Can't find MAC address for next hop to " + pkt.dstAddress);
                    mNetworkAgent.onPacketKeepaliveEvent(slot, ConnectivityManager.PacketKeepalive.ERROR_INVALID_IP_ADDRESS);
                    break;
                }
                pkt.dstMac = dstMac;
                int result = startWifiIPPacketOffload(slot, pkt, intervalSeconds);
                mNetworkAgent.onPacketKeepaliveEvent(slot, result);
                break;
            }
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config = null;
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_UNWANTED_NETWORK:
            if (message.arg1 == NETWORK_STATUS_UNWANTED_DISCONNECT) {
                mWifiNative.disconnect();
                transitionTo(mDisconnectingState);
            } else if (message.arg1 == NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN || message.arg1 == NETWORK_STATUS_UNWANTED_VALIDATION_FAILED) {
                Log.d(TAG, (message.arg1 == NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN ? "NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN" : "NETWORK_STATUS_UNWANTED_VALIDATION_FAILED"));
                config = getCurrentWifiConfiguration();
                if (config != null) {
                    // Disable autojoin
                    if (message.arg1 == NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN) {
                        mWifiConfigManager.setNetworkValidatedInternetAccess(config.networkId, false);
                        mWifiConfigManager.updateNetworkSelectionStatus(config.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_NO_INTERNET);
                    }
                    mWifiConfigManager.incrementNetworkNoInternetAccessReports(config.networkId);
                }
            }
            return HANDLED;
        case CMD_NETWORK_STATUS:
            if (message.arg1 == NetworkAgent.VALID_NETWORK) {
                config = getCurrentWifiConfiguration();
                if (config != null) {
                    // re-enable autojoin
                    mWifiConfigManager.setNetworkValidatedInternetAccess(config.networkId, true);
                }
            }
            return HANDLED;
        case CMD_ACCEPT_UNVALIDATED:
            boolean accept = (message.arg1 != 0);
            mWifiConfigManager.setNetworkNoInternetAccessExpected(mLastNetworkId, accept);
            return HANDLED;
        case CMD_TEST_NETWORK_DISCONNECT:
            // Force a disconnect
            if (message.arg1 == testNetworkDisconnectCounter) {
                mWifiNative.disconnect();
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // ASSOCIATING to a new BSSID while already connected, indicates
            // that driver is roaming
            mLastDriverRoamAttempt = mClock.getWallClockMillis();
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            long lastRoam = 0;
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_NETWORK_DISCONNECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            if (mLastDriverRoamAttempt != 0) {
                // Calculate time since last driver roam attempt
                lastRoam = mClock.getWallClockMillis() - mLastDriverRoamAttempt;
                mLastDriverRoamAttempt = 0;
            }
            if (unexpectedDisconnectedReason(message.arg2)) {
                mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_UNEXPECTED_DISCONNECT);
            }
            config = getCurrentWifiConfiguration();
            if (mEnableLinkDebouncing && mScreenOn && !isLinkDebouncing() && config != null && config.getNetworkSelectionStatus().isNetworkEnabled() && config.networkId != mWifiConfigManager.getLastSelectedNetwork() && (message.arg2 != 3 || /* reason cannot be 3, i.e. locally generated */
            (lastRoam > 0 && lastRoam < 2000)) && ((ScanResult.is24GHz(mWifiInfo.getFrequency()) && mWifiInfo.getRssi() > WifiQualifiedNetworkSelector.QUALIFIED_RSSI_24G_BAND) || (ScanResult.is5GHz(mWifiInfo.getFrequency()) && mWifiInfo.getRssi() > mThresholdQualifiedRssi5))) {
                // Start de-bouncing the L2 disconnection:
                // this L2 disconnection might be spurious.
                // Hence we allow 4 seconds for the state machine to try
                // to reconnect, go thru the
                // roaming cycle and enter Obtaining IP address
                // before signalling the disconnect to ConnectivityService and L3
                startScanForConfiguration(getCurrentWifiConfiguration());
                mIsLinkDebouncing = true;
                sendMessageDelayed(obtainMessage(CMD_DELAYED_NETWORK_DISCONNECT, 0, mLastNetworkId), LINK_FLAPPING_DEBOUNCE_MSEC);
                if (mVerboseLoggingEnabled) {
                    log("NETWORK_DISCONNECTION_EVENT in connected state" + " BSSID=" + mWifiInfo.getBSSID() + " RSSI=" + mWifiInfo.getRssi() + " freq=" + mWifiInfo.getFrequency() + " reason=" + message.arg2 + " -> debounce");
                }
                return HANDLED;
            } else {
                if (mVerboseLoggingEnabled) {
                    log("NETWORK_DISCONNECTION_EVENT in connected state" + " BSSID=" + mWifiInfo.getBSSID() + " RSSI=" + mWifiInfo.getRssi() + " freq=" + mWifiInfo.getFrequency() + " was debouncing=" + isLinkDebouncing() + " reason=" + message.arg2 + " Network Selection Status=" + (config == null ? "Unavailable" : config.getNetworkSelectionStatus().getNetworkStatusString()));
                }
            }
            break;
        case CMD_START_ROAM:
            // Clear the driver roam indication since we are attempting a framework roam
            mLastDriverRoamAttempt = 0;
            /* Connect command coming from auto-join */
            int netId = message.arg1;
            ScanResult candidate = (ScanResult) message.obj;
            String bssid = SUPPLICANT_BSSID_ANY;
            if (candidate != null) {
                bssid = candidate.BSSID;
            }
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            if (config == null) {
                loge("CMD_START_ROAM and no config, bail out...");
                break;
            }
            logd("CMD_START_ROAM sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " config " + config.configKey() + " roam=" + Integer.toString(message.arg2) + " to " + bssid + " targetRoamBSSID " + mTargetRoamBSSID);
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            mWifiMetrics.startConnectionEvent(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_ENTERPRISE);
            if (mWifiSupplicantControl.roamToNetwork(config)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = true;
                transitionTo(mRoamingState);
            } else {
                loge("CMD_START_ROAM Failed to start roaming to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                break;
            }
            break;
        case CMD_START_IP_PACKET_OFFLOAD:
            {
                int slot = message.arg1;
                int intervalSeconds = message.arg2;
                KeepalivePacketData pkt = (KeepalivePacketData) message.obj;
                byte[] dstMac;
                try {
                    InetAddress gateway = RouteInfo.selectBestRoute(mLinkProperties.getRoutes(), pkt.dstAddress).getGateway();
                    String dstMacStr = macAddressFromRoute(gateway.getHostAddress());
                    dstMac = macAddressFromString(dstMacStr);
                } catch (NullPointerException | IllegalArgumentException e) {
                    loge("Can't find MAC address for next hop to " + pkt.dstAddress);
                    mNetworkAgent.onPacketKeepaliveEvent(slot, ConnectivityManager.PacketKeepalive.ERROR_INVALID_IP_ADDRESS);
                    break;
                }
                pkt.dstMac = dstMac;
                int result = startWifiIPPacketOffload(slot, pkt, intervalSeconds);
                mNetworkAgent.onPacketKeepaliveEvent(slot, result);
                break;
            }
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
public static boolean openEditor(@NotNull Project project, @NotNull String path) {
    File file = new File(path);
    if (file.exists()) {
        VirtualFile vFile = VfsUtil.findFileByIoFile(file, true);
        if (vFile != null) {
            OpenFileDescriptor descriptor = new OpenFileDescriptor(project, vFile);
            return !FileEditorManager.getInstance(project).openEditor(descriptor, true).isEmpty();
        }
    }
    return false;
}
#method_after
public static boolean openEditor(@NotNull Project project, @NotNull VirtualFile vFile) {
    OpenFileDescriptor descriptor;
    if (vFile.getFileType() == StdFileTypes.XML) {
        // For XML files, ensure that we open the text editor rather than the default
        // editor for now, until the layout editor is fully done
        descriptor = new OpenFileDescriptor(project, vFile, 0);
    } else {
        descriptor = new OpenFileDescriptor(project, vFile);
    }
    return !FileEditorManager.getInstance(project).openEditor(descriptor, true).isEmpty();
}
#end_block

#method_before
@NotNull
private Map<String, Object> createParameterMap(@NotNull Map<String, Object> args) {
    // Create the data model.
    final Map<String, Object> paramMap = new HashMap<String, Object>();
    // Builtin conversion methods
    paramMap.put("slashedPackageName", new FmSlashedPackageNameMethod());
    paramMap.put("camelCaseToUnderscore", new FmCamelCaseToUnderscoreMethod());
    paramMap.put("underscoreToCamelCase", new FmUnderscoreToCamelCaseMethod());
    paramMap.put("activityToLayout", new FmActivityToLayoutMethod());
    paramMap.put("layoutToActivity", new FmLayoutToActivityMethod());
    paramMap.put("classToResource", new FmClassNameToResourceMethod());
    paramMap.put("escapeXmlAttribute", new FmEscapeXmlStringMethod());
    paramMap.put("escapeXmlText", new FmEscapeXmlStringMethod());
    paramMap.put("escapeXmlString", new FmEscapeXmlStringMethod());
    paramMap.put("extractLetters", new FmExtractLettersMethod());
    // This should be handled better: perhaps declared "required packages" as part of the
    // inputs? (It would be better if we could conditionally disable template based
    // on availability)
    Map<String, String> builtin = new HashMap<String, String>();
    builtin.put("templatesRes", VALUE_TEMPLATE_DIR);
    paramMap.put("android", builtin);
    // Wizard parameters supplied by user, specific to this template
    paramMap.putAll(args);
    return paramMap;
}
#method_after
@NotNull
private Map<String, Object> createParameterMap(@NotNull Map<String, Object> args) {
    // Create the data model.
    final Map<String, Object> paramMap = new HashMap<String, Object>();
    // Builtin conversion methods
    paramMap.put("slashedPackageName", new FmSlashedPackageNameMethod());
    paramMap.put("camelCaseToUnderscore", new FmCamelCaseToUnderscoreMethod());
    paramMap.put("underscoreToCamelCase", new FmUnderscoreToCamelCaseMethod());
    paramMap.put("activityToLayout", new FmActivityToLayoutMethod());
    paramMap.put("layoutToActivity", new FmLayoutToActivityMethod());
    paramMap.put("classToResource", new FmClassNameToResourceMethod());
    paramMap.put("escapeXmlAttribute", new FmEscapeXmlStringMethod());
    paramMap.put("escapeXmlText", new FmEscapeXmlStringMethod());
    paramMap.put("escapeXmlString", new FmEscapeXmlStringMethod());
    paramMap.put("extractLetters", new FmExtractLettersMethod());
    // Dependency list
    paramMap.put(TemplateMetadata.ATTR_DEPENDENCIES_LIST, new LinkedList<String>());
    // This should be handled better: perhaps declared "required packages" as part of the
    // inputs? (It would be better if we could conditionally disable template based
    // on availability)
    Map<String, String> builtin = new HashMap<String, String>();
    builtin.put("templatesRes", VALUE_TEMPLATE_DIR);
    paramMap.put("android", builtin);
    // Wizard parameters supplied by user, specific to this template
    paramMap.putAll(args);
    return paramMap;
}
#end_block

#method_before
private void processFile(@NotNull final Configuration freemarker, @NotNull String path, @NotNull final Map<String, Object> paramMap) {
    try {
        String xml;
        if (path.endsWith(DOT_XML)) {
            // Just read the file
            xml = readTextFile(getTemplateFile(path));
            if (xml == null) {
                return;
            }
        } else {
            myLoader.setTemplateFile(getTemplateFile(path));
            xml = processFreemarkerTemplate(freemarker, paramMap, path);
        }
        // Handle UTF-8 since processed file may contain file paths
        ByteArrayInputStream inputStream = new ByteArrayInputStream(xml.getBytes(Charsets.UTF_8.toString()));
        Reader reader = new InputStreamReader(inputStream, Charsets.UTF_8.toString());
        InputSource inputSource = new InputSource(reader);
        inputSource.setEncoding(Charsets.UTF_8.toString());
        SAXParserFactory.newInstance().newSAXParser().parse(inputSource, new DefaultHandler() {

            @Override
            public void startElement(String uri, String localName, String name, Attributes attributes) throws SAXException {
                if (TAG_PARAMETER.equals(name)) {
                    String id = attributes.getValue(ATTR_ID);
                    if (!paramMap.containsKey(id)) {
                        String value = attributes.getValue(ATTR_DEFAULT);
                        Object mapValue = value;
                        if (value != null && !value.isEmpty()) {
                            String type = attributes.getValue(ATTR_TYPE);
                            if ("boolean".equals(type)) {
                                mapValue = Boolean.valueOf(value);
                            }
                        }
                        paramMap.put(id, mapValue);
                    }
                } else if (TAG_GLOBAL.equals(name)) {
                    String id = attributes.getValue(ATTR_ID);
                    if (!paramMap.containsKey(id)) {
                        String value = attributes.getValue(ATTR_VALUE);
                        paramMap.put(id, value);
                    }
                } else if (TAG_GLOBALS.equals(name)) {
                    // Handle evaluation of variables
                    String path = attributes.getValue(ATTR_FILE);
                    if (path != null) {
                        processFile(freemarker, path, paramMap);
                    }
                // else: <globals> root element
                } else if (TAG_EXECUTE.equals(name)) {
                    String path = attributes.getValue(ATTR_FILE);
                    if (path != null) {
                        executeRecipeFile(freemarker, path, paramMap);
                    }
                } else if (TAG_DEPENDENCY.equals(name)) {
                    String dependencyName = attributes.getValue(ATTR_NAME);
                    String dependencyVersion = attributes.getValue(ATTR_VERSION);
                    int minApiLevel = (Integer) paramMap.get(TemplateMetadata.ATTR_MIN_API_LEVEL);
                    if (dependencyName.equals(SUPPORT_LIBRARY_NAME)) {
                        // We assume the revision requirement has been satisfied
                        // by the wizard
                        paramMap.put(TemplateMetadata.ATTR_ANDROID_SUPPORT_URL, getSupportMavenUrl(minApiLevel, dependencyVersion));
                    } else if (dependencyName.equals(APP_COMPAT_LIBRARY_NAME)) {
                        // API level 11 (Android 3.0) introduces action bar natively
                        if (minApiLevel <= 11) {
                            paramMap.put(TemplateMetadata.ATTR_APP_COMPAT_URL, getAppCompatMavenUrl(minApiLevel, dependencyVersion));
                        }
                    } else if (dependencyName.equals(GRID_LAYOUT_LIBRARY_NAME)) {
                        // API level 14 (ICS) introduces grid layout natively
                        if (minApiLevel <= 13) {
                            paramMap.put(TemplateMetadata.ATTR_GRID_LAYOUT_URL, getGridLayoutMavenUrl(minApiLevel, dependencyVersion));
                        }
                    }
                // TODO: Add other libraries here (Cloud SDK, Play Services, AppCompatLib, etc).
                } else if (!name.equals("template") && !name.equals("category") && !name.equals("option") && !name.equals(TAG_THUMBS) && !name.equals(TAG_THUMB) && !name.equals(TAG_ICONS)) {
                    LOG.error("WARNING: Unknown template directive " + name);
                }
            }
        });
    } catch (Exception e) {
        ourMostRecentException = e;
        LOG.warn(e);
    }
}
#method_after
private void processFile(@NotNull final Configuration freemarker, @NotNull String path, @NotNull final Map<String, Object> paramMap) {
    try {
        String xml;
        if (path.endsWith(DOT_XML)) {
            // Just read the file
            xml = readTextFile(getTemplateFile(path));
            if (xml == null) {
                return;
            }
        } else {
            myLoader.setTemplateFile(getTemplateFile(path));
            xml = processFreemarkerTemplate(freemarker, paramMap, path);
        }
        // Handle UTF-8 since processed file may contain file paths
        ByteArrayInputStream inputStream = new ByteArrayInputStream(xml.getBytes(Charsets.UTF_8.toString()));
        Reader reader = new InputStreamReader(inputStream, Charsets.UTF_8.toString());
        InputSource inputSource = new InputSource(reader);
        inputSource.setEncoding(Charsets.UTF_8.toString());
        SAXParserFactory.newInstance().newSAXParser().parse(inputSource, new DefaultHandler() {

            @Override
            public void startElement(String uri, String localName, String name, Attributes attributes) throws SAXException {
                if (TAG_PARAMETER.equals(name)) {
                    String id = attributes.getValue(ATTR_ID);
                    if (!paramMap.containsKey(id)) {
                        String value = attributes.getValue(ATTR_DEFAULT);
                        Object mapValue = value;
                        if (value != null && !value.isEmpty()) {
                            String type = attributes.getValue(ATTR_TYPE);
                            if ("boolean".equals(type)) {
                                mapValue = Boolean.valueOf(value);
                            }
                        }
                        paramMap.put(id, mapValue);
                    }
                } else if (TAG_GLOBAL.equals(name)) {
                    String id = attributes.getValue(ATTR_ID);
                    if (!paramMap.containsKey(id)) {
                        String value = attributes.getValue(ATTR_VALUE);
                        paramMap.put(id, value);
                    }
                } else if (TAG_GLOBALS.equals(name)) {
                    // Handle evaluation of variables
                    String path = attributes.getValue(ATTR_FILE);
                    if (path != null) {
                        processFile(freemarker, path, paramMap);
                    }
                // else: <globals> root element
                } else if (TAG_EXECUTE.equals(name)) {
                    String path = attributes.getValue(ATTR_FILE);
                    if (path != null) {
                        executeRecipeFile(freemarker, path, paramMap);
                    }
                } else if (TAG_DEPENDENCY.equals(name)) {
                    String dependencyName = attributes.getValue(ATTR_NAME);
                    String dependencyVersion = attributes.getValue(ATTR_VERSION);
                    List<String> dependencyList = (List<String>) paramMap.get(TemplateMetadata.ATTR_DEPENDENCIES_LIST);
                    if (dependencyName.equals(SUPPORT_ID) || dependencyName.equals(APP_COMPAT_ID) || dependencyName.equals(GRID_LAYOUT_ID)) {
                        dependencyList.add(getLibraryUrl(dependencyName, dependencyVersion));
                    }
                // TODO: Add other libraries here (Cloud SDK, Play Services, YouTube, AdMob, etc).
                } else if (!name.equals("template") && !name.equals("category") && !name.equals("option") && !name.equals(TAG_THUMBS) && !name.equals(TAG_THUMB) && !name.equals(TAG_ICONS)) {
                    LOG.error("WARNING: Unknown template directive " + name);
                }
            }
        });
    } catch (Exception e) {
        ourMostRecentException = e;
        LOG.warn(e);
    }
}
#end_block

#method_before
public void updateParameters() {
    // Support Library
    if ((get(ATTR_FRAGMENTS_EXTRA) != null && Boolean.parseBoolean(get(ATTR_FRAGMENTS_EXTRA).toString())) || (get(ATTR_NAVIGATION_DRAWER_EXTRA) != null && Boolean.parseBoolean(get(ATTR_NAVIGATION_DRAWER_EXTRA).toString()))) {
        put(ATTR_ANDROID_SUPPORT_URL, RepositoryUrls.getSupportMavenUrl(-1, null));
    } else {
        put(ATTR_ANDROID_SUPPORT_URL, null);
    }
    // AppCompat Library
    if (get(ATTR_ACTION_BAR_EXTRA) != null && Boolean.parseBoolean(get(ATTR_ACTION_BAR_EXTRA).toString())) {
        put(ATTR_APP_COMPAT_URL, RepositoryUrls.getAppCompatMavenUrl(-1, null));
    } else {
        put(ATTR_APP_COMPAT_URL, null);
    }
    // GridLayout Library
    if (get(ATTR_GRID_LAYOUT_EXTRA) != null && Boolean.parseBoolean(get(ATTR_GRID_LAYOUT_EXTRA).toString())) {
        put(ATTR_GRID_LAYOUT_URL, RepositoryUrls.getGridLayoutMavenUrl(-1, null));
    } else {
        put(ATTR_GRID_LAYOUT_URL, null);
    }
    put(ATTR_COPY_ICONS, !Boolean.parseBoolean(get(ATTR_CREATE_ICONS).toString()));
    copyParameters(myParameters, myActivityTemplateState.myParameters, ATTR_PACKAGE_NAME, ATTR_APP_TITLE, ATTR_MIN_API, ATTR_MIN_API_LEVEL, ATTR_TARGET_API, ATTR_BUILD_API, ATTR_COPY_ICONS, ATTR_IS_NEW_PROJECT, ATTR_IS_LAUNCHER, ATTR_CREATE_ACTIVITY, ATTR_CREATE_ICONS, ATTR_IS_GRADLE, ATTR_TOP_OUT, ATTR_PROJECT_OUT, ATTR_SRC_OUT, ATTR_RES_OUT, ATTR_MANIFEST_OUT);
    copyParameters(myParameters, myLauncherIconState.myParameters, ATTR_PACKAGE_NAME, ATTR_APP_TITLE, ATTR_MIN_API, ATTR_MIN_API_LEVEL, ATTR_TARGET_API, ATTR_BUILD_API, ATTR_COPY_ICONS, ATTR_IS_NEW_PROJECT, ATTR_IS_LAUNCHER, ATTR_CREATE_ACTIVITY, ATTR_CREATE_ICONS, ATTR_IS_GRADLE, ATTR_TOP_OUT, ATTR_PROJECT_OUT, ATTR_SRC_OUT, ATTR_RES_OUT, ATTR_MANIFEST_OUT);
}
#method_after
public void updateParameters() {
    put(ATTR_COPY_ICONS, !Boolean.parseBoolean(get(ATTR_CREATE_ICONS).toString()));
    copyParameters(myParameters, myActivityTemplateState.myParameters, ATTR_PACKAGE_NAME, ATTR_APP_TITLE, ATTR_MIN_API, ATTR_MIN_API_LEVEL, ATTR_TARGET_API, ATTR_BUILD_API, ATTR_COPY_ICONS, ATTR_IS_NEW_PROJECT, ATTR_IS_LAUNCHER, ATTR_CREATE_ACTIVITY, ATTR_CREATE_ICONS, ATTR_IS_GRADLE, ATTR_TOP_OUT, ATTR_PROJECT_OUT, ATTR_SRC_OUT, ATTR_RES_OUT, ATTR_MANIFEST_OUT);
    copyParameters(myParameters, myLauncherIconState.myParameters, ATTR_PACKAGE_NAME, ATTR_APP_TITLE, ATTR_MIN_API, ATTR_MIN_API_LEVEL, ATTR_TARGET_API, ATTR_BUILD_API, ATTR_COPY_ICONS, ATTR_IS_NEW_PROJECT, ATTR_IS_LAUNCHER, ATTR_CREATE_ACTIVITY, ATTR_CREATE_ICONS, ATTR_IS_GRADLE, ATTR_TOP_OUT, ATTR_PROJECT_OUT, ATTR_SRC_OUT, ATTR_RES_OUT, ATTR_MANIFEST_OUT);
}
#end_block

#method_before
private void broadcastPlayBackStateChanged(PlaybackState mState) {
    Intent intent = new Intent(BluetoothAvrcpController.ACTION_TRACK_EVENT);
    intent.putExtra(BluetoothAvrcpController.EXTRA_PLAYBACK, mState);
    if (DBG)
        Log.d(TAG, " broadcastPlayBackStateChanged = " + mState.toString());
    sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
}
#method_after
private void broadcastPlayBackStateChanged(PlaybackState state) {
    Intent intent = new Intent(BluetoothAvrcpController.ACTION_TRACK_EVENT);
    intent.putExtra(BluetoothAvrcpController.EXTRA_PLAYBACK, state);
    if (DBG)
        Log.d(TAG, " broadcastPlayBackStateChanged = " + state.toString());
    sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    Log.d(TAG, " HandleMessage: " + AvrcpControllerConstants.dumpMessageString(msg.what) + " Remote Connected " + !mConnectedDevices.isEmpty());
    switch(msg.what) {
        case AvrcpControllerConstants.MESSAGE_SEND_PASS_THROUGH_CMD:
            BluetoothDevice device = (BluetoothDevice) msg.obj;
            sendPassThroughCommandNative(getByteAddress(device), msg.arg1, msg.arg2);
            A2dpSinkService a2dpSnkService = A2dpSinkService.getA2dpSinkService();
            if ((a2dpSnkService != null) && (!mConnectedDevices.isEmpty())) {
                Log.d(TAG, " inform AVRCP Commands to A2DP Sink ");
                a2dpSnkService.informAvrcpPassThroughCmd(device, msg.arg1, msg.arg2);
            }
            break;
        case AvrcpControllerConstants.MESSAGE_SEND_GROUP_NAVIGATION_CMD:
            BluetoothDevice peerDevice = (BluetoothDevice) msg.obj;
            sendGroupNavigationCommandNative(getByteAddress(peerDevice), msg.arg1, msg.arg2);
            break;
        case AvrcpControllerConstants.MESSAGE_SEND_SET_CURRENT_PLAYER_APPLICATION_SETTINGS:
            byte numAttributes = (byte) msg.arg1;
            ByteBuffer bbRsp = (ByteBuffer) msg.obj;
            byte[] attributeIds = new byte[numAttributes];
            byte[] attributeVals = new byte[numAttributes];
            for (int i = 0; (bbRsp.hasRemaining()) && (i < numAttributes); i++) {
                attributeIds[i] = bbRsp.get();
                attributeVals[i] = bbRsp.get();
            }
            setPlayerApplicationSettingValuesNative(getByteAddress(mAvrcpRemoteDevice.mBTDevice), numAttributes, attributeIds, attributeVals);
            break;
        case AvrcpControllerConstants.MESSAGE_PROCESS_CONNECTION_CHANGE:
            int newState = msg.arg1;
            int oldState = msg.arg2;
            BluetoothDevice rtDevice = (BluetoothDevice) msg.obj;
            if ((newState == BluetoothProfile.STATE_CONNECTED) && (oldState == BluetoothProfile.STATE_DISCONNECTED)) {
                /* We create RemoteDevice and MediaPlayerList here
                     * Now playing list after RC features
                     */
                if (mAvrcpRemoteDevice == null) {
                    mAvrcpRemoteDevice = new RemoteDevice(rtDevice);
                    /* Remote will have a player irrespective of AVRCP Version
                         * Create a Default player, we will add entries in case Browsing
                         * is supported by remote
                         */
                    if (mRemoteMediaPlayers == null) {
                        mRemoteMediaPlayers = new RemoteMediaPlayers(mAvrcpRemoteDevice);
                        PlayerInfo mPlayer = new PlayerInfo();
                        mPlayer.mPlayerId = 0;
                        mRemoteMediaPlayers.addPlayer(mPlayer);
                        mRemoteMediaPlayers.setAddressedPlayer(mPlayer);
                    }
                }
            } else if ((newState == BluetoothProfile.STATE_DISCONNECTED) && (oldState == BluetoothProfile.STATE_CONNECTED)) /* connection down */
            {
                resetRemoteData();
                mHandler.removeCallbacksAndMessages(null);
            }
            /*
                 * Send intent now
                 */
            Intent intent = new Intent(BluetoothAvrcpController.ACTION_CONNECTION_STATE_CHANGED);
            intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, oldState);
            intent.putExtra(BluetoothProfile.EXTRA_STATE, newState);
            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, rtDevice);
            // intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
            sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
            break;
        case AvrcpControllerConstants.MESSAGE_PROCESS_RC_FEATURES:
            if (mAvrcpRemoteDevice == null)
                break;
            mAvrcpRemoteDevice.mRemoteFeatures = msg.arg1;
            /* in case of AVRCP version < 1.3, no need to add track info */
            if (mAvrcpRemoteDevice.isMetaDataSupported()) {
                if (mRemoteNowPlayingList == null)
                    mRemoteNowPlayingList = new NowPlaying(mAvrcpRemoteDevice);
                TrackInfo mTrack = new TrackInfo();
                /* First element of NowPlayingList will be current Track
                     * for 1.3 this will be the only song
                     * for >= 1.4, others songs will have non-zero UID
                     */
                mTrack.mItemUid = 0;
                mRemoteNowPlayingList.addTrack(mTrack);
                mRemoteNowPlayingList.setCurrTrack(mTrack);
            }
            break;
        case AvrcpControllerConstants.MESSAGE_PROCESS_SET_ABS_VOL_CMD:
            mAvrcpRemoteDevice.mAbsVolNotificationState = AvrcpControllerConstants.DEFER_VOLUME_CHANGE_RSP;
            setAbsVolume(msg.arg1, msg.arg2);
            break;
        case AvrcpControllerConstants.MESSAGE_PROCESS_REGISTER_ABS_VOL_NOTIFICATION:
            /* start BroadcastReceiver now */
            IntentFilter filter = new IntentFilter(AudioManager.VOLUME_CHANGED_ACTION);
            mAvrcpRemoteDevice.mNotificationLabel = msg.arg1;
            mAvrcpRemoteDevice.mAbsVolNotificationState = AvrcpControllerConstants.SEND_VOLUME_CHANGE_RSP;
            registerReceiver(mBroadcastReceiver, filter);
            int maxVolume = mAudioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC);
            int currIndex = mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC);
            int percentageVol = ((currIndex * AvrcpControllerConstants.ABS_VOL_BASE) / maxVolume);
            Log.d(TAG, " Sending Interim Response = " + percentageVol + " label " + msg.arg1);
            sendRegisterAbsVolRspNative(getByteAddress(mAvrcpRemoteDevice.mBTDevice), (byte) AvrcpControllerConstants.NOTIFICATION_RSP_TYPE_INTERIM, percentageVol, mAvrcpRemoteDevice.mNotificationLabel);
            break;
        case AvrcpControllerConstants.MESSAGE_PROCESS_TRACK_CHANGED:
            if (mRemoteNowPlayingList != null) {
                mRemoteNowPlayingList.updateCurrentTrack((TrackInfo) msg.obj);
                broadcastMetaDataChanged(AvrcpUtils.getMediaMetaData(mRemoteNowPlayingList.getCurrentTrack()));
            }
            break;
        case AvrcpControllerConstants.MESSAGE_PROCESS_PLAY_POS_CHANGED:
            if (mRemoteMediaPlayers != null) {
                mRemoteMediaPlayers.getAddressedPlayer().mPlayTime = msg.arg2;
                broadcastPlayBackStateChanged(AvrcpUtils.mapBtPlayStatustoPlayBackState(mRemoteMediaPlayers.getAddressedPlayer().mPlayStatus, mRemoteMediaPlayers.getAddressedPlayer().mPlayTime));
            }
            if (mRemoteNowPlayingList != null) {
                mRemoteNowPlayingList.getCurrentTrack().mTrackLen = msg.arg1;
            }
            break;
        case AvrcpControllerConstants.MESSAGE_PROCESS_PLAY_STATUS_CHANGED:
            if (mRemoteMediaPlayers != null) {
                mRemoteMediaPlayers.getAddressedPlayer().mPlayStatus = (byte) msg.arg1;
                broadcastPlayBackStateChanged(AvrcpUtils.mapBtPlayStatustoPlayBackState(mRemoteMediaPlayers.getAddressedPlayer().mPlayStatus, mRemoteMediaPlayers.getAddressedPlayer().mPlayTime));
                if (mRemoteMediaPlayers.getPlayStatus() == AvrcpControllerConstants.PLAY_STATUS_PLAYING) {
                    A2dpSinkService a2dpSinkService = A2dpSinkService.getA2dpSinkService();
                    if ((a2dpSinkService != null) && (!mConnectedDevices.isEmpty())) {
                        Log.d(TAG, " State = PLAYING, inform A2DP SINK");
                        a2dpSinkService.informAvrcpStatePlaying(mConnectedDevices.get(0));
                    }
                }
            }
            break;
        case AvrcpControllerConstants.MESSAGE_PROCESS_SUPPORTED_PLAYER_APP_SETTING:
            if (mRemoteMediaPlayers != null)
                mRemoteMediaPlayers.getAddressedPlayer().setSupportedPlayerAppSetting((ByteBuffer) msg.obj);
            break;
        case AvrcpControllerConstants.MESSAGE_PROCESS_PLAYER_APP_SETTING_CHANGED:
            if (mRemoteMediaPlayers != null) {
                mRemoteMediaPlayers.getAddressedPlayer().updatePlayerAppSetting((ByteBuffer) msg.obj);
                broadcastPlayerAppSettingChanged(getCurrentPlayerAppSetting());
            }
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    Log.d(TAG, " HandleMessage: " + AvrcpControllerConstants.dumpMessageString(msg.what) + " Remote Connected " + !mConnectedDevices.isEmpty());
    A2dpSinkService a2dpSinkService = A2dpSinkService.getA2dpSinkService();
    switch(msg.what) {
        case AvrcpControllerConstants.MESSAGE_STOP_METADATA_BROADCASTS:
            // Any messages hence forth about play pos/play status/song info will be ignored.
            if (mRemoteMediaPlayers != null) {
                // Mock the current state to *look like* it is paused. The remote play state is
                // still cached in mRemoteMediaPlayers and will be restored when the
                // startAvrcpUpdates is called again.
                broadcastPlayBackStateChanged(AvrcpUtils.mapBtPlayStatustoPlayBackState((byte) AvrcpControllerConstants.PLAY_STATUS_PAUSED, mRemoteMediaPlayers.getAddressedPlayer().mPlayTime));
            }
            mBroadcastMetadata = false;
            break;
        case AvrcpControllerConstants.MESSAGE_START_METADATA_BROADCASTS:
            // Any messages hence forth about play pos/play status/song info will be sent.
            if (mRemoteMediaPlayers != null) {
                broadcastPlayBackStateChanged(getCurrentPlayBackState());
                broadcastMetaDataChanged(getCurrentMetaData(AvrcpControllerConstants.AVRCP_SCOPE_NOW_PLAYING, 0));
            }
            mBroadcastMetadata = true;
            break;
        case AvrcpControllerConstants.MESSAGE_SEND_PASS_THROUGH_CMD:
            BluetoothDevice device = (BluetoothDevice) msg.obj;
            sendPassThroughCommandNative(getByteAddress(device), msg.arg1, msg.arg2);
            if ((a2dpSinkService != null) && (!mConnectedDevices.isEmpty())) {
                Log.d(TAG, " inform AVRCP Commands to A2DP Sink ");
                a2dpSinkService.informAvrcpPassThroughCmd(device, msg.arg1, msg.arg2);
            }
            break;
        case AvrcpControllerConstants.MESSAGE_SEND_GROUP_NAVIGATION_CMD:
            BluetoothDevice peerDevice = (BluetoothDevice) msg.obj;
            sendGroupNavigationCommandNative(getByteAddress(peerDevice), msg.arg1, msg.arg2);
            break;
        case AvrcpControllerConstants.MESSAGE_SEND_SET_CURRENT_PLAYER_APPLICATION_SETTINGS:
            byte numAttributes = (byte) msg.arg1;
            ByteBuffer bbRsp = (ByteBuffer) msg.obj;
            byte[] attributeIds = new byte[numAttributes];
            byte[] attributeVals = new byte[numAttributes];
            for (int i = 0; (bbRsp.hasRemaining()) && (i < numAttributes); i++) {
                attributeIds[i] = bbRsp.get();
                attributeVals[i] = bbRsp.get();
            }
            setPlayerApplicationSettingValuesNative(getByteAddress(mAvrcpRemoteDevice.mBTDevice), numAttributes, attributeIds, attributeVals);
            break;
        case AvrcpControllerConstants.MESSAGE_PROCESS_CONNECTION_CHANGE:
            int newState = msg.arg1;
            int oldState = msg.arg2;
            BluetoothDevice rtDevice = (BluetoothDevice) msg.obj;
            if ((newState == BluetoothProfile.STATE_CONNECTED) && (oldState == BluetoothProfile.STATE_DISCONNECTED)) {
                /* We create RemoteDevice and MediaPlayerList here
                     * Now playing list after RC features
                     */
                if (mAvrcpRemoteDevice == null) {
                    mAvrcpRemoteDevice = new RemoteDevice(rtDevice);
                    /* Remote will have a player irrespective of AVRCP Version
                         * Create a Default player, we will add entries in case Browsing
                         * is supported by remote
                         */
                    if (mRemoteMediaPlayers == null) {
                        mRemoteMediaPlayers = new RemoteMediaPlayers(mAvrcpRemoteDevice);
                        PlayerInfo mPlayer = new PlayerInfo();
                        mPlayer.mPlayerId = 0;
                        mRemoteMediaPlayers.addPlayer(mPlayer);
                        mRemoteMediaPlayers.setAddressedPlayer(mPlayer);
                    }
                }
            } else if ((newState == BluetoothProfile.STATE_DISCONNECTED) && (oldState == BluetoothProfile.STATE_CONNECTED)) /* connection down */
            {
                resetRemoteData();
                mHandler.removeCallbacksAndMessages(null);
            }
            /*
                 * Send intent now
                 */
            Intent intent = new Intent(BluetoothAvrcpController.ACTION_CONNECTION_STATE_CHANGED);
            intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, oldState);
            intent.putExtra(BluetoothProfile.EXTRA_STATE, newState);
            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, rtDevice);
            // intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
            sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
            break;
        case AvrcpControllerConstants.MESSAGE_PROCESS_RC_FEATURES:
            if (mAvrcpRemoteDevice == null)
                break;
            mAvrcpRemoteDevice.mRemoteFeatures = msg.arg1;
            /* in case of AVRCP version < 1.3, no need to add track info */
            if (mAvrcpRemoteDevice.isMetaDataSupported()) {
                if (mRemoteNowPlayingList == null)
                    mRemoteNowPlayingList = new NowPlaying(mAvrcpRemoteDevice);
                TrackInfo mTrack = new TrackInfo();
                /* First element of NowPlayingList will be current Track
                     * for 1.3 this will be the only song
                     * for >= 1.4, others songs will have non-zero UID
                     */
                mTrack.mItemUid = 0;
                mRemoteNowPlayingList.addTrack(mTrack);
                mRemoteNowPlayingList.setCurrTrack(mTrack);
            }
            break;
        case AvrcpControllerConstants.MESSAGE_PROCESS_SET_ABS_VOL_CMD:
            mAvrcpRemoteDevice.mAbsVolNotificationState = AvrcpControllerConstants.DEFER_VOLUME_CHANGE_RSP;
            setAbsVolume(msg.arg1, msg.arg2);
            break;
        case AvrcpControllerConstants.MESSAGE_PROCESS_REGISTER_ABS_VOL_NOTIFICATION:
            /* start BroadcastReceiver now */
            IntentFilter filter = new IntentFilter(AudioManager.VOLUME_CHANGED_ACTION);
            mAvrcpRemoteDevice.mNotificationLabel = msg.arg1;
            mAvrcpRemoteDevice.mAbsVolNotificationState = AvrcpControllerConstants.SEND_VOLUME_CHANGE_RSP;
            registerReceiver(mBroadcastReceiver, filter);
            int maxVolume = mAudioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC);
            int currIndex = mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC);
            int percentageVol = ((currIndex * AvrcpControllerConstants.ABS_VOL_BASE) / maxVolume);
            Log.d(TAG, " Sending Interim Response = " + percentageVol + " label " + msg.arg1);
            sendRegisterAbsVolRspNative(getByteAddress(mAvrcpRemoteDevice.mBTDevice), (byte) AvrcpControllerConstants.NOTIFICATION_RSP_TYPE_INTERIM, percentageVol, mAvrcpRemoteDevice.mNotificationLabel);
            break;
        case AvrcpControllerConstants.MESSAGE_PROCESS_TRACK_CHANGED:
            if (mRemoteNowPlayingList != null) {
                mRemoteNowPlayingList.updateCurrentTrack((TrackInfo) msg.obj);
                if (!mBroadcastMetadata) {
                    Log.d(TAG, "Metadata is not broadcasted, ignoring.");
                    return;
                }
                broadcastMetaDataChanged(AvrcpUtils.getMediaMetaData(mRemoteNowPlayingList.getCurrentTrack()));
            }
            break;
        case AvrcpControllerConstants.MESSAGE_PROCESS_PLAY_POS_CHANGED:
            if (mRemoteMediaPlayers != null) {
                mRemoteMediaPlayers.getAddressedPlayer().mPlayTime = msg.arg2;
                if (!mBroadcastMetadata) {
                    Log.d(TAG, "Metadata is not broadcasted, ignoring.");
                    return;
                }
                broadcastPlayBackStateChanged(AvrcpUtils.mapBtPlayStatustoPlayBackState(mRemoteMediaPlayers.getAddressedPlayer().mPlayStatus, mRemoteMediaPlayers.getAddressedPlayer().mPlayTime));
            }
            if (mRemoteNowPlayingList != null) {
                mRemoteNowPlayingList.getCurrentTrack().mTrackLen = msg.arg1;
            }
            break;
        case AvrcpControllerConstants.MESSAGE_PROCESS_PLAY_STATUS_CHANGED:
            if (mRemoteMediaPlayers != null) {
                int status = msg.arg1;
                mRemoteMediaPlayers.getAddressedPlayer().mPlayStatus = (byte) status;
                if (status == AvrcpControllerConstants.PLAY_STATUS_PLAYING) {
                    a2dpSinkService.informTGStatePlaying(mConnectedDevices.get(0), true);
                } else if (status == AvrcpControllerConstants.PLAY_STATUS_PAUSED || status == AvrcpControllerConstants.PLAY_STATUS_STOPPED) {
                    a2dpSinkService.informTGStatePlaying(mConnectedDevices.get(0), false);
                }
                if (mBroadcastMetadata) {
                    broadcastPlayBackStateChanged(AvrcpUtils.mapBtPlayStatustoPlayBackState(mRemoteMediaPlayers.getAddressedPlayer().mPlayStatus, mRemoteMediaPlayers.getAddressedPlayer().mPlayTime));
                } else {
                    Log.d(TAG, "Metadata is not broadcasted, ignoring.");
                    return;
                }
            }
            break;
        case AvrcpControllerConstants.MESSAGE_PROCESS_SUPPORTED_PLAYER_APP_SETTING:
            if (mRemoteMediaPlayers != null)
                mRemoteMediaPlayers.getAddressedPlayer().setSupportedPlayerAppSetting((ByteBuffer) msg.obj);
            break;
        case AvrcpControllerConstants.MESSAGE_PROCESS_PLAYER_APP_SETTING_CHANGED:
            if (mRemoteMediaPlayers != null) {
                mRemoteMediaPlayers.getAddressedPlayer().updatePlayerAppSetting((ByteBuffer) msg.obj);
                broadcastPlayerAppSettingChanged(getCurrentPlayerAppSetting());
            }
            break;
    }
}
#end_block

#method_before
void cleanup() {
    if (DEBUG)
        Log.v(TAG, "cleanup");
    mNowPlayingItems = null;
    mMediaInterface = null;
}
#method_after
void cleanup() {
    if (DEBUG)
        Log.v(TAG, "cleanup");
    mNowPlayingListManager = null;
    mMediaInterface = null;
}
#end_block

#method_before
synchronized void getFolderItemsNowPlaying(byte[] bdaddr, FolderItemsCmd reqObj, MediaController mediaController) {
    List<QueueItem> tempItems;
    if (DEBUG)
        Log.v(TAG, "getFolderItemsNowPlaying");
    if (mNowPlayingItems == null) {
        if (mediaController != null) {
            updateNowPlaying(mediaController.getQueue());
            if (mNowPlayingItems != null) {
                getFolderItemsFilterAttr(bdaddr, reqObj, mNowPlayingItems, AvrcpHalConstants.BTRC_SCOPE_NOW_PLAYING, reqObj.mStartItem, reqObj.mEndItem);
            } else {
                Log.w(TAG, "Received Now playing list is null from: " + mediaController.getPackageName() + ", sending internal error response");
                mMediaInterface.folderItemsRsp(bdaddr, AvrcpHalConstants.BTRC_STS_INTERNAL_ERR, null);
            }
        } else {
            Log.e(TAG, "mediaController = null" + ", sending internal error response");
            mMediaInterface.folderItemsRsp(bdaddr, AvrcpHalConstants.BTRC_STS_INTERNAL_ERR, null);
        }
    } else {
        if (DEBUG)
            Log.i(TAG, "sending cached now playing list");
        /* Filter attributes from cached NowPlayingList and send response */
        getFolderItemsFilterAttr(bdaddr, reqObj, mNowPlayingItems, AvrcpHalConstants.BTRC_SCOPE_FILE_SYSTEM, reqObj.mStartItem, reqObj.mEndItem);
    }
}
#method_after
void getFolderItemsNowPlaying(byte[] bdaddr, AvrcpCmd.FolderItemsCmd reqObj, MediaController mediaController) {
    List<QueueItem> tempItems;
    List<MediaSession.QueueItem> mNowPlayingItems = mNowPlayingListManager.getNowPlayingList();
    if (DEBUG)
        Log.v(TAG, "getFolderItemsNowPlaying");
    if (mNowPlayingItems != null) {
        // We already have the cached list sending the response to remote
        if (DEBUG)
            Log.i(TAG, "sending cached now playing list");
        /* Filter attributes from cached NowPlayingList and send response */
        getFolderItemsFilterAttr(bdaddr, reqObj, mNowPlayingItems, AvrcpConstants.BTRC_SCOPE_FILE_SYSTEM, reqObj.mStartItem, reqObj.mEndItem);
    } else if (mediaController == null) {
        Log.e(TAG, "mediaController = null, sending internal error response");
        mMediaInterface.folderItemsRsp(bdaddr, AvrcpConstants.RSP_INTERNAL_ERR, null);
    } else {
        // We don't have the cached list, fetching it from Media Controller
        mNowPlayingItems = mediaController.getQueue();
        if (mNowPlayingItems == null) {
            Log.w(TAG, "Received Now playing list is null from: " + mediaController.getPackageName() + ", sending internal error response");
            mMediaInterface.folderItemsRsp(bdaddr, AvrcpConstants.RSP_INTERNAL_ERR, null);
        } else {
            mNowPlayingListManager.setNowPlayingList(mNowPlayingItems);
            getFolderItemsFilterAttr(bdaddr, reqObj, mNowPlayingItems, AvrcpConstants.BTRC_SCOPE_NOW_PLAYING, reqObj.mStartItem, reqObj.mEndItem);
        }
    }
}
#end_block

#method_before
synchronized void getItemAttr(byte[] bdaddr, ItemAttrCmd itemAttr, MediaController mediaController) {
    int status = AvrcpHalConstants.BTRC_STS_NO_ERROR;
    int idx;
    long mediaID = ByteBuffer.wrap(itemAttr.mUid).getLong();
    /* checking if item attributes has been asked for now playing item or
         * some other item with specific media id */
    if (Arrays.equals(itemAttr.mUid, NOW_PLAYING_UID)) {
        if (DEBUG)
            Log.d(TAG, "getItemAttr: Remote requests for now playing contents:");
        // get the current playing song metadata and sending the queueitem.
        if (mediaController != null) {
            MediaMetadata metadata = mediaController.getMetadata();
            if (metadata != null) {
                getItemAttrFilterAttr(bdaddr, itemAttr, getQueueItem(metadata));
            } else {
                Log.e(TAG, "getItemAttr: metadata = null");
                status = AvrcpHalConstants.BTRC_STS_INTERNAL_ERR;
            }
        } else {
            Log.e(TAG, "getItemAttr: mediaController = null");
            status = AvrcpHalConstants.BTRC_STS_INTERNAL_ERR;
        }
    } else if (mNowPlayingItems != null) {
        if (DEBUG)
            printByteArray("getItemAttr-UID", itemAttr.mUid);
        for (idx = 0; idx < mNowPlayingItems.size(); idx++) {
            if (mediaID == mNowPlayingItems.get(idx).getQueueId()) {
                getItemAttrFilterAttr(bdaddr, itemAttr, mNowPlayingItems.get(idx));
                break;
            }
        }
        if (idx >= mNowPlayingItems.size()) {
            Log.e(TAG, "getItemAttr: idx is more than now playing list: idx = " + idx + ", now playing list size = " + mNowPlayingItems.size());
            status = AvrcpHalConstants.BTRC_STS_INV_ITEM;
        }
    } else {
        Log.e(TAG, "getItemAttr: mNowPlayingItems is null!");
        status = AvrcpHalConstants.BTRC_STS_INTERNAL_ERR;
    }
    // sending error status in case of error
    if (status != AvrcpHalConstants.BTRC_STS_NO_ERROR) {
        mMediaInterface.getItemAttrRsp(bdaddr, status, null);
    }
}
#method_after
void getItemAttr(byte[] bdaddr, AvrcpCmd.ItemAttrCmd itemAttr, MediaController mediaController) {
    int status = AvrcpConstants.RSP_NO_ERROR;
    int idx;
    long mediaID = ByteBuffer.wrap(itemAttr.mUid).getLong();
    List<MediaSession.QueueItem> mNowPlayingItems = mNowPlayingListManager.getNowPlayingList();
    /* checking if item attributes has been asked for now playing item or
         * some other item with specific media id */
    if (Arrays.equals(itemAttr.mUid, NOW_PLAYING_UID)) {
        if (DEBUG)
            Log.d(TAG, "getItemAttr: Remote requests for now playing contents:");
        // get the current playing song metadata and sending the queueitem.
        if (mediaController != null) {
            MediaMetadata metadata = mediaController.getMetadata();
            if (metadata != null) {
                getItemAttrFilterAttr(bdaddr, itemAttr, getQueueItem(metadata));
            } else {
                Log.e(TAG, "getItemAttr: metadata = null");
                status = AvrcpConstants.RSP_INTERNAL_ERR;
            }
        } else {
            Log.e(TAG, "getItemAttr: mediaController = null");
            status = AvrcpConstants.RSP_INTERNAL_ERR;
        }
    } else if (mNowPlayingItems != null) {
        if (DEBUG)
            printByteArray("getItemAttr-UID", itemAttr.mUid);
        for (idx = 0; idx < mNowPlayingItems.size(); idx++) {
            if (mediaID == mNowPlayingItems.get(idx).getQueueId()) {
                getItemAttrFilterAttr(bdaddr, itemAttr, mNowPlayingItems.get(idx));
                break;
            }
        }
        if (idx >= mNowPlayingItems.size()) {
            Log.e(TAG, "getItemAttr: idx is more than now playing list: idx = " + idx + ", now playing list size = " + mNowPlayingItems.size());
            status = AvrcpConstants.RSP_INV_ITEM;
        }
    } else {
        Log.e(TAG, "getItemAttr: mNowPlayingItems is null!");
        status = AvrcpConstants.RSP_INTERNAL_ERR;
    }
    // sending error status in case of error
    if (status != AvrcpConstants.RSP_NO_ERROR) {
        mMediaInterface.getItemAttrRsp(bdaddr, status, null);
    }
}
#end_block

#method_before
synchronized void playItem(byte[] bdaddr, byte[] uid, byte scope, MediaController mediaController) {
    long qid = ByteBuffer.wrap(uid).getLong();
    if (mediaController != null) {
        MediaController.TransportControls mediaControllerCntrl = mediaController.getTransportControls();
        if (DEBUG)
            Log.d(TAG, "Sending playID");
        if (scope == AvrcpHalConstants.BTRC_SCOPE_NOW_PLAYING) {
            int idx;
            /* find the queueId of the mediaId to play */
            if (mNowPlayingItems != null) {
                for (idx = 0; idx < mNowPlayingItems.size(); idx++) {
                    if (qid == mNowPlayingItems.get(idx).getQueueId()) {
                        mediaControllerCntrl.skipToQueueItem(qid);
                        break;
                    }
                }
                /* if mediaId is not found in nowplaying list */
                if (idx >= mNowPlayingItems.size()) {
                    Log.w(TAG, "item is not present in queue");
                    mMediaInterface.playItemRsp(bdaddr, AvrcpHalConstants.BTRC_STS_INV_ITEM);
                }
            } else {
                Log.w(TAG, "nowPlayingItems is null");
                mMediaInterface.playItemRsp(bdaddr, AvrcpHalConstants.BTRC_STS_INTERNAL_ERR);
            }
        }
        mMediaInterface.playItemRsp(bdaddr, AvrcpHalConstants.BTRC_STS_NO_ERROR);
    } else {
        Log.e(TAG, "mediaController is null");
        mMediaInterface.playItemRsp(bdaddr, AvrcpHalConstants.BTRC_STS_INTERNAL_ERR);
    }
}
#method_after
void playItem(byte[] bdaddr, byte[] uid, byte scope, MediaController mediaController) {
    long qid = ByteBuffer.wrap(uid).getLong();
    List<MediaSession.QueueItem> mNowPlayingItems = mNowPlayingListManager.getNowPlayingList();
    if (mediaController != null) {
        MediaController.TransportControls mediaControllerCntrl = mediaController.getTransportControls();
        if (DEBUG)
            Log.d(TAG, "Sending playID");
        if (scope == AvrcpConstants.BTRC_SCOPE_NOW_PLAYING) {
            int idx;
            /* find the queueId of the mediaId to play */
            if (mNowPlayingItems != null) {
                for (idx = 0; idx < mNowPlayingItems.size(); idx++) {
                    if (qid == mNowPlayingItems.get(idx).getQueueId()) {
                        mediaControllerCntrl.skipToQueueItem(qid);
                        break;
                    }
                }
                /* if mediaId is not found in nowplaying list */
                if (idx >= mNowPlayingItems.size()) {
                    Log.w(TAG, "item is not present in queue");
                    mMediaInterface.playItemRsp(bdaddr, AvrcpConstants.RSP_INV_ITEM);
                }
            } else {
                Log.w(TAG, "nowPlayingItems is null");
                mMediaInterface.playItemRsp(bdaddr, AvrcpConstants.RSP_INTERNAL_ERR);
            }
        }
        mMediaInterface.playItemRsp(bdaddr, AvrcpConstants.RSP_NO_ERROR);
    } else {
        Log.e(TAG, "mediaController is null");
        mMediaInterface.playItemRsp(bdaddr, AvrcpConstants.RSP_INTERNAL_ERR);
    }
}
#end_block

#method_before
synchronized void getTotalNumOfItems(byte[] bdaddr, byte scope, MediaController mediaController) {
    if (DEBUG)
        Log.d(TAG, "getTotalNumOfItems scope = " + scope);
    if (mNowPlayingItems != null) {
        mMediaInterface.getTotalNumOfItemsRsp(bdaddr, AvrcpHalConstants.BTRC_STS_NO_ERROR, 0, mNowPlayingItems.size());
    } else {
        if (mediaController != null) {
            mNowPlayingItems = mediaController.getQueue();
            if (mNowPlayingItems != null) {
                mMediaInterface.getTotalNumOfItemsRsp(bdaddr, AvrcpHalConstants.BTRC_STS_NO_ERROR, 0, mNowPlayingItems.size());
            } else {
                Log.e(TAG, "mNowPlayingItems is null");
                mMediaInterface.getTotalNumOfItemsRsp(bdaddr, AvrcpHalConstants.BTRC_STS_INV_ITEM, 0, 0);
            }
        } else {
            Log.e(TAG, "mediaController is null");
            mMediaInterface.getTotalNumOfItemsRsp(bdaddr, AvrcpHalConstants.BTRC_STS_INTERNAL_ERR, 0, 0);
        }
    }
}
#method_after
void getTotalNumOfItems(byte[] bdaddr, byte scope, MediaController mediaController) {
    if (DEBUG)
        Log.d(TAG, "getTotalNumOfItems scope = " + scope);
    List<MediaSession.QueueItem> mNowPlayingItems = mNowPlayingListManager.getNowPlayingList();
    if (mNowPlayingItems != null) {
        // We already have the cached list sending the response to remote
        mMediaInterface.getTotalNumOfItemsRsp(bdaddr, AvrcpConstants.RSP_NO_ERROR, 0, mNowPlayingItems.size());
    } else if (mediaController == null) {
        Log.e(TAG, "mediaController is null");
        mMediaInterface.getTotalNumOfItemsRsp(bdaddr, AvrcpConstants.RSP_INTERNAL_ERR, 0, 0);
    } else {
        // We don't have the cached list, fetching it from Media Controller
        mNowPlayingItems = mediaController.getQueue();
        if (mNowPlayingItems == null) {
            Log.e(TAG, "mNowPlayingItems is null");
            mMediaInterface.getTotalNumOfItemsRsp(bdaddr, AvrcpConstants.RSP_INV_ITEM, 0, 0);
        } else {
            mNowPlayingListManager.setNowPlayingList(mediaController.getQueue());
            mMediaInterface.getTotalNumOfItemsRsp(bdaddr, AvrcpConstants.RSP_NO_ERROR, 0, mNowPlayingItems.size());
        }
    }
}
#end_block

#method_before
synchronized void sendTrackChangeWithId(int trackChangedNT, long trackNumber, MediaController mediaController) {
    if (DEBUG)
        Log.d(TAG, "sendTrackChangeWithId");
    try {
        String mediaId = mediaController.getMetadata().getDescription().getMediaId();
        long qid = 0;
        /* traverse now playing list for current playing item */
        for (QueueItem qitem : mNowPlayingItems) {
            if (qitem.getDescription().getMediaId().equals(mediaId)) {
                qid = qitem.getQueueId();
                if (DEBUG)
                    Log.d(TAG, "sendTrackChangeWithId: Found matching qid= " + qid);
                break;
            }
        }
        /* for any item associated with NowPlaying, uid is queueId */
        byte[] uid = ByteBuffer.allocate(AvrcpHalConstants.UID_SIZE).putLong(qid).array();
        if (DEBUG)
            printByteArray("trackChangedRsp", uid);
        mMediaInterface.trackChangedRsp(trackChangedNT, uid);
    } catch (NullPointerException e) {
        Log.w(TAG, "Null Pointer while getting current track Uid from media player");
        sendTrackChangeRsp(trackChangedNT, trackNumber);
    }
}
#method_after
void sendTrackChangeWithId(int trackChangedNT, long trackNumber, MediaController mediaController) {
    if (DEBUG)
        Log.d(TAG, "sendTrackChangeWithId");
    try {
        String mediaId = mediaController.getMetadata().getDescription().getMediaId();
        long qid = 0;
        List<MediaSession.QueueItem> mNowPlayingItems = mNowPlayingListManager.getNowPlayingList();
        /* traverse now playing list for current playing item */
        for (QueueItem qitem : mNowPlayingItems) {
            if (qitem.getDescription().getMediaId().equals(mediaId)) {
                qid = qitem.getQueueId();
                if (DEBUG)
                    Log.d(TAG, "sendTrackChangeWithId: Found matching qid= " + qid);
                break;
            }
        }
        /* for any item associated with NowPlaying, uid is queueId */
        byte[] uid = ByteBuffer.allocate(AvrcpConstants.UID_SIZE).putLong(qid).array();
        if (DEBUG)
            printByteArray("trackChangedRsp", uid);
        mMediaInterface.trackChangedRsp(trackChangedNT, uid);
    } catch (NullPointerException e) {
        Log.w(TAG, "Null Pointer while getting current track Uid from media player");
        sendTrackChangeRsp(trackChangedNT, trackNumber);
    }
}
#end_block

#method_before
private void sendTrackChangeRsp(int trackChangedNT, long trackNumber) {
    byte[] track = new byte[AvrcpHalConstants.TRACK_ID_SIZE];
    /* track is stored in big endian format */
    for (int idx = 0; idx < AvrcpHalConstants.TRACK_ID_SIZE; ++idx) {
        if (trackChangedNT == AvrcpHalConstants.NOTIFICATION_TYPE_INTERIM && trackNumber == -1) {
            /* if no track is currently selected then return 0xFF in interim response */
            track[idx] = AvrcpHalConstants.NO_TRACK_SELECTED;
        } else {
            /* if Browsing is not supported and a track is selected, then return 0x00 */
            track[idx] = AvrcpHalConstants.TRACK_IS_SELECTED;
        }
    }
    if (DEBUG)
        printByteArray("sendTrackChangeRsp", track);
    mMediaInterface.trackChangedRsp(trackChangedNT, track);
}
#method_after
private void sendTrackChangeRsp(int trackChangedNT, long trackNumber) {
    byte[] track = new byte[AvrcpConstants.TRACK_ID_SIZE];
    /* track is stored in big endian format */
    for (int idx = 0; idx < AvrcpConstants.TRACK_ID_SIZE; ++idx) {
        if (trackChangedNT == AvrcpConstants.NOTIFICATION_TYPE_INTERIM && trackNumber == -1) {
            /* if no track is currently selected then return 0xFF in interim response */
            track[idx] = AvrcpConstants.NO_TRACK_SELECTED;
        } else {
            /* if Browsing is not supported and a track is selected, then return 0x00 */
            track[idx] = AvrcpConstants.TRACK_IS_SELECTED;
        }
    }
    if (DEBUG)
        printByteArray("sendTrackChangeRsp", track);
    mMediaInterface.trackChangedRsp(trackChangedNT, track);
}
#end_block

#method_before
private List<MediaSession.QueueItem> checkIndexOutofBounds(byte[] bdaddr, List<MediaSession.QueueItem> children, int startItem, int endItem) {
    try {
        List<MediaSession.QueueItem> childrenSubList = children.subList(startItem, Math.min(children.size(), endItem + 1));
        if (childrenSubList.isEmpty()) {
            Log.i(TAG, "childrenSubList is empty.");
            throw new IndexOutOfBoundsException();
        }
        return childrenSubList;
    } catch (IndexOutOfBoundsException ex) {
        Log.i(TAG, "Index out of bounds start item =" + startItem + " end item = " + Math.min(children.size(), endItem + 1));
        mMediaInterface.folderItemsRsp(bdaddr, AvrcpHalConstants.BTRC_STS_INV_RANGE, null);
        return null;
    } catch (IllegalArgumentException ex) {
        Log.i(TAG, "Index out of bounds start item =" + startItem + " > size");
        mMediaInterface.folderItemsRsp(bdaddr, AvrcpHalConstants.BTRC_STS_INV_RANGE, null);
        return null;
    }
}
#method_after
private List<MediaSession.QueueItem> checkIndexOutofBounds(byte[] bdaddr, List<MediaSession.QueueItem> children, int startItem, int endItem) {
    try {
        List<MediaSession.QueueItem> childrenSubList = children.subList(startItem, Math.min(children.size(), endItem + 1));
        if (childrenSubList.isEmpty()) {
            Log.i(TAG, "childrenSubList is empty.");
            throw new IndexOutOfBoundsException();
        }
        return childrenSubList;
    } catch (IndexOutOfBoundsException ex) {
        Log.i(TAG, "Index out of bounds start item =" + startItem + " end item = " + Math.min(children.size(), endItem + 1));
        mMediaInterface.folderItemsRsp(bdaddr, AvrcpConstants.RSP_INV_RANGE, null);
        return null;
    } catch (IllegalArgumentException ex) {
        Log.i(TAG, "Index out of bounds start item =" + startItem + " > size");
        mMediaInterface.folderItemsRsp(bdaddr, AvrcpConstants.RSP_INV_RANGE, null);
        return null;
    }
}
#end_block

#method_before
private void getFolderItemsFilterAttr(byte[] bdaddr, FolderItemsCmd mFolderItemsReqObj, List<MediaSession.QueueItem> children, byte scope, int startItem, int endItem) {
    if (DEBUG)
        Log.d(TAG, "getFolderItemsFilterAttr: startItem =" + startItem + ", endItem = " + endItem);
    List<MediaSession.QueueItem> result_items = new ArrayList<MediaSession.QueueItem>();
    if (children != null) {
        /* check for index out of bound errors */
        if ((result_items = checkIndexOutofBounds(bdaddr, children, startItem, endItem)) == null) {
            Log.w(TAG, "result_items is null.");
            mMediaInterface.folderItemsRsp(bdaddr, AvrcpHalConstants.BTRC_STS_INV_RANGE, null);
            return;
        }
        FolderItemsData folderDataNative = new FolderItemsData(result_items.size());
        /* variables to temperorily add attrs */
        ArrayList<String> attrArray = new ArrayList<String>();
        ArrayList<Integer> attrId = new ArrayList<Integer>();
        for (int itemIndex = 0; itemIndex < result_items.size(); itemIndex++) {
            // get the queue id
            long qid = result_items.get(itemIndex).getQueueId();
            byte[] uid = ByteBuffer.allocate(AvrcpHalConstants.UID_SIZE).putLong(qid).array();
            // get the array of uid from 2d to array 1D array
            for (int idx = 0; idx < AvrcpHalConstants.UID_SIZE; idx++) {
                folderDataNative.mItemUid[itemIndex * AvrcpHalConstants.UID_SIZE + idx] = uid[idx];
            }
            /* Set display name for current item */
            folderDataNative.mDisplayNames[itemIndex] = result_items.get(itemIndex).getDescription().getTitle().toString();
            int maxAttributesRequested = 0;
            boolean isAllAttribRequested = false;
            /* check if remote requested for attributes */
            if (mFolderItemsReqObj.mNumAttr != AvrcpHalConstants.NUM_ATTR_NONE) {
                int attrCnt = 0;
                /* add requested attr ids to a temp array */
                if (mFolderItemsReqObj.mNumAttr == AvrcpHalConstants.NUM_ATTR_ALL) {
                    isAllAttribRequested = true;
                    maxAttributesRequested = AvrcpHalConstants.MAX_NUM_ATTR;
                } else {
                    /* get only the requested attribute ids from the request */
                    maxAttributesRequested = mFolderItemsReqObj.mNumAttr;
                }
                /* lookup and copy values of attributes for ids requested above */
                for (int idx = 0; idx < maxAttributesRequested; idx++) {
                    /* check if media player provided requested attributes */
                    String value = null;
                    int attribId = isAllAttribRequested ? (idx + 1) : mFolderItemsReqObj.mAttrIDs[idx];
                    if (attribId >= AvrcpHalConstants.ATTRID_TITLE && attribId <= AvrcpHalConstants.ATTRID_PLAY_TIME) {
                        if ((value = getAttrValue(attribId, result_items, itemIndex)) != null) {
                            attrArray.add(value);
                            attrId.add(attribId);
                            attrCnt++;
                        }
                    } else {
                        Log.d(TAG, "invalid attributed id is requested: " + attribId);
                    }
                }
                /* add num attr actually received from media player for a particular item */
                folderDataNative.mAttributesNum[itemIndex] = attrCnt;
            }
        }
        /* copy filtered attr ids and attr values to response parameters */
        if (mFolderItemsReqObj.mNumAttr != AvrcpHalConstants.NUM_ATTR_NONE) {
            folderDataNative.mAttrIds = new int[attrId.size()];
            for (int attrIndex = 0; attrIndex < attrId.size(); attrIndex++) folderDataNative.mAttrIds[attrIndex] = attrId.get(attrIndex);
            folderDataNative.mAttrValues = attrArray.toArray(new String[attrArray.size()]);
        }
        for (int attrIndex = 0; attrIndex < folderDataNative.mAttributesNum.length; attrIndex++) Log.d(TAG, "folderDataNative.mAttributesNum" + folderDataNative.mAttributesNum[attrIndex] + " attrIndex " + attrIndex);
        /* create rsp object and send response to remote device */
        FolderItemsRsp rspObj = new FolderItemsRsp(AvrcpHalConstants.BTRC_STS_NO_ERROR, Avrcp.sUIDCounter, scope, folderDataNative.mNumItems, folderDataNative.mFolderTypes, folderDataNative.mPlayable, folderDataNative.mItemTypes, folderDataNative.mItemUid, folderDataNative.mDisplayNames, folderDataNative.mAttributesNum, folderDataNative.mAttrIds, folderDataNative.mAttrValues);
        mMediaInterface.folderItemsRsp(bdaddr, AvrcpHalConstants.BTRC_STS_NO_ERROR, rspObj);
    } else {
        Log.e(TAG, "Error: children are null in getFolderItemsFilterAttr");
        mMediaInterface.folderItemsRsp(bdaddr, AvrcpHalConstants.BTRC_STS_INV_RANGE, null);
        return;
    }
}
#method_after
private void getFolderItemsFilterAttr(byte[] bdaddr, AvrcpCmd.FolderItemsCmd mFolderItemsReqObj, List<MediaSession.QueueItem> children, byte scope, int startItem, int endItem) {
    if (DEBUG)
        Log.d(TAG, "getFolderItemsFilterAttr: startItem =" + startItem + ", endItem = " + endItem);
    List<MediaSession.QueueItem> result_items = new ArrayList<MediaSession.QueueItem>();
    if (children != null) {
        /* check for index out of bound errors */
        if ((result_items = checkIndexOutofBounds(bdaddr, children, startItem, endItem)) == null) {
            Log.w(TAG, "result_items is null.");
            mMediaInterface.folderItemsRsp(bdaddr, AvrcpConstants.RSP_INV_RANGE, null);
            return;
        }
        FolderItemsData folderDataNative = new FolderItemsData(result_items.size());
        /* variables to temperorily add attrs */
        ArrayList<String> attrArray = new ArrayList<String>();
        ArrayList<Integer> attrId = new ArrayList<Integer>();
        for (int itemIndex = 0; itemIndex < result_items.size(); itemIndex++) {
            // get the queue id
            long qid = result_items.get(itemIndex).getQueueId();
            byte[] uid = ByteBuffer.allocate(AvrcpConstants.UID_SIZE).putLong(qid).array();
            // get the array of uid from 2d to array 1D array
            for (int idx = 0; idx < AvrcpConstants.UID_SIZE; idx++) {
                folderDataNative.mItemUid[itemIndex * AvrcpConstants.UID_SIZE + idx] = uid[idx];
            }
            /* Set display name for current item */
            folderDataNative.mDisplayNames[itemIndex] = result_items.get(itemIndex).getDescription().getTitle().toString();
            int maxAttributesRequested = 0;
            boolean isAllAttribRequested = false;
            /* check if remote requested for attributes */
            if (mFolderItemsReqObj.mNumAttr != AvrcpConstants.NUM_ATTR_NONE) {
                int attrCnt = 0;
                /* add requested attr ids to a temp array */
                if (mFolderItemsReqObj.mNumAttr == AvrcpConstants.NUM_ATTR_ALL) {
                    isAllAttribRequested = true;
                    maxAttributesRequested = AvrcpConstants.MAX_NUM_ATTR;
                } else {
                    /* get only the requested attribute ids from the request */
                    maxAttributesRequested = mFolderItemsReqObj.mNumAttr;
                }
                /* lookup and copy values of attributes for ids requested above */
                for (int idx = 0; idx < maxAttributesRequested; idx++) {
                    /* check if media player provided requested attributes */
                    String value = null;
                    int attribId = isAllAttribRequested ? (idx + 1) : mFolderItemsReqObj.mAttrIDs[idx];
                    if (attribId >= AvrcpConstants.ATTRID_TITLE && attribId <= AvrcpConstants.ATTRID_PLAY_TIME) {
                        if ((value = getAttrValue(attribId, result_items, itemIndex)) != null) {
                            attrArray.add(value);
                            attrId.add(attribId);
                            attrCnt++;
                        }
                    } else {
                        Log.w(TAG, "invalid attributed id is requested: " + attribId);
                    }
                }
                /* add num attr actually received from media player for a particular item */
                folderDataNative.mAttributesNum[itemIndex] = attrCnt;
            }
        }
        /* copy filtered attr ids and attr values to response parameters */
        if (mFolderItemsReqObj.mNumAttr != AvrcpConstants.NUM_ATTR_NONE) {
            folderDataNative.mAttrIds = new int[attrId.size()];
            for (int attrIndex = 0; attrIndex < attrId.size(); attrIndex++) folderDataNative.mAttrIds[attrIndex] = attrId.get(attrIndex);
            folderDataNative.mAttrValues = attrArray.toArray(new String[attrArray.size()]);
        }
        for (int attrIndex = 0; attrIndex < folderDataNative.mAttributesNum.length; attrIndex++) if (DEBUG)
            Log.d(TAG, "folderDataNative.mAttributesNum" + folderDataNative.mAttributesNum[attrIndex] + " attrIndex " + attrIndex);
        /* create rsp object and send response to remote device */
        FolderItemsRsp rspObj = new FolderItemsRsp(AvrcpConstants.RSP_NO_ERROR, Avrcp.sUIDCounter, scope, folderDataNative.mNumItems, folderDataNative.mFolderTypes, folderDataNative.mPlayable, folderDataNative.mItemTypes, folderDataNative.mItemUid, folderDataNative.mDisplayNames, folderDataNative.mAttributesNum, folderDataNative.mAttrIds, folderDataNative.mAttrValues);
        mMediaInterface.folderItemsRsp(bdaddr, AvrcpConstants.RSP_NO_ERROR, rspObj);
    } else {
        Log.e(TAG, "Error: children are null in getFolderItemsFilterAttr");
        mMediaInterface.folderItemsRsp(bdaddr, AvrcpConstants.RSP_INV_RANGE, null);
        return;
    }
}
#end_block

#method_before
private String getAttrValue(int attr, List<MediaSession.QueueItem> resultItems, int itemIndex) {
    String attrValue = null;
    try {
        switch(attr) {
            /* Title is mandatory attribute */
            case AvrcpHalConstants.ATTRID_TITLE:
                attrValue = resultItems.get(itemIndex).getDescription().getTitle().toString();
                break;
            case AvrcpHalConstants.ATTRID_ARTIST:
                attrValue = resultItems.get(itemIndex).getDescription().getExtras().getString(MediaMetadata.METADATA_KEY_ARTIST);
                break;
            case AvrcpHalConstants.ATTRID_ALBUM:
                attrValue = resultItems.get(itemIndex).getDescription().getExtras().getString(MediaMetadata.METADATA_KEY_ALBUM);
                break;
            case AvrcpHalConstants.ATTRID_TRACK_NUM:
                attrValue = resultItems.get(itemIndex).getDescription().getExtras().getString(MediaMetadata.METADATA_KEY_TRACK_NUMBER);
                break;
            case AvrcpHalConstants.ATTRID_NUM_TRACKS:
                attrValue = resultItems.get(itemIndex).getDescription().getExtras().getString(MediaMetadata.METADATA_KEY_NUM_TRACKS);
                break;
            case AvrcpHalConstants.ATTRID_GENRE:
                attrValue = resultItems.get(itemIndex).getDescription().getExtras().getString(MediaMetadata.METADATA_KEY_GENRE);
                break;
            case AvrcpHalConstants.ATTRID_PLAY_TIME:
                attrValue = resultItems.get(itemIndex).getDescription().getExtras().getString(MediaMetadata.METADATA_KEY_DURATION);
                break;
            default:
                Log.e(TAG, "Unknown attribute ID");
        }
    } catch (IndexOutOfBoundsException ex) {
        Log.w(TAG, "getAttrValue: requested item index out of bounds");
        return null;
    } catch (NullPointerException ex) {
        Log.w(TAG, "getAttrValue: attr id not found in result");
        /* checking if attribute is title, then it is mandatory and cannot send null */
        if (attr == AvrcpHalConstants.ATTRID_TITLE) {
            return "<Unknown Title>";
        }
        return null;
    }
    if (DEBUG)
        Log.d(TAG, "getAttrValue: attrvalue = " + attrValue + ", attr id:" + attr);
    return attrValue;
}
#method_after
private String getAttrValue(int attr, List<MediaSession.QueueItem> resultItems, int itemIndex) {
    String attrValue = null;
    try {
        switch(attr) {
            /* Title is mandatory attribute */
            case AvrcpConstants.ATTRID_TITLE:
                attrValue = resultItems.get(itemIndex).getDescription().getTitle().toString();
                break;
            case AvrcpConstants.ATTRID_ARTIST:
                attrValue = resultItems.get(itemIndex).getDescription().getExtras().getString(MediaMetadata.METADATA_KEY_ARTIST);
                break;
            case AvrcpConstants.ATTRID_ALBUM:
                attrValue = resultItems.get(itemIndex).getDescription().getExtras().getString(MediaMetadata.METADATA_KEY_ALBUM);
                break;
            case AvrcpConstants.ATTRID_TRACK_NUM:
                attrValue = resultItems.get(itemIndex).getDescription().getExtras().getString(MediaMetadata.METADATA_KEY_TRACK_NUMBER);
                break;
            case AvrcpConstants.ATTRID_NUM_TRACKS:
                attrValue = resultItems.get(itemIndex).getDescription().getExtras().getString(MediaMetadata.METADATA_KEY_NUM_TRACKS);
                break;
            case AvrcpConstants.ATTRID_GENRE:
                attrValue = resultItems.get(itemIndex).getDescription().getExtras().getString(MediaMetadata.METADATA_KEY_GENRE);
                break;
            case AvrcpConstants.ATTRID_PLAY_TIME:
                attrValue = resultItems.get(itemIndex).getDescription().getExtras().getString(MediaMetadata.METADATA_KEY_DURATION);
                break;
            default:
                Log.e(TAG, "Unknown attribute ID");
        }
    } catch (IndexOutOfBoundsException ex) {
        Log.w(TAG, "getAttrValue: requested item index out of bounds");
        return null;
    } catch (NullPointerException ex) {
        Log.w(TAG, "getAttrValue: attr id not found in result");
        /* checking if attribute is title, then it is mandatory and cannot send null */
        if (attr == AvrcpConstants.ATTRID_TITLE) {
            return "<Unknown Title>";
        }
        return null;
    }
    if (DEBUG)
        Log.d(TAG, "getAttrValue: attrvalue = " + attrValue + ", attr id:" + attr);
    return attrValue;
}
#end_block

#method_before
private void getItemAttrFilterAttr(byte[] bdaddr, ItemAttrCmd mItemAttrReqObj, MediaSession.QueueItem mediaItem) {
    /* Response parameters */
    int[] attrIds = null;
    /* array of attr ids */
    String[] attrValues = null;
    /* array of attr values */
    int attrCounter = 0;
    /* num attributes for each item */
    List<MediaSession.QueueItem> resultItems = new ArrayList<MediaSession.QueueItem>();
    resultItems.add(mediaItem);
    /* variables to temperorily add attrs */
    ArrayList<String> attrArray = new ArrayList<String>();
    ArrayList<Integer> attrId = new ArrayList<Integer>();
    ArrayList<Integer> attrTempId = new ArrayList<Integer>();
    /* check if remote device has requested for attributes */
    if (mItemAttrReqObj.mNumAttr != AvrcpHalConstants.NUM_ATTR_NONE) {
        if (mItemAttrReqObj.mNumAttr == AvrcpHalConstants.NUM_ATTR_ALL) {
            for (int idx = 1; idx < AvrcpHalConstants.MAX_NUM_ATTR; idx++) {
                attrTempId.add(idx);
            /* attr id 0x00 is unused */
            }
        } else {
            /* get only the requested attribute ids from the request */
            for (int idx = 0; idx < mItemAttrReqObj.mNumAttr; idx++) {
                Log.d(TAG, "getAttrValue: attr id[" + idx + "] :" + mItemAttrReqObj.mAttrIDs[idx]);
                attrTempId.add(mItemAttrReqObj.mAttrIDs[idx]);
            }
        }
        Log.d(TAG, "getAttrValue: attr id list size:" + attrTempId.size());
        /* lookup and copy values of attributes for ids requested above */
        for (int idx = 0; idx < attrTempId.size(); idx++) {
            /* check if media player provided requested attributes */
            String value = null;
            if ((value = getAttrValue(attrTempId.get(idx), resultItems, 0)) != null) {
                attrArray.add(value);
                attrId.add(attrTempId.get(idx));
                attrCounter++;
            }
        }
        attrTempId = null;
    }
    /* copy filtered attr ids and attr values to response parameters */
    if (mItemAttrReqObj.mNumAttr != AvrcpHalConstants.NUM_ATTR_NONE) {
        attrIds = new int[attrId.size()];
        for (int attrIndex = 0; attrIndex < attrId.size(); attrIndex++) attrIds[attrIndex] = attrId.get(attrIndex);
        attrValues = attrArray.toArray(new String[attrId.size()]);
        /* create rsp object and send response */
        ItemAttrRsp rspObj = new ItemAttrRsp(AvrcpHalConstants.BTRC_STS_NO_ERROR, (byte) attrCounter, attrIds, attrValues);
        mMediaInterface.getItemAttrRsp(bdaddr, AvrcpHalConstants.BTRC_STS_NO_ERROR, rspObj);
        return;
    }
}
#method_after
private void getItemAttrFilterAttr(byte[] bdaddr, AvrcpCmd.ItemAttrCmd mItemAttrReqObj, MediaSession.QueueItem mediaItem) {
    /* Response parameters */
    int[] attrIds = null;
    /* array of attr ids */
    String[] attrValues = null;
    /* array of attr values */
    int attrCounter = 0;
    /* num attributes for each item */
    List<MediaSession.QueueItem> resultItems = new ArrayList<MediaSession.QueueItem>();
    resultItems.add(mediaItem);
    /* variables to temperorily add attrs */
    ArrayList<String> attrArray = new ArrayList<String>();
    ArrayList<Integer> attrId = new ArrayList<Integer>();
    ArrayList<Integer> attrTempId = new ArrayList<Integer>();
    /* check if remote device has requested for attributes */
    if (mItemAttrReqObj.mNumAttr != AvrcpConstants.NUM_ATTR_NONE) {
        if (mItemAttrReqObj.mNumAttr == AvrcpConstants.NUM_ATTR_ALL) {
            for (int idx = 1; idx < AvrcpConstants.MAX_NUM_ATTR; idx++) {
                attrTempId.add(idx);
            /* attr id 0x00 is unused */
            }
        } else {
            /* get only the requested attribute ids from the request */
            for (int idx = 0; idx < mItemAttrReqObj.mNumAttr; idx++) {
                if (DEBUG)
                    Log.d(TAG, "getAttrValue: attr id[" + idx + "] :" + mItemAttrReqObj.mAttrIDs[idx]);
                attrTempId.add(mItemAttrReqObj.mAttrIDs[idx]);
            }
        }
        if (DEBUG)
            Log.d(TAG, "getAttrValue: attr id list size:" + attrTempId.size());
        /* lookup and copy values of attributes for ids requested above */
        for (int idx = 0; idx < attrTempId.size(); idx++) {
            /* check if media player provided requested attributes */
            String value = null;
            if ((value = getAttrValue(attrTempId.get(idx), resultItems, 0)) != null) {
                attrArray.add(value);
                attrId.add(attrTempId.get(idx));
                attrCounter++;
            }
        }
        attrTempId = null;
    }
    /* copy filtered attr ids and attr values to response parameters */
    if (mItemAttrReqObj.mNumAttr != AvrcpConstants.NUM_ATTR_NONE) {
        attrIds = new int[attrId.size()];
        for (int attrIndex = 0; attrIndex < attrId.size(); attrIndex++) attrIds[attrIndex] = attrId.get(attrIndex);
        attrValues = attrArray.toArray(new String[attrId.size()]);
        /* create rsp object and send response */
        ItemAttrRsp rspObj = new ItemAttrRsp(AvrcpConstants.RSP_NO_ERROR, (byte) attrCounter, attrIds, attrValues);
        mMediaInterface.getItemAttrRsp(bdaddr, AvrcpConstants.RSP_NO_ERROR, rspObj);
        return;
    }
}
#end_block

#method_before
void handlePassthroughCmd(int id, int keyState, byte[] bdAddr, MediaController mediaController) {
    if (mediaController != null) {
        MediaController.TransportControls mediaControllerCntrl = mediaController.getTransportControls();
        if (DEBUG)
            Log.v(TAG, "handlePassthroughCmd - id:" + id + " keyState:" + keyState);
        if (keyState == AvrcpHalConstants.KEY_STATE_PRESS) {
            switch(id) {
                case BluetoothAvrcp.PASSTHROUGH_ID_REWIND:
                    mediaControllerCntrl.rewind();
                    break;
                case BluetoothAvrcp.PASSTHROUGH_ID_FAST_FOR:
                    mediaControllerCntrl.fastForward();
                    break;
                case BluetoothAvrcp.PASSTHROUGH_ID_PLAY:
                    mediaControllerCntrl.play();
                    break;
                case BluetoothAvrcp.PASSTHROUGH_ID_PAUSE:
                    mediaControllerCntrl.pause();
                    break;
                case BluetoothAvrcp.PASSTHROUGH_ID_STOP:
                    mediaControllerCntrl.stop();
                    break;
                case BluetoothAvrcp.PASSTHROUGH_ID_FORWARD:
                    mediaControllerCntrl.skipToNext();
                    break;
                case BluetoothAvrcp.PASSTHROUGH_ID_BACKWARD:
                    mediaControllerCntrl.skipToPrevious();
                    break;
                default:
                    Log.w(TAG, "unknown id:" + id + " keyState:" + keyState);
            }
        } else {
            Log.i(TAG, "ignoring the release event for id:" + id + " keyState:" + keyState);
        }
    } else {
        Log.e(TAG, "Unable to handlePassthroughCmd, mediaController is null!");
    }
}
#method_after
void handlePassthroughCmd(int id, int keyState, byte[] bdAddr, MediaController mediaController) {
    if (mediaController != null) {
        MediaController.TransportControls mediaControllerCntrl = mediaController.getTransportControls();
        if (DEBUG)
            Log.v(TAG, "handlePassthroughCmd - id:" + id + " keyState:" + keyState);
        if (keyState == AvrcpConstants.KEY_STATE_PRESS) {
            switch(id) {
                case BluetoothAvrcp.PASSTHROUGH_ID_REWIND:
                    mediaControllerCntrl.rewind();
                    break;
                case BluetoothAvrcp.PASSTHROUGH_ID_FAST_FOR:
                    mediaControllerCntrl.fastForward();
                    break;
                case BluetoothAvrcp.PASSTHROUGH_ID_PLAY:
                    mediaControllerCntrl.play();
                    break;
                case BluetoothAvrcp.PASSTHROUGH_ID_PAUSE:
                    mediaControllerCntrl.pause();
                    break;
                case BluetoothAvrcp.PASSTHROUGH_ID_STOP:
                    mediaControllerCntrl.stop();
                    break;
                case BluetoothAvrcp.PASSTHROUGH_ID_FORWARD:
                    mediaControllerCntrl.skipToNext();
                    break;
                case BluetoothAvrcp.PASSTHROUGH_ID_BACKWARD:
                    mediaControllerCntrl.skipToPrevious();
                    break;
                default:
                    Log.w(TAG, "unknown id:" + id + " keyState:" + keyState);
            }
        } else {
            Log.i(TAG, "ignoring the release event for id:" + id + " keyState:" + keyState);
        }
    } else {
        Log.e(TAG, "Unable to handlePassthroughCmd, mediaController is null!");
    }
}
#end_block

#method_before
public void doQuit() {
    if (DEBUG)
        Log.d(TAG, "doQuit");
    mHandler.removeCallbacksAndMessages(null);
    Looper looper = mHandler.getLooper();
    if (looper != null) {
        looper.quit();
    }
    unregOldMediaControllerCb(true);
    mMediaSessionManager.removeOnActiveSessionsChangedListener(mActiveSessionListener);
    mHandler = null;
    mMPLObj = null;
    mContext.unregisterReceiver(mAvrcpReceiver);
    mAddressedMediaPlayer.cleanup();
    mAvrcpBrowseManager.cleanup();
}
#method_after
public void doQuit() {
    if (DEBUG)
        Log.d(TAG, "doQuit");
    mHandler.removeCallbacksAndMessages(null);
    Looper looper = mHandler.getLooper();
    if (looper != null) {
        looper.quit();
    }
    unregOldMediaControllerCb();
    mMediaSessionManager.removeOnActiveSessionsChangedListener(mActiveSessionListener);
    mHandler = null;
    mMPLObj = null;
    mContext.unregisterReceiver(mAvrcpReceiver);
    mAddressedMediaPlayer.cleanup();
    mAvrcpBrowseManager.cleanup();
}
#end_block

#method_before
@Override
public synchronized void onPlaybackStateChanged(PlaybackState state) {
    Log.v(TAG, "MediaController playback changed: " + state.toString());
    updatePlayPauseState(state);
    if (DEBUG)
        Log.v(TAG, "onPlaybackStateChanged: state=" + state.getState());
    byte stateBytes = (byte) convertPlayStateToBytes(state.getState());
    /* updating play status in global media player list */
    if (!isCurrentMediaPlayerListEmpty() && isIdValid(mCurrAddrPlayerID)) {
        try {
            mMediaPlayerInfoList.get(mCurrAddrPlayerID - 1).setPlayStatus(stateBytes);
        } catch (IndexOutOfBoundsException e) {
            Log.i(TAG, "onPlaybackStateChanged: list size = " + getPlayerListSize() + ", mCurrAddrPlayerID = " + mCurrAddrPlayerID);
            e.printStackTrace();
        }
    }
}
#method_after
@Override
public synchronized void onPlaybackStateChanged(PlaybackState state) {
    Log.v(TAG, "MediaController playback changed: " + state.toString());
    updatePlaybackState(state);
    if (DEBUG)
        Log.v(TAG, "onPlaybackStateChanged: state=" + state.getState());
    byte stateBytes = (byte) convertPlayStateToBytes(state.getState());
    /* updating play status in global media player list */
    if (!isCurrentMediaPlayerListEmpty() && isIdValid(mCurrAddrPlayerID)) {
        try {
            mMediaPlayerInfoList.get(mCurrAddrPlayerID - 1).setPlayStatus(stateBytes);
        } catch (IndexOutOfBoundsException e) {
            Log.i(TAG, "onPlaybackStateChanged: list size = " + getPlayerListSize() + ", mCurrAddrPlayerID = " + mCurrAddrPlayerID);
            e.printStackTrace();
        }
    }
}
#end_block

#method_before
@Override
public void onQueueChanged(List<MediaSession.QueueItem> queue) {
    Log.v(TAG, "onQueueChanged: NowPlaying list changed");
    mAddressedMediaPlayer.updateNowPlaying(queue);
    /* sent notification to remote for NowPlayingList changed */
    if (!registerNotificationRspNowPlayingChangedNative(AvrcpHalConstants.NOTIFICATION_TYPE_CHANGED)) {
        Log.e(TAG, "onQueueChanged-registerNotificationRspNowPlayingChangedNative failed");
    }
}
#method_after
@Override
public void onQueueChanged(List<MediaSession.QueueItem> queue) {
    if (queue == null) {
        Log.v(TAG, "onQueueChanged: received null queue");
        return;
    }
    Log.v(TAG, "onQueueChanged: NowPlaying list changed, Queue Size = " + queue.size());
    mAddressedMediaPlayer.updateNowPlayingList(queue);
    /* sent notification to remote for NowPlayingList changed */
    if (!registerNotificationRspNowPlayingChangedNative(AvrcpConstants.NOTIFICATION_TYPE_CHANGED)) {
        Log.e(TAG, "onQueueChanged-registerNotificationRspNowPlayingChangedNative failed");
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    if (DEBUG)
        Log.v(TAG, "AvrcpMessageHandler: received message=" + msg.what);
    switch(msg.what) {
        case MESSAGE_GET_RC_FEATURES:
            {
                String address = (String) msg.obj;
                if (DEBUG)
                    Log.v(TAG, "MESSAGE_GET_RC_FEATURES: address=" + address + ", features=" + msg.arg1);
                mFeatures = msg.arg1;
                mFeatures = modifyRcFeatureFromBlacklist(mFeatures, address);
                mAudioManager.avrcpSupportsAbsoluteVolume(address, isAbsoluteVolumeSupported());
                mLastLocalVolume = -1;
                mRemoteVolume = -1;
                mLocalVolume = -1;
                mInitialRemoteVolume = -1;
                mAddress = address;
                if (mVolumeMapping != null)
                    mVolumeMapping.clear();
                break;
            }
        case MESSAGE_GET_PLAY_STATUS:
            {
                byte[] address = (byte[]) msg.obj;
                if (DEBUG)
                    Log.v(TAG, "MESSAGE_GET_PLAY_STATUS");
                getPlayStatusRspNative(address, convertPlayStateToPlayStatus(mCurrentPlayState), (int) mSongLengthMs, (int) getPlayPosition());
                break;
            }
        case MESSAGE_GET_ELEM_ATTRS:
            {
                String[] textArray;
                ElementAttrCmd elem = (ElementAttrCmd) msg.obj;
                byte numAttr = elem.mNumAttr;
                int[] attrIds = elem.mAttrIDs;
                if (DEBUG)
                    Log.v(TAG, "MESSAGE_GET_ELEM_ATTRS:numAttr=" + numAttr);
                textArray = new String[numAttr];
                for (int i = 0; i < numAttr; ++i) {
                    textArray[i] = getAttributeString(attrIds[i]);
                }
                byte[] bdaddr = elem.mAddress;
                getElementAttrRspNative(bdaddr, numAttr, attrIds, textArray);
                break;
            }
        case MESSAGE_REGISTER_NOTIFICATION:
            if (DEBUG)
                Log.v(TAG, "MESSAGE_REGISTER_NOTIFICATION:event=" + msg.arg1 + " param=" + msg.arg2);
            processRegisterNotification((byte[]) msg.obj, msg.arg1, msg.arg2);
            break;
        case MESSAGE_PLAY_INTERVAL_TIMEOUT:
            if (DEBUG)
                Log.v(TAG, "MESSAGE_PLAY_INTERVAL_TIMEOUT");
            mPlayPosChangedNT = AvrcpHalConstants.NOTIFICATION_TYPE_CHANGED;
            registerNotificationRspPlayPosNative(mPlayPosChangedNT, (int) getPlayPosition());
            break;
        case MESSAGE_VOLUME_CHANGED:
            if (!isAbsoluteVolumeSupported()) {
                if (DEBUG)
                    Log.v(TAG, "ignore MESSAGE_VOLUME_CHANGED");
                break;
            }
            if (DEBUG)
                Log.v(TAG, "MESSAGE_VOLUME_CHANGED: volume=" + ((byte) msg.arg1 & 0x7f) + " ctype=" + msg.arg2);
            boolean volAdj = false;
            if (msg.arg2 == AVRC_RSP_ACCEPT || msg.arg2 == AVRC_RSP_REJ) {
                if (mVolCmdAdjustInProgress == false && mVolCmdSetInProgress == false) {
                    Log.e(TAG, "Unsolicited response, ignored");
                    break;
                }
                removeMessages(MESSAGE_ABS_VOL_TIMEOUT);
                volAdj = mVolCmdAdjustInProgress;
                mVolCmdAdjustInProgress = false;
                mVolCmdSetInProgress = false;
                mAbsVolRetryTimes = 0;
            }
            // discard MSB as it is RFD
            byte absVol = (byte) ((byte) msg.arg1 & 0x7f);
            // convert remote volume to local volume
            int volIndex = convertToAudioStreamVolume(absVol);
            if (mInitialRemoteVolume == -1) {
                mInitialRemoteVolume = absVol;
                if (mAbsVolThreshold > 0 && mAbsVolThreshold < mAudioStreamMax && volIndex > mAbsVolThreshold) {
                    if (DEBUG)
                        Log.v(TAG, "remote inital volume too high " + volIndex + ">" + mAbsVolThreshold);
                    Message msg1 = mHandler.obtainMessage(MESSAGE_SET_ABSOLUTE_VOLUME, mAbsVolThreshold, 0);
                    mHandler.sendMessage(msg1);
                    mRemoteVolume = absVol;
                    mLocalVolume = volIndex;
                    break;
                }
            }
            if (mLocalVolume != volIndex && (msg.arg2 == AVRC_RSP_ACCEPT || msg.arg2 == AVRC_RSP_CHANGED || msg.arg2 == AVRC_RSP_INTERIM)) {
                /* If the volume has successfully changed */
                mLocalVolume = volIndex;
                if (mLastLocalVolume != -1 && msg.arg2 == AVRC_RSP_ACCEPT) {
                    if (mLastLocalVolume != volIndex) {
                        /* remote volume changed more than requested due to
                             * local and remote has different volume steps */
                        if (DEBUG)
                            Log.d(TAG, "Remote returned volume does not match desired volume " + mLastLocalVolume + " vs " + volIndex);
                        mLastLocalVolume = mLocalVolume;
                    }
                }
                // remember the remote volume value, as it's the one supported by remote
                if (volAdj) {
                    synchronized (mVolumeMapping) {
                        mVolumeMapping.put(volIndex, (int) absVol);
                        if (DEBUG)
                            Log.v(TAG, "remember volume mapping " + volIndex + "-" + absVol);
                    }
                }
                notifyVolumeChanged(mLocalVolume);
                mRemoteVolume = absVol;
                long pecentVolChanged = ((long) absVol * 100) / 0x7f;
                Log.e(TAG, "percent volume changed: " + pecentVolChanged + "%");
            } else if (msg.arg2 == AVRC_RSP_REJ) {
                Log.e(TAG, "setAbsoluteVolume call rejected");
            } else if (volAdj && mLastRemoteVolume > 0 && mLastRemoteVolume < AVRCP_MAX_VOL && mLocalVolume == volIndex && (msg.arg2 == AVRC_RSP_ACCEPT)) {
                /* oops, the volume is still same, remote does not like the value
                     * retry a volume one step up/down */
                if (DEBUG)
                    Log.d(TAG, "Remote device didn't tune volume, let's try one more step.");
                int retry_volume = Math.min(AVRCP_MAX_VOL, Math.max(0, mLastRemoteVolume + mLastDirection));
                if (setVolumeNative(retry_volume)) {
                    mLastRemoteVolume = retry_volume;
                    sendMessageDelayed(obtainMessage(MESSAGE_ABS_VOL_TIMEOUT), CMD_TIMEOUT_DELAY);
                    mVolCmdAdjustInProgress = true;
                }
            }
            break;
        case MESSAGE_ADJUST_VOLUME:
            if (!isAbsoluteVolumeSupported()) {
                if (DEBUG)
                    Log.v(TAG, "ignore MESSAGE_ADJUST_VOLUME");
                break;
            }
            if (DEBUG)
                Log.d(TAG, "MESSAGE_ADJUST_VOLUME: direction=" + msg.arg1);
            if (mVolCmdAdjustInProgress || mVolCmdSetInProgress) {
                if (DEBUG)
                    Log.w(TAG, "There is already a volume command in progress.");
                break;
            }
            // Remote device didn't set initial volume. Let's black list it
            if (mInitialRemoteVolume == -1) {
                Log.d(TAG, "remote " + mAddress + " never tell us initial volume, black list it.");
                blackListCurrentDevice();
                break;
            }
            // Wait on verification on volume from device, before changing the volume.
            if (mRemoteVolume != -1 && (msg.arg1 == -1 || msg.arg1 == 1)) {
                int setVol = -1;
                int targetVolIndex = -1;
                if (mLocalVolume == 0 && msg.arg1 == -1) {
                    if (DEBUG)
                        Log.w(TAG, "No need to Vol down from 0.");
                    break;
                }
                if (mLocalVolume == mAudioStreamMax && msg.arg1 == 1) {
                    if (DEBUG)
                        Log.w(TAG, "No need to Vol up from max.");
                    break;
                }
                targetVolIndex = mLocalVolume + msg.arg1;
                if (DEBUG)
                    Log.d(TAG, "Adjusting volume to  " + targetVolIndex);
                Integer i;
                synchronized (mVolumeMapping) {
                    i = mVolumeMapping.get(targetVolIndex);
                }
                if (i != null) {
                    /* if we already know this volume mapping, use it */
                    setVol = i.byteValue();
                    if (setVol == mRemoteVolume) {
                        if (DEBUG)
                            Log.d(TAG, "got same volume from mapping for " + targetVolIndex + ", ignore.");
                        setVol = -1;
                    }
                    if (DEBUG)
                        Log.d(TAG, "set volume from mapping " + targetVolIndex + "-" + setVol);
                }
                if (setVol == -1) {
                    /* otherwise use phone steps */
                    setVol = Math.min(AVRCP_MAX_VOL, convertToAvrcpVolume(Math.max(0, targetVolIndex)));
                    if (DEBUG)
                        Log.d(TAG, "set volume from local volume " + targetVolIndex + "-" + setVol);
                }
                if (setVolumeNative(setVol)) {
                    sendMessageDelayed(obtainMessage(MESSAGE_ABS_VOL_TIMEOUT), CMD_TIMEOUT_DELAY);
                    mVolCmdAdjustInProgress = true;
                    mLastDirection = msg.arg1;
                    mLastRemoteVolume = setVol;
                    mLastLocalVolume = targetVolIndex;
                } else {
                    if (DEBUG)
                        Log.d(TAG, "setVolumeNative failed");
                }
            } else {
                Log.e(TAG, "Unknown direction in MESSAGE_ADJUST_VOLUME");
            }
            break;
        case MESSAGE_SET_ABSOLUTE_VOLUME:
            if (!isAbsoluteVolumeSupported()) {
                if (DEBUG)
                    Log.v(TAG, "ignore MESSAGE_SET_ABSOLUTE_VOLUME");
                break;
            }
            if (DEBUG)
                Log.v(TAG, "MESSAGE_SET_ABSOLUTE_VOLUME");
            if (mVolCmdSetInProgress || mVolCmdAdjustInProgress) {
                if (DEBUG)
                    Log.w(TAG, "There is already a volume command in progress.");
                break;
            }
            // Remote device didn't set initial volume. Let's black list it
            if (mInitialRemoteVolume == -1) {
                if (DEBUG)
                    Log.d(TAG, "remote " + mAddress + " never tell us initial volume, black list it.");
                blackListCurrentDevice();
                break;
            }
            int avrcpVolume = convertToAvrcpVolume(msg.arg1);
            avrcpVolume = Math.min(AVRCP_MAX_VOL, Math.max(0, avrcpVolume));
            if (DEBUG)
                Log.d(TAG, "Setting volume to " + msg.arg1 + "-" + avrcpVolume);
            if (setVolumeNative(avrcpVolume)) {
                sendMessageDelayed(obtainMessage(MESSAGE_ABS_VOL_TIMEOUT), CMD_TIMEOUT_DELAY);
                mVolCmdSetInProgress = true;
                mLastRemoteVolume = avrcpVolume;
                mLastLocalVolume = msg.arg1;
            } else {
                if (DEBUG)
                    Log.d(TAG, "setVolumeNative failed");
            }
            break;
        case MESSAGE_ABS_VOL_TIMEOUT:
            if (DEBUG)
                Log.v(TAG, "MESSAGE_ABS_VOL_TIMEOUT: Volume change cmd timed out.");
            mVolCmdAdjustInProgress = false;
            mVolCmdSetInProgress = false;
            if (mAbsVolRetryTimes >= MAX_ERROR_RETRY_TIMES) {
                mAbsVolRetryTimes = 0;
                /* too many volume change failures, black list the device */
                blackListCurrentDevice();
            } else {
                mAbsVolRetryTimes += 1;
                if (setVolumeNative(mLastRemoteVolume)) {
                    sendMessageDelayed(obtainMessage(MESSAGE_ABS_VOL_TIMEOUT), CMD_TIMEOUT_DELAY);
                    mVolCmdSetInProgress = true;
                }
            }
            break;
        case MESSAGE_FAST_FORWARD:
        case MESSAGE_REWIND:
            if (msg.what == MESSAGE_FAST_FORWARD) {
                if ((mCurrentPlayState.getActions() & PlaybackState.ACTION_FAST_FORWARD) != 0) {
                    int keyState = msg.arg1 == AvrcpHalConstants.KEY_STATE_PRESS ? KeyEvent.ACTION_DOWN : KeyEvent.ACTION_UP;
                    KeyEvent keyEvent = new KeyEvent(keyState, KeyEvent.KEYCODE_MEDIA_FAST_FORWARD);
                    mMediaController.dispatchMediaButtonEvent(keyEvent);
                    break;
                }
            } else if ((mCurrentPlayState.getActions() & PlaybackState.ACTION_REWIND) != 0) {
                int keyState = msg.arg1 == AvrcpHalConstants.KEY_STATE_PRESS ? KeyEvent.ACTION_DOWN : KeyEvent.ACTION_UP;
                KeyEvent keyEvent = new KeyEvent(keyState, KeyEvent.KEYCODE_MEDIA_REWIND);
                mMediaController.dispatchMediaButtonEvent(keyEvent);
                break;
            }
            int skipAmount;
            int playStatus;
            if (msg.what == MESSAGE_FAST_FORWARD) {
                if (DEBUG)
                    Log.v(TAG, "MESSAGE_FAST_FORWARD");
                removeMessages(MESSAGE_FAST_FORWARD);
                skipAmount = BASE_SKIP_AMOUNT;
                playStatus = PlaybackState.STATE_FAST_FORWARDING;
            } else {
                if (DEBUG)
                    Log.v(TAG, "MESSAGE_REWIND");
                removeMessages(MESSAGE_REWIND);
                skipAmount = -BASE_SKIP_AMOUNT;
                playStatus = PlaybackState.STATE_REWINDING;
            }
            if (hasMessages(MESSAGE_CHANGE_PLAY_POS) && (skipAmount != mSkipAmount)) {
                Log.w(TAG, "missing release button event:" + mSkipAmount);
            }
            if ((!hasMessages(MESSAGE_CHANGE_PLAY_POS)) || (skipAmount != mSkipAmount)) {
                mSkipStartTime = SystemClock.elapsedRealtime();
            }
            removeMessages(MESSAGE_CHANGE_PLAY_POS);
            if (msg.arg1 == AvrcpHalConstants.KEY_STATE_PRESS) {
                mSkipAmount = skipAmount;
                changePositionBy(mSkipAmount * getSkipMultiplier());
                Message posMsg = obtainMessage(MESSAGE_CHANGE_PLAY_POS);
                posMsg.arg1 = 1;
                sendMessageDelayed(posMsg, SKIP_PERIOD);
            }
            registerNotificationRspPlayStatusNative(AvrcpHalConstants.NOTIFICATION_TYPE_CHANGED, playStatus);
            break;
        case MESSAGE_CHANGE_PLAY_POS:
            if (DEBUG)
                Log.v(TAG, "MESSAGE_CHANGE_PLAY_POS:" + msg.arg1);
            changePositionBy(mSkipAmount * getSkipMultiplier());
            if (msg.arg1 * SKIP_PERIOD < BUTTON_TIMEOUT_TIME) {
                Message posMsg = obtainMessage(MESSAGE_CHANGE_PLAY_POS);
                posMsg.arg1 = msg.arg1 + 1;
                sendMessageDelayed(posMsg, SKIP_PERIOD);
            }
            break;
        case MESSAGE_SET_A2DP_AUDIO_STATE:
            if (DEBUG)
                Log.v(TAG, "MESSAGE_SET_A2DP_AUDIO_STATE:" + msg.arg1);
            updateA2dpAudioState(msg.arg1);
            break;
        case MESSAGE_GET_FOLDER_ITEMS:
            {
                FolderItemsCmd folderObj = (FolderItemsCmd) msg.obj;
                switch(folderObj.mScope) {
                    case AvrcpHalConstants.BTRC_SCOPE_PLAYER_LIST:
                        handleMediaPlayerListRsp(folderObj);
                        break;
                    case AvrcpHalConstants.BTRC_SCOPE_FILE_SYSTEM:
                    case AvrcpHalConstants.BTRC_SCOPE_NOW_PLAYING:
                        handleGetFolderItemBrowseResponse(folderObj, folderObj.mAddress);
                        break;
                    default:
                        Log.e(TAG, "unknown scope for getfolderitems. scope = " + folderObj.mScope);
                        getFolderItemsRspNative(folderObj.mAddress, AvrcpHalConstants.BTRC_STS_INV_SCOPE, (short) 0, (byte) 0, 0, null, null, null, null, null, null, null, null);
                }
                break;
            }
        case MESSAGE_SET_ADDR_PLAYER:
            // object is bdaddr, argument 1 is the selected player id
            setAddressedPlayer((byte[]) msg.obj, msg.arg1);
            break;
        case MESSAGE_GET_ITEM_ATTR:
            // msg object contains the item attribute object
            handleGetItemAttr((ItemAttrCmd) msg.obj);
            break;
        case MESSAGE_SET_BR_PLAYER:
            // argument 1 is the selected player id
            setBrowsedPlayer((byte[]) msg.obj, msg.arg1);
            break;
        case MESSAGE_CHANGE_PATH:
            {
                Bundle data = msg.getData();
                byte[] bdaddr = data.getByteArray("BdAddress");
                byte[] folderUid = data.getByteArray("folderUid");
                byte direction = data.getByte("direction");
                if (mAvrcpBrowseManager.getBrowseMediaPlayer(bdaddr) != null) {
                    mAvrcpBrowseManager.getBrowseMediaPlayer(bdaddr).changePath(folderUid, direction);
                } else {
                    Log.e(TAG, "Remote requesting change path before setbrowsedplayer");
                    changePathRspNative(bdaddr, AvrcpHalConstants.BTRC_STS_BAD_CMD, 0);
                }
                break;
            }
        case MESSAGE_PLAY_ITEM:
            {
                Bundle data = msg.getData();
                byte[] bdaddr = data.getByteArray("BdAddress");
                byte[] uid = data.getByteArray("uid");
                byte scope = data.getByte("scope");
                handlePlayItemResponse(bdaddr, uid, scope);
                break;
            }
        case MESSAGE_GET_TOTAL_NUM_OF_ITEMS:
            // argument 1 is scope, object is bdaddr
            handleGetTotalNumOfItemsResponse((byte[]) msg.obj, (byte) msg.arg1);
            break;
        case MESSAGE_PASS_THROUGH:
            // argument 1 is id, argument 2 is keyState, object is bdaddr
            mAddressedMediaPlayer.handlePassthroughCmd(msg.arg1, msg.arg2, (byte[]) msg.obj, mMediaController);
            break;
        default:
            Log.e(TAG, "unknown message! msg.what=" + msg.what);
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    if (DEBUG)
        Log.v(TAG, "AvrcpMessageHandler: received message=" + msg.what);
    switch(msg.what) {
        case MSG_NATIVE_REQ_GET_RC_FEATURES:
            {
                String address = (String) msg.obj;
                if (DEBUG)
                    Log.v(TAG, "MSG_NATIVE_REQ_GET_RC_FEATURES: address=" + address + ", features=" + msg.arg1);
                mFeatures = msg.arg1;
                mFeatures = modifyRcFeatureFromBlacklist(mFeatures, address);
                mAudioManager.avrcpSupportsAbsoluteVolume(address, isAbsoluteVolumeSupported());
                mLastLocalVolume = -1;
                mRemoteVolume = -1;
                mLocalVolume = -1;
                mInitialRemoteVolume = -1;
                mAddress = address;
                if (mVolumeMapping != null)
                    mVolumeMapping.clear();
                break;
            }
        case MSG_NATIVE_REQ_GET_PLAY_STATUS:
            {
                byte[] address = (byte[]) msg.obj;
                if (DEBUG)
                    Log.v(TAG, "MSG_NATIVE_REQ_GET_PLAY_STATUS");
                getPlayStatusRspNative(address, convertPlayStateToPlayStatus(mCurrentPlayState), (int) mSongLengthMs, (int) getPlayPosition());
                break;
            }
        case MSG_NATIVE_REQ_GET_ELEM_ATTRS:
            {
                String[] textArray;
                AvrcpCmd.ElementAttrCmd elem = (AvrcpCmd.ElementAttrCmd) msg.obj;
                byte numAttr = elem.mNumAttr;
                int[] attrIds = elem.mAttrIDs;
                if (DEBUG)
                    Log.v(TAG, "MSG_NATIVE_REQ_GET_ELEM_ATTRS:numAttr=" + numAttr);
                textArray = new String[numAttr];
                for (int i = 0; i < numAttr; ++i) {
                    textArray[i] = mMediaAttributes.getString(attrIds[i]);
                    Log.v(TAG, "getAttributeString:attrId=" + attrIds[i] + " str=" + textArray[i]);
                }
                byte[] bdaddr = elem.mAddress;
                getElementAttrRspNative(bdaddr, numAttr, attrIds, textArray);
                break;
            }
        case MSG_NATIVE_REQ_REGISTER_NOTIFICATION:
            if (DEBUG)
                Log.v(TAG, "MSG_NATIVE_REQ_REGISTER_NOTIFICATION:event=" + msg.arg1 + " param=" + msg.arg2);
            processRegisterNotification((byte[]) msg.obj, msg.arg1, msg.arg2);
            break;
        case MSG_PLAY_INTERVAL_TIMEOUT:
            if (DEBUG)
                Log.v(TAG, "MSG_PLAY_INTERVAL_TIMEOUT");
            sendPlayPosNotificationRsp(false);
            break;
        case MSG_NATIVE_REQ_VOLUME_CHANGE:
            if (!isAbsoluteVolumeSupported()) {
                if (DEBUG)
                    Log.v(TAG, "ignore MSG_NATIVE_REQ_VOLUME_CHANGE");
                break;
            }
            if (DEBUG)
                Log.v(TAG, "MSG_NATIVE_REQ_VOLUME_CHANGE: volume=" + ((byte) msg.arg1 & 0x7f) + " ctype=" + msg.arg2);
            boolean volAdj = false;
            if (msg.arg2 == AVRC_RSP_ACCEPT || msg.arg2 == AVRC_RSP_REJ) {
                if (mVolCmdAdjustInProgress == false && mVolCmdSetInProgress == false) {
                    Log.e(TAG, "Unsolicited response, ignored");
                    break;
                }
                removeMessages(MSG_ABS_VOL_TIMEOUT);
                volAdj = mVolCmdAdjustInProgress;
                mVolCmdAdjustInProgress = false;
                mVolCmdSetInProgress = false;
                mAbsVolRetryTimes = 0;
            }
            // discard MSB as it is RFD
            byte absVol = (byte) ((byte) msg.arg1 & 0x7f);
            // convert remote volume to local volume
            int volIndex = convertToAudioStreamVolume(absVol);
            if (mInitialRemoteVolume == -1) {
                mInitialRemoteVolume = absVol;
                if (mAbsVolThreshold > 0 && mAbsVolThreshold < mAudioStreamMax && volIndex > mAbsVolThreshold) {
                    if (DEBUG)
                        Log.v(TAG, "remote inital volume too high " + volIndex + ">" + mAbsVolThreshold);
                    Message msg1 = mHandler.obtainMessage(MSG_SET_ABSOLUTE_VOLUME, mAbsVolThreshold, 0);
                    mHandler.sendMessage(msg1);
                    mRemoteVolume = absVol;
                    mLocalVolume = volIndex;
                    break;
                }
            }
            if (mLocalVolume != volIndex && (msg.arg2 == AVRC_RSP_ACCEPT || msg.arg2 == AVRC_RSP_CHANGED || msg.arg2 == AVRC_RSP_INTERIM)) {
                /* If the volume has successfully changed */
                mLocalVolume = volIndex;
                if (mLastLocalVolume != -1 && msg.arg2 == AVRC_RSP_ACCEPT) {
                    if (mLastLocalVolume != volIndex) {
                        /* remote volume changed more than requested due to
                             * local and remote has different volume steps */
                        if (DEBUG)
                            Log.d(TAG, "Remote returned volume does not match desired volume " + mLastLocalVolume + " vs " + volIndex);
                        mLastLocalVolume = mLocalVolume;
                    }
                }
                // remember the remote volume value, as it's the one supported by remote
                if (volAdj) {
                    synchronized (mVolumeMapping) {
                        mVolumeMapping.put(volIndex, (int) absVol);
                        if (DEBUG)
                            Log.v(TAG, "remember volume mapping " + volIndex + "-" + absVol);
                    }
                }
                notifyVolumeChanged(mLocalVolume);
                mRemoteVolume = absVol;
                long pecentVolChanged = ((long) absVol * 100) / 0x7f;
                Log.e(TAG, "percent volume changed: " + pecentVolChanged + "%");
            } else if (msg.arg2 == AVRC_RSP_REJ) {
                Log.e(TAG, "setAbsoluteVolume call rejected");
            } else if (volAdj && mLastRemoteVolume > 0 && mLastRemoteVolume < AVRCP_MAX_VOL && mLocalVolume == volIndex && (msg.arg2 == AVRC_RSP_ACCEPT)) {
                /* oops, the volume is still same, remote does not like the value
                     * retry a volume one step up/down */
                if (DEBUG)
                    Log.d(TAG, "Remote device didn't tune volume, let's try one more step.");
                int retry_volume = Math.min(AVRCP_MAX_VOL, Math.max(0, mLastRemoteVolume + mLastDirection));
                if (setVolumeNative(retry_volume)) {
                    mLastRemoteVolume = retry_volume;
                    sendMessageDelayed(obtainMessage(MSG_ABS_VOL_TIMEOUT), CMD_TIMEOUT_DELAY);
                    mVolCmdAdjustInProgress = true;
                }
            }
            break;
        case MSG_ADJUST_VOLUME:
            if (!isAbsoluteVolumeSupported()) {
                if (DEBUG)
                    Log.v(TAG, "ignore MSG_ADJUST_VOLUME");
                break;
            }
            if (DEBUG)
                Log.d(TAG, "MSG_ADJUST_VOLUME: direction=" + msg.arg1);
            if (mVolCmdAdjustInProgress || mVolCmdSetInProgress) {
                if (DEBUG)
                    Log.w(TAG, "There is already a volume command in progress.");
                break;
            }
            // Remote device didn't set initial volume. Let's black list it
            if (mInitialRemoteVolume == -1) {
                Log.d(TAG, "remote " + mAddress + " never tell us initial volume, black list it.");
                blackListCurrentDevice();
                break;
            }
            // Wait on verification on volume from device, before changing the volume.
            if (mRemoteVolume != -1 && (msg.arg1 == -1 || msg.arg1 == 1)) {
                int setVol = -1;
                int targetVolIndex = -1;
                if (mLocalVolume == 0 && msg.arg1 == -1) {
                    if (DEBUG)
                        Log.w(TAG, "No need to Vol down from 0.");
                    break;
                }
                if (mLocalVolume == mAudioStreamMax && msg.arg1 == 1) {
                    if (DEBUG)
                        Log.w(TAG, "No need to Vol up from max.");
                    break;
                }
                targetVolIndex = mLocalVolume + msg.arg1;
                if (DEBUG)
                    Log.d(TAG, "Adjusting volume to  " + targetVolIndex);
                Integer i;
                synchronized (mVolumeMapping) {
                    i = mVolumeMapping.get(targetVolIndex);
                }
                if (i != null) {
                    /* if we already know this volume mapping, use it */
                    setVol = i.byteValue();
                    if (setVol == mRemoteVolume) {
                        if (DEBUG)
                            Log.d(TAG, "got same volume from mapping for " + targetVolIndex + ", ignore.");
                        setVol = -1;
                    }
                    if (DEBUG)
                        Log.d(TAG, "set volume from mapping " + targetVolIndex + "-" + setVol);
                }
                if (setVol == -1) {
                    /* otherwise use phone steps */
                    setVol = Math.min(AVRCP_MAX_VOL, convertToAvrcpVolume(Math.max(0, targetVolIndex)));
                    if (DEBUG)
                        Log.d(TAG, "set volume from local volume " + targetVolIndex + "-" + setVol);
                }
                if (setVolumeNative(setVol)) {
                    sendMessageDelayed(obtainMessage(MSG_ABS_VOL_TIMEOUT), CMD_TIMEOUT_DELAY);
                    mVolCmdAdjustInProgress = true;
                    mLastDirection = msg.arg1;
                    mLastRemoteVolume = setVol;
                    mLastLocalVolume = targetVolIndex;
                } else {
                    if (DEBUG)
                        Log.d(TAG, "setVolumeNative failed");
                }
            } else {
                Log.e(TAG, "Unknown direction in MSG_ADJUST_VOLUME");
            }
            break;
        case MSG_SET_ABSOLUTE_VOLUME:
            if (!isAbsoluteVolumeSupported()) {
                if (DEBUG)
                    Log.v(TAG, "ignore MSG_SET_ABSOLUTE_VOLUME");
                break;
            }
            if (DEBUG)
                Log.v(TAG, "MSG_SET_ABSOLUTE_VOLUME");
            if (mVolCmdSetInProgress || mVolCmdAdjustInProgress) {
                if (DEBUG)
                    Log.w(TAG, "There is already a volume command in progress.");
                break;
            }
            // Remote device didn't set initial volume. Let's black list it
            if (mInitialRemoteVolume == -1) {
                if (DEBUG)
                    Log.d(TAG, "remote " + mAddress + " never tell us initial volume, black list it.");
                blackListCurrentDevice();
                break;
            }
            int avrcpVolume = convertToAvrcpVolume(msg.arg1);
            avrcpVolume = Math.min(AVRCP_MAX_VOL, Math.max(0, avrcpVolume));
            if (DEBUG)
                Log.d(TAG, "Setting volume to " + msg.arg1 + "-" + avrcpVolume);
            if (setVolumeNative(avrcpVolume)) {
                sendMessageDelayed(obtainMessage(MSG_ABS_VOL_TIMEOUT), CMD_TIMEOUT_DELAY);
                mVolCmdSetInProgress = true;
                mLastRemoteVolume = avrcpVolume;
                mLastLocalVolume = msg.arg1;
            } else {
                if (DEBUG)
                    Log.d(TAG, "setVolumeNative failed");
            }
            break;
        case MSG_ABS_VOL_TIMEOUT:
            if (DEBUG)
                Log.v(TAG, "MSG_ABS_VOL_TIMEOUT: Volume change cmd timed out.");
            mVolCmdAdjustInProgress = false;
            mVolCmdSetInProgress = false;
            if (mAbsVolRetryTimes >= MAX_ERROR_RETRY_TIMES) {
                mAbsVolRetryTimes = 0;
                /* too many volume change failures, black list the device */
                blackListCurrentDevice();
            } else {
                mAbsVolRetryTimes += 1;
                if (setVolumeNative(mLastRemoteVolume)) {
                    sendMessageDelayed(obtainMessage(MSG_ABS_VOL_TIMEOUT), CMD_TIMEOUT_DELAY);
                    mVolCmdSetInProgress = true;
                }
            }
            break;
        case MSG_FAST_FORWARD:
        case MSG_REWIND:
            if (msg.what == MSG_FAST_FORWARD) {
                if ((mCurrentPlayState.getActions() & PlaybackState.ACTION_FAST_FORWARD) != 0) {
                    int keyState = msg.arg1 == AvrcpConstants.KEY_STATE_PRESS ? KeyEvent.ACTION_DOWN : KeyEvent.ACTION_UP;
                    KeyEvent keyEvent = new KeyEvent(keyState, KeyEvent.KEYCODE_MEDIA_FAST_FORWARD);
                    mMediaController.dispatchMediaButtonEvent(keyEvent);
                    break;
                }
            } else if ((mCurrentPlayState.getActions() & PlaybackState.ACTION_REWIND) != 0) {
                int keyState = msg.arg1 == AvrcpConstants.KEY_STATE_PRESS ? KeyEvent.ACTION_DOWN : KeyEvent.ACTION_UP;
                KeyEvent keyEvent = new KeyEvent(keyState, KeyEvent.KEYCODE_MEDIA_REWIND);
                mMediaController.dispatchMediaButtonEvent(keyEvent);
                break;
            }
            int skipAmount;
            int playStatus;
            if (msg.what == MSG_FAST_FORWARD) {
                if (DEBUG)
                    Log.v(TAG, "MSG_FAST_FORWARD");
                removeMessages(MSG_FAST_FORWARD);
                skipAmount = BASE_SKIP_AMOUNT;
                playStatus = PLAYSTATUS_FWD_SEEK;
            } else {
                if (DEBUG)
                    Log.v(TAG, "MSG_REWIND");
                removeMessages(MSG_REWIND);
                skipAmount = -BASE_SKIP_AMOUNT;
                playStatus = PLAYSTATUS_REV_SEEK;
            }
            if (hasMessages(MSG_CHANGE_PLAY_POS) && (skipAmount != mSkipAmount)) {
                Log.w(TAG, "missing release button event:" + mSkipAmount);
            }
            if ((!hasMessages(MSG_CHANGE_PLAY_POS)) || (skipAmount != mSkipAmount)) {
                mSkipStartTime = SystemClock.elapsedRealtime();
            }
            removeMessages(MSG_CHANGE_PLAY_POS);
            if (msg.arg1 == AvrcpConstants.KEY_STATE_PRESS) {
                mSkipAmount = skipAmount;
                changePositionBy(mSkipAmount * getSkipMultiplier());
                Message posMsg = obtainMessage(MSG_CHANGE_PLAY_POS);
                posMsg.arg1 = 1;
                sendMessageDelayed(posMsg, SKIP_PERIOD);
            }
            registerNotificationRspPlayStatusNative(AvrcpConstants.NOTIFICATION_TYPE_CHANGED, playStatus);
            break;
        case MSG_CHANGE_PLAY_POS:
            if (DEBUG)
                Log.v(TAG, "MSG_CHANGE_PLAY_POS:" + msg.arg1);
            changePositionBy(mSkipAmount * getSkipMultiplier());
            if (msg.arg1 * SKIP_PERIOD < BUTTON_TIMEOUT_TIME) {
                Message posMsg = obtainMessage(MSG_CHANGE_PLAY_POS);
                posMsg.arg1 = msg.arg1 + 1;
                sendMessageDelayed(posMsg, SKIP_PERIOD);
            }
            break;
        case MSG_SET_A2DP_AUDIO_STATE:
            if (DEBUG)
                Log.v(TAG, "MSG_SET_A2DP_AUDIO_STATE:" + msg.arg1);
            updateA2dpAudioState(msg.arg1);
            break;
        case MSG_NATIVE_REQ_GET_FOLDER_ITEMS:
            {
                AvrcpCmd.FolderItemsCmd folderObj = (AvrcpCmd.FolderItemsCmd) msg.obj;
                switch(folderObj.mScope) {
                    case AvrcpConstants.BTRC_SCOPE_PLAYER_LIST:
                        handleMediaPlayerListRsp(folderObj);
                        break;
                    case AvrcpConstants.BTRC_SCOPE_FILE_SYSTEM:
                    case AvrcpConstants.BTRC_SCOPE_NOW_PLAYING:
                        handleGetFolderItemBrowseResponse(folderObj, folderObj.mAddress);
                        break;
                    default:
                        Log.e(TAG, "unknown scope for getfolderitems. scope = " + folderObj.mScope);
                        getFolderItemsRspNative(folderObj.mAddress, AvrcpConstants.RSP_INV_SCOPE, (short) 0, (byte) 0, 0, null, null, null, null, null, null, null, null);
                }
                break;
            }
        case MSG_NATIVE_REQ_SET_ADDR_PLAYER:
            // object is bdaddr, argument 1 is the selected player id
            setAddressedPlayer((byte[]) msg.obj, msg.arg1);
            break;
        case MSG_NATIVE_REQ_GET_ITEM_ATTR:
            // msg object contains the item attribute object
            handleGetItemAttr((AvrcpCmd.ItemAttrCmd) msg.obj);
            break;
        case MSG_NATIVE_REQ_SET_BR_PLAYER:
            // argument 1 is the selected player id
            setBrowsedPlayer((byte[]) msg.obj, msg.arg1);
            break;
        case MSG_NATIVE_REQ_CHANGE_PATH:
            {
                Bundle data = msg.getData();
                byte[] bdaddr = data.getByteArray("BdAddress");
                byte[] folderUid = data.getByteArray("folderUid");
                byte direction = data.getByte("direction");
                if (mAvrcpBrowseManager.getBrowsedMediaPlayer(bdaddr) != null) {
                    mAvrcpBrowseManager.getBrowsedMediaPlayer(bdaddr).changePath(folderUid, direction);
                } else {
                    Log.e(TAG, "Remote requesting change path before setbrowsedplayer");
                    changePathRspNative(bdaddr, AvrcpConstants.RSP_BAD_CMD, 0);
                }
                break;
            }
        case MSG_NATIVE_REQ_PLAY_ITEM:
            {
                Bundle data = msg.getData();
                byte[] bdaddr = data.getByteArray("BdAddress");
                byte[] uid = data.getByteArray("uid");
                byte scope = data.getByte("scope");
                handlePlayItemResponse(bdaddr, uid, scope);
                break;
            }
        case MSG_NATIVE_REQ_GET_TOTAL_NUM_OF_ITEMS:
            // argument 1 is scope, object is bdaddr
            handleGetTotalNumOfItemsResponse((byte[]) msg.obj, (byte) msg.arg1);
            break;
        case MSG_NATIVE_REQ_PASS_THROUGH:
            // argument 1 is id, argument 2 is keyState, object is bdaddr
            mAddressedMediaPlayer.handlePassthroughCmd(msg.arg1, msg.arg2, (byte[]) msg.obj, mMediaController);
            break;
        default:
            Log.e(TAG, "unknown message! msg.what=" + msg.what);
            break;
    }
}
#end_block

#method_before
private void updateA2dpAudioState(int state) {
    boolean isPlaying = (state == BluetoothA2dp.STATE_PLAYING);
    if (isPlaying != isPlayingState(mCurrentPlayState)) {
        /* if a2dp is streaming, check to make sure music is active */
        if (isPlaying && !mAudioManager.isMusicActive())
            return;
        PlaybackState.Builder builder = new PlaybackState.Builder();
        if (isPlaying) {
            builder.setState(PlaybackState.STATE_PLAYING, PlaybackState.PLAYBACK_POSITION_UNKNOWN, 1.0f);
        } else {
            builder.setState(PlaybackState.STATE_PAUSED, PlaybackState.PLAYBACK_POSITION_UNKNOWN, 0.0f);
        }
        updatePlayPauseState(builder.build());
    }
}
#method_after
private void updateA2dpAudioState(int state) {
    boolean isPlaying = (state == BluetoothA2dp.STATE_PLAYING);
    if (isPlaying != isPlayingState(mCurrentPlayState)) {
        /* if a2dp is streaming, check to make sure music is active */
        if (isPlaying && !mAudioManager.isMusicActive())
            return;
        PlaybackState.Builder builder = new PlaybackState.Builder();
        if (isPlaying) {
            builder.setState(PlaybackState.STATE_PLAYING, PlaybackState.PLAYBACK_POSITION_UNKNOWN, 1.0f);
        } else {
            builder.setState(PlaybackState.STATE_PAUSED, PlaybackState.PLAYBACK_POSITION_UNKNOWN, 0.0f);
        }
        updatePlaybackState(builder.build());
    }
}
#end_block

#method_before
private void updateMetadata(MediaMetadata data) {
    String oldMetadata = mMetadata.toString();
    if (data == null) {
        mMetadata = new Metadata();
        mSongLengthMs = 0L;
    } else {
        mMetadata.artist = data.getString(MediaMetadata.METADATA_KEY_ARTIST);
        mMetadata.trackTitle = data.getString(MediaMetadata.METADATA_KEY_TITLE);
        mMetadata.albumTitle = data.getString(MediaMetadata.METADATA_KEY_ALBUM);
        mSongLengthMs = data.getLong(MediaMetadata.METADATA_KEY_DURATION);
    }
    if (!oldMetadata.equals(mMetadata.toString())) {
        Log.v(TAG, "Metadata Changed to " + mMetadata.toString());
        mTrackNumber++;
        if (mTrackChangedNT == AvrcpHalConstants.NOTIFICATION_TYPE_INTERIM) {
            mTrackChangedNT = AvrcpHalConstants.NOTIFICATION_TYPE_CHANGED;
            sendTrackChangedRsp();
        }
        if (mCurrentPosMs != PlaybackState.PLAYBACK_POSITION_UNKNOWN && isPlayingState(mCurrentPlayState)) {
            mPlayStartTimeMs = SystemClock.elapsedRealtime();
        }
        /* need to send play position changed notification when track is changed */
        if (mPlayPosChangedNT == AvrcpHalConstants.NOTIFICATION_TYPE_INTERIM) {
            mPlayPosChangedNT = AvrcpHalConstants.NOTIFICATION_TYPE_CHANGED;
            registerNotificationRspPlayPosNative(mPlayPosChangedNT, (int) getPlayPosition());
            mHandler.removeMessages(MESSAGE_PLAY_INTERVAL_TIMEOUT);
        }
    } else {
        Log.v(TAG, "Updated " + mMetadata.toString() + " but no change!");
    }
}
#method_after
private void updateMetadata(MediaMetadata data) {
    MediaAttributes oldAttributes = mMediaAttributes;
    mMediaAttributes = new MediaAttributes(data);
    if (data == null) {
        mSongLengthMs = 0L;
    } else {
        mSongLengthMs = data.getLong(MediaMetadata.METADATA_KEY_DURATION);
    }
    if (!oldAttributes.equals(mMediaAttributes)) {
        Log.v(TAG, "MediaAttributes Changed to " + mMediaAttributes.toString());
        mTrackNumber++;
        if (mTrackChangedNT == AvrcpConstants.NOTIFICATION_TYPE_INTERIM) {
            mTrackChangedNT = AvrcpConstants.NOTIFICATION_TYPE_CHANGED;
            sendTrackChangedRsp();
        }
    } else {
        Log.v(TAG, "Updated " + mMediaAttributes.toString() + " but no change!");
    }
    // notifications if needed.
    if (mMediaController != null) {
        updatePlaybackState(mMediaController.getPlaybackState());
    } else {
        updatePlaybackState(null);
    }
}
#end_block

#method_before
private void processRegisterNotification(byte[] address, int eventId, int param) {
    switch(eventId) {
        case EVT_PLAY_STATUS_CHANGED:
            mPlayStatusChangedNT = AvrcpHalConstants.NOTIFICATION_TYPE_INTERIM;
            registerNotificationRspPlayStatusNative(mPlayStatusChangedNT, convertPlayStateToPlayStatus(mCurrentPlayState));
            break;
        case EVT_TRACK_CHANGED:
            Log.v(TAG, "Track changed notification enabled");
            mTrackChangedNT = AvrcpHalConstants.NOTIFICATION_TYPE_INTERIM;
            sendTrackChangedRsp();
            break;
        case EVT_PLAY_POS_CHANGED:
            long songPosition = getPlayPosition();
            mPlayPosChangedNT = AvrcpHalConstants.NOTIFICATION_TYPE_INTERIM;
            mPlaybackIntervalMs = (long) param * 1000L;
            if (mCurrentPosMs != PlaybackState.PLAYBACK_POSITION_UNKNOWN) {
                mNextPosMs = songPosition + mPlaybackIntervalMs;
                mPrevPosMs = songPosition - mPlaybackIntervalMs;
                if (isPlayingState(mCurrentPlayState)) {
                    Message msg = mHandler.obtainMessage(MESSAGE_PLAY_INTERVAL_TIMEOUT);
                    mHandler.sendMessageDelayed(msg, mPlaybackIntervalMs);
                }
            }
            registerNotificationRspPlayPosNative(mPlayPosChangedNT, (int) songPosition);
            break;
        case EVT_AVBL_PLAYERS_CHANGED:
            /* Notify remote available players changed */
            if (DEBUG)
                Log.d(TAG, "sending availablePlayersChanged to remote ");
            registerNotificationRspAvalPlayerChangedNative(AvrcpHalConstants.NOTIFICATION_TYPE_INTERIM);
            break;
        case EVT_ADDR_PLAYER_CHANGED:
            /* Notify remote addressed players changed */
            if (DEBUG)
                Log.d(TAG, "sending addressedPlayersChanged to remote ");
            registerNotificationRspAddrPlayerChangedNative(AvrcpHalConstants.NOTIFICATION_TYPE_INTERIM, mCurrAddrPlayerID, sUIDCounter);
            break;
        case EVENT_UIDS_CHANGED:
            if (DEBUG)
                Log.d(TAG, "sending UIDs changed to remote");
            registerNotificationRspUIDsChangedNative(AvrcpHalConstants.NOTIFICATION_TYPE_INTERIM, sUIDCounter);
            break;
        case EVENT_NOW_PLAYING_CONTENT_CHANGED:
            if (DEBUG)
                Log.d(TAG, "sending NowPlayingList changed to remote");
            /* send interim response to remote device */
            if (!registerNotificationRspNowPlayingChangedNative(AvrcpHalConstants.NOTIFICATION_TYPE_INTERIM)) {
                Log.e(TAG, "EVENT_NOW_PLAYING_CONTENT_CHANGED: " + "registerNotificationRspNowPlayingChangedNative for Interim rsp failed!");
            }
            break;
    }
}
#method_after
private void processRegisterNotification(byte[] address, int eventId, int param) {
    switch(eventId) {
        case EVT_PLAY_STATUS_CHANGED:
            mPlayStatusChangedNT = AvrcpConstants.NOTIFICATION_TYPE_INTERIM;
            registerNotificationRspPlayStatusNative(mPlayStatusChangedNT, convertPlayStateToPlayStatus(mCurrentPlayState));
            break;
        case EVT_TRACK_CHANGED:
            Log.v(TAG, "Track changed notification enabled");
            mTrackChangedNT = AvrcpConstants.NOTIFICATION_TYPE_INTERIM;
            sendTrackChangedRsp();
            break;
        case EVT_PLAY_POS_CHANGED:
            mPlayPosChangedNT = AvrcpConstants.NOTIFICATION_TYPE_INTERIM;
            mPlaybackIntervalMs = (long) param * 1000L;
            sendPlayPosNotificationRsp(true);
            break;
        case EVT_AVBL_PLAYERS_CHANGED:
            /* Notify remote available players changed */
            if (DEBUG)
                Log.d(TAG, "sending availablePlayersChanged to remote ");
            registerNotificationRspAvalPlayerChangedNative(AvrcpConstants.NOTIFICATION_TYPE_INTERIM);
            break;
        case EVT_ADDR_PLAYER_CHANGED:
            /* Notify remote addressed players changed */
            if (DEBUG)
                Log.d(TAG, "sending addressedPlayersChanged to remote ");
            registerNotificationRspAddrPlayerChangedNative(AvrcpConstants.NOTIFICATION_TYPE_INTERIM, mCurrAddrPlayerID, sUIDCounter);
            break;
        case EVENT_UIDS_CHANGED:
            if (DEBUG)
                Log.d(TAG, "sending UIDs changed to remote");
            registerNotificationRspUIDsChangedNative(AvrcpConstants.NOTIFICATION_TYPE_INTERIM, sUIDCounter);
            break;
        case EVENT_NOW_PLAYING_CONTENT_CHANGED:
            if (DEBUG)
                Log.d(TAG, "sending NowPlayingList changed to remote");
            /* send interim response to remote device */
            if (!registerNotificationRspNowPlayingChangedNative(AvrcpConstants.NOTIFICATION_TYPE_INTERIM)) {
                Log.e(TAG, "EVENT_NOW_PLAYING_CONTENT_CHANGED: " + "registerNotificationRspNowPlayingChangedNative for Interim rsp failed!");
            }
            break;
    }
}
#end_block

#method_before
private void fastForward(byte[] address, int keyState) {
    Message msg = mHandler.obtainMessage(MESSAGE_FAST_FORWARD, keyState, 0);
    Bundle data = new Bundle();
    data.putByteArray("BdAddress", address);
    msg.setData(data);
    mHandler.sendMessage(msg);
}
#method_after
private void fastForward(byte[] address, int keyState) {
    Message msg = mHandler.obtainMessage(MSG_FAST_FORWARD, keyState, 0);
    Bundle data = new Bundle();
    data.putByteArray("BdAddress", address);
    msg.setData(data);
    mHandler.sendMessage(msg);
}
#end_block

#method_before
private void rewind(byte[] address, int keyState) {
    Message msg = mHandler.obtainMessage(MESSAGE_REWIND, keyState, 0);
    Bundle data = new Bundle();
    data.putByteArray("BdAddress", address);
    msg.setData(data);
    mHandler.sendMessage(msg);
}
#method_after
private void rewind(byte[] address, int keyState) {
    Message msg = mHandler.obtainMessage(MSG_REWIND, keyState, 0);
    Bundle data = new Bundle();
    data.putByteArray("BdAddress", address);
    msg.setData(data);
    mHandler.sendMessage(msg);
}
#end_block

#method_before
private void trackChangeRspForBrowseUnsupported() {
    byte[] track = new byte[AvrcpHalConstants.TRACK_ID_SIZE];
    /* track is stored in big endian format */
    for (int idx = 0; idx < AvrcpHalConstants.TRACK_ID_SIZE; ++idx) {
        if (mTrackChangedNT == AvrcpHalConstants.NOTIFICATION_TYPE_INTERIM && mTrackNumber == -1) {
            /* if no track is currently selected then return 0xFF in interim response */
            track[idx] = AvrcpHalConstants.NO_TRACK_SELECTED;
        } else {
            /* if Browsing is not supported and a track is selected, then return 0x00 */
            track[idx] = AvrcpHalConstants.TRACK_IS_SELECTED;
        }
    }
    registerNotificationRspTrackChangeNative(mTrackChangedNT, track);
}
#method_after
private void trackChangeRspForBrowseUnsupported() {
    byte[] track = new byte[AvrcpConstants.TRACK_ID_SIZE];
    /* track is stored in big endian format */
    for (int idx = 0; idx < AvrcpConstants.TRACK_ID_SIZE; ++idx) {
        if (mTrackChangedNT == AvrcpConstants.NOTIFICATION_TYPE_INTERIM && mTrackNumber == -1) {
            /* if no track is currently selected then return 0xFF in interim response */
            track[idx] = AvrcpConstants.NO_TRACK_SELECTED;
        } else {
            /* if Browsing is not supported and a track is selected, then return 0x00 */
            track[idx] = AvrcpConstants.TRACK_IS_SELECTED;
        }
    }
    registerNotificationRspTrackChangeNative(mTrackChangedNT, track);
}
#end_block

#method_before
private long getPlayPosition() {
    long songPosition = -1L;
    if (mCurrentPosMs != PlaybackState.PLAYBACK_POSITION_UNKNOWN) {
        if (mCurrentPlayState.getState() == PlaybackState.STATE_PLAYING) {
            songPosition = SystemClock.elapsedRealtime() - mPlayStartTimeMs + mCurrentPosMs;
        } else {
            songPosition = mCurrentPosMs;
        }
    }
    if (DEBUG)
        Log.v(TAG, "position=" + songPosition);
    return songPosition;
}
#method_after
private long getPlayPosition() {
    if (mCurrentPlayState == null) {
        return -1L;
    }
    if (mCurrentPlayState.getPosition() == PlaybackState.PLAYBACK_POSITION_UNKNOWN) {
        return -1L;
    }
    if (isPlayingState(mCurrentPlayState)) {
        return SystemClock.elapsedRealtime() - mLastStateUpdate + mCurrentPlayState.getPosition();
    }
    return mCurrentPlayState.getPosition();
}
#end_block

#method_before
public void adjustVolume(int direction) {
    Message msg = mHandler.obtainMessage(MESSAGE_ADJUST_VOLUME, direction, 0);
    mHandler.sendMessage(msg);
}
#method_after
public void adjustVolume(int direction) {
    Message msg = mHandler.obtainMessage(MSG_ADJUST_VOLUME, direction, 0);
    mHandler.sendMessage(msg);
}
#end_block

#method_before
public void setAbsoluteVolume(int volume) {
    if (volume == mLocalVolume) {
        if (DEBUG)
            Log.v(TAG, "setAbsoluteVolume is setting same index, ignore " + volume);
        return;
    }
    mHandler.removeMessages(MESSAGE_ADJUST_VOLUME);
    Message msg = mHandler.obtainMessage(MESSAGE_SET_ABSOLUTE_VOLUME, volume, 0);
    mHandler.sendMessage(msg);
}
#method_after
public void setAbsoluteVolume(int volume) {
    if (volume == mLocalVolume) {
        if (DEBUG)
            Log.v(TAG, "setAbsoluteVolume is setting same index, ignore " + volume);
        return;
    }
    mHandler.removeMessages(MSG_ADJUST_VOLUME);
    Message msg = mHandler.obtainMessage(MSG_SET_ABSOLUTE_VOLUME, volume, 0);
    mHandler.sendMessage(msg);
}
#end_block

#method_before
public void setA2dpAudioState(int state) {
    Message msg = mHandler.obtainMessage(MESSAGE_SET_A2DP_AUDIO_STATE, state, 0);
    mHandler.sendMessage(msg);
}
#method_after
public void setA2dpAudioState(int state) {
    Message msg = mHandler.obtainMessage(MSG_SET_A2DP_AUDIO_STATE, state, 0);
    mHandler.sendMessage(msg);
}
#end_block

#method_before
private synchronized int getBrowseId(String packageName) {
    boolean response = false;
    int browseInfoID = 0;
    for (BrowsePlayerInfo _info : mBrowsePlayerInfoList) {
        if (_info.packageName.equals(packageName)) {
            response = true;
            break;
        }
        browseInfoID++;
    }
    if (!response) {
        browseInfoID = -1;
    }
    if (DEBUG)
        Log.d(TAG, "getBrowseId for packageName: " + packageName + " , browseInfoID: " + browseInfoID);
    return browseInfoID;
}
#method_after
private synchronized int getBrowseId(String packageName) {
    boolean response = false;
    int browseInfoID = 0;
    for (BrowsePlayerInfo info : mBrowsePlayerInfoList) {
        if (info.packageName.equals(packageName)) {
            response = true;
            break;
        }
        browseInfoID++;
    }
    if (!response) {
        browseInfoID = -1;
    }
    if (DEBUG)
        Log.d(TAG, "getBrowseId for packageName: " + packageName + " , browseInfoID: " + browseInfoID);
    return browseInfoID;
}
#end_block

#method_before
private void setAddressedPlayer(byte[] bdaddr, int selectedId) {
    int status = AvrcpHalConstants.BTRC_STS_NO_ERROR;
    if (isCurrentMediaPlayerListEmpty()) {
        status = AvrcpHalConstants.BTRC_STS_NO_AVBL_PLAY;
        Log.w(TAG, " No Available Players to set, sending response back ");
    } else if (!isIdValid(selectedId)) {
        status = AvrcpHalConstants.BTRC_STS_INV_PLAYER;
        Log.w(TAG, " Invalid Player id: " + selectedId + " to set, sending response back ");
    } else if (!isPlayerAlreadyAddressed(selectedId)) {
        // register new Media Controller Callback and update the current Ids
        if (!updateCurrentController(selectedId, mCurrBrowsePlayerID)) {
            status = AvrcpHalConstants.BTRC_STS_INTERNAL_ERR;
            Log.e(TAG, "register for new Address player failed: " + mCurrAddrPlayerID);
        }
    } else {
        Log.i(TAG, "requested addressPlayer is already focused:" + getCurrentAddrPlayer());
    }
    if (DEBUG)
        Log.d(TAG, "setAddressedPlayer for selectedId: " + selectedId + " , status: " + status);
    // Sending address player response to remote
    setAddressedPlayerRspNative(bdaddr, status);
}
#method_after
private void setAddressedPlayer(byte[] bdaddr, int selectedId) {
    int status = AvrcpConstants.RSP_NO_ERROR;
    if (isCurrentMediaPlayerListEmpty()) {
        status = AvrcpConstants.RSP_NO_AVBL_PLAY;
        Log.w(TAG, " No Available Players to set, sending response back ");
    } else if (!isIdValid(selectedId)) {
        status = AvrcpConstants.RSP_INV_PLAYER;
        Log.w(TAG, " Invalid Player id: " + selectedId + " to set, sending response back ");
    } else if (!isPlayerAlreadyAddressed(selectedId)) {
        // register new Media Controller Callback and update the current Ids
        if (!updateCurrentController(selectedId, mCurrBrowsePlayerID)) {
            status = AvrcpConstants.RSP_INTERNAL_ERR;
            Log.e(TAG, "register for new Address player failed: " + mCurrAddrPlayerID);
        }
    } else {
        Log.i(TAG, "requested addressPlayer is already focused:" + getCurrentAddrPlayer());
    }
    if (DEBUG)
        Log.d(TAG, "setAddressedPlayer for selectedId: " + selectedId + " , status: " + status);
    // Sending address player response to remote
    setAddressedPlayerRspNative(bdaddr, status);
}
#end_block

#method_before
private void setBrowsedPlayer(byte[] bdaddr, int selectedId) {
    int status = AvrcpHalConstants.BTRC_STS_NO_ERROR;
    // checking for error cases
    if (isCurrentMediaPlayerListEmpty()) {
        status = AvrcpHalConstants.BTRC_STS_NO_AVBL_PLAY;
        Log.w(TAG, " No Available Players to set, sending response back ");
    } else {
        // update current browse player id and start browsing service
        updateNewIds(mCurrAddrPlayerID, selectedId);
        String browsedPackage = getPackageName(selectedId);
        if (!isPackageNameValid(browsedPackage)) {
            Log.w(TAG, " Invalid package for id:" + mCurrBrowsePlayerID);
            status = AvrcpHalConstants.BTRC_STS_INV_PLAYER;
        } else if (!isBrowseSupported(browsedPackage)) {
            Log.w(TAG, "Browse unsupported for id:" + mCurrBrowsePlayerID + ", packagename : " + browsedPackage);
            status = AvrcpHalConstants.BTRC_STS_PLAY_NOT_BROW;
        } else if (!startBrowseService(bdaddr, browsedPackage)) {
            Log.e(TAG, "service cannot be started for browse player id:" + mCurrBrowsePlayerID + ", packagename : " + browsedPackage);
            status = AvrcpHalConstants.BTRC_STS_INTERNAL_ERR;
        }
    }
    if (status != AvrcpHalConstants.BTRC_STS_NO_ERROR) {
        setBrowsedPlayerRspNative(bdaddr, status, (byte) 0x00, 0, null);
    }
    if (DEBUG)
        Log.d(TAG, "setBrowsedPlayer for selectedId: " + selectedId + " , status: " + status);
}
#method_after
private void setBrowsedPlayer(byte[] bdaddr, int selectedId) {
    int status = AvrcpConstants.RSP_NO_ERROR;
    // checking for error cases
    if (isCurrentMediaPlayerListEmpty()) {
        status = AvrcpConstants.RSP_NO_AVBL_PLAY;
        Log.w(TAG, " No Available Players to set, sending response back ");
    } else {
        // update current browse player id and start browsing service
        updateNewIds(mCurrAddrPlayerID, selectedId);
        String browsedPackage = getPackageName(selectedId);
        if (!isPackageNameValid(browsedPackage)) {
            Log.w(TAG, " Invalid package for id:" + mCurrBrowsePlayerID);
            status = AvrcpConstants.RSP_INV_PLAYER;
        } else if (!isBrowseSupported(browsedPackage)) {
            Log.w(TAG, "Browse unsupported for id:" + mCurrBrowsePlayerID + ", packagename : " + browsedPackage);
            status = AvrcpConstants.RSP_PLAY_NOT_BROW;
        } else if (!startBrowseService(bdaddr, browsedPackage)) {
            Log.e(TAG, "service cannot be started for browse player id:" + mCurrBrowsePlayerID + ", packagename : " + browsedPackage);
            status = AvrcpConstants.RSP_INTERNAL_ERR;
        }
    }
    if (status != AvrcpConstants.RSP_NO_ERROR) {
        setBrowsedPlayerRspNative(bdaddr, status, (byte) 0x00, 0, null);
    }
    if (DEBUG)
        Log.d(TAG, "setBrowsedPlayer for selectedId: " + selectedId + " , status: " + status);
}
#end_block

#method_before
private boolean startBrowseService(byte[] bdaddr, String packageName) {
    boolean status = true;
    /* creating new instance for Browse Media Player */
    String browseService = getBrowseServiceName(packageName);
    if (!browseService.isEmpty()) {
        mAvrcpBrowseManager.getBrowseMediaPlayer(bdaddr).setBrowsed(packageName, browseService);
    } else {
        Log.w(TAG, "No Browser service available for " + packageName);
        status = false;
    }
    if (DEBUG)
        Log.d(TAG, "startBrowseService for packageName: " + packageName + ", status = " + status);
    return status;
}
#method_after
private boolean startBrowseService(byte[] bdaddr, String packageName) {
    boolean status = true;
    /* creating new instance for Browse Media Player */
    String browseService = getBrowseServiceName(packageName);
    if (!browseService.isEmpty()) {
        mAvrcpBrowseManager.getBrowsedMediaPlayer(bdaddr).setBrowsed(packageName, browseService);
    } else {
        Log.w(TAG, "No Browser service available for " + packageName);
        status = false;
    }
    if (DEBUG)
        Log.d(TAG, "startBrowseService for packageName: " + packageName + ", status = " + status);
    return status;
}
#end_block

#method_before
private synchronized void buildBrowsablePlayersList() {
    if (DEBUG)
        Log.i(TAG, "buildBrowsablePlayersList()");
    // Clearing old browsable player's list
    mBrowsePlayerInfoList.clear();
    Intent intent = new Intent("android.media.browse.MediaBrowserService");
    List<ResolveInfo> resInfos = mPackageManager.queryIntentServices(intent, 0);
    for (ResolveInfo resolveInfo : resInfos) {
        String displayableName = resolveInfo.loadLabel(mPackageManager).toString();
        String serviceName = resolveInfo.serviceInfo.name;
        String packageName = resolveInfo.serviceInfo.packageName;
        BrowsePlayerInfo infoObj = new BrowsePlayerInfo(packageName, displayableName, serviceName);
        if (DEBUG)
            Log.d(TAG, infoObj.toString());
        mBrowsePlayerInfoList.add(infoObj);
    }
    if (DEBUG)
        Log.i(TAG, "buildBrowsablePlayersList: found " + resInfos.size() + " players");
}
#method_after
private synchronized void buildBrowsablePlayersList() {
    if (DEBUG)
        Log.i(TAG, "buildBrowsablePlayersList()");
    // Clearing old browsable player's list
    mBrowsePlayerInfoList.clear();
    Intent intent = new Intent(android.service.media.MediaBrowserService.SERVICE_INTERFACE);
    List<ResolveInfo> resInfos = mPackageManager.queryIntentServices(intent, 0);
    for (ResolveInfo resolveInfo : resInfos) {
        String displayableName = resolveInfo.loadLabel(mPackageManager).toString();
        String serviceName = resolveInfo.serviceInfo.name;
        String packageName = resolveInfo.serviceInfo.packageName;
        BrowsePlayerInfo infoObj = new BrowsePlayerInfo(packageName, displayableName, serviceName);
        if (DEBUG)
            Log.d(TAG, infoObj.toString());
        mBrowsePlayerInfoList.add(infoObj);
    }
    if (DEBUG)
        Log.i(TAG, "buildBrowsablePlayersList: found " + resInfos.size() + " players");
}
#end_block

#method_before
private synchronized void initMediaPlayersInfoList() {
    if (DEBUG)
        Log.v(TAG, "initMediaPlayersInfoList");
    // Clearing old browsable player's list
    mMediaPlayerInfoList.clear();
    /* Initializing all media players */
    for (MediaController _mediaController : getActiveControllersList()) {
        initMediaPlayer(_mediaController);
    }
}
#method_after
private synchronized void initMediaPlayersInfoList() {
    if (DEBUG)
        Log.v(TAG, "initMediaPlayersInfoList");
    // Clearing old browsable player's list
    mMediaPlayerInfoList.clear();
    /* Initializing all media players */
    for (MediaController mediaController : getActiveControllersList()) {
        initMediaPlayer(mediaController);
    }
}
#end_block

#method_before
private synchronized void initMediaPlayer(MediaController _mediaController) {
    String packageName = _mediaController.getPackageName();
    MediaPlayerInfo mMediaPlayerInfo = new MediaPlayerInfo(packageName, AvrcpHalConstants.PLAYER_TYPE_AUDIO, AvrcpHalConstants.PLAYER_SUBTYPE_NONE, getPlayBackState(_mediaController), getFeatureBitMask(packageName), getAppLabel(packageName), _mediaController);
    if (DEBUG)
        Log.d(TAG, mMediaPlayerInfo.toString());
    mMediaPlayerInfoList.add(mMediaPlayerInfo);
}
#method_after
private synchronized void initMediaPlayer(MediaController mediaController) {
    String packageName = mediaController.getPackageName();
    MediaPlayerInfo mMediaPlayerInfo = new MediaPlayerInfo(packageName, AvrcpConstants.PLAYER_TYPE_AUDIO, AvrcpConstants.PLAYER_SUBTYPE_NONE, getPlayBackState(mediaController), getFeatureBitMask(packageName), getAppLabel(packageName), mediaController);
    if (DEBUG)
        Log.d(TAG, mMediaPlayerInfo.toString());
    mMediaPlayerInfoList.add(mMediaPlayerInfo);
}
#end_block

#method_before
private byte getPlayBackState(MediaController _MediaController) {
    PlaybackState pbState = _MediaController.getPlaybackState();
    byte playStateBytes = PLAYSTATUS_STOPPED;
    if (pbState != null) {
        playStateBytes = (byte) convertPlayStateToBytes(pbState.getState());
        Log.v(TAG, "getPlayBackState: playStateBytes = " + playStateBytes);
    } else {
        Log.w(TAG, "playState object null, sending playStateBytes = " + playStateBytes);
    }
    return playStateBytes;
}
#method_after
private byte getPlayBackState(MediaController mediaController) {
    PlaybackState pbState = mediaController.getPlaybackState();
    byte playStateBytes = PLAYSTATUS_STOPPED;
    if (pbState != null) {
        playStateBytes = (byte) convertPlayStateToBytes(pbState.getState());
        Log.v(TAG, "getPlayBackState: playStateBytes = " + playStateBytes);
    } else {
        Log.w(TAG, "playState object null, sending playStateBytes = " + playStateBytes);
    }
    return playStateBytes;
}
#end_block

#method_before
private short[] getFeatureBitMask(String packageName) {
    ArrayList<Short> featureBitsList = new ArrayList<Short>();
    /* adding default feature bits */
    featureBitsList.add(AvrcpHalConstants.AVRC_PF_PLAY_BIT_NO);
    featureBitsList.add(AvrcpHalConstants.AVRC_PF_STOP_BIT_NO);
    featureBitsList.add(AvrcpHalConstants.AVRC_PF_PAUSE_BIT_NO);
    featureBitsList.add(AvrcpHalConstants.AVRC_PF_REWIND_BIT_NO);
    featureBitsList.add(AvrcpHalConstants.AVRC_PF_FAST_FWD_BIT_NO);
    featureBitsList.add(AvrcpHalConstants.AVRC_PF_FORWARD_BIT_NO);
    featureBitsList.add(AvrcpHalConstants.AVRC_PF_BACKWARD_BIT_NO);
    /* Add/Modify browse player supported features. */
    if (isBrowseSupported(packageName)) {
        featureBitsList.add(AvrcpHalConstants.AVRC_PF_ADV_CTRL_BIT_NO);
        featureBitsList.add(AvrcpHalConstants.AVRC_PF_BROWSE_BIT_NO);
        featureBitsList.add(AvrcpHalConstants.AVRC_PF_UID_UNIQUE_BIT_NO);
        featureBitsList.add(AvrcpHalConstants.AVRC_PF_NOW_PLAY_BIT_NO);
    }
    // converting arraylist to array for response
    short[] featureBitsArray = new short[featureBitsList.size()];
    for (int i = 0; i < featureBitsList.size(); i++) {
        featureBitsArray[i] = featureBitsList.get(i).shortValue();
    }
    return featureBitsArray;
}
#method_after
private short[] getFeatureBitMask(String packageName) {
    ArrayList<Short> featureBitsList = new ArrayList<Short>();
    /* adding default feature bits */
    featureBitsList.add(AvrcpConstants.AVRC_PF_PLAY_BIT_NO);
    featureBitsList.add(AvrcpConstants.AVRC_PF_STOP_BIT_NO);
    featureBitsList.add(AvrcpConstants.AVRC_PF_PAUSE_BIT_NO);
    featureBitsList.add(AvrcpConstants.AVRC_PF_REWIND_BIT_NO);
    featureBitsList.add(AvrcpConstants.AVRC_PF_FAST_FWD_BIT_NO);
    featureBitsList.add(AvrcpConstants.AVRC_PF_FORWARD_BIT_NO);
    featureBitsList.add(AvrcpConstants.AVRC_PF_BACKWARD_BIT_NO);
    featureBitsList.add(AvrcpConstants.AVRC_PF_ADV_CTRL_BIT_NO);
    /* Add/Modify browse player supported features. */
    if (isBrowseSupported(packageName)) {
        featureBitsList.add(AvrcpConstants.AVRC_PF_BROWSE_BIT_NO);
        featureBitsList.add(AvrcpConstants.AVRC_PF_UID_UNIQUE_BIT_NO);
        featureBitsList.add(AvrcpConstants.AVRC_PF_NOW_PLAY_BIT_NO);
        featureBitsList.add(AvrcpConstants.AVRC_PF_GET_NUM_OF_ITEMS_BIT_NO);
    }
    // converting arraylist to array for response
    short[] featureBitsArray = new short[featureBitsList.size()];
    for (int i = 0; i < featureBitsList.size(); i++) {
        featureBitsArray[i] = featureBitsList.get(i).shortValue();
    }
    return featureBitsArray;
}
#end_block

#method_before
private synchronized boolean isBrowseSupported(String packageName) {
    boolean response = false;
    /* check if Browsable Player's list contains this package name */
    for (BrowsePlayerInfo _info : mBrowsePlayerInfoList) {
        if (_info.packageName.equals(packageName))
            response = true;
    }
    if (DEBUG)
        Log.v(TAG, "isBrowseSupported for " + packageName + ": " + response);
    return response;
}
#method_after
private synchronized boolean isBrowseSupported(String packageName) {
    boolean response = false;
    /* check if Browsable Player's list contains this package name */
    for (BrowsePlayerInfo info : mBrowsePlayerInfoList) {
        if (info.packageName.equals(packageName)) {
            // TODO: (apanicke) Currently browsing isn't implemented
            // properly and causes metadata to break. Fix browsing
            // interface and change this to true.
            response = false;
        }
    }
    if (DEBUG)
        Log.v(TAG, "isBrowseSupported for " + packageName + ": " + response);
    return response;
}
#end_block

#method_before
private String getCurrentBrowsedPlayer(byte[] bdaddr) {
    String browsedPlayerPackage = "";
    Map<String, BrowseMediaPlayer> connList = mAvrcpBrowseManager.getConnList();
    String bdaddrStr = new String(bdaddr);
    if (connList.containsKey(bdaddrStr)) {
        browsedPlayerPackage = connList.get(bdaddrStr).getPackageName();
    }
    if (DEBUG)
        Log.v(TAG, "getCurrentBrowsedPlayerPackage: " + browsedPlayerPackage);
    return browsedPlayerPackage;
}
#method_after
private String getCurrentBrowsedPlayer(byte[] bdaddr) {
    String browsedPlayerPackage = "";
    Map<String, BrowsedMediaPlayer> connList = mAvrcpBrowseManager.getConnList();
    String bdaddrStr = new String(bdaddr);
    if (connList.containsKey(bdaddrStr)) {
        browsedPlayerPackage = connList.get(bdaddrStr).getPackageName();
    }
    if (DEBUG)
        Log.v(TAG, "getCurrentBrowsedPlayerPackage: " + browsedPlayerPackage);
    return browsedPlayerPackage;
}
#end_block

#method_before
private synchronized MediaPlayerInfo getMediaPlayerInfo(String packageName) {
    if (DEBUG)
        Log.v(TAG, "getMediaPlayerInfo: " + packageName);
    if (mMediaPlayerInfoList.size() > 0) {
        final Iterator<MediaPlayerInfo> rccIterator = mMediaPlayerInfoList.iterator();
        while (rccIterator.hasNext()) {
            final MediaPlayerInfo mpi = rccIterator.next();
            if (packageName.equals(mpi.getPackageName())) {
                if (DEBUG)
                    Log.v(TAG, "Found " + mpi.getPackageName());
                return mpi;
            }
        }
    } else {
        if (DEBUG)
            Log.v(TAG, "Media players list empty");
    }
    return null;
}
#method_after
private synchronized MediaPlayerInfo getMediaPlayerInfo(String packageName) {
    if (DEBUG)
        Log.v(TAG, "getMediaPlayerInfo: " + packageName);
    if (mMediaPlayerInfoList.size() > 0) {
        for (MediaPlayerInfo info : mMediaPlayerInfoList) {
            if (packageName.equals(info.getPackageName())) {
                if (DEBUG)
                    Log.v(TAG, "Found " + info.getPackageName());
                return info;
            }
        }
    } else {
        if (DEBUG)
            Log.v(TAG, "Media players list empty");
    }
    return null;
}
#end_block

#method_before
private synchronized MediaPlayerListRsp prepareMediaPlayerRspObj() {
    /* Forming player list -- */
    int numPlayers = mMediaPlayerInfoList.size();
    byte[] playerTypes = new byte[numPlayers];
    int[] playerSubTypes = new int[numPlayers];
    String[] displayableNameArray = new String[numPlayers];
    String[] packageNameArray = new String[numPlayers];
    byte[] playStatusValues = new byte[numPlayers];
    short[] featureBitMaskValues = new short[numPlayers * AvrcpHalConstants.AVRC_FEATURE_MASK_SIZE];
    List<MediaController> mediaControllerList = new ArrayList<MediaController>();
    int playerId = 0;
    for (MediaPlayerInfo info : mMediaPlayerInfoList) {
        playerTypes[playerId] = info.getMajorType();
        playerSubTypes[playerId] = info.getSubType();
        packageNameArray[playerId] = info.getPackageName();
        displayableNameArray[playerId] = info.getDisplayableName();
        playStatusValues[playerId] = info.getPlayStatus();
        mediaControllerList.add(info.getMediaController());
        for (int numBit = 0; numBit < info.getFeatureBitMask().length; numBit++) {
            /* gives which octet this belongs to */
            byte octet = (byte) (info.getFeatureBitMask()[numBit] / 8);
            /* gives the bit position within the octet */
            byte bit = (byte) (info.getFeatureBitMask()[numBit] % 8);
            featureBitMaskValues[(playerId * AvrcpHalConstants.AVRC_FEATURE_MASK_SIZE) + octet] |= (1 << bit);
        }
        /* printLogs */
        if (DEBUG) {
            Log.d(TAG, "\n   +++ Player " + playerId + " +++   ");
            Log.d(TAG, "display Name[" + playerId + "]: " + displayableNameArray[playerId]);
            Log.d(TAG, "Package Name[" + playerId + "]: " + packageNameArray[playerId]);
            Log.d(TAG, "player Types[" + playerId + "]: " + playerTypes[playerId]);
            Log.d(TAG, "Play Status Value[" + playerId + "]: " + playStatusValues[playerId]);
            Log.d(TAG, "\n");
        }
        playerId++;
    }
    if (DEBUG)
        Log.d(TAG, "prepareMediaPlayerRspObj: numPlayers = " + numPlayers);
    return new MediaPlayerListRsp(AvrcpHalConstants.BTRC_STS_NO_ERROR, sUIDCounter, numPlayers, AvrcpHalConstants.BTRC_ITEM_PLAYER, playerTypes, playerSubTypes, playStatusValues, featureBitMaskValues, displayableNameArray, packageNameArray, mediaControllerList);
}
#method_after
private synchronized MediaPlayerListRsp prepareMediaPlayerRspObj() {
    /* Forming player list -- */
    int numPlayers = mMediaPlayerInfoList.size();
    byte[] playerTypes = new byte[numPlayers];
    int[] playerSubTypes = new int[numPlayers];
    String[] displayableNameArray = new String[numPlayers];
    String[] packageNameArray = new String[numPlayers];
    byte[] playStatusValues = new byte[numPlayers];
    short[] featureBitMaskValues = new short[numPlayers * AvrcpConstants.AVRC_FEATURE_MASK_SIZE];
    List<MediaController> mediaControllerList = new ArrayList<MediaController>();
    int playerId = 0;
    for (MediaPlayerInfo info : mMediaPlayerInfoList) {
        playerTypes[playerId] = info.getMajorType();
        playerSubTypes[playerId] = info.getSubType();
        packageNameArray[playerId] = info.getPackageName();
        displayableNameArray[playerId] = info.getDisplayableName();
        playStatusValues[playerId] = info.getPlayStatus();
        mediaControllerList.add(info.getMediaController());
        for (int numBit = 0; numBit < info.getFeatureBitMask().length; numBit++) {
            /* gives which octet this belongs to */
            byte octet = (byte) (info.getFeatureBitMask()[numBit] / 8);
            /* gives the bit position within the octet */
            byte bit = (byte) (info.getFeatureBitMask()[numBit] % 8);
            featureBitMaskValues[(playerId * AvrcpConstants.AVRC_FEATURE_MASK_SIZE) + octet] |= (1 << bit);
        }
        /* printLogs */
        if (DEBUG) {
            Log.d(TAG, "\n   +++ Player " + playerId + " +++   ");
            Log.d(TAG, "display Name[" + playerId + "]: " + displayableNameArray[playerId]);
            Log.d(TAG, "Package Name[" + playerId + "]: " + packageNameArray[playerId]);
            Log.d(TAG, "player Types[" + playerId + "]: " + playerTypes[playerId]);
            Log.d(TAG, "Play Status Value[" + playerId + "]: " + playStatusValues[playerId]);
            Log.d(TAG, "\n");
        }
        playerId++;
    }
    if (DEBUG)
        Log.d(TAG, "prepareMediaPlayerRspObj: numPlayers = " + numPlayers);
    return new MediaPlayerListRsp(AvrcpConstants.RSP_NO_ERROR, sUIDCounter, numPlayers, AvrcpConstants.BTRC_ITEM_PLAYER, playerTypes, playerSubTypes, playStatusValues, featureBitMaskValues, displayableNameArray, packageNameArray, mediaControllerList);
}
#end_block

#method_before
private void handleMediaPlayerListRsp(FolderItemsCmd folderObj) {
    if (folderObj.mStartItem >= mMPLObj.mNumItems) {
        Log.i(TAG, "handleMediaPlayerListRsp: start item = " + folderObj.mStartItem + ", but available num of items = " + mMPLObj.mNumItems);
        mediaPlayerListRspNative(folderObj.mAddress, AvrcpHalConstants.BTRC_STS_INV_RANGE, (short) 0, (byte) 0, 0, null, null, null, null, null);
    } else {
        if (DEBUG)
            Log.d(TAG, "handleMediaPlayerListRsp: num items = " + mMPLObj.mNumItems);
        sendFolderItems(mMPLObj, folderObj.mAddress);
    }
}
#method_after
private void handleMediaPlayerListRsp(AvrcpCmd.FolderItemsCmd folderObj) {
    if (folderObj.mStartItem >= mMPLObj.mNumItems) {
        Log.i(TAG, "handleMediaPlayerListRsp: start item = " + folderObj.mStartItem + ", but available num of items = " + mMPLObj.mNumItems);
        mediaPlayerListRspNative(folderObj.mAddress, AvrcpConstants.RSP_INV_RANGE, (short) 0, (byte) 0, 0, null, null, null, null, null);
    } else {
        if (DEBUG)
            Log.d(TAG, "handleMediaPlayerListRsp: num items = " + mMPLObj.mNumItems);
        sendFolderItems(mMPLObj, folderObj.mAddress);
    }
}
#end_block

#method_before
private boolean updateCurrentController(int AddrId, int browseId) {
    boolean registerRsp = true;
    if (!unregOldMediaControllerCb(false)) {
        Log.d(TAG, "unregisterOldMediaControllerCallback return false");
    }
    updateNewIds(AddrId, browseId);
    if (!regNewMediaControllerCb()) {
        Log.d(TAG, "registerOldMediaControllerCallback return false");
        registerRsp = false;
    }
    if (DEBUG)
        Log.d(TAG, "updateCurrentController: registerRsp = " + registerRsp);
    return registerRsp;
}
#method_after
private boolean updateCurrentController(int addrId, int browseId) {
    boolean registerRsp = true;
    if (!unregOldMediaControllerCb()) {
        Log.d(TAG, "unregisterOldMediaControllerCallback return false");
    }
    updateNewIds(addrId, browseId);
    if (!regNewMediaControllerCb()) {
        Log.d(TAG, "registerOldMediaControllerCallback return false");
        registerRsp = false;
    }
    if (DEBUG)
        Log.d(TAG, "updateCurrentController: registerRsp = " + registerRsp);
    return registerRsp;
}
#end_block

#method_before
private boolean unregOldMediaControllerCb(boolean onCleanUp) {
    boolean isUnregistered = false;
    // unregistering callback for old media controller.
    MediaController oldController = getCurrentMediaController();
    if (oldController != null) {
        // pause audio on previously addressed media player unless it is called at cleanup
        if (!onCleanUp) {
            Log.i(TAG, "Pausing Audio on previously addressed media player:" + " package name: " + oldController.getPackageName());
            oldController.getTransportControls().pause();
        }
        oldController.unregisterCallback(mMediaControllerCb);
        isUnregistered = true;
    } else {
        Log.i(TAG, "old controller is null, addressPlayerId:" + mCurrAddrPlayerID);
    }
    if (DEBUG)
        Log.d(TAG, "unregOldMediaControllerCb: isUnregistered = " + isUnregistered);
    return isUnregistered;
}
#method_after
private boolean unregOldMediaControllerCb() {
    boolean isUnregistered = false;
    // unregistering callback for old media controller.
    MediaController oldController = getCurrentMediaController();
    if (oldController != null) {
        oldController.unregisterCallback(mMediaControllerCb);
        isUnregistered = true;
    } else {
        Log.i(TAG, "old controller is null, addressPlayerId:" + mCurrAddrPlayerID);
    }
    if (DEBUG)
        Log.d(TAG, "unregOldMediaControllerCb: isUnregistered = " + isUnregistered);
    return isUnregistered;
}
#end_block

#method_before
private boolean regNewMediaControllerCb() {
    boolean isRegistered = false;
    // registering callback for new media controller.
    MediaController newController = getCurrentMediaController();
    mMediaController = newController;
    if (mMediaController != null) {
        mMediaController.registerCallback(mMediaControllerCb, mHandler);
        isRegistered = true;
        updateMetadata(mMediaController.getMetadata());
        updatePlayPauseState(mMediaController.getPlaybackState());
        mAddressedMediaPlayer.updateNowPlaying(mMediaController.getQueue());
    } else {
        Log.i(TAG, "new controller is null, addressPlayerId:" + mCurrAddrPlayerID);
        updateMetadata(null);
        updatePlayPauseState(null);
        mAddressedMediaPlayer.updateNowPlaying(null);
    }
    if (DEBUG)
        Log.d(TAG, "regNewMediaControllerCb: isRegistered = " + isRegistered);
    return isRegistered;
}
#method_after
private boolean regNewMediaControllerCb() {
    // registering callback for new media controller.
    MediaController newController = getCurrentMediaController();
    mMediaController = newController;
    String name = (mMediaController == null) ? "null" : mMediaController.getPackageName();
    Log.v(TAG, "MediaController changed to " + name);
    if (mMediaController == null) {
        Log.i(TAG, "new controller is null, addressPlayerId:" + mCurrAddrPlayerID);
        updateMetadata(null);
        mAddressedMediaPlayer.updateNowPlayingList(null);
        return false;
    }
    mMediaController.registerCallback(mMediaControllerCb, mHandler);
    updateMetadata(mMediaController.getMetadata());
    mAddressedMediaPlayer.updateNowPlayingList(mMediaController.getQueue());
    return true;
}
#end_block

#method_before
private void handleGetFolderItemBrowseResponse(FolderItemsCmd folderObj, byte[] bdaddr) {
    int status = AvrcpHalConstants.BTRC_STS_NO_ERROR;
    /* Browsed player is already set */
    switch(folderObj.mScope) {
        case AvrcpHalConstants.BTRC_SCOPE_FILE_SYSTEM:
            if (mAvrcpBrowseManager.getBrowseMediaPlayer(bdaddr) != null) {
                mAvrcpBrowseManager.getBrowseMediaPlayer(bdaddr).getFolderItemsVFS(folderObj);
            } else {
                /* No browsed player set. Browsed player should be set by CT before performing browse.*/
                Log.e(TAG, "handleGetFolderItemBrowseResponse: mBrowseMediaPlayer is null");
                status = AvrcpHalConstants.BTRC_STS_INTERNAL_ERR;
            }
            break;
        case AvrcpHalConstants.BTRC_SCOPE_NOW_PLAYING:
            mAddressedMediaPlayer.getFolderItemsNowPlaying(bdaddr, folderObj, mMediaController);
            break;
        default:
            /* invalid scope */
            Log.e(TAG, "handleGetFolderItemBrowseResponse:invalid scope");
            status = AvrcpHalConstants.BTRC_STS_INV_SCOPE;
    }
    if (status != AvrcpHalConstants.BTRC_STS_NO_ERROR) {
        getFolderItemsRspNative(bdaddr, status, (short) 0, (byte) 0x00, 0, null, null, null, null, null, null, null, null);
    }
}
#method_after
private void handleGetFolderItemBrowseResponse(AvrcpCmd.FolderItemsCmd folderObj, byte[] bdaddr) {
    int status = AvrcpConstants.RSP_NO_ERROR;
    /* Browsed player is already set */
    switch(folderObj.mScope) {
        case AvrcpConstants.BTRC_SCOPE_FILE_SYSTEM:
            if (mAvrcpBrowseManager.getBrowsedMediaPlayer(bdaddr) != null) {
                mAvrcpBrowseManager.getBrowsedMediaPlayer(bdaddr).getFolderItemsVFS(folderObj);
            } else {
                /* No browsed player set. Browsed player should be set by CT before performing browse.*/
                Log.e(TAG, "handleGetFolderItemBrowseResponse: mBrowsedMediaPlayer is null");
                status = AvrcpConstants.RSP_INTERNAL_ERR;
            }
            break;
        case AvrcpConstants.BTRC_SCOPE_NOW_PLAYING:
            mAddressedMediaPlayer.getFolderItemsNowPlaying(bdaddr, folderObj, mMediaController);
            break;
        default:
            /* invalid scope */
            Log.e(TAG, "handleGetFolderItemBrowseResponse:invalid scope");
            status = AvrcpConstants.RSP_INV_SCOPE;
    }
    if (status != AvrcpConstants.RSP_NO_ERROR) {
        getFolderItemsRspNative(bdaddr, status, (short) 0, (byte) 0x00, 0, null, null, null, null, null, null, null, null);
    }
}
#end_block

#method_before
private void updateNewIds(int addrId, int browseId) {
    mCurrAddrPlayerID = addrId;
    mCurrBrowsePlayerID = browseId;
    if (DEBUG)
        Log.v(TAG, "Updated CurrentIds: AddrPlayerID:" + mCurrAddrPlayerID + " to " + addrId + ", BrowsePlayerID:" + mCurrBrowsePlayerID + " to " + browseId);
}
#method_after
private synchronized void updateNewIds(int addrId, int browseId) {
    mCurrAddrPlayerID = addrId;
    mCurrBrowsePlayerID = browseId;
    if (DEBUG)
        Log.v(TAG, "Updated CurrentIds: AddrPlayerID:" + mCurrAddrPlayerID + " to " + addrId + ", BrowsePlayerID:" + mCurrBrowsePlayerID + " to " + browseId);
}
#end_block

#method_before
private void handlePlayItemResponse(byte[] bdaddr, byte[] uid, byte scope) {
    if (scope == AvrcpHalConstants.BTRC_SCOPE_NOW_PLAYING) {
        mAddressedMediaPlayer.playItem(bdaddr, uid, scope, mMediaController);
    } else {
        if (!isAddrPlayerSameAsBrowsed(bdaddr)) {
            Log.w(TAG, "Remote requesting play item on uid which may not be recognized by" + "current addressed player");
            playItemRspNative(bdaddr, AvrcpHalConstants.BTRC_STS_INV_ITEM);
        }
        if (mAvrcpBrowseManager.getBrowseMediaPlayer(bdaddr) != null) {
            mAvrcpBrowseManager.getBrowseMediaPlayer(bdaddr).playItem(uid, scope);
        } else {
            Log.e(TAG, "handlePlayItemResponse: Remote requested playitem " + "before setbrowsedplayer");
            playItemRspNative(bdaddr, AvrcpHalConstants.BTRC_STS_INTERNAL_ERR);
        }
    }
}
#method_after
private void handlePlayItemResponse(byte[] bdaddr, byte[] uid, byte scope) {
    if (scope == AvrcpConstants.BTRC_SCOPE_NOW_PLAYING) {
        mAddressedMediaPlayer.playItem(bdaddr, uid, scope, mMediaController);
    } else {
        if (!isAddrPlayerSameAsBrowsed(bdaddr)) {
            Log.w(TAG, "Remote requesting play item on uid which may not be recognized by" + "current addressed player");
            playItemRspNative(bdaddr, AvrcpConstants.RSP_INV_ITEM);
        }
        if (mAvrcpBrowseManager.getBrowsedMediaPlayer(bdaddr) != null) {
            mAvrcpBrowseManager.getBrowsedMediaPlayer(bdaddr).playItem(uid, scope);
        } else {
            Log.e(TAG, "handlePlayItemResponse: Remote requested playitem " + "before setbrowsedplayer");
            playItemRspNative(bdaddr, AvrcpConstants.RSP_INTERNAL_ERR);
        }
    }
}
#end_block

#method_before
private void handleGetItemAttr(ItemAttrCmd itemAttr) {
    if (itemAttr.mScope == AvrcpHalConstants.BTRC_SCOPE_NOW_PLAYING) {
        mAddressedMediaPlayer.getItemAttr(itemAttr.mAddress, itemAttr, mMediaController);
    } else {
        if (mAvrcpBrowseManager.getBrowseMediaPlayer(itemAttr.mAddress) != null)
            mAvrcpBrowseManager.getBrowseMediaPlayer(itemAttr.mAddress).getItemAttr(itemAttr);
        else {
            Log.e(TAG, "Could not get attributes. mBrowseMediaPlayer is null");
            getItemAttrRspNative(itemAttr.mAddress, AvrcpHalConstants.BTRC_STS_INTERNAL_ERR, (byte) 0, null, null);
        }
    }
}
#method_after
private void handleGetItemAttr(AvrcpCmd.ItemAttrCmd itemAttr) {
    if (itemAttr.mScope == AvrcpConstants.BTRC_SCOPE_NOW_PLAYING) {
        mAddressedMediaPlayer.getItemAttr(itemAttr.mAddress, itemAttr, mMediaController);
    } else {
        if (mAvrcpBrowseManager.getBrowsedMediaPlayer(itemAttr.mAddress) != null)
            mAvrcpBrowseManager.getBrowsedMediaPlayer(itemAttr.mAddress).getItemAttr(itemAttr);
        else {
            Log.e(TAG, "Could not get attributes. mBrowsedMediaPlayer is null");
            getItemAttrRspNative(itemAttr.mAddress, AvrcpConstants.RSP_INTERNAL_ERR, (byte) 0, null, null);
        }
    }
}
#end_block

#method_before
private void handleGetTotalNumOfItemsResponse(byte[] bdaddr, byte scope) {
    // for scope as media player list
    if (scope == AvrcpHalConstants.BTRC_SCOPE_PLAYER_LIST) {
        int numPlayers = getPlayerListSize();
        if (DEBUG)
            Log.d(TAG, "handleGetTotalNumOfItemsResponse: sending total " + numPlayers + " media players.");
        getTotalNumOfItemsRspNative(bdaddr, AvrcpHalConstants.BTRC_STS_NO_ERROR, 0, numPlayers);
    } else if (scope == AvrcpHalConstants.BTRC_SCOPE_NOW_PLAYING) {
        mAddressedMediaPlayer.getTotalNumOfItems(bdaddr, scope, mMediaController);
    } else {
        // for FileSystem browsing scopes as VFS, Now Playing
        if (mAvrcpBrowseManager.getBrowseMediaPlayer(bdaddr) != null) {
            mAvrcpBrowseManager.getBrowseMediaPlayer(bdaddr).getTotalNumOfItems(scope);
        } else {
            Log.e(TAG, "Could not get Total NumOfItems. mBrowseMediaPlayer is null");
            getTotalNumOfItemsRspNative(bdaddr, AvrcpHalConstants.BTRC_STS_INTERNAL_ERR, 0, 0);
        }
    }
}
#method_after
private void handleGetTotalNumOfItemsResponse(byte[] bdaddr, byte scope) {
    // for scope as media player list
    if (scope == AvrcpConstants.BTRC_SCOPE_PLAYER_LIST) {
        int numPlayers = getPlayerListSize();
        if (DEBUG)
            Log.d(TAG, "handleGetTotalNumOfItemsResponse: sending total " + numPlayers + " media players.");
        getTotalNumOfItemsRspNative(bdaddr, AvrcpConstants.RSP_NO_ERROR, 0, numPlayers);
    } else if (scope == AvrcpConstants.BTRC_SCOPE_NOW_PLAYING) {
        mAddressedMediaPlayer.getTotalNumOfItems(bdaddr, scope, mMediaController);
    } else {
        // for FileSystem browsing scopes as VFS, Now Playing
        if (mAvrcpBrowseManager.getBrowsedMediaPlayer(bdaddr) != null) {
            mAvrcpBrowseManager.getBrowsedMediaPlayer(bdaddr).getTotalNumOfItems(scope);
        } else {
            Log.e(TAG, "Could not get Total NumOfItems. mBrowsedMediaPlayer is null");
            getTotalNumOfItemsRspNative(bdaddr, AvrcpConstants.RSP_INTERNAL_ERR, 0, 0);
        }
    }
}
#end_block

#method_before
private boolean isCurrentMediaPlayerListEmpty() {
    boolean isEmpty = true;
    if (mMPLObj != null && mMPLObj.mPackageNameList != null && mMPLObj.mPackageNameList.length != 0 && !mMediaPlayerInfoList.isEmpty()) {
        isEmpty = false;
    } else {
        if (DEBUG)
            Log.d(TAG, "Current MediaPlayer List Empty.");
    }
    return isEmpty;
}
#method_after
private boolean isCurrentMediaPlayerListEmpty() {
    boolean isEmpty = (mMPLObj == null || mMPLObj.mPackageNameList == null || mMPLObj.mPackageNameList.length == 0 || mMediaPlayerInfoList.isEmpty());
    if (DEBUG)
        Log.d(TAG, "Current MediaPlayer List Empty.= " + isEmpty);
    return isEmpty;
}
#end_block

#method_before
private boolean isIdValid(int id) {
    boolean isValid = true;
    if (id <= 0 || id > mMPLObj.mPackageNameList.length) {
        isValid = false;
        Log.w(TAG, "Id is invalid: id = " + id);
    }
    return isValid;
}
#method_after
private boolean isIdValid(int id) {
    boolean isValid = (id > 0 && id <= mMPLObj.mPackageNameList.length);
    if (DEBUG)
        Log.d(TAG, "Id = " + id + "isIdValid = " + isValid);
    return isValid;
}
#end_block

#method_before
private boolean isPackageNameValid(String browsedPackage) {
    boolean isValid = false;
    if (browsedPackage != null && browsedPackage.length() > 0) {
        isValid = true;
    }
    if (DEBUG)
        Log.d(TAG, "isPackageNameValid: browsedPackage = " + browsedPackage + "isValid = " + isValid);
    return isValid;
}
#method_after
private boolean isPackageNameValid(String browsedPackage) {
    boolean isValid = (browsedPackage != null && browsedPackage.length() > 0);
    if (DEBUG)
        Log.d(TAG, "isPackageNameValid: browsedPackage = " + browsedPackage + "isValid = " + isValid);
    return isValid;
}
#end_block

#method_before
private boolean isPlayerAlreadyAddressed(int selectedId) {
    boolean isAddressed = false;
    // checking if selected ID is same as the current addressed player id
    if (mCurrAddrPlayerID == selectedId) {
        isAddressed = true;
    }
    if (DEBUG)
        Log.d(TAG, "isPlayerAlreadyAddressed: isAddressed = " + isAddressed);
    return isAddressed;
}
#method_after
private boolean isPlayerAlreadyAddressed(int selectedId) {
    // checking if selected ID is same as the current addressed player id
    boolean isAddressed = (mCurrAddrPlayerID == selectedId);
    if (DEBUG)
        Log.d(TAG, "isPlayerAlreadyAddressed: isAddressed = " + isAddressed);
    return isAddressed;
}
#end_block

#method_before
public void dump(StringBuilder sb) {
    sb.append("AVRCP:\n");
    ProfileService.println(sb, "mMetadata: " + mMetadata);
    ProfileService.println(sb, "mTransportControlFlags: " + mTransportControlFlags);
    ProfileService.println(sb, "mCurrentPlayState: " + mCurrentPlayState);
    ProfileService.println(sb, "mPlayStatusChangedNT: " + mPlayStatusChangedNT);
    ProfileService.println(sb, "mTrackChangedNT: " + mTrackChangedNT);
    ProfileService.println(sb, "mTrackNumber: " + mTrackNumber);
    ProfileService.println(sb, "mCurrentPosMs: " + mCurrentPosMs);
    ProfileService.println(sb, "mPlayStartTimeMs: " + mPlayStartTimeMs);
    ProfileService.println(sb, "mSongLengthMs: " + mSongLengthMs);
    ProfileService.println(sb, "mPlaybackIntervalMs: " + mPlaybackIntervalMs);
    ProfileService.println(sb, "mPlayPosChangedNT: " + mPlayPosChangedNT);
    ProfileService.println(sb, "mNextPosMs: " + mNextPosMs);
    ProfileService.println(sb, "mPrevPosMs: " + mPrevPosMs);
    ProfileService.println(sb, "mSkipStartTime: " + mSkipStartTime);
    ProfileService.println(sb, "mFeatures: " + mFeatures);
    ProfileService.println(sb, "mRemoteVolume: " + mRemoteVolume);
    ProfileService.println(sb, "mLastRemoteVolume: " + mLastRemoteVolume);
    ProfileService.println(sb, "mLastDirection: " + mLastDirection);
    ProfileService.println(sb, "mVolumeStep: " + mVolumeStep);
    ProfileService.println(sb, "mAudioStreamMax: " + mAudioStreamMax);
    ProfileService.println(sb, "mVolCmdAdjustInProgress: " + mVolCmdAdjustInProgress);
    ProfileService.println(sb, "mVolCmdSetInProgress: " + mVolCmdSetInProgress);
    ProfileService.println(sb, "mAbsVolRetryTimes: " + mAbsVolRetryTimes);
    ProfileService.println(sb, "mSkipAmount: " + mSkipAmount);
    ProfileService.println(sb, "mVolumeMapping: " + mVolumeMapping.toString());
}
#method_after
public void dump(StringBuilder sb) {
    sb.append("AVRCP:\n");
    ProfileService.println(sb, "mMediaAttributes: " + mMediaAttributes);
    ProfileService.println(sb, "mTransportControlFlags: " + mTransportControlFlags);
    ProfileService.println(sb, "mCurrentPlayState: " + mCurrentPlayState);
    ProfileService.println(sb, "mLastStateUpdate: " + mLastStateUpdate);
    ProfileService.println(sb, "mPlayStatusChangedNT: " + mPlayStatusChangedNT);
    ProfileService.println(sb, "mTrackChangedNT: " + mTrackChangedNT);
    ProfileService.println(sb, "mTrackNumber: " + mTrackNumber);
    ProfileService.println(sb, "mSongLengthMs: " + mSongLengthMs);
    ProfileService.println(sb, "mPlaybackIntervalMs: " + mPlaybackIntervalMs);
    ProfileService.println(sb, "mPlayPosChangedNT: " + mPlayPosChangedNT);
    ProfileService.println(sb, "mNextPosMs: " + mNextPosMs);
    ProfileService.println(sb, "mPrevPosMs: " + mPrevPosMs);
    ProfileService.println(sb, "mSkipStartTime: " + mSkipStartTime);
    ProfileService.println(sb, "mFeatures: " + mFeatures);
    ProfileService.println(sb, "mRemoteVolume: " + mRemoteVolume);
    ProfileService.println(sb, "mLastRemoteVolume: " + mLastRemoteVolume);
    ProfileService.println(sb, "mLastDirection: " + mLastDirection);
    ProfileService.println(sb, "mVolumeStep: " + mVolumeStep);
    ProfileService.println(sb, "mAudioStreamMax: " + mAudioStreamMax);
    ProfileService.println(sb, "mVolCmdAdjustInProgress: " + mVolCmdAdjustInProgress);
    ProfileService.println(sb, "mVolCmdSetInProgress: " + mVolCmdSetInProgress);
    ProfileService.println(sb, "mAbsVolRetryTimes: " + mAbsVolRetryTimes);
    ProfileService.println(sb, "mSkipAmount: " + mSkipAmount);
    ProfileService.println(sb, "mVolumeMapping: " + mVolumeMapping.toString());
    if (mMediaController != null)
        ProfileService.println(sb, "mMediaSession pkg: " + mMediaController.getPackageName());
}
#end_block

#method_before
public void cleanup() {
    for (int idx = 0; idx < connList.size(); idx++) {
        Iterator entries = connList.entrySet().iterator();
        while (entries.hasNext()) {
            Map.Entry entry = (Map.Entry) entries.next();
            BrowseMediaPlayer browseMediaPlayer = (BrowseMediaPlayer) entry.getValue();
            if (browseMediaPlayer != null) {
                browseMediaPlayer.cleanup();
            }
        }
    }
    // clean up the map
    connList.clear();
}
#method_after
public void cleanup() {
    Iterator entries = connList.entrySet().iterator();
    while (entries.hasNext()) {
        Map.Entry entry = (Map.Entry) entries.next();
        BrowsedMediaPlayer browsedMediaPlayer = (BrowsedMediaPlayer) entry.getValue();
        if (browsedMediaPlayer != null) {
            browsedMediaPlayer.cleanup();
        }
    }
    // clean up the map
    connList.clear();
}
#end_block

#method_before
public void cleanupConn(BluetoothDevice device) {
    if (null == device)
        return;
    String bdaddr = new String(hexStringToByteArray(device.getAddress().replace(":", "")));
    /* check to see remote device performed setBrowsedPlayer */
    if (connList.containsKey(bdaddr)) {
        BrowseMediaPlayer browseMediaPlayer = connList.get(bdaddr);
        /* cleanup browsing connection to media player for disconnected remote device */
        if (browseMediaPlayer != null)
            browseMediaPlayer.cleanup();
        /* remove bdaddr of disconnected device */
        connList.remove(bdaddr);
    }
}
#method_after
public void cleanupConn(BluetoothDevice device) {
    if (null == device)
        return;
    String bdaddr = new String(hexStringToByteArray(device.getAddress().replace(":", "")));
    /* check to see remote device performed setBrowsedPlayer */
    if (connList.containsKey(bdaddr)) {
        BrowsedMediaPlayer browsedMediaPlayer = connList.get(bdaddr);
        /* cleanup browsing connection to media player for disconnected remote device */
        if (browsedMediaPlayer != null)
            browsedMediaPlayer.cleanup();
        /* remove bdaddr of disconnected device */
        connList.remove(bdaddr);
    }
}
#end_block

#method_before
public Map<String, BrowseMediaPlayer> getConnList() {
    return connList;
}
#method_after
public Map<String, BrowsedMediaPlayer> getConnList() {
    return connList;
}
#end_block

#method_before
public void mediaPlayerListRsp(byte[] address, int rspStatus, MediaPlayerListRsp rspObj) {
    if (rspObj != null && rspStatus == AvrcpHalConstants.BTRC_STS_NO_ERROR) {
        if (!mediaPlayerListRspNative(address, rspStatus, sUIDCounter, rspObj.itemType, rspObj.mNumItems, rspObj.mPlayerTypes, rspObj.mPlayerSubTypes, rspObj.mPlayStatusValues, rspObj.mFeatureBitMaskValues, rspObj.mPlayerNameList))
            Log.e(TAG, "mediaPlayerListRsp failed!");
    } else {
        Log.e(TAG, "mediaPlayerListRsp: rspObj is null");
        if (!mediaPlayerListRspNative(address, rspStatus, sUIDCounter, (byte) 0x00, 0, null, null, null, null, null))
            Log.e(TAG, "mediaPlayerListRsp failed!");
    }
}
#method_after
public void mediaPlayerListRsp(byte[] address, int rspStatus, MediaPlayerListRsp rspObj) {
    if (rspObj != null && rspStatus == AvrcpConstants.RSP_NO_ERROR) {
        if (!mediaPlayerListRspNative(address, rspStatus, sUIDCounter, rspObj.itemType, rspObj.mNumItems, rspObj.mPlayerTypes, rspObj.mPlayerSubTypes, rspObj.mPlayStatusValues, rspObj.mFeatureBitMaskValues, rspObj.mPlayerNameList))
            Log.e(TAG, "mediaPlayerListRsp failed!");
    } else {
        Log.e(TAG, "mediaPlayerListRsp: rspObj is null");
        if (!mediaPlayerListRspNative(address, rspStatus, sUIDCounter, (byte) 0x00, 0, null, null, null, null, null))
            Log.e(TAG, "mediaPlayerListRsp failed!");
    }
}
#end_block

#method_before
public void folderItemsRsp(byte[] address, int rspStatus, FolderItemsRsp rspObj) {
    if (rspObj != null && rspStatus == AvrcpHalConstants.BTRC_STS_NO_ERROR) {
        if (!getFolderItemsRspNative(address, rspStatus, sUIDCounter, rspObj.mScope, rspObj.mNumItems, rspObj.mFolderTypes, rspObj.mPlayable, rspObj.mItemTypes, rspObj.mItemUid, rspObj.mDisplayNames, rspObj.mAttributesNum, rspObj.mAttrIds, rspObj.mAttrValues))
            Log.e(TAG, "getFolderItemsRspNative failed!");
    } else {
        Log.e(TAG, "folderItemsRsp: rspObj is null or rspStatus is error:" + rspStatus);
        if (!getFolderItemsRspNative(address, rspStatus, sUIDCounter, (byte) 0x00, 0, null, null, null, null, null, null, null, null))
            Log.e(TAG, "getFolderItemsRspNative failed!");
    }
}
#method_after
public void folderItemsRsp(byte[] address, int rspStatus, FolderItemsRsp rspObj) {
    if (rspObj != null && rspStatus == AvrcpConstants.RSP_NO_ERROR) {
        if (!getFolderItemsRspNative(address, rspStatus, sUIDCounter, rspObj.mScope, rspObj.mNumItems, rspObj.mFolderTypes, rspObj.mPlayable, rspObj.mItemTypes, rspObj.mItemUid, rspObj.mDisplayNames, rspObj.mAttributesNum, rspObj.mAttrIds, rspObj.mAttrValues))
            Log.e(TAG, "getFolderItemsRspNative failed!");
    } else {
        Log.e(TAG, "folderItemsRsp: rspObj is null or rspStatus is error:" + rspStatus);
        if (!getFolderItemsRspNative(address, rspStatus, sUIDCounter, (byte) 0x00, 0, null, null, null, null, null, null, null, null))
            Log.e(TAG, "getFolderItemsRspNative failed!");
    }
}
#end_block

#method_before
public void getItemAttrRsp(byte[] address, int rspStatus, ItemAttrRsp rspObj) {
    if (rspObj != null && rspStatus == AvrcpHalConstants.BTRC_STS_NO_ERROR) {
        if (!getItemAttrRspNative(address, rspStatus, rspObj.mNumAttr, rspObj.mAttributesIds, rspObj.mAttributesArray))
            Log.e(TAG, "getItemAttrRspNative failed!");
    } else {
        Log.e(TAG, "getItemAttrRsp: rspObj is null or rspStatus is error:" + rspStatus);
        if (!getItemAttrRspNative(address, rspStatus, (byte) 0x00, null, null))
            Log.e(TAG, "getItemAttrRspNative failed!");
    }
}
#method_after
public void getItemAttrRsp(byte[] address, int rspStatus, ItemAttrRsp rspObj) {
    if (rspObj != null && rspStatus == AvrcpConstants.RSP_NO_ERROR) {
        if (!getItemAttrRspNative(address, rspStatus, rspObj.mNumAttr, rspObj.mAttributesIds, rspObj.mAttributesArray))
            Log.e(TAG, "getItemAttrRspNative failed!");
    } else {
        Log.e(TAG, "getItemAttrRsp: rspObj is null or rspStatus is error:" + rspStatus);
        if (!getItemAttrRspNative(address, rspStatus, (byte) 0x00, null, null))
            Log.e(TAG, "getItemAttrRspNative failed!");
    }
}
#end_block

#method_before
public void playItemRsp(byte[] address, int rspStatus) {
    if (!playItemRspNative(address, rspStatus))
        Log.e(TAG, "playItemRspNative failed!");
}
#method_after
public void playItemRsp(byte[] address, int rspStatus) {
    if (!playItemRspNative(address, rspStatus)) {
        Log.e(TAG, "playItemRspNative failed!");
    }
}
#end_block

#method_before
public void getTotalNumOfItemsRsp(byte[] address, int rspStatus, int uidCounter, int numItems) {
    if (!getTotalNumOfItemsRspNative(address, rspStatus, sUIDCounter, numItems))
        Log.e(TAG, "getTotalNumOfItemsRspNative failed!");
}
#method_after
public void getTotalNumOfItemsRsp(byte[] address, int rspStatus, int uidCounter, int numItems) {
    if (!getTotalNumOfItemsRspNative(address, rspStatus, sUIDCounter, numItems)) {
        Log.e(TAG, "getTotalNumOfItemsRspNative failed!");
    }
}
#end_block

#method_before
public void addrPlayerChangedRsp(byte[] address, int type, int playerId, int uidCounter) {
    if (!registerNotificationRspAddrPlayerChangedNative(type, playerId, sUIDCounter))
        Log.e(TAG, "registerNotificationRspAddrPlayerChangedNative failed!");
}
#method_after
public void addrPlayerChangedRsp(byte[] address, int type, int playerId, int uidCounter) {
    if (!registerNotificationRspAddrPlayerChangedNative(type, playerId, sUIDCounter)) {
        Log.e(TAG, "registerNotificationRspAddrPlayerChangedNative failed!");
    }
}
#end_block

#method_before
public void avalPlayerChangedRsp(byte[] address, int type) {
    if (!registerNotificationRspAvalPlayerChangedNative(type))
        Log.e(TAG, "registerNotificationRspAvalPlayerChangedNative failed!");
}
#method_after
public void avalPlayerChangedRsp(byte[] address, int type) {
    if (!registerNotificationRspAvalPlayerChangedNative(type)) {
        Log.e(TAG, "registerNotificationRspAvalPlayerChangedNative failed!");
    }
}
#end_block

#method_before
public void uidsChangedRsp(byte[] address, int type, int uidCounter) {
    if (!registerNotificationRspUIDsChangedNative(type, sUIDCounter))
        Log.e(TAG, "registerNotificationRspUIDsChangedNative failed!");
}
#method_after
public void uidsChangedRsp(byte[] address, int type, int uidCounter) {
    if (!registerNotificationRspUIDsChangedNative(type, sUIDCounter)) {
        Log.e(TAG, "registerNotificationRspUIDsChangedNative failed!");
    }
}
#end_block

#method_before
public void nowPlayingChangedRsp(int type) {
    if (!registerNotificationRspNowPlayingChangedNative(type))
        Log.e(TAG, "registerNotificationRspNowPlayingChangedNative failed!");
}
#method_after
public void nowPlayingChangedRsp(int type) {
    if (!registerNotificationRspNowPlayingChangedNative(type)) {
        Log.e(TAG, "registerNotificationRspNowPlayingChangedNative failed!");
    }
}
#end_block

#method_before
public void trackChangedRsp(int type, byte[] uid) {
    if (!registerNotificationRspTrackChangeNative(type, uid))
        Log.e(TAG, "registerNotificationRspTrackChangeNative failed!");
}
#method_after
public void trackChangedRsp(int type, byte[] uid) {
    if (!registerNotificationRspTrackChangeNative(type, uid)) {
        Log.e(TAG, "registerNotificationRspTrackChangeNative failed!");
    }
}
#end_block

#method_before
private static void testProxyGetMethodID() {
    InvocationHandler handler = new DummyInvocationHandler();
    SimpleInterface proxy = (SimpleInterface) Proxy.newProxyInstance(SimpleInterface.class.getClassLoader(), new Class[] { SimpleInterface.class }, handler);
    if (testGetMethodID(SimpleInterface.class) == 0) {
        throw new AssertionError();
    }
    if (testGetMethodID(proxy.getClass()) == 0) {
        throw new AssertionError();
    }
}
#method_after
private static void testProxyGetMethodID() {
    InvocationHandler handler = new DummyInvocationHandler();
    SimpleInterface proxy = (SimpleInterface) Proxy.newProxyInstance(SimpleInterface.class.getClassLoader(), new Class<?>[] { SimpleInterface.class }, handler);
    if (testGetMethodID(SimpleInterface.class) == 0) {
        throw new AssertionError();
    }
    if (testGetMethodID(proxy.getClass()) == 0) {
        throw new AssertionError();
    }
}
#end_block

#method_before
boolean isPrime(int certainty) {
    return NativeBN.BN_is_prime_ex(bignum, certainty);
}
#method_after
boolean isPrime(int certainty) {
    return NativeBN.BN_primality_test(bignum, certainty, false);
}
#end_block

#method_before
// TODO(29631070): this is a general testing mechanism to test other operations that are
public void testHashMapOperations() {
    performHashMapOperationAndCheckResults(PUT, /* operation */
    mapOf("class1.algorithm1", "impl1"), /* initialStatus */
    new String[] { "class2.algorithm2", "impl2" }, /* operationParameters */
    mapOf("class1.algorithm1", "impl1", "class2.algorithm2", "impl2"), true);
    performHashMapOperationAndCheckResults(PUT_ALL, mapOf("class1.algorithm1", "impl1"), mapOf("class2.algorithm2", "impl2", "class3.algorithm3", "impl3"), mapOf("class1.algorithm1", "impl1", "class2.algorithm2", "impl2", "class3.algorithm3", "impl3"), true);
    performHashMapOperationAndCheckResults(REMOVE, mapOf("class1.algorithm1", "impl1"), "class1.algorithm1", mapOf(), true);
    performHashMapOperationAndCheckResults(REMOVE, mapOf("class1.algorithm1", "impl1"), "class2.algorithm1", mapOf("class1.algorithm1", "impl1"), true);
}
#method_after
// TODO(29631070): this is a general testing mechanism to test other operations that are
public void testHashMapOperations() {
    performHashMapOperationAndCheckResults(PUT, /* operation */
    mapOf("class1.algorithm1", "impl1"), /* initialStatus */
    new Pair("class2.algorithm2", "impl2"), /* operationParameters */
    mapOf("class1.algorithm1", "impl1", "class2.algorithm2", "impl2"), true);
    performHashMapOperationAndCheckResults(PUT_ALL, mapOf("class1.algorithm1", "impl1"), mapOf("class2.algorithm2", "impl2", "class3.algorithm3", "impl3"), mapOf("class1.algorithm1", "impl1", "class2.algorithm2", "impl2", "class3.algorithm3", "impl3"), true);
    performHashMapOperationAndCheckResults(REMOVE, mapOf("class1.algorithm1", "impl1"), "class1.algorithm1", mapOf(), true);
    performHashMapOperationAndCheckResults(REMOVE, mapOf("class1.algorithm1", "impl1"), "class2.algorithm1", mapOf("class1.algorithm1", "impl1"), true);
}
#end_block

#method_before
private void performHashMapOperationAndCheckResults(Consumer<ProviderAndOperationParameter> operation, Map<String, String> initialState, Object operationParameters, Map<String, String> expectedResult, boolean mustChangeVersion) {
    Provider p = new MockProvider("MockProvider");
    // Need to set as registered so that the security version will change on update.
    p.setRegistered();
    int securityVersionBeforeOperation = Security.getVersion();
    p.putAll(initialState);
    // Perform the operation.
    operation.accept(new ProviderAndOperationParameter(p, operationParameters));
    // Check that elements are correctly mapped to services.
    HashMap<String, String> services = new HashMap<String, String>();
    for (Provider.Service s : p.getServices()) {
        services.put(s.getType() + "." + s.getAlgorithm(), s.getClassName());
    }
    assertEquals(expectedResult.entrySet(), services.entrySet());
    // Check that elements are in the provider hash map.
    // The hash map in the provider has info other than services, include those in the
    // expected results.
    HashMap<Object, Object> hashExpectedResult = new HashMap<Object, Object>();
    hashExpectedResult.putAll(expectedResult);
    hashExpectedResult.put("Provider.id info", p.getInfo());
    hashExpectedResult.put("Provider.id className", p.getClass().getName());
    hashExpectedResult.put("Provider.id version", String.valueOf(p.getVersion()));
    hashExpectedResult.put("Provider.id name", p.getName());
    assertEquals(hashExpectedResult.entrySet(), p.entrySet());
    for (Object key : hashExpectedResult.keySet()) {
        assertTrue(p.containsKey(key));
        assertEquals(hashExpectedResult.get(key), p.get(key));
    }
    if (mustChangeVersion) {
        assertTrue(securityVersionBeforeOperation != Security.getVersion());
    }
}
#method_after
private <A> void performHashMapOperationAndCheckResults(Consumer<ProviderAndOperationParameter<A>> operation, Map<String, String> initialState, A operationParameters, Map<String, String> expectedResult, boolean mustChangeVersion) {
    Provider p = new MockProvider("MockProvider");
    // Need to set as registered so that the security version will change on update.
    p.setRegistered();
    int securityVersionBeforeOperation = Security.getVersion();
    p.putAll(initialState);
    // Perform the operation.
    operation.accept(new ProviderAndOperationParameter<A>(p, operationParameters));
    // Check that elements are correctly mapped to services.
    HashMap<String, String> services = new HashMap<String, String>();
    for (Provider.Service s : p.getServices()) {
        services.put(s.getType() + "." + s.getAlgorithm(), s.getClassName());
    }
    assertEquals(expectedResult.entrySet(), services.entrySet());
    // Check that elements are in the provider hash map.
    // The hash map in the provider has info other than services, include those in the
    // expected results.
    HashMap<String, String> hashExpectedResult = new HashMap<String, String>();
    hashExpectedResult.putAll(expectedResult);
    hashExpectedResult.put("Provider.id info", p.getInfo());
    hashExpectedResult.put("Provider.id className", p.getClass().getName());
    hashExpectedResult.put("Provider.id version", String.valueOf(p.getVersion()));
    hashExpectedResult.put("Provider.id name", p.getName());
    assertEquals(hashExpectedResult.entrySet(), p.entrySet());
    if (mustChangeVersion) {
        assertTrue(securityVersionBeforeOperation != Security.getVersion());
    }
}
#end_block

#method_before
@Override
public <T extends Annotation> T[] getAnnotationsByType(Class<T> annotationClass) {
    // getAnnotationsByType() == getDeclaredAnnotationByType() for Field.
    return AnnotatedElements.getDeclaredAnnotationsByType(this, annotationClass);
}
#method_after
@Override
public <T extends Annotation> T[] getAnnotationsByType(Class<T> annotationClass) {
    // Android-changed: Uses AnnotatedElements instead.
    return AnnotatedElements.getDirectOrIndirectAnnotationsByType(this, annotationClass);
}
#end_block

#method_before
public Type[] getGenericParameterTypes() {
    // Android-changed: See AbstractMethod.
    throw new UnsupportedOperationException("Not implemented on Android. See AbstractMethod");
}
#method_after
public Type[] getGenericParameterTypes() {
    // Android-changed: Implemented in AbstractMethod instead.
    throw new UnsupportedOperationException("Executable.getGenericParameterTypes() not implemented");
}
#end_block

#method_before
public Type[] getGenericExceptionTypes() {
    // Android-changed: See AbstractMethod.
    throw new UnsupportedOperationException("Not implemented on Android.");
}
#method_after
public Type[] getGenericExceptionTypes() {
    // Android-changed: Implemented in AbstractMethod instead.
    throw new UnsupportedOperationException("Executable.getGenericExceptionTypes() not implemented");
}
#end_block

#method_before
public <T extends Annotation> T getAnnotation(Class<T> annotationClass) {
    // Android-changed: See AbstractMethod.
    throw new UnsupportedOperationException("Not implemented on Android.");
}
#method_after
public <T extends Annotation> T getAnnotation(Class<T> annotationClass) {
    // Android-changed: Implemented in AbstractMethod instead.
    throw new UnsupportedOperationException("Executable.getAnnotation(Class) not implemented");
}
#end_block

#method_before
@Override
public <T extends Annotation> T[] getAnnotationsByType(Class<T> annotationClass) {
    // getAnnotationsByType() == getDeclaredAnnotationByType() for Method and Constructor.
    return AnnotatedElements.getDeclaredAnnotationsByType(this, annotationClass);
}
#method_after
@Override
public <T extends Annotation> T[] getAnnotationsByType(Class<T> annotationClass) {
    // Android-changed: Uses AnnotatedElements instead.
    return AnnotatedElements.getDirectOrIndirectAnnotationsByType(this, annotationClass);
}
#end_block

#method_before
public Annotation[] getDeclaredAnnotations() {
    // Android-changed: See AbstractMethod.
    throw new UnsupportedOperationException("Not implemented on Android.");
}
#method_after
public Annotation[] getDeclaredAnnotations() {
    // Android-changed: Implemented in AbstractMethod instead.
    throw new UnsupportedOperationException("Executable.getDeclaredAnnotations() not implemented");
}
#end_block

#method_before
default <T extends Annotation> T[] getAnnotationsByType(Class<T> annotationClass) {
    // undetectable way because Class is final.
    return AnnotatedElements.getDeclaredAnnotationsByType(this, annotationClass);
}
#method_after
default <T extends Annotation> T[] getAnnotationsByType(Class<T> annotationClass) {
    // undetectable way because Class is final.
    return AnnotatedElements.getDirectOrIndirectAnnotationsByType(this, annotationClass);
}
#end_block

#method_before
default <T extends Annotation> T getDeclaredAnnotation(Class<T> annotationClass) {
    Objects.requireNonNull(annotationClass);
    // Loop over all directly-present annotations looking for a matching one
    for (Annotation annotation : getDeclaredAnnotations()) {
        if (annotationClass.equals(annotation.annotationType())) {
            // of compile-time only.
            return annotationClass.cast(annotation);
        }
    }
    return null;
}
#method_after
default <T extends Annotation> Annotation getDeclaredAnnotation(Class<T> annotationClass) {
    Objects.requireNonNull(annotationClass);
    // Loop over all directly-present annotations looking for a matching one
    for (Annotation annotation : getDeclaredAnnotations()) {
        if (annotationClass.equals(annotation.annotationType())) {
            // of compile-time only.
            return annotationClass.cast(annotation);
        }
    }
    return null;
}
#end_block

#method_before
default <T extends Annotation> T[] getDeclaredAnnotationsByType(Class<T> annotationClass) {
    return AnnotatedElements.getDeclaredAnnotationsByType(this, annotationClass);
}
#method_after
default <T extends Annotation> T[] getDeclaredAnnotationsByType(Class<T> annotationClass) {
    return AnnotatedElements.getDirectOrIndirectAnnotationsByType(this, annotationClass);
}
#end_block

#method_before
@BeforeExperiment
public void setup() {
    C0 c0 = new C0();
    callF0(c0);
    C1 c1 = new C1();
    callF0(c1);
    callF64(c1);
    C2 c2 = new C2();
    callF0(c2);
    callF64(c2);
    callF128(c2);
    C3 c3 = new C3();
    callF0(c3);
    callF64(c3);
    callF128(c3);
    callF192(c3);
    C4 c4 = new C4();
    callF0(c4);
    callF64(c4);
    callF128(c4);
    callF192(c4);
    callF256(c4);
    C5 c5 = new C5();
    callF0(c5);
    callF64(c5);
    callF128(c5);
    callF192(c5);
    callF256(c5);
    callF320(c5);
    C6 c6 = new C6();
    callF0(c6);
    callF64(c6);
    callF128(c6);
    callF192(c6);
    callF256(c6);
    callF320(c6);
    callF384(c6);
    C7 c7 = new C7();
    callF0(c7);
    callF64(c7);
    callF128(c7);
    callF192(c7);
    callF256(c7);
    callF320(c7);
    callF384(c7);
    callF448(c7);
    C8 c8 = new C8();
    callF0(c8);
    callF64(c8);
    callF128(c8);
    callF192(c8);
    callF256(c8);
    callF320(c8);
    callF384(c8);
    callF448(c8);
    callF512(c8);
    C9 c9 = new C9();
    callF0(c9);
    callF64(c9);
    callF128(c9);
    callF192(c9);
    callF256(c9);
    callF320(c9);
    callF384(c9);
    callF448(c9);
    callF512(c9);
    callF576(c9);
    C10 c10 = new C10();
    callF0(c10);
    callF64(c10);
    callF128(c10);
    callF192(c10);
    callF256(c10);
    callF320(c10);
    callF384(c10);
    callF448(c10);
    callF512(c10);
    callF576(c10);
    callF640(c10);
    C11 c11 = new C11();
    callF0(c11);
    callF64(c11);
    callF128(c11);
    callF192(c11);
    callF256(c11);
    callF320(c11);
    callF384(c11);
    callF448(c11);
    callF512(c11);
    callF576(c11);
    callF640(c11);
    callF704(c11);
    C12 c12 = new C12();
    callF0(c12);
    callF64(c12);
    callF128(c12);
    callF192(c12);
    callF256(c12);
    callF320(c12);
    callF384(c12);
    callF448(c12);
    callF512(c12);
    callF576(c12);
    callF640(c12);
    callF704(c12);
    callF768(c12);
    C13 c13 = new C13();
    callF0(c13);
    callF64(c13);
    callF128(c13);
    callF192(c13);
    callF256(c13);
    callF320(c13);
    callF384(c13);
    callF448(c13);
    callF512(c13);
    callF576(c13);
    callF640(c13);
    callF704(c13);
    callF768(c13);
    callF832(c13);
    C14 c14 = new C14();
    callF0(c14);
    callF64(c14);
    callF128(c14);
    callF192(c14);
    callF256(c14);
    callF320(c14);
    callF384(c14);
    callF448(c14);
    callF512(c14);
    callF576(c14);
    callF640(c14);
    callF704(c14);
    callF768(c14);
    callF832(c14);
    callF896(c14);
    C15 c15 = new C15();
    callF0(c15);
    callF64(c15);
    callF128(c15);
    callF192(c15);
    callF256(c15);
    callF320(c15);
    callF384(c15);
    callF448(c15);
    callF512(c15);
    callF576(c15);
    callF640(c15);
    callF704(c15);
    callF768(c15);
    callF832(c15);
    callF896(c15);
    callF960(c15);
    C16 c16 = new C16();
    callF0(c16);
    callF64(c16);
    callF128(c16);
    callF192(c16);
    callF256(c16);
    callF320(c16);
    callF384(c16);
    callF448(c16);
    callF512(c16);
    callF576(c16);
    callF640(c16);
    callF704(c16);
    callF768(c16);
    callF832(c16);
    callF896(c16);
    callF960(c16);
    callF1024(c16);
    C17 c17 = new C17();
    callF0(c17);
    callF64(c17);
    callF128(c17);
    callF192(c17);
    callF256(c17);
    callF320(c17);
    callF384(c17);
    callF448(c17);
    callF512(c17);
    callF576(c17);
    callF640(c17);
    callF704(c17);
    callF768(c17);
    callF832(c17);
    callF896(c17);
    callF960(c17);
    callF1024(c17);
    callF1088(c17);
    C18 c18 = new C18();
    callF0(c18);
    callF64(c18);
    callF128(c18);
    callF192(c18);
    callF256(c18);
    callF320(c18);
    callF384(c18);
    callF448(c18);
    callF512(c18);
    callF576(c18);
    callF640(c18);
    callF704(c18);
    callF768(c18);
    callF832(c18);
    callF896(c18);
    callF960(c18);
    callF1024(c18);
    callF1088(c18);
    callF1152(c18);
    C19 c19 = new C19();
    callF0(c19);
    callF64(c19);
    callF128(c19);
    callF192(c19);
    callF256(c19);
    callF320(c19);
    callF384(c19);
    callF448(c19);
    callF512(c19);
    callF576(c19);
    callF640(c19);
    callF704(c19);
    callF768(c19);
    callF832(c19);
    callF896(c19);
    callF960(c19);
    callF1024(c19);
    callF1088(c19);
    callF1152(c19);
    callF1216(c19);
}
#method_after
@BeforeExperiment
public void setup() {
    C0 c0 = new C0();
    callF0(c0);
    C1 c1 = new C1();
    callF0(c1);
    callF43(c1);
    C2 c2 = new C2();
    callF0(c2);
    callF43(c2);
    callF86(c2);
    C3 c3 = new C3();
    callF0(c3);
    callF43(c3);
    callF86(c3);
    callF129(c3);
    C4 c4 = new C4();
    callF0(c4);
    callF43(c4);
    callF86(c4);
    callF129(c4);
    callF172(c4);
    C5 c5 = new C5();
    callF0(c5);
    callF43(c5);
    callF86(c5);
    callF129(c5);
    callF172(c5);
    callF215(c5);
    C6 c6 = new C6();
    callF0(c6);
    callF43(c6);
    callF86(c6);
    callF129(c6);
    callF172(c6);
    callF215(c6);
    callF258(c6);
    C7 c7 = new C7();
    callF0(c7);
    callF43(c7);
    callF86(c7);
    callF129(c7);
    callF172(c7);
    callF215(c7);
    callF258(c7);
    callF301(c7);
    C8 c8 = new C8();
    callF0(c8);
    callF43(c8);
    callF86(c8);
    callF129(c8);
    callF172(c8);
    callF215(c8);
    callF258(c8);
    callF301(c8);
    callF344(c8);
    C9 c9 = new C9();
    callF0(c9);
    callF43(c9);
    callF86(c9);
    callF129(c9);
    callF172(c9);
    callF215(c9);
    callF258(c9);
    callF301(c9);
    callF344(c9);
    callF387(c9);
    C10 c10 = new C10();
    callF0(c10);
    callF43(c10);
    callF86(c10);
    callF129(c10);
    callF172(c10);
    callF215(c10);
    callF258(c10);
    callF301(c10);
    callF344(c10);
    callF387(c10);
    callF430(c10);
    C11 c11 = new C11();
    callF0(c11);
    callF43(c11);
    callF86(c11);
    callF129(c11);
    callF172(c11);
    callF215(c11);
    callF258(c11);
    callF301(c11);
    callF344(c11);
    callF387(c11);
    callF430(c11);
    callF473(c11);
    C12 c12 = new C12();
    callF0(c12);
    callF43(c12);
    callF86(c12);
    callF129(c12);
    callF172(c12);
    callF215(c12);
    callF258(c12);
    callF301(c12);
    callF344(c12);
    callF387(c12);
    callF430(c12);
    callF473(c12);
    callF516(c12);
    C13 c13 = new C13();
    callF0(c13);
    callF43(c13);
    callF86(c13);
    callF129(c13);
    callF172(c13);
    callF215(c13);
    callF258(c13);
    callF301(c13);
    callF344(c13);
    callF387(c13);
    callF430(c13);
    callF473(c13);
    callF516(c13);
    callF559(c13);
    C14 c14 = new C14();
    callF0(c14);
    callF43(c14);
    callF86(c14);
    callF129(c14);
    callF172(c14);
    callF215(c14);
    callF258(c14);
    callF301(c14);
    callF344(c14);
    callF387(c14);
    callF430(c14);
    callF473(c14);
    callF516(c14);
    callF559(c14);
    callF602(c14);
    C15 c15 = new C15();
    callF0(c15);
    callF43(c15);
    callF86(c15);
    callF129(c15);
    callF172(c15);
    callF215(c15);
    callF258(c15);
    callF301(c15);
    callF344(c15);
    callF387(c15);
    callF430(c15);
    callF473(c15);
    callF516(c15);
    callF559(c15);
    callF602(c15);
    callF645(c15);
    C16 c16 = new C16();
    callF0(c16);
    callF43(c16);
    callF86(c16);
    callF129(c16);
    callF172(c16);
    callF215(c16);
    callF258(c16);
    callF301(c16);
    callF344(c16);
    callF387(c16);
    callF430(c16);
    callF473(c16);
    callF516(c16);
    callF559(c16);
    callF602(c16);
    callF645(c16);
    callF688(c16);
    C17 c17 = new C17();
    callF0(c17);
    callF43(c17);
    callF86(c17);
    callF129(c17);
    callF172(c17);
    callF215(c17);
    callF258(c17);
    callF301(c17);
    callF344(c17);
    callF387(c17);
    callF430(c17);
    callF473(c17);
    callF516(c17);
    callF559(c17);
    callF602(c17);
    callF645(c17);
    callF688(c17);
    callF731(c17);
    C18 c18 = new C18();
    callF0(c18);
    callF43(c18);
    callF86(c18);
    callF129(c18);
    callF172(c18);
    callF215(c18);
    callF258(c18);
    callF301(c18);
    callF344(c18);
    callF387(c18);
    callF430(c18);
    callF473(c18);
    callF516(c18);
    callF559(c18);
    callF602(c18);
    callF645(c18);
    callF688(c18);
    callF731(c18);
    callF774(c18);
    C19 c19 = new C19();
    callF0(c19);
    callF43(c19);
    callF86(c19);
    callF129(c19);
    callF172(c19);
    callF215(c19);
    callF258(c19);
    callF301(c19);
    callF344(c19);
    callF387(c19);
    callF430(c19);
    callF473(c19);
    callF516(c19);
    callF559(c19);
    callF602(c19);
    callF645(c19);
    callF688(c19);
    callF731(c19);
    callF774(c19);
    callF817(c19);
}
#end_block

#method_before
public void timeConflictDepth02(int nreps) {
    C1 c1 = new C1();
    for (int i = 0; i < nreps; i++) {
        callF0(c1);
        callF64(c1);
        callF0(c1);
        callF64(c1);
        callF0(c1);
        callF64(c1);
        callF0(c1);
        callF64(c1);
        callF0(c1);
        callF64(c1);
        callF0(c1);
        callF64(c1);
        callF0(c1);
        callF64(c1);
        callF0(c1);
        callF64(c1);
        callF0(c1);
        callF64(c1);
        callF0(c1);
        callF64(c1);
    }
}
#method_after
public void timeConflictDepth02(int nreps) {
    C1 c1 = new C1();
    for (int i = 0; i < nreps; i++) {
        callF0(c1);
        callF43(c1);
        callF0(c1);
        callF43(c1);
        callF0(c1);
        callF43(c1);
        callF0(c1);
        callF43(c1);
        callF0(c1);
        callF43(c1);
        callF0(c1);
        callF43(c1);
        callF0(c1);
        callF43(c1);
        callF0(c1);
        callF43(c1);
        callF0(c1);
        callF43(c1);
        callF0(c1);
        callF43(c1);
    }
}
#end_block

#method_before
public void timeConflictDepth03(int nreps) {
    C2 c2 = new C2();
    for (int i = 0; i < nreps; i++) {
        callF0(c2);
        callF64(c2);
        callF128(c2);
        callF0(c2);
        callF64(c2);
        callF128(c2);
        callF0(c2);
        callF64(c2);
        callF128(c2);
        callF0(c2);
        callF64(c2);
        callF128(c2);
        callF0(c2);
        callF64(c2);
        callF128(c2);
        callF0(c2);
        callF64(c2);
        callF128(c2);
        callF0(c2);
        callF64(c2);
    }
}
#method_after
public void timeConflictDepth03(int nreps) {
    C2 c2 = new C2();
    for (int i = 0; i < nreps; i++) {
        callF0(c2);
        callF43(c2);
        callF86(c2);
        callF0(c2);
        callF43(c2);
        callF86(c2);
        callF0(c2);
        callF43(c2);
        callF86(c2);
        callF0(c2);
        callF43(c2);
        callF86(c2);
        callF0(c2);
        callF43(c2);
        callF86(c2);
        callF0(c2);
        callF43(c2);
        callF86(c2);
        callF0(c2);
        callF43(c2);
    }
}
#end_block

#method_before
public void timeConflictDepth04(int nreps) {
    C3 c3 = new C3();
    for (int i = 0; i < nreps; i++) {
        callF0(c3);
        callF64(c3);
        callF128(c3);
        callF192(c3);
        callF0(c3);
        callF64(c3);
        callF128(c3);
        callF192(c3);
        callF0(c3);
        callF64(c3);
        callF128(c3);
        callF192(c3);
        callF0(c3);
        callF64(c3);
        callF128(c3);
        callF192(c3);
        callF0(c3);
        callF64(c3);
        callF128(c3);
        callF192(c3);
    }
}
#method_after
public void timeConflictDepth04(int nreps) {
    C3 c3 = new C3();
    for (int i = 0; i < nreps; i++) {
        callF0(c3);
        callF43(c3);
        callF86(c3);
        callF129(c3);
        callF0(c3);
        callF43(c3);
        callF86(c3);
        callF129(c3);
        callF0(c3);
        callF43(c3);
        callF86(c3);
        callF129(c3);
        callF0(c3);
        callF43(c3);
        callF86(c3);
        callF129(c3);
        callF0(c3);
        callF43(c3);
        callF86(c3);
        callF129(c3);
    }
}
#end_block

#method_before
public void timeConflictDepth05(int nreps) {
    C4 c4 = new C4();
    for (int i = 0; i < nreps; i++) {
        callF0(c4);
        callF64(c4);
        callF128(c4);
        callF192(c4);
        callF256(c4);
        callF0(c4);
        callF64(c4);
        callF128(c4);
        callF192(c4);
        callF256(c4);
        callF0(c4);
        callF64(c4);
        callF128(c4);
        callF192(c4);
        callF256(c4);
        callF0(c4);
        callF64(c4);
        callF128(c4);
        callF192(c4);
        callF256(c4);
    }
}
#method_after
public void timeConflictDepth05(int nreps) {
    C4 c4 = new C4();
    for (int i = 0; i < nreps; i++) {
        callF0(c4);
        callF43(c4);
        callF86(c4);
        callF129(c4);
        callF172(c4);
        callF0(c4);
        callF43(c4);
        callF86(c4);
        callF129(c4);
        callF172(c4);
        callF0(c4);
        callF43(c4);
        callF86(c4);
        callF129(c4);
        callF172(c4);
        callF0(c4);
        callF43(c4);
        callF86(c4);
        callF129(c4);
        callF172(c4);
    }
}
#end_block

#method_before
public void timeConflictDepth06(int nreps) {
    C5 c5 = new C5();
    for (int i = 0; i < nreps; i++) {
        callF0(c5);
        callF64(c5);
        callF128(c5);
        callF192(c5);
        callF256(c5);
        callF320(c5);
        callF0(c5);
        callF64(c5);
        callF128(c5);
        callF192(c5);
        callF256(c5);
        callF320(c5);
        callF0(c5);
        callF64(c5);
        callF128(c5);
        callF192(c5);
        callF256(c5);
        callF320(c5);
        callF0(c5);
        callF64(c5);
    }
}
#method_after
public void timeConflictDepth06(int nreps) {
    C5 c5 = new C5();
    for (int i = 0; i < nreps; i++) {
        callF0(c5);
        callF43(c5);
        callF86(c5);
        callF129(c5);
        callF172(c5);
        callF215(c5);
        callF0(c5);
        callF43(c5);
        callF86(c5);
        callF129(c5);
        callF172(c5);
        callF215(c5);
        callF0(c5);
        callF43(c5);
        callF86(c5);
        callF129(c5);
        callF172(c5);
        callF215(c5);
        callF0(c5);
        callF43(c5);
    }
}
#end_block

#method_before
public void timeConflictDepth07(int nreps) {
    C6 c6 = new C6();
    for (int i = 0; i < nreps; i++) {
        callF0(c6);
        callF64(c6);
        callF128(c6);
        callF192(c6);
        callF256(c6);
        callF320(c6);
        callF384(c6);
        callF0(c6);
        callF64(c6);
        callF128(c6);
        callF192(c6);
        callF256(c6);
        callF320(c6);
        callF384(c6);
        callF0(c6);
        callF64(c6);
        callF128(c6);
        callF192(c6);
        callF256(c6);
        callF320(c6);
    }
}
#method_after
public void timeConflictDepth07(int nreps) {
    C6 c6 = new C6();
    for (int i = 0; i < nreps; i++) {
        callF0(c6);
        callF43(c6);
        callF86(c6);
        callF129(c6);
        callF172(c6);
        callF215(c6);
        callF258(c6);
        callF0(c6);
        callF43(c6);
        callF86(c6);
        callF129(c6);
        callF172(c6);
        callF215(c6);
        callF258(c6);
        callF0(c6);
        callF43(c6);
        callF86(c6);
        callF129(c6);
        callF172(c6);
        callF215(c6);
    }
}
#end_block

#method_before
public void timeConflictDepth08(int nreps) {
    C7 c7 = new C7();
    for (int i = 0; i < nreps; i++) {
        callF0(c7);
        callF64(c7);
        callF128(c7);
        callF192(c7);
        callF256(c7);
        callF320(c7);
        callF384(c7);
        callF448(c7);
        callF0(c7);
        callF64(c7);
        callF128(c7);
        callF192(c7);
        callF256(c7);
        callF320(c7);
        callF384(c7);
        callF448(c7);
        callF0(c7);
        callF64(c7);
        callF128(c7);
        callF192(c7);
    }
}
#method_after
public void timeConflictDepth08(int nreps) {
    C7 c7 = new C7();
    for (int i = 0; i < nreps; i++) {
        callF0(c7);
        callF43(c7);
        callF86(c7);
        callF129(c7);
        callF172(c7);
        callF215(c7);
        callF258(c7);
        callF301(c7);
        callF0(c7);
        callF43(c7);
        callF86(c7);
        callF129(c7);
        callF172(c7);
        callF215(c7);
        callF258(c7);
        callF301(c7);
        callF0(c7);
        callF43(c7);
        callF86(c7);
        callF129(c7);
    }
}
#end_block

#method_before
public void timeConflictDepth09(int nreps) {
    C8 c8 = new C8();
    for (int i = 0; i < nreps; i++) {
        callF0(c8);
        callF64(c8);
        callF128(c8);
        callF192(c8);
        callF256(c8);
        callF320(c8);
        callF384(c8);
        callF448(c8);
        callF512(c8);
        callF0(c8);
        callF64(c8);
        callF128(c8);
        callF192(c8);
        callF256(c8);
        callF320(c8);
        callF384(c8);
        callF448(c8);
        callF512(c8);
        callF0(c8);
        callF64(c8);
    }
}
#method_after
public void timeConflictDepth09(int nreps) {
    C8 c8 = new C8();
    for (int i = 0; i < nreps; i++) {
        callF0(c8);
        callF43(c8);
        callF86(c8);
        callF129(c8);
        callF172(c8);
        callF215(c8);
        callF258(c8);
        callF301(c8);
        callF344(c8);
        callF0(c8);
        callF43(c8);
        callF86(c8);
        callF129(c8);
        callF172(c8);
        callF215(c8);
        callF258(c8);
        callF301(c8);
        callF344(c8);
        callF0(c8);
        callF43(c8);
    }
}
#end_block

#method_before
public void timeConflictDepth10(int nreps) {
    C9 c9 = new C9();
    for (int i = 0; i < nreps; i++) {
        callF0(c9);
        callF64(c9);
        callF128(c9);
        callF192(c9);
        callF256(c9);
        callF320(c9);
        callF384(c9);
        callF448(c9);
        callF512(c9);
        callF576(c9);
        callF0(c9);
        callF64(c9);
        callF128(c9);
        callF192(c9);
        callF256(c9);
        callF320(c9);
        callF384(c9);
        callF448(c9);
        callF512(c9);
        callF576(c9);
    }
}
#method_after
public void timeConflictDepth10(int nreps) {
    C9 c9 = new C9();
    for (int i = 0; i < nreps; i++) {
        callF0(c9);
        callF43(c9);
        callF86(c9);
        callF129(c9);
        callF172(c9);
        callF215(c9);
        callF258(c9);
        callF301(c9);
        callF344(c9);
        callF387(c9);
        callF0(c9);
        callF43(c9);
        callF86(c9);
        callF129(c9);
        callF172(c9);
        callF215(c9);
        callF258(c9);
        callF301(c9);
        callF344(c9);
        callF387(c9);
    }
}
#end_block

#method_before
public void timeConflictDepth11(int nreps) {
    C10 c10 = new C10();
    for (int i = 0; i < nreps; i++) {
        callF0(c10);
        callF64(c10);
        callF128(c10);
        callF192(c10);
        callF256(c10);
        callF320(c10);
        callF384(c10);
        callF448(c10);
        callF512(c10);
        callF576(c10);
        callF640(c10);
        callF0(c10);
        callF64(c10);
        callF128(c10);
        callF192(c10);
        callF256(c10);
        callF320(c10);
        callF384(c10);
        callF448(c10);
        callF512(c10);
    }
}
#method_after
public void timeConflictDepth11(int nreps) {
    C10 c10 = new C10();
    for (int i = 0; i < nreps; i++) {
        callF0(c10);
        callF43(c10);
        callF86(c10);
        callF129(c10);
        callF172(c10);
        callF215(c10);
        callF258(c10);
        callF301(c10);
        callF344(c10);
        callF387(c10);
        callF430(c10);
        callF0(c10);
        callF43(c10);
        callF86(c10);
        callF129(c10);
        callF172(c10);
        callF215(c10);
        callF258(c10);
        callF301(c10);
        callF344(c10);
    }
}
#end_block

#method_before
public void timeConflictDepth12(int nreps) {
    C11 c11 = new C11();
    for (int i = 0; i < nreps; i++) {
        callF0(c11);
        callF64(c11);
        callF128(c11);
        callF192(c11);
        callF256(c11);
        callF320(c11);
        callF384(c11);
        callF448(c11);
        callF512(c11);
        callF576(c11);
        callF640(c11);
        callF704(c11);
        callF0(c11);
        callF64(c11);
        callF128(c11);
        callF192(c11);
        callF256(c11);
        callF320(c11);
        callF384(c11);
        callF448(c11);
    }
}
#method_after
public void timeConflictDepth12(int nreps) {
    C11 c11 = new C11();
    for (int i = 0; i < nreps; i++) {
        callF0(c11);
        callF43(c11);
        callF86(c11);
        callF129(c11);
        callF172(c11);
        callF215(c11);
        callF258(c11);
        callF301(c11);
        callF344(c11);
        callF387(c11);
        callF430(c11);
        callF473(c11);
        callF0(c11);
        callF43(c11);
        callF86(c11);
        callF129(c11);
        callF172(c11);
        callF215(c11);
        callF258(c11);
        callF301(c11);
    }
}
#end_block

#method_before
public void timeConflictDepth13(int nreps) {
    C12 c12 = new C12();
    for (int i = 0; i < nreps; i++) {
        callF0(c12);
        callF64(c12);
        callF128(c12);
        callF192(c12);
        callF256(c12);
        callF320(c12);
        callF384(c12);
        callF448(c12);
        callF512(c12);
        callF576(c12);
        callF640(c12);
        callF704(c12);
        callF768(c12);
        callF0(c12);
        callF64(c12);
        callF128(c12);
        callF192(c12);
        callF256(c12);
        callF320(c12);
        callF384(c12);
    }
}
#method_after
public void timeConflictDepth13(int nreps) {
    C12 c12 = new C12();
    for (int i = 0; i < nreps; i++) {
        callF0(c12);
        callF43(c12);
        callF86(c12);
        callF129(c12);
        callF172(c12);
        callF215(c12);
        callF258(c12);
        callF301(c12);
        callF344(c12);
        callF387(c12);
        callF430(c12);
        callF473(c12);
        callF516(c12);
        callF0(c12);
        callF43(c12);
        callF86(c12);
        callF129(c12);
        callF172(c12);
        callF215(c12);
        callF258(c12);
    }
}
#end_block

#method_before
public void timeConflictDepth14(int nreps) {
    C13 c13 = new C13();
    for (int i = 0; i < nreps; i++) {
        callF0(c13);
        callF64(c13);
        callF128(c13);
        callF192(c13);
        callF256(c13);
        callF320(c13);
        callF384(c13);
        callF448(c13);
        callF512(c13);
        callF576(c13);
        callF640(c13);
        callF704(c13);
        callF768(c13);
        callF832(c13);
        callF0(c13);
        callF64(c13);
        callF128(c13);
        callF192(c13);
        callF256(c13);
        callF320(c13);
    }
}
#method_after
public void timeConflictDepth14(int nreps) {
    C13 c13 = new C13();
    for (int i = 0; i < nreps; i++) {
        callF0(c13);
        callF43(c13);
        callF86(c13);
        callF129(c13);
        callF172(c13);
        callF215(c13);
        callF258(c13);
        callF301(c13);
        callF344(c13);
        callF387(c13);
        callF430(c13);
        callF473(c13);
        callF516(c13);
        callF559(c13);
        callF0(c13);
        callF43(c13);
        callF86(c13);
        callF129(c13);
        callF172(c13);
        callF215(c13);
    }
}
#end_block

#method_before
public void timeConflictDepth15(int nreps) {
    C14 c14 = new C14();
    for (int i = 0; i < nreps; i++) {
        callF0(c14);
        callF64(c14);
        callF128(c14);
        callF192(c14);
        callF256(c14);
        callF320(c14);
        callF384(c14);
        callF448(c14);
        callF512(c14);
        callF576(c14);
        callF640(c14);
        callF704(c14);
        callF768(c14);
        callF832(c14);
        callF896(c14);
        callF0(c14);
        callF64(c14);
        callF128(c14);
        callF192(c14);
        callF256(c14);
    }
}
#method_after
public void timeConflictDepth15(int nreps) {
    C14 c14 = new C14();
    for (int i = 0; i < nreps; i++) {
        callF0(c14);
        callF43(c14);
        callF86(c14);
        callF129(c14);
        callF172(c14);
        callF215(c14);
        callF258(c14);
        callF301(c14);
        callF344(c14);
        callF387(c14);
        callF430(c14);
        callF473(c14);
        callF516(c14);
        callF559(c14);
        callF602(c14);
        callF0(c14);
        callF43(c14);
        callF86(c14);
        callF129(c14);
        callF172(c14);
    }
}
#end_block

#method_before
public void timeConflictDepth16(int nreps) {
    C15 c15 = new C15();
    for (int i = 0; i < nreps; i++) {
        callF0(c15);
        callF64(c15);
        callF128(c15);
        callF192(c15);
        callF256(c15);
        callF320(c15);
        callF384(c15);
        callF448(c15);
        callF512(c15);
        callF576(c15);
        callF640(c15);
        callF704(c15);
        callF768(c15);
        callF832(c15);
        callF896(c15);
        callF960(c15);
        callF0(c15);
        callF64(c15);
        callF128(c15);
        callF192(c15);
    }
}
#method_after
public void timeConflictDepth16(int nreps) {
    C15 c15 = new C15();
    for (int i = 0; i < nreps; i++) {
        callF0(c15);
        callF43(c15);
        callF86(c15);
        callF129(c15);
        callF172(c15);
        callF215(c15);
        callF258(c15);
        callF301(c15);
        callF344(c15);
        callF387(c15);
        callF430(c15);
        callF473(c15);
        callF516(c15);
        callF559(c15);
        callF602(c15);
        callF645(c15);
        callF0(c15);
        callF43(c15);
        callF86(c15);
        callF129(c15);
    }
}
#end_block

#method_before
public void timeConflictDepth17(int nreps) {
    C16 c16 = new C16();
    for (int i = 0; i < nreps; i++) {
        callF0(c16);
        callF64(c16);
        callF128(c16);
        callF192(c16);
        callF256(c16);
        callF320(c16);
        callF384(c16);
        callF448(c16);
        callF512(c16);
        callF576(c16);
        callF640(c16);
        callF704(c16);
        callF768(c16);
        callF832(c16);
        callF896(c16);
        callF960(c16);
        callF1024(c16);
        callF0(c16);
        callF64(c16);
        callF128(c16);
    }
}
#method_after
public void timeConflictDepth17(int nreps) {
    C16 c16 = new C16();
    for (int i = 0; i < nreps; i++) {
        callF0(c16);
        callF43(c16);
        callF86(c16);
        callF129(c16);
        callF172(c16);
        callF215(c16);
        callF258(c16);
        callF301(c16);
        callF344(c16);
        callF387(c16);
        callF430(c16);
        callF473(c16);
        callF516(c16);
        callF559(c16);
        callF602(c16);
        callF645(c16);
        callF688(c16);
        callF0(c16);
        callF43(c16);
        callF86(c16);
    }
}
#end_block

#method_before
public void timeConflictDepth18(int nreps) {
    C17 c17 = new C17();
    for (int i = 0; i < nreps; i++) {
        callF0(c17);
        callF64(c17);
        callF128(c17);
        callF192(c17);
        callF256(c17);
        callF320(c17);
        callF384(c17);
        callF448(c17);
        callF512(c17);
        callF576(c17);
        callF640(c17);
        callF704(c17);
        callF768(c17);
        callF832(c17);
        callF896(c17);
        callF960(c17);
        callF1024(c17);
        callF1088(c17);
        callF0(c17);
        callF64(c17);
    }
}
#method_after
public void timeConflictDepth18(int nreps) {
    C17 c17 = new C17();
    for (int i = 0; i < nreps; i++) {
        callF0(c17);
        callF43(c17);
        callF86(c17);
        callF129(c17);
        callF172(c17);
        callF215(c17);
        callF258(c17);
        callF301(c17);
        callF344(c17);
        callF387(c17);
        callF430(c17);
        callF473(c17);
        callF516(c17);
        callF559(c17);
        callF602(c17);
        callF645(c17);
        callF688(c17);
        callF731(c17);
        callF0(c17);
        callF43(c17);
    }
}
#end_block

#method_before
public void timeConflictDepth19(int nreps) {
    C18 c18 = new C18();
    for (int i = 0; i < nreps; i++) {
        callF0(c18);
        callF64(c18);
        callF128(c18);
        callF192(c18);
        callF256(c18);
        callF320(c18);
        callF384(c18);
        callF448(c18);
        callF512(c18);
        callF576(c18);
        callF640(c18);
        callF704(c18);
        callF768(c18);
        callF832(c18);
        callF896(c18);
        callF960(c18);
        callF1024(c18);
        callF1088(c18);
        callF1152(c18);
        callF0(c18);
    }
}
#method_after
public void timeConflictDepth19(int nreps) {
    C18 c18 = new C18();
    for (int i = 0; i < nreps; i++) {
        callF0(c18);
        callF43(c18);
        callF86(c18);
        callF129(c18);
        callF172(c18);
        callF215(c18);
        callF258(c18);
        callF301(c18);
        callF344(c18);
        callF387(c18);
        callF430(c18);
        callF473(c18);
        callF516(c18);
        callF559(c18);
        callF602(c18);
        callF645(c18);
        callF688(c18);
        callF731(c18);
        callF774(c18);
        callF0(c18);
    }
}
#end_block

#method_before
public void timeConflictDepth20(int nreps) {
    C19 c19 = new C19();
    for (int i = 0; i < nreps; i++) {
        callF0(c19);
        callF64(c19);
        callF128(c19);
        callF192(c19);
        callF256(c19);
        callF320(c19);
        callF384(c19);
        callF448(c19);
        callF512(c19);
        callF576(c19);
        callF640(c19);
        callF704(c19);
        callF768(c19);
        callF832(c19);
        callF896(c19);
        callF960(c19);
        callF1024(c19);
        callF1088(c19);
        callF1152(c19);
        callF1216(c19);
    }
}
#method_after
public void timeConflictDepth20(int nreps) {
    C19 c19 = new C19();
    for (int i = 0; i < nreps; i++) {
        callF0(c19);
        callF43(c19);
        callF86(c19);
        callF129(c19);
        callF172(c19);
        callF215(c19);
        callF258(c19);
        callF301(c19);
        callF344(c19);
        callF387(c19);
        callF430(c19);
        callF473(c19);
        callF516(c19);
        callF559(c19);
        callF602(c19);
        callF645(c19);
        callF688(c19);
        callF731(c19);
        callF774(c19);
        callF817(c19);
    }
}
#end_block

#method_before
@Test
@TestInfo(id = "14581295")
public void enableSetDateAndSetTime() throws Exception {
    final int api = testFramework.getApi();
    Instrumentation instrumentation = testFramework.getInstrumentation();
    final UiDevice device = testFramework.getDevice();
    AppLauncher.launch(instrumentation, "Settings");
    final String scrollableRes = (api >= 24) ? Res.SETTINGS_RECYCLER_VIEW_RES : Res.SETTINGS_LIST_CONTAINER_RES;
    UiScrollable itemList = new UiScrollable(new UiSelector().resourceIdMatches(scrollableRes));
    itemList.setAsVerticalList();
    itemList.scrollIntoView(new UiSelector().textContains("Date & time"));
    device.findObject(new UiSelector().text("Date & time")).click();
    UiObject2 widget;
    try {
        final String listViewClass = (api >= 24) ? "android.support.v7.widget.RecyclerView" : "android.widget.ListView";
        widget = UiAutomatorPlus.findObjectByRelative(instrumentation, By.clazz("android.widget.Switch"), By.text("Automatic date & time"), By.clazz(listViewClass));
    } catch (UiObjectNotFoundException e) {
        widget = UiAutomatorPlus.findObjectByRelative(instrumentation, By.clazz("android.widget.CheckBox"), By.text("Automatic date & time"), By.clazz("android.widget.ListView"));
    }
    // Test requires "Automatic date & time" widget to start in the enabled state.
    if (!widget.isChecked()) {
        widget.click();
    }
    assertTrue("Failed to disable set date.", new Wait().until(new Wait.ExpectedCondition() {

        @Override
        public boolean isTrue() throws Exception {
            return !device.findObject(new UiSelector().text("Set date")).isEnabled();
        }
    }));
    assertTrue("Failed to disable set time.", new Wait().until(new Wait.ExpectedCondition() {

        @Override
        public boolean isTrue() throws Exception {
            return !device.findObject(new UiSelector().text("Set time")).isEnabled();
        }
    }));
    widget.click();
    assertTrue("Failed to enable set date.", new Wait().until(new Wait.ExpectedCondition() {

        @Override
        public boolean isTrue() throws Exception {
            return device.findObject(new UiSelector().text("Set date")).isEnabled();
        }
    }));
    assertTrue("Failed to enable set time.", new Wait().until(new Wait.ExpectedCondition() {

        @Override
        public boolean isTrue() throws Exception {
            return device.findObject(new UiSelector().text("Set time")).isEnabled();
        }
    }));
    device.findObject(new UiSelector().text("Set date")).clickAndWaitForNewWindow();
    if (api < 20) {
        assertTrue(device.findObject(new UiSelector().resourceId(Res.ANDROID_DATE_PICKER_HEADER_RES_19)).exists());
        device.findObject(new UiSelector().textContains("Done")).click();
        device.findObject(new UiSelector().text("Set time")).click();
        assertTrue(device.findObject(new UiSelector().resourceId(Res.ANDROID_TIME_HEADER_RES_19)).exists());
        device.findObject(new UiSelector().textContains("Done")).click();
    } else {
        assertTrue(device.findObject(new UiSelector().resourceId(Res.ANDROID_DATE_PICKER_HEADER_RES)).exists());
        device.findObject(new UiSelector().textContains("CANCEL")).click();
        device.findObject(new UiSelector().text("Set time")).click();
        assertTrue(device.findObject(new UiSelector().resourceId(Res.ANDROID_TIME_HEADER_RES)).exists());
        device.findObject(new UiSelector().textContains("CANCEL")).click();
    }
}
#method_after
@Test
@TestInfo(id = "14581295")
public void enableSetDateAndSetTime() throws Exception {
    int api = testFramework.getApi();
    Instrumentation instrumentation = testFramework.getInstrumentation();
    final UiDevice device = testFramework.getDevice();
    AppLauncher.launch(instrumentation, "Settings");
    String scrollableRes = (api >= 24) ? Res.SETTINGS_RECYCLER_VIEW_RES : Res.SETTINGS_LIST_CONTAINER_RES;
    UiScrollable itemList = new UiScrollable(new UiSelector().resourceIdMatches(scrollableRes));
    itemList.setAsVerticalList();
    itemList.scrollIntoView(new UiSelector().textContains("Date & time"));
    device.findObject(new UiSelector().text("Date & time")).click();
    UiObject2 widget;
    try {
        String listViewClass = (api >= 24) ? "android.support.v7.widget.RecyclerView" : "android.widget.ListView";
        widget = UiAutomatorPlus.findObjectByRelative(instrumentation, By.clazz("android.widget.Switch"), By.text("Automatic date & time"), By.clazz(listViewClass));
    } catch (UiObjectNotFoundException e) {
        widget = UiAutomatorPlus.findObjectByRelative(instrumentation, By.clazz("android.widget.CheckBox"), By.text("Automatic date & time"), By.clazz("android.widget.ListView"));
    }
    // Test requires "Automatic date & time" widget to start in the enabled state.
    if (!widget.isChecked()) {
        widget.click();
    }
    assertTrue("Failed to disable set date.", new Wait().until(new Wait.ExpectedCondition() {

        @Override
        public boolean isTrue() throws Exception {
            return !device.findObject(new UiSelector().text("Set date")).isEnabled();
        }
    }));
    assertTrue("Failed to disable set time.", new Wait().until(new Wait.ExpectedCondition() {

        @Override
        public boolean isTrue() throws Exception {
            return !device.findObject(new UiSelector().text("Set time")).isEnabled();
        }
    }));
    widget.click();
    assertTrue("Failed to enable set date.", new Wait().until(new Wait.ExpectedCondition() {

        @Override
        public boolean isTrue() throws Exception {
            return device.findObject(new UiSelector().text("Set date")).isEnabled();
        }
    }));
    assertTrue("Failed to enable set time.", new Wait().until(new Wait.ExpectedCondition() {

        @Override
        public boolean isTrue() throws Exception {
            return device.findObject(new UiSelector().text("Set time")).isEnabled();
        }
    }));
    device.findObject(new UiSelector().text("Set date")).clickAndWaitForNewWindow();
    if (api < 20) {
        assertTrue(device.findObject(new UiSelector().resourceId(Res.ANDROID_DATE_PICKER_HEADER_RES_19)).exists());
        device.findObject(new UiSelector().textContains("Done")).click();
        device.findObject(new UiSelector().text("Set time")).click();
        assertTrue(device.findObject(new UiSelector().resourceId(Res.ANDROID_TIME_HEADER_RES_19)).exists());
        device.findObject(new UiSelector().textContains("Done")).click();
    } else {
        assertTrue(device.findObject(new UiSelector().resourceId(Res.ANDROID_DATE_PICKER_HEADER_RES)).exists());
        device.findObject(new UiSelector().textContains("CANCEL")).click();
        device.findObject(new UiSelector().text("Set time")).click();
        assertTrue(device.findObject(new UiSelector().resourceId(Res.ANDROID_TIME_HEADER_RES)).exists());
        device.findObject(new UiSelector().textContains("CANCEL")).click();
    }
}
#end_block

#method_before
private boolean createEglContext() {
    if (mEglDisplay == null) {
        mEglDisplay = EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY);
        if (mEglDisplay == EGL14.EGL_NO_DISPLAY) {
            logEglError("eglGetDisplay");
            return false;
        }
        int[] version = new int[2];
        if (!EGL14.eglInitialize(mEglDisplay, version, 0, version, 1)) {
            mEglDisplay = null;
            logEglError("eglInitialize");
            return false;
        }
    }
    if (mEglConfig == null) {
        int[] eglConfigAttribList = new int[] { EGL14.EGL_RENDERABLE_TYPE, EGL14.EGL_OPENGL_ES2_BIT, EGL14.EGL_RED_SIZE, 8, EGL14.EGL_GREEN_SIZE, 8, EGL14.EGL_BLUE_SIZE, 8, EGL14.EGL_ALPHA_SIZE, 8, EGL14.EGL_NONE };
        int[] numEglConfigs = new int[1];
        EGLConfig[] eglConfigs = new EGLConfig[1];
        if (!EGL14.eglChooseConfig(mEglDisplay, eglConfigAttribList, 0, eglConfigs, 0, eglConfigs.length, numEglConfigs, 0)) {
            logEglError("eglChooseConfig");
            return false;
        } else if (numEglConfigs[0] <= 0) {
            Slog.e(TAG, "no valid config found");
            return false;
        }
        mEglConfig = eglConfigs[0];
    }
    if (mEglContext == null) {
        int[] eglContextAttribList = new int[] { EGL14.EGL_CONTEXT_CLIENT_VERSION, 2, EGL14.EGL_NONE };
        mEglContext = EGL14.eglCreateContext(mEglDisplay, mEglConfig, EGL14.EGL_NO_CONTEXT, eglContextAttribList, 0);
        if (mEglContext == null) {
            logEglError("eglCreateContext");
            return false;
        }
    }
    return true;
}
#method_after
private boolean createEglContext() {
    if (mEglDisplay == null) {
        mEglDisplay = EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY);
        if (mEglDisplay == EGL14.EGL_NO_DISPLAY) {
            logEglError("eglGetDisplay");
            return false;
        }
        int[] version = new int[2];
        if (!EGL14.eglInitialize(mEglDisplay, version, 0, version, 1)) {
            mEglDisplay = null;
            logEglError("eglInitialize");
            return false;
        }
    }
    if (mEglConfig == null) {
        int[] eglConfigAttribList = new int[] { EGL14.EGL_RENDERABLE_TYPE, EGL14.EGL_OPENGL_ES2_BIT, EGL14.EGL_RED_SIZE, 8, EGL14.EGL_GREEN_SIZE, 8, EGL14.EGL_BLUE_SIZE, 8, EGL14.EGL_ALPHA_SIZE, 8, EGL14.EGL_NONE };
        int[] numEglConfigs = new int[1];
        EGLConfig[] eglConfigs = new EGLConfig[1];
        if (!EGL14.eglChooseConfig(mEglDisplay, eglConfigAttribList, 0, eglConfigs, 0, eglConfigs.length, numEglConfigs, 0)) {
            logEglError("eglChooseConfig");
            return false;
        }
        if (numEglConfigs[0] <= 0) {
            Slog.e(TAG, "no valid config found");
            return false;
        }
        mEglConfig = eglConfigs[0];
    }
    if (mEglContext == null) {
        int[] eglContextAttribList = new int[] { EGL14.EGL_CONTEXT_CLIENT_VERSION, 2, EGL14.EGL_NONE };
        mEglContext = EGL14.eglCreateContext(mEglDisplay, mEglConfig, EGL14.EGL_NO_CONTEXT, eglContextAttribList, 0);
        if (mEglContext == null) {
            logEglError("eglCreateContext");
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public void onSystemReady() {
    mSystemReady = true;
    sendMsg(mAudioHandler, MSG_LOAD_SOUND_EFFECTS, SENDMSG_QUEUE, 0, 0, null, 0);
    mKeyguardManager = (KeyguardManager) mContext.getSystemService(Context.KEYGUARD_SERVICE);
    mScoConnectionState = AudioManager.SCO_AUDIO_STATE_ERROR;
    resetBluetoothSco();
    getBluetoothHeadset();
    // FIXME: this is to maintain compatibility with deprecated intent
    // AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED. Remove when appropriate.
    Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
    newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE, AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
    sendStickyBroadcastToAll(newIntent);
    BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
    if (adapter != null) {
        adapter.getProfileProxy(mContext, mBluetoothProfileServiceListener, BluetoothProfile.A2DP);
    }
    mHdmiManager = (HdmiControlManager) mContext.getSystemService(Context.HDMI_CONTROL_SERVICE);
    if (mHdmiManager != null) {
        synchronized (mHdmiManager) {
            mHdmiTvClient = mHdmiManager.getTvClient();
            if (mHdmiTvClient != null) {
                mFixedVolumeDevices &= ~AudioSystem.DEVICE_ALL_HDMI_SYSTEM_AUDIO_AND_SPEAKER;
            }
            mHdmiPlaybackClient = mHdmiManager.getPlaybackClient();
            mHdmiCecSink = false;
        }
    }
    sendMsg(mAudioHandler, MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED, SENDMSG_REPLACE, 0, 0, TAG, SAFE_VOLUME_CONFIGURE_TIMEOUT_MS);
    StreamOverride.init(mContext);
    mControllerService.init();
    onIndicateSystemReady();
}
#method_after
public void onSystemReady() {
    mSystemReady = true;
    sendMsg(mAudioHandler, MSG_LOAD_SOUND_EFFECTS, SENDMSG_QUEUE, 0, 0, null, 0);
    mScoConnectionState = AudioManager.SCO_AUDIO_STATE_ERROR;
    resetBluetoothSco();
    getBluetoothHeadset();
    // FIXME: this is to maintain compatibility with deprecated intent
    // AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED. Remove when appropriate.
    Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
    newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE, AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
    sendStickyBroadcastToAll(newIntent);
    BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
    if (adapter != null) {
        adapter.getProfileProxy(mContext, mBluetoothProfileServiceListener, BluetoothProfile.A2DP);
    }
    mHdmiManager = (HdmiControlManager) mContext.getSystemService(Context.HDMI_CONTROL_SERVICE);
    if (mHdmiManager != null) {
        synchronized (mHdmiManager) {
            mHdmiTvClient = mHdmiManager.getTvClient();
            if (mHdmiTvClient != null) {
                mFixedVolumeDevices &= ~AudioSystem.DEVICE_ALL_HDMI_SYSTEM_AUDIO_AND_SPEAKER;
            }
            mHdmiPlaybackClient = mHdmiManager.getPlaybackClient();
            mHdmiCecSink = false;
        }
    }
    mNm = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
    sendMsg(mAudioHandler, MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED, SENDMSG_REPLACE, 0, 0, TAG, SAFE_VOLUME_CONFIGURE_TIMEOUT_MS);
    StreamOverride.init(mContext);
    mControllerService.init();
    onIndicateSystemReady();
}
#end_block

#method_before
private void readPersistedSettings() {
    final ContentResolver cr = mContentResolver;
    int ringerModeFromSettings = Settings.Global.getInt(cr, Settings.Global.MODE_RINGER, AudioManager.RINGER_MODE_NORMAL);
    int ringerMode = ringerModeFromSettings;
    // ringer modes
    if (!isValidRingerMode(ringerMode)) {
        ringerMode = AudioManager.RINGER_MODE_NORMAL;
    }
    if ((ringerMode == AudioManager.RINGER_MODE_VIBRATE) && !mHasVibrator) {
        ringerMode = AudioManager.RINGER_MODE_SILENT;
    }
    if (ringerMode != ringerModeFromSettings) {
        Settings.Global.putInt(cr, Settings.Global.MODE_RINGER, ringerMode);
    }
    if (mUseFixedVolume || isPlatformTelevision()) {
        ringerMode = AudioManager.RINGER_MODE_NORMAL;
    }
    synchronized (mSettingsLock) {
        mRingerMode = ringerMode;
        if (mRingerModeExternal == -1) {
            mRingerModeExternal = mRingerMode;
        }
        // System.VIBRATE_ON is not used any more but defaults for mVibrateSetting
        // are still needed while setVibrateSetting() and getVibrateSetting() are being
        // deprecated.
        mVibrateSetting = AudioSystem.getValueForVibrateSetting(0, AudioManager.VIBRATE_TYPE_NOTIFICATION, mHasVibrator ? AudioManager.VIBRATE_SETTING_ONLY_SILENT : AudioManager.VIBRATE_SETTING_OFF);
        mVibrateSetting = AudioSystem.getValueForVibrateSetting(mVibrateSetting, AudioManager.VIBRATE_TYPE_RINGER, mHasVibrator ? AudioManager.VIBRATE_SETTING_ONLY_SILENT : AudioManager.VIBRATE_SETTING_OFF);
        updateRingerModeAffectedStreams();
        readDockAudioSettings(cr);
    }
    mMuteAffectedStreams = System.getIntForUser(cr, System.MUTE_STREAMS_AFFECTED, AudioSystem.DEFAULT_MUTE_STREAMS_AFFECTED, UserHandle.USER_CURRENT);
    boolean masterMute = System.getIntForUser(cr, System.VOLUME_MASTER_MUTE, 0, UserHandle.USER_CURRENT) == 1;
    if (mUseFixedVolume) {
        masterMute = false;
        AudioSystem.setMasterVolume(1.0f);
    }
    AudioSystem.setMasterMute(masterMute);
    broadcastMasterMuteStatus(masterMute);
    boolean microphoneMute = System.getIntForUser(cr, System.MICROPHONE_MUTE, 0, UserHandle.USER_CURRENT) == 1;
    AudioSystem.muteMicrophone(microphoneMute);
    // Each stream will read its own persisted settings
    // Broadcast the sticky intents
    broadcastRingerMode(AudioManager.RINGER_MODE_CHANGED_ACTION, mRingerModeExternal);
    broadcastRingerMode(AudioManager.INTERNAL_RINGER_MODE_CHANGED_ACTION, mRingerMode);
    // Broadcast vibrate settings
    broadcastVibrateSetting(AudioManager.VIBRATE_TYPE_RINGER);
    broadcastVibrateSetting(AudioManager.VIBRATE_TYPE_NOTIFICATION);
    // Load settings for the volume controller
    mVolumeController.loadSettings(cr);
}
#method_after
private void readPersistedSettings() {
    final ContentResolver cr = mContentResolver;
    int ringerModeFromSettings = Settings.Global.getInt(cr, Settings.Global.MODE_RINGER, AudioManager.RINGER_MODE_NORMAL);
    int ringerMode = ringerModeFromSettings;
    // ringer modes
    if (!isValidRingerMode(ringerMode)) {
        ringerMode = AudioManager.RINGER_MODE_NORMAL;
    }
    if ((ringerMode == AudioManager.RINGER_MODE_VIBRATE) && !mHasVibrator) {
        ringerMode = AudioManager.RINGER_MODE_SILENT;
    }
    if (ringerMode != ringerModeFromSettings) {
        Settings.Global.putInt(cr, Settings.Global.MODE_RINGER, ringerMode);
    }
    if (mUseFixedVolume || isPlatformTelevision()) {
        ringerMode = AudioManager.RINGER_MODE_NORMAL;
    }
    synchronized (mSettingsLock) {
        mRingerMode = ringerMode;
        if (mRingerModeExternal == -1) {
            mRingerModeExternal = mRingerMode;
        }
        // System.VIBRATE_ON is not used any more but defaults for mVibrateSetting
        // are still needed while setVibrateSetting() and getVibrateSetting() are being
        // deprecated.
        mVibrateSetting = AudioSystem.getValueForVibrateSetting(0, AudioManager.VIBRATE_TYPE_NOTIFICATION, mHasVibrator ? AudioManager.VIBRATE_SETTING_ONLY_SILENT : AudioManager.VIBRATE_SETTING_OFF);
        mVibrateSetting = AudioSystem.getValueForVibrateSetting(mVibrateSetting, AudioManager.VIBRATE_TYPE_RINGER, mHasVibrator ? AudioManager.VIBRATE_SETTING_ONLY_SILENT : AudioManager.VIBRATE_SETTING_OFF);
        updateRingerModeAffectedStreams();
        readDockAudioSettings(cr);
        sendEncodedSurroundMode(cr);
    }
    mMuteAffectedStreams = System.getIntForUser(cr, System.MUTE_STREAMS_AFFECTED, AudioSystem.DEFAULT_MUTE_STREAMS_AFFECTED, UserHandle.USER_CURRENT);
    updateMasterMono(cr);
    // Each stream will read its own persisted settings
    // Broadcast the sticky intents
    broadcastRingerMode(AudioManager.RINGER_MODE_CHANGED_ACTION, mRingerModeExternal);
    broadcastRingerMode(AudioManager.INTERNAL_RINGER_MODE_CHANGED_ACTION, mRingerMode);
    // Broadcast vibrate settings
    broadcastVibrateSetting(AudioManager.VIBRATE_TYPE_RINGER);
    broadcastVibrateSetting(AudioManager.VIBRATE_TYPE_NOTIFICATION);
    // Load settings for the volume controller
    mVolumeController.loadSettings(cr);
}
#end_block

#method_before
private void adjustStreamVolume(int streamType, int direction, int flags, String callingPackage, String caller, int uid) {
    if (mUseFixedVolume) {
        return;
    }
    if (DEBUG_VOL)
        Log.d(TAG, "adjustStreamVolume() stream=" + streamType + ", dir=" + direction + ", flags=" + flags + ", caller=" + caller);
    ensureValidDirection(direction);
    ensureValidStreamType(streamType);
    boolean isMuteAdjust = isMuteAdjust(direction);
    if (isMuteAdjust && !isStreamAffectedByMute(streamType)) {
        return;
    }
    // use stream type alias here so that streams with same alias have the same behavior,
    // including with regard to silent mode control (e.g the use of STREAM_RING below and in
    // checkForRingerModeChange() in place of STREAM_RING or STREAM_NOTIFICATION)
    int streamTypeAlias = mStreamVolumeAlias[streamType];
    VolumeStreamState streamState = mStreamStates[streamTypeAlias];
    final int device = getDeviceForStream(streamTypeAlias);
    int aliasIndex = streamState.getIndex(device);
    boolean adjustVolume = true;
    int step;
    // is not an a2dp device
    if ((device & AudioSystem.DEVICE_OUT_ALL_A2DP) == 0 && (flags & AudioManager.FLAG_BLUETOOTH_ABS_VOLUME) != 0) {
        return;
    }
    // so we handle user restrictions correctly.
    if (uid == android.os.Process.SYSTEM_UID) {
        uid = UserHandle.getUid(getCurrentUserId(), UserHandle.getAppId(uid));
    }
    if (mAppOps.noteOp(STREAM_VOLUME_OPS[streamTypeAlias], uid, callingPackage) != AppOpsManager.MODE_ALLOWED) {
        return;
    }
    // reset any pending volume command
    synchronized (mSafeMediaVolumeState) {
        mPendingVolumeCommand = null;
    }
    flags &= ~AudioManager.FLAG_FIXED_VOLUME;
    if ((streamTypeAlias == AudioSystem.STREAM_MUSIC) && ((device & mFixedVolumeDevices) != 0)) {
        flags |= AudioManager.FLAG_FIXED_VOLUME;
        // This is simulated by stepping by the full allowed volume range
        if (mSafeMediaVolumeState == SAFE_MEDIA_VOLUME_ACTIVE && (device & mSafeMediaVolumeDevices) != 0) {
            step = mSafeMediaVolumeIndex;
        } else {
            step = streamState.getMaxIndex();
        }
        if (aliasIndex != 0) {
            aliasIndex = step;
        }
    } else {
        // convert one UI step (+/-1) into a number of internal units on the stream alias
        step = rescaleIndex(10, streamType, streamTypeAlias);
    }
    // or the stream type is one that is affected by ringer modes
    if (((flags & AudioManager.FLAG_ALLOW_RINGER_MODES) != 0) || (streamTypeAlias == getUiSoundsStreamType())) {
        int ringerMode = getRingerModeInternal();
        // do not vibrate if already in vibrate mode
        if (ringerMode == AudioManager.RINGER_MODE_VIBRATE) {
            flags &= ~AudioManager.FLAG_VIBRATE;
        }
        // Check if the ringer mode handles this adjustment. If it does we don't
        // need to adjust the volume further.
        final int result = checkForRingerModeChange(aliasIndex, direction, step, streamState.mIsMuted);
        adjustVolume = (result & FLAG_ADJUST_VOLUME) != 0;
        // If suppressing a volume adjustment in silent mode, display the UI hint
        if ((result & AudioManager.FLAG_SHOW_SILENT_HINT) != 0) {
            flags |= AudioManager.FLAG_SHOW_SILENT_HINT;
        }
        // If suppressing a volume down adjustment in vibrate mode, display the UI hint
        if ((result & AudioManager.FLAG_SHOW_VIBRATE_HINT) != 0) {
            flags |= AudioManager.FLAG_SHOW_VIBRATE_HINT;
        }
    }
    // If the ringermode is suppressing media, prevent changes
    if (streamTypeAlias == AudioSystem.STREAM_MUSIC && (mRingerModeMutedStreams & (1 << AudioSystem.STREAM_MUSIC)) != 0) {
        adjustVolume = false;
    }
    int oldIndex = mStreamStates[streamType].getIndex(device);
    if (adjustVolume && (direction != AudioManager.ADJUST_SAME)) {
        mAudioHandler.removeMessages(MSG_UNMUTE_STREAM);
        // Check if volume update should be send to AVRCP
        if (streamTypeAlias == AudioSystem.STREAM_MUSIC && (device & AudioSystem.DEVICE_OUT_ALL_A2DP) != 0 && (flags & AudioManager.FLAG_BLUETOOTH_ABS_VOLUME) == 0) {
            synchronized (mA2dpAvrcpLock) {
                if (mA2dp != null && mAvrcpAbsVolSupported) {
                    mA2dp.adjustAvrcpAbsoluteVolume(direction);
                }
            }
        }
        if (isMuteAdjust) {
            boolean state;
            if (direction == AudioManager.ADJUST_TOGGLE_MUTE) {
                state = !streamState.mIsMuted;
            } else {
                state = direction == AudioManager.ADJUST_MUTE;
            }
            if (streamTypeAlias == AudioSystem.STREAM_MUSIC) {
                setSystemAudioMute(state);
            }
            for (int stream = 0; stream < mStreamStates.length; stream++) {
                if (streamTypeAlias == mStreamVolumeAlias[stream]) {
                    if (!(readCameraSoundForced() && (mStreamStates[stream].getStreamType() == AudioSystem.STREAM_SYSTEM_ENFORCED))) {
                        mStreamStates[stream].mute(state);
                    }
                }
            }
        } else if ((direction == AudioManager.ADJUST_RAISE) && !checkSafeMediaVolume(streamTypeAlias, aliasIndex + step, device)) {
            Log.e(TAG, "adjustStreamVolume() safe volume index = " + oldIndex);
            mVolumeController.postDisplaySafeVolumeWarning(flags);
        } else if (streamState.adjustIndex(direction * step, device, caller) || streamState.mIsMuted) {
            // message to persist).
            if (streamState.mIsMuted) {
                // Unmute the stream if it was previously muted
                if (direction == AudioManager.ADJUST_RAISE) {
                    // unmute immediately for volume up
                    streamState.mute(false);
                } else if (direction == AudioManager.ADJUST_LOWER) {
                    if (mPlatformType == AudioSystem.PLATFORM_TELEVISION) {
                        sendMsg(mAudioHandler, MSG_UNMUTE_STREAM, SENDMSG_QUEUE, streamTypeAlias, flags, null, UNMUTE_STREAM_DELAY);
                    }
                }
            }
            sendMsg(mAudioHandler, MSG_SET_DEVICE_VOLUME, SENDMSG_QUEUE, device, 0, streamState, 0);
        }
        // Check if volume update should be sent to Hdmi system audio.
        int newIndex = mStreamStates[streamType].getIndex(device);
        if (streamTypeAlias == AudioSystem.STREAM_MUSIC) {
            setSystemAudioVolume(oldIndex, newIndex, getStreamMaxVolume(streamType), flags);
        }
        if (mHdmiManager != null) {
            synchronized (mHdmiManager) {
                // mHdmiCecSink true => mHdmiPlaybackClient != null
                if (mHdmiCecSink && streamTypeAlias == AudioSystem.STREAM_MUSIC && oldIndex != newIndex) {
                    synchronized (mHdmiPlaybackClient) {
                        int keyCode = (direction == -1) ? KeyEvent.KEYCODE_VOLUME_DOWN : KeyEvent.KEYCODE_VOLUME_UP;
                        mHdmiPlaybackClient.sendKeyEvent(keyCode, true);
                        mHdmiPlaybackClient.sendKeyEvent(keyCode, false);
                    }
                }
            }
        }
    }
    int index = mStreamStates[streamType].getIndex(device);
    sendVolumeUpdate(streamType, oldIndex, index, flags);
}
#method_after
private void adjustStreamVolume(int streamType, int direction, int flags, String callingPackage, String caller, int uid) {
    if (mUseFixedVolume) {
        return;
    }
    if (DEBUG_VOL)
        Log.d(TAG, "adjustStreamVolume() stream=" + streamType + ", dir=" + direction + ", flags=" + flags + ", caller=" + caller);
    ensureValidDirection(direction);
    ensureValidStreamType(streamType);
    boolean isMuteAdjust = isMuteAdjust(direction);
    if (isMuteAdjust && !isStreamAffectedByMute(streamType)) {
        return;
    }
    // use stream type alias here so that streams with same alias have the same behavior,
    // including with regard to silent mode control (e.g the use of STREAM_RING below and in
    // checkForRingerModeChange() in place of STREAM_RING or STREAM_NOTIFICATION)
    int streamTypeAlias = mStreamVolumeAlias[streamType];
    VolumeStreamState streamState = mStreamStates[streamTypeAlias];
    final int device = getDeviceForStream(streamTypeAlias);
    int aliasIndex = streamState.getIndex(device);
    boolean adjustVolume = true;
    int step;
    // is not an a2dp device
    if ((device & AudioSystem.DEVICE_OUT_ALL_A2DP) == 0 && (flags & AudioManager.FLAG_BLUETOOTH_ABS_VOLUME) != 0) {
        return;
    }
    // so we handle user restrictions correctly.
    if (uid == android.os.Process.SYSTEM_UID) {
        uid = UserHandle.getUid(getCurrentUserId(), UserHandle.getAppId(uid));
    }
    if (mAppOps.noteOp(STREAM_VOLUME_OPS[streamTypeAlias], uid, callingPackage) != AppOpsManager.MODE_ALLOWED) {
        return;
    }
    // reset any pending volume command
    synchronized (mSafeMediaVolumeState) {
        mPendingVolumeCommand = null;
    }
    flags &= ~AudioManager.FLAG_FIXED_VOLUME;
    if ((streamTypeAlias == AudioSystem.STREAM_MUSIC) && ((device & mFixedVolumeDevices) != 0)) {
        flags |= AudioManager.FLAG_FIXED_VOLUME;
        // This is simulated by stepping by the full allowed volume range
        if (mSafeMediaVolumeState == SAFE_MEDIA_VOLUME_ACTIVE && (device & mSafeMediaVolumeDevices) != 0) {
            step = mSafeMediaVolumeIndex;
        } else {
            step = streamState.getMaxIndex();
        }
        if (aliasIndex != 0) {
            aliasIndex = step;
        }
    } else {
        // convert one UI step (+/-1) into a number of internal units on the stream alias
        step = rescaleIndex(10, streamType, streamTypeAlias);
    }
    // or the stream type is one that is affected by ringer modes
    if (((flags & AudioManager.FLAG_ALLOW_RINGER_MODES) != 0) || (streamTypeAlias == getUiSoundsStreamType())) {
        int ringerMode = getRingerModeInternal();
        // do not vibrate if already in vibrate mode
        if (ringerMode == AudioManager.RINGER_MODE_VIBRATE) {
            flags &= ~AudioManager.FLAG_VIBRATE;
        }
        // Check if the ringer mode handles this adjustment. If it does we don't
        // need to adjust the volume further.
        final int result = checkForRingerModeChange(aliasIndex, direction, step, streamState.mIsMuted, callingPackage, flags);
        adjustVolume = (result & FLAG_ADJUST_VOLUME) != 0;
        // If suppressing a volume adjustment in silent mode, display the UI hint
        if ((result & AudioManager.FLAG_SHOW_SILENT_HINT) != 0) {
            flags |= AudioManager.FLAG_SHOW_SILENT_HINT;
        }
        // If suppressing a volume down adjustment in vibrate mode, display the UI hint
        if ((result & AudioManager.FLAG_SHOW_VIBRATE_HINT) != 0) {
            flags |= AudioManager.FLAG_SHOW_VIBRATE_HINT;
        }
    }
    // If the ringermode is suppressing media, prevent changes
    if (!volumeAdjustmentAllowedByDnd(streamTypeAlias, flags)) {
        adjustVolume = false;
    }
    int oldIndex = mStreamStates[streamType].getIndex(device);
    if (adjustVolume && (direction != AudioManager.ADJUST_SAME)) {
        mAudioHandler.removeMessages(MSG_UNMUTE_STREAM);
        // Check if volume update should be send to AVRCP
        if (streamTypeAlias == AudioSystem.STREAM_MUSIC && (device & AudioSystem.DEVICE_OUT_ALL_A2DP) != 0 && (flags & AudioManager.FLAG_BLUETOOTH_ABS_VOLUME) == 0) {
            synchronized (mA2dpAvrcpLock) {
                if (mA2dp != null && mAvrcpAbsVolSupported) {
                    mA2dp.adjustAvrcpAbsoluteVolume(direction);
                }
            }
        }
        if (isMuteAdjust) {
            boolean state;
            if (direction == AudioManager.ADJUST_TOGGLE_MUTE) {
                state = !streamState.mIsMuted;
            } else {
                state = direction == AudioManager.ADJUST_MUTE;
            }
            if (streamTypeAlias == AudioSystem.STREAM_MUSIC) {
                setSystemAudioMute(state);
            }
            for (int stream = 0; stream < mStreamStates.length; stream++) {
                if (streamTypeAlias == mStreamVolumeAlias[stream]) {
                    if (!(readCameraSoundForced() && (mStreamStates[stream].getStreamType() == AudioSystem.STREAM_SYSTEM_ENFORCED))) {
                        mStreamStates[stream].mute(state);
                    }
                }
            }
        } else if ((direction == AudioManager.ADJUST_RAISE) && !checkSafeMediaVolume(streamTypeAlias, aliasIndex + step, device)) {
            Log.e(TAG, "adjustStreamVolume() safe volume index = " + oldIndex);
            mVolumeController.postDisplaySafeVolumeWarning(flags);
        } else if (streamState.adjustIndex(direction * step, device, caller) || streamState.mIsMuted) {
            // message to persist).
            if (streamState.mIsMuted) {
                // Unmute the stream if it was previously muted
                if (direction == AudioManager.ADJUST_RAISE) {
                    // unmute immediately for volume up
                    streamState.mute(false);
                } else if (direction == AudioManager.ADJUST_LOWER) {
                    if (mPlatformType == AudioSystem.PLATFORM_TELEVISION) {
                        sendMsg(mAudioHandler, MSG_UNMUTE_STREAM, SENDMSG_QUEUE, streamTypeAlias, flags, null, UNMUTE_STREAM_DELAY);
                    }
                }
            }
            sendMsg(mAudioHandler, MSG_SET_DEVICE_VOLUME, SENDMSG_QUEUE, device, 0, streamState, 0);
        }
        // Check if volume update should be sent to Hdmi system audio.
        int newIndex = mStreamStates[streamType].getIndex(device);
        if (streamTypeAlias == AudioSystem.STREAM_MUSIC) {
            setSystemAudioVolume(oldIndex, newIndex, getStreamMaxVolume(streamType), flags);
        }
        if (mHdmiManager != null) {
            synchronized (mHdmiManager) {
                // mHdmiCecSink true => mHdmiPlaybackClient != null
                if (mHdmiCecSink && streamTypeAlias == AudioSystem.STREAM_MUSIC && oldIndex != newIndex) {
                    synchronized (mHdmiPlaybackClient) {
                        int keyCode = (direction == -1) ? KeyEvent.KEYCODE_VOLUME_DOWN : KeyEvent.KEYCODE_VOLUME_UP;
                        final long ident = Binder.clearCallingIdentity();
                        try {
                            mHdmiPlaybackClient.sendKeyEvent(keyCode, true);
                            mHdmiPlaybackClient.sendKeyEvent(keyCode, false);
                        } finally {
                            Binder.restoreCallingIdentity(ident);
                        }
                    }
                }
            }
        }
    }
    int index = mStreamStates[streamType].getIndex(device);
    sendVolumeUpdate(streamType, oldIndex, index, flags);
}
#end_block

#method_before
private void onSetStreamVolume(int streamType, int index, int flags, int device, String caller) {
    final int stream = mStreamVolumeAlias[streamType];
    setStreamVolumeInt(stream, index, device, false, caller);
    // setting volume on ui sounds stream type also controls silent mode
    if (((flags & AudioManager.FLAG_ALLOW_RINGER_MODES) != 0) || (stream == getUiSoundsStreamType())) {
        int newRingerMode;
        if (index == 0) {
            newRingerMode = mHasVibrator ? AudioManager.RINGER_MODE_VIBRATE : mVolumePolicy.volumeDownToEnterSilent ? AudioManager.RINGER_MODE_SILENT : AudioManager.RINGER_MODE_NORMAL;
        } else {
            newRingerMode = AudioManager.RINGER_MODE_NORMAL;
        }
        setRingerMode(newRingerMode, TAG + ".onSetStreamVolume", false);
    }
    // setting non-zero volume for a muted stream unmutes the stream and vice versa
    mStreamStates[stream].mute(index == 0);
}
#method_after
private void onSetStreamVolume(int streamType, int index, int flags, int device, String caller) {
    final int stream = mStreamVolumeAlias[streamType];
    setStreamVolumeInt(stream, index, device, false, caller);
    // setting volume on ui sounds stream type also controls silent mode
    if (((flags & AudioManager.FLAG_ALLOW_RINGER_MODES) != 0) || (stream == getUiSoundsStreamType())) {
        setRingerMode(getNewRingerMode(stream, index, flags), TAG + ".onSetStreamVolume", false);
    }
    // setting non-zero volume for a muted stream unmutes the stream and vice versa
    mStreamStates[stream].mute(index == 0);
}
#end_block

#method_before
private void setStreamVolume(int streamType, int index, int flags, String callingPackage, String caller, int uid) {
    if (mUseFixedVolume) {
        return;
    }
    ensureValidStreamType(streamType);
    int streamTypeAlias = mStreamVolumeAlias[streamType];
    VolumeStreamState streamState = mStreamStates[streamTypeAlias];
    final int device = getDeviceForStream(streamType);
    int oldIndex;
    // is not an a2dp device
    if ((device & AudioSystem.DEVICE_OUT_ALL_A2DP) == 0 && (flags & AudioManager.FLAG_BLUETOOTH_ABS_VOLUME) != 0) {
        return;
    }
    // so we handle user restrictions correctly.
    if (uid == android.os.Process.SYSTEM_UID) {
        uid = UserHandle.getUid(getCurrentUserId(), UserHandle.getAppId(uid));
    }
    if (mAppOps.noteOp(STREAM_VOLUME_OPS[streamTypeAlias], uid, callingPackage) != AppOpsManager.MODE_ALLOWED) {
        return;
    }
    synchronized (mSafeMediaVolumeState) {
        // reset any pending volume command
        mPendingVolumeCommand = null;
        oldIndex = streamState.getIndex(device);
        index = rescaleIndex(index * 10, streamType, streamTypeAlias);
        if (streamTypeAlias == AudioSystem.STREAM_MUSIC && (device & AudioSystem.DEVICE_OUT_ALL_A2DP) != 0 && (flags & AudioManager.FLAG_BLUETOOTH_ABS_VOLUME) == 0) {
            synchronized (mA2dpAvrcpLock) {
                if (mA2dp != null && mAvrcpAbsVolSupported) {
                    mA2dp.setAvrcpAbsoluteVolume(index / 10);
                }
            }
        }
        if (streamTypeAlias == AudioSystem.STREAM_MUSIC) {
            setSystemAudioVolume(oldIndex, index, getStreamMaxVolume(streamType), flags);
        }
        flags &= ~AudioManager.FLAG_FIXED_VOLUME;
        if ((streamTypeAlias == AudioSystem.STREAM_MUSIC) && ((device & mFixedVolumeDevices) != 0)) {
            flags |= AudioManager.FLAG_FIXED_VOLUME;
            // volume is either 0 or max allowed for fixed volume devices
            if (index != 0) {
                if (mSafeMediaVolumeState == SAFE_MEDIA_VOLUME_ACTIVE && (device & mSafeMediaVolumeDevices) != 0) {
                    index = mSafeMediaVolumeIndex;
                } else {
                    index = streamState.getMaxIndex();
                }
            }
        }
        if (!checkSafeMediaVolume(streamTypeAlias, index, device)) {
            mVolumeController.postDisplaySafeVolumeWarning(flags);
            mPendingVolumeCommand = new StreamVolumeCommand(streamType, index, flags, device);
        } else {
            onSetStreamVolume(streamType, index, flags, device, caller);
            index = mStreamStates[streamType].getIndex(device);
        }
    }
    sendVolumeUpdate(streamType, oldIndex, index, flags);
}
#method_after
private void setStreamVolume(int streamType, int index, int flags, String callingPackage, String caller, int uid) {
    if (mUseFixedVolume) {
        return;
    }
    ensureValidStreamType(streamType);
    int streamTypeAlias = mStreamVolumeAlias[streamType];
    VolumeStreamState streamState = mStreamStates[streamTypeAlias];
    final int device = getDeviceForStream(streamType);
    int oldIndex;
    // is not an a2dp device
    if ((device & AudioSystem.DEVICE_OUT_ALL_A2DP) == 0 && (flags & AudioManager.FLAG_BLUETOOTH_ABS_VOLUME) != 0) {
        return;
    }
    // so we handle user restrictions correctly.
    if (uid == android.os.Process.SYSTEM_UID) {
        uid = UserHandle.getUid(getCurrentUserId(), UserHandle.getAppId(uid));
    }
    if (mAppOps.noteOp(STREAM_VOLUME_OPS[streamTypeAlias], uid, callingPackage) != AppOpsManager.MODE_ALLOWED) {
        return;
    }
    if (isAndroidNPlus(callingPackage) && wouldToggleZenMode(getNewRingerMode(streamTypeAlias, index, flags)) && !mNm.isNotificationPolicyAccessGrantedForPackage(callingPackage)) {
        throw new SecurityException("Not allowed to change Do Not Disturb state");
    }
    if (!volumeAdjustmentAllowedByDnd(streamTypeAlias, flags)) {
        return;
    }
    synchronized (mSafeMediaVolumeState) {
        // reset any pending volume command
        mPendingVolumeCommand = null;
        oldIndex = streamState.getIndex(device);
        index = rescaleIndex(index * 10, streamType, streamTypeAlias);
        if (streamTypeAlias == AudioSystem.STREAM_MUSIC && (device & AudioSystem.DEVICE_OUT_ALL_A2DP) != 0 && (flags & AudioManager.FLAG_BLUETOOTH_ABS_VOLUME) == 0) {
            synchronized (mA2dpAvrcpLock) {
                if (mA2dp != null && mAvrcpAbsVolSupported) {
                    mA2dp.setAvrcpAbsoluteVolume(index / 10);
                }
            }
        }
        if (streamTypeAlias == AudioSystem.STREAM_MUSIC) {
            setSystemAudioVolume(oldIndex, index, getStreamMaxVolume(streamType), flags);
        }
        flags &= ~AudioManager.FLAG_FIXED_VOLUME;
        if ((streamTypeAlias == AudioSystem.STREAM_MUSIC) && ((device & mFixedVolumeDevices) != 0)) {
            flags |= AudioManager.FLAG_FIXED_VOLUME;
            // volume is either 0 or max allowed for fixed volume devices
            if (index != 0) {
                if (mSafeMediaVolumeState == SAFE_MEDIA_VOLUME_ACTIVE && (device & mSafeMediaVolumeDevices) != 0) {
                    index = mSafeMediaVolumeIndex;
                } else {
                    index = streamState.getMaxIndex();
                }
            }
        }
        if (!checkSafeMediaVolume(streamTypeAlias, index, device)) {
            mVolumeController.postDisplaySafeVolumeWarning(flags);
            mPendingVolumeCommand = new StreamVolumeCommand(streamType, index, flags, device);
        } else {
            onSetStreamVolume(streamType, index, flags, device, caller);
            index = mStreamStates[streamType].getIndex(device);
        }
    }
    sendVolumeUpdate(streamType, oldIndex, index, flags);
}
#end_block

#method_before
private int getCurrentUserId() {
    final long ident = Binder.clearCallingIdentity();
    try {
        UserInfo currentUser = ActivityManagerNative.getDefault().getCurrentUser();
        return currentUser.id;
    } catch (RemoteException e) {
    // Activity manager not running, nothing we can do assume user 0.
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
    return UserHandle.USER_OWNER;
}
#method_after
private int getCurrentUserId() {
    final long ident = Binder.clearCallingIdentity();
    try {
        UserInfo currentUser = ActivityManagerNative.getDefault().getCurrentUser();
        return currentUser.id;
    } catch (RemoteException e) {
    // Activity manager not running, nothing we can do assume user 0.
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
    return UserHandle.USER_SYSTEM;
}
#end_block

#method_before
private void setMasterMuteInternal(boolean mute, int flags, String callingPackage, int uid, int userId) {
    // so we handle user restrictions correctly.
    if (uid == android.os.Process.SYSTEM_UID) {
        uid = UserHandle.getUid(userId, UserHandle.getAppId(uid));
    }
    if (mAppOps.noteOp(AppOpsManager.OP_AUDIO_MASTER_VOLUME, uid, callingPackage) != AppOpsManager.MODE_ALLOWED) {
        return;
    }
    if (userId != UserHandle.getCallingUserId() && mContext.checkCallingOrSelfPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED) {
        return;
    }
    if (getCurrentUserId() == userId) {
        if (mute != AudioSystem.getMasterMute()) {
            setSystemAudioMute(mute);
            AudioSystem.setMasterMute(mute);
            // Post a persist master volume msg
            sendMsg(mAudioHandler, MSG_PERSIST_MASTER_VOLUME_MUTE, SENDMSG_REPLACE, mute ? 1 : 0, userId, null, PERSIST_DELAY);
            sendMasterMuteUpdate(mute, flags);
            Intent intent = new Intent(AudioManager.MASTER_MUTE_CHANGED_ACTION);
            intent.putExtra(AudioManager.EXTRA_MASTER_VOLUME_MUTED, mute);
            sendBroadcastToAll(intent);
        }
    } else {
        // If not the current user just persist the setting which will be loaded
        // on user switch.
        sendMsg(mAudioHandler, MSG_PERSIST_MASTER_VOLUME_MUTE, SENDMSG_REPLACE, mute ? 1 : 0, userId, null, PERSIST_DELAY);
    }
}
#method_after
private void setMasterMuteInternal(boolean mute, int flags, String callingPackage, int uid, int userId) {
    // so we handle user restrictions correctly.
    if (uid == android.os.Process.SYSTEM_UID) {
        uid = UserHandle.getUid(userId, UserHandle.getAppId(uid));
    }
    // If OP_AUDIO_MASTER_VOLUME is set, disallow unmuting.
    if (!mute && mAppOps.noteOp(AppOpsManager.OP_AUDIO_MASTER_VOLUME, uid, callingPackage) != AppOpsManager.MODE_ALLOWED) {
        return;
    }
    if (userId != UserHandle.getCallingUserId() && mContext.checkCallingOrSelfPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED) {
        return;
    }
    setMasterMuteInternalNoCallerCheck(mute, flags, userId);
}
#end_block

#method_before
public void setMicrophoneMute(boolean on, String callingPackage, int userId) {
    // If we are being called by the system check for user we are going to change
    // so we handle user restrictions correctly.
    int uid = Binder.getCallingUid();
    if (uid == android.os.Process.SYSTEM_UID) {
        uid = UserHandle.getUid(userId, UserHandle.getAppId(uid));
    }
    if (mAppOps.noteOp(AppOpsManager.OP_MUTE_MICROPHONE, uid, callingPackage) != AppOpsManager.MODE_ALLOWED) {
        return;
    }
    if (!checkAudioSettingsPermission("setMicrophoneMute()")) {
        return;
    }
    if (userId != UserHandle.getCallingUserId() && mContext.checkCallingOrSelfPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED) {
        return;
    }
    // which will be loaded on user switch.
    if (getCurrentUserId() == userId) {
        AudioSystem.muteMicrophone(on);
    }
    // Post a persist microphone msg.
    sendMsg(mAudioHandler, MSG_PERSIST_MICROPHONE_MUTE, SENDMSG_REPLACE, on ? 1 : 0, userId, null, PERSIST_DELAY);
}
#method_after
@Override
public void setMicrophoneMute(boolean on, String callingPackage, int userId) {
    // If we are being called by the system check for user we are going to change
    // so we handle user restrictions correctly.
    int uid = Binder.getCallingUid();
    if (uid == android.os.Process.SYSTEM_UID) {
        uid = UserHandle.getUid(userId, UserHandle.getAppId(uid));
    }
    // If OP_MUTE_MICROPHONE is set, disallow unmuting.
    if (!on && mAppOps.noteOp(AppOpsManager.OP_MUTE_MICROPHONE, uid, callingPackage) != AppOpsManager.MODE_ALLOWED) {
        return;
    }
    if (!checkAudioSettingsPermission("setMicrophoneMute()")) {
        return;
    }
    if (userId != UserHandle.getCallingUserId() && mContext.checkCallingOrSelfPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED) {
        return;
    }
    setMicrophoneMuteNoCallerCheck(on, userId);
}
#end_block

#method_before
public void setRingerModeExternal(int ringerMode, String caller) {
    setRingerMode(ringerMode, caller, true);
}
#method_after
public void setRingerModeExternal(int ringerMode, String caller) {
    if (isAndroidNPlus(caller) && wouldToggleZenMode(ringerMode) && !mNm.isNotificationPolicyAccessGrantedForPackage(caller)) {
        throw new SecurityException("Not allowed to change Do Not Disturb state");
    }
    setRingerMode(ringerMode, caller, true);
}
#end_block

#method_before
private void readAudioSettings(boolean userSwitch) {
    // restore ringer mode, ringer mode affected streams, mute affected streams and vibrate settings
    readPersistedSettings();
    // restore volume settings
    int numStreamTypes = AudioSystem.getNumStreamTypes();
    for (int streamType = 0; streamType < numStreamTypes; streamType++) {
        VolumeStreamState streamState = mStreamStates[streamType];
        if (userSwitch && mStreamVolumeAlias[streamType] == AudioSystem.STREAM_MUSIC) {
            continue;
        }
        streamState.readSettings();
        synchronized (VolumeStreamState.class) {
            // unmute stream that was muted but is not affect by mute anymore
            if (streamState.mIsMuted && ((!isStreamAffectedByMute(streamType) && !isStreamMutedByRingerMode(streamType)) || mUseFixedVolume)) {
                streamState.mIsMuted = false;
            }
        }
    }
    // apply new ringer mode before checking volume for alias streams so that streams
    // muted by ringer mode have the correct volume
    setRingerModeInt(getRingerModeInternal(), false);
    checkAllFixedVolumeDevices();
    checkAllAliasStreamVolumes();
    checkMuteAffectedStreams();
    synchronized (mSafeMediaVolumeState) {
        mMusicActiveMs = MathUtils.constrain(Settings.Secure.getIntForUser(mContentResolver, Settings.Secure.UNSAFE_VOLUME_MUSIC_ACTIVE_MS, 0, UserHandle.USER_CURRENT), 0, UNSAFE_VOLUME_MUSIC_ACTIVE_MS_MAX);
        if (mSafeMediaVolumeState == SAFE_MEDIA_VOLUME_ACTIVE) {
            enforceSafeMediaVolume(TAG);
        }
    }
}
#method_after
private void readAudioSettings(boolean userSwitch) {
    // restore ringer mode, ringer mode affected streams, mute affected streams and vibrate settings
    readPersistedSettings();
    readUserRestrictions();
    // restore volume settings
    int numStreamTypes = AudioSystem.getNumStreamTypes();
    for (int streamType = 0; streamType < numStreamTypes; streamType++) {
        VolumeStreamState streamState = mStreamStates[streamType];
        if (userSwitch && mStreamVolumeAlias[streamType] == AudioSystem.STREAM_MUSIC) {
            continue;
        }
        streamState.readSettings();
        synchronized (VolumeStreamState.class) {
            // unmute stream that was muted but is not affect by mute anymore
            if (streamState.mIsMuted && ((!isStreamAffectedByMute(streamType) && !isStreamMutedByRingerMode(streamType)) || mUseFixedVolume)) {
                streamState.mIsMuted = false;
            }
        }
    }
    // apply new ringer mode before checking volume for alias streams so that streams
    // muted by ringer mode have the correct volume
    setRingerModeInt(getRingerModeInternal(), false);
    checkAllFixedVolumeDevices();
    checkAllAliasStreamVolumes();
    checkMuteAffectedStreams();
    synchronized (mSafeMediaVolumeState) {
        mMusicActiveMs = MathUtils.constrain(Settings.Secure.getIntForUser(mContentResolver, Settings.Secure.UNSAFE_VOLUME_MUSIC_ACTIVE_MS, 0, UserHandle.USER_CURRENT), 0, UNSAFE_VOLUME_MUSIC_ACTIVE_MS_MAX);
        if (mSafeMediaVolumeState == SAFE_MEDIA_VOLUME_ACTIVE) {
            enforceSafeMediaVolume(TAG);
        }
    }
}
#end_block

#method_before
// /////////////////////////////////////////////////////////////////////////
// Internal methods
// /////////////////////////////////////////////////////////////////////////
private int checkForRingerModeChange(int oldIndex, int direction, int step, boolean isMuted) {
    final boolean isTv = mPlatformType == AudioSystem.PLATFORM_TELEVISION;
    int result = FLAG_ADJUST_VOLUME;
    int ringerMode = getRingerModeInternal();
    switch(ringerMode) {
        case RINGER_MODE_NORMAL:
            if (direction == AudioManager.ADJUST_LOWER) {
                if (mHasVibrator) {
                    // (step <= oldIndex < 2 * step) is equivalent to: (old UI index == 1)
                    if (step <= oldIndex && oldIndex < 2 * step) {
                        ringerMode = RINGER_MODE_VIBRATE;
                        mLoweredFromNormalToVibrateTime = SystemClock.uptimeMillis();
                    }
                } else {
                    if (oldIndex == step && mVolumePolicy.volumeDownToEnterSilent) {
                        ringerMode = RINGER_MODE_SILENT;
                    }
                }
            } else if (isTv && (direction == AudioManager.ADJUST_TOGGLE_MUTE || direction == AudioManager.ADJUST_MUTE)) {
                if (mHasVibrator) {
                    ringerMode = RINGER_MODE_VIBRATE;
                } else {
                    ringerMode = RINGER_MODE_SILENT;
                }
                // Setting the ringer mode will toggle mute
                result &= ~FLAG_ADJUST_VOLUME;
            }
            break;
        case RINGER_MODE_VIBRATE:
            if (!mHasVibrator) {
                Log.e(TAG, "checkForRingerModeChange() current ringer mode is vibrate" + "but no vibrator is present");
                break;
            }
            if ((direction == AudioManager.ADJUST_LOWER)) {
                // This is the case we were muted with the volume turned up
                if (isTv && oldIndex >= 2 * step && isMuted) {
                    ringerMode = RINGER_MODE_NORMAL;
                } else if (mPrevVolDirection != AudioManager.ADJUST_LOWER) {
                    if (mVolumePolicy.volumeDownToEnterSilent) {
                        final long diff = SystemClock.uptimeMillis() - mLoweredFromNormalToVibrateTime;
                        if (diff > mVolumePolicy.vibrateToSilentDebounce && mRingerModeDelegate.canVolumeDownEnterSilent()) {
                            ringerMode = RINGER_MODE_SILENT;
                        }
                    } else {
                        result |= AudioManager.FLAG_SHOW_VIBRATE_HINT;
                    }
                }
            } else if (direction == AudioManager.ADJUST_RAISE || direction == AudioManager.ADJUST_TOGGLE_MUTE || direction == AudioManager.ADJUST_UNMUTE) {
                ringerMode = RINGER_MODE_NORMAL;
            }
            result &= ~FLAG_ADJUST_VOLUME;
            break;
        case RINGER_MODE_SILENT:
            if (isTv && direction == AudioManager.ADJUST_LOWER && oldIndex >= 2 * step && isMuted) {
                // This is the case we were muted with the volume turned up
                ringerMode = RINGER_MODE_NORMAL;
            } else if (direction == AudioManager.ADJUST_RAISE || direction == AudioManager.ADJUST_TOGGLE_MUTE || direction == AudioManager.ADJUST_UNMUTE) {
                if (!mVolumePolicy.volumeUpToExitSilent) {
                    result |= AudioManager.FLAG_SHOW_SILENT_HINT;
                } else {
                    if (mHasVibrator && direction == AudioManager.ADJUST_RAISE) {
                        ringerMode = RINGER_MODE_VIBRATE;
                    } else {
                        // If we don't have a vibrator or they were toggling mute
                        // go straight back to normal.
                        ringerMode = RINGER_MODE_NORMAL;
                    }
                }
            }
            result &= ~FLAG_ADJUST_VOLUME;
            break;
        default:
            Log.e(TAG, "checkForRingerModeChange() wrong ringer mode: " + ringerMode);
            break;
    }
    setRingerMode(ringerMode, TAG + ".checkForRingerModeChange", false);
    mPrevVolDirection = direction;
    return result;
}
#method_after
// /////////////////////////////////////////////////////////////////////////
// Internal methods
// /////////////////////////////////////////////////////////////////////////
private int checkForRingerModeChange(int oldIndex, int direction, int step, boolean isMuted, String caller, int flags) {
    final boolean isTv = mPlatformType == AudioSystem.PLATFORM_TELEVISION;
    int result = FLAG_ADJUST_VOLUME;
    int ringerMode = getRingerModeInternal();
    switch(ringerMode) {
        case RINGER_MODE_NORMAL:
            if (direction == AudioManager.ADJUST_LOWER) {
                if (mHasVibrator) {
                    // (step <= oldIndex < 2 * step) is equivalent to: (old UI index == 1)
                    if (step <= oldIndex && oldIndex < 2 * step) {
                        ringerMode = RINGER_MODE_VIBRATE;
                        mLoweredFromNormalToVibrateTime = SystemClock.uptimeMillis();
                    }
                } else {
                    if (oldIndex == step && mVolumePolicy.volumeDownToEnterSilent) {
                        ringerMode = RINGER_MODE_SILENT;
                    }
                }
            } else if (isTv && (direction == AudioManager.ADJUST_TOGGLE_MUTE || direction == AudioManager.ADJUST_MUTE)) {
                if (mHasVibrator) {
                    ringerMode = RINGER_MODE_VIBRATE;
                } else {
                    ringerMode = RINGER_MODE_SILENT;
                }
                // Setting the ringer mode will toggle mute
                result &= ~FLAG_ADJUST_VOLUME;
            }
            break;
        case RINGER_MODE_VIBRATE:
            if (!mHasVibrator) {
                Log.e(TAG, "checkForRingerModeChange() current ringer mode is vibrate" + "but no vibrator is present");
                break;
            }
            if ((direction == AudioManager.ADJUST_LOWER)) {
                // This is the case we were muted with the volume turned up
                if (isTv && oldIndex >= 2 * step && isMuted) {
                    ringerMode = RINGER_MODE_NORMAL;
                } else if (mPrevVolDirection != AudioManager.ADJUST_LOWER) {
                    if (mVolumePolicy.volumeDownToEnterSilent) {
                        final long diff = SystemClock.uptimeMillis() - mLoweredFromNormalToVibrateTime;
                        if (diff > mVolumePolicy.vibrateToSilentDebounce && mRingerModeDelegate.canVolumeDownEnterSilent()) {
                            ringerMode = RINGER_MODE_SILENT;
                        }
                    } else {
                        result |= AudioManager.FLAG_SHOW_VIBRATE_HINT;
                    }
                }
            } else if (direction == AudioManager.ADJUST_RAISE || direction == AudioManager.ADJUST_TOGGLE_MUTE || direction == AudioManager.ADJUST_UNMUTE) {
                ringerMode = RINGER_MODE_NORMAL;
            }
            result &= ~FLAG_ADJUST_VOLUME;
            break;
        case RINGER_MODE_SILENT:
            if (isTv && direction == AudioManager.ADJUST_LOWER && oldIndex >= 2 * step && isMuted) {
                // This is the case we were muted with the volume turned up
                ringerMode = RINGER_MODE_NORMAL;
            } else if (direction == AudioManager.ADJUST_RAISE || direction == AudioManager.ADJUST_TOGGLE_MUTE || direction == AudioManager.ADJUST_UNMUTE) {
                if (!mVolumePolicy.volumeUpToExitSilent) {
                    result |= AudioManager.FLAG_SHOW_SILENT_HINT;
                } else {
                    if (mHasVibrator && direction == AudioManager.ADJUST_RAISE) {
                        ringerMode = RINGER_MODE_VIBRATE;
                    } else {
                        // If we don't have a vibrator or they were toggling mute
                        // go straight back to normal.
                        ringerMode = RINGER_MODE_NORMAL;
                    }
                }
            }
            result &= ~FLAG_ADJUST_VOLUME;
            break;
        default:
            Log.e(TAG, "checkForRingerModeChange() wrong ringer mode: " + ringerMode);
            break;
    }
    if (isAndroidNPlus(caller) && wouldToggleZenMode(ringerMode) && !mNm.isNotificationPolicyAccessGrantedForPackage(caller) && (flags & AudioManager.FLAG_FROM_KEY) == 0) {
        throw new SecurityException("Not allowed to change Do Not Disturb state");
    }
    setRingerMode(ringerMode, TAG + ".checkForRingerModeChange", false);
    mPrevVolDirection = direction;
    return result;
}
#end_block

#method_before
public void applyDeviceVolume_syncVSS(int device) {
    int index;
    if (mIsMuted) {
        index = 0;
    } else if ((device & AudioSystem.DEVICE_OUT_ALL_A2DP) != 0 && mAvrcpAbsVolSupported) {
        /* Special handling for Bluetooth Absolute Volume scenario
                 * If we send full audio gain, some accessories are too loud even at its lowest
                 * volume. We are not able to enumerate all such accessories, so here is the
                 * workaround from phone side.
                 * For the lowest volume steps 1 2 and 3, restrict audio gain to 50% 70% and 85%.
                 * For volume step 0, set audio gain to 0 as some accessories won't mute on their end.
                 */
        int i = (getIndex(device) + 5) / 10;
        if (i == 0) {
            // 0% for volume 0
            index = 0;
        } else if (i == 1) {
            // 50% for volume 1
            index = (int) (mIndexMax * 0.5) / 10;
        } else if (i == 2) {
            // 70% for volume 2
            index = (int) (mIndexMax * 0.70) / 10;
        } else if (i == 3) {
            // 85% for volume 3
            index = (int) (mIndexMax * 0.85) / 10;
        } else {
            // otherwise, full gain
            index = (mIndexMax + 5) / 10;
        }
    } else if ((device & mFullVolumeDevices) != 0) {
        index = (mIndexMax + 5) / 10;
    } else {
        index = (getIndex(device) + 5) / 10;
    }
    AudioSystem.setStreamVolumeIndex(mStreamType, index, device);
}
#method_after
public void applyDeviceVolume_syncVSS(int device) {
    int index;
    if (mIsMuted) {
        index = 0;
    } else if ((device & AudioSystem.DEVICE_OUT_ALL_A2DP) != 0 && mAvrcpAbsVolSupported) {
        index = getAbsoluteVolumeIndex((getIndex(device) + 5) / 10);
    } else if ((device & mFullVolumeDevices) != 0) {
        index = (mIndexMax + 5) / 10;
    } else {
        index = (getIndex(device) + 5) / 10;
    }
    AudioSystem.setStreamVolumeIndex(mStreamType, index, device);
}
#end_block

#method_before
public void applyAllVolumes() {
    synchronized (VolumeStreamState.class) {
        // apply default volume first: by convention this will reset all
        // devices volumes in audio policy manager to the supplied value
        int index;
        if (mIsMuted) {
            index = 0;
        } else {
            index = (getIndex(AudioSystem.DEVICE_OUT_DEFAULT) + 5) / 10;
        }
        AudioSystem.setStreamVolumeIndex(mStreamType, index, AudioSystem.DEVICE_OUT_DEFAULT);
        // then apply device specific volumes
        for (int i = 0; i < mIndexMap.size(); i++) {
            int device = mIndexMap.keyAt(i);
            if (device != AudioSystem.DEVICE_OUT_DEFAULT) {
                if (mIsMuted) {
                    index = 0;
                } else if ((device & AudioSystem.DEVICE_OUT_ALL_A2DP) != 0 && mAvrcpAbsVolSupported) {
                    /* Special handling for Bluetooth Absolute Volume scenario
                             * when remote device tune volume out of mute
                             */
                    int j = (getIndex(device) + 5) / 10;
                    if (j == 1) {
                        // 50% for volume 1
                        index = (int) (mIndexMax * 0.5) / 10;
                    } else if (j == 2) {
                        // 70% for volume 2
                        index = (int) (mIndexMax * 0.70) / 10;
                    } else if (j == 3) {
                        // 85% for volume 3
                        index = (int) (mIndexMax * 0.85) / 10;
                    } else {
                        // otherwise, full gain
                        index = (mIndexMax + 5) / 10;
                    }
                } else if ((device & mFullVolumeDevices) != 0) {
                    index = (mIndexMax + 5) / 10;
                } else {
                    index = (mIndexMap.valueAt(i) + 5) / 10;
                }
                AudioSystem.setStreamVolumeIndex(mStreamType, index, device);
            }
        }
    }
}
#method_after
public void applyAllVolumes() {
    synchronized (VolumeStreamState.class) {
        // apply device specific volumes first
        int index;
        for (int i = 0; i < mIndexMap.size(); i++) {
            final int device = mIndexMap.keyAt(i);
            if (device != AudioSystem.DEVICE_OUT_DEFAULT) {
                if (mIsMuted) {
                    index = 0;
                } else if ((device & AudioSystem.DEVICE_OUT_ALL_A2DP) != 0 && mAvrcpAbsVolSupported) {
                    index = getAbsoluteVolumeIndex((getIndex(device) + 5) / 10);
                } else if ((device & mFullVolumeDevices) != 0) {
                    index = (mIndexMax + 5) / 10;
                } else {
                    index = (mIndexMap.valueAt(i) + 5) / 10;
                }
                AudioSystem.setStreamVolumeIndex(mStreamType, index, device);
            }
        }
        // by audio policy manager if no explicit volume is present for a given device type
        if (mIsMuted) {
            index = 0;
        } else {
            index = (getIndex(AudioSystem.DEVICE_OUT_DEFAULT) + 5) / 10;
        }
        AudioSystem.setStreamVolumeIndex(mStreamType, index, AudioSystem.DEVICE_OUT_DEFAULT);
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_SET_DEVICE_VOLUME:
            setDeviceVolume((VolumeStreamState) msg.obj, msg.arg1);
            break;
        case MSG_SET_ALL_VOLUMES:
            setAllVolumes((VolumeStreamState) msg.obj);
            break;
        case MSG_PERSIST_VOLUME:
            persistVolume((VolumeStreamState) msg.obj, msg.arg1);
            break;
        case MSG_PERSIST_MASTER_VOLUME_MUTE:
            if (mUseFixedVolume) {
                return;
            }
            Settings.System.putIntForUser(mContentResolver, Settings.System.VOLUME_MASTER_MUTE, msg.arg1, msg.arg2);
            break;
        case MSG_PERSIST_RINGER_MODE:
            // note that the value persisted is the current ringer mode, not the
            // value of ringer mode as of the time the request was made to persist
            persistRingerMode(getRingerModeInternal());
            break;
        case MSG_MEDIA_SERVER_DIED:
            onMediaServerDied();
            break;
        case MSG_UNLOAD_SOUND_EFFECTS:
            onUnloadSoundEffects();
            break;
        case MSG_LOAD_SOUND_EFFECTS:
            // FIXME: onLoadSoundEffects() should be executed in a separate thread as it
            // can take several dozens of milliseconds to complete
            boolean loaded = onLoadSoundEffects();
            if (msg.obj != null) {
                LoadSoundEffectReply reply = (LoadSoundEffectReply) msg.obj;
                synchronized (reply) {
                    reply.mStatus = loaded ? 0 : -1;
                    reply.notify();
                }
            }
            break;
        case MSG_PLAY_SOUND_EFFECT:
            onPlaySoundEffect(msg.arg1, msg.arg2);
            break;
        case MSG_BTA2DP_DOCK_TIMEOUT:
            // msg.obj  == address of BTA2DP device
            synchronized (mConnectedDevices) {
                makeA2dpDeviceUnavailableNow((String) msg.obj);
            }
            break;
        case MSG_SET_FORCE_USE:
        case MSG_SET_FORCE_BT_A2DP_USE:
            setForceUse(msg.arg1, msg.arg2);
            break;
        case MSG_BT_HEADSET_CNCT_FAILED:
            resetBluetoothSco();
            break;
        case MSG_SET_WIRED_DEVICE_CONNECTION_STATE:
            {
                WiredDeviceConnectionState connectState = (WiredDeviceConnectionState) msg.obj;
                onSetWiredDeviceConnectionState(connectState.mType, connectState.mState, connectState.mAddress, connectState.mName, connectState.mCaller);
                mAudioEventWakeLock.release();
            }
            break;
        case MSG_SET_A2DP_SRC_CONNECTION_STATE:
            onSetA2dpSourceConnectionState((BluetoothDevice) msg.obj, msg.arg1);
            mAudioEventWakeLock.release();
            break;
        case MSG_SET_A2DP_SINK_CONNECTION_STATE:
            onSetA2dpSinkConnectionState((BluetoothDevice) msg.obj, msg.arg1);
            mAudioEventWakeLock.release();
            break;
        case MSG_REPORT_NEW_ROUTES:
            {
                int N = mRoutesObservers.beginBroadcast();
                if (N > 0) {
                    AudioRoutesInfo routes;
                    synchronized (mCurAudioRoutes) {
                        routes = new AudioRoutesInfo(mCurAudioRoutes);
                    }
                    while (N > 0) {
                        N--;
                        IAudioRoutesObserver obs = mRoutesObservers.getBroadcastItem(N);
                        try {
                            obs.dispatchAudioRoutesChanged(routes);
                        } catch (RemoteException e) {
                        }
                    }
                }
                mRoutesObservers.finishBroadcast();
                observeDevicesForStreams(-1);
                break;
            }
        case MSG_CHECK_MUSIC_ACTIVE:
            onCheckMusicActive((String) msg.obj);
            break;
        case MSG_BROADCAST_AUDIO_BECOMING_NOISY:
            onSendBecomingNoisyIntent();
            break;
        case MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED:
        case MSG_CONFIGURE_SAFE_MEDIA_VOLUME:
            onConfigureSafeVolume((msg.what == MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED), (String) msg.obj);
            break;
        case MSG_PERSIST_SAFE_VOLUME_STATE:
            onPersistSafeVolumeState(msg.arg1);
            break;
        case MSG_BROADCAST_BT_CONNECTION_STATE:
            onBroadcastScoConnectionState(msg.arg1);
            break;
        case MSG_SYSTEM_READY:
            onSystemReady();
            break;
        case MSG_INDICATE_SYSTEM_READY:
            onIndicateSystemReady();
            break;
        case MSG_PERSIST_MUSIC_ACTIVE_MS:
            final int musicActiveMs = msg.arg1;
            Settings.Secure.putIntForUser(mContentResolver, Settings.Secure.UNSAFE_VOLUME_MUSIC_ACTIVE_MS, musicActiveMs, UserHandle.USER_CURRENT);
            break;
        case MSG_PERSIST_MICROPHONE_MUTE:
            Settings.System.putIntForUser(mContentResolver, Settings.System.MICROPHONE_MUTE, msg.arg1, msg.arg2);
            break;
        case MSG_UNMUTE_STREAM:
            onUnmuteStream(msg.arg1, msg.arg2);
            break;
        case MSG_DYN_POLICY_MIX_STATE_UPDATE:
            onDynPolicyMixStateUpdate((String) msg.obj, msg.arg1);
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_SET_DEVICE_VOLUME:
            setDeviceVolume((VolumeStreamState) msg.obj, msg.arg1);
            break;
        case MSG_SET_ALL_VOLUMES:
            setAllVolumes((VolumeStreamState) msg.obj);
            break;
        case MSG_PERSIST_VOLUME:
            persistVolume((VolumeStreamState) msg.obj, msg.arg1);
            break;
        case MSG_PERSIST_RINGER_MODE:
            // note that the value persisted is the current ringer mode, not the
            // value of ringer mode as of the time the request was made to persist
            persistRingerMode(getRingerModeInternal());
            break;
        case MSG_AUDIO_SERVER_DIED:
            onAudioServerDied();
            break;
        case MSG_UNLOAD_SOUND_EFFECTS:
            onUnloadSoundEffects();
            break;
        case MSG_LOAD_SOUND_EFFECTS:
            // FIXME: onLoadSoundEffects() should be executed in a separate thread as it
            // can take several dozens of milliseconds to complete
            boolean loaded = onLoadSoundEffects();
            if (msg.obj != null) {
                LoadSoundEffectReply reply = (LoadSoundEffectReply) msg.obj;
                synchronized (reply) {
                    reply.mStatus = loaded ? 0 : -1;
                    reply.notify();
                }
            }
            break;
        case MSG_PLAY_SOUND_EFFECT:
            onPlaySoundEffect(msg.arg1, msg.arg2);
            break;
        case MSG_BTA2DP_DOCK_TIMEOUT:
            // msg.obj  == address of BTA2DP device
            synchronized (mConnectedDevices) {
                makeA2dpDeviceUnavailableNow((String) msg.obj);
            }
            break;
        case MSG_SET_FORCE_USE:
        case MSG_SET_FORCE_BT_A2DP_USE:
            setForceUse(msg.arg1, msg.arg2);
            break;
        case MSG_BT_HEADSET_CNCT_FAILED:
            resetBluetoothSco();
            break;
        case MSG_SET_WIRED_DEVICE_CONNECTION_STATE:
            {
                WiredDeviceConnectionState connectState = (WiredDeviceConnectionState) msg.obj;
                onSetWiredDeviceConnectionState(connectState.mType, connectState.mState, connectState.mAddress, connectState.mName, connectState.mCaller);
                mAudioEventWakeLock.release();
            }
            break;
        case MSG_SET_A2DP_SRC_CONNECTION_STATE:
            onSetA2dpSourceConnectionState((BluetoothDevice) msg.obj, msg.arg1);
            mAudioEventWakeLock.release();
            break;
        case MSG_SET_A2DP_SINK_CONNECTION_STATE:
            onSetA2dpSinkConnectionState((BluetoothDevice) msg.obj, msg.arg1);
            mAudioEventWakeLock.release();
            break;
        case MSG_REPORT_NEW_ROUTES:
            {
                int N = mRoutesObservers.beginBroadcast();
                if (N > 0) {
                    AudioRoutesInfo routes;
                    synchronized (mCurAudioRoutes) {
                        routes = new AudioRoutesInfo(mCurAudioRoutes);
                    }
                    while (N > 0) {
                        N--;
                        IAudioRoutesObserver obs = mRoutesObservers.getBroadcastItem(N);
                        try {
                            obs.dispatchAudioRoutesChanged(routes);
                        } catch (RemoteException e) {
                        }
                    }
                }
                mRoutesObservers.finishBroadcast();
                observeDevicesForStreams(-1);
                break;
            }
        case MSG_CHECK_MUSIC_ACTIVE:
            onCheckMusicActive((String) msg.obj);
            break;
        case MSG_BROADCAST_AUDIO_BECOMING_NOISY:
            onSendBecomingNoisyIntent();
            break;
        case MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED:
        case MSG_CONFIGURE_SAFE_MEDIA_VOLUME:
            onConfigureSafeVolume((msg.what == MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED), (String) msg.obj);
            break;
        case MSG_PERSIST_SAFE_VOLUME_STATE:
            onPersistSafeVolumeState(msg.arg1);
            break;
        case MSG_BROADCAST_BT_CONNECTION_STATE:
            onBroadcastScoConnectionState(msg.arg1);
            break;
        case MSG_SYSTEM_READY:
            onSystemReady();
            break;
        case MSG_INDICATE_SYSTEM_READY:
            onIndicateSystemReady();
            break;
        case MSG_PERSIST_MUSIC_ACTIVE_MS:
            final int musicActiveMs = msg.arg1;
            Settings.Secure.putIntForUser(mContentResolver, Settings.Secure.UNSAFE_VOLUME_MUSIC_ACTIVE_MS, musicActiveMs, UserHandle.USER_CURRENT);
            break;
        case MSG_UNMUTE_STREAM:
            onUnmuteStream(msg.arg1, msg.arg2);
            break;
        case MSG_DYN_POLICY_MIX_STATE_UPDATE:
            onDynPolicyMixStateUpdate((String) msg.obj, msg.arg1);
            break;
    }
}
#end_block

#method_before
@Override
public void onChange(boolean selfChange) {
    super.onChange(selfChange);
    // mRingerModeMutedStreams and mMuteAffectedStreams are safe (only accessed once).
    synchronized (mSettingsLock) {
        if (updateRingerModeAffectedStreams()) {
            /*
                     * Ensure all stream types that should be affected by ringer mode
                     * are in the proper state.
                     */
            setRingerModeInt(getRingerModeInternal(), false);
        }
        readDockAudioSettings(mContentResolver);
    }
}
#method_after
@Override
public void onChange(boolean selfChange) {
    super.onChange(selfChange);
    // mRingerModeMutedStreams and mMuteAffectedStreams are safe (only accessed once).
    synchronized (mSettingsLock) {
        if (updateRingerModeAffectedStreams()) {
            /*
                     * Ensure all stream types that should be affected by ringer mode
                     * are in the proper state.
                     */
            setRingerModeInt(getRingerModeInternal(), false);
        }
        readDockAudioSettings(mContentResolver);
        updateMasterMono(mContentResolver);
        updateEncodedSurroundOutput();
    }
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    String action = intent.getAction();
    int outDevice;
    int inDevice;
    int state;
    if (action.equals(Intent.ACTION_DOCK_EVENT)) {
        int dockState = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
        int config;
        switch(dockState) {
            case Intent.EXTRA_DOCK_STATE_DESK:
                config = AudioSystem.FORCE_BT_DESK_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_CAR:
                config = AudioSystem.FORCE_BT_CAR_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_LE_DESK:
                config = AudioSystem.FORCE_ANALOG_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_HE_DESK:
                config = AudioSystem.FORCE_DIGITAL_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_UNDOCKED:
            default:
                config = AudioSystem.FORCE_NONE;
        }
        // (see mDockAudioMediaEnabled)
        if (!((dockState == Intent.EXTRA_DOCK_STATE_LE_DESK) || ((dockState == Intent.EXTRA_DOCK_STATE_UNDOCKED) && (mDockState == Intent.EXTRA_DOCK_STATE_LE_DESK)))) {
            AudioSystem.setForceUse(AudioSystem.FOR_DOCK, config);
        }
        mDockState = dockState;
    } else if (action.equals(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED)) {
        state = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, BluetoothProfile.STATE_DISCONNECTED);
        BluetoothDevice btDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        setBtScoDeviceConnectionState(btDevice, state);
    } else if (action.equals(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED)) {
        boolean broadcast = false;
        int scoAudioState = AudioManager.SCO_AUDIO_STATE_ERROR;
        synchronized (mScoClients) {
            int btState = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, -1);
            // broadcast intent if the connection was initated by AudioService
            if (!mScoClients.isEmpty() && (mScoAudioState == SCO_STATE_ACTIVE_INTERNAL || mScoAudioState == SCO_STATE_ACTIVATE_REQ || mScoAudioState == SCO_STATE_DEACTIVATE_REQ)) {
                broadcast = true;
            }
            switch(btState) {
                case BluetoothHeadset.STATE_AUDIO_CONNECTED:
                    scoAudioState = AudioManager.SCO_AUDIO_STATE_CONNECTED;
                    if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL && mScoAudioState != SCO_STATE_DEACTIVATE_REQ && mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
                        mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
                    }
                    break;
                case BluetoothHeadset.STATE_AUDIO_DISCONNECTED:
                    scoAudioState = AudioManager.SCO_AUDIO_STATE_DISCONNECTED;
                    mScoAudioState = SCO_STATE_INACTIVE;
                    clearAllScoClients(0, false);
                    break;
                case BluetoothHeadset.STATE_AUDIO_CONNECTING:
                    if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL && mScoAudioState != SCO_STATE_DEACTIVATE_REQ && mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
                        mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
                    }
                default:
                    // do not broadcast CONNECTING or invalid state
                    broadcast = false;
                    break;
            }
        }
        if (broadcast) {
            broadcastScoConnectionState(scoAudioState);
            // FIXME: this is to maintain compatibility with deprecated intent
            // AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED. Remove when appropriate.
            Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
            newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE, scoAudioState);
            sendStickyBroadcastToAll(newIntent);
        }
    } else if (action.equals(Intent.ACTION_SCREEN_ON)) {
        if (mMonitorRotation) {
            RotationHelper.enable();
        }
        AudioSystem.setParameters("screen_state=on");
    } else if (action.equals(Intent.ACTION_SCREEN_OFF)) {
        if (mMonitorRotation) {
            // reduce wakeups (save current) by only listening when display is on
            RotationHelper.disable();
        }
        AudioSystem.setParameters("screen_state=off");
    } else if (action.equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
        handleConfigurationChanged(context);
    } else if (action.equals(Intent.ACTION_USER_SWITCHED)) {
        // attempt to stop music playback for background user
        sendMsg(mAudioHandler, MSG_BROADCAST_AUDIO_BECOMING_NOISY, SENDMSG_REPLACE, 0, 0, null, 0);
        // the current audio focus owner is no longer valid
        mMediaFocusControl.discardAudioFocusOwner();
        // load volume settings for new user
        readAudioSettings(true);
        // preserve STREAM_MUSIC volume from one user to the next.
        sendMsg(mAudioHandler, MSG_SET_ALL_VOLUMES, SENDMSG_QUEUE, 0, 0, mStreamStates[AudioSystem.STREAM_MUSIC], 0);
    } else if (action.equals(Intent.ACTION_USER_BACKGROUND)) {
        // Disable audio recording for the background user/profile
        int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);
        if (userId >= 0) {
            // TODO Kill recording streams instead of killing processes holding permission
            UserInfo userInfo = UserManagerService.getInstance().getUserInfo(userId);
            killBackgroundUserProcessesWithRecordAudioPermission(userInfo);
        }
        UserManagerService.getInstance().setSystemControlledUserRestriction(UserManager.DISALLOW_RECORD_AUDIO, true, userId);
    } else if (action.equals(Intent.ACTION_USER_FOREGROUND)) {
        // Enable audio recording for foreground user/profile
        int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);
        UserManagerService.getInstance().setSystemControlledUserRestriction(UserManager.DISALLOW_RECORD_AUDIO, false, userId);
    }
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    String action = intent.getAction();
    int outDevice;
    int inDevice;
    int state;
    if (action.equals(Intent.ACTION_DOCK_EVENT)) {
        int dockState = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
        int config;
        switch(dockState) {
            case Intent.EXTRA_DOCK_STATE_DESK:
                config = AudioSystem.FORCE_BT_DESK_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_CAR:
                config = AudioSystem.FORCE_BT_CAR_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_LE_DESK:
                config = AudioSystem.FORCE_ANALOG_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_HE_DESK:
                config = AudioSystem.FORCE_DIGITAL_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_UNDOCKED:
            default:
                config = AudioSystem.FORCE_NONE;
        }
        // (see mDockAudioMediaEnabled)
        if (!((dockState == Intent.EXTRA_DOCK_STATE_LE_DESK) || ((dockState == Intent.EXTRA_DOCK_STATE_UNDOCKED) && (mDockState == Intent.EXTRA_DOCK_STATE_LE_DESK)))) {
            AudioSystem.setForceUse(AudioSystem.FOR_DOCK, config);
        }
        mDockState = dockState;
    } else if (action.equals(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED)) {
        state = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, BluetoothProfile.STATE_DISCONNECTED);
        BluetoothDevice btDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        setBtScoDeviceConnectionState(btDevice, state);
    } else if (action.equals(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED)) {
        boolean broadcast = false;
        int scoAudioState = AudioManager.SCO_AUDIO_STATE_ERROR;
        synchronized (mScoClients) {
            int btState = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, -1);
            // broadcast intent if the connection was initated by AudioService
            if (!mScoClients.isEmpty() && (mScoAudioState == SCO_STATE_ACTIVE_INTERNAL || mScoAudioState == SCO_STATE_ACTIVATE_REQ || mScoAudioState == SCO_STATE_DEACTIVATE_REQ)) {
                broadcast = true;
            }
            switch(btState) {
                case BluetoothHeadset.STATE_AUDIO_CONNECTED:
                    scoAudioState = AudioManager.SCO_AUDIO_STATE_CONNECTED;
                    if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL && mScoAudioState != SCO_STATE_DEACTIVATE_REQ && mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
                        mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
                    }
                    break;
                case BluetoothHeadset.STATE_AUDIO_DISCONNECTED:
                    scoAudioState = AudioManager.SCO_AUDIO_STATE_DISCONNECTED;
                    mScoAudioState = SCO_STATE_INACTIVE;
                    clearAllScoClients(0, false);
                    break;
                case BluetoothHeadset.STATE_AUDIO_CONNECTING:
                    if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL && mScoAudioState != SCO_STATE_DEACTIVATE_REQ && mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
                        mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
                    }
                default:
                    // do not broadcast CONNECTING or invalid state
                    broadcast = false;
                    break;
            }
        }
        if (broadcast) {
            broadcastScoConnectionState(scoAudioState);
            // FIXME: this is to maintain compatibility with deprecated intent
            // AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED. Remove when appropriate.
            Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
            newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE, scoAudioState);
            sendStickyBroadcastToAll(newIntent);
        }
    } else if (action.equals(Intent.ACTION_SCREEN_ON)) {
        if (mMonitorRotation) {
            RotationHelper.enable();
        }
        AudioSystem.setParameters("screen_state=on");
    } else if (action.equals(Intent.ACTION_SCREEN_OFF)) {
        if (mMonitorRotation) {
            // reduce wakeups (save current) by only listening when display is on
            RotationHelper.disable();
        }
        AudioSystem.setParameters("screen_state=off");
    } else if (action.equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
        handleConfigurationChanged(context);
    } else if (action.equals(Intent.ACTION_USER_SWITCHED)) {
        if (mUserSwitchedReceived) {
            // attempt to stop music playback for background user except on first user
            // switch (i.e. first boot)
            sendMsg(mAudioHandler, MSG_BROADCAST_AUDIO_BECOMING_NOISY, SENDMSG_REPLACE, 0, 0, null, 0);
        }
        mUserSwitchedReceived = true;
        // the current audio focus owner is no longer valid
        mMediaFocusControl.discardAudioFocusOwner();
        // load volume settings for new user
        readAudioSettings(true);
        // preserve STREAM_MUSIC volume from one user to the next.
        sendMsg(mAudioHandler, MSG_SET_ALL_VOLUMES, SENDMSG_QUEUE, 0, 0, mStreamStates[AudioSystem.STREAM_MUSIC], 0);
    } else if (action.equals(Intent.ACTION_USER_BACKGROUND)) {
        // Disable audio recording for the background user/profile
        int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);
        if (userId >= 0) {
            // TODO Kill recording streams instead of killing processes holding permission
            UserInfo userInfo = UserManagerService.getInstance().getUserInfo(userId);
            killBackgroundUserProcessesWithRecordAudioPermission(userInfo);
        }
        UserManagerService.getInstance().setUserRestriction(UserManager.DISALLOW_RECORD_AUDIO, true, userId);
    } else if (action.equals(Intent.ACTION_USER_FOREGROUND)) {
        // Enable audio recording for foreground user/profile
        int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);
        UserManagerService.getInstance().setUserRestriction(UserManager.DISALLOW_RECORD_AUDIO, false, userId);
    } else if (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED)) {
        state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, -1);
        if (state == BluetoothAdapter.STATE_OFF || state == BluetoothAdapter.STATE_TURNING_OFF) {
            disconnectAllBluetoothProfiles();
        }
    }
}
#end_block

#method_before
// end class AudioServiceBroadcastReceiver
private void killBackgroundUserProcessesWithRecordAudioPermission(UserInfo oldUser) {
    PackageManager pm = mContext.getPackageManager();
    // Find the home activity of the user. It should not be killed to avoid expensive restart,
    // when the user switches back. For managed profiles, we should kill all recording apps
    ComponentName homeActivityName = null;
    if (!oldUser.isManagedProfile()) {
        homeActivityName = LocalServices.getService(ActivityManagerInternal.class).getHomeActivityForUser(oldUser.id);
    }
    final String[] permissions = { Manifest.permission.RECORD_AUDIO };
    List<PackageInfo> packages;
    try {
        packages = AppGlobals.getPackageManager().getPackagesHoldingPermissions(permissions, 0, oldUser.id).getList();
    } catch (RemoteException e) {
        throw new AndroidRuntimeException(e);
    }
    for (int j = packages.size() - 1; j >= 0; j--) {
        PackageInfo pkg = packages.get(j);
        // Skip system processes
        if (UserHandle.getAppId(pkg.applicationInfo.uid) < FIRST_APPLICATION_UID) {
            continue;
        }
        // Skip packages that have permission to interact across users
        if (pm.checkPermission(Manifest.permission.INTERACT_ACROSS_USERS, pkg.packageName) == PackageManager.PERMISSION_GRANTED) {
            continue;
        }
        if (homeActivityName != null && pkg.packageName.equals(homeActivityName.getPackageName()) && pkg.applicationInfo.isSystemApp()) {
            continue;
        }
        try {
            final int uid = pkg.applicationInfo.uid;
            ActivityManagerNative.getDefault().killUid(UserHandle.getAppId(uid), UserHandle.getUserId(uid), "killBackgroundUserProcessesWithAudioRecordPermission");
        } catch (RemoteException e) {
            Log.w(TAG, "Error calling killUid", e);
        }
    }
}
#method_after
// end class AudioServiceUserRestrictionsListener
private void killBackgroundUserProcessesWithRecordAudioPermission(UserInfo oldUser) {
    PackageManager pm = mContext.getPackageManager();
    // Find the home activity of the user. It should not be killed to avoid expensive restart,
    // when the user switches back. For managed profiles, we should kill all recording apps
    ComponentName homeActivityName = null;
    if (!oldUser.isManagedProfile()) {
        homeActivityName = LocalServices.getService(ActivityManagerInternal.class).getHomeActivityForUser(oldUser.id);
    }
    final String[] permissions = { Manifest.permission.RECORD_AUDIO };
    List<PackageInfo> packages;
    try {
        packages = AppGlobals.getPackageManager().getPackagesHoldingPermissions(permissions, 0, oldUser.id).getList();
    } catch (RemoteException e) {
        throw new AndroidRuntimeException(e);
    }
    for (int j = packages.size() - 1; j >= 0; j--) {
        PackageInfo pkg = packages.get(j);
        // Skip system processes
        if (UserHandle.getAppId(pkg.applicationInfo.uid) < FIRST_APPLICATION_UID) {
            continue;
        }
        // Skip packages that have permission to interact across users
        if (pm.checkPermission(Manifest.permission.INTERACT_ACROSS_USERS, pkg.packageName) == PackageManager.PERMISSION_GRANTED) {
            continue;
        }
        if (homeActivityName != null && pkg.packageName.equals(homeActivityName.getPackageName()) && pkg.applicationInfo.isSystemApp()) {
            continue;
        }
        try {
            final int uid = pkg.applicationInfo.uid;
            ActivityManagerNative.getDefault().killUid(UserHandle.getAppId(uid), UserHandle.getUserId(uid), "killBackgroundUserProcessesWithAudioRecordPermission");
        } catch (RemoteException e) {
            Log.w(TAG, "Error calling killUid", e);
        }
    }
}
#end_block

#method_before
public String toString() {
    // Android changed: Several apps try to parse the output of toString(). This is a really
    // bad idea - especially when there's a Package.getName() function as well as a
    // Class.getName() function that can be used instead.
    // Starting from the API level 25 the proper output is generated.
    final int targetSdkVersion = VMRuntime.getRuntime().getTargetSdkVersion();
    if (targetSdkVersion > 0 && targetSdkVersion <= 24) {
        return "package " + pkgName;
    }
    // Post N-MR1
    String spec = specTitle;
    String ver = specVersion;
    if (spec != null && spec.length() > 0)
        spec = ", " + spec;
    else
        spec = "";
    if (ver != null && ver.length() > 0)
        ver = ", version " + ver;
    else
        ver = "";
    return "package " + pkgName + spec + ver;
}
#method_after
public String toString() {
    // Android changed start
    // Several apps try to parse the output of toString(). This is a really
    // bad idea - especially when there's a Package.getName() function as well as a
    // Class.getName() function that can be used instead.
    // Starting from the API level 25 the proper output is generated.
    final int targetSdkVersion = VMRuntime.getRuntime().getTargetSdkVersion();
    if (targetSdkVersion > 0 && targetSdkVersion <= 24) {
        return "package " + pkgName;
    }
    // Android changed end
    String spec = specTitle;
    String ver = specVersion;
    if (spec != null && spec.length() > 0)
        spec = ", " + spec;
    else
        spec = "";
    if (ver != null && ver.length() > 0)
        ver = ", version " + ver;
    else
        ver = "";
    return "package " + pkgName + spec + ver;
}
#end_block

#method_before
public int length() {
    return (count & Integer.MAX_VALUE);
}
#method_after
public int length() {
    // are ASCII), the first bit of "count" used as the compression flag.
    return (count & Integer.MAX_VALUE);
}
#end_block

#method_before
static int indexOf(String source, String target, int fromIndex) {
    final int source_length = source.length();
    final int target_length = target.length();
    if (fromIndex >= source_length) {
        return (target_length == 0 ? source_length : -1);
    }
    if (fromIndex < 0) {
        fromIndex = 0;
    }
    if (target_length == 0) {
        return fromIndex;
    }
    char first = target.charAt(0);
    int max = (source_length - target_length);
    for (int i = fromIndex; i <= max; i++) {
        /* Look for first character. */
        if (source.charAt(i) != first) {
            while (++i <= max && source.charAt(i) != first) ;
        }
        /* Found first character, now look at the rest of v2 */
        if (i <= max) {
            int j = i + 1;
            int end = j + target_length - 1;
            for (int k = 1; j < end && source.charAt(j) == target.charAt(k); j++, k++) ;
            if (j == end) {
                /* Found whole string. */
                return i;
            }
        }
    }
    return -1;
}
#method_after
static int indexOf(String source, String target, int fromIndex) {
    final int sourceLength = source.length();
    final int targetLength = target.length();
    if (fromIndex >= sourceLength) {
        return (targetLength == 0 ? sourceLength : -1);
    }
    if (fromIndex < 0) {
        fromIndex = 0;
    }
    if (targetLength == 0) {
        return fromIndex;
    }
    char first = target.charAt(0);
    int max = (sourceLength - targetLength);
    for (int i = fromIndex; i <= max; i++) {
        /* Look for first character. */
        if (source.charAt(i) != first) {
            while (++i <= max && source.charAt(i) != first) ;
        }
        /* Found first character, now look at the rest of v2 */
        if (i <= max) {
            int j = i + 1;
            int end = j + targetLength - 1;
            for (int k = 1; j < end && source.charAt(j) == target.charAt(k); j++, k++) ;
            if (j == end) {
                /* Found whole string. */
                return i;
            }
        }
    }
    return -1;
}
#end_block

#method_before
static int lastIndexOf(String source, String target, int fromIndex) {
    /*
         * Check arguments; return immediately where possible. For
         * consistency, don't check for null str.
         */
    final int source_length = source.length();
    final int target_length = target.length();
    int rightIndex = source_length - target_length;
    if (fromIndex < 0) {
        return -1;
    }
    if (fromIndex > rightIndex) {
        fromIndex = rightIndex;
    }
    /* Empty string always matches. */
    if (target_length == 0) {
        return fromIndex;
    }
    int strLastIndex = target_length - 1;
    char strLastChar = target.charAt(strLastIndex);
    int min = target_length - 1;
    int i = min + fromIndex;
    startSearchForLastChar: while (true) {
        while (i >= min && source.charAt(i) != strLastChar) {
            i--;
        }
        if (i < min) {
            return -1;
        }
        int j = i - 1;
        int start = j - (target_length - 1);
        int k = strLastIndex - 1;
        while (j > start) {
            if (source.charAt(j--) != target.charAt(k--)) {
                i--;
                continue startSearchForLastChar;
            }
        }
        return start + 1;
    }
}
#method_after
static int lastIndexOf(String source, String target, int fromIndex) {
    /*
         * Check arguments; return immediately where possible. For
         * consistency, don't check for null str.
         */
    final int sourceLength = source.length();
    final int targetLength = target.length();
    int rightIndex = sourceLength - targetLength;
    if (fromIndex < 0) {
        return -1;
    }
    if (fromIndex > rightIndex) {
        fromIndex = rightIndex;
    }
    /* Empty string always matches. */
    if (targetLength == 0) {
        return fromIndex;
    }
    int strLastIndex = targetLength - 1;
    char strLastChar = target.charAt(strLastIndex);
    int min = targetLength - 1;
    int i = min + fromIndex;
    startSearchForLastChar: while (true) {
        while (i >= min && source.charAt(i) != strLastChar) {
            i--;
        }
        if (i < min) {
            return -1;
        }
        int j = i - 1;
        int start = j - (targetLength - 1);
        int k = strLastIndex - 1;
        while (j > start) {
            if (source.charAt(j--) != target.charAt(k--)) {
                i--;
                continue startSearchForLastChar;
            }
        }
        return start + 1;
    }
}
#end_block

#method_before
@Test
@TestInfo(id = "14581588")
public void createBugReport() throws Exception {
    Instrumentation instrumentation = testFramework.getInstrumentation();
    final UiDevice device = UiDevice.getInstance(instrumentation);
    if (testFramework.getApi() >= 21) {
        deleteBugReportFiles();
        if (!DeveloperOptionsManager.isDeveloperOptionsEnabled(instrumentation)) {
            DeveloperOptionsManager.enableDeveloperOptions(testFramework.getInstrumentation());
        }
        AppLauncher.launch(instrumentation, "Settings");
        UiScrollable itemList = new UiScrollable(new UiSelector().resourceIdMatches(Res.SETTINGS_LIST_CONTAINER_RES));
        itemList.setAsVerticalList();
        UiObject item = itemList.getChildByText(new UiSelector().className("android.widget.TextView"), "Developer options");
        item.click();
        try {
            device.findObject(new UiSelector().text("Take bug report")).clickAndWaitForNewWindow();
            if (device.findObject(new UiSelector().text("Report")).exists()) {
                device.findObject(new UiSelector().text("Report")).click();
            }
            boolean gotPngAndZip = new Wait(TimeUnit.MILLISECONDS.convert(30L, TimeUnit.SECONDS)).until(new Wait.ExpectedCondition() {

                @Override
                public boolean isTrue() throws Exception {
                    String result = device.executeShellCommand("ls " + BUG_REPORT_DIR);
                    Log.d(TAG, "ls result " + result);
                    return result.matches("(?s).*bugreport[-0-9]+\\.png.*") && result.matches("(?s).*bugreport[-0-9]+\\.zip.*");
                }
            });
            Assert.assertTrue("Missing bug report files for png and zip.", gotPngAndZip);
        } finally {
            deleteBugReportFiles();
        }
    }
}
#method_after
@Test
@TestInfo(id = "14581588")
public void createBugReport() throws Exception {
    Instrumentation instrumentation = testFramework.getInstrumentation();
    final UiDevice device = UiDevice.getInstance(instrumentation);
    if (testFramework.getApi() >= 21) {
        deleteBugReportFiles();
        if (!DeveloperOptionsManager.isDeveloperOptionsEnabled(instrumentation)) {
            DeveloperOptionsManager.enableDeveloperOptions(testFramework.getInstrumentation());
        }
        AppLauncher.launch(instrumentation, "Settings");
        UiScrollable itemList = new UiScrollable(new UiSelector().resourceIdMatches(Res.SETTINGS_LIST_CONTAINER_RES));
        itemList.setAsVerticalList();
        UiObject item = itemList.getChildByText(new UiSelector().className("android.widget.TextView"), "Developer options");
        item.click();
        // Remove bug report files even if the test fails.
        try {
            device.findObject(new UiSelector().text("Take bug report")).clickAndWaitForNewWindow();
            if (device.findObject(new UiSelector().text("Report")).exists()) {
                device.findObject(new UiSelector().text("Report")).click();
            }
            boolean gotPngAndZip = new Wait(TimeUnit.MILLISECONDS.convert(30L, TimeUnit.SECONDS)).until(new Wait.ExpectedCondition() {

                @Override
                public boolean isTrue() throws Exception {
                    String result = device.executeShellCommand("ls " + BUG_REPORT_DIR);
                    Log.d(TAG, "ls result " + result);
                    return result.matches("(?s).*bugreport[-0-9]+\\.png.*") && result.matches("(?s).*bugreport[-0-9]+\\.zip.*");
                }
            });
            Assert.assertTrue("Missing bug report files for png and zip.", gotPngAndZip);
        } finally {
            deleteBugReportFiles();
        }
    }
}
#end_block

#method_before
public void testRetentionPolicy() {
    Annotation classRetentionAnnotation = RetentionAnnotations.class.getAnnotation(ClassRetentionAnnotation.class);
    // b/29500035
    int targetSdkVersion = VMRuntime.getRuntime().getTargetSdkVersion();
    if (targetSdkVersion > 0 && targetSdkVersion <= 23) {
        // pre-N behavior
        assertNotNull(classRetentionAnnotation);
    } else {
        // N and later behavior
        assertNull(classRetentionAnnotation);
    }
    assertNotNull(RetentionAnnotations.class.getAnnotation(RuntimeRetentionAnnotation.class));
    assertNull(RetentionAnnotations.class.getAnnotation(SourceRetentionAnnotation.class));
}
#method_after
public void testRetentionPolicy() {
    // b/29500035
    int savedTargetSdkVersion = VMRuntime.getRuntime().getTargetSdkVersion();
    try {
        // Test N and later behavior
        VMRuntime.getRuntime().setTargetSdkVersion(24);
        Annotation classRetentionAnnotation = RetentionAnnotations.class.getAnnotation(ClassRetentionAnnotation.class);
        assertNull(classRetentionAnnotation);
        // Test pre-N behavior
        VMRuntime.getRuntime().setTargetSdkVersion(23);
        classRetentionAnnotation = RetentionAnnotations.class.getAnnotation(ClassRetentionAnnotation.class);
        assertNotNull(classRetentionAnnotation);
    } finally {
        VMRuntime.getRuntime().setTargetSdkVersion(savedTargetSdkVersion);
    }
    assertNotNull(RetentionAnnotations.class.getAnnotation(RuntimeRetentionAnnotation.class));
    assertNull(RetentionAnnotations.class.getAnnotation(SourceRetentionAnnotation.class));
}
#end_block

#method_before
@Test
@TestInfo(id = "14581588")
public void createBugReport() throws Exception {
    Instrumentation instrumentation = testFramework.getInstrumentation();
    final UiDevice device = UiDevice.getInstance(instrumentation);
    if (testFramework.getApi() >= 21) {
        deleteBugReportFiles();
        if (!DeveloperOptionsManager.isDeveloperOptionsEnabled(instrumentation)) {
            DeveloperOptionsManager.enableDeveloperOptions(testFramework.getInstrumentation());
        }
        AppLauncher.launch(instrumentation, "Settings");
        UiScrollable itemList = new UiScrollable(new UiSelector().resourceIdMatches(Res.SETTINGS_LIST_CONTAINER_RES));
        itemList.setAsVerticalList();
        UiObject item = itemList.getChildByText(new UiSelector().className("android.widget.TextView"), "Developer options");
        item.click();
        device.findObject(new UiSelector().text("Take bug report")).clickAndWaitForNewWindow();
        if (device.findObject(new UiSelector().text("Report")).exists()) {
            device.findObject(new UiSelector().text("Report")).click();
        }
        boolean gotPngAndZip = new Wait(30000, 500).until(new Wait.ExpectedCondition() {

            @Override
            public boolean isTrue() throws Exception {
                String result = device.executeShellCommand("ls " + BUG_REPORT_DIR);
                Log.d(TAG, "ls result " + result);
                return result.matches("(?s).*bugreport[-0-9]+\\.png.*") && result.matches("(?s).*bugreport[-0-9]+\\.zip.*");
            }
        });
        Assert.assertTrue("Missing bug report files for png and zip.", gotPngAndZip);
    }
}
#method_after
@Test
@TestInfo(id = "14581588")
public void createBugReport() throws Exception {
    Instrumentation instrumentation = testFramework.getInstrumentation();
    final UiDevice device = UiDevice.getInstance(instrumentation);
    if (testFramework.getApi() >= 21) {
        deleteBugReportFiles();
        if (!DeveloperOptionsManager.isDeveloperOptionsEnabled(instrumentation)) {
            DeveloperOptionsManager.enableDeveloperOptions(testFramework.getInstrumentation());
        }
        AppLauncher.launch(instrumentation, "Settings");
        UiScrollable itemList = new UiScrollable(new UiSelector().resourceIdMatches(Res.SETTINGS_LIST_CONTAINER_RES));
        itemList.setAsVerticalList();
        UiObject item = itemList.getChildByText(new UiSelector().className("android.widget.TextView"), "Developer options");
        item.click();
        device.findObject(new UiSelector().text("Take bug report")).clickAndWaitForNewWindow();
        if (device.findObject(new UiSelector().text("Report")).exists()) {
            device.findObject(new UiSelector().text("Report")).click();
        }
        boolean gotPngAndZip = new Wait(TimeUnit.MILLISECONDS.convert(30L, TimeUnit.SECONDS)).until(new Wait.ExpectedCondition() {

            @Override
            public boolean isTrue() throws Exception {
                String result = device.executeShellCommand("ls " + BUG_REPORT_DIR);
                Log.d(TAG, "ls result " + result);
                return result.matches("(?s).*bugreport[-0-9]+\\.png.*") && result.matches("(?s).*bugreport[-0-9]+\\.zip.*");
            }
        });
        Assert.assertTrue("Missing bug report files for png and zip.", gotPngAndZip);
    }
}
#end_block

#method_before
@Override
public void evaluate() throws Throwable {
    MonitoringInstrumentation instrumentation = ActivityTestRule.this.mInstrumentation instanceof MonitoringInstrumentation ? (MonitoringInstrumentation) ActivityTestRule.this.mInstrumentation : null;
    try {
        if (mActivityProvider != null && instrumentation != null) {
            instrumentation.useActivityProvider(mActivityProvider);
        }
        if (mLaunchActivity) {
            mActivity = launchActivity(getActivityIntent());
        }
        mBase.evaluate();
    } finally {
        if (instrumentation != null) {
            instrumentation.resetActivityProvider();
        }
        finishActivity();
        afterActivityFinished();
    }
}
#method_after
@Override
public void evaluate() throws Throwable {
    MonitoringInstrumentation instrumentation = ActivityTestRule.this.mInstrumentation instanceof MonitoringInstrumentation ? (MonitoringInstrumentation) ActivityTestRule.this.mInstrumentation : null;
    try {
        if (mActivityFactory != null && instrumentation != null) {
            instrumentation.interceptActivityUsing(mActivityFactory);
        }
        if (mLaunchActivity) {
            mActivity = launchActivity(getActivityIntent());
        }
        mBase.evaluate();
    } finally {
        if (instrumentation != null) {
            instrumentation.useDefaultInterceptingActivityFactory();
        }
        finishActivity();
        afterActivityFinished();
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    instrumentation = (MonitoringInstrumentation) getInstrumentation();
}
#method_after
@Before
public void setUp() throws Exception {
    mInstrumentation = (MonitoringInstrumentation) getInstrumentation();
}
#end_block

#method_before
@Override
public void onCreate(Bundle arguments) {
    Log.i(LOG_TAG, "Instrumentation Started!");
    logUncaughtExceptions();
    installMultidex();
    InstrumentationRegistry.registerInstance(this, arguments);
    ActivityLifecycleMonitorRegistry.registerInstance(mLifecycleMonitor);
    ApplicationLifecycleMonitorRegistry.registerInstance(mApplicationMonitor);
    IntentMonitorRegistry.registerInstance(mIntentMonitor);
    mHandlerForMainLooper = new Handler(Looper.getMainLooper());
    mMainThread = Thread.currentThread();
    final int corePoolSize = 0;
    final long keepAliveTime = 0L;
    mExecutorService = new ThreadPoolExecutor(corePoolSize, Integer.MAX_VALUE, keepAliveTime, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());
    Looper.myQueue().addIdleHandler(mIdleHandler);
    super.onCreate(arguments);
    specifyDexMakerCacheProperty();
    setupDexmakerClassloader();
}
#method_after
@Override
public void onCreate(Bundle arguments) {
    Log.i(LOG_TAG, "Instrumentation Started!");
    logUncaughtExceptions();
    installMultidex();
    InstrumentationRegistry.registerInstance(this, arguments);
    ActivityLifecycleMonitorRegistry.registerInstance(mLifecycleMonitor);
    ApplicationLifecycleMonitorRegistry.registerInstance(mApplicationMonitor);
    IntentMonitorRegistry.registerInstance(mIntentMonitor);
    mHandlerForMainLooper = new Handler(Looper.getMainLooper());
    mMainThread = Thread.currentThread();
    final int corePoolSize = 0;
    final long keepAliveTime = 0L;
    mExecutorService = new ThreadPoolExecutor(corePoolSize, Integer.MAX_VALUE, keepAliveTime, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());
    Looper.myQueue().addIdleHandler(mIdleHandler);
    super.onCreate(arguments);
    specifyDexMakerCacheProperty();
    setupDexmakerClassloader();
    useDefaultInterceptingActivityFactory();
}
#end_block

#method_before
@Override
public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException {
    return this.mActivityProvider != null && mActivityProvider.getActivityClass().getName().equals(className) ? mActivityProvider.getActivity() : super.newActivity(cl, className, intent);
}
#method_after
@Override
public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException {
    return mInterceptingActivityFactory.shouldIntercept(cl, className, intent) ? mInterceptingActivityFactory.create(cl, className, intent) : super.newActivity(cl, className, intent);
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    initializeFiles();
}
#method_after
public void setUp() throws Exception {
    initializeFiles();
}
#end_block

#method_before
private void initializeFiles() throws IOException {
    Files.createDirectory(TEST_DIR_PATH);
    File testInputFile = new File(TEST_DIR, DATA_FILE);
    if (!testInputFile.exists()) {
        testInputFile.createNewFile();
    }
    FileWriter fw = new FileWriter(testInputFile.getAbsoluteFile());
    BufferedWriter bw = new BufferedWriter(fw);
    bw.write(TEST_FILE_DATA);
    bw.close();
}
#method_after
private static void initializeFiles() throws IOException {
    Files.createDirectory(TEST_DIR_PATH);
    File testInputFile = new File(TEST_DIR, DATA_FILE);
    if (!testInputFile.exists()) {
        testInputFile.createNewFile();
    }
    FileWriter fw = new FileWriter(testInputFile.getAbsoluteFile());
    BufferedWriter bw = new BufferedWriter(fw);
    bw.write(TEST_FILE_DATA);
    bw.close();
}
#end_block

#method_before
@Override
public void tearDown() throws Exception {
    clearAll();
    super.tearDown();
}
#method_after
static public void tearDown() throws Exception {
    clearAll();
}
#end_block

#method_before
void clearAll() throws IOException {
    Path root = Paths.get(TEST_DIR);
    delete(root);
}
#method_after
static void clearAll() throws IOException {
    Path root = Paths.get(TEST_DIR);
    delete(root);
}
#end_block

#method_before
void reset() throws IOException {
    clearAll();
    initializeFiles();
}
#method_after
static void reset() throws IOException {
    clearAll();
    initializeFiles();
}
#end_block

#method_before
private void delete(Path path) throws IOException {
    if (Files.isDirectory(path)) {
        DirectoryStream<Path> dirStream = Files.newDirectoryStream(path);
        dirStream.forEach(p -> {
            try {
                delete(p);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        });
        dirStream.close();
    }
    try {
        Files.deleteIfExists(path);
    } catch (Exception e) {
    // Do nothing
    }
}
#method_after
private static void delete(Path path) throws IOException {
    if (Files.isDirectory(path)) {
        DirectoryStream<Path> dirStream = Files.newDirectoryStream(path);
        dirStream.forEach(p -> {
            try {
                delete(p);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        });
        dirStream.close();
    }
    try {
        Files.deleteIfExists(path);
    } catch (Exception e) {
    // Do nothing
    }
}
#end_block

#method_before
void writeToFile(Path file, String data, OpenOption... option) throws IOException {
    OutputStream os = Files.newOutputStream(file, option);
    os.write(data.getBytes());
    os.close();
}
#method_after
static void writeToFile(Path file, String data, OpenOption... option) throws IOException {
    OutputStream os = Files.newOutputStream(file, option);
    os.write(data.getBytes());
    os.close();
}
#end_block

#method_before
String readFromFile(Path file) throws IOException {
    InputStream is = Files.newInputStream(file);
    return readFromInputStream(is);
}
#method_after
static String readFromFile(Path file) throws IOException {
    InputStream is = Files.newInputStream(file);
    return readFromInputStream(is);
}
#end_block

#method_before
String readFromInputStream(InputStream is) throws IOException {
    byte[] input = new byte[10000];
    is.read(input);
    return new String(input, "UTF-8").trim();
}
#method_after
static String readFromInputStream(InputStream is) throws IOException {
    byte[] input = new byte[10000];
    is.read(input);
    return new String(input, "UTF-8").trim();
}
#end_block

#method_before
Process execCmdAndWaitForTermination(String... cmdList) throws InterruptedException, IOException {
    Process process = Runtime.getRuntime().exec(cmdList);
    // Wait for the process to terminate.
    process.waitFor();
    return process;
}
#method_after
static Process execCmdAndWaitForTermination(String... cmdList) throws InterruptedException, IOException {
    Process process = Runtime.getRuntime().exec(cmdList);
    // Wait for the process to terminate.
    process.waitFor();
    return process;
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    mockPath = mock(Path.class);
    mockPath2 = mock(Path.class);
    mockFileSystem = mock(FileSystem.class);
    mockFileSystemProvider = mock(FileSystemProvider.class);
    when(mockPath.getFileSystem()).thenReturn(mockFileSystem);
    when(mockPath2.getFileSystem()).thenReturn(mockFileSystem);
    when(mockFileSystem.provider()).thenReturn(mockFileSystemProvider);
}
#method_after
@Before
public void setUp() throws Exception {
    when(mockPath.getFileSystem()).thenReturn(mockFileSystem);
    when(mockPath2.getFileSystem()).thenReturn(mockFileSystem);
    when(mockFileSystem.provider()).thenReturn(mockFileSystemProvider);
}
#end_block

#method_before
public void test_newInputStream() throws IOException {
    InputStream is = new ByteArrayInputStream(new byte[0]);
    when(mockFileSystemProvider.newInputStream(mockPath, READ)).thenReturn(is);
    assertSame(is, Files.newInputStream(mockPath, READ));
    verify(mockFileSystemProvider).newInputStream(mockPath, READ);
    is.close();
}
#method_after
@Test
public void test_newInputStream() throws IOException {
    try (InputStream is = new ByteArrayInputStream(new byte[0])) {
        when(mockFileSystemProvider.newInputStream(mockPath, READ)).thenReturn(is);
        assertSame(is, Files.newInputStream(mockPath, READ));
        verify(mockFileSystemProvider).newInputStream(mockPath, READ);
    }
}
#end_block

#method_before
public void test_newOutputStream() throws IOException {
    OutputStream os = new ByteArrayOutputStream();
    when(mockFileSystemProvider.newOutputStream(mockPath, APPEND)).thenReturn(os);
    assertSame(os, Files.newOutputStream(mockPath, APPEND));
    verify(mockFileSystemProvider).newOutputStream(mockPath, APPEND);
    os.close();
}
#method_after
@Test
public void test_newOutputStream() throws IOException {
    try (OutputStream os = new ByteArrayOutputStream()) {
        when(mockFileSystemProvider.newOutputStream(mockPath, APPEND)).thenReturn(os);
        assertSame(os, Files.newOutputStream(mockPath, APPEND));
        verify(mockFileSystemProvider).newOutputStream(mockPath, APPEND);
    }
}
#end_block

#method_before
public void test_createFile() throws IOException {
    assertFalse(Files.exists(NON_EXISTENT_FILE_PATH));
    Files.createFile(NON_EXISTENT_FILE_PATH);
    assertTrue(Files.exists(NON_EXISTENT_FILE_PATH));
    try {
        Files.createFile(NON_EXISTENT_FILE_PATH);
        fail();
    } catch (FileAlreadyExistsException expected) {
    }
    // File with unicode name.
    Path unicodeFilePath = Paths.get(TEST_DIR, "परीक्षण फ़ाइल");
    Files.createFile(unicodeFilePath);
    Files.exists(unicodeFilePath);
    // When file exists.
    try {
        Files.createFile(DATA_FILE_PATH);
        fail();
    } catch (FileAlreadyExistsException expected) {
    }
}
#method_after
@Test
public void test_createFile() throws IOException {
    assertFalse(Files.exists(TEST_PATH));
    Files.createFile(TEST_PATH);
    assertTrue(Files.exists(TEST_PATH));
    // File with unicode name.
    Path unicodeFilePath = Paths.get(TEST_DIR, "परीक्षण फ़ाइल");
    Files.createFile(unicodeFilePath);
    Files.exists(unicodeFilePath);
    // When file exists.
    try {
        Files.createFile(DATA_FILE_PATH);
        fail();
    } catch (FileAlreadyExistsException expected) {
    }
}
#end_block

#method_before
public void test_createFile_NPE() throws IOException {
    try {
        Files.createFile(null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#method_after
@Test
public void test_createFile_NPE() throws IOException {
    try {
        Files.createFile(null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
public void test_createFile$String$Attr() throws IOException {
    Set<PosixFilePermission> perm = PosixFilePermissions.fromString("rwx------");
    FileAttribute<Set<PosixFilePermission>> attr = PosixFilePermissions.asFileAttribute(perm);
    Files.createFile(NON_EXISTENT_FILE_PATH, attr);
    assertEquals(attr.value(), Files.getAttribute(NON_EXISTENT_FILE_PATH, attr.name()));
    // Creating a new file and passing multiple attribute of the same name.
    perm = PosixFilePermissions.fromString("rw-------");
    FileAttribute<Set<PosixFilePermission>> attr1 = PosixFilePermissions.asFileAttribute(perm);
    Path filePath2 = Paths.get(TEST_DIR, "new_file");
    Files.createFile(filePath2, attr, attr1);
    // Value should be equal to the last attribute passed.
    assertEquals(attr1.value(), Files.getAttribute(filePath2, attr.name()));
    // When file exists.
    try {
        Files.createFile(DATA_FILE_PATH, attr);
        fail();
    } catch (FileAlreadyExistsException expected) {
    }
}
#method_after
@Test
public void test_createFile$String$Attr() throws IOException {
    Set<PosixFilePermission> perm = PosixFilePermissions.fromString("rwx------");
    FileAttribute<Set<PosixFilePermission>> attr = PosixFilePermissions.asFileAttribute(perm);
    Files.createFile(TEST_PATH, attr);
    assertEquals(attr.value(), Files.getAttribute(TEST_PATH, attr.name()));
    // Creating a new file and passing multiple attribute of the same name.
    perm = PosixFilePermissions.fromString("rw-------");
    FileAttribute<Set<PosixFilePermission>> attr1 = PosixFilePermissions.asFileAttribute(perm);
    Path filePath2 = Paths.get(TEST_DIR, "new_file");
    Files.createFile(filePath2, attr, attr1);
    // Value should be equal to the last attribute passed.
    assertEquals(attr1.value(), Files.getAttribute(filePath2, attr.name()));
    // When file exists.
    try {
        Files.createFile(DATA_FILE_PATH, attr);
        fail();
    } catch (FileAlreadyExistsException expected) {
    }
}
#end_block

#method_before
public void test_createDirectory_delegation() throws IOException {
    Set<PosixFilePermission> perm = PosixFilePermissions.fromString("rwx------");
    FileAttribute<Set<PosixFilePermission>> attr = PosixFilePermissions.asFileAttribute(perm);
    assertEquals(mockPath, Files.createDirectory(mockPath, attr));
    verify(mockFileSystemProvider).createDirectory(mockPath, attr);
}
#method_after
@Test
public void test_createDirectory_delegation() throws IOException {
    Set<PosixFilePermission> perm = PosixFilePermissions.fromString("rwx------");
    FileAttribute<Set<PosixFilePermission>> attr = PosixFilePermissions.asFileAttribute(perm);
    assertEquals(mockPath, Files.createDirectory(mockPath, attr));
    verify(mockFileSystemProvider).createDirectory(mockPath, attr);
}
#end_block

#method_before
public void test_createDirectories() throws IOException {
    // Should be able to create parent directories.
    Path dirPath = Paths.get(TEST_DIR, "dir1/dir2/dir3");
    assertFalse(Files.exists(dirPath));
    Files.createDirectories(dirPath);
    assertTrue(Files.isDirectory(dirPath));
    // Creating an existing directory. Should not throw any error.
    Files.createDirectories(dirPath);
}
#method_after
@Test
public void test_createDirectories() throws IOException {
    // Should be able to create parent directories.
    Path dirPath = Paths.get(TEST_DIR, "dir1/dir2/dir3");
    assertFalse(Files.exists(dirPath));
    Files.createDirectories(dirPath);
    assertTrue(Files.isDirectory(dirPath));
    // Creating an existing directory. Should not throw any error.
    Files.createDirectories(dirPath);
}
#end_block

#method_before
public void test_createDirectories_NPE() throws IOException {
    try {
        Files.createDirectories(null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#method_after
@Test
public void test_createDirectories_NPE() throws IOException {
    try {
        Files.createDirectories(null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
public void test_createDirectories$Path$Attr() throws IOException {
    Path dirPath = Paths.get(TEST_DIR, "dir1/dir2/dir3");
    Set<PosixFilePermission> perm = PosixFilePermissions.fromString("rwx------");
    FileAttribute<Set<PosixFilePermission>> attr = PosixFilePermissions.asFileAttribute(perm);
    assertFalse(Files.exists(dirPath));
    Files.createDirectories(dirPath, attr);
    assertEquals(attr.value(), Files.getAttribute(dirPath, attr.name()));
    // Creating an existing directory with new permissions.
    perm = PosixFilePermissions.fromString("rw-------");
    FileAttribute<Set<PosixFilePermission>> attr1 = PosixFilePermissions.asFileAttribute(perm);
    Files.createDirectories(dirPath, attr);
    // Value should not change as the directory exists.
    assertEquals(attr.value(), Files.getAttribute(dirPath, attr.name()));
    // Creating a new directory and passing multiple attribute of the same name.
    Path dirPath2 = Paths.get(TEST_DIR, "dir1/dir2/dir4");
    Files.createDirectories(dirPath2, attr, attr1);
    // Value should be equal to the last attribute passed.
    assertEquals(attr1.value(), Files.getAttribute(dirPath2, attr.name()));
}
#method_after
@Test
public void test_createDirectories$Path$Attr() throws IOException {
    Path dirPath = Paths.get(TEST_DIR, "dir1/dir2/dir3");
    Set<PosixFilePermission> perm = PosixFilePermissions.fromString("rwx------");
    FileAttribute<Set<PosixFilePermission>> attr = PosixFilePermissions.asFileAttribute(perm);
    assertFalse(Files.exists(dirPath));
    Files.createDirectories(dirPath, attr);
    assertEquals(attr.value(), Files.getAttribute(dirPath, attr.name()));
    // Creating an existing directory with new permissions.
    perm = PosixFilePermissions.fromString("rw-------");
    FileAttribute<Set<PosixFilePermission>> attr1 = PosixFilePermissions.asFileAttribute(perm);
    Files.createDirectories(dirPath, attr);
    // Value should not change as the directory exists.
    assertEquals(attr.value(), Files.getAttribute(dirPath, attr.name()));
    // Creating a new directory and passing multiple attribute of the same name.
    Path dirPath2 = Paths.get(TEST_DIR, "dir1/dir2/dir4");
    Files.createDirectories(dirPath2, attr, attr1);
    // Value should be equal to the last attribute passed.
    assertEquals(attr1.value(), Files.getAttribute(dirPath2, attr.name()));
}
#end_block

#method_before
public void test_createDirectories$Path$Attr_NPE() throws IOException {
    Path dirPath = Paths.get(TEST_DIR, "dir1/dir2/dir3");
    Set<PosixFilePermission> perm = PosixFilePermissions.fromString("rwx------");
    FileAttribute<Set<PosixFilePermission>> attr = PosixFilePermissions.asFileAttribute(perm);
    try {
        Files.createDirectories(null, attr);
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        Files.createDirectories(dirPath, (FileAttribute<?>[]) null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#method_after
@Test
public void test_createDirectories$Path$Attr_NPE() throws IOException {
    Path dirPath = Paths.get(TEST_DIR, "dir1/dir2/dir3");
    Set<PosixFilePermission> perm = PosixFilePermissions.fromString("rwx------");
    FileAttribute<Set<PosixFilePermission>> attr = PosixFilePermissions.asFileAttribute(perm);
    try {
        Files.createDirectories(null, attr);
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        Files.createDirectories(dirPath, (FileAttribute<?>[]) null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
public void test_newDirectoryStream() throws IOException {
    Path path_dir1 = Paths.get(TEST_DIR, "newDir1");
    Path path_dir2 = Paths.get(TEST_DIR, "newDir1/newDir2");
    Path path_dir3 = Paths.get(TEST_DIR, "newDir1/newDir3");
    Path path_file1 = Paths.get(TEST_DIR, "newDir1/newFile1");
    Path path_file2 = Paths.get(TEST_DIR, "newDir1/newFile2");
    Path path_file3 = Paths.get(TEST_DIR, "newDir1/newDir2/newFile3");
    Map<Path, Boolean> pathMap = new HashMap<>();
    pathMap.put(path_dir1, false);
    pathMap.put(path_dir2, false);
    pathMap.put(path_dir3, false);
    pathMap.put(path_file1, false);
    pathMap.put(path_file2, false);
    pathMap.put(path_file3, false);
    Files.createDirectory(path_dir1);
    Files.createDirectory(path_dir2);
    Files.createDirectory(path_dir3);
    Files.createFile(path_file1);
    Files.createFile(path_file2);
    Files.createFile(path_file3);
    DirectoryStream<Path> directoryStream = Files.newDirectoryStream(path_dir1);
    directoryStream.forEach(k -> pathMap.replace(k, true));
    assertEquals(6, pathMap.size());
    assertFalse(pathMap.get(path_dir1));
    assertTrue(pathMap.get(path_dir2));
    assertTrue(pathMap.get(path_dir3));
    assertTrue(pathMap.get(path_file1));
    assertTrue(pathMap.get(path_file2));
    assertFalse(pathMap.get(path_file3));
}
#method_after
@Test
public void test_newDirectoryStream() throws IOException {
    // Directory setup.
    Path path_dir1 = Paths.get(TEST_DIR, "newDir1");
    Path path_dir2 = Paths.get(TEST_DIR, "newDir1/newDir2");
    Path path_dir3 = Paths.get(TEST_DIR, "newDir1/newDir3");
    Path path_file1 = Paths.get(TEST_DIR, "newDir1/newFile1");
    Path path_file2 = Paths.get(TEST_DIR, "newDir1/newFile2");
    Path path_file3 = Paths.get(TEST_DIR, "newDir1/newDir2/newFile3");
    Files.createDirectory(path_dir1);
    Files.createDirectory(path_dir2);
    Files.createDirectory(path_dir3);
    Files.createFile(path_file1);
    Files.createFile(path_file2);
    Files.createFile(path_file3);
    HashSet<Path> pathSet = new HashSet<>();
    HashSet<Path> expectedPathSet = new HashSet<>();
    expectedPathSet.add(path_dir2);
    expectedPathSet.add(path_dir3);
    expectedPathSet.add(path_file1);
    expectedPathSet.add(path_file2);
    try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(path_dir1)) {
        directoryStream.forEach(k -> pathSet.add(k));
        assertEquals(expectedPathSet, pathSet);
    }
}
#end_block

#method_before
public void test_newDirectoryStream_Exception() throws IOException {
    // Non existent directory.
    Path path_dir1 = Paths.get(TEST_DIR, "newDir1");
    try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(path_dir1)) {
        fail();
    } catch (NoSuchFileException expected) {
    }
    // File instead of directory.
    Path path_file1 = Paths.get(TEST_DIR, "newFile1");
    Files.createFile(path_file1);
    try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(path_file1)) {
        fail();
    } catch (NotDirectoryException expected) {
    }
    try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(null)) {
        fail();
    } catch (NullPointerException expected) {
    }
}
#method_after
@Test
public void test_newDirectoryStream_Exception() throws IOException {
    // Non existent directory.
    Path path_dir1 = Paths.get(TEST_DIR, "newDir1");
    try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(path_dir1)) {
        fail();
    } catch (NoSuchFileException expected) {
    }
    // File instead of directory.
    Path path_file1 = Paths.get(TEST_DIR, "newFile1");
    Files.createFile(path_file1);
    try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(path_file1)) {
        fail();
    } catch (NotDirectoryException expected) {
    }
    try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(null)) {
        fail();
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
public void test_newDirectoryStream$Path$String() throws IOException {
    Path path_root = Paths.get(TEST_DIR, "dir");
    Path path_java1 = Paths.get(TEST_DIR, "dir/f1.java");
    Path path_java2 = Paths.get(TEST_DIR, "dir/f2.java");
    Path path_java3 = Paths.get(TEST_DIR, "dir/f3.java");
    Path path_txt1 = Paths.get(TEST_DIR, "dir/f1.txt");
    Path path_txt2 = Paths.get(TEST_DIR, "dir/f2.txt");
    Path path_txt3 = Paths.get(TEST_DIR, "dir/f3.txt");
    Map<Path, Boolean> pathMap = new HashMap<>();
    pathMap.put(path_java1, false);
    pathMap.put(path_java2, false);
    pathMap.put(path_java3, false);
    pathMap.put(path_txt1, false);
    pathMap.put(path_txt2, false);
    pathMap.put(path_txt3, false);
    Files.createDirectory(path_root);
    // A directory with .java extension.
    Files.createDirectory(path_java1);
    Files.createFile(path_java2);
    Files.createFile(path_java3);
    Files.createFile(path_txt1);
    Files.createFile(path_txt2);
    Files.createFile(path_txt3);
    DirectoryStream<Path> directoryStream = Files.newDirectoryStream(path_root, "*.java");
    directoryStream.forEach(k -> pathMap.replace(k, true));
    assertEquals(6, pathMap.size());
    assertTrue(pathMap.get(path_java1));
    assertTrue(pathMap.get(path_java2));
    assertTrue(pathMap.get(path_java3));
    assertFalse(pathMap.get(path_txt1));
    assertFalse(pathMap.get(path_txt2));
    assertFalse(pathMap.get(path_txt3));
}
#method_after
@Test
public void test_newDirectoryStream$Path$String() throws IOException {
    // Directory setup.
    Path path_root = Paths.get(TEST_DIR, "dir");
    Path path_java1 = Paths.get(TEST_DIR, "dir/f1.java");
    Path path_java2 = Paths.get(TEST_DIR, "dir/f2.java");
    Path path_java3 = Paths.get(TEST_DIR, "dir/f3.java");
    Path path_txt1 = Paths.get(TEST_DIR, "dir/f1.txt");
    Path path_txt2 = Paths.get(TEST_DIR, "dir/f2.txt");
    Path path_txt3 = Paths.get(TEST_DIR, "dir/f3.txt");
    Files.createDirectory(path_root);
    // A directory with .java extension.
    Files.createDirectory(path_java1);
    Files.createFile(path_java2);
    Files.createFile(path_java3);
    Files.createFile(path_txt1);
    Files.createFile(path_txt2);
    Files.createFile(path_txt3);
    HashSet<Path> pathSet = new HashSet<>();
    HashSet<Path> expectedPathSet = new HashSet<>();
    expectedPathSet.add(path_java1);
    expectedPathSet.add(path_java2);
    expectedPathSet.add(path_java3);
    try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(path_root, "*.java")) {
        directoryStream.forEach(k -> pathSet.add(k));
        assertEquals(expectedPathSet, pathSet);
    }
}
#end_block

#method_before
public void test_newDirectoryStream$Path$String_Exception() throws IOException {
    // Non existent directory.
    Path path_dir1 = Paths.get(TEST_DIR, "newDir1");
    try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(path_dir1, "*.c")) {
        fail();
    } catch (NoSuchFileException expected) {
    }
    // File instead of directory.
    Path path_file1 = Paths.get(TEST_DIR, "newFile1");
    Files.createFile(path_file1);
    try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(path_file1, "*.c")) {
        fail();
    } catch (NotDirectoryException expected) {
    }
    Files.createFile(path_dir1);
    try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(path_file1, "[a")) {
        fail();
    } catch (PatternSyntaxException expected) {
    }
    try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(null, "[a")) {
        fail();
    } catch (NullPointerException expected) {
    }
    try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(path_dir1, (String) null)) {
        fail();
    } catch (NullPointerException expected) {
    }
}
#method_after
@Test
public void test_newDirectoryStream$Path$String_Exception() throws IOException {
    // Non existent directory.
    Path path_dir1 = Paths.get(TEST_DIR, "newDir1");
    try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(path_dir1, "*.c")) {
        fail();
    } catch (NoSuchFileException expected) {
    }
    // File instead of directory.
    Path path_file1 = Paths.get(TEST_DIR, "newFile1");
    Files.createFile(path_file1);
    try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(path_file1, "*.c")) {
        fail();
    } catch (NotDirectoryException expected) {
    }
    Files.createFile(path_dir1);
    try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(path_file1, "[a")) {
        fail();
    } catch (PatternSyntaxException expected) {
    }
    try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(null, "[a")) {
        fail();
    } catch (NullPointerException expected) {
    }
    try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(path_dir1, (String) null)) {
        fail();
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
public void testCookieWithNoPeriod() throws Exception {
    CookieManager cm = new CookieManager(createCookieStore(), null);
    Map<String, List<String>> responseHeaders = new HashMap<>();
    List<String> list = new ArrayList<String>();
    list.add("foo=bar");
    responseHeaders.put("Set-Cookie", list);
    URI uri = new URI("http://localhost");
    cm.put(uri, responseHeaders);
    Map<String, List<String>> cookies = cm.get(new URI("https://localhost/log/me/in"), responseHeaders);
    assertEquals(1, cookies.size());
    List<String> cookieList = cookies.values().iterator().next();
    assertEquals("foo=bar", cookieList.get(0));
}
#method_after
public void testCookieWithNoPeriod() throws Exception {
    CookieManager cm = new CookieManager(createCookieStore(), null);
    Map<String, List<String>> responseHeaders = Collections.singletonMap("Set-Cookie", Collections.singletonList("foo=bar"));
    URI uri = new URI("http://localhost");
    cm.put(uri, responseHeaders);
    Map<String, List<String>> cookies = cm.get(new URI("https://localhost/log/me/in"), responseHeaders);
    List<String> cookieList = cookies.values().iterator().next();
    assertEquals(Collections.singletonList("foo=bar"), cookieList);
}
#end_block

#method_before
public boolean setNetworkVariable(int netId, String name, String value) {
    if (TextUtils.isEmpty(name) || TextUtils.isEmpty(value))
        return false;
    if (name.equals(WifiConfiguration.pskVarName) || name.equals(WifiEnterpriseConfig.PASSWORD_KEY) || name.equals(WifiEnterpriseConfig.IDENTITY_KEY)) {
        return doBooleanCommandWithoutLogging("SET_NETWORK " + netId + " " + name + " " + value);
    } else {
        return doBooleanCommand("SET_NETWORK " + netId + " " + name + " " + value);
    }
}
#method_after
public boolean setNetworkVariable(int netId, String name, String value) {
    if (TextUtils.isEmpty(name) || TextUtils.isEmpty(value))
        return false;
    if (name.equals(WifiConfiguration.pskVarName) || name.equals(WifiEnterpriseConfig.PASSWORD_KEY) || name.equals(WifiEnterpriseConfig.IDENTITY_KEY) || name.equals(WifiEnterpriseConfig.ANON_IDENTITY_KEY)) {
        return doBooleanCommandWithoutLogging("SET_NETWORK " + netId + " " + name + " " + value);
    } else {
        return doBooleanCommand("SET_NETWORK " + netId + " " + name + " " + value);
    }
}
#end_block

#method_before
public List<byte[]> getStatusResponses() {
    if (peerCertificateOcspData == null) {
        return null;
    }
    return Collections.singletonList(peerCertificateOcspData.clone());
}
#method_after
public List<byte[]> getStatusResponses() {
    if (peerCertificateOcspData == null) {
        return Collections.<byte[]>emptyList();
    }
    return Collections.singletonList(peerCertificateOcspData.clone());
}
#end_block

#method_before
/**
 * Returns all the interfaces on this machine. The {@code Enumeration}
 * contains at least one element, possibly representing a loopback
 * interface that only supports communication between entities on
 * this machine.
 *
 * NOTE: can use getNetworkInterfaces()+getInetAddresses()
 *       to obtain all IP addresses for this node
 *
 * @return an Enumeration of NetworkInterfaces found on this machine
 * @exception  SocketException  if an I/O error occurs.
 */
public static Enumeration<NetworkInterface> getNetworkInterfaces() throws SocketException {
    final NetworkInterface[] netifs = getAll();
    // specified to return null if no network interfaces
    if (netifs == null)
        return null;
    return new Enumeration<NetworkInterface>() {

        private int i = 0;

        public NetworkInterface nextElement() {
            if (netifs != null && i < netifs.length) {
                NetworkInterface netif = netifs[i++];
                return netif;
            } else {
                throw new NoSuchElementException();
            }
        }

        public boolean hasMoreElements() {
            return (netifs != null && i < netifs.length);
        }
    };
}
#method_after
/**
 * Returns all the interfaces on this machine. The {@code Enumeration}
 * contains at least one element, possibly representing a loopback
 * interface that only supports communication between entities on
 * this machine.
 *
 * NOTE: can use getNetworkInterfaces()+getInetAddresses()
 *       to obtain all IP addresses for this node
 *
 * @return an Enumeration of NetworkInterfaces found on this machine
 * @exception  SocketException  if an I/O error occurs.
 */
public static Enumeration<NetworkInterface> getNetworkInterfaces() throws SocketException {
    final NetworkInterface[] netifs = getAll();
    // specified to return null if no network interfaces
    if (netifs.length == 0)
        return null;
    return Collections.enumeration(Arrays.asList(netifs));
}
#end_block

#method_before
private static NetworkInterface[] getAll() throws SocketException {
    // Group Ifaddrs by interface name.
    Map<String, List<StructIfaddrs>> inetMap = new HashMap<>();
    StructIfaddrs[] ifaddrs;
    try {
        ifaddrs = Libcore.os.getifaddrs();
    } catch (ErrnoException e) {
        throw e.rethrowAsSocketException();
    }
    for (StructIfaddrs ifa : ifaddrs) {
        String name = ifa.ifa_name;
        List<StructIfaddrs> ifas;
        if ((ifas = inetMap.get(name)) == null) {
            ifas = new ArrayList<>();
            inetMap.put(name, ifas);
        }
        ifas.add(ifa);
    }
    // Populate NetworkInterface instances.
    Map<String, NetworkInterface> nis = new HashMap<>(inetMap.size());
    for (Map.Entry<String, List<StructIfaddrs>> e : inetMap.entrySet()) {
        String name = e.getKey();
        int index = Libcore.os.if_nametoindex(e.getKey());
        NetworkInterface ni = new NetworkInterface(name, index, null);
        ni.displayName = name;
        List<InetAddress> addrs = new ArrayList<>();
        List<InterfaceAddress> binds = new ArrayList<>();
        for (StructIfaddrs ifa : e.getValue()) {
            if (ifa.ifa_addr != null) {
                addrs.add(ifa.ifa_addr);
                binds.add(new InterfaceAddress(ifa.ifa_addr, (Inet4Address) ifa.ifa_broadaddr, ifa.ifa_netmask));
            }
            if (ifa.hwaddr != null) {
                ni.hardwareAddr = ifa.hwaddr;
            }
        }
        ni.addrs = addrs.toArray(new InetAddress[addrs.size()]);
        ni.bindings = binds.toArray(new InterfaceAddress[binds.size()]);
        nis.put(name, ni);
    }
    // Populate childs/parent.
    for (Map.Entry<String, NetworkInterface> e : nis.entrySet()) {
        NetworkInterface ni = e.getValue();
        String niName = ni.getName();
        int colonIdx = niName.indexOf(':');
        if (colonIdx != -1) {
            // This is a virtual interface.
            String parentName = niName.substring(0, colonIdx);
            NetworkInterface parent = nis.get(parentName);
            ni.virtual = true;
            ni.parent = parent;
            parent.childs.add(ni);
        }
    }
    return nis.values().toArray(new NetworkInterface[nis.size()]);
}
#method_after
private static NetworkInterface[] getAll() throws SocketException {
    // Group Ifaddrs by interface name.
    Map<String, List<StructIfaddrs>> inetMap = new HashMap<>();
    StructIfaddrs[] ifaddrs;
    try {
        ifaddrs = Libcore.os.getifaddrs();
    } catch (ErrnoException e) {
        throw e.rethrowAsSocketException();
    }
    for (StructIfaddrs ifa : ifaddrs) {
        String name = ifa.ifa_name;
        List<StructIfaddrs> ifas;
        if ((ifas = inetMap.get(name)) == null) {
            ifas = new ArrayList<>();
            inetMap.put(name, ifas);
        }
        ifas.add(ifa);
    }
    // Populate NetworkInterface instances.
    Map<String, NetworkInterface> nis = new HashMap<>(inetMap.size());
    for (Map.Entry<String, List<StructIfaddrs>> e : inetMap.entrySet()) {
        String name = e.getKey();
        int index = Libcore.os.if_nametoindex(e.getKey());
        if (index == 0) {
            // This interface has gone away between getifaddrs and if_nametoindex
            continue;
        }
        NetworkInterface ni = new NetworkInterface(name, index, null);
        ni.displayName = name;
        List<InetAddress> addrs = new ArrayList<>();
        List<InterfaceAddress> binds = new ArrayList<>();
        for (StructIfaddrs ifa : e.getValue()) {
            if (ifa.ifa_addr != null) {
                addrs.add(ifa.ifa_addr);
                binds.add(new InterfaceAddress(ifa.ifa_addr, (Inet4Address) ifa.ifa_broadaddr, ifa.ifa_netmask));
            }
            if (ifa.hwaddr != null) {
                ni.hardwareAddr = ifa.hwaddr;
            }
        }
        ni.addrs = addrs.toArray(new InetAddress[addrs.size()]);
        ni.bindings = binds.toArray(new InterfaceAddress[binds.size()]);
        nis.put(name, ni);
    }
    // Populate childs/parent.
    for (Map.Entry<String, NetworkInterface> e : nis.entrySet()) {
        NetworkInterface ni = e.getValue();
        String niName = ni.getName();
        int colonIdx = niName.indexOf(':');
        if (colonIdx != -1) {
            // This is a virtual interface.
            String parentName = niName.substring(0, colonIdx);
            NetworkInterface parent = nis.get(parentName);
            ni.virtual = true;
            ni.parent = parent;
            parent.childs.add(ni);
        }
    }
    return nis.values().toArray(new NetworkInterface[nis.size()]);
}
#end_block

#method_before
public void testDisplayNamesWithScript() throws Exception {
    Locale.Builder builder = new Locale.Builder().setLanguage("sr").setRegion("RS");
    Locale latinLocale = builder.setScript("Latn").build();
    Locale cyrillicLocale = builder.setScript("Cyrl").build();
    Locale noScriptLocale = builder.setScript(null).build();
    TimeZone tz = TimeZone.getTimeZone("Europe/London");
    final String latinName = "Srednje vreme po Griniču";
    final String cyrillicName = "Средње време по Гриничу";
    // Check java.util.TimeZone
    assertEquals(latinName, tz.getDisplayName(latinLocale));
    assertEquals(cyrillicName, tz.getDisplayName(cyrillicLocale));
    assertEquals(cyrillicName, tz.getDisplayName(noScriptLocale));
    // Check ICU TimeZoneNames
    // The one-argument getDisplayName() override uses LONG_GENERIC style which is different
    // from what java.util.TimeZone uses. Force the LONG style to get equivalent results.
    final int style = android.icu.util.TimeZone.LONG;
    android.icu.util.TimeZone utz = android.icu.util.TimeZone.getTimeZone(tz.getID());
    assertEquals(latinName, utz.getDisplayName(false, style, latinLocale));
    assertEquals(cyrillicName, utz.getDisplayName(false, style, cyrillicLocale));
    assertEquals(cyrillicName, utz.getDisplayName(false, style, noScriptLocale));
}
#method_after
public void testDisplayNamesWithScript() throws Exception {
    Locale latinLocale = Locale.forLanguageTag("sr-Latn-RS");
    Locale cyrillicLocale = Locale.forLanguageTag("sr-Cyrl-RS");
    Locale noScriptLocale = Locale.forLanguageTag("sr-RS");
    TimeZone tz = TimeZone.getTimeZone("Europe/London");
    final String latinName = "Srednje vreme po Griniču";
    final String cyrillicName = "Средње време по Гриничу";
    // Check java.util.TimeZone
    assertEquals(latinName, tz.getDisplayName(latinLocale));
    assertEquals(cyrillicName, tz.getDisplayName(cyrillicLocale));
    assertEquals(cyrillicName, tz.getDisplayName(noScriptLocale));
    // Check ICU TimeZoneNames
    // The one-argument getDisplayName() override uses LONG_GENERIC style which is different
    // from what java.util.TimeZone uses. Force the LONG style to get equivalent results.
    final int style = android.icu.util.TimeZone.LONG;
    android.icu.util.TimeZone utz = android.icu.util.TimeZone.getTimeZone(tz.getID());
    assertEquals(latinName, utz.getDisplayName(false, style, latinLocale));
    assertEquals(cyrillicName, utz.getDisplayName(false, style, cyrillicLocale));
    assertEquals(cyrillicName, utz.getDisplayName(false, style, noScriptLocale));
}
#end_block

#method_before
@Override
protected void setUp() throws Exception {
    super.setUp();
    mInstrumentation = getInstrumentation();
    mActivity = getActivity();
    assertTrue(waitForActivityToHaveFocus(500));
}
#method_after
@Override
protected void setUp() throws Exception {
    super.setUp();
    mInstrumentation = getInstrumentation();
    mActivity = getActivity();
    assertTrue(waitForActivityToHaveFocus(5000));
}
#end_block

