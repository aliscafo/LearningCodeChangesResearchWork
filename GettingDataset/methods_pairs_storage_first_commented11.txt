441
#method_before
private CommitValidationMessage getMissingChangeIdErrorMsg(String errMsg, RevCommit c) {
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    if (c.getFullMessage().contains(CHANGE_ID_PREFIX)) {
        String lastLine = Iterables.getLast(Splitter.on('\n').split(c.getFullMessage()), "");
        if (!lastLine.contains(CHANGE_ID_PREFIX)) {
            sb.append("\n\n").append("Hint: run\n").append("  git commit --amend\n").append("and put 'Change-Id: Ixxx..' at the bottom on a separate line\n");
        }
    }
    sb.append('\n');
    sb.append('\n');
    sb.append("Hint: To automatically insert ");
    sb.append(FooterConstants.CHANGE_ID.getName());
    sb.append(", install the hook:\n");
    sb.append(getCommitMessageHookInstallationHint());
    sb.append('\n');
    sb.append("And then amend the commit:\n");
    sb.append("  git commit --amend\n");
    return new CommitValidationMessage(sb.toString(), false);
}
#method_after
private CommitValidationMessage getMissingChangeIdErrorMsg(String errMsg, RevCommit c) {
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    if (c.getFullMessage().contains(CHANGE_ID_PREFIX)) {
        String lastLine = Iterables.getLast(Splitter.on('\n').split(c.getFullMessage()), "");
        if (!lastLine.contains(CHANGE_ID_PREFIX)) {
            sb.append("\n\n").append("Hint: run\n").append("  git commit --amend\n").append("and move 'Change-Id: Ixxx..' to the bottom on a separate line\n");
        }
    }
    sb.append('\n');
    sb.append('\n');
    sb.append("Hint: To automatically insert ");
    sb.append(FooterConstants.CHANGE_ID.getName());
    sb.append(", install the hook:\n");
    sb.append(getCommitMessageHookInstallationHint());
    sb.append('\n');
    sb.append("And then amend the commit:\n");
    sb.append("  git commit --amend\n");
    return new CommitValidationMessage(sb.toString(), false);
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException, IOException {
    if (sendMail && (notify != NotifyHandling.NONE || !accountsToNotify.isEmpty())) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    CreateChangeSender cm = createChangeSenderFactory.create(change.getProject(), change.getId());
                    cm.setFrom(change.getOwner());
                    cm.setPatchSet(patchSet, patchSetInfo);
                    cm.setNotify(notify);
                    cm.setAccountsToNotify(accountsToNotify);
                    cm.addReviewers(reviewers);
                    cm.addExtraCC(extraCC);
                    cm.send();
                } catch (Exception e) {
                    logger.atSevere().withCause(e).log("Cannot send email for new change %s", change.getId());
                }
            }

            @Override
            public String toString() {
                return "send-email newchange";
            }
        };
        if (requestScopePropagator != null) {
            @SuppressWarnings("unused")
            Future<?> possiblyIgnoredError = sendEmailExecutor.submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    /* For labels that are not set in this operation, show the "current" value
     * of 0, and no oldValue as the value was not modified by this operation.
     * For labels that are set in this operation, the value was modified, so
     * show a transition from an oldValue of 0 to the new value.
     */
    if (fireRevisionCreated) {
        revisionCreated.fire(change, patchSet, ctx.getAccount(), ctx.getWhen(), notify);
        if (approvals != null && !approvals.isEmpty()) {
            List<LabelType> labels = projectState.getLabelTypes(change).getLabelTypes();
            Map<String, Short> allApprovals = new HashMap<>();
            Map<String, Short> oldApprovals = new HashMap<>();
            for (LabelType lt : labels) {
                allApprovals.put(lt.getName(), (short) 0);
                oldApprovals.put(lt.getName(), null);
            }
            for (Map.Entry<String, Short> entry : approvals.entrySet()) {
                if (entry.getValue() != 0) {
                    allApprovals.put(entry.getKey(), entry.getValue());
                    oldApprovals.put(entry.getKey(), (short) 0);
                }
            }
            commentAdded.fire(change, patchSet, ctx.getAccount(), null, allApprovals, oldApprovals, ctx.getWhen());
        }
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException, IOException {
    if (sendMail && (notify != NotifyHandling.NONE || !accountsToNotify.isEmpty())) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    CreateChangeSender cm = createChangeSenderFactory.create(change.getProject(), change.getId());
                    cm.setFrom(change.getOwner());
                    cm.setPatchSet(patchSet, patchSetInfo);
                    cm.setNotify(notify);
                    cm.setAccountsToNotify(accountsToNotify);
                    cm.addReviewers(reviewers);
                    cm.addExtraCC(extraCC);
                    cm.send();
                } catch (Exception e) {
                    logger.atSevere().withCause(e).log("Cannot send email for new change %s", change.getId());
                }
            }

            @Override
            public String toString() {
                return "send-email newchange";
            }
        };
        if (requestScopePropagator != null) {
            @SuppressWarnings("unused")
            Future<?> possiblyIgnoredError = sendEmailExecutor.submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    /* For labels that are not set in this operation, show the "current" value
     * of 0, and no oldValue as the value was not modified by this operation.
     * For labels that are set in this operation, the value was modified, so
     * show a transition from an oldValue of 0 to the new value.
     */
    if (fireRevisionCreated) {
        revisionCreated.fire(change, patchSet, ctx.getAccount(), ctx.getWhen(), notify);
        if (approvals != null && !approvals.isEmpty()) {
            List<LabelType> labels = projectState.getLabelTypes(change.getDest()).getLabelTypes();
            Map<String, Short> allApprovals = new HashMap<>();
            Map<String, Short> oldApprovals = new HashMap<>();
            for (LabelType lt : labels) {
                allApprovals.put(lt.getName(), (short) 0);
                oldApprovals.put(lt.getName(), null);
            }
            for (Map.Entry<String, Short> entry : approvals.entrySet()) {
                if (entry.getValue() != 0) {
                    allApprovals.put(entry.getKey(), entry.getValue());
                    oldApprovals.put(entry.getKey(), (short) 0);
                }
            }
            commentAdded.fire(change, patchSet, ctx.getAccount(), null, allApprovals, oldApprovals, ctx.getWhen());
        }
    }
}
#end_block

#method_before
public LabelTypes getLabelTypes() throws OrmException {
    if (labelTypes == null) {
        ProjectState state;
        try {
            state = projectCache.checkedGet(project());
        } catch (IOException e) {
            throw new OrmException("project state not available", e);
        }
        labelTypes = state.getLabelTypes(change());
    }
    return labelTypes;
}
#method_after
public LabelTypes getLabelTypes() throws OrmException {
    if (labelTypes == null) {
        ProjectState state;
        try {
            state = projectCache.checkedGet(project());
        } catch (IOException e) {
            throw new OrmException("project state not available", e);
        }
        labelTypes = state.getLabelTypes(change().getDest());
    }
    return labelTypes;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    if (!reviewers.isEmpty()) {
        if (migration.readChanges() && state == CC) {
            addedCCs = approvalsUtil.addCcs(ctx.getNotes(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), reviewers);
            if (addedCCs.isEmpty()) {
                return false;
            }
        } else {
            addedReviewers = approvalsUtil.addReviewers(ctx.getDb(), ctx.getNotes(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), projectCache.checkedGet(rsrc.getProject()).getLabelTypes(rsrc.getChange()), rsrc.getChange(), reviewers);
            if (addedReviewers.isEmpty()) {
                return false;
            }
        }
    }
    for (Address a : reviewersByEmail) {
        ctx.getUpdate(ctx.getChange().currentPatchSetId()).putReviewerByEmail(a, ReviewerStateInternal.fromReviewerState(state));
    }
    patchSet = psUtil.current(dbProvider.get(), rsrc.getNotes());
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    if (!reviewers.isEmpty()) {
        if (migration.readChanges() && state == CC) {
            addedCCs = approvalsUtil.addCcs(ctx.getNotes(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), reviewers);
            if (addedCCs.isEmpty()) {
                return false;
            }
        } else {
            addedReviewers = approvalsUtil.addReviewers(ctx.getDb(), ctx.getNotes(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), projectCache.checkedGet(rsrc.getProject()).getLabelTypes(rsrc.getChange().getDest()), rsrc.getChange(), reviewers);
            if (addedReviewers.isEmpty()) {
                return false;
            }
        }
    }
    for (Address a : reviewersByEmail) {
        ctx.getUpdate(ctx.getChange().currentPatchSetId()).putReviewerByEmail(a, ReviewerStateInternal.fromReviewerState(state));
    }
    patchSet = psUtil.current(dbProvider.get(), rsrc.getNotes());
    return true;
}
#end_block

#method_before
public LabelTypes getLabelTypes(ChangeNotes notes) {
    return getLabelTypes(notes.getChange().getDest(), notes.getChange().getOwner());
}
#method_after
public LabelTypes getLabelTypes(ChangeNotes notes) {
    return getLabelTypes(notes.getChange().getDest());
}
#end_block

#method_before
private LabelTypes getLabelTypes(Branch.NameKey destination, Account.Id changeOwner) {
    IdentifiedUser owner = userFactory.create(changeOwner);
    List<LabelType> all = getLabelTypes().getLabelTypes();
    List<LabelType> r = Lists.newArrayListWithCapacity(all.size());
    for (LabelType l : all) {
        List<String> refs = l.getRefPatterns();
        if (refs == null) {
            r.add(l);
        } else {
            for (String refPattern : refs) {
                if (RefConfigSection.isValid(refPattern) && match(destination, refPattern, owner)) {
                    r.add(l);
                    break;
                }
            }
        }
    }
    return new LabelTypes(r);
}
#method_after
public LabelTypes getLabelTypes(Branch.NameKey destination) {
    List<LabelType> all = getLabelTypes().getLabelTypes();
    List<LabelType> r = Lists.newArrayListWithCapacity(all.size());
    for (LabelType l : all) {
        List<String> refs = l.getRefPatterns();
        if (refs == null) {
            r.add(l);
        } else {
            for (String refPattern : refs) {
                if (refPattern.contains("${")) {
                    logger.atWarning().log("Ref pattern for label %s in project %s contains illegal expanded parameters: %s." + " Ref pattern will be ignored.", l, getName(), refPattern);
                    continue;
                }
                if (RefConfigSection.isValid(refPattern) && match(destination, refPattern)) {
                    r.add(l);
                    break;
                }
            }
        }
    }
    return new LabelTypes(r);
}
#end_block

#method_before
private boolean match(Branch.NameKey destination, String refPattern, CurrentUser changeOwner) {
    return RefPatternMatcher.getMatcher(refPattern).match(destination.get(), changeOwner);
}
#method_after
private boolean match(Branch.NameKey destination, String refPattern) {
    return RefPatternMatcher.getMatcher(refPattern).match(destination.get(), null);
}
#end_block

#method_before
private BloomFilter<K> buildBloomFilter() {
    SqlHandle c = null;
    try {
        c = acquire();
        if (estimatedSize <= 0) {
            try (PreparedStatement ps = c.conn.prepareStatement("SELECT COUNT(*) FROM data WHERE version=?")) {
                ps.setInt(1, version);
                try (ResultSet r = ps.executeQuery()) {
                    estimatedSize = r.next() ? r.getInt(1) : 0;
                }
            }
        }
        BloomFilter<K> b = newBloomFilter();
        try (PreparedStatement ps = c.conn.prepareStatement("SELECT k FROM data WHERE version=?")) {
            ps.setInt(1, version);
            try (ResultSet r = ps.executeQuery()) {
                while (r.next()) {
                    b.put(keyType.get(r, 1));
                }
            }
        } catch (Exception e) {
            if (e.getCause() instanceof InvalidClassException) {
                // If deserialization failed using default Java serialization, this means we are using
                // the old serialVersionUID-based invalidation strategy. In that case, authors are
                // most likely bumping serialVersionUID rather than using the new versioning in the
                // CacheBinding.  That's ok; we'll continue to support both for now.
                // TODO(dborowitz): Remove this case when Java serialization is no longer used.
                logger.atWarning().log("Entries cached for %s have an incompatible class and can't be deserialized. " + "Cache is flushed.", url);
                invalidateAll();
            } else {
                throw e;
            }
        }
        return b;
    } catch (IOException | SQLException e) {
        logger.atWarning().log("Cannot build BloomFilter for %s: %s", url, e.getMessage());
        c = close(c);
        return null;
    } finally {
        release(c);
    }
}
#method_after
private BloomFilter<K> buildBloomFilter() {
    SqlHandle c = null;
    try {
        c = acquire();
        if (estimatedSize <= 0) {
            try (PreparedStatement ps = c.conn.prepareStatement("SELECT COUNT(*) FROM data WHERE version=?")) {
                ps.setInt(1, version);
                try (ResultSet r = ps.executeQuery()) {
                    estimatedSize = r.next() ? r.getInt(1) : 0;
                }
            }
        }
        BloomFilter<K> b = newBloomFilter();
        try (PreparedStatement ps = c.conn.prepareStatement("SELECT k FROM data WHERE version=?")) {
            ps.setInt(1, version);
            try (ResultSet r = ps.executeQuery()) {
                while (r.next()) {
                    b.put(keyType.get(r, 1));
                }
            }
        } catch (Exception e) {
            if (Throwables.getCausalChain(e).stream().anyMatch(InvalidClassException.class::isInstance)) {
                // If deserialization failed using default Java serialization, this means we are using
                // the old serialVersionUID-based invalidation strategy. In that case, authors are
                // most likely bumping serialVersionUID rather than using the new versioning in the
                // CacheBinding.  That's ok; we'll continue to support both for now.
                // TODO(dborowitz): Remove this case when Java serialization is no longer used.
                logger.atWarning().log("Entries cached for %s have an incompatible class and can't be deserialized. " + "Cache is flushed.", url);
                invalidateAll();
            } else {
                throw e;
            }
        }
        return b;
    } catch (IOException | SQLException e) {
        logger.atWarning().log("Cannot build BloomFilter for %s: %s", url, e.getMessage());
        c = close(c);
        return null;
    } finally {
        release(c);
    }
}
#end_block

#method_before
@Override
public PureRevertInfo pureRevert(@Nullable String claimedOriginal) throws RestApiException {
    try {
        getPureRevert.setClaimedOriginal(claimedOriginal);
        return getPureRevert.apply(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot compute pure revert", e);
    }
}
#method_after
@Override
public PureRevertInfo pureRevert(@Nullable String claimedOriginal) throws RestApiException {
    try {
        GetPureRevert getPureRevert = getPureRevertProvider.get();
        getPureRevert.setClaimedOriginal(claimedOriginal);
        return getPureRevert.apply(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot compute pure revert", e);
    }
}
#end_block

#method_before
@Test
public void deleteNewChangeAsUserWithDeleteChangesPermissionForProjectOwners() throws Exception {
    GroupApi groupApi = gApi.groups().create(name("delete-change"));
    groupApi.addMembers("user");
    ProjectInput in = new ProjectInput();
    in.name = name("delete-change");
    in.owners = Lists.newArrayListWithCapacity(1);
    in.owners.add(groupApi.name());
    ProjectApi api = gApi.projects().create(in);
    Project.NameKey nameKey = new Project.NameKey(api.get().name);
    TestRepository<InMemoryRepository> repo = cloneProject(nameKey, admin);
    ProjectConfig cfg = projectCache.checkedGet(nameKey).getConfig();
    Util.allow(cfg, Permission.DELETE_CHANGES, PROJECT_OWNERS, "refs/*");
    saveProjectConfig(nameKey, cfg);
    deleteChangeAsUser(repo, admin, user);
}
#method_after
@Test
public void deleteNewChangeAsUserWithDeleteChangesPermissionForProjectOwners() throws Exception {
    GroupApi groupApi = gApi.groups().create(name("delete-change"));
    groupApi.addMembers("user");
    ProjectInput in = new ProjectInput();
    in.name = name("delete-change");
    in.owners = Lists.newArrayListWithCapacity(1);
    in.owners.add(groupApi.name());
    in.createEmptyCommit = true;
    ProjectApi api = gApi.projects().create(in);
    Project.NameKey nameKey = new Project.NameKey(api.get().name);
    ProjectConfig cfg = projectCache.checkedGet(nameKey).getConfig();
    Util.allow(cfg, Permission.DELETE_CHANGES, PROJECT_OWNERS, "refs/*");
    saveProjectConfig(nameKey, cfg);
    deleteChangeAsUser(nameKey, admin, user);
}
#end_block

#method_before
@Test
@TestProjectInput(cloneAs = "user")
public void deleteChangeAsUserWithDeleteOwnChangesPermissionForGroup() throws Exception {
    allow(Permission.DELETE_OWN_CHANGES, REGISTERED_USERS, "refs/*");
    deleteChangeAsUser(user, user);
}
#method_after
@Test
public void deleteChangeAsUserWithDeleteOwnChangesPermissionForGroup() throws Exception {
    allow(Permission.DELETE_OWN_CHANGES, REGISTERED_USERS, "refs/*");
    deleteChangeAsUser(user, user);
}
#end_block

#method_before
@Test
@TestProjectInput(cloneAs = "user")
public void deleteChangeAsUserWithDeleteOwnChangesPermissionForOwners() throws Exception {
    allow(Permission.DELETE_OWN_CHANGES, CHANGE_OWNER, "refs/*");
    deleteChangeAsUser(user, user);
}
#method_after
@Test
public void deleteChangeAsUserWithDeleteOwnChangesPermissionForOwners() throws Exception {
    allow(Permission.DELETE_OWN_CHANGES, CHANGE_OWNER, "refs/*");
    deleteChangeAsUser(user, user);
}
#end_block

#method_before
private void deleteChangeAsUser(TestAccount owner, TestAccount deleteAs) throws Exception {
    deleteChangeAsUser(testRepo, owner, deleteAs);
}
#method_after
private void deleteChangeAsUser(TestAccount owner, TestAccount deleteAs) throws Exception {
    deleteChangeAsUser(project, owner, deleteAs);
}
#end_block

#method_before
private void deleteChangeAsUser(TestRepository<InMemoryRepository> repo, TestAccount owner, TestAccount deleteAs) throws Exception {
    try {
        PushOneCommit.Result changeResult = pushFactory.create(db, owner.getIdent(), repo).to("refs/for/master");
        String changeId = changeResult.getChangeId();
        setApiUser(deleteAs);
        gApi.changes().id(changeId).delete();
        assertThat(query(changeId)).isEmpty();
    } finally {
        removePermission(Permission.DELETE_OWN_CHANGES, project, "refs/*");
        removePermission(Permission.DELETE_CHANGES, project, "refs/*");
    }
}
#method_after
private void deleteChangeAsUser(Project.NameKey projectName, TestAccount owner, TestAccount deleteAs) throws Exception {
    try {
        setApiUser(owner);
        ChangeInput in = new ChangeInput();
        in.project = projectName.get();
        in.branch = "refs/heads/master";
        in.subject = "test";
        String changeId = gApi.changes().create(in).get().changeId;
        assertThat(gApi.changes().id(changeId).info().owner._accountId).isEqualTo(owner.id.get());
        setApiUser(deleteAs);
        gApi.changes().id(changeId).delete();
        assertThat(query(changeId)).isEmpty();
    } finally {
        removePermission(Permission.DELETE_OWN_CHANGES, project, "refs/*");
        removePermission(Permission.DELETE_CHANGES, project, "refs/*");
    }
}
#end_block

#method_before
@Test
@TestProjectInput(cloneAs = "user")
public void deleteNewChangeOfAnotherUserAsAdmin() throws Exception {
    deleteChangeAsUser(user, admin);
}
#method_after
@Test
public void deleteNewChangeOfAnotherUserAsAdmin() throws Exception {
    deleteChangeAsUser(user, admin);
}
#end_block

#method_before
public static boolean shouldConfigure() {
    String property = System.getProperty(LOG4J_CONFIGURATION);
    return Strings.isNullOrEmpty(property);
}
#method_after
public static boolean shouldConfigure() {
    return Strings.isNullOrEmpty(System.getProperty(LOG4J_CONFIGURATION));
}
#end_block

#method_before
private void validate() throws UnloggedFailure {
    PermissionBackend.WithUser userPermission = permissionBackend.user(userProvider);
    boolean hasSuperPrivs = userPermission.testOrFalse(GlobalPermission.ADMINISTRATE_SERVER);
    boolean hasModAccountPrivs = hasSuperPrivs || userPermission.testOrFalse(GlobalPermission.MODIFY_ACCOUNT);
    if (id != userProvider.get().getAccountId()) {
        if (!hasModAccountPrivs) {
            throw die("Setting another user's account information requries 'modify account' or 'administrate server' capabilities.");
        }
    }
    if (active || inactive) {
        if (!hasModAccountPrivs) {
            throw die("--active and --inactive require 'modify account' or 'administrate server' capabilities.");
        }
        if (active && inactive) {
            throw die("--active and --inactive options are mutually exclusive.");
        }
    }
    if (generateHttpPassword && clearHttpPassword) {
        throw die("--generate-http-password and --clear-http-password are mutually exclusive.");
    }
    if (!Strings.isNullOrEmpty(httpPassword)) {
        // gave --http-password
        if (!hasSuperPrivs) {
            throw die("--http-password requires 'administrate server' capabilities.");
        }
        if (generateHttpPassword) {
            throw die("--http-password and --generate-http-password options are mutually exclusive.");
        }
        if (clearHttpPassword) {
            throw die("--http-password and --clear-http-password options are mutually exclusive.");
        }
    }
    if (addSshKeys.contains("-") && deleteSshKeys.contains("-")) {
        throw die("Only one option may use the stdin");
    }
    if (deleteSshKeys.contains("ALL")) {
        deleteSshKeys = Collections.singletonList("ALL");
    }
    if (deleteEmails.contains("ALL")) {
        deleteEmails = Collections.singletonList("ALL");
    }
    if (deleteEmails.contains(preferredEmail)) {
        throw die("--preferred-email and --delete-email options are mutually " + "exclusive for the same email address.");
    }
}
#method_after
private void validate() throws UnloggedFailure {
    PermissionBackend.WithUser userPermission = permissionBackend.user(userProvider);
    boolean isAdmin = userPermission.testOrFalse(GlobalPermission.ADMINISTRATE_SERVER);
    boolean canModifyAccount = isAdmin || userPermission.testOrFalse(GlobalPermission.MODIFY_ACCOUNT);
    if (!user.hasSameAccountId(userProvider.get()) && !canModifyAccount) {
        throw die("Setting another user's account information requries 'modify account' or 'administrate server' capabilities.");
    }
    if (active || inactive) {
        if (!canModifyAccount) {
            throw die("--active and --inactive require 'modify account' or 'administrate server' capabilities.");
        }
        if (active && inactive) {
            throw die("--active and --inactive options are mutually exclusive.");
        }
    }
    if (generateHttpPassword && clearHttpPassword) {
        throw die("--generate-http-password and --clear-http-password are mutually exclusive.");
    }
    if (!Strings.isNullOrEmpty(httpPassword)) {
        // gave --http-password
        if (!isAdmin) {
            throw die("--http-password requires 'administrate server' capabilities.");
        }
        if (generateHttpPassword) {
            throw die("--http-password and --generate-http-password options are mutually exclusive.");
        }
        if (clearHttpPassword) {
            throw die("--http-password and --clear-http-password options are mutually exclusive.");
        }
    }
    if (addSshKeys.contains("-") && deleteSshKeys.contains("-")) {
        throw die("Only one option may use the stdin");
    }
    if (deleteSshKeys.contains("ALL")) {
        deleteSshKeys = Collections.singletonList("ALL");
    }
    if (deleteEmails.contains("ALL")) {
        deleteEmails = Collections.singletonList("ALL");
    }
    if (deleteEmails.contains(preferredEmail)) {
        throw die("--preferred-email and --delete-email options are mutually " + "exclusive for the same email address.");
    }
}
#end_block

#method_before
@Override
public ChangeBundle fromReviewDb(ReviewDb db, Change.Id id) throws OrmException {
    Change reviewDbChange = db.changes().get(id);
    if (reviewDbChange == null) {
        return null;
    }
    // TODO(dborowitz): Figure out how to do this more consistently, e.g. hand-written inner joins.
    List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(id).toList();
    return new ChangeBundle(reviewDbChange, db.changeMessages().byChange(id), db.patchSets().byChange(id), approvals, db.patchComments().byChange(id), ReviewerSet.fromApprovals(approvals), Source.REVIEW_DB);
}
#method_after
@Override
@Nullable
public ChangeBundle fromReviewDb(ReviewDb db, Change.Id id) throws OrmException {
    Change reviewDbChange = db.changes().get(id);
    if (reviewDbChange == null) {
        return null;
    }
    // TODO(dborowitz): Figure out how to do this more consistently, e.g. hand-written inner joins.
    List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(id).toList();
    return new ChangeBundle(reviewDbChange, db.changeMessages().byChange(id), db.patchSets().byChange(id), approvals, db.patchComments().byChange(id), ReviewerSet.fromApprovals(approvals), Source.REVIEW_DB);
}
#end_block

#method_before
public String getNameEmailFor(Account.Id accountId) {
    if (accountId == null) {
        return args.gerritPersonIdent.toExternalString();
    }
    return args.accountCache.get(accountId).getAccount().getNameEmail(args.anonymousCowardName);
}
#method_after
public String getNameEmailFor(Account.Id accountId) {
    if (accountId == null) {
        return String.format("%s <%s>", args.gerritPersonIdent.getName(), args.gerritPersonIdent.getEmailAddress());
    }
    return args.accountCache.get(accountId).getAccount().getNameEmail(args.anonymousCowardName);
}
#end_block

#method_before
@Test
@GerritConfig(name = "index.autoReindexIfStale", value = "false")
public void indexProject() throws Exception {
    configureIndex(server.getTestInjector());
    PushOneCommit.Result change = createChange("first change", "test1.txt", "test1");
    String changeId = change.getChangeId();
    ChangeInfo changeInfo = gApi.changes().id(changeId).get();
    disableChangeIndexWrites();
    amendChange(changeId, "second test", "test2.txt", "test2");
    assertChangeQuery("message:second", change.getChange(), false);
    enableChangeIndexWrites();
    changeIndexedCounter.clear();
    String cmd = Joiner.on(" ").join("gerrit", "index", "project", project.get());
    adminSshSession.exec(cmd);
    adminSshSession.assertSuccess();
    changeIndexedCounter.assertReindexOf(changeInfo, 1);
    assertChangeQuery("message:second", change.getChange(), true);
}
#method_after
@Test
@GerritConfig(name = "index.autoReindexIfStale", value = "false")
public void indexProject() throws Exception {
    configureIndex(server.getTestInjector());
    PushOneCommit.Result change = createChange("first change", "test1.txt", "test1");
    String changeId = change.getChangeId();
    ChangeInfo changeInfo = gApi.changes().id(changeId).get();
    disableChangeIndexWrites();
    amendChange(changeId, "second test", "test2.txt", "test2");
    assertChangeQuery("message:second", change.getChange(), false);
    enableChangeIndexWrites();
    changeIndexedCounter.clear();
    String cmd = Joiner.on(" ").join("gerrit", "index", "project", project.get());
    adminSshSession.exec(cmd);
    adminSshSession.assertSuccess();
    boolean indexing = true;
    while (indexing) {
        String out = adminSshSession.exec("gerrit show-queue");
        adminSshSession.assertSuccess();
        indexing = out.contains("Index all changes of project " + project.get());
    }
    changeIndexedCounter.assertReindexOf(changeInfo, 1);
    assertChangeQuery("message:second", change.getChange(), true);
}
#end_block

#method_before
@Test
public void supportedVersion() throws Exception {
    assertThat(ElasticVersion.forVersion("2.4.0")).isEqualTo(ElasticVersion.V2_4);
    assertThat(ElasticVersion.forVersion("2.4.6")).isEqualTo(ElasticVersion.V2_4);
    assertThat(ElasticVersion.forVersion("5.6.0")).isEqualTo(ElasticVersion.V5_6);
    assertThat(ElasticVersion.forVersion("5.6.9")).isEqualTo(ElasticVersion.V5_6);
    assertThat(ElasticVersion.forVersion("6.2.0")).isEqualTo(ElasticVersion.V6_2);
    assertThat(ElasticVersion.forVersion("6.2.4")).isEqualTo(ElasticVersion.V6_2);
    assertThat(ElasticVersion.forVersion("6.3.0")).isEqualTo(ElasticVersion.V6_3);
    assertThat(ElasticVersion.forVersion("6.3.1")).isEqualTo(ElasticVersion.V6_3);
}
#method_after
@Test
public void supportedVersion() throws Exception {
    assertThat(ElasticVersion.forVersion("2.4.0")).isEqualTo(ElasticVersion.V2_4);
    assertThat(ElasticVersion.forVersion("2.4.6")).isEqualTo(ElasticVersion.V2_4);
    assertThat(ElasticVersion.forVersion("5.6.0")).isEqualTo(ElasticVersion.V5_6);
    assertThat(ElasticVersion.forVersion("5.6.9")).isEqualTo(ElasticVersion.V5_6);
    assertThat(ElasticVersion.forVersion("5.6.10")).isEqualTo(ElasticVersion.V5_6);
    assertThat(ElasticVersion.forVersion("6.2.0")).isEqualTo(ElasticVersion.V6_2);
    assertThat(ElasticVersion.forVersion("6.2.4")).isEqualTo(ElasticVersion.V6_2);
    assertThat(ElasticVersion.forVersion("6.3.0")).isEqualTo(ElasticVersion.V6_3);
    assertThat(ElasticVersion.forVersion("6.3.1")).isEqualTo(ElasticVersion.V6_3);
}
#end_block

#method_before
List<String> discover(String prefix, String indexName) throws IOException {
    String name = prefix + indexName + "_";
    Response response = client.get().performRequest(HttpGet.METHOD_NAME, client.adapter().getVersionDiscoveryUrl(name));
    StatusLine statusLine = response.getStatusLine();
    if (statusLine.getStatusCode() != HttpStatus.SC_OK) {
        throw new IOException(String.format("Failed to discover index versions for %s: %d: %s", name, statusLine.getStatusCode(), statusLine.getReasonPhrase()));
    }
    return new JsonParser().parse(AbstractElasticIndex.getContent(response)).getAsJsonObject().entrySet().stream().map(e -> e.getKey().replace(name, "")).collect(toList());
}
#method_after
List<String> discover(String prefix, String indexName) throws IOException {
    String name = prefix + indexName + "_";
    Response response = client.get().performRequest(HttpGet.METHOD_NAME, client.adapter().getVersionDiscoveryUrl(name));
    StatusLine statusLine = response.getStatusLine();
    if (statusLine.getStatusCode() != HttpStatus.SC_OK) {
        String message = String.format("Failed to discover index versions for %s: %d: %s", name, statusLine.getStatusCode(), statusLine.getReasonPhrase());
        log.error(message);
        throw new IOException(message);
    }
    return new JsonParser().parse(AbstractElasticIndex.getContent(response)).getAsJsonObject().entrySet().stream().map(e -> e.getKey().replace(name, "")).collect(toList());
}
#end_block

#method_before
public Response<String> apply(IdentifiedUser user, NameInput input) throws MethodNotAllowedException, ResourceNotFoundException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new NameInput();
    }
    if (!realm.allowsEdit(AccountFieldName.FULL_NAME)) {
        throw new MethodNotAllowedException("realm does not allow editing name");
    }
    String newName = input.name;
    Account account = accountsUpdate.create().update(user.getAccountId(), a -> a.setFullName(newName));
    if (account == null) {
        throw new ResourceNotFoundException("account not found");
    }
    return Strings.isNullOrEmpty(account.getFullName()) ? Response.none() : Response.ok(account.getFullName());
}
#method_after
public Response<String> apply(IdentifiedUser user, NameInput input) throws MethodNotAllowedException, ResourceNotFoundException, IOException, ConfigInvalidException, OrmException {
    if (input == null) {
        input = new NameInput();
    }
    if (!realm.allowsEdit(AccountFieldName.FULL_NAME)) {
        throw new MethodNotAllowedException("realm does not allow editing name");
    }
    String newName = input.name;
    Account account = accountsUpdate.create().update("Set Full Name via API", user.getAccountId(), u -> u.setFullName(newName));
    if (account == null) {
        throw new ResourceNotFoundException("account not found");
    }
    return Strings.isNullOrEmpty(account.getFullName()) ? Response.none() : Response.ok(account.getFullName());
}
#end_block

#method_before
public Response<AccountInfo> apply(AccountInput input) throws BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (input.username != null && !username.equals(input.username)) {
        throw new BadRequestException("username must match URL");
    }
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw new BadRequestException("Username '" + username + "' must contain only letters, numbers, _, - or .");
    }
    Set<AccountGroup.UUID> groups = parseGroups(input.groups);
    Account.Id id = new Account.Id(seq.nextAccountId());
    ExternalId extUser = ExternalId.createUsername(username, id, input.httpPassword);
    if (externalIds.get(extUser.key()) != null) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        if (externalIds.get(ExternalId.Key.create(SCHEME_MAILTO, input.email)) != null) {
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
        if (!validator.isValid(input.email)) {
            throw new BadRequestException("invalid email address");
        }
    }
    List<ExternalId> extIds = new ArrayList<>();
    extIds.add(extUser);
    for (AccountExternalIdCreator c : externalIdCreators) {
        extIds.addAll(c.create(id, username, input.email));
    }
    ExternalIdsUpdate externalIdsUpdate = externalIdsUpdateFactory.create();
    try {
        externalIdsUpdate.insert(extIds);
    } catch (OrmDuplicateKeyException duplicateKey) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        try {
            externalIdsUpdate.insert(ExternalId.createEmail(id, input.email));
        } catch (OrmDuplicateKeyException duplicateKey) {
            try {
                externalIdsUpdate.delete(extUser);
            } catch (IOException | ConfigInvalidException cleanupError) {
            // Ignored
            }
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
    }
    accountsUpdate.create().insert(id, a -> {
        a.setFullName(input.name);
        a.setPreferredEmail(input.email);
    });
    for (AccountGroup.UUID groupUuid : groups) {
        try {
            addGroupMember(groupUuid, id);
        } catch (NoSuchGroupException e) {
            throw new UnprocessableEntityException(String.format("Group %s not found", groupUuid));
        }
    }
    if (input.sshKey != null) {
        try {
            authorizedKeys.addKey(id, input.sshKey);
            sshKeyCache.evict(username);
        } catch (InvalidSshKeyException e) {
            throw new BadRequestException(e.getMessage());
        }
    }
    AccountLoader loader = infoLoader.create(true);
    AccountInfo info = loader.get(id);
    loader.fill();
    return Response.created(info);
}
#method_after
public Response<AccountInfo> apply(AccountInput input) throws BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (input.username != null && !username.equals(input.username)) {
        throw new BadRequestException("username must match URL");
    }
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw new BadRequestException("Username '" + username + "' must contain only letters, numbers, _, - or .");
    }
    Set<AccountGroup.UUID> groups = parseGroups(input.groups);
    Account.Id id = new Account.Id(seq.nextAccountId());
    List<ExternalId> extIds = new ArrayList<>();
    if (input.email != null) {
        if (!validator.isValid(input.email)) {
            throw new BadRequestException("invalid email address");
        }
        extIds.add(ExternalId.createEmail(id, input.email));
    }
    extIds.add(ExternalId.createUsername(username, id, input.httpPassword));
    for (AccountExternalIdCreator c : externalIdCreators) {
        extIds.addAll(c.create(id, username, input.email));
    }
    try {
        accountsUpdate.create().insert("Create Account via API", id, u -> u.setFullName(input.name).setPreferredEmail(input.email).addExternalIds(extIds));
    } catch (DuplicateExternalIdKeyException e) {
        if (e.getDuplicateKey().isScheme(SCHEME_USERNAME)) {
            throw new ResourceConflictException("username '" + e.getDuplicateKey().id() + "' already exists");
        } else if (e.getDuplicateKey().isScheme(SCHEME_MAILTO)) {
            throw new UnprocessableEntityException("email '" + e.getDuplicateKey().id() + "' already exists");
        } else {
            // AccountExternalIdCreator returned an external ID that already exists
            throw e;
        }
    }
    for (AccountGroup.UUID groupUuid : groups) {
        try {
            addGroupMember(groupUuid, id);
        } catch (NoSuchGroupException e) {
            throw new UnprocessableEntityException(String.format("Group %s not found", groupUuid));
        }
    }
    if (input.sshKey != null) {
        try {
            authorizedKeys.addKey(id, input.sshKey);
            sshKeyCache.evict(username);
        } catch (InvalidSshKeyException e) {
            throw new BadRequestException(e.getMessage());
        }
    }
    AccountLoader loader = infoLoader.create(true);
    AccountInfo info = loader.get(id);
    loader.fill();
    return Response.created(info);
}
#end_block

#method_before
public Response<String> apply(IdentifiedUser user, String email) throws ResourceNotFoundException, IOException, ConfigInvalidException {
    AtomicBoolean alreadyPreferred = new AtomicBoolean(false);
    Account account = accountsUpdate.create().update(user.getAccountId(), a -> {
        if (email.equals(a.getPreferredEmail())) {
            alreadyPreferred.set(true);
        } else {
            a.setPreferredEmail(email);
        }
    });
    if (account == null) {
        throw new ResourceNotFoundException("account not found");
    }
    return alreadyPreferred.get() ? Response.ok("") : Response.created("");
}
#method_after
public Response<String> apply(IdentifiedUser user, String email) throws ResourceNotFoundException, IOException, ConfigInvalidException, OrmException {
    AtomicBoolean alreadyPreferred = new AtomicBoolean(false);
    Account account = accountsUpdate.create().update("Set Preferred Email via API", user.getAccountId(), (a, u) -> {
        if (email.equals(a.getPreferredEmail())) {
            alreadyPreferred.set(true);
        } else {
            u.setPreferredEmail(email);
        }
    });
    if (account == null) {
        throw new ResourceNotFoundException("account not found");
    }
    return alreadyPreferred.get() ? Response.ok("") : Response.created("");
}
#end_block

#method_before
@Override
public String apply(AccountResource rsrc, UsernameInput input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, ResourceConflictException, OrmException, IOException, ConfigInvalidException, PermissionBackendException {
    if (self.get() != rsrc.getUser()) {
        permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER);
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME)) {
        throw new MethodNotAllowedException("realm does not allow editing username");
    }
    if (input == null) {
        input = new UsernameInput();
    }
    try {
        changeUserNameFactory.create(rsrc.getUser(), input.username).call();
    } catch (IllegalStateException e) {
        if (ChangeUserName.USERNAME_CANNOT_BE_CHANGED.equals(e.getMessage())) {
            throw new MethodNotAllowedException(e.getMessage());
        }
        throw e;
    } catch (InvalidUserNameException e) {
        throw new UnprocessableEntityException("invalid username");
    } catch (NameAlreadyUsedException e) {
        throw new ResourceConflictException("username already used");
    }
    return input.username;
}
#method_after
@Override
public String apply(AccountResource rsrc, UsernameInput input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, ResourceConflictException, OrmException, IOException, ConfigInvalidException, PermissionBackendException {
    if (self.get() != rsrc.getUser()) {
        permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER);
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME)) {
        throw new MethodNotAllowedException("realm does not allow editing username");
    }
    if (input == null) {
        input = new UsernameInput();
    }
    try {
        changeUserNameFactory.create("Set Username via API", rsrc.getUser(), input.username).call();
    } catch (IllegalStateException e) {
        if (ChangeUserName.USERNAME_CANNOT_BE_CHANGED.equals(e.getMessage())) {
            throw new MethodNotAllowedException(e.getMessage());
        }
        throw e;
    } catch (InvalidUserNameException e) {
        throw new UnprocessableEntityException("invalid username");
    } catch (NameAlreadyUsedException e) {
        throw new ResourceConflictException("username already used");
    }
    return input.username;
}
#end_block

#method_before
private void assertChangeUpToDate(boolean expected, Change.Id id) throws Exception {
    try (Repository repo = repoManager.openRepository(project)) {
        Change c = getUnwrappedDb().changes().get(id);
        assertThat(c).isNotNull();
        assertThat(c.getNoteDbState()).isNotNull();
        assertThat(NoteDbChangeState.parse(c).isChangeUpToDate(new RepoRefCache(repo))).isEqualTo(expected);
    }
}
#method_after
private void assertChangeUpToDate(boolean expected, Change.Id id) throws Exception {
    try (Repository repo = repoManager.openRepository(project)) {
        Change c = getUnwrappedDb().changes().get(id);
        assertThat(c).isNotNull();
        assertThat(c.getNoteDbState()).isNotNull();
        NoteDbChangeState state = NoteDbChangeState.parse(c);
        assertThat(state).isNotNull();
        assertThat(state.getPrimaryStorage()).isEqualTo(PrimaryStorage.REVIEW_DB);
        assertThat(state.isChangeUpToDate(new RepoRefCache(repo))).isEqualTo(expected);
    }
}
#end_block

#method_before
public Response<String> apply(IdentifiedUser user, StatusInput input) throws ResourceNotFoundException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new StatusInput();
    }
    String newStatus = input.status;
    Account account = accountsUpdate.create().update(user.getAccountId(), a -> a.setStatus(Strings.nullToEmpty(newStatus)));
    if (account == null) {
        throw new ResourceNotFoundException("account not found");
    }
    return Strings.isNullOrEmpty(account.getStatus()) ? Response.none() : Response.ok(account.getStatus());
}
#method_after
public Response<String> apply(IdentifiedUser user, StatusInput input) throws ResourceNotFoundException, IOException, ConfigInvalidException, OrmException {
    if (input == null) {
        input = new StatusInput();
    }
    String newStatus = input.status;
    Account account = accountsUpdate.create().update("Set Status via API", user.getAccountId(), u -> u.setStatus(newStatus));
    if (account == null) {
        throw new ResourceNotFoundException("account not found");
    }
    return Strings.isNullOrEmpty(account.getStatus()) ? Response.none() : Response.ok(account.getStatus());
}
#end_block

#method_before
private GeneralPreferencesInfo writeToGit(GeneralPreferencesInfo i) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName)) {
        VersionedAccountPreferences p = VersionedAccountPreferences.forDefault();
        p.load(md);
        storeSection(p.getConfig(), UserConfigSections.GENERAL, null, i, GeneralPreferencesInfo.defaults());
        com.google.gerrit.server.restapi.account.SetPreferences.storeMyMenus(p, i.my);
        com.google.gerrit.server.restapi.account.SetPreferences.storeUrlAliases(p, i.urlAliases);
        p.commit(md);
        accountCache.evictAllNoReindex();
        GeneralPreferencesInfo r = loadSection(p.getConfig(), UserConfigSections.GENERAL, null, new GeneralPreferencesInfo(), GeneralPreferencesInfo.defaults(), null);
        return loader.loadMyMenusAndUrlAliases(r, p, null);
    }
}
#method_after
private GeneralPreferencesInfo writeToGit(GeneralPreferencesInfo i) throws RepositoryNotFoundException, IOException, ConfigInvalidException, BadRequestException {
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName)) {
        VersionedAccountPreferences p = VersionedAccountPreferences.forDefault();
        p.load(md);
        storeSection(p.getConfig(), UserConfigSections.GENERAL, null, i, GeneralPreferencesInfo.defaults());
        com.google.gerrit.server.restapi.account.SetPreferences.storeMyMenus(p, i.my);
        com.google.gerrit.server.restapi.account.SetPreferences.storeUrlAliases(p, i.urlAliases);
        p.commit(md);
        accountCache.evictAllNoReindex();
        GeneralPreferencesInfo r = loadSection(p.getConfig(), UserConfigSections.GENERAL, null, new GeneralPreferencesInfo(), GeneralPreferencesInfo.defaults(), null);
        return loader.loadMyMenusAndUrlAliases(r, p, null);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(RevisionReviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Fixes.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FIX_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(ChangeIncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "robotcomments").to(ListChangeRobotComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    get(CHANGE_KIND, "pure_revert").to(GetPureRevert.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "private").to(PostPrivate.class);
    post(CHANGE_KIND, "private.delete").to(DeletePrivateByPost.class);
    delete(CHANGE_KIND, "private").to(DeletePrivate.class);
    put(CHANGE_KIND, "ignore").to(Ignore.class);
    put(CHANGE_KIND, "unignore").to(Unignore.class);
    put(CHANGE_KIND, "reviewed").to(MarkAsReviewed.class);
    put(CHANGE_KIND, "unreviewed").to(MarkAsUnreviewed.class);
    post(CHANGE_KIND, "wip").to(SetWorkInProgress.class);
    post(CHANGE_KIND, "ready").to(SetReadyForReview.class);
    put(CHANGE_KIND, "message").to(PutMessage.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    put(REVISION_KIND, "description").to(PutDescription.class);
    get(REVISION_KIND, "description").to(GetDescription.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "reviewers").to(RevisionReviewers.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    delete(COMMENT_KIND).to(DeleteComment.class);
    post(COMMENT_KIND, "delete").to(DeleteComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "fixes").to(Fixes.class);
    post(FIX_KIND, "apply").to(ApplyFix.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    post(COMMIT_KIND, "cherrypick").to(CherryPickCommit.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(ChangeResource.Factory.class);
    factory(DeleteReviewerByEmailOp.Factory.class);
    factory(DeleteReviewerOp.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(PostReviewersOp.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(WorkInProgressOp.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(RevisionReviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Fixes.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FIX_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(ChangeIncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "robotcomments").to(ListChangeRobotComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    get(CHANGE_KIND, "pure_revert").to(GetPureRevert.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "private").to(PostPrivate.class);
    post(CHANGE_KIND, "private.delete").to(DeletePrivateByPost.class);
    delete(CHANGE_KIND, "private").to(DeletePrivate.class);
    put(CHANGE_KIND, "ignore").to(Ignore.class);
    put(CHANGE_KIND, "unignore").to(Unignore.class);
    put(CHANGE_KIND, "reviewed").to(MarkAsReviewed.class);
    put(CHANGE_KIND, "unreviewed").to(MarkAsUnreviewed.class);
    post(CHANGE_KIND, "wip").to(SetWorkInProgress.class);
    post(CHANGE_KIND, "ready").to(SetReadyForReview.class);
    put(CHANGE_KIND, "message").to(PutMessage.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    put(REVISION_KIND, "description").to(PutDescription.class);
    get(REVISION_KIND, "description").to(GetDescription.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "reviewers").to(RevisionReviewers.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    delete(COMMENT_KIND).to(DeleteComment.class);
    post(COMMENT_KIND, "delete").to(DeleteComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "fixes").to(Fixes.class);
    post(FIX_KIND, "apply").to(ApplyFix.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    post(COMMIT_KIND, "cherrypick").to(CherryPickCommit.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(ChangeResource.Factory.class);
    factory(DeleteReviewerByEmailOp.Factory.class);
    factory(DeleteReviewerOp.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(PostReviewersOp.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(SetPrivateOp.Factory.class);
    factory(WorkInProgressOp.Factory.class);
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) {
    if (workInProgress || notify.ordinal() < NotifyHandling.OWNER_REVIEWERS.ordinal()) {
        return;
    }
    email.create(notify, ImmutableListMultimap.of(), notes, ps, ctx.getIdentifiedUser(), cmsg, ImmutableList.of(), cmsg.getMessage(), ImmutableList.of()).sendAsync();
}
#method_after
@Override
public void postUpdate(Context ctx) {
    stateChanged.fire(change, ctx.getAccount(), ctx.getWhen());
    if (workInProgress || notify.ordinal() < NotifyHandling.OWNER_REVIEWERS.ordinal()) {
        return;
    }
    email.create(notify, ImmutableListMultimap.of(), notes, ps, ctx.getIdentifiedUser(), cmsg, ImmutableList.of(), cmsg.getMessage(), ImmutableList.of()).sendAsync();
}
#end_block

#method_before
@Override
protected Response<String> applyImpl(BatchUpdate.Factory updateFactory, ChangeResource rsrc, SetPrivateOp.Input input) throws RestApiException, UpdateException {
    if (!canDeletePrivate(rsrc).value()) {
        throw new AuthException("not allowed to unmark private");
    }
    if (!rsrc.getChange().isPrivate()) {
        throw new ResourceConflictException("change is not private");
    }
    SetPrivateOp op = new SetPrivateOp(cmUtil, false, input);
    try (BatchUpdate u = updateFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        u.addOp(rsrc.getId(), op).execute();
    }
    return Response.none();
}
#method_after
@Override
protected Response<String> applyImpl(BatchUpdate.Factory updateFactory, ChangeResource rsrc, SetPrivateOp.Input input) throws RestApiException, UpdateException {
    if (!canDeletePrivate(rsrc).value()) {
        throw new AuthException("not allowed to unmark private");
    }
    if (!rsrc.getChange().isPrivate()) {
        throw new ResourceConflictException("change is not private");
    }
    SetPrivateOp op = setPrivateOpFactory.create(cmUtil, false, input);
    try (BatchUpdate u = updateFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        u.addOp(rsrc.getId(), op).execute();
    }
    return Response.none();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountCacheImpl.module());
    install(BatchUpdate.module());
    install(ChangeKindCacheImpl.module());
    install(ChangeFinder.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new ExternalIdModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new ReceiveCommitsModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(ChangeData.AssistedFactory.class);
    factory(ChangeJson.AssistedFactory.class);
    factory(CreateChangeSender.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(SetAssigneeSender.Factory.class);
    factory(VisibleRefFilter.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    factory(SubmitRuleEvaluator.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(AccountDeactivator.class);
    bind(ApprovalsUtil.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    bind(UiActions.class);
    install(new com.google.gerrit.server.restapi.access.Module());
    install(new ConfigRestModule());
    install(new com.google.gerrit.server.restapi.change.Module());
    install(new com.google.gerrit.server.group.Module(groupsMigration));
    install(new com.google.gerrit.server.restapi.account.Module());
    install(new com.google.gerrit.server.restapi.project.Module());
    install(new com.google.gerrit.server.restapi.group.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), AssigneeChangedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    bind(ChangeMergedListener.class).annotatedWith(Exports.named("CreateGroupPermissionSyncer")).to(CreateGroupPermissionSyncer.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), AccountIndexedListener.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), GroupIndexedListener.class);
    DynamicSet.setOf(binder(), ProjectIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterRefUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), ChangeMessageModifier.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), OnSubmitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ReviewerSuggestion.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), ParentWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicSet.setOf(binder(), TagWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    DynamicSet.setOf(binder(), AssigneeValidationListener.class);
    DynamicSet.setOf(binder(), ActionVisitor.class);
    DynamicItem.itemOf(binder(), MergeSuperSetComputation.class);
    DynamicItem.itemOf(binder(), ProjectNameLockManager.class);
    DynamicMap.mapOf(binder(), MailFilter.class);
    bind(MailFilter.class).annotatedWith(Exports.named("ListMailFilter")).to(ListMailFilter.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeHasOperandFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryProcessor.ChangeAttributeFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(AbandonOp.Factory.class);
    factory(AccountMergeValidator.Factory.class);
    factory(GroupMergeValidator.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(OnSubmitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountCacheImpl.module());
    install(BatchUpdate.module());
    install(ChangeKindCacheImpl.module());
    install(ChangeFinder.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new ExternalIdModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new ReceiveCommitsModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(ChangeData.AssistedFactory.class);
    factory(ChangeJson.AssistedFactory.class);
    factory(CreateChangeSender.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(SetAssigneeSender.Factory.class);
    factory(VisibleRefFilter.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    factory(SubmitRuleEvaluator.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(AccountDeactivator.class);
    bind(ApprovalsUtil.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    bind(UiActions.class);
    install(new com.google.gerrit.server.restapi.access.Module());
    install(new ConfigRestModule());
    install(new com.google.gerrit.server.restapi.change.Module());
    install(new com.google.gerrit.server.group.Module(groupsMigration));
    install(new com.google.gerrit.server.restapi.account.Module());
    install(new com.google.gerrit.server.restapi.project.Module());
    install(new com.google.gerrit.server.restapi.group.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), AssigneeChangedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    bind(ChangeMergedListener.class).annotatedWith(Exports.named("CreateGroupPermissionSyncer")).to(CreateGroupPermissionSyncer.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), PrivateStateChangedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), WorkInProgressStateChangedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), AccountIndexedListener.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), GroupIndexedListener.class);
    DynamicSet.setOf(binder(), ProjectIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterRefUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), ChangeMessageModifier.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), OnSubmitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ReviewerSuggestion.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), ParentWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicSet.setOf(binder(), TagWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    DynamicSet.setOf(binder(), AssigneeValidationListener.class);
    DynamicSet.setOf(binder(), ActionVisitor.class);
    DynamicItem.itemOf(binder(), MergeSuperSetComputation.class);
    DynamicItem.itemOf(binder(), ProjectNameLockManager.class);
    DynamicMap.mapOf(binder(), MailFilter.class);
    bind(MailFilter.class).annotatedWith(Exports.named("ListMailFilter")).to(ListMailFilter.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeHasOperandFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryProcessor.ChangeAttributeFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(AbandonOp.Factory.class);
    factory(AccountMergeValidator.Factory.class);
    factory(GroupMergeValidator.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(OnSubmitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
private ChangeConfigInfo getChangeInfo(Config cfg) {
    ChangeConfigInfo info = new ChangeConfigInfo();
    info.allowBlame = toBoolean(cfg.getBoolean("change", "allowBlame", true));
    info.allowDrafts = toBoolean(cfg.getBoolean("change", "allowDrafts", true));
    boolean hasAssigneeInIndex = indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE);
    info.showAssigneeInChangesTable = toBoolean(cfg.getBoolean("change", "showAssigneeInChangesTable", false) && hasAssigneeInIndex);
    info.largeChange = cfg.getInt("change", "largeChange", 500);
    info.privateByDefault = toBoolean(cfg.getBoolean("change", "privateByDefault", false));
    info.replyTooltip = Optional.ofNullable(cfg.getString("change", null, "replyTooltip")).orElse("Reply and score") + " (Shortcut: a)";
    info.replyLabel = Optional.ofNullable(cfg.getString("change", null, "replyLabel")).orElse("Reply") + "\u2026";
    info.updateDelay = (int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 300, TimeUnit.SECONDS);
    info.submitWholeTopic = MergeSuperSet.wholeTopicEnabled(cfg);
    return info;
}
#method_after
private ChangeConfigInfo getChangeInfo(Config cfg) {
    ChangeConfigInfo info = new ChangeConfigInfo();
    info.allowBlame = toBoolean(cfg.getBoolean("change", "allowBlame", true));
    info.allowDrafts = toBoolean(cfg.getBoolean("change", "allowDrafts", true));
    boolean hasAssigneeInIndex = indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE);
    info.showAssigneeInChangesTable = toBoolean(cfg.getBoolean("change", "showAssigneeInChangesTable", false) && hasAssigneeInIndex);
    info.largeChange = cfg.getInt("change", "largeChange", 500);
    info.replyTooltip = Optional.ofNullable(cfg.getString("change", null, "replyTooltip")).orElse("Reply and score") + " (Shortcut: a)";
    info.replyLabel = Optional.ofNullable(cfg.getString("change", null, "replyLabel")).orElse("Reply") + "\u2026";
    info.updateDelay = (int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 300, TimeUnit.SECONDS);
    info.submitWholeTopic = MergeSuperSet.wholeTopicEnabled(cfg);
    return info;
}
#end_block

#method_before
@Override
public Response<String> applyImpl(BatchUpdate.Factory updateFactory, ChangeResource rsrc, SetPrivateOp.Input input) throws RestApiException, UpdateException {
    if (!canSetPrivate(rsrc).value()) {
        throw new AuthException("not allowed to mark private");
    }
    if (rsrc.getChange().isPrivate()) {
        return Response.ok("");
    }
    SetPrivateOp op = new SetPrivateOp(cmUtil, true, input);
    try (BatchUpdate u = updateFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        u.addOp(rsrc.getId(), op).execute();
    }
    return Response.created("");
}
#method_after
@Override
public Response<String> applyImpl(BatchUpdate.Factory updateFactory, ChangeResource rsrc, SetPrivateOp.Input input) throws RestApiException, UpdateException {
    if (!canSetPrivate(rsrc).value()) {
        throw new AuthException("not allowed to mark private");
    }
    if (rsrc.getChange().isPrivate()) {
        return Response.ok("");
    }
    SetPrivateOp op = setPrivateOpFactory.create(cmUtil, true, input);
    try (BatchUpdate u = updateFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        u.addOp(rsrc.getId(), op).execute();
    }
    return Response.created("");
}
#end_block

#method_before
private void writeToGit(Account.Id id, GeneralPreferencesInfo i) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    VersionedAccountPreferences prefs;
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName)) {
        prefs = VersionedAccountPreferences.forUser(id);
        prefs.load(md);
        storeSection(prefs.getConfig(), UserConfigSections.GENERAL, null, i, loader.readDefaultsFromGit(md.getRepository(), null));
        storeMyChangeTableColumns(prefs, i.changeTable);
        storeMyMenus(prefs, i.my);
        storeUrlAliases(prefs, i.urlAliases);
        prefs.commit(md);
        cache.evict(id);
    }
}
#method_after
private void writeToGit(Account.Id id, GeneralPreferencesInfo i) throws RepositoryNotFoundException, IOException, ConfigInvalidException, BadRequestException {
    VersionedAccountPreferences prefs;
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName)) {
        prefs = VersionedAccountPreferences.forUser(id);
        prefs.load(md);
        storeSection(prefs.getConfig(), UserConfigSections.GENERAL, null, i, loader.readDefaultsFromGit(md.getRepository(), null));
        storeMyChangeTableColumns(prefs, i.changeTable);
        storeMyMenus(prefs, i.my);
        storeUrlAliases(prefs, i.urlAliases);
        prefs.commit(md);
        cache.evict(id);
    }
}
#end_block

#method_before
public static void storeMyMenus(VersionedAccountPreferences prefs, List<MenuItem> my) {
    Config cfg = prefs.getConfig();
    if (my != null) {
        unsetSection(cfg, UserConfigSections.MY);
        for (MenuItem item : my) {
            set(cfg, item.name, KEY_URL, item.url);
            set(cfg, item.name, KEY_TARGET, item.target);
            set(cfg, item.name, KEY_ID, item.id);
        }
    }
}
#method_after
public static void storeMyMenus(VersionedAccountPreferences prefs, List<MenuItem> my) throws BadRequestException {
    Config cfg = prefs.getConfig();
    if (my != null) {
        unsetSection(cfg, UserConfigSections.MY);
        for (MenuItem item : my) {
            checkRequiredMenuItemField(item.name, "name");
            checkRequiredMenuItemField(item.url, "URL");
            set(cfg, item.name, KEY_URL, item.url);
            set(cfg, item.name, KEY_TARGET, item.target);
            set(cfg, item.name, KEY_ID, item.id);
        }
    }
}
#end_block

#method_before
private static void set(Config cfg, String section, String key, String val) {
    if (Strings.isNullOrEmpty(val)) {
        cfg.unset(UserConfigSections.MY, section, key);
    } else {
        cfg.setString(UserConfigSections.MY, section, key, val);
    }
}
#method_after
private static void set(Config cfg, String section, String key, @Nullable String val) {
    if (val == null || val.trim().isEmpty()) {
        cfg.unset(UserConfigSections.MY, section.trim(), key);
    } else {
        cfg.setString(UserConfigSections.MY, section.trim(), key, val.trim());
    }
}
#end_block

#method_before
@Override
public ChangeResource parse(TopLevelResource root, IdString id) throws ResourceNotFoundException, OrmException, PermissionBackendException {
    List<ChangeNotes> notes = changeFinder.find(id.encoded());
    if (notes.isEmpty()) {
        throw new ResourceNotFoundException(id);
    } else if (notes.size() != 1) {
        throw new ResourceNotFoundException("Multiple changes found for " + id);
    }
    ChangeNotes change = notes.get(0);
    if (!canRead(change)) {
        throw new ResourceNotFoundException(id);
    }
    return changeResourceFactory.create(change, user.get());
}
#method_after
@Override
public ChangeResource parse(TopLevelResource root, IdString id) throws RestApiException, OrmException, PermissionBackendException {
    List<ChangeNotes> notes = changeFinder.find(id.encoded(), true);
    if (notes.isEmpty()) {
        throw new ResourceNotFoundException(id);
    } else if (notes.size() != 1) {
        throw new ResourceNotFoundException("Multiple changes found for " + id);
    }
    ChangeNotes change = notes.get(0);
    if (!canRead(change)) {
        throw new ResourceNotFoundException(id);
    }
    return changeResourceFactory.create(change, user.get());
}
#end_block

#method_before
private List<ChangeAndCommit> getRelated(RevisionResource rsrc) throws OrmException, IOException, PermissionBackendException {
    Set<String> groups = getAllGroups(rsrc.getNotes());
    if (groups.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeData> cds = queryProvider.get().enforceVisibility(true).byProjectGroups(rsrc.getChange().getProject(), groups);
    if (cds.isEmpty()) {
        return Collections.emptyList();
    }
    if (cds.size() == 1 && cds.get(0).getId().equals(rsrc.getChange().getId())) {
        return Collections.emptyList();
    }
    List<ChangeAndCommit> result = new ArrayList<>(cds.size());
    boolean isEdit = rsrc.getEdit().isPresent();
    PatchSet basePs = isEdit ? rsrc.getEdit().get().getBasePatchSet() : rsrc.getPatchSet();
    reloadChangeIfStale(cds, basePs);
    for (RelatedChangesSorter.PatchSetData d : sorter.sort(cds, basePs, rsrc.getUser())) {
        PatchSet ps = d.patchSet();
        RevCommit commit;
        if (isEdit && ps.getId().equals(basePs.getId())) {
            // Replace base of an edit with the edit itself.
            ps = rsrc.getPatchSet();
            commit = rsrc.getEdit().get().getEditCommit();
        } else {
            commit = d.commit();
        }
        result.add(new ChangeAndCommit(rsrc.getProject(), d.data().change(), ps, commit));
    }
    if (result.size() == 1) {
        ChangeAndCommit r = result.get(0);
        if (r.commit != null && r.commit.commit.equals(rsrc.getPatchSet().getRevision().get())) {
            return Collections.emptyList();
        }
    }
    return result;
}
#method_after
private List<ChangeAndCommit> getRelated(RevisionResource rsrc) throws OrmException, IOException, PermissionBackendException {
    Set<String> groups = getAllGroups(rsrc.getNotes(), db.get(), psUtil);
    if (groups.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeData> cds = InternalChangeQuery.byProjectGroups(queryProvider, indexConfig, rsrc.getChange().getProject(), groups);
    if (cds.isEmpty()) {
        return Collections.emptyList();
    }
    if (cds.size() == 1 && cds.get(0).getId().equals(rsrc.getChange().getId())) {
        return Collections.emptyList();
    }
    List<ChangeAndCommit> result = new ArrayList<>(cds.size());
    boolean isEdit = rsrc.getEdit().isPresent();
    PatchSet basePs = isEdit ? rsrc.getEdit().get().getBasePatchSet() : rsrc.getPatchSet();
    reloadChangeIfStale(cds, basePs);
    for (RelatedChangesSorter.PatchSetData d : sorter.sort(cds, basePs, rsrc.getUser())) {
        PatchSet ps = d.patchSet();
        RevCommit commit;
        if (isEdit && ps.getId().equals(basePs.getId())) {
            // Replace base of an edit with the edit itself.
            ps = rsrc.getPatchSet();
            commit = rsrc.getEdit().get().getEditCommit();
        } else {
            commit = d.commit();
        }
        result.add(new ChangeAndCommit(rsrc.getProject(), d.data().change(), ps, commit));
    }
    if (result.size() == 1) {
        ChangeAndCommit r = result.get(0);
        if (r.commit != null && r.commit.commit.equals(rsrc.getPatchSet().getRevision().get())) {
            return Collections.emptyList();
        }
    }
    return result;
}
#end_block

#method_before
private Set<String> getAllGroups(ChangeNotes notes) throws OrmException {
    Set<String> result = new HashSet<>();
    for (PatchSet ps : psUtil.byChange(db.get(), notes)) {
        result.addAll(ps.getGroups());
    }
    return result;
}
#method_after
@VisibleForTesting
public static Set<String> getAllGroups(ChangeNotes notes, ReviewDb db, PatchSetUtil psUtil) throws OrmException {
    return psUtil.byChange(db, notes).stream().flatMap(ps -> ps.getGroups().stream()).collect(toSet());
}
#end_block

#method_before
public List<SuggestedReviewerInfo> suggestReviewers(ChangeNotes changeNotes, SuggestReviewers suggestReviewers, ProjectState projectState, VisibilityControl visibilityControl, boolean excludeGroups) throws IOException, OrmException, ConfigInvalidException {
    String query = suggestReviewers.getQuery();
    int limit = suggestReviewers.getLimit();
    if (!suggestReviewers.getSuggestAccounts()) {
        return Collections.emptyList();
    }
    List<Account.Id> candidateList = new ArrayList<>();
    if (!Strings.isNullOrEmpty(query)) {
        candidateList = suggestAccounts(suggestReviewers);
    }
    List<Account.Id> sortedRecommendations = recommendAccounts(changeNotes, suggestReviewers, projectState, candidateList);
    // Filter accounts by visibility and enforce limit
    List<Account.Id> filteredRecommendations = new ArrayList<>();
    try (Timer0.Context ctx = metrics.filterVisibility.start()) {
        for (Account.Id reviewer : sortedRecommendations) {
            if (filteredRecommendations.size() >= limit) {
                break;
            }
            if (visibilityControl.isVisibleTo(reviewer)) {
                filteredRecommendations.add(reviewer);
            }
        }
    }
    List<SuggestedReviewerInfo> suggestedReviewer = loadAccounts(filteredRecommendations);
    if (!excludeGroups && suggestedReviewer.size() < limit && !Strings.isNullOrEmpty(query)) {
        // Add groups at the end as individual accounts are usually more
        // important.
        suggestedReviewer.addAll(suggestAccountGroups(suggestReviewers, projectState, visibilityControl, limit - suggestedReviewer.size()));
    }
    if (suggestedReviewer.size() <= limit) {
        return suggestedReviewer;
    }
    return suggestedReviewer.subList(0, limit);
}
#method_after
public List<SuggestedReviewerInfo> suggestReviewers(ChangeNotes changeNotes, SuggestReviewers suggestReviewers, ProjectState projectState, VisibilityControl visibilityControl, boolean excludeGroups) throws IOException, OrmException, ConfigInvalidException {
    String query = suggestReviewers.getQuery();
    int limit = suggestReviewers.getLimit();
    if (!suggestReviewers.getSuggestAccounts()) {
        return Collections.emptyList();
    }
    List<Account.Id> candidateList = new ArrayList<>();
    if (!Strings.isNullOrEmpty(query)) {
        candidateList = suggestAccounts(suggestReviewers);
    }
    List<Account.Id> sortedRecommendations = recommendAccounts(changeNotes, suggestReviewers, projectState, candidateList);
    // Filter accounts by visibility and enforce limit
    List<Account.Id> filteredRecommendations = new ArrayList<>();
    try (Timer0.Context ctx = metrics.filterVisibility.start()) {
        for (Account.Id reviewer : sortedRecommendations) {
            if (filteredRecommendations.size() >= limit) {
                break;
            }
            // Check if change is visible to reviewer and if the current user can see reviewer
            if (visibilityControl.isVisibleTo(reviewer) && accountControlFactory.get().canSee(reviewer)) {
                filteredRecommendations.add(reviewer);
            }
        }
    }
    List<SuggestedReviewerInfo> suggestedReviewer = loadAccounts(filteredRecommendations);
    if (!excludeGroups && suggestedReviewer.size() < limit && !Strings.isNullOrEmpty(query)) {
        // Add groups at the end as individual accounts are usually more
        // important.
        suggestedReviewer.addAll(suggestAccountGroups(suggestReviewers, projectState, visibilityControl, limit - suggestedReviewer.size()));
    }
    if (suggestedReviewer.size() <= limit) {
        return suggestedReviewer;
    }
    return suggestedReviewer.subList(0, limit);
}
#end_block

#method_before
private List<Account.Id> suggestAccounts(SuggestReviewers suggestReviewers) throws OrmException {
    try (Timer0.Context ctx = metrics.queryAccountsLatency.start()) {
        try {
            QueryResult<AccountState> result = queryProvider.get().setUserProvidedLimit(suggestReviewers.getLimit() * CANDIDATE_LIST_MULTIPLIER).query(AccountPredicates.andActive(accountQueryBuilder.defaultQuery(suggestReviewers.getQuery())));
            return result.entities().stream().map(a -> a.getAccount().getId()).collect(toList());
        } catch (QueryParseException e) {
            return ImmutableList.of();
        }
    }
}
#method_after
private List<Account.Id> suggestAccounts(SuggestReviewers suggestReviewers) throws OrmException {
    try (Timer0.Context ctx = metrics.queryAccountsLatency.start()) {
        try {
            // For performance reasons we don't use AccountQueryProvider as it would always load the
            // complete account from the cache (or worse, from NoteDb) even though we only need the ID
            // which we can directly get from the returned results.
            ResultSet<FieldBundle> result = accountIndexes.getSearchIndex().getSource(Predicate.and(AccountPredicates.isActive(), accountQueryBuilder.defaultQuery(suggestReviewers.getQuery())), QueryOptions.create(indexConfig, 0, suggestReviewers.getLimit() * CANDIDATE_LIST_MULTIPLIER, ImmutableSet.of(AccountField.ID.getName()))).readRaw();
            return result.toList().stream().map(f -> new Account.Id(f.getValue(AccountField.ID).intValue())).collect(toList());
        } catch (QueryParseException e) {
            return ImmutableList.of();
        }
    }
}
#end_block

#method_before
@Override
public Star parse(AccountResource parent, IdString id) throws ResourceNotFoundException, OrmException, PermissionBackendException {
    IdentifiedUser user = parent.getUser();
    ChangeResource change = changes.parse(TopLevelResource.INSTANCE, id);
    Set<String> labels = starredChangesUtil.getLabels(user.getAccountId(), change.getId());
    return new AccountResource.Star(user, change, labels);
}
#method_after
@Override
public Star parse(AccountResource parent, IdString id) throws RestApiException, OrmException, PermissionBackendException {
    IdentifiedUser user = parent.getUser();
    ChangeResource change = changes.parse(TopLevelResource.INSTANCE, id);
    Set<String> labels = starredChangesUtil.getLabels(user.getAccountId(), change.getId());
    return new AccountResource.Star(user, change, labels);
}
#end_block

#method_before
@Override
public AccountResource.StarredChange parse(AccountResource parent, IdString id) throws ResourceNotFoundException, OrmException, PermissionBackendException {
    IdentifiedUser user = parent.getUser();
    ChangeResource change = changes.parse(TopLevelResource.INSTANCE, id);
    if (starredChangesUtil.getLabels(user.getAccountId(), change.getId()).contains(StarredChangesUtil.DEFAULT_LABEL)) {
        return new AccountResource.StarredChange(user, change);
    }
    throw new ResourceNotFoundException(id);
}
#method_after
@Override
public AccountResource.StarredChange parse(AccountResource parent, IdString id) throws RestApiException, OrmException, PermissionBackendException {
    IdentifiedUser user = parent.getUser();
    ChangeResource change = changes.parse(TopLevelResource.INSTANCE, id);
    if (starredChangesUtil.getLabels(user.getAccountId(), change.getId()).contains(StarredChangesUtil.DEFAULT_LABEL)) {
        return new AccountResource.StarredChange(user, change);
    }
    throw new ResourceNotFoundException(id);
}
#end_block

#method_before
@Override
public RestModifyView<AccountResource, EmptyInput> create(AccountResource parent, IdString id) throws UnprocessableEntityException {
    try {
        return createProvider.get().setChange(changes.parse(TopLevelResource.INSTANCE, id));
    } catch (ResourceNotFoundException e) {
        throw new UnprocessableEntityException(String.format("change %s not found", id.get()));
    } catch (OrmException | PermissionBackendException e) {
        log.error("cannot resolve change", e);
        throw new UnprocessableEntityException("internal server error");
    }
}
#method_after
@Override
public RestModifyView<AccountResource, EmptyInput> create(AccountResource parent, IdString id) throws RestApiException {
    try {
        return createProvider.get().setChange(changes.parse(TopLevelResource.INSTANCE, id));
    } catch (ResourceNotFoundException e) {
        throw new UnprocessableEntityException(String.format("change %s not found", id.get()));
    } catch (OrmException | PermissionBackendException e) {
        log.error("cannot resolve change", e);
        throw new UnprocessableEntityException("internal server error");
    }
}
#end_block

#method_before
public Response<String> apply(IdentifiedUser user, String newPassword) throws ResourceNotFoundException, ResourceConflictException, OrmException, IOException, ConfigInvalidException {
    if (user.getUserName() == null) {
        throw new ResourceConflictException("username must be set");
    }
    ExternalId extId = externalIds.get(ExternalId.Key.create(SCHEME_USERNAME, user.getUserName()));
    if (extId == null) {
        throw new ResourceNotFoundException();
    }
    ExternalId newExtId = ExternalId.createWithPassword(extId.key(), extId.accountId(), extId.email(), newPassword);
    externalIdsUpdate.create().upsert(newExtId);
    return Strings.isNullOrEmpty(newPassword) ? Response.<String>none() : Response.ok(newPassword);
}
#method_after
public Response<String> apply(IdentifiedUser user, String newPassword) throws ResourceNotFoundException, ResourceConflictException, OrmException, IOException, ConfigInvalidException {
    if (user.getUserName() == null) {
        throw new ResourceConflictException("username must be set");
    }
    ExternalId extId = externalIds.get(ExternalId.Key.create(SCHEME_USERNAME, user.getUserName()));
    if (extId == null) {
        throw new ResourceNotFoundException();
    }
    accountsUpdate.create().update("Set HTTP Password via API", extId.accountId(), u -> u.updateExternalId(ExternalId.createWithPassword(extId.key(), extId.accountId(), extId.email(), newPassword)));
    return Strings.isNullOrEmpty(newPassword) ? Response.<String>none() : Response.ok(newPassword);
}
#end_block

#method_before
@Test
public void unresolvedCommentsBlocked() throws Exception {
    modifySubmitRules("submit_rule(submit(R)) :- \n" + "gerrit:unresolved_comments_count(0), \n" + "!," + "gerrit:commit_author(A), \n" + "R = label('All-Comments-Resolved', ok(A)).\n" + "submit_rule(submit(R)) :- \n" + "gerrit:unresolved_comments_count(U), \n" + "U > 0," + "R = label('All-Comments-Resolved', need(_)). \n\n");
    String oldHead = getRemoteHead().name();
    PushOneCommit.Result result1 = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    testRepo.reset(oldHead);
    PushOneCommit.Result result2 = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    addComment(result1, "comment 1", true, false, null);
    addComment(result2, "comment 2", true, true, null);
    gApi.changes().id(result1.getChangeId()).current().submit();
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Failed to submit 1 change due to the following problems");
    exception.expectMessage("needs All-Comments-Resolved");
    gApi.changes().id(result2.getChangeId()).current().submit();
}
#method_after
@Test
public void unresolvedCommentsBlocked() throws Exception {
    modifySubmitRules("submit_rule(submit(R)) :- \n" + "gerrit:unresolved_comments_count(0), \n" + "!," + "gerrit:uploader(U), \n" + "R = label('All-Comments-Resolved', ok(U)).\n" + "submit_rule(submit(R)) :- \n" + "gerrit:unresolved_comments_count(U), \n" + "U > 0," + "R = label('All-Comments-Resolved', need(_)). \n\n");
    String oldHead = getRemoteHead().name();
    PushOneCommit.Result result1 = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    testRepo.reset(oldHead);
    PushOneCommit.Result result2 = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    addComment(result1, "comment 1", true, false, null);
    addComment(result2, "comment 2", true, true, null);
    gApi.changes().id(result1.getChangeId()).current().submit();
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Failed to submit 1 change due to the following problems");
    exception.expectMessage("needs All-Comments-Resolved");
    gApi.changes().id(result2.getChangeId()).current().submit();
}
#end_block

#method_before
private void addPureRevertSubmitRule() throws Exception {
    modifySubmitRules("submit_rule(submit(R)) :- \n" + "gerrit:pure_revert(1), \n" + "!," + "gerrit:commit_author(A), \n" + "R = label('Is-Pure-Revert', ok(A)).\n" + "submit_rule(submit(R)) :- \n" + "gerrit:pure_revert(U), \n" + "U \\= 1," + "R = label('Is-Pure-Revert', need(_)). \n\n");
}
#method_after
private void addPureRevertSubmitRule() throws Exception {
    modifySubmitRules("submit_rule(submit(R)) :- \n" + "gerrit:pure_revert(1), \n" + "!," + "gerrit:uploader(U), \n" + "R = label('Is-Pure-Revert', ok(U)).\n" + "submit_rule(submit(R)) :- \n" + "gerrit:pure_revert(U), \n" + "U \\= 1," + "R = label('Is-Pure-Revert', need(_)). \n\n");
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceConflictException, OrmException {
    Change change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    change.setPrivate(isPrivate);
    change.setLastUpdatedOn(ctx.getWhen());
    update.setPrivate(isPrivate);
    addMessage(ctx, update);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceConflictException, OrmException {
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    change.setPrivate(isPrivate);
    change.setLastUpdatedOn(ctx.getWhen());
    update.setPrivate(isPrivate);
    addMessage(ctx, update);
    return true;
}
#end_block

#method_before
public Response<String> apply(IdentifiedUser user, String email) throws RestApiException, IOException, ConfigInvalidException, OrmException {
    AtomicReference<Optional<RestApiException>> exception = new AtomicReference<>(Optional.empty());
    AtomicBoolean alreadyPreferred = new AtomicBoolean(false);
    accountsUpdateProvider.get().update("Set Preferred Email via API", user.getAccountId(), (a, u) -> {
        if (email.equals(a.getAccount().getPreferredEmail())) {
            alreadyPreferred.set(true);
        } else {
            if (ExternalId.getEmails(a.getExternalIds()).noneMatch(e -> e.equalsIgnoreCase(email))) {
                // user doesn't have an external ID for this email
                if (user.hasEmailAddress(email)) {
                    // but Realm says the user is allowed to use this email
                    if (!externalIds.byEmail(email).isEmpty()) {
                        // but the email is already assigned to another account
                        exception.set(Optional.of(new ResourceConflictException("email in use by another account")));
                    }
                    // claim the email now
                    u.addExternalId(ExternalId.createEmail(a.getAccount().getId(), email));
                } else {
                    // Realm says that the email doesn't belong to the user. This can only happen as
                    // a race condition because the EmailsCollection would have thrown
                    // ResourceNotFoundException already before invoking this REST endpoint.
                    exception.set(Optional.of(new ResourceNotFoundException(email)));
                }
            }
            u.setPreferredEmail(email);
        }
    }).orElseThrow(() -> new ResourceNotFoundException("account not found"));
    if (exception.get().isPresent()) {
        throw exception.get().get();
    }
    return alreadyPreferred.get() ? Response.ok("") : Response.created("");
}
#method_after
public Response<String> apply(IdentifiedUser user, String preferredEmail) throws RestApiException, IOException, ConfigInvalidException, OrmException {
    AtomicReference<Optional<RestApiException>> exception = new AtomicReference<>(Optional.empty());
    AtomicBoolean alreadyPreferred = new AtomicBoolean(false);
    accountsUpdateProvider.get().update("Set Preferred Email via API", user.getAccountId(), (a, u) -> {
        if (preferredEmail.equals(a.getAccount().getPreferredEmail())) {
            alreadyPreferred.set(true);
        } else {
            // check if the user has a matching email
            String matchingEmail = null;
            for (String email : a.getExternalIds().stream().map(ExternalId::email).filter(Objects::nonNull).collect(toSet())) {
                if (email.equals(preferredEmail)) {
                    // we have an email that matches exactly, prefer this one
                    matchingEmail = email;
                    break;
                } else if (matchingEmail == null && email.equalsIgnoreCase(preferredEmail)) {
                    // we found an email that matches but has a different case
                    matchingEmail = email;
                }
            }
            if (matchingEmail == null) {
                // user doesn't have an external ID for this email
                if (user.hasEmailAddress(preferredEmail)) {
                    // but Realm says the user is allowed to use this email
                    Set<ExternalId> existingExtIdsWithThisEmail = externalIds.byEmail(preferredEmail);
                    if (!existingExtIdsWithThisEmail.isEmpty()) {
                        // but the email is already assigned to another account
                        log.warn("Cannot set preferred email {} for account {} because it is owned" + " by the following account(s): {}", preferredEmail, user.getAccountId(), existingExtIdsWithThisEmail.stream().map(ExternalId::accountId).collect(toList()));
                        exception.set(Optional.of(new ResourceConflictException("email in use by another account")));
                        return;
                    }
                    // claim the email now
                    u.addExternalId(ExternalId.createEmail(a.getAccount().getId(), preferredEmail));
                    matchingEmail = preferredEmail;
                } else {
                    // Realm says that the email doesn't belong to the user. This can only happen as
                    // a race condition because EmailsCollection would have thrown
                    // ResourceNotFoundException already before invoking this REST endpoint.
                    exception.set(Optional.of(new ResourceNotFoundException(preferredEmail)));
                    return;
                }
            }
            u.setPreferredEmail(matchingEmail);
        }
    }).orElseThrow(() -> new ResourceNotFoundException("account not found"));
    if (exception.get().isPresent()) {
        throw exception.get().get();
    }
    return alreadyPreferred.get() ? Response.ok("") : Response.created("");
}
#end_block

#method_before
public void testGetItsProjectNull() {
    String[] branches = {};
    setupIsEnabled("true", null, null, branches);
    ItsConfig itsConfig = createItsConfig();
    replayMocks();
    assertNull(itsConfig.getItsProjectName(new Project.NameKey("testProject")).orElse(null));
}
#method_after
public void testGetItsProjectNull() {
    String[] branches = {};
    setupIsEnabled("true", null, null, branches);
    ItsConfig itsConfig = createItsConfig();
    replayMocks();
    assertFalse(itsConfig.getItsProjectName(new Project.NameKey("testProject")).isPresent());
}
#end_block

#method_before
public void testGetItsProjectConfigured() {
    String[] branches = {};
    setupIsEnabled("true", "itsProject", null, branches);
    ItsConfig itsConfig = createItsConfig();
    replayMocks();
    assertEquals("itsProject", itsConfig.getItsProjectName(new Project.NameKey("testProject")).orElse(null));
}
#method_after
public void testGetItsProjectConfigured() {
    String[] branches = {};
    setupIsEnabled("true", "itsProject", null, branches);
    ItsConfig itsConfig = createItsConfig();
    replayMocks();
    Optional<String> itsProjectName = itsConfig.getItsProjectName(new Project.NameKey("testProject"));
    assertTrue(itsProjectName.isPresent());
    assertEquals("itsProject", itsProjectName.get());
}
#end_block

#method_before
private ItsAction getAction(String actionName) {
    switch(actionName) {
        case "add-comment":
            return addCommentFactory.create();
        case "add-standard-comment":
            return addStandardCommentFactory.create();
        case "add-soy-comment":
            return addSoyCommentFactory.create();
        case "log-event":
            return logEventFactory.create();
        case "add-property-to-field":
            return addPropertyToFieldFactory.create();
        case "create-version-from-property":
            return createVersionFromPropertyFactory.create();
        default:
            return null;
    }
}
#method_after
private Action getAction(String actionName) {
    switch(actionName) {
        case "add-comment":
            return addCommentFactory.create();
        case "add-standard-comment":
            return addStandardCommentFactory.create();
        case "add-soy-comment":
            return addSoyCommentFactory.create();
        case "log-event":
            return logEventFactory.create();
        case "add-property-to-field":
            return addPropertyToFieldFactory.create();
        case "create-version-from-property":
            return createVersionFromPropertyFactory.create();
        default:
            return null;
    }
}
#end_block

#method_before
private void executeOnIssue(String issue, ActionRequest actionRequest, Map<String, String> properties) {
    ItsFacade its = itsFactory.getFacade(new Project.NameKey(properties.get("project")));
    try {
        ItsAction action = getAction(actionRequest.getName());
        if (action == null) {
            its.performAction(issue, actionRequest.getUnparsed());
        } else if (Action.class.isInstance(action)) {
            Action.class.cast(action).execute(its, issue, actionRequest, properties);
        }
    } catch (IOException e) {
        log.error("Error while executing action " + actionRequest, e);
    }
}
#method_after
private void executeOnIssue(String issue, ActionRequest actionRequest, Map<String, String> properties) {
    ItsFacade its = itsFactory.getFacade(new Project.NameKey(properties.get("project")));
    try {
        Action action = getAction(actionRequest.getName());
        if (action == null) {
            its.performAction(issue, actionRequest.getUnparsed());
        } else if (action.getType() == ActionType.ISSUE) {
            action.execute(its, issue, actionRequest, properties);
        }
    } catch (IOException e) {
        log.error("Error while executing action " + actionRequest, e);
    }
}
#end_block

#method_before
private void executeOnProject(String itsProject, ActionRequest actionRequest, Map<String, String> properties) {
    try {
        String actionName = actionRequest.getName();
        ItsAction action = getAction(actionName);
        if (action == null) {
            log.debug("No action found for name {}", actionName);
            return;
        }
        if (!ProjectAction.class.isInstance(action)) {
            return;
        }
        ItsFacade its = itsFactory.getFacade(new Project.NameKey(properties.get("project")));
        ProjectAction.class.cast(action).execute(its, itsProject, actionRequest, properties);
    } catch (IOException e) {
        log.error("Error while executing action " + actionRequest, e);
    }
}
#method_after
private void executeOnProject(String itsProject, ActionRequest actionRequest, Map<String, String> properties) {
    try {
        String actionName = actionRequest.getName();
        Action action = getAction(actionName);
        if (action == null) {
            log.debug("No action found for name {}", actionName);
            return;
        }
        if (action.getType() != ActionType.PROJECT) {
            return;
        }
        ItsFacade its = itsFactory.getFacade(new Project.NameKey(properties.get("project")));
        action.execute(its, itsProject, actionRequest, properties);
    } catch (IOException e) {
        log.error("Error while executing action " + actionRequest, e);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ProjectConfigEntry.class).annotatedWith(Exports.named("enabled")).toInstance(new ItsHookEnabledConfigEntry(pluginName, pluginCfgFactory));
    bind(ItsConfig.class);
    DynamicSet.bind(binder(), CommitValidationListener.class).to(ItsValidateComment.class);
    DynamicSet.bind(binder(), EventListener.class).to(ActionController.class);
    factory(ActionRequest.Factory.class);
    factory(Property.Factory.class);
    factory(Condition.Factory.class);
    factory(Rule.Factory.class);
    factory(AddComment.Factory.class);
    factory(AddSoyComment.Factory.class);
    factory(AddStandardComment.Factory.class);
    factory(LogEvent.Factory.class);
    factory(AddPropertyToField.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ProjectConfigEntry.class).annotatedWith(Exports.named("enabled")).toInstance(new ItsHookEnabledConfigEntry(pluginName, pluginCfgFactory));
    bind(ItsConfig.class);
    DynamicSet.bind(binder(), CommitValidationListener.class).to(ItsValidateComment.class);
    DynamicSet.bind(binder(), EventListener.class).to(ActionController.class);
    factory(ActionRequest.Factory.class);
    factory(Condition.Factory.class);
    factory(Rule.Factory.class);
    factory(AddComment.Factory.class);
    factory(AddSoyComment.Factory.class);
    factory(AddStandardComment.Factory.class);
    factory(LogEvent.Factory.class);
    factory(AddPropertyToField.Factory.class);
    install(ItsRulesProjectCacheImpl.module());
}
#end_block

#method_before
public void execute(String issue, Iterable<ActionRequest> actions, Set<Property> properties) {
    for (ActionRequest actionRequest : actions) {
        execute(issue, actionRequest, properties);
    }
}
#method_after
private void execute(String issue, ActionRequest actionRequest, Map<String, String> properties) {
    ItsFacade its = itsFactory.getFacade(new Project.NameKey(properties.get("project")));
    try {
        Action action = getAction(actionRequest.getName());
        if (action == null) {
            its.performAction(issue, actionRequest.getUnparsed());
        } else {
            action.execute(its, issue, actionRequest, properties);
        }
    } catch (IOException e) {
        log.error("Error while executing action " + actionRequest, e);
    }
}
#end_block

#method_before
public void testExecuteItem() throws IOException {
    ActionRequest actionRequest = createMock(ActionRequest.class);
    expect(actionRequest.getName()).andReturn("unparsed");
    expect(actionRequest.getUnparsed()).andReturn("unparsed action 1");
    Set<Property> properties = Collections.emptySet();
    its.performAction("4711", "unparsed action 1");
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute("4711", actionRequest, properties);
}
#method_after
public void testExecuteItem() throws IOException {
    ActionRequest actionRequest = createMock(ActionRequest.class);
    expect(actionRequest.getName()).andReturn("unparsed");
    expect(actionRequest.getUnparsed()).andReturn("unparsed action 1");
    expect(itsFacadeFactory.getFacade(new Project.NameKey(properties.get("project")))).andReturn(its);
    Set<ActionRequest> actionRequests = ImmutableSet.of(actionRequest);
    its.performAction("4711", "unparsed action 1");
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute(actionRequests, properties);
}
#end_block

#method_before
public void testExecuteItemException() throws IOException {
    ActionRequest actionRequest = createMock(ActionRequest.class);
    expect(actionRequest.getName()).andReturn("unparsed");
    expect(actionRequest.getUnparsed()).andReturn("unparsed action 1");
    Set<Property> properties = Collections.emptySet();
    its.performAction("4711", "unparsed action 1");
    expectLastCall().andThrow(new IOException("injected exception 1"));
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute("4711", actionRequest, properties);
    assertLogThrowableMessageContains("injected exception 1");
}
#method_after
public void testExecuteItemException() throws IOException {
    ActionRequest actionRequest = createMock(ActionRequest.class);
    expect(actionRequest.getName()).andReturn("unparsed");
    expect(actionRequest.getUnparsed()).andReturn("unparsed action 1");
    expect(itsFacadeFactory.getFacade(new Project.NameKey(properties.get("project")))).andReturn(its);
    Set<ActionRequest> actionRequests = ImmutableSet.of(actionRequest);
    its.performAction("4711", "unparsed action 1");
    expectLastCall().andThrow(new IOException("injected exception 1"));
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute(actionRequests, properties);
    assertLogThrowableMessageContains("injected exception 1");
}
#end_block

#method_before
public void testExecuteIterable() throws IOException {
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    expect(actionRequest1.getName()).andReturn("unparsed");
    expect(actionRequest1.getUnparsed()).andReturn("unparsed action 1");
    ActionRequest actionRequest2 = createMock(ActionRequest.class);
    expect(actionRequest2.getName()).andReturn("unparsed");
    expect(actionRequest2.getUnparsed()).andReturn("unparsed action 2");
    Set<Property> properties = Collections.emptySet();
    its.performAction("4711", "unparsed action 1");
    its.performAction("4711", "unparsed action 2");
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute("4711", Sets.newHashSet(actionRequest1, actionRequest2), properties);
}
#method_after
public void testExecuteIterable() throws IOException {
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    expect(actionRequest1.getName()).andReturn("unparsed");
    expect(actionRequest1.getUnparsed()).andReturn("unparsed action 1");
    ActionRequest actionRequest2 = createMock(ActionRequest.class);
    expect(actionRequest2.getName()).andReturn("unparsed");
    expect(actionRequest2.getUnparsed()).andReturn("unparsed action 2");
    expect(itsFacadeFactory.getFacade(new Project.NameKey(properties.get("project")))).andReturn(its).anyTimes();
    Set<ActionRequest> actionRequests = ImmutableSet.of(actionRequest1, actionRequest2);
    its.performAction("4711", "unparsed action 1");
    its.performAction("4711", "unparsed action 2");
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute(actionRequests, properties);
}
#end_block

#method_before
public void testExecuteIterableExceptions() throws IOException {
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    expect(actionRequest1.getName()).andReturn("unparsed");
    expect(actionRequest1.getUnparsed()).andReturn("unparsed action 1");
    ActionRequest actionRequest2 = createMock(ActionRequest.class);
    expect(actionRequest2.getName()).andReturn("unparsed");
    expect(actionRequest2.getUnparsed()).andReturn("unparsed action 2");
    ActionRequest actionRequest3 = createMock(ActionRequest.class);
    expect(actionRequest3.getName()).andReturn("unparsed");
    expect(actionRequest3.getUnparsed()).andReturn("unparsed action 3");
    Set<Property> properties = Collections.emptySet();
    its.performAction("4711", "unparsed action 1");
    expectLastCall().andThrow(new IOException("injected exception 1"));
    its.performAction("4711", "unparsed action 2");
    its.performAction("4711", "unparsed action 3");
    expectLastCall().andThrow(new IOException("injected exception 3"));
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute("4711", Sets.newHashSet(actionRequest1, actionRequest2, actionRequest3), properties);
    assertLogThrowableMessageContains("injected exception 1");
    assertLogThrowableMessageContains("injected exception 3");
}
#method_after
public void testExecuteIterableExceptions() throws IOException {
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    expect(actionRequest1.getName()).andReturn("unparsed");
    expect(actionRequest1.getUnparsed()).andReturn("unparsed action 1");
    ActionRequest actionRequest2 = createMock(ActionRequest.class);
    expect(actionRequest2.getName()).andReturn("unparsed");
    expect(actionRequest2.getUnparsed()).andReturn("unparsed action 2");
    ActionRequest actionRequest3 = createMock(ActionRequest.class);
    expect(actionRequest3.getName()).andReturn("unparsed");
    expect(actionRequest3.getUnparsed()).andReturn("unparsed action 3");
    expect(itsFacadeFactory.getFacade(new Project.NameKey(properties.get("project")))).andReturn(its).anyTimes();
    Set<ActionRequest> actionRequests = ImmutableSet.of(actionRequest1, actionRequest2, actionRequest3);
    its.performAction("4711", "unparsed action 1");
    expectLastCall().andThrow(new IOException("injected exception 1"));
    its.performAction("4711", "unparsed action 2");
    its.performAction("4711", "unparsed action 3");
    expectLastCall().andThrow(new IOException("injected exception 3"));
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute(actionRequests, properties);
    assertLogThrowableMessageContains("injected exception 1");
    assertLogThrowableMessageContains("injected exception 3");
}
#end_block

#method_before
public void testAddCommentDelegation() throws IOException {
    ActionRequest actionRequest = createMock(ActionRequest.class);
    expect(actionRequest.getName()).andReturn("add-comment");
    Set<Property> properties = Collections.emptySet();
    AddComment addComment = createMock(AddComment.class);
    expect(addCommentFactory.create()).andReturn(addComment);
    addComment.execute("4711", actionRequest, properties);
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute("4711", actionRequest, properties);
}
#method_after
public void testAddCommentDelegation() throws IOException {
    ActionRequest actionRequest = createMock(ActionRequest.class);
    expect(actionRequest.getName()).andReturn("add-comment");
    Set<ActionRequest> actionRequests = ImmutableSet.of(actionRequest);
    AddComment addComment = createMock(AddComment.class);
    expect(addCommentFactory.create()).andReturn(addComment);
    expect(itsFacadeFactory.getFacade(new Project.NameKey(properties.get("project")))).andReturn(its);
    addComment.execute(its, "4711", actionRequest, properties);
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute(actionRequests, properties);
}
#end_block

#method_before
public void testAddSoyCommentDelegation() throws IOException {
    ActionRequest actionRequest = createMock(ActionRequest.class);
    expect(actionRequest.getName()).andReturn("add-soy-comment");
    Set<Property> properties = Collections.emptySet();
    AddSoyComment addSoyComment = createMock(AddSoyComment.class);
    expect(addSoyCommentFactory.create()).andReturn(addSoyComment);
    addSoyComment.execute("4711", actionRequest, properties);
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute("4711", actionRequest, properties);
}
#method_after
public void testAddSoyCommentDelegation() throws IOException {
    ActionRequest actionRequest = createMock(ActionRequest.class);
    expect(actionRequest.getName()).andReturn("add-soy-comment");
    Set<ActionRequest> actionRequests = ImmutableSet.of(actionRequest);
    AddSoyComment addSoyComment = createMock(AddSoyComment.class);
    expect(addSoyCommentFactory.create()).andReturn(addSoyComment);
    expect(itsFacadeFactory.getFacade(new Project.NameKey(properties.get("project")))).andReturn(its);
    addSoyComment.execute(its, "4711", actionRequest, properties);
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute(actionRequests, properties);
}
#end_block

#method_before
public void testAddStandardCommentDelegation() throws IOException {
    ActionRequest actionRequest = createMock(ActionRequest.class);
    expect(actionRequest.getName()).andReturn("add-standard-comment");
    Set<Property> properties = Collections.emptySet();
    AddStandardComment addStandardComment = createMock(AddStandardComment.class);
    expect(addStandardCommentFactory.create()).andReturn(addStandardComment);
    addStandardComment.execute("4711", actionRequest, properties);
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute("4711", actionRequest, properties);
}
#method_after
public void testAddStandardCommentDelegation() throws IOException {
    ActionRequest actionRequest = createMock(ActionRequest.class);
    expect(actionRequest.getName()).andReturn("add-standard-comment");
    Set<ActionRequest> actionRequests = ImmutableSet.of(actionRequest);
    AddStandardComment addStandardComment = createMock(AddStandardComment.class);
    expect(addStandardCommentFactory.create()).andReturn(addStandardComment);
    expect(itsFacadeFactory.getFacade(new Project.NameKey(properties.get("project")))).andReturn(its);
    addStandardComment.execute(its, "4711", actionRequest, properties);
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute(actionRequests, properties);
}
#end_block

#method_before
public void testLogEventDelegation() throws IOException {
    ActionRequest actionRequest = createMock(ActionRequest.class);
    expect(actionRequest.getName()).andReturn("log-event");
    Set<Property> properties = Collections.emptySet();
    LogEvent logEvent = createMock(LogEvent.class);
    expect(logEventFactory.create()).andReturn(logEvent);
    logEvent.execute("4711", actionRequest, properties);
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute("4711", actionRequest, properties);
}
#method_after
public void testLogEventDelegation() throws IOException {
    ActionRequest actionRequest = createMock(ActionRequest.class);
    expect(actionRequest.getName()).andReturn("log-event");
    Set<ActionRequest> actionRequests = ImmutableSet.of(actionRequest);
    LogEvent logEvent = createMock(LogEvent.class);
    expect(logEventFactory.create()).andReturn(logEvent);
    expect(itsFacadeFactory.getFacade(new Project.NameKey(properties.get("project")))).andReturn(its);
    logEvent.execute(its, "4711", actionRequest, properties);
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute(actionRequests, properties);
}
#end_block

#method_before
public void testAddPropertyToFieldDelegation() throws IOException {
    ActionRequest actionRequest = createMock(ActionRequest.class);
    expect(actionRequest.getName()).andReturn("add-property-to-field");
    Set<Property> properties = Collections.emptySet();
    AddPropertyToField addPropertyToField = createMock(AddPropertyToField.class);
    expect(addPropertyToFieldFactory.create()).andReturn(addPropertyToField);
    addPropertyToField.execute("4711", actionRequest, properties);
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute("4711", actionRequest, properties);
}
#method_after
public void testAddPropertyToFieldDelegation() throws IOException {
    ActionRequest actionRequest = createMock(ActionRequest.class);
    expect(actionRequest.getName()).andReturn("add-property-to-field");
    Set<ActionRequest> actionRequests = ImmutableSet.of(actionRequest);
    AddPropertyToField addPropertyToField = createMock(AddPropertyToField.class);
    expect(addPropertyToFieldFactory.create()).andReturn(addPropertyToField);
    expect(itsFacadeFactory.getFacade(new Project.NameKey(properties.get("project")))).andReturn(its);
    addPropertyToField.execute(its, "4711", actionRequest, properties);
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute(actionRequests, properties);
}
#end_block

#method_before
@Override
protected void configure() {
    its = createMock(ItsFacade.class);
    bind(ItsFacade.class).toInstance(its);
    addCommentFactory = createMock(AddComment.Factory.class);
    bind(AddComment.Factory.class).toInstance(addCommentFactory);
    addSoyCommentFactory = createMock(AddSoyComment.Factory.class);
    bind(AddSoyComment.Factory.class).toInstance(addSoyCommentFactory);
    addStandardCommentFactory = createMock(AddStandardComment.Factory.class);
    bind(AddStandardComment.Factory.class).toInstance(addStandardCommentFactory);
    logEventFactory = createMock(LogEvent.Factory.class);
    bind(LogEvent.Factory.class).toInstance(logEventFactory);
    addPropertyToFieldFactory = createMock(AddPropertyToField.Factory.class);
    bind(AddPropertyToField.Factory.class).toInstance(addPropertyToFieldFactory);
}
#method_after
@Override
protected void configure() {
    its = createMock(ItsFacade.class);
    bind(ItsFacade.class).toInstance(its);
    addCommentFactory = createMock(AddComment.Factory.class);
    bind(AddComment.Factory.class).toInstance(addCommentFactory);
    addSoyCommentFactory = createMock(AddSoyComment.Factory.class);
    bind(AddSoyComment.Factory.class).toInstance(addSoyCommentFactory);
    addStandardCommentFactory = createMock(AddStandardComment.Factory.class);
    bind(AddStandardComment.Factory.class).toInstance(addStandardCommentFactory);
    logEventFactory = createMock(LogEvent.Factory.class);
    bind(LogEvent.Factory.class).toInstance(logEventFactory);
    itsFacadeFactory = createMock(ItsFacadeFactory.class);
    bind(ItsFacadeFactory.class).toInstance(itsFacadeFactory);
    addPropertyToFieldFactory = createMock(AddPropertyToField.Factory.class);
    bind(AddPropertyToField.Factory.class).toInstance(addPropertyToFieldFactory);
}
#end_block

#method_before
private void autoCloseChanges(ReceiveCommand cmd) {
    logDebug("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    // insertChangesAndPatchSets.
    try {
        retryHelper.execute(updateFactory -> {
            try (BatchUpdate bu = updateFactory.create(db, projectState.getNameKey(), user, TimeUtil.nowTs());
                ObjectInserter ins = repo.newObjectInserter();
                ObjectReader reader = ins.newReader();
                RevWalk rw = new RevWalk(reader)) {
                bu.setRepository(repo, rw, ins).updateChangesInParallel();
                bu.setRequestId(receiveId);
                // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
                RevCommit newTip = rw.parseCommit(cmd.getNewId());
                Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
                rw.reset();
                rw.markStart(newTip);
                if (!ObjectId.zeroId().equals(cmd.getOldId())) {
                    rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
                }
                ListMultimap<ObjectId, Ref> byCommit = changeRefsById();
                Map<Change.Key, ChangeNotes> byKey = null;
                List<ReplaceRequest> replaceAndClose = new ArrayList<>();
                int existingPatchSets = 0;
                int newPatchSets = 0;
                COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
                    rw.parseBody(c);
                    for (Ref ref : byCommit.get(c.copy())) {
                        PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                        ChangeNotes notes = notesFactory.createChecked(db, project.getNameKey(), psId.getParentKey());
                        if (notes.getChange().getDest().equals(branch)) {
                            existingPatchSets++;
                            bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                            continue COMMIT;
                        }
                    }
                    for (String changeId : c.getFooterLines(CHANGE_ID)) {
                        if (byKey == null) {
                            byKey = executeIndexQuery(() -> openChangesByKeyByBranch(branch));
                        }
                        ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                        if (onto != null) {
                            newPatchSets++;
                            // Hold onto this until we're done with the walk, as the call to
                            // req.validate below calls isMergedInto which resets the walk.
                            ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                            req.notes = onto;
                            replaceAndClose.add(req);
                            continue COMMIT;
                        }
                    }
                }
                for (ReplaceRequest req : replaceAndClose) {
                    Change.Id id = req.notes.getChangeId();
                    if (!executeRequestValidation(() -> req.validate(true))) {
                        logDebug("Not closing %s because validation failed", id);
                        continue;
                    }
                    req.addOps(bu, null);
                    bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(req.replaceOp::getPatchSet));
                    bu.addOp(id, new ChangeProgressOp(closeProgress));
                }
                logDebug("Auto-closing %s changes with existing patch sets and %s with new patch sets", existingPatchSets, newPatchSets);
                bu.execute();
            } catch (IOException | OrmException | PermissionBackendException e) {
                logError("Failed to auto-close changes", e);
            }
            return null;
        }, // eat up the whole timeout so that no time is left to retry this outer action.
        RetryHelper.options().timeout(retryHelper.getDefaultTimeout(ActionType.CHANGE_UPDATE).multipliedBy(5)).build());
    } catch (RestApiException e) {
        logError("Can't insert patchset", e);
    } catch (UpdateException e) {
        logError("Failed to auto-close changes", e);
    }
}
#method_after
private void autoCloseChanges(ReceiveCommand cmd) {
    logDebug("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    // insertChangesAndPatchSets.
    try {
        retryHelper.execute(updateFactory -> {
            try (BatchUpdate bu = updateFactory.create(db, projectState.getNameKey(), user, TimeUtil.nowTs());
                ObjectInserter ins = repo.newObjectInserter();
                ObjectReader reader = ins.newReader();
                RevWalk rw = new RevWalk(reader)) {
                bu.setRepository(repo, rw, ins).updateChangesInParallel();
                bu.setRequestId(receiveId);
                // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
                RevCommit newTip = rw.parseCommit(cmd.getNewId());
                Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
                rw.reset();
                rw.markStart(newTip);
                if (!ObjectId.zeroId().equals(cmd.getOldId())) {
                    rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
                }
                ListMultimap<ObjectId, Ref> byCommit = changeRefsById();
                Map<Change.Key, ChangeNotes> byKey = null;
                List<ReplaceRequest> replaceAndClose = new ArrayList<>();
                int existingPatchSets = 0;
                int newPatchSets = 0;
                COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
                    rw.parseBody(c);
                    for (Ref ref : byCommit.get(c.copy())) {
                        PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                        Optional<ChangeNotes> notes = getChangeNotes(psId.getParentKey());
                        if (notes.isPresent() && notes.get().getChange().getDest().equals(branch)) {
                            existingPatchSets++;
                            bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                            continue COMMIT;
                        }
                    }
                    for (String changeId : c.getFooterLines(CHANGE_ID)) {
                        if (byKey == null) {
                            byKey = executeIndexQuery(() -> openChangesByKeyByBranch(branch));
                        }
                        ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                        if (onto != null) {
                            newPatchSets++;
                            // Hold onto this until we're done with the walk, as the call to
                            // req.validate below calls isMergedInto which resets the walk.
                            ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                            req.notes = onto;
                            replaceAndClose.add(req);
                            continue COMMIT;
                        }
                    }
                }
                for (ReplaceRequest req : replaceAndClose) {
                    Change.Id id = req.notes.getChangeId();
                    if (!executeRequestValidation(() -> req.validate(true))) {
                        logDebug("Not closing %s because validation failed", id);
                        continue;
                    }
                    req.addOps(bu, null);
                    bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(req.replaceOp::getPatchSet));
                    bu.addOp(id, new ChangeProgressOp(closeProgress));
                }
                logDebug("Auto-closing %s changes with existing patch sets and %s with new patch sets", existingPatchSets, newPatchSets);
                bu.execute();
            } catch (IOException | OrmException | PermissionBackendException e) {
                logError("Failed to auto-close changes", e);
            }
            return null;
        }, // eat up the whole timeout so that no time is left to retry this outer action.
        RetryHelper.options().timeout(retryHelper.getDefaultTimeout(ActionType.CHANGE_UPDATE).multipliedBy(5)).build());
    } catch (RestApiException e) {
        logError("Can't insert patchset", e);
    } catch (UpdateException e) {
        logError("Failed to auto-close changes", e);
    }
}
#end_block

#method_before
@Override
public void delete(K id) throws IOException {
    String uri = getURI(indexType, BULK);
    Response response = postRequest(getDeleteActions(id), uri, getRefreshParam());
    int statusCode = response.getStatusLine().getStatusCode();
    if (statusCode != HttpStatus.SC_OK) {
        throw new IOException(String.format("Failed to delete %s from index %s: %s", id, indexName, statusCode));
    }
}
#method_after
@Override
public void delete(K id) throws IOException {
    String uri = getURI(type, BULK);
    Response response = postRequest(getDeleteActions(id), uri, getRefreshParam());
    int statusCode = response.getStatusLine().getStatusCode();
    if (statusCode != HttpStatus.SC_OK) {
        throw new IOException(String.format("Failed to delete %s from index %s: %s", id, indexName, statusCode));
    }
}
#end_block

#method_before
protected String delete(String type, K id) {
    return new DeleteRequest(id.toString(), indexName, type).toString();
}
#method_after
protected String delete(String type, K id) {
    return new DeleteRequest(id.toString(), indexName, type, client.adapter()).toString();
}
#end_block

#method_before
@Override
public void replace(ChangeData cd) throws IOException {
    String deleteIndex;
    String insertIndex;
    try {
        if (cd.change().getStatus().isOpen()) {
            insertIndex = OPEN_CHANGES;
            deleteIndex = CLOSED_CHANGES;
        } else {
            insertIndex = CLOSED_CHANGES;
            deleteIndex = OPEN_CHANGES;
        }
    } catch (OrmException e) {
        throw new IOException(e);
    }
    BulkRequest bulk = new IndexRequest(getId(cd), indexName, insertIndex).add(new UpdateRequest<>(fillArgs, schema, cd)).add(new DeleteRequest(cd.getId().toString(), indexName, deleteIndex));
    String uri = getURI(ALL_CHANGES, BULK);
    Response response = postRequest(bulk, uri, getRefreshParam());
    int statusCode = response.getStatusLine().getStatusCode();
    if (statusCode != HttpStatus.SC_OK) {
        throw new IOException(String.format("Failed to replace change %s in index %s: %s", cd.getId(), indexName, statusCode));
    }
}
#method_after
@Override
public void replace(ChangeData cd) throws IOException {
    String deleteIndex;
    String insertIndex;
    try {
        if (cd.change().getStatus().isOpen()) {
            insertIndex = OPEN_CHANGES;
            deleteIndex = CLOSED_CHANGES;
        } else {
            insertIndex = CLOSED_CHANGES;
            deleteIndex = OPEN_CHANGES;
        }
    } catch (OrmException e) {
        throw new IOException(e);
    }
    ElasticQueryAdapter adapter = client.adapter();
    BulkRequest bulk = new IndexRequest(getId(cd), indexName, adapter.getType(insertIndex), adapter).add(new UpdateRequest<>(fillArgs, schema, cd));
    if (!adapter.usePostV5Type()) {
        bulk.add(new DeleteRequest(cd.getId().toString(), indexName, deleteIndex, adapter));
    }
    String uri = getURI(type, BULK);
    Response response = postRequest(bulk, uri, getRefreshParam());
    int statusCode = response.getStatusLine().getStatusCode();
    if (statusCode != HttpStatus.SC_OK) {
        throw new IOException(String.format("Failed to replace change %s in index %s: %s", cd.getId(), indexName, statusCode));
    }
}
#end_block

#method_before
@Override
public ChangeDataSource getSource(Predicate<ChangeData> p, QueryOptions opts) throws QueryParseException {
    Set<Change.Status> statuses = ChangeIndexRewriter.getPossibleStatus(p);
    List<String> indexes = Lists.newArrayListWithCapacity(2);
    if (!Sets.intersection(statuses, OPEN_STATUSES).isEmpty()) {
        indexes.add(OPEN_CHANGES);
    }
    if (!Sets.intersection(statuses, CLOSED_STATUSES).isEmpty()) {
        indexes.add(CLOSED_CHANGES);
    }
    return new QuerySource(indexes, p, opts);
}
#method_after
@Override
public ChangeDataSource getSource(Predicate<ChangeData> p, QueryOptions opts) throws QueryParseException {
    Set<Change.Status> statuses = ChangeIndexRewriter.getPossibleStatus(p);
    List<String> indexes = Lists.newArrayListWithCapacity(2);
    if (client.adapter().usePostV5Type()) {
        if (!Sets.intersection(statuses, OPEN_STATUSES).isEmpty() || !Sets.intersection(statuses, CLOSED_STATUSES).isEmpty()) {
            indexes.add(ElasticQueryAdapter.POST_V5_TYPE);
        }
    } else {
        if (!Sets.intersection(statuses, OPEN_STATUSES).isEmpty()) {
            indexes.add(OPEN_CHANGES);
        }
        if (!Sets.intersection(statuses, CLOSED_STATUSES).isEmpty()) {
            indexes.add(CLOSED_CHANGES);
        }
    }
    return new QuerySource(indexes, p, opts);
}
#end_block

#method_before
@Override
protected String getDeleteActions(Id c) {
    return delete(OPEN_CHANGES, c) + delete(CLOSED_CHANGES, c);
}
#method_after
@Override
protected String getDeleteActions(Id c) {
    if (client.adapter().usePostV5Type()) {
        return delete(ElasticQueryAdapter.POST_V5_TYPE, c);
    }
    return delete(OPEN_CHANGES, c) + delete(CLOSED_CHANGES, c);
}
#end_block

#method_before
@Override
protected String getMappings() {
    return gson.toJson(ImmutableMap.of("mappings", mapping));
}
#method_after
@Override
protected String getMappings() {
    if (client.adapter().usePostV5Type()) {
        return getMappingsFor(ElasticQueryAdapter.POST_V5_TYPE, mapping.changes);
    }
    return gson.toJson(ImmutableMap.of(MAPPINGS, mapping));
}
#end_block

#method_before
@Test
public void byDeletedAccount() throws Exception {
    AccountInfo user = newAccountWithFullName("ballen", "Barry Allen");
    Account.Id userId = Account.Id.parse(user._accountId.toString());
    assertQuery("Barry", user);
    for (AccountIndex index : accountIndexes.getWriteIndexes()) {
        index.delete(userId);
    }
    assertQuery("Barry");
}
#method_after
@Test
public void byDeletedAccount() throws Exception {
    AccountInfo user = newAccountWithFullName("jdoe", "John Doe");
    Account.Id userId = Account.Id.parse(user._accountId.toString());
    assertQuery("John", user);
    for (AccountIndex index : accountIndexes.getWriteIndexes()) {
        index.delete(userId);
    }
    assertQuery("John");
}
#end_block

#method_before
public void testExecuteItem() throws IOException {
    ActionRequest actionRequest = createMock(ActionRequest.class);
    expect(actionRequest.getName()).andReturn("unparsed");
    expect(actionRequest.getUnparsed()).andReturn("unparsed action 1");
    ItsServerInfo serverInfo = createMock(ItsServerInfo.class);
    Set<Property> properties = Collections.emptySet();
    its.performAction(serverInfo, "4711", "unparsed action 1");
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute(serverInfo, "4711", actionRequest, properties);
}
#method_after
public void testExecuteItem() throws IOException {
    ActionRequest actionRequest = createMock(ActionRequest.class);
    expect(actionRequest.getName()).andReturn("unparsed");
    expect(actionRequest.getUnparsed()).andReturn("unparsed action 1");
    expect(itsFacadeFactory.getFacade(new Project.NameKey(properties.get("project")))).andReturn(its);
    Set<ActionRequest> actionRequests = ImmutableSet.of(actionRequest);
    its.performAction("4711", "unparsed action 1");
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute(actionRequests, properties);
}
#end_block

#method_before
public void testExecuteItemException() throws IOException {
    ActionRequest actionRequest = createMock(ActionRequest.class);
    expect(actionRequest.getName()).andReturn("unparsed");
    expect(actionRequest.getUnparsed()).andReturn("unparsed action 1");
    ItsServerInfo serverInfo = createMock(ItsServerInfo.class);
    Set<Property> properties = Collections.emptySet();
    its.performAction(serverInfo, "4711", "unparsed action 1");
    expectLastCall().andThrow(new IOException("injected exception 1"));
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute(serverInfo, "4711", actionRequest, properties);
    assertLogThrowableMessageContains("injected exception 1");
}
#method_after
public void testExecuteItemException() throws IOException {
    ActionRequest actionRequest = createMock(ActionRequest.class);
    expect(actionRequest.getName()).andReturn("unparsed");
    expect(actionRequest.getUnparsed()).andReturn("unparsed action 1");
    expect(itsFacadeFactory.getFacade(new Project.NameKey(properties.get("project")))).andReturn(its);
    Set<ActionRequest> actionRequests = ImmutableSet.of(actionRequest);
    its.performAction("4711", "unparsed action 1");
    expectLastCall().andThrow(new IOException("injected exception 1"));
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute(actionRequests, properties);
    assertLogThrowableMessageContains("injected exception 1");
}
#end_block

#method_before
public void testExecuteIterable() throws IOException {
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    expect(actionRequest1.getName()).andReturn("unparsed");
    expect(actionRequest1.getUnparsed()).andReturn("unparsed action 1");
    ActionRequest actionRequest2 = createMock(ActionRequest.class);
    expect(actionRequest2.getName()).andReturn("unparsed");
    expect(actionRequest2.getUnparsed()).andReturn("unparsed action 2");
    ItsServerInfo serverInfo = createMock(ItsServerInfo.class);
    Set<Property> properties = Collections.emptySet();
    its.performAction(serverInfo, "4711", "unparsed action 1");
    its.performAction(serverInfo, "4711", "unparsed action 2");
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute(serverInfo, "4711", Sets.newHashSet(actionRequest1, actionRequest2), properties);
}
#method_after
public void testExecuteIterable() throws IOException {
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    expect(actionRequest1.getName()).andReturn("unparsed");
    expect(actionRequest1.getUnparsed()).andReturn("unparsed action 1");
    ActionRequest actionRequest2 = createMock(ActionRequest.class);
    expect(actionRequest2.getName()).andReturn("unparsed");
    expect(actionRequest2.getUnparsed()).andReturn("unparsed action 2");
    expect(itsFacadeFactory.getFacade(new Project.NameKey(properties.get("project")))).andReturn(its).anyTimes();
    Set<ActionRequest> actionRequests = ImmutableSet.of(actionRequest1, actionRequest2);
    its.performAction("4711", "unparsed action 1");
    its.performAction("4711", "unparsed action 2");
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute(actionRequests, properties);
}
#end_block

#method_before
public void testExecuteIterableExceptions() throws IOException {
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    expect(actionRequest1.getName()).andReturn("unparsed");
    expect(actionRequest1.getUnparsed()).andReturn("unparsed action 1");
    ActionRequest actionRequest2 = createMock(ActionRequest.class);
    expect(actionRequest2.getName()).andReturn("unparsed");
    expect(actionRequest2.getUnparsed()).andReturn("unparsed action 2");
    ActionRequest actionRequest3 = createMock(ActionRequest.class);
    expect(actionRequest3.getName()).andReturn("unparsed");
    expect(actionRequest3.getUnparsed()).andReturn("unparsed action 3");
    ItsServerInfo serverInfo = createMock(ItsServerInfo.class);
    Set<Property> properties = Collections.emptySet();
    its.performAction(serverInfo, "4711", "unparsed action 1");
    expectLastCall().andThrow(new IOException("injected exception 1"));
    its.performAction(serverInfo, "4711", "unparsed action 2");
    its.performAction(serverInfo, "4711", "unparsed action 3");
    expectLastCall().andThrow(new IOException("injected exception 3"));
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute(serverInfo, "4711", Sets.newHashSet(actionRequest1, actionRequest2, actionRequest3), properties);
    assertLogThrowableMessageContains("injected exception 1");
    assertLogThrowableMessageContains("injected exception 3");
}
#method_after
public void testExecuteIterableExceptions() throws IOException {
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    expect(actionRequest1.getName()).andReturn("unparsed");
    expect(actionRequest1.getUnparsed()).andReturn("unparsed action 1");
    ActionRequest actionRequest2 = createMock(ActionRequest.class);
    expect(actionRequest2.getName()).andReturn("unparsed");
    expect(actionRequest2.getUnparsed()).andReturn("unparsed action 2");
    ActionRequest actionRequest3 = createMock(ActionRequest.class);
    expect(actionRequest3.getName()).andReturn("unparsed");
    expect(actionRequest3.getUnparsed()).andReturn("unparsed action 3");
    expect(itsFacadeFactory.getFacade(new Project.NameKey(properties.get("project")))).andReturn(its).anyTimes();
    Set<ActionRequest> actionRequests = ImmutableSet.of(actionRequest1, actionRequest2, actionRequest3);
    its.performAction("4711", "unparsed action 1");
    expectLastCall().andThrow(new IOException("injected exception 1"));
    its.performAction("4711", "unparsed action 2");
    its.performAction("4711", "unparsed action 3");
    expectLastCall().andThrow(new IOException("injected exception 3"));
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute(actionRequests, properties);
    assertLogThrowableMessageContains("injected exception 1");
    assertLogThrowableMessageContains("injected exception 3");
}
#end_block

#method_before
public void testAddCommentDelegation() throws IOException {
    ActionRequest actionRequest = createMock(ActionRequest.class);
    expect(actionRequest.getName()).andReturn("add-comment");
    Set<Property> properties = Collections.emptySet();
    AddComment addComment = createMock(AddComment.class);
    expect(addCommentFactory.create()).andReturn(addComment);
    ItsServerInfo serverInfo = createMock(ItsServerInfo.class);
    addComment.execute(serverInfo, "4711", actionRequest, properties);
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute(serverInfo, "4711", actionRequest, properties);
}
#method_after
public void testAddCommentDelegation() throws IOException {
    ActionRequest actionRequest = createMock(ActionRequest.class);
    expect(actionRequest.getName()).andReturn("add-comment");
    Set<ActionRequest> actionRequests = ImmutableSet.of(actionRequest);
    AddComment addComment = createMock(AddComment.class);
    expect(addCommentFactory.create()).andReturn(addComment);
    expect(itsFacadeFactory.getFacade(new Project.NameKey(properties.get("project")))).andReturn(its);
    addComment.execute(its, "4711", actionRequest, properties);
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute(actionRequests, properties);
}
#end_block

#method_before
public void testAddSoyCommentDelegation() throws IOException {
    ActionRequest actionRequest = createMock(ActionRequest.class);
    expect(actionRequest.getName()).andReturn("add-soy-comment");
    Set<Property> properties = Collections.emptySet();
    AddSoyComment addSoyComment = createMock(AddSoyComment.class);
    expect(addSoyCommentFactory.create()).andReturn(addSoyComment);
    ItsServerInfo serverInfo = createMock(ItsServerInfo.class);
    addSoyComment.execute(serverInfo, "4711", actionRequest, properties);
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute(serverInfo, "4711", actionRequest, properties);
}
#method_after
public void testAddSoyCommentDelegation() throws IOException {
    ActionRequest actionRequest = createMock(ActionRequest.class);
    expect(actionRequest.getName()).andReturn("add-soy-comment");
    Set<ActionRequest> actionRequests = ImmutableSet.of(actionRequest);
    AddSoyComment addSoyComment = createMock(AddSoyComment.class);
    expect(addSoyCommentFactory.create()).andReturn(addSoyComment);
    expect(itsFacadeFactory.getFacade(new Project.NameKey(properties.get("project")))).andReturn(its);
    addSoyComment.execute(its, "4711", actionRequest, properties);
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute(actionRequests, properties);
}
#end_block

#method_before
public void testAddStandardCommentDelegation() throws IOException {
    ActionRequest actionRequest = createMock(ActionRequest.class);
    expect(actionRequest.getName()).andReturn("add-standard-comment");
    Set<Property> properties = Collections.emptySet();
    AddStandardComment addStandardComment = createMock(AddStandardComment.class);
    expect(addStandardCommentFactory.create()).andReturn(addStandardComment);
    ItsServerInfo serverInfo = createMock(ItsServerInfo.class);
    addStandardComment.execute(serverInfo, "4711", actionRequest, properties);
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute(serverInfo, "4711", actionRequest, properties);
}
#method_after
public void testAddStandardCommentDelegation() throws IOException {
    ActionRequest actionRequest = createMock(ActionRequest.class);
    expect(actionRequest.getName()).andReturn("add-standard-comment");
    Set<ActionRequest> actionRequests = ImmutableSet.of(actionRequest);
    AddStandardComment addStandardComment = createMock(AddStandardComment.class);
    expect(addStandardCommentFactory.create()).andReturn(addStandardComment);
    expect(itsFacadeFactory.getFacade(new Project.NameKey(properties.get("project")))).andReturn(its);
    addStandardComment.execute(its, "4711", actionRequest, properties);
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute(actionRequests, properties);
}
#end_block

#method_before
public void testLogEventDelegation() throws IOException {
    ActionRequest actionRequest = createMock(ActionRequest.class);
    expect(actionRequest.getName()).andReturn("log-event");
    Set<Property> properties = Collections.emptySet();
    LogEvent logEvent = createMock(LogEvent.class);
    expect(logEventFactory.create()).andReturn(logEvent);
    ItsServerInfo serverInfo = createMock(ItsServerInfo.class);
    logEvent.execute(serverInfo, "4711", actionRequest, properties);
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute(serverInfo, "4711", actionRequest, properties);
}
#method_after
public void testLogEventDelegation() throws IOException {
    ActionRequest actionRequest = createMock(ActionRequest.class);
    expect(actionRequest.getName()).andReturn("log-event");
    Set<ActionRequest> actionRequests = ImmutableSet.of(actionRequest);
    LogEvent logEvent = createMock(LogEvent.class);
    expect(logEventFactory.create()).andReturn(logEvent);
    expect(itsFacadeFactory.getFacade(new Project.NameKey(properties.get("project")))).andReturn(its);
    logEvent.execute(its, "4711", actionRequest, properties);
    replayMocks();
    ActionExecutor actionExecutor = createActionExecutor();
    actionExecutor.execute(actionRequests, properties);
}
#end_block

#method_before
@Override
protected void configure() {
    its = createMock(ItsFacade.class);
    bind(ItsFacade.class).toInstance(its);
    addCommentFactory = createMock(AddComment.Factory.class);
    bind(AddComment.Factory.class).toInstance(addCommentFactory);
    addSoyCommentFactory = createMock(AddSoyComment.Factory.class);
    bind(AddSoyComment.Factory.class).toInstance(addSoyCommentFactory);
    addStandardCommentFactory = createMock(AddStandardComment.Factory.class);
    bind(AddStandardComment.Factory.class).toInstance(addStandardCommentFactory);
    logEventFactory = createMock(LogEvent.Factory.class);
    bind(LogEvent.Factory.class).toInstance(logEventFactory);
}
#method_after
@Override
protected void configure() {
    its = createMock(ItsFacade.class);
    bind(ItsFacade.class).toInstance(its);
    addCommentFactory = createMock(AddComment.Factory.class);
    bind(AddComment.Factory.class).toInstance(addCommentFactory);
    addSoyCommentFactory = createMock(AddSoyComment.Factory.class);
    bind(AddSoyComment.Factory.class).toInstance(addSoyCommentFactory);
    addStandardCommentFactory = createMock(AddStandardComment.Factory.class);
    bind(AddStandardComment.Factory.class).toInstance(addStandardCommentFactory);
    logEventFactory = createMock(LogEvent.Factory.class);
    bind(LogEvent.Factory.class).toInstance(logEventFactory);
    itsFacadeFactory = createMock(ItsFacadeFactory.class);
    bind(ItsFacadeFactory.class).toInstance(itsFacadeFactory);
}
#end_block

#method_before
public void testSuggestedNonMatching() throws CommitValidationException {
    List<CommitValidationMessage> ret;
    ItsValidateComment ivc = injector.getInstance(ItsValidateComment.class);
    ReceiveCommand command = createMock(ReceiveCommand.class);
    RevCommit commit = createMock(RevCommit.class);
    CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null);
    expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.SUGGESTED).atLeastOnce();
    expect(commit.getFullMessage()).andReturn("TestMessage").atLeastOnce();
    expect(commit.getId()).andReturn(commit).anyTimes();
    expect(commit.getName()).andReturn("TestCommit").anyTimes();
    expect(issueExtractor.getIssueIds("TestMessage")).andReturn(new String[] {}).atLeastOnce();
    replayMocks();
    ret = ivc.onCommitReceived(event);
    assertEquals("Size of returned CommitValidationMessages does not match", 1, ret.size());
    assertTrue("First CommitValidationMessages does not contain 'Missing " + "issue'", ret.get(0).getMessage().contains("Missing issue"));
}
#method_after
public void testSuggestedNonMatching() throws CommitValidationException {
    List<CommitValidationMessage> ret;
    ItsValidateComment ivc = injector.getInstance(ItsValidateComment.class);
    ReceiveCommand command = createMock(ReceiveCommand.class);
    RevCommit commit = createMock(RevCommit.class);
    CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null);
    expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.SUGGESTED).atLeastOnce();
    expect(itsConfig.getDummyIssuePattern()).andReturn(Optional.empty()).atLeastOnce();
    expect(commit.getFullMessage()).andReturn("TestMessage").atLeastOnce();
    expect(commit.getId()).andReturn(commit).anyTimes();
    expect(commit.getName()).andReturn("TestCommit").anyTimes();
    expect(issueExtractor.getIssueIds("TestMessage")).andReturn(new String[] {}).atLeastOnce();
    replayMocks();
    ret = ivc.onCommitReceived(event);
    assertEquals("Size of returned CommitValidationMessages does not match", 1, ret.size());
    assertTrue("First CommitValidationMessages does not contain 'Missing " + "issue'", ret.get(0).getMessage().contains("Missing issue"));
}
#end_block

#method_before
public void testMandatoryNonMatching() {
    ItsValidateComment ivc = injector.getInstance(ItsValidateComment.class);
    ReceiveCommand command = createMock(ReceiveCommand.class);
    RevCommit commit = createMock(RevCommit.class);
    CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null);
    expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.MANDATORY).atLeastOnce();
    expect(commit.getFullMessage()).andReturn("TestMessage").atLeastOnce();
    expect(commit.getId()).andReturn(commit).anyTimes();
    expect(commit.getName()).andReturn("TestCommit").anyTimes();
    expect(issueExtractor.getIssueIds("TestMessage")).andReturn(new String[] {}).atLeastOnce();
    replayMocks();
    try {
        ivc.onCommitReceived(event);
        fail("onCommitReceived did not throw any exception");
    } catch (CommitValidationException e) {
        assertTrue("Message of thrown CommitValidationException does not " + "contain 'Missing issue'", e.getMessage().contains("Missing issue"));
    }
}
#method_after
public void testMandatoryNonMatching() {
    ItsValidateComment ivc = injector.getInstance(ItsValidateComment.class);
    ReceiveCommand command = createMock(ReceiveCommand.class);
    RevCommit commit = createMock(RevCommit.class);
    CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null);
    expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.MANDATORY).atLeastOnce();
    expect(itsConfig.getDummyIssuePattern()).andReturn(Optional.empty()).atLeastOnce();
    expect(commit.getFullMessage()).andReturn("TestMessage").atLeastOnce();
    expect(commit.getId()).andReturn(commit).anyTimes();
    expect(commit.getName()).andReturn("TestCommit").anyTimes();
    expect(issueExtractor.getIssueIds("TestMessage")).andReturn(new String[] {}).atLeastOnce();
    replayMocks();
    try {
        ivc.onCommitReceived(event);
        fail("onCommitReceived did not throw any exception");
    } catch (CommitValidationException e) {
        assertTrue("Message of thrown CommitValidationException does not " + "contain 'Missing issue'", e.getMessage().contains("Missing issue"));
    }
}
#end_block

#method_before
public void testSuggestedMatchingSingleExisting() throws CommitValidationException, IOException {
    List<CommitValidationMessage> ret;
    ItsValidateComment ivc = injector.getInstance(ItsValidateComment.class);
    ReceiveCommand command = createMock(ReceiveCommand.class);
    RevCommit commit = createMock(RevCommit.class);
    CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null);
    expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.SUGGESTED).atLeastOnce();
    expect(commit.getFullMessage()).andReturn("bug#4711").atLeastOnce();
    expect(commit.getId()).andReturn(commit).anyTimes();
    expect(commit.getName()).andReturn("TestCommit").anyTimes();
    expect(issueExtractor.getIssueIds("bug#4711")).andReturn(new String[] { "4711" }).atLeastOnce();
    ItsServerInfo serverInfo = createMock(ItsServerInfo.class);
    expect(itsServer.getServer(project.getName())).andReturn(serverInfo);
    expect(itsFacade.exists(serverInfo, "4711")).andReturn(true).atLeastOnce();
    replayMocks();
    ret = ivc.onCommitReceived(event);
    assertEmptyList(ret);
}
#method_after
public void testSuggestedMatchingSingleExisting() throws CommitValidationException, IOException {
    List<CommitValidationMessage> ret;
    ItsValidateComment ivc = injector.getInstance(ItsValidateComment.class);
    ReceiveCommand command = createMock(ReceiveCommand.class);
    RevCommit commit = createMock(RevCommit.class);
    CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null);
    expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.SUGGESTED).atLeastOnce();
    expect(commit.getFullMessage()).andReturn("bug#4711").atLeastOnce();
    expect(commit.getId()).andReturn(commit).anyTimes();
    expect(commit.getName()).andReturn("TestCommit").anyTimes();
    expect(issueExtractor.getIssueIds("bug#4711")).andReturn(new String[] { "4711" }).atLeastOnce();
    expect(itsFacadeFactory.getFacade(project.getNameKey())).andReturn(itsFacade);
    expect(itsFacade.exists("4711")).andReturn(true).atLeastOnce();
    replayMocks();
    ret = ivc.onCommitReceived(event);
    assertEmptyList(ret);
}
#end_block

#method_before
public void testMandatoryMatchingSingleExisting() throws CommitValidationException, IOException {
    List<CommitValidationMessage> ret;
    ItsValidateComment ivc = injector.getInstance(ItsValidateComment.class);
    ReceiveCommand command = createMock(ReceiveCommand.class);
    RevCommit commit = createMock(RevCommit.class);
    CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null);
    expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.MANDATORY).atLeastOnce();
    expect(commit.getFullMessage()).andReturn("bug#4711").atLeastOnce();
    expect(commit.getId()).andReturn(commit).anyTimes();
    expect(commit.getName()).andReturn("TestCommit").anyTimes();
    expect(issueExtractor.getIssueIds("bug#4711")).andReturn(new String[] { "4711" }).atLeastOnce();
    ItsServerInfo serverInfo = createMock(ItsServerInfo.class);
    expect(itsServer.getServer(project.getName())).andReturn(serverInfo);
    expect(itsFacade.exists(serverInfo, "4711")).andReturn(true).atLeastOnce();
    replayMocks();
    ret = ivc.onCommitReceived(event);
    assertEmptyList(ret);
}
#method_after
public void testMandatoryMatchingSingleExisting() throws CommitValidationException, IOException {
    List<CommitValidationMessage> ret;
    ItsValidateComment ivc = injector.getInstance(ItsValidateComment.class);
    ReceiveCommand command = createMock(ReceiveCommand.class);
    RevCommit commit = createMock(RevCommit.class);
    CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null);
    expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.MANDATORY).atLeastOnce();
    expect(commit.getFullMessage()).andReturn("bug#4711").atLeastOnce();
    expect(commit.getId()).andReturn(commit).anyTimes();
    expect(commit.getName()).andReturn("TestCommit").anyTimes();
    expect(issueExtractor.getIssueIds("bug#4711")).andReturn(new String[] { "4711" }).atLeastOnce();
    expect(itsFacadeFactory.getFacade(project.getNameKey())).andReturn(itsFacade);
    expect(itsFacade.exists("4711")).andReturn(true).atLeastOnce();
    replayMocks();
    ret = ivc.onCommitReceived(event);
    assertEmptyList(ret);
}
#end_block

#method_before
public void testSuggestedMatchingSingleNonExisting() throws CommitValidationException, IOException {
    List<CommitValidationMessage> ret;
    ItsValidateComment ivc = injector.getInstance(ItsValidateComment.class);
    ReceiveCommand command = createMock(ReceiveCommand.class);
    RevCommit commit = createMock(RevCommit.class);
    CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null);
    expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.SUGGESTED).atLeastOnce();
    expect(commit.getFullMessage()).andReturn("bug#4711").atLeastOnce();
    expect(commit.getId()).andReturn(commit).anyTimes();
    expect(commit.getName()).andReturn("TestCommit").anyTimes();
    expect(issueExtractor.getIssueIds("bug#4711")).andReturn(new String[] { "4711" }).atLeastOnce();
    ItsServerInfo serverInfo = createMock(ItsServerInfo.class);
    expect(itsServer.getServer(project.getName())).andReturn(serverInfo);
    expect(itsFacade.exists(serverInfo, "4711")).andReturn(false).atLeastOnce();
    replayMocks();
    ret = ivc.onCommitReceived(event);
    assertEquals("Size of returned CommitValidationMessages does not match", 1, ret.size());
    assertTrue("First CommitValidationMessages does not contain " + "'Non-existing'", ret.get(0).getMessage().contains("Non-existing"));
    assertTrue("First CommitValidationMessages does not contain '4711'", ret.get(0).getMessage().contains("4711"));
}
#method_after
public void testSuggestedMatchingSingleNonExisting() throws CommitValidationException, IOException {
    List<CommitValidationMessage> ret;
    ItsValidateComment ivc = injector.getInstance(ItsValidateComment.class);
    ReceiveCommand command = createMock(ReceiveCommand.class);
    RevCommit commit = createMock(RevCommit.class);
    CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null);
    expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.SUGGESTED).atLeastOnce();
    expect(commit.getFullMessage()).andReturn("bug#4711").atLeastOnce();
    expect(commit.getId()).andReturn(commit).anyTimes();
    expect(commit.getName()).andReturn("TestCommit").anyTimes();
    expect(issueExtractor.getIssueIds("bug#4711")).andReturn(new String[] { "4711" }).atLeastOnce();
    expect(itsFacadeFactory.getFacade(project.getNameKey())).andReturn(itsFacade);
    expect(itsFacade.exists("4711")).andReturn(false).atLeastOnce();
    replayMocks();
    ret = ivc.onCommitReceived(event);
    assertEquals("Size of returned CommitValidationMessages does not match", 1, ret.size());
    assertTrue("First CommitValidationMessages does not contain " + "'Non-existing'", ret.get(0).getMessage().contains("Non-existing"));
    assertTrue("First CommitValidationMessages does not contain '4711'", ret.get(0).getMessage().contains("4711"));
}
#end_block

#method_before
public void testMandatoryMatchingSingleNonExisting() throws IOException {
    ItsValidateComment ivc = injector.getInstance(ItsValidateComment.class);
    ReceiveCommand command = createMock(ReceiveCommand.class);
    RevCommit commit = createMock(RevCommit.class);
    CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null);
    expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.MANDATORY).atLeastOnce();
    expect(commit.getFullMessage()).andReturn("bug#4711").atLeastOnce();
    expect(commit.getId()).andReturn(commit).anyTimes();
    expect(commit.getName()).andReturn("TestCommit").anyTimes();
    expect(issueExtractor.getIssueIds("bug#4711")).andReturn(new String[] { "4711" }).atLeastOnce();
    ItsServerInfo serverInfo = createMock(ItsServerInfo.class);
    expect(itsServer.getServer(project.getName())).andReturn(serverInfo);
    expect(itsFacade.exists(serverInfo, "4711")).andReturn(false).atLeastOnce();
    replayMocks();
    try {
        ivc.onCommitReceived(event);
        fail("onCommitReceived did not throw any exception");
    } catch (CommitValidationException e) {
        assertTrue("Message of thrown CommitValidationException does not " + "contain 'Non-existing'", e.getMessage().contains("Non-existing"));
    }
}
#method_after
public void testMandatoryMatchingSingleNonExisting() throws IOException {
    ItsValidateComment ivc = injector.getInstance(ItsValidateComment.class);
    ReceiveCommand command = createMock(ReceiveCommand.class);
    RevCommit commit = createMock(RevCommit.class);
    CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null);
    expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.MANDATORY).atLeastOnce();
    expect(commit.getFullMessage()).andReturn("bug#4711").atLeastOnce();
    expect(commit.getId()).andReturn(commit).anyTimes();
    expect(commit.getName()).andReturn("TestCommit").anyTimes();
    expect(issueExtractor.getIssueIds("bug#4711")).andReturn(new String[] { "4711" }).atLeastOnce();
    expect(itsFacadeFactory.getFacade(project.getNameKey())).andReturn(itsFacade);
    expect(itsFacade.exists("4711")).andReturn(false).atLeastOnce();
    replayMocks();
    try {
        ivc.onCommitReceived(event);
        fail("onCommitReceived did not throw any exception");
    } catch (CommitValidationException e) {
        assertTrue("Message of thrown CommitValidationException does not " + "contain 'Non-existing'", e.getMessage().contains("Non-existing"));
    }
}
#end_block

#method_before
public void testSuggestedMatchingMultiple() throws CommitValidationException, IOException {
    List<CommitValidationMessage> ret;
    ItsValidateComment ivc = injector.getInstance(ItsValidateComment.class);
    ReceiveCommand command = createMock(ReceiveCommand.class);
    RevCommit commit = createMock(RevCommit.class);
    CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null);
    expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.SUGGESTED).atLeastOnce();
    expect(commit.getFullMessage()).andReturn("bug#4711, bug#42").atLeastOnce();
    expect(commit.getId()).andReturn(commit).anyTimes();
    expect(commit.getName()).andReturn("TestCommit").anyTimes();
    expect(issueExtractor.getIssueIds("bug#4711, bug#42")).andReturn(new String[] { "4711", "42" }).atLeastOnce();
    ItsServerInfo serverInfo = createMock(ItsServerInfo.class);
    expect(itsServer.getServer(project.getName())).andReturn(serverInfo);
    expect(itsServer.getServer(project.getName())).andReturn(serverInfo);
    expect(itsFacade.exists(serverInfo, "4711")).andReturn(true).atLeastOnce();
    expect(itsFacade.exists(serverInfo, "42")).andReturn(true).atLeastOnce();
    replayMocks();
    ret = ivc.onCommitReceived(event);
    assertEmptyList(ret);
}
#method_after
public void testSuggestedMatchingMultiple() throws CommitValidationException, IOException {
    List<CommitValidationMessage> ret;
    ItsValidateComment ivc = injector.getInstance(ItsValidateComment.class);
    ReceiveCommand command = createMock(ReceiveCommand.class);
    RevCommit commit = createMock(RevCommit.class);
    CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null);
    expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.SUGGESTED).atLeastOnce();
    expect(commit.getFullMessage()).andReturn("bug#4711, bug#42").atLeastOnce();
    expect(commit.getId()).andReturn(commit).anyTimes();
    expect(commit.getName()).andReturn("TestCommit").anyTimes();
    expect(issueExtractor.getIssueIds("bug#4711, bug#42")).andReturn(new String[] { "4711", "42" }).atLeastOnce();
    expect(itsFacadeFactory.getFacade(project.getNameKey())).andReturn(itsFacade).anyTimes();
    expect(itsFacade.exists("4711")).andReturn(true).atLeastOnce();
    expect(itsFacade.exists("42")).andReturn(true).atLeastOnce();
    replayMocks();
    ret = ivc.onCommitReceived(event);
    assertEmptyList(ret);
}
#end_block

#method_before
public void testMandatoryMatchingMultiple() throws CommitValidationException, IOException {
    List<CommitValidationMessage> ret;
    ItsValidateComment ivc = injector.getInstance(ItsValidateComment.class);
    ReceiveCommand command = createMock(ReceiveCommand.class);
    RevCommit commit = createMock(RevCommit.class);
    CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null);
    expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.MANDATORY).atLeastOnce();
    expect(commit.getFullMessage()).andReturn("bug#4711, bug#42").atLeastOnce();
    expect(commit.getId()).andReturn(commit).anyTimes();
    expect(commit.getName()).andReturn("TestCommit").anyTimes();
    expect(issueExtractor.getIssueIds("bug#4711, bug#42")).andReturn(new String[] { "4711", "42" }).atLeastOnce();
    ItsServerInfo serverInfo = createMock(ItsServerInfo.class);
    expect(itsServer.getServer(project.getName())).andReturn(serverInfo);
    expect(itsServer.getServer(project.getName())).andReturn(serverInfo);
    expect(itsFacade.exists(serverInfo, "4711")).andReturn(true).atLeastOnce();
    expect(itsFacade.exists(serverInfo, "42")).andReturn(true).atLeastOnce();
    replayMocks();
    ret = ivc.onCommitReceived(event);
    assertEmptyList(ret);
}
#method_after
public void testMandatoryMatchingMultiple() throws CommitValidationException, IOException {
    List<CommitValidationMessage> ret;
    ItsValidateComment ivc = injector.getInstance(ItsValidateComment.class);
    ReceiveCommand command = createMock(ReceiveCommand.class);
    RevCommit commit = createMock(RevCommit.class);
    CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null);
    expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.MANDATORY).atLeastOnce();
    expect(commit.getFullMessage()).andReturn("bug#4711, bug#42").atLeastOnce();
    expect(commit.getId()).andReturn(commit).anyTimes();
    expect(commit.getName()).andReturn("TestCommit").anyTimes();
    expect(issueExtractor.getIssueIds("bug#4711, bug#42")).andReturn(new String[] { "4711", "42" }).atLeastOnce();
    expect(itsFacadeFactory.getFacade(project.getNameKey())).andReturn(itsFacade).anyTimes();
    expect(itsFacade.exists("4711")).andReturn(true).atLeastOnce();
    expect(itsFacade.exists("42")).andReturn(true).atLeastOnce();
    replayMocks();
    ret = ivc.onCommitReceived(event);
    assertEmptyList(ret);
}
#end_block

#method_before
public void testSuggestedMatchingMultipleOneNonExsting() throws CommitValidationException, IOException {
    List<CommitValidationMessage> ret;
    ItsValidateComment ivc = injector.getInstance(ItsValidateComment.class);
    ReceiveCommand command = createMock(ReceiveCommand.class);
    RevCommit commit = createMock(RevCommit.class);
    CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null);
    expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.SUGGESTED).atLeastOnce();
    expect(commit.getFullMessage()).andReturn("bug#4711, bug#42").atLeastOnce();
    expect(commit.getId()).andReturn(commit).anyTimes();
    expect(commit.getName()).andReturn("TestCommit").anyTimes();
    expect(issueExtractor.getIssueIds("bug#4711, bug#42")).andReturn(new String[] { "4711", "42" }).atLeastOnce();
    ItsServerInfo serverInfo = createMock(ItsServerInfo.class);
    expect(itsServer.getServer(project.getName())).andReturn(serverInfo);
    expect(itsServer.getServer(project.getName())).andReturn(serverInfo);
    expect(itsFacade.exists(serverInfo, "4711")).andReturn(false).atLeastOnce();
    expect(itsFacade.exists(serverInfo, "42")).andReturn(true).atLeastOnce();
    replayMocks();
    ret = ivc.onCommitReceived(event);
    assertEquals("Size of returned CommitValidationMessages does not match", 1, ret.size());
    assertTrue("First CommitValidationMessages does not contain " + "'Non-existing'", ret.get(0).getMessage().contains("Non-existing"));
    assertTrue("First CommitValidationMessages does not contain '4711'", ret.get(0).getMessage().contains("4711"));
    assertFalse("First CommitValidationMessages contains '42', although " + "that bug exists", ret.get(0).getMessage().contains("42"));
}
#method_after
public void testSuggestedMatchingMultipleOneNonExsting() throws CommitValidationException, IOException {
    List<CommitValidationMessage> ret;
    ItsValidateComment ivc = injector.getInstance(ItsValidateComment.class);
    ReceiveCommand command = createMock(ReceiveCommand.class);
    RevCommit commit = createMock(RevCommit.class);
    CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null);
    expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.SUGGESTED).atLeastOnce();
    expect(commit.getFullMessage()).andReturn("bug#4711, bug#42").atLeastOnce();
    expect(commit.getId()).andReturn(commit).anyTimes();
    expect(commit.getName()).andReturn("TestCommit").anyTimes();
    expect(issueExtractor.getIssueIds("bug#4711, bug#42")).andReturn(new String[] { "4711", "42" }).atLeastOnce();
    expect(itsFacadeFactory.getFacade(project.getNameKey())).andReturn(itsFacade).anyTimes();
    expect(itsFacade.exists("4711")).andReturn(false).atLeastOnce();
    expect(itsFacade.exists("42")).andReturn(true).atLeastOnce();
    replayMocks();
    ret = ivc.onCommitReceived(event);
    assertEquals("Size of returned CommitValidationMessages does not match", 1, ret.size());
    assertTrue("First CommitValidationMessages does not contain " + "'Non-existing'", ret.get(0).getMessage().contains("Non-existing"));
    assertTrue("First CommitValidationMessages does not contain '4711'", ret.get(0).getMessage().contains("4711"));
    assertFalse("First CommitValidationMessages contains '42', although " + "that bug exists", ret.get(0).getMessage().contains("42"));
}
#end_block

#method_before
public void testMandatoryMatchingMultipleOneNonExsting() throws IOException {
    ItsValidateComment ivc = injector.getInstance(ItsValidateComment.class);
    ReceiveCommand command = createMock(ReceiveCommand.class);
    RevCommit commit = createMock(RevCommit.class);
    CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null);
    expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.MANDATORY).atLeastOnce();
    expect(commit.getFullMessage()).andReturn("bug#4711, bug#42").atLeastOnce();
    expect(commit.getId()).andReturn(commit).anyTimes();
    expect(commit.getName()).andReturn("TestCommit").anyTimes();
    expect(issueExtractor.getIssueIds("bug#4711, bug#42")).andReturn(new String[] { "4711", "42" }).atLeastOnce();
    ItsServerInfo serverInfo = createMock(ItsServerInfo.class);
    expect(itsServer.getServer(project.getName())).andReturn(serverInfo);
    expect(itsServer.getServer(project.getName())).andReturn(serverInfo);
    expect(itsFacade.exists(serverInfo, "4711")).andReturn(false).atLeastOnce();
    expect(itsFacade.exists(serverInfo, "42")).andReturn(true).atLeastOnce();
    replayMocks();
    try {
        ivc.onCommitReceived(event);
        fail("onCommitReceived did not throw any exception");
    } catch (CommitValidationException e) {
        assertTrue("Message of thrown CommitValidationException does not " + "contain 'Non-existing'", e.getMessage().contains("Non-existing"));
    }
}
#method_after
public void testMandatoryMatchingMultipleOneNonExsting() throws IOException {
    ItsValidateComment ivc = injector.getInstance(ItsValidateComment.class);
    ReceiveCommand command = createMock(ReceiveCommand.class);
    RevCommit commit = createMock(RevCommit.class);
    CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null);
    expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.MANDATORY).atLeastOnce();
    expect(commit.getFullMessage()).andReturn("bug#4711, bug#42").atLeastOnce();
    expect(commit.getId()).andReturn(commit).anyTimes();
    expect(commit.getName()).andReturn("TestCommit").anyTimes();
    expect(issueExtractor.getIssueIds("bug#4711, bug#42")).andReturn(new String[] { "4711", "42" }).atLeastOnce();
    expect(itsFacadeFactory.getFacade(project.getNameKey())).andReturn(itsFacade).anyTimes();
    expect(itsFacade.exists("4711")).andReturn(false).atLeastOnce();
    expect(itsFacade.exists("42")).andReturn(true).atLeastOnce();
    replayMocks();
    try {
        ivc.onCommitReceived(event);
        fail("onCommitReceived did not throw any exception");
    } catch (CommitValidationException e) {
        assertTrue("Message of thrown CommitValidationException does not " + "contain 'Non-existing'", e.getMessage().contains("Non-existing"));
    }
}
#end_block

#method_before
public void testSuggestedMatchingMultipleSomeNonExsting() throws CommitValidationException, IOException {
    List<CommitValidationMessage> ret;
    ItsValidateComment ivc = injector.getInstance(ItsValidateComment.class);
    ReceiveCommand command = createMock(ReceiveCommand.class);
    RevCommit commit = createMock(RevCommit.class);
    CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null);
    expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.SUGGESTED).atLeastOnce();
    expect(commit.getFullMessage()).andReturn("bug#4711, bug#42").atLeastOnce();
    expect(commit.getId()).andReturn(commit).anyTimes();
    expect(commit.getName()).andReturn("TestCommit").anyTimes();
    expect(issueExtractor.getIssueIds("bug#4711, bug#42")).andReturn(new String[] { "4711", "42" }).atLeastOnce();
    ItsServerInfo serverInfo = createMock(ItsServerInfo.class);
    expect(itsServer.getServer(project.getName())).andReturn(serverInfo);
    expect(itsServer.getServer(project.getName())).andReturn(serverInfo);
    expect(itsFacade.exists(serverInfo, "4711")).andReturn(false).atLeastOnce();
    expect(itsFacade.exists(serverInfo, "42")).andReturn(false).atLeastOnce();
    replayMocks();
    ret = ivc.onCommitReceived(event);
    assertEquals("Size of returned CommitValidationMessages does not match", 1, ret.size());
    assertTrue("First CommitValidationMessages does not contain " + "'Non-existing'", ret.get(0).getMessage().contains("Non-existing"));
    assertTrue("First CommitValidationMessages does not contain '4711'", ret.get(0).getMessage().contains("4711"));
    assertTrue("First CommitValidationMessages does not contain '42'", ret.get(0).getMessage().contains("42"));
}
#method_after
public void testSuggestedMatchingMultipleSomeNonExsting() throws CommitValidationException, IOException {
    List<CommitValidationMessage> ret;
    ItsValidateComment ivc = injector.getInstance(ItsValidateComment.class);
    ReceiveCommand command = createMock(ReceiveCommand.class);
    RevCommit commit = createMock(RevCommit.class);
    CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null);
    expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.SUGGESTED).atLeastOnce();
    expect(commit.getFullMessage()).andReturn("bug#4711, bug#42").atLeastOnce();
    expect(commit.getId()).andReturn(commit).anyTimes();
    expect(commit.getName()).andReturn("TestCommit").anyTimes();
    expect(issueExtractor.getIssueIds("bug#4711, bug#42")).andReturn(new String[] { "4711", "42" }).atLeastOnce();
    expect(itsFacadeFactory.getFacade(project.getNameKey())).andReturn(itsFacade).anyTimes();
    expect(itsFacade.exists("4711")).andReturn(false).atLeastOnce();
    expect(itsFacade.exists("42")).andReturn(false).atLeastOnce();
    replayMocks();
    ret = ivc.onCommitReceived(event);
    assertEquals("Size of returned CommitValidationMessages does not match", 1, ret.size());
    assertTrue("First CommitValidationMessages does not contain " + "'Non-existing'", ret.get(0).getMessage().contains("Non-existing"));
    assertTrue("First CommitValidationMessages does not contain '4711'", ret.get(0).getMessage().contains("4711"));
    assertTrue("First CommitValidationMessages does not contain '42'", ret.get(0).getMessage().contains("42"));
}
#end_block

#method_before
public void testMandatoryMatchingMultipleSomeNonExsting() throws IOException {
    ItsValidateComment ivc = injector.getInstance(ItsValidateComment.class);
    ReceiveCommand command = createMock(ReceiveCommand.class);
    RevCommit commit = createMock(RevCommit.class);
    CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null);
    expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.MANDATORY).atLeastOnce();
    expect(commit.getFullMessage()).andReturn("bug#4711, bug#42").atLeastOnce();
    expect(commit.getId()).andReturn(commit).anyTimes();
    expect(commit.getName()).andReturn("TestCommit").anyTimes();
    expect(issueExtractor.getIssueIds("bug#4711, bug#42")).andReturn(new String[] { "4711", "42" }).atLeastOnce();
    ItsServerInfo serverInfo = createMock(ItsServerInfo.class);
    expect(itsServer.getServer(project.getName())).andReturn(serverInfo);
    expect(itsServer.getServer(project.getName())).andReturn(serverInfo);
    expect(itsFacade.exists(serverInfo, "4711")).andReturn(false).atLeastOnce();
    expect(itsFacade.exists(serverInfo, "42")).andReturn(false).atLeastOnce();
    replayMocks();
    try {
        ivc.onCommitReceived(event);
        fail("onCommitReceived did not throw any exception");
    } catch (CommitValidationException e) {
        assertTrue("Message of thrown CommitValidationException does not " + "contain 'Non-existing'", e.getMessage().contains("Non-existing"));
    }
}
#method_after
public void testMandatoryMatchingMultipleSomeNonExsting() throws IOException {
    ItsValidateComment ivc = injector.getInstance(ItsValidateComment.class);
    ReceiveCommand command = createMock(ReceiveCommand.class);
    RevCommit commit = createMock(RevCommit.class);
    CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null);
    expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.MANDATORY).atLeastOnce();
    expect(commit.getFullMessage()).andReturn("bug#4711, bug#42").atLeastOnce();
    expect(commit.getId()).andReturn(commit).anyTimes();
    expect(commit.getName()).andReturn("TestCommit").anyTimes();
    expect(issueExtractor.getIssueIds("bug#4711, bug#42")).andReturn(new String[] { "4711", "42" }).atLeastOnce();
    expect(itsFacadeFactory.getFacade(project.getNameKey())).andReturn(itsFacade).anyTimes();
    expect(itsFacade.exists("4711")).andReturn(false).atLeastOnce();
    expect(itsFacade.exists("42")).andReturn(true).atLeastOnce();
    replayMocks();
    try {
        ivc.onCommitReceived(event);
        fail("onCommitReceived did not throw any exception");
    } catch (CommitValidationException e) {
        assertTrue("Message of thrown CommitValidationException does not " + "contain 'Non-existing'", e.getMessage().contains("Non-existing"));
    }
}
#end_block

#method_before
public void testSuggestedMatchingMultipleIOExceptionIsNonExsting() throws CommitValidationException, IOException {
    List<CommitValidationMessage> ret;
    ItsValidateComment ivc = injector.getInstance(ItsValidateComment.class);
    ReceiveCommand command = createMock(ReceiveCommand.class);
    RevCommit commit = createMock(RevCommit.class);
    CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null);
    expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.SUGGESTED).atLeastOnce();
    expect(commit.getFullMessage()).andReturn("bug#4711, bug#42").atLeastOnce();
    expect(commit.getId()).andReturn(commit).anyTimes();
    expect(commit.getName()).andReturn("TestCommit").anyTimes();
    expect(issueExtractor.getIssueIds("bug#4711, bug#42")).andReturn(new String[] { "4711", "42" }).atLeastOnce();
    ItsServerInfo serverInfo = createMock(ItsServerInfo.class);
    expect(itsServer.getServer(project.getName())).andReturn(serverInfo);
    expect(itsServer.getServer(project.getName())).andReturn(serverInfo);
    expect(itsFacade.exists(serverInfo, "4711")).andThrow(new IOException("InjectedEx1")).atLeastOnce();
    expect(itsFacade.exists(serverInfo, "42")).andReturn(false).atLeastOnce();
    replayMocks();
    ret = ivc.onCommitReceived(event);
    assertEquals("Size of returned CommitValidationMessages does not match", 2, ret.size());
    assertTrue("First CommitValidationMessages does not contain " + "'Failed'", ret.get(0).getMessage().contains("Failed"));
    assertTrue("First CommitValidationMessages does not contain '4711'", ret.get(0).getMessage().contains("4711"));
    assertFalse("First CommitValidationMessages contains '42', although " + "that bug exists", ret.get(0).getMessage().contains("42"));
    assertTrue("Second CommitValidationMessages does not contain " + "'Non-existing'", ret.get(1).getMessage().contains("Non-existing"));
    assertTrue("Second CommitValidationMessages does not contain '4711'", ret.get(1).getMessage().contains("4711"));
    assertTrue("Second CommitValidationMessages does not contain '42'", ret.get(1).getMessage().contains("42"));
    assertLogMessageContains("4711");
}
#method_after
public void testSuggestedMatchingMultipleIOExceptionIsNonExsting() throws CommitValidationException, IOException {
    List<CommitValidationMessage> ret;
    ItsValidateComment ivc = injector.getInstance(ItsValidateComment.class);
    ReceiveCommand command = createMock(ReceiveCommand.class);
    RevCommit commit = createMock(RevCommit.class);
    CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null);
    expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.SUGGESTED).atLeastOnce();
    expect(commit.getFullMessage()).andReturn("bug#4711, bug#42").atLeastOnce();
    expect(commit.getId()).andReturn(commit).anyTimes();
    expect(commit.getName()).andReturn("TestCommit").anyTimes();
    expect(issueExtractor.getIssueIds("bug#4711, bug#42")).andReturn(new String[] { "4711", "42" }).atLeastOnce();
    expect(itsFacadeFactory.getFacade(project.getNameKey())).andReturn(itsFacade).anyTimes();
    expect(itsFacade.exists("4711")).andThrow(new IOException("InjectedEx1")).atLeastOnce();
    expect(itsFacade.exists("42")).andReturn(false).atLeastOnce();
    replayMocks();
    ret = ivc.onCommitReceived(event);
    assertEquals("Size of returned CommitValidationMessages does not match", 2, ret.size());
    assertTrue("First CommitValidationMessages does not contain " + "'Failed'", ret.get(0).getMessage().contains("Failed"));
    assertTrue("First CommitValidationMessages does not contain '4711'", ret.get(0).getMessage().contains("4711"));
    assertFalse("First CommitValidationMessages contains '42', although " + "that bug exists", ret.get(0).getMessage().contains("42"));
    assertTrue("Second CommitValidationMessages does not contain " + "'Non-existing'", ret.get(1).getMessage().contains("Non-existing"));
    assertTrue("Second CommitValidationMessages does not contain '4711'", ret.get(1).getMessage().contains("4711"));
    assertTrue("Second CommitValidationMessages does not contain '42'", ret.get(1).getMessage().contains("42"));
    assertLogMessageContains("4711");
}
#end_block

#method_before
@Override
protected void configure() {
    bind(String.class).annotatedWith(PluginName.class).toInstance("ItsTestName");
    issueExtractor = createMock(IssueExtractor.class);
    bind(IssueExtractor.class).toInstance(issueExtractor);
    itsFacade = createMock(ItsFacade.class);
    bind(ItsFacade.class).toInstance(itsFacade);
    itsConfig = createMock(ItsConfig.class);
    bind(ItsConfig.class).toInstance(itsConfig);
    itsServer = createMock(ItsServer.class);
    bind(ItsServer.class).toInstance(itsServer);
}
#method_after
@Override
protected void configure() {
    bind(String.class).annotatedWith(PluginName.class).toInstance("ItsTestName");
    issueExtractor = createMock(IssueExtractor.class);
    bind(IssueExtractor.class).toInstance(issueExtractor);
    itsFacade = createMock(ItsFacade.class);
    bind(ItsFacade.class).toInstance(itsFacade);
    itsConfig = createMock(ItsConfig.class);
    bind(ItsConfig.class).toInstance(itsConfig);
    itsFacadeFactory = createMock(ItsFacadeFactory.class);
    bind(ItsFacadeFactory.class).toInstance(itsFacadeFactory);
}
#end_block

#method_before
public void testNoPropertySets() {
    ActionController actionController = createActionController();
    ChangeEvent event = createMock(ChangeEvent.class);
    Set<Set<Property>> propertySets = Collections.emptySet();
    expect(propertyExtractor.extractFrom(event)).andReturn(propertySets).anyTimes();
    replayMocks();
    actionController.onEvent(event);
}
#method_after
public void testNoPropertySets() {
    ActionController actionController = createActionController();
    ChangeEvent event = createMock(ChangeEvent.class);
    Set<Map<String, String>> propertySets = new HashSet<>();
    expect(propertyExtractor.extractFrom(event)).andReturn(propertySets).anyTimes();
    replayMocks();
    actionController.onEvent(event);
}
#end_block

#method_before
@Override
protected void configure() {
    propertyExtractor = createMock(PropertyExtractor.class);
    bind(PropertyExtractor.class).toInstance(propertyExtractor);
    ruleBase = createMock(RuleBase.class);
    bind(RuleBase.class).toInstance(ruleBase);
    itsServer = createMock(ItsServer.class);
    bind(ItsServer.class).toInstance(itsServer);
    actionExecutor = createMock(ActionExecutor.class);
    bind(ActionExecutor.class).toInstance(actionExecutor);
    itsConfig = createMock(ItsConfig.class);
    bind(ItsConfig.class).toInstance(itsConfig);
}
#method_after
@Override
protected void configure() {
    propertyExtractor = createMock(PropertyExtractor.class);
    bind(PropertyExtractor.class).toInstance(propertyExtractor);
    ruleBase = createMock(RuleBase.class);
    bind(RuleBase.class).toInstance(ruleBase);
    actionExecutor = createMock(ActionExecutor.class);
    bind(ActionExecutor.class).toInstance(actionExecutor);
    itsConfig = createMock(ItsConfig.class);
    bind(ItsConfig.class).toInstance(itsConfig);
}
#end_block

#method_before
public void execute(ItsServerInfo server, String issue, Iterable<ActionRequest> actions, Set<Property> properties) {
    for (ActionRequest actionRequest : actions) {
        execute(server, issue, actionRequest, properties);
    }
}
#method_after
private void execute(String issue, ActionRequest actionRequest, Map<String, String> properties) {
    ItsFacade its = itsFactory.getFacade(new Project.NameKey(properties.get("project")));
    try {
        Action action = getAction(actionRequest.getName());
        if (action == null) {
            its.performAction(issue, actionRequest.getUnparsed());
        } else {
            action.execute(its, issue, actionRequest, properties);
        }
    } catch (IOException e) {
        log.error("Error while executing action " + actionRequest, e);
    }
}
#end_block

#method_before
private List<CommitValidationMessage> validCommit(String projectName, RevCommit commit) throws CommitValidationException {
    List<CommitValidationMessage> ret = Lists.newArrayList();
    ItsAssociationPolicy associationPolicy = itsConfig.getItsAssociationPolicy();
    switch(associationPolicy) {
        case MANDATORY:
        case SUGGESTED:
            String commitMessage = commit.getFullMessage();
            String[] issueIds = issueExtractor.getIssueIds(commitMessage);
            String synopsis = null;
            String details = null;
            if (issueIds.length > 0) {
                List<String> nonExistingIssueIds = Lists.newArrayList();
                for (String issueId : issueIds) {
                    boolean exists = false;
                    try {
                        exists = client.exists(itsServer.getServer(projectName), issueId);
                    } catch (IOException e) {
                        synopsis = "Failed to check whether or not issue " + issueId + " exists";
                        log.warn(synopsis, e);
                        details = e.toString();
                        ret.add(commitValidationFailure(synopsis, details));
                    }
                    if (!exists) {
                        nonExistingIssueIds.add(issueId);
                    }
                }
                if (!nonExistingIssueIds.isEmpty()) {
                    synopsis = "Non-existing issue ids referenced in commit message";
                    StringBuilder sb = new StringBuilder();
                    sb.append("The issue-ids\n");
                    for (String issueId : nonExistingIssueIds) {
                        sb.append("    * ");
                        sb.append(issueId);
                        sb.append("\n");
                    }
                    sb.append("are referenced in the commit message of\n");
                    sb.append(commit.getId().getName());
                    sb.append(",\n");
                    sb.append("but do not exist in ");
                    sb.append(pluginName);
                    sb.append(" Issue-Tracker");
                    details = sb.toString();
                    ret.add(commitValidationFailure(synopsis, details));
                }
            } else {
                synopsis = "Missing issue-id in commit message";
                StringBuilder sb = new StringBuilder();
                sb.append("Commit ");
                sb.append(commit.getId().getName());
                sb.append(" not associated to any issue\n");
                sb.append("\n");
                sb.append("Hint: insert one or more issue-id anywhere in the ");
                sb.append("commit message.\n");
                sb.append("      Issue-ids are strings matching ");
                sb.append(itsConfig.getIssuePattern().pattern());
                sb.append("\n");
                sb.append("      and are pointing to existing tickets on ");
                sb.append(pluginName);
                sb.append(" Issue-Tracker");
                details = sb.toString();
                ret.add(commitValidationFailure(synopsis, details));
            }
            break;
        case OPTIONAL:
        default:
            break;
    }
    return ret;
}
#method_after
private List<CommitValidationMessage> validCommit(Project.NameKey project, RevCommit commit) throws CommitValidationException {
    List<CommitValidationMessage> ret = Lists.newArrayList();
    ItsAssociationPolicy associationPolicy = itsConfig.getItsAssociationPolicy();
    switch(associationPolicy) {
        case MANDATORY:
        case SUGGESTED:
            String commitMessage = commit.getFullMessage();
            String[] issueIds = issueExtractor.getIssueIds(commitMessage);
            String synopsis = null;
            String details = null;
            if (issueIds.length > 0) {
                List<String> nonExistingIssueIds = Lists.newArrayList();
                client = itsFacadeFactory.getFacade(project);
                for (String issueId : issueIds) {
                    boolean exists = false;
                    try {
                        exists = client.exists(issueId);
                    } catch (IOException e) {
                        synopsis = "Failed to check whether or not issue " + issueId + " exists";
                        log.warn(synopsis, e);
                        details = e.toString();
                        ret.add(commitValidationFailure(synopsis, details));
                    }
                    if (!exists) {
                        nonExistingIssueIds.add(issueId);
                    }
                }
                if (!nonExistingIssueIds.isEmpty()) {
                    synopsis = "Non-existing issue ids referenced in commit message";
                    StringBuilder sb = new StringBuilder();
                    sb.append("The issue-ids\n");
                    for (String issueId : nonExistingIssueIds) {
                        sb.append("    * ");
                        sb.append(issueId);
                        sb.append("\n");
                    }
                    sb.append("are referenced in the commit message of\n");
                    sb.append(commit.getId().getName());
                    sb.append(",\n");
                    sb.append("but do not exist in ");
                    sb.append(pluginName);
                    sb.append(" Issue-Tracker");
                    details = sb.toString();
                    ret.add(commitValidationFailure(synopsis, details));
                }
            } else if (!itsConfig.getDummyIssuePattern().map(p -> p.matcher(commitMessage).find()).orElse(false)) {
                synopsis = "Missing issue-id in commit message";
                StringBuilder sb = new StringBuilder();
                sb.append("Commit ");
                sb.append(commit.getId().getName());
                sb.append(" not associated to any issue\n");
                sb.append("\n");
                sb.append("Hint: insert one or more issue-id anywhere in the ");
                sb.append("commit message.\n");
                sb.append("      Issue-ids are strings matching ");
                sb.append(itsConfig.getIssuePattern().pattern());
                sb.append("\n");
                sb.append("      and are pointing to existing tickets on ");
                sb.append(pluginName);
                sb.append(" Issue-Tracker");
                details = sb.toString();
                ret.add(commitValidationFailure(synopsis, details));
            }
            break;
        case OPTIONAL:
        default:
            break;
    }
    return ret;
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    ItsConfig.setCurrentProjectName(receiveEvent.getProjectNameKey());
    if (itsConfig.isEnabled(receiveEvent.getProjectNameKey(), receiveEvent.getRefName())) {
        return validCommit(receiveEvent.getProjectNameKey().get(), receiveEvent.commit);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    Project.NameKey projectName = receiveEvent.getProjectNameKey();
    ItsConfig.setCurrentProjectName(projectName);
    if (itsConfig.isEnabled(projectName, receiveEvent.getRefName())) {
        return validCommit(projectName, receiveEvent.commit);
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
public Description getDescription(ChangeResource rsrc) {
    boolean isProjectOwner;
    try {
        isProjectOwner = projectControlFactory.controlFor(rsrc.getProject(), rsrc.getUser()).isOwner();
    } catch (IOException | NoSuchProjectException e) {
        isProjectOwner = false;
        log.error("Cannot retrieve project own ACL", e);
    }
    return new Description().setLabel("WIP").setTitle("Set Work In Progress").setVisible(and(rsrc.getChange().getStatus() == Status.NEW && !rsrc.getChange().isWorkInProgress(), or(rsrc.isUserOwner(), or(isProjectOwner, permissionBackend.user(self).testCond(GlobalPermission.ADMINISTRATE_SERVER)))));
}
#method_after
@Override
public Description getDescription(ChangeResource rsrc) {
    boolean isProjectOwner;
    try {
        isProjectOwner = projectControlFactory.controlFor(rsrc.getProject(), rsrc.getUser()).isOwner();
    } catch (IOException | NoSuchProjectException e) {
        isProjectOwner = false;
        log.error("Cannot retrieve project owner ACL", e);
    }
    return new Description().setLabel("WIP").setTitle("Set Work In Progress").setVisible(and(rsrc.getChange().getStatus() == Status.NEW && !rsrc.getChange().isWorkInProgress(), or(rsrc.isUserOwner(), or(isProjectOwner, permissionBackend.user(self).testCond(GlobalPermission.ADMINISTRATE_SERVER)))));
}
#end_block

#method_before
@Override
public Description getDescription(ChangeResource rsrc) {
    boolean isProjectOwner;
    try {
        isProjectOwner = projectControlFactory.controlFor(rsrc.getProject(), rsrc.getUser()).isOwner();
    } catch (IOException | NoSuchProjectException e) {
        isProjectOwner = false;
        log.error("Cannot retrieve project own ACL", e);
    }
    return new Description().setLabel("Start Review").setTitle("Set Ready For Review").setVisible(and(rsrc.getChange().getStatus() == Status.NEW && rsrc.getChange().isWorkInProgress(), or(rsrc.isUserOwner(), or(isProjectOwner, permissionBackend.user(self).testCond(GlobalPermission.ADMINISTRATE_SERVER)))));
}
#method_after
@Override
public Description getDescription(ChangeResource rsrc) {
    boolean isProjectOwner;
    try {
        isProjectOwner = projectControlFactory.controlFor(rsrc.getProject(), rsrc.getUser()).isOwner();
    } catch (IOException | NoSuchProjectException e) {
        isProjectOwner = false;
        log.error("Cannot retrieve project owner ACL", e);
    }
    return new Description().setLabel("Start Review").setTitle("Set Ready For Review").setVisible(and(rsrc.getChange().getStatus() == Status.NEW && rsrc.getChange().isWorkInProgress(), or(rsrc.isUserOwner(), or(isProjectOwner, permissionBackend.user(self).testCond(GlobalPermission.ADMINISTRATE_SERVER)))));
}
#end_block

#method_before
private Collection<Rule> getRulesFromFile(File ruleFile) {
    if (ruleFile.exists()) {
        FileBasedConfig cfg = new FileBasedConfig(ruleFile, FS.DETECTED);
        try {
            cfg.load();
            return getRulesFromConfig(cfg);
        } catch (IOException | ConfigInvalidException e) {
            log.error("Invalid ITS action configuration", e);
        }
    }
    return Collections.emptyList();
}
#method_after
private static Collection<Rule> getRulesFromFile(RulesConfigReader rulesConfigReader, File ruleFile) {
    if (ruleFile.exists()) {
        FileBasedConfig cfg = new FileBasedConfig(ruleFile, FS.DETECTED);
        try {
            cfg.load();
            return rulesConfigReader.getRulesFromConfig(cfg);
        } catch (IOException | ConfigInvalidException e) {
            log.error("Invalid ITS action configuration", e);
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
public Collection<ActionRequest> actionRequestsFor(Collection<Property> properties) {
    String projectName = getProjectFromProperties(properties);
    Collection<Rule> fromProjectConfig = getRulesForProject(projectName);
    Collection<Rule> rulesToAdd = !fromProjectConfig.isEmpty() ? fromProjectConfig : rules;
    Collection<ActionRequest> actions = new ArrayList<>();
    for (Rule rule : rulesToAdd) {
        actions.addAll(rule.actionRequestsFor(properties));
    }
    return actions;
}
#method_after
public Collection<ActionRequest> actionRequestsFor(Map<String, String> properties) {
    String projectName = properties.get("project");
    Collection<Rule> fromProjectConfig = rulesProjectCache.get(projectName);
    Collection<Rule> rulesToAdd = !fromProjectConfig.isEmpty() ? fromProjectConfig : rules;
    if (rulesToAdd.isEmpty() && !globalRuleFile.exists() && !itsSpecificRuleFile.exists()) {
        log.warn("Neither global rule file {} nor Its specific rule file {} exist and no rules are " + "configured for project {}. Please configure rules.", globalRuleFile, itsSpecificRuleFile, projectName);
        return Collections.emptyList();
    }
    Collection<ActionRequest> actions = new ArrayList<>();
    for (Rule rule : rulesToAdd) {
        actions.addAll(rule.actionRequestsFor(properties));
    }
    return actions;
}
#end_block

#method_before
public void testActionRequestsForSimple() throws IOException {
    injectRuleBase("[rule \"rule1\"]\n" + "\taction = action1");
    Rule rule1 = createMock(Rule.class);
    expect(ruleFactory.create(RULE_1)).andReturn(rule1);
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    expect(actionRequestFactory.create(ACTION_1)).andReturn(actionRequest1);
    rule1.addActionRequest(actionRequest1);
    Property property1 = createMock(Property.class);
    expect(property1.getKey()).andReturn(PROJECT_KEY);
    expect(property1.getValue()).andReturn("");
    Collection<Property> properties = ImmutableList.of(property1);
    List<ActionRequest> rule1Match = Lists.newArrayListWithCapacity(1);
    rule1Match.add(actionRequest1);
    expect(rule1.actionRequestsFor(properties)).andReturn(rule1Match);
    replayMocks();
    RuleBase ruleBase = createRuleBase();
    Collection<ActionRequest> actual = ruleBase.actionRequestsFor(properties);
    List<ActionRequest> expected = Lists.newArrayListWithCapacity(3);
    expected.add(actionRequest1);
    assertEquals("Matched actionRequests do not match", expected, actual);
}
#method_after
public void testActionRequestsForSimple() throws IOException {
    String rules = "[rule \"rule1\"]\n\taction = action1\n";
    injectRuleBase(rules);
    Rule rule1 = createMock(Rule.class);
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    Map<String, String> properties = ImmutableMap.of(PROJECT_KEY, TEST_PROJECT);
    List<ActionRequest> rule1Match = Lists.newArrayListWithCapacity(1);
    rule1Match.add(actionRequest1);
    expect(rule1.actionRequestsFor(properties)).andReturn(rule1Match);
    expect(rulesConfigReader.getRulesFromConfig(isA(Config.class))).andReturn(ImmutableList.of(rule1)).once();
    expect(rulesProjectCache.get(TEST_PROJECT)).andReturn(ImmutableList.of());
    replayMocks();
    RuleBase ruleBase = createRuleBase();
    Collection<ActionRequest> actual = ruleBase.actionRequestsFor(properties);
    List<ActionRequest> expected = Lists.newArrayListWithCapacity(3);
    expected.add(actionRequest1);
    assertEquals("Matched actionRequests do not match", expected, actual);
}
#end_block

#method_before
public void testActionRequestsForExtended() throws IOException {
    injectRuleBase("[rule \"rule1\"]\n" + "\taction = action1\n" + "\taction = action2\n" + "\n" + "[rule \"rule2\"]\n" + "\taction = action3");
    Rule rule1 = createMock(Rule.class);
    expect(ruleFactory.create(RULE_1)).andReturn(rule1);
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    expect(actionRequestFactory.create(ACTION_1)).andReturn(actionRequest1);
    rule1.addActionRequest(actionRequest1);
    ActionRequest actionRequest2 = createMock(ActionRequest.class);
    expect(actionRequestFactory.create("action2")).andReturn(actionRequest2);
    rule1.addActionRequest(actionRequest2);
    Rule rule2 = createMock(Rule.class);
    expect(ruleFactory.create("rule2")).andReturn(rule2);
    ActionRequest actionRequest3 = createMock(ActionRequest.class);
    expect(actionRequestFactory.create("action3")).andReturn(actionRequest3);
    rule2.addActionRequest(actionRequest3);
    Collection<Property> properties = Lists.newArrayListWithCapacity(1);
    Property property1 = createMock(Property.class);
    expect(property1.getKey()).andReturn(PROJECT_KEY);
    expect(property1.getValue()).andReturn(TEST_PROJECT);
    properties.add(property1);
    List<ActionRequest> rule1Match = Lists.newArrayListWithCapacity(2);
    rule1Match.add(actionRequest1);
    rule1Match.add(actionRequest2);
    expect(rule1.actionRequestsFor(properties)).andReturn(rule1Match);
    List<ActionRequest> rule2Match = Lists.newArrayListWithCapacity(1);
    rule2Match.add(actionRequest3);
    expect(rule2.actionRequestsFor(properties)).andReturn(rule2Match);
    ProjectState projectState = createMock(ProjectState.class);
    ProjectLevelConfig projectLevelConfigGlobal = createMock(ProjectLevelConfig.class);
    expect(projectLevelConfigGlobal.get()).andReturn(new Config());
    expect(projectState.getConfig(RuleBaseKind.GLOBAL.fileName)).andReturn(projectLevelConfigGlobal);
    ProjectLevelConfig projectLevelConfigPlugin = createMock(ProjectLevelConfig.class);
    expect(projectLevelConfigPlugin.get()).andReturn(new Config());
    expect(projectState.getConfig(RuleBaseKind.ITS.fileName)).andReturn(projectLevelConfigPlugin);
    expect(projectState.parents()).andReturn(FluentIterable.of());
    expect(projectCache.checkedGet(new Project.NameKey(TEST_PROJECT))).andReturn(projectState);
    replayMocks();
    RuleBase ruleBase = createRuleBase();
    Collection<ActionRequest> actual = ruleBase.actionRequestsFor(properties);
    List<ActionRequest> expected = Lists.newArrayListWithCapacity(3);
    expected.add(actionRequest1);
    expected.add(actionRequest2);
    expected.add(actionRequest3);
    assertEquals("Matched actionRequests do not match", expected, actual);
}
#method_after
public void testActionRequestsForExtended() throws IOException {
    injectRuleBase("[rule \"rule1\"]\n" + "\taction = action1\n" + "\taction = action2\n" + "\n" + "[rule \"rule2\"]\n" + "\taction = action3\n");
    Rule rule1 = createMock(Rule.class);
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    ActionRequest actionRequest2 = createMock(ActionRequest.class);
    Rule rule2 = createMock(Rule.class);
    ActionRequest actionRequest3 = createMock(ActionRequest.class);
    Map<String, String> properties = ImmutableMap.of(PROJECT_KEY, TEST_PROJECT);
    List<ActionRequest> rule1Match = ImmutableList.of(actionRequest1, actionRequest2);
    expect(rule1.actionRequestsFor(properties)).andReturn(rule1Match).anyTimes();
    List<ActionRequest> rule2Match = ImmutableList.of(actionRequest3);
    expect(rule2.actionRequestsFor(properties)).andReturn(rule2Match).anyTimes();
    expect(rulesProjectCache.get(TEST_PROJECT)).andReturn(ImmutableList.of());
    expect(rulesConfigReader.getRulesFromConfig(isA(Config.class))).andReturn(ImmutableList.of(rule1, rule2)).andReturn(ImmutableList.of()).anyTimes();
    replayMocks();
    RuleBase ruleBase = createRuleBase();
    Collection<ActionRequest> actual = ruleBase.actionRequestsFor(properties);
    List<ActionRequest> expected = ImmutableList.of(actionRequest1, actionRequest2, actionRequest3);
    assertEquals("Matched actionRequests do not match", expected, actual);
}
#end_block

#method_before
public void testProjectConfigIsLoaded() throws IOException {
    Rule rule1 = createMock(Rule.class);
    expect(ruleFactory.create(RULE_1)).andReturn(rule1);
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    expect(actionRequestFactory.create(ACTION_1)).andReturn(actionRequest1);
    rule1.addActionRequest(actionRequest1);
    Condition condition1 = createMock(Condition.class);
    expect(conditionFactory.create(CONDITION_KEY, VALUE_1)).andReturn(condition1);
    rule1.addCondition(condition1);
    Property property1 = createMock(Property.class);
    expect(property1.getKey()).andReturn(PROJECT_KEY);
    expect(property1.getValue()).andReturn(TEST_PROJECT);
    Collection<Property> properties = ImmutableList.of(property1);
    List<ActionRequest> rule1Match = ImmutableList.of(actionRequest1);
    expect(rule1.actionRequestsFor(properties)).andReturn(rule1Match);
    ProjectState projectState = createMock(ProjectState.class);
    ProjectLevelConfig projectLevelConfigGlobal = createMock(ProjectLevelConfig.class);
    Config projectGlobalCfg = new Config();
    projectGlobalCfg.setString(RULE_SECTION, RULE_1, CONDITION_KEY, VALUE_1);
    projectGlobalCfg.setString(RULE_SECTION, RULE_1, ACTION_KEY, ACTION_1);
    expect(projectLevelConfigGlobal.get()).andReturn(projectGlobalCfg);
    expect(projectState.getConfig(RuleBaseKind.GLOBAL.fileName)).andReturn(projectLevelConfigGlobal);
    ProjectLevelConfig projectLevelConfigPlugin = createMock(ProjectLevelConfig.class);
    expect(projectLevelConfigPlugin.get()).andReturn(new Config());
    expect(projectState.getConfig(RuleBaseKind.ITS.fileName)).andReturn(projectLevelConfigPlugin);
    expect(projectCache.checkedGet(new Project.NameKey(TEST_PROJECT))).andReturn(projectState);
    replayMocks();
    RuleBase ruleBase = createRuleBase();
    Collection<ActionRequest> actual = ruleBase.actionRequestsFor(properties);
    List<ActionRequest> expected = ImmutableList.of(actionRequest1);
    assertEquals("Matched actionRequests do not match", expected, actual);
    assertLogMessageContains("Neither global rule file");
}
#method_after
public void testProjectConfigIsLoaded() {
    Rule rule1 = createMock(Rule.class);
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    Map<String, String> properties = ImmutableMap.of(PROJECT_KEY, TEST_PROJECT);
    List<ActionRequest> rule1Match = ImmutableList.of(actionRequest1);
    expect(rule1.actionRequestsFor(properties)).andReturn(rule1Match);
    expect(rulesProjectCache.get(TEST_PROJECT)).andReturn(ImmutableList.of(rule1));
    replayMocks();
    RuleBase ruleBase = createRuleBase();
    Collection<ActionRequest> actual = ruleBase.actionRequestsFor(properties);
    List<ActionRequest> expected = ImmutableList.of(actionRequest1);
    assertEquals("Matched actionRequests do not match", expected, actual);
}
#end_block

#method_before
private void injectRuleBase(String rules, RuleBaseKind ruleBaseKind) throws IOException {
    Path ruleBaseFile = sitePath.resolve("etc").resolve("its").resolve(ruleBaseKind.fileName);
    Files.createDirectories(ruleBaseFile.getParent());
    Files.write(ruleBaseFile, rules.getBytes());
}
#method_after
private void injectRuleBase(String rules, RuleBaseKind ruleBaseKind) throws IOException {
    Path ruleBaseFile = itsPath.resolve(ruleBaseKind.fileName);
    Files.createDirectories(ruleBaseFile.getParent());
    Files.write(ruleBaseFile, rules.getBytes());
}
#end_block

#method_before
@Override
public void tearDown() throws Exception {
    if (cleanupSitePath) {
        if (Files.exists(sitePath)) {
            FileUtils.delete(sitePath.toFile(), FileUtils.RECURSIVE);
        }
    }
    super.tearDown();
}
#method_after
@Override
public void tearDown() throws Exception {
    if (cleanupSitePath) {
        if (Files.exists(itsPath)) {
            FileUtils.delete(itsPath.toFile(), FileUtils.RECURSIVE);
        }
    }
    super.tearDown();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(String.class).annotatedWith(PluginName.class).toInstance("ItsTestName");
    sitePath = randomTargetPath();
    assertFalse("sitePath already (" + sitePath + ") already exists", Files.exists(sitePath));
    cleanupSitePath = true;
    bind(Path.class).annotatedWith(SitePath.class).toInstance(sitePath);
    ruleFactory = createMock(Rule.Factory.class);
    bind(Rule.Factory.class).toInstance(ruleFactory);
    conditionFactory = createMock(Condition.Factory.class);
    bind(Condition.Factory.class).toInstance(conditionFactory);
    actionRequestFactory = createMock(ActionRequest.Factory.class);
    bind(ActionRequest.Factory.class).toInstance(actionRequestFactory);
    projectCache = createMock(ProjectCache.class);
    bind(ProjectCache.class).toInstance(projectCache);
}
#method_after
@Override
protected void configure() {
    bind(String.class).annotatedWith(PluginName.class).toInstance("ItsTestName");
    itsPath = randomTargetPath().resolve("etc").resolve("its");
    assertFalse("itsPath (" + itsPath + ") already exists", Files.exists(itsPath));
    cleanupSitePath = true;
    bind(Path.class).annotatedWith(ItsPath.class).toInstance(itsPath);
    rulesConfigReader = createMock(RulesConfigReader.class);
    bind(RulesConfigReader.class).toInstance(rulesConfigReader);
    rulesProjectCache = createMock(ItsRulesProjectCache.class);
    bind(ItsRulesProjectCache.class).toInstance(rulesProjectCache);
    bind(String.class).annotatedWith(GlobalRulesFileName.class).toInstance(RuleBaseKind.GLOBAL.fileName);
    bind(String.class).annotatedWith(PluginRulesFileName.class).toInstance(RuleBaseKind.ITS.fileName);
}
#end_block

#method_before
public static <T> Key<T> create(Class<T> clazz, Object... identifiers) {
    return new Key<>(clazz, ImmutableList.copyOf(identifiers));
}
#method_after
public static <T> Key<T> create(Class<T> clazz, Object identifier) {
    return new Key<>(clazz, ImmutableList.of(identifier));
}
#end_block

#method_before
public void testActionRequestsForSimple() throws IOException {
    String rules = "[rule \"rule1\"]\n\taction = action1\n";
    injectRuleBase(rules);
    Rule rule1 = createMock(Rule.class);
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    Collection<Property> properties = ImmutableList.of();
    List<ActionRequest> rule1Match = ImmutableList.of(actionRequest1);
    expect(rule1.actionRequestsFor(properties)).andReturn(rule1Match);
    Capture<Config> capturedConfig = createCapture();
    expect(rulesConfigReader.getRulesFromConfig(and(capture(capturedConfig), isA(Config.class)))).andReturn(ImmutableList.of(rule1)).once();
    replayMocks();
    RuleBase ruleBase = createRuleBase();
    Collection<ActionRequest> actual = ruleBase.actionRequestsFor(properties);
    List<ActionRequest> expected = ImmutableList.of(actionRequest1);
    assertEquals("Matched actionRequests do not match", expected, actual);
    assertInConfig(rules, capturedConfig);
}
#method_after
public void testActionRequestsForSimple() throws IOException {
    String rules = "[rule \"rule1\"]\n\taction = action1\n";
    injectRuleBase(rules);
    Rule rule1 = createMock(Rule.class);
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    Map<String, String> properties = ImmutableMap.of();
    List<ActionRequest> rule1Match = Lists.newArrayListWithCapacity(1);
    rule1Match.add(actionRequest1);
    expect(rule1.actionRequestsFor(properties)).andReturn(rule1Match);
    expect(rulesConfigReader.getRulesFromConfig(isA(Config.class))).andReturn(ImmutableList.of(rule1)).once();
    replayMocks();
    RuleBase ruleBase = createRuleBase();
    Collection<ActionRequest> actual = ruleBase.actionRequestsFor(properties);
    List<ActionRequest> expected = Lists.newArrayListWithCapacity(3);
    expected.add(actionRequest1);
    assertEquals("Matched actionRequests do not match", expected, actual);
}
#end_block

#method_before
public void testActionRequestsForExtended() throws IOException {
    injectRuleBase("[rule \"rule1\"]\n" + "\taction = action1\n" + "\taction = action2\n" + "\n" + "[rule \"rule2\"]\n" + "\taction = action3\n");
    Rule rule1 = createMock(Rule.class);
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    ActionRequest actionRequest2 = createMock(ActionRequest.class);
    Rule rule2 = createMock(Rule.class);
    ActionRequest actionRequest3 = createMock(ActionRequest.class);
    Collection<Property> properties = ImmutableList.of();
    List<ActionRequest> rule1Match = ImmutableList.of(actionRequest1, actionRequest2);
    expect(rule1.actionRequestsFor(properties)).andReturn(rule1Match).anyTimes();
    List<ActionRequest> rule2Match = ImmutableList.of(actionRequest3);
    expect(rule2.actionRequestsFor(properties)).andReturn(rule2Match).anyTimes();
    expect(rulesConfigReader.getRulesFromConfig(isA(Config.class))).andReturn(ImmutableList.of(rule1, rule2)).andReturn(ImmutableList.of()).anyTimes();
    replayMocks();
    RuleBase ruleBase = createRuleBase();
    Collection<ActionRequest> actual = ruleBase.actionRequestsFor(properties);
    List<ActionRequest> expected = ImmutableList.of(actionRequest1, actionRequest2, actionRequest3);
    assertEquals("Matched actionRequests do not match", expected, actual);
}
#method_after
public void testActionRequestsForExtended() throws IOException {
    injectRuleBase("[rule \"rule1\"]\n" + "\taction = action1\n" + "\taction = action2\n" + "\n" + "[rule \"rule2\"]\n" + "\taction = action3\n");
    Rule rule1 = createMock(Rule.class);
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    ActionRequest actionRequest2 = createMock(ActionRequest.class);
    Rule rule2 = createMock(Rule.class);
    ActionRequest actionRequest3 = createMock(ActionRequest.class);
    Map<String, String> properties = ImmutableMap.of();
    List<ActionRequest> rule1Match = ImmutableList.of(actionRequest1, actionRequest2);
    expect(rule1.actionRequestsFor(properties)).andReturn(rule1Match).anyTimes();
    List<ActionRequest> rule2Match = ImmutableList.of(actionRequest3);
    expect(rule2.actionRequestsFor(properties)).andReturn(rule2Match).anyTimes();
    expect(rulesConfigReader.getRulesFromConfig(isA(Config.class))).andReturn(ImmutableList.of(rule1, rule2)).andReturn(ImmutableList.of()).anyTimes();
    replayMocks();
    RuleBase ruleBase = createRuleBase();
    Collection<ActionRequest> actual = ruleBase.actionRequestsFor(properties);
    List<ActionRequest> expected = ImmutableList.of(actionRequest1, actionRequest2, actionRequest3);
    assertEquals("Matched actionRequests do not match", expected, actual);
}
#end_block

#method_before
public void testAllRuleBaseFilesAreLoaded() throws IOException {
    injectRuleBase("[rule \"rule2\"]\n\taction = action2", RuleBaseKind.GLOBAL);
    injectRuleBase("[rule \"rule3\"]\n\taction = action3", RuleBaseKind.ITS);
    Collection<Property> properties = ImmutableList.of();
    Rule rule2 = createMock(Rule.class);
    ActionRequest actionRequest2 = createMock(ActionRequest.class);
    List<ActionRequest> rule2Match = ImmutableList.of(actionRequest2);
    expect(rule2.actionRequestsFor(properties)).andReturn(rule2Match);
    Rule rule3 = createMock(Rule.class);
    ActionRequest actionRequest3 = createMock(ActionRequest.class);
    List<ActionRequest> rule3Match = ImmutableList.of(actionRequest3);
    expect(rule3.actionRequestsFor(properties)).andReturn(rule3Match);
    expect(rulesConfigReader.getRulesFromConfig(isA(Config.class))).andReturn(ImmutableList.of(rule2, rule3)).andReturn(ImmutableList.of()).anyTimes();
    replayMocks();
    RuleBase ruleBase = createRuleBase();
    Collection<ActionRequest> actual = ruleBase.actionRequestsFor(properties);
    List<ActionRequest> expected = ImmutableList.of(actionRequest2, actionRequest3);
    assertEquals("Matched actionRequests do not match", expected, actual);
}
#method_after
public void testAllRuleBaseFilesAreLoaded() throws IOException {
    injectRuleBase("[rule \"rule2\"]\n\taction = action2", RuleBaseKind.GLOBAL);
    injectRuleBase("[rule \"rule3\"]\n\taction = action3", RuleBaseKind.ITS);
    Map<String, String> properties = ImmutableMap.of();
    Rule rule2 = createMock(Rule.class);
    ActionRequest actionRequest2 = createMock(ActionRequest.class);
    List<ActionRequest> rule2Match = ImmutableList.of(actionRequest2);
    expect(rule2.actionRequestsFor(properties)).andReturn(rule2Match);
    Rule rule3 = createMock(Rule.class);
    ActionRequest actionRequest3 = createMock(ActionRequest.class);
    List<ActionRequest> rule3Match = ImmutableList.of(actionRequest3);
    expect(rule3.actionRequestsFor(properties)).andReturn(rule3Match);
    expect(rulesConfigReader.getRulesFromConfig(isA(Config.class))).andReturn(ImmutableList.of(rule2, rule3)).andReturn(ImmutableList.of()).anyTimes();
    replayMocks();
    RuleBase ruleBase = createRuleBase();
    Collection<ActionRequest> actual = ruleBase.actionRequestsFor(properties);
    List<ActionRequest> expected = ImmutableList.of(actionRequest2, actionRequest3);
    assertEquals("Matched actionRequests do not match", expected, actual);
}
#end_block

#method_before
private Collection<Rule> getRulesFromFile(File ruleFile) {
    if (ruleFile.exists()) {
        FileBasedConfig cfg = new FileBasedConfig(ruleFile, FS.DETECTED);
        try {
            cfg.load();
            return rulesConfigReader.getRulesFromConfig(cfg);
        } catch (IOException | ConfigInvalidException e) {
            log.error("Invalid ITS action configuration", e);
        }
    }
    return Collections.emptyList();
}
#method_after
private static Collection<Rule> getRulesFromFile(RulesConfigReader rulesConfigReader, File ruleFile) {
    if (ruleFile.exists()) {
        FileBasedConfig cfg = new FileBasedConfig(ruleFile, FS.DETECTED);
        try {
            cfg.load();
            return rulesConfigReader.getRulesFromConfig(cfg);
        } catch (IOException | ConfigInvalidException e) {
            log.error("Invalid ITS action configuration", e);
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
public Collection<ActionRequest> actionRequestsFor(Iterable<Property> properties) {
    Collection<ActionRequest> ret = Lists.newLinkedList();
    for (Rule rule : rules) {
        ret.addAll(rule.actionRequestsFor(properties));
    }
    return ret;
}
#method_after
public Collection<ActionRequest> actionRequestsFor(Map<String, String> properties) {
    Collection<ActionRequest> ret = Lists.newLinkedList();
    for (Rule rule : rules) {
        ret.addAll(rule.actionRequestsFor(properties));
    }
    return ret;
}
#end_block

#method_before
@Override
protected String getRequest() {
    JsonObject properties = new JsonObject();
    properties.addProperty("_id", id);
    properties.addProperty("_index", index);
    client.adapter().setType(properties, type);
    JsonObject jsonAction = new JsonObject();
    jsonAction.add(action, properties);
    return jsonAction.toString() + System.lineSeparator();
}
#method_after
@Override
protected String getRequest() {
    JsonObject properties = new JsonObject();
    properties.addProperty("_id", id);
    properties.addProperty("_index", index);
    adapter.setType(properties, type);
    JsonObject jsonAction = new JsonObject();
    jsonAction.add(action, properties);
    return jsonAction.toString() + System.lineSeparator();
}
#end_block

#method_before
@Override
public void replace(AccountState as) throws IOException {
    BulkRequest bulk = new IndexRequest(getId(as), indexName, type, client).add(new UpdateRequest<>(schema, as));
    String uri = getURI(type, BULK);
    Response response = postRequest(bulk, uri, getRefreshParam());
    int statusCode = response.getStatusLine().getStatusCode();
    if (statusCode != HttpStatus.SC_OK) {
        throw new IOException(String.format("Failed to replace account %s in index %s: %s", as.getAccount().getId(), indexName, statusCode));
    }
}
#method_after
@Override
public void replace(AccountState as) throws IOException {
    BulkRequest bulk = new IndexRequest(getId(as), indexName, type, client.adapter()).add(new UpdateRequest<>(schema, as));
    String uri = getURI(type, BULK);
    Response response = postRequest(bulk, uri, getRefreshParam());
    int statusCode = response.getStatusLine().getStatusCode();
    if (statusCode != HttpStatus.SC_OK) {
        throw new IOException(String.format("Failed to replace account %s in index %s: %s", as.getAccount().getId(), indexName, statusCode));
    }
}
#end_block

#method_before
protected String delete(String type, K id) {
    return new DeleteRequest(id.toString(), indexName, type, client).toString();
}
#method_after
protected String delete(String type, K id) {
    return new DeleteRequest(id.toString(), indexName, type, client.adapter()).toString();
}
#end_block

#method_before
@Override
public void replace(ChangeData cd) throws IOException {
    String deleteIndex;
    String insertIndex;
    try {
        if (cd.change().getStatus().isOpen()) {
            insertIndex = OPEN_CHANGES;
            deleteIndex = CLOSED_CHANGES;
        } else {
            insertIndex = CLOSED_CHANGES;
            deleteIndex = OPEN_CHANGES;
        }
    } catch (OrmException e) {
        throw new IOException(e);
    }
    BulkRequest bulk = new IndexRequest(getId(cd), indexName, client.adapter().getType(insertIndex), client).add(new UpdateRequest<>(fillArgs, schema, cd));
    if (!client.adapter().usePostV5Type()) {
        bulk.add(new DeleteRequest(cd.getId().toString(), indexName, deleteIndex, client));
    }
    String uri = getURI(type, BULK);
    Response response = postRequest(bulk, uri, getRefreshParam());
    int statusCode = response.getStatusLine().getStatusCode();
    if (statusCode != HttpStatus.SC_OK) {
        throw new IOException(String.format("Failed to replace change %s in index %s: %s", cd.getId(), indexName, statusCode));
    }
}
#method_after
@Override
public void replace(ChangeData cd) throws IOException {
    String deleteIndex;
    String insertIndex;
    try {
        if (cd.change().getStatus().isOpen()) {
            insertIndex = OPEN_CHANGES;
            deleteIndex = CLOSED_CHANGES;
        } else {
            insertIndex = CLOSED_CHANGES;
            deleteIndex = OPEN_CHANGES;
        }
    } catch (OrmException e) {
        throw new IOException(e);
    }
    ElasticQueryAdapter adapter = client.adapter();
    BulkRequest bulk = new IndexRequest(getId(cd), indexName, adapter.getType(insertIndex), adapter).add(new UpdateRequest<>(fillArgs, schema, cd));
    if (!adapter.usePostV5Type()) {
        bulk.add(new DeleteRequest(cd.getId().toString(), indexName, deleteIndex, adapter));
    }
    String uri = getURI(type, BULK);
    Response response = postRequest(bulk, uri, getRefreshParam());
    int statusCode = response.getStatusLine().getStatusCode();
    if (statusCode != HttpStatus.SC_OK) {
        throw new IOException(String.format("Failed to replace change %s in index %s: %s", cd.getId(), indexName, statusCode));
    }
}
#end_block

#method_before
@Override
public void replace(AccountGroup group) throws IOException {
    BulkRequest bulk = new IndexRequest(getId(group), indexName, type, client).add(new UpdateRequest<>(schema, group));
    String uri = getURI(type, BULK);
    Response response = postRequest(bulk, uri, getRefreshParam());
    int statusCode = response.getStatusLine().getStatusCode();
    if (statusCode != HttpStatus.SC_OK) {
        throw new IOException(String.format("Failed to replace group %s in index %s: %s", group.getGroupUUID().get(), indexName, statusCode));
    }
}
#method_after
@Override
public void replace(AccountGroup group) throws IOException {
    BulkRequest bulk = new IndexRequest(getId(group), indexName, type, client.adapter()).add(new UpdateRequest<>(schema, group));
    String uri = getURI(type, BULK);
    Response response = postRequest(bulk, uri, getRefreshParam());
    int statusCode = response.getStatusLine().getStatusCode();
    if (statusCode != HttpStatus.SC_OK) {
        throw new IOException(String.format("Failed to replace group %s in index %s: %s", group.getGroupUUID().get(), indexName, statusCode));
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ProjectConfigEntry.class).annotatedWith(Exports.named("enabled")).toInstance(new ItsHookEnabledConfigEntry(pluginName, pluginCfgFactory));
    bind(ItsConfig.class);
    DynamicSet.bind(binder(), CommitValidationListener.class).to(ItsValidateComment.class);
    DynamicSet.bind(binder(), EventListener.class).to(ActionController.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ItsRulesProjectCache.class);
    factory(ActionRequest.Factory.class);
    factory(Condition.Factory.class);
    factory(Rule.Factory.class);
    factory(AddComment.Factory.class);
    factory(AddSoyComment.Factory.class);
    factory(AddStandardComment.Factory.class);
    factory(LogEvent.Factory.class);
    install(ItsRulesProjectCache.module());
}
#method_after
@Override
protected void configure() {
    bind(ProjectConfigEntry.class).annotatedWith(Exports.named("enabled")).toInstance(new ItsHookEnabledConfigEntry(pluginName, pluginCfgFactory));
    bind(ItsConfig.class);
    DynamicSet.bind(binder(), CommitValidationListener.class).to(ItsValidateComment.class);
    DynamicSet.bind(binder(), EventListener.class).to(ActionController.class);
    factory(ActionRequest.Factory.class);
    factory(Condition.Factory.class);
    factory(Rule.Factory.class);
    factory(AddComment.Factory.class);
    factory(AddSoyComment.Factory.class);
    factory(AddStandardComment.Factory.class);
    factory(LogEvent.Factory.class);
}
#end_block

#method_before
public void testEmptyRuleBase() throws IOException {
    injectRuleBase("");
    Capture<Config> capturedConfig = createCapture();
    expect(rulesConfigReader.getRulesFromConfig(and(capture(capturedConfig), isA(Config.class)))).andReturn(ImmutableList.of()).once();
    replayMocks();
    createRuleBase();
    Config config = capturedConfig.getValue();
    assertTrue(config.toText().isEmpty());
}
#method_after
public void testEmptyRuleBase() throws IOException {
    injectRuleBase("");
    replayMocks();
    createRuleBase();
}
#end_block

#method_before
public void testSimpleRuleBase() throws IOException {
    String rules = "[rule \"rule1\"]\n\tconditionA = value1\n\taction = action1\n";
    injectRuleBase(rules);
    Capture<Config> capturedConfig = createCapture();
    expect(rulesConfigReader.getRulesFromConfig(and(capture(capturedConfig), isA(Config.class)))).andReturn(ImmutableList.of()).once();
    replayMocks();
    createRuleBase();
    assertInConfig(rules, capturedConfig);
}
#method_after
public void testSimpleRuleBase() throws IOException {
    injectRuleBase("[rule \"rule1\"]\n" + "\tconditionA = value1\n" + "\taction = action1");
    Rule rule1 = createMock(Rule.class);
    expect(ruleFactory.create("rule1")).andReturn(rule1);
    Condition condition1 = createMock(Condition.class);
    expect(conditionFactory.create("conditionA", "value1")).andReturn(condition1);
    rule1.addCondition(condition1);
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    expect(actionRequestFactory.create("action1")).andReturn(actionRequest1);
    rule1.addActionRequest(actionRequest1);
    replayMocks();
    createRuleBase();
}
#end_block

#method_before
public void testBasicRuleBase() throws IOException {
    String rules = "[rule \"rule1\"]\n" + "\tconditionA = value1,value2\n" + "\tconditionA = value3,value of 4\n" + "\tconditionB = value5\n" + "\taction = action1\n" + "\taction = action2 param\n" + "\n" + "[ruleXZ \"nonrule\"]\n" + "\tconditionA = value1\n" + "\taction = action2\n" + "[rule \"rule2\"]\n" + "\tconditionC = value6\n" + "\taction = action3\n";
    injectRuleBase(rules);
    Capture<Config> capturedConfig = createCapture();
    expect(rulesConfigReader.getRulesFromConfig(and(capture(capturedConfig), isA(Config.class)))).andReturn(ImmutableList.of()).once();
    replayMocks();
    createRuleBase();
    assertInConfig(rules, capturedConfig);
}
#method_after
public void testBasicRuleBase() throws IOException {
    injectRuleBase("[rule \"rule1\"]\n" + "\tconditionA = value1,value2\n" + "\tconditionA = value3,value of 4\n" + "\tconditionB = value5\n" + "\taction = action1\n" + "\taction = action2 param\n" + "\n" + "[ruleXZ \"nonrule\"]\n" + "\tconditionA = value1\n" + "\taction = action2\n" + "[rule \"rule2\"]\n" + "\tconditionC = value6\n" + "\taction = action3");
    Rule rule1 = createMock(Rule.class);
    expect(ruleFactory.create("rule1")).andReturn(rule1);
    Condition condition1 = createMock(Condition.class);
    expect(conditionFactory.create("conditionA", "value1,value2")).andReturn(condition1);
    rule1.addCondition(condition1);
    Condition condition2 = createMock(Condition.class);
    expect(conditionFactory.create("conditionA", "value3,value of 4")).andReturn(condition2);
    rule1.addCondition(condition2);
    Condition condition3 = createMock(Condition.class);
    expect(conditionFactory.create("conditionB", "value5")).andReturn(condition3);
    rule1.addCondition(condition3);
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    expect(actionRequestFactory.create("action1")).andReturn(actionRequest1);
    rule1.addActionRequest(actionRequest1);
    ActionRequest actionRequest2 = createMock(ActionRequest.class);
    expect(actionRequestFactory.create("action2 param")).andReturn(actionRequest2);
    rule1.addActionRequest(actionRequest2);
    Rule rule2 = createMock(Rule.class);
    expect(ruleFactory.create("rule2")).andReturn(rule2);
    Condition condition4 = createMock(Condition.class);
    expect(conditionFactory.create("conditionC", "value6")).andReturn(condition4);
    rule2.addCondition(condition4);
    ActionRequest actionRequest3 = createMock(ActionRequest.class);
    expect(actionRequestFactory.create("action3")).andReturn(actionRequest3);
    rule2.addActionRequest(actionRequest3);
    replayMocks();
    createRuleBase();
}
#end_block

#method_before
public void testActionRequestsForSimple() throws IOException {
    String rules = "[rule \"rule1\"]\n\taction = action1\n";
    injectRuleBase(rules);
    Rule rule1 = createMock(Rule.class);
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    Map<String, String> properties = ImmutableMap.of(PROJECT_KEY, TEST_PROJECT);
    List<ActionRequest> rule1Match = ImmutableList.of(actionRequest1);
    expect(rule1.actionRequestsFor(properties)).andReturn(rule1Match);
    Capture<Config> capturedConfig = createCapture();
    expect(rulesConfigReader.getRulesFromConfig(and(capture(capturedConfig), isA(Config.class)))).andReturn(ImmutableList.of(rule1)).once();
    expect(rulesProjectCache.get(new Project.NameKey(TEST_PROJECT))).andReturn(ImmutableList.of());
    replayMocks();
    RuleBase ruleBase = createRuleBase();
    Collection<ActionRequest> actual = ruleBase.actionRequestsFor(properties);
    List<ActionRequest> expected = ImmutableList.of(actionRequest1);
    assertEquals("Matched actionRequests do not match", expected, actual);
    assertInConfig(rules, capturedConfig);
}
#method_after
public void testActionRequestsForSimple() throws IOException {
    injectRuleBase("[rule \"rule1\"]\n" + "\taction = action1");
    Rule rule1 = createMock(Rule.class);
    expect(ruleFactory.create("rule1")).andReturn(rule1);
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    expect(actionRequestFactory.create("action1")).andReturn(actionRequest1);
    rule1.addActionRequest(actionRequest1);
    Map<String, String> properties = ImmutableMap.of();
    List<ActionRequest> rule1Match = Lists.newArrayListWithCapacity(1);
    rule1Match.add(actionRequest1);
    expect(rule1.actionRequestsFor(properties)).andReturn(rule1Match);
    replayMocks();
    RuleBase ruleBase = createRuleBase();
    Collection<ActionRequest> actual = ruleBase.actionRequestsFor(properties);
    List<ActionRequest> expected = Lists.newArrayListWithCapacity(3);
    expected.add(actionRequest1);
    assertEquals("Matched actionRequests do not match", expected, actual);
}
#end_block

#method_before
public void testActionRequestsForExtended() throws IOException {
    injectRuleBase("[rule \"rule1\"]\n" + "\taction = action1\n" + "\taction = action2\n" + "\n" + "[rule \"rule2\"]\n" + "\taction = action3\n");
    Rule rule1 = createMock(Rule.class);
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    ActionRequest actionRequest2 = createMock(ActionRequest.class);
    Rule rule2 = createMock(Rule.class);
    ActionRequest actionRequest3 = createMock(ActionRequest.class);
    Map<String, String> properties = ImmutableMap.of(PROJECT_KEY, TEST_PROJECT);
    List<ActionRequest> rule1Match = ImmutableList.of(actionRequest1, actionRequest2);
    expect(rule1.actionRequestsFor(properties)).andReturn(rule1Match).anyTimes();
    List<ActionRequest> rule2Match = ImmutableList.of(actionRequest3);
    expect(rule2.actionRequestsFor(properties)).andReturn(rule2Match).anyTimes();
    expect(rulesProjectCache.get(new Project.NameKey(TEST_PROJECT))).andReturn(ImmutableList.of());
    expect(rulesConfigReader.getRulesFromConfig(isA(Config.class))).andReturn(ImmutableList.of(rule1, rule2)).andReturn(ImmutableList.of()).anyTimes();
    replayMocks();
    RuleBase ruleBase = createRuleBase();
    Collection<ActionRequest> actual = ruleBase.actionRequestsFor(properties);
    List<ActionRequest> expected = ImmutableList.of(actionRequest1, actionRequest2, actionRequest3);
    assertEquals("Matched actionRequests do not match", expected, actual);
}
#method_after
public void testActionRequestsForExtended() throws IOException {
    injectRuleBase("[rule \"rule1\"]\n" + "\taction = action1\n" + "\taction = action2\n" + "\n" + "[rule \"rule2\"]\n" + "\taction = action3");
    Rule rule1 = createMock(Rule.class);
    expect(ruleFactory.create("rule1")).andReturn(rule1);
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    expect(actionRequestFactory.create("action1")).andReturn(actionRequest1);
    rule1.addActionRequest(actionRequest1);
    ActionRequest actionRequest2 = createMock(ActionRequest.class);
    expect(actionRequestFactory.create("action2")).andReturn(actionRequest2);
    rule1.addActionRequest(actionRequest2);
    Rule rule2 = createMock(Rule.class);
    expect(ruleFactory.create("rule2")).andReturn(rule2);
    ActionRequest actionRequest3 = createMock(ActionRequest.class);
    expect(actionRequestFactory.create("action3")).andReturn(actionRequest3);
    rule2.addActionRequest(actionRequest3);
    Map<String, String> properties = ImmutableMap.of("sample", "property");
    List<ActionRequest> rule1Match = Lists.newArrayListWithCapacity(2);
    rule1Match.add(actionRequest1);
    rule1Match.add(actionRequest2);
    expect(rule1.actionRequestsFor(properties)).andReturn(rule1Match);
    List<ActionRequest> rule2Match = Lists.newArrayListWithCapacity(1);
    rule2Match.add(actionRequest3);
    expect(rule2.actionRequestsFor(properties)).andReturn(rule2Match);
    replayMocks();
    RuleBase ruleBase = createRuleBase();
    Collection<ActionRequest> actual = ruleBase.actionRequestsFor(properties);
    List<ActionRequest> expected = Lists.newArrayListWithCapacity(3);
    expected.add(actionRequest1);
    expected.add(actionRequest2);
    expected.add(actionRequest3);
    assertEquals("Matched actionRequests do not match", expected, actual);
}
#end_block

#method_before
public void testSimpleItsRuleBase() throws IOException {
    String rules = "[rule \"rule1\"]\n\tconditionA = value1\n\taction = action1\n";
    injectRuleBase(rules, RuleBaseKind.ITS);
    Capture<Config> capturedConfig = createCapture();
    expect(rulesConfigReader.getRulesFromConfig(and(capture(capturedConfig), isA(Config.class)))).andReturn(ImmutableList.of()).once();
    replayMocks();
    createRuleBase();
    assertInConfig(rules, capturedConfig);
}
#method_after
public void testSimpleItsRuleBase() throws IOException {
    injectRuleBase("[rule \"rule1\"]\n" + "\tconditionA = value1\n" + "\taction = action1", RuleBaseKind.ITS);
    Rule rule1 = createMock(Rule.class);
    expect(ruleFactory.create("rule1")).andReturn(rule1);
    Condition condition1 = createMock(Condition.class);
    expect(conditionFactory.create("conditionA", "value1")).andReturn(condition1);
    rule1.addCondition(condition1);
    ActionRequest actionRequest1 = createMock(ActionRequest.class);
    expect(actionRequestFactory.create("action1")).andReturn(actionRequest1);
    rule1.addActionRequest(actionRequest1);
    replayMocks();
    createRuleBase();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(String.class).annotatedWith(PluginName.class).toInstance("ItsTestName");
    itsPath = randomTargetPath().resolve("etc").resolve("its");
    assertFalse("itsPath (" + itsPath + ") already exists", Files.exists(itsPath));
    cleanupSitePath = true;
    rulesConfigReader = createMock(RulesConfigReader.class);
    bind(RulesConfigReader.class).toInstance(rulesConfigReader);
    rulesProjectCache = createMock(ItsRulesProjectCache.class);
    bind(ItsRulesProjectCache.class).toInstance(rulesProjectCache);
    bind(Path.class).annotatedWith(ItsPath.class).toInstance(itsPath);
    bind(String.class).annotatedWith(GlobalRulesFileName.class).toInstance(RuleBaseKind.GLOBAL.fileName);
    bind(String.class).annotatedWith(PluginRulesFileName.class).toInstance(RuleBaseKind.ITS.fileName);
}
#method_after
@Override
protected void configure() {
    bind(String.class).annotatedWith(PluginName.class).toInstance("ItsTestName");
    itsPath = randomTargetPath().resolve("etc").resolve("its");
    assertFalse("itsPath (" + itsPath + ") already exists", Files.exists(itsPath));
    cleanupSitePath = true;
    bind(Path.class).annotatedWith(ItsPath.class).toInstance(itsPath);
    bind(String.class).annotatedWith(GlobalRulesFileName.class).toInstance(RuleBaseKind.GLOBAL.fileName);
    bind(String.class).annotatedWith(PluginRulesFileName.class).toInstance(RuleBaseKind.ITS.fileName);
    ruleFactory = createMock(Rule.Factory.class);
    bind(Rule.Factory.class).toInstance(ruleFactory);
    conditionFactory = createMock(Condition.Factory.class);
    bind(Condition.Factory.class).toInstance(conditionFactory);
    actionRequestFactory = createMock(ActionRequest.Factory.class);
    bind(ActionRequest.Factory.class).toInstance(actionRequestFactory);
}
#end_block

#method_before
public void testChangeAttribute() {
    AccountAttribute owner = new AccountAttribute();
    owner.email = "testEmail";
    owner.name = "testName";
    owner.username = "testUsername";
    ChangeAttribute changeAttribute = new ChangeAttribute();
    changeAttribute.branch = "testBranch";
    changeAttribute.topic = "testTopic";
    changeAttribute.subject = "testSubject";
    changeAttribute.id = "testId";
    changeAttribute.number = 4711;
    changeAttribute.url = "http://www.example.org/test";
    changeAttribute.owner = owner;
    changeAttribute.commitMessage = "Commit Message";
    changeAttribute.status = Change.Status.NEW;
    expect(facade.createLinkForWebui("http://www.example.org/test", "http://www.example.org/test")).andReturn("http://www.example.org/test");
    replayMocks();
    PropertyAttributeExtractor extractor = injector.getInstance(PropertyAttributeExtractor.class);
    Map<String, String> actual = extractor.extractFrom(changeAttribute);
    ImmutableMap<String, String> expected = new ImmutableMap.Builder<String, String>().put("branch", "testBranch").put("topic", "testTopic").put("subject", "testSubject").put("changeId", "testId").put("changeNumber", "4711").put("changeUrl", "http://www.example.org/test").put("status", Change.Status.NEW.name()).put("ownerEmail", "testEmail").put("ownerName", "testName").put("ownerUsername", "testUsername").put("commitMessage", "Commit Message").put("formatChangeUrl", "http://www.example.org/test").build();
    assertEquals("Properties do not match", expected, actual);
}
#method_after
public void testChangeAttribute() {
    AccountAttribute owner = new AccountAttribute();
    owner.email = "testEmail";
    owner.name = "testName";
    owner.username = "testUsername";
    ChangeAttribute changeAttribute = new ChangeAttribute();
    changeAttribute.branch = "testBranch";
    changeAttribute.topic = "testTopic";
    changeAttribute.subject = "testSubject";
    changeAttribute.id = "testId";
    changeAttribute.number = 4711;
    changeAttribute.url = "http://www.example.org/test";
    changeAttribute.owner = owner;
    changeAttribute.commitMessage = "Commit Message";
    changeAttribute.status = Change.Status.NEW;
    expect(facade.createLinkForWebui("http://www.example.org/test", "http://www.example.org/test")).andReturn("http://www.example.org/test");
    replayMocks();
    PropertyAttributeExtractor extractor = injector.getInstance(PropertyAttributeExtractor.class);
    Map<String, String> actual = extractor.extractFrom(changeAttribute);
    ImmutableMap<String, String> expected = new ImmutableMap.Builder<String, String>().put("branch", "testBranch").put("topic", "testTopic").put("subject", "testSubject").put("escapedSubject", "testSubject").put("changeId", "testId").put("changeNumber", "4711").put("changeUrl", "http://www.example.org/test").put("status", Change.Status.NEW.name()).put("ownerEmail", "testEmail").put("ownerName", "testName").put("ownerUsername", "testUsername").put("commitMessage", "Commit Message").put("formatChangeUrl", "http://www.example.org/test").build();
    assertEquals("Properties do not match", expected, actual);
}
#end_block

#method_before
public void testChangeAttributeFull() {
    AccountAttribute owner = new AccountAttribute();
    owner.email = "testEmail";
    owner.name = "testName";
    owner.username = "testUsername";
    ChangeAttribute changeAttribute = new ChangeAttribute();
    changeAttribute.branch = "testBranch";
    changeAttribute.topic = "testTopic";
    changeAttribute.subject = "testSubject";
    changeAttribute.id = "testId";
    changeAttribute.number = 4711;
    changeAttribute.url = "http://www.example.org/test";
    changeAttribute.status = Status.ABANDONED;
    changeAttribute.owner = owner;
    changeAttribute.commitMessage = "Commit Message";
    expect(facade.createLinkForWebui("http://www.example.org/test", "http://www.example.org/test")).andReturn("http://www.example.org/test");
    replayMocks();
    PropertyAttributeExtractor extractor = injector.getInstance(PropertyAttributeExtractor.class);
    Map<String, String> actual = extractor.extractFrom(changeAttribute);
    ImmutableMap<String, String> expected = new ImmutableMap.Builder<String, String>().put("branch", "testBranch").put("topic", "testTopic").put("subject", "testSubject").put("changeId", "testId").put("changeNumber", "4711").put("changeUrl", "http://www.example.org/test").put("status", Change.Status.ABANDONED.name()).put("ownerEmail", "testEmail").put("ownerName", "testName").put("ownerUsername", "testUsername").put("commitMessage", "Commit Message").put("formatChangeUrl", "http://www.example.org/test").build();
    assertEquals("Properties do not match", expected, actual);
}
#method_after
public void testChangeAttributeFull() {
    AccountAttribute owner = new AccountAttribute();
    owner.email = "testEmail";
    owner.name = "testName";
    owner.username = "testUsername";
    ChangeAttribute changeAttribute = new ChangeAttribute();
    changeAttribute.branch = "testBranch";
    changeAttribute.topic = "testTopic";
    changeAttribute.subject = "testSubject";
    changeAttribute.id = "testId";
    changeAttribute.number = 4711;
    changeAttribute.url = "http://www.example.org/test";
    changeAttribute.status = Status.ABANDONED;
    changeAttribute.owner = owner;
    changeAttribute.commitMessage = "Commit Message";
    expect(facade.createLinkForWebui("http://www.example.org/test", "http://www.example.org/test")).andReturn("http://www.example.org/test");
    replayMocks();
    PropertyAttributeExtractor extractor = injector.getInstance(PropertyAttributeExtractor.class);
    Map<String, String> actual = extractor.extractFrom(changeAttribute);
    ImmutableMap<String, String> expected = new ImmutableMap.Builder<String, String>().put("branch", "testBranch").put("topic", "testTopic").put("subject", "testSubject").put("escapedSubject", "testSubject").put("changeId", "testId").put("changeNumber", "4711").put("changeUrl", "http://www.example.org/test").put("status", Change.Status.ABANDONED.name()).put("ownerEmail", "testEmail").put("ownerName", "testName").put("ownerUsername", "testUsername").put("commitMessage", "Commit Message").put("formatChangeUrl", "http://www.example.org/test").build();
    assertEquals("Properties do not match", expected, actual);
}
#end_block

#method_before
public Map<String, String> extractFrom(AccountAttribute accountAttribute, String prefix) {
    Map<String, String> properties = new HashMap<>();
    if (accountAttribute != null) {
        properties.put(prefix + "Email", accountAttribute.email);
        properties.put(prefix + "Username", accountAttribute.username);
        properties.put(prefix + "Name", accountAttribute.name);
    }
    return properties;
}
#method_after
Map<String, String> extractFrom(AccountAttribute accountAttribute, String prefix) {
    Map<String, String> properties = new HashMap<>();
    if (accountAttribute != null) {
        properties.put(prefix + "Email", accountAttribute.email);
        properties.put(prefix + "Username", accountAttribute.username);
        properties.put(prefix + "Name", accountAttribute.name);
    }
    return properties;
}
#end_block

#method_before
public Map<String, String> extractFrom(ChangeAttribute changeAttribute) {
    return ImmutableMap.<String, String>builder().put("branch", changeAttribute.branch).put("topic", changeAttribute.topic != null ? changeAttribute.topic : "").put("subject", changeAttribute.subject).put("commitMessage", changeAttribute.commitMessage).put("changeId", changeAttribute.id).put("changeNumber", String.valueOf(changeAttribute.number)).put("changeUrl", changeAttribute.url).put("formatChangeUrl", its.createLinkForWebui(changeAttribute.url, changeAttribute.url)).put("status", changeAttribute.status != null ? changeAttribute.status.toString() : "").putAll(extractFrom(changeAttribute.owner, "owner")).build();
}
#method_after
Map<String, String> extractFrom(ChangeAttribute changeAttribute) {
    return ImmutableMap.<String, String>builder().put("branch", changeAttribute.branch).put("topic", changeAttribute.topic != null ? changeAttribute.topic : "").put("subject", changeAttribute.subject).put("escapedSubject", StringEscapeUtils.escapeJava(changeAttribute.subject)).put("commitMessage", changeAttribute.commitMessage).put("changeId", changeAttribute.id).put("changeNumber", String.valueOf(changeAttribute.number)).put("changeUrl", changeAttribute.url).put("formatChangeUrl", its.createLinkForWebui(changeAttribute.url, changeAttribute.url)).put("status", changeAttribute.status != null ? changeAttribute.status.toString() : "").putAll(extractFrom(changeAttribute.owner, "owner")).build();
}
#end_block

#method_before
public Map<String, String> extractFrom(PatchSetAttribute patchSetAttribute) {
    return ImmutableMap.<String, String>builder().put("revision", patchSetAttribute.revision).put("patchSetNumber", String.valueOf(patchSetAttribute.number)).put("ref", patchSetAttribute.ref).put("createdOn", patchSetAttribute.createdOn.toString()).put("parents", patchSetAttribute.parents.toString()).put("deletions", Integer.toString(patchSetAttribute.sizeDeletions)).put("insertions", Integer.toString(patchSetAttribute.sizeInsertions)).putAll(extractFrom(patchSetAttribute.uploader, "uploader")).putAll(extractFrom(patchSetAttribute.author, "author")).build();
}
#method_after
Map<String, String> extractFrom(PatchSetAttribute patchSetAttribute) {
    return ImmutableMap.<String, String>builder().put("revision", patchSetAttribute.revision).put("patchSetNumber", String.valueOf(patchSetAttribute.number)).put("ref", patchSetAttribute.ref).put("createdOn", patchSetAttribute.createdOn.toString()).put("parents", patchSetAttribute.parents.toString()).put("deletions", Integer.toString(patchSetAttribute.sizeDeletions)).put("insertions", Integer.toString(patchSetAttribute.sizeInsertions)).putAll(extractFrom(patchSetAttribute.uploader, "uploader")).putAll(extractFrom(patchSetAttribute.author, "author")).build();
}
#end_block

#method_before
public Map<String, String> extractFrom(RefUpdateAttribute refUpdateAttribute) {
    return ImmutableMap.<String, String>builder().put("revision", refUpdateAttribute.newRev).put("revisionOld", refUpdateAttribute.oldRev).put("ref", refUpdateAttribute.refName).build();
}
#method_after
Map<String, String> extractFrom(RefUpdateAttribute refUpdateAttribute) {
    return ImmutableMap.<String, String>builder().put("revision", refUpdateAttribute.newRev).put("revisionOld", refUpdateAttribute.oldRev).put("ref", refUpdateAttribute.refName).build();
}
#end_block

#method_before
public boolean isMetBy(Map<String, String> properties) {
    String property = properties.get(key);
    String[] prpts = property != null ? property.split(" ") : new String[] {};
    for (String p : prpts) {
        if (values.contains(p.trim())) {
            return !negated;
        }
    }
    return negated;
}
#method_after
public boolean isMetBy(Map<String, String> properties) {
    String property = properties.get(key);
    String[] propertyValues = property != null ? property.split(" ") : new String[] {};
    for (String p : propertyValues) {
        if (values.contains(p.trim())) {
            return !negated;
        }
    }
    return negated;
}
#end_block

#method_before
private void reloadRules() {
    rules = new ArrayList<>();
    // Add global rules
    File globalRuleFile = itsPath.resolve(globalRulesFileName).toFile();
    rules.addAll(getRulesFromFile(globalRuleFile));
    // Add its-specific rules
    File itsSpecificRuleFile = itsPath.resolve(pluginRulesFileName).toFile();
    rules.addAll(getRulesFromFile(itsSpecificRuleFile));
    if (!globalRuleFile.exists() && !itsSpecificRuleFile.exists()) {
        log.warn("Neither global rule file {} nor Its specific rule file {} exist. Please configure rules.", globalRuleFile, itsSpecificRuleFile);
    }
}
#method_after
private void reloadRules() {
    rules = Lists.newArrayList();
    // Add global rules
    File globalRuleFile = itsPath.resolve(globalRulesFileName).toFile();
    addRulesFromFile(globalRuleFile);
    // Add its-specific rules
    File itsSpecificRuleFile = itsPath.resolve(pluginRulesFileName).toFile();
    addRulesFromFile(itsSpecificRuleFile);
    if (!globalRuleFile.exists() && !itsSpecificRuleFile.exists()) {
        log.warn("Neither global rule file {} nor Its specific rule file {} exist. Please configure rules.", globalRuleFile, itsSpecificRuleFile);
    }
}
#end_block

#method_before
public Collection<ActionRequest> actionRequestsFor(Map<String, String> properties) {
    String projectName = properties.get("project");
    Collection<Rule> fromProjectConfig = rulesProjectCache.get(new Project.NameKey(projectName));
    Collection<Rule> rulesToAdd = !fromProjectConfig.isEmpty() ? fromProjectConfig : rules;
    Collection<ActionRequest> actions = new ArrayList<>();
    for (Rule rule : rulesToAdd) {
        actions.addAll(rule.actionRequestsFor(properties));
    }
    return actions;
}
#method_after
public Collection<ActionRequest> actionRequestsFor(Map<String, String> properties) {
    Collection<ActionRequest> ret = Lists.newLinkedList();
    for (Rule rule : rules) {
        ret.addAll(rule.actionRequestsFor(properties));
    }
    return ret;
}
#end_block

#method_before
private String clean(String msg) {
    return msg.replaceAll("(?i)(?m)^Signed-off-by:.*$\n?", "").replaceAll("(?m)^#.*$\n?", "").replaceAll("(?m)\n\n\n+", "\\\n").replaceAll("\\n*$", "").replaceAll("(?s)\ndiff --git.*", "").trim();
}
#method_after
private String clean(String msg) {
    return msg.replaceAll("(?m)^#.*$\n?", "").trim();
}
#end_block

#method_before
private void initUserAuth(final PublickeyAuthenticator pubkey, final GSSAuthenticator kerberosAuthenticator, String kerberosKeytab, String kerberosPrincipal) {
    List<NamedFactory<UserAuth>> authFactories = new ArrayList<>();
    if (kerberosKeytab != null) {
        authFactories.add(UserAuthGSSFactory.INSTANCE);
        log.info("Enabling kerberos with keytab " + kerberosKeytab);
        if (!new File(kerberosKeytab).canRead()) {
            sshDaemonLog.error("Keytab " + kerberosKeytab + " does not exist or is not readable; further errors are possible");
        }
        kerberosAuthenticator.setKeytabFile(kerberosKeytab);
        if (kerberosPrincipal == null) {
            try {
                kerberosPrincipal = "host/" + InetAddress.getLocalHost().getCanonicalHostName();
            } catch (UnknownHostException e) {
                kerberosPrincipal = "host/localhost";
            }
        }
        sshDaemonLog.info("Using kerberos principal " + kerberosPrincipal);
        if (!kerberosPrincipal.startsWith("host/")) {
            sshDaemonLog.warn("Host principal does not start with host/ " + "which most SSH clients will supply automatically");
        }
        kerberosAuthenticator.setServicePrincipalName(kerberosPrincipal);
        setGSSAuthenticator(kerberosAuthenticator);
    }
    authFactories.add(UserAuthPublicKeyFactory.INSTANCE);
    setUserAuthFactories(authFactories);
    setPublickeyAuthenticator(pubkey);
}
#method_after
private void initUserAuth(final PublickeyAuthenticator pubkey, final GSSAuthenticator kerberosAuthenticator, String kerberosKeytab, String kerberosPrincipal) {
    List<NamedFactory<UserAuth>> authFactories = new ArrayList<>();
    if (kerberosKeytab != null) {
        authFactories.add(UserAuthGSSFactory.INSTANCE);
        sshDaemonLog.info("Enabling kerberos with keytab " + kerberosKeytab);
        if (!new File(kerberosKeytab).canRead()) {
            sshDaemonLog.error("Keytab " + kerberosKeytab + " does not exist or is not readable; further errors are possible");
        }
        kerberosAuthenticator.setKeytabFile(kerberosKeytab);
        if (kerberosPrincipal == null) {
            try {
                kerberosPrincipal = "host/" + InetAddress.getLocalHost().getCanonicalHostName();
            } catch (UnknownHostException e) {
                kerberosPrincipal = "host/localhost";
            }
        }
        sshDaemonLog.info("Using kerberos principal " + kerberosPrincipal);
        if (!kerberosPrincipal.startsWith("host/")) {
            sshDaemonLog.warn("Host principal does not start with host/ " + "which most SSH clients will supply automatically");
        }
        kerberosAuthenticator.setServicePrincipalName(kerberosPrincipal);
        setGSSAuthenticator(kerberosAuthenticator);
    }
    authFactories.add(UserAuthPublicKeyFactory.INSTANCE);
    setUserAuthFactories(authFactories);
    setPublickeyAuthenticator(pubkey);
}
#end_block

#method_before
public Executor createQueue(int poolsize, String prefix) {
    return createQueue(poolsize, prefix, false);
}
#method_after
public Executor createQueue(int poolsize, String queueName) {
    return createQueue(poolsize, queueName, false);
}
#end_block

#method_before
private Executor createQueue(int poolsize, String prefix, boolean withMetrics) {
    final Executor r = new Executor(poolsize, prefix);
    if (withMetrics) {
        log.info("Adding metrics for '{}' queue", prefix);
        r.buildMetrics(prefix);
    }
    r.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);
    r.setExecuteExistingDelayedTasksAfterShutdownPolicy(true);
    queues.add(r);
    return r;
}
#method_after
public Executor createQueue(int poolsize, String queueName, boolean withMetrics) {
    final Executor r = new Executor(poolsize, queueName);
    if (withMetrics) {
        log.info("Adding metrics for '{}' queue", queueName);
        r.buildMetrics(queueName);
    }
    r.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);
    r.setExecuteExistingDelayedTasksAfterShutdownPolicy(true);
    queues.add(r);
    return r;
}
#end_block

#method_before
@Override
protected void doXContent(XContentBuilder builder) throws IOException {
    switch(type) {
        case PHRASE_PREFIX:
            builder.startObject("match_phrase_prefix");
            break;
        case PHRASE:
        default:
            builder.startObject("match_phrase");
    }
    builder.field(name, text);
    builder.endObject();
}
#method_after
@Override
protected void doXContent(XContentBuilder builder) throws IOException {
    builder.startObject(type.toString()).field(name, text).endObject();
}
#end_block

#method_before
@Override
public void log(final Request req, final Response rsp) {
    final LoggingEvent event = new // 
    LoggingEvent(// fqnOfCategoryClass
    Logger.class.getName(), // logger
    log, // when
    TimeUtil.nowMs(), // level
    Level.INFO, // message text
    "", // thread name
    "HTTPD", // exception information
    null, // current NDC string
    null, // caller location
    null, // MDC properties
    null);
    String uri = req.getRequestURI();
    String qs = req.getQueryString();
    if (!Strings.isNullOrEmpty(qs)) {
        StringBuilder b = new StringBuilder(uri);
        boolean first = true;
        for (String kvPair : Splitter.on('&').split(qs)) {
            Iterator<String> i = Splitter.on('=').limit(2).split(kvPair).iterator();
            String key = i.next();
            b.append(first ? '?' : '&').append(key);
            first = false;
            if (i.hasNext()) {
                b.append('=');
                if (REDACT_PARAM.contains(Url.decode(key))) {
                    b.append('*');
                } else {
                    b.append(i.next());
                }
            }
        }
        uri = b.toString();
    }
    String user = (String) req.getAttribute(GetUserFilter.REQ_ATTR_KEY);
    if (user != null) {
        event.setProperty(P_USER, user);
    }
    set(event, P_HOST, req.getRemoteAddr());
    set(event, P_METHOD, req.getMethod());
    set(event, P_RESOURCE, uri);
    set(event, P_PROTOCOL, req.getProtocol());
    set(event, P_STATUS, rsp.getStatus());
    set(event, P_CONTENT_LENGTH, rsp.getContentCount());
    set(event, P_REFERER, req.getHeader("Referer"));
    set(event, P_USER_AGENT, req.getHeader("User-Agent"));
    async.append(event);
}
#method_after
@Override
public void log(final Request req, final Response rsp) {
    final LoggingEvent event = new // 
    LoggingEvent(// fqnOfCategoryClass
    Logger.class.getName(), // logger
    log, // when
    TimeUtil.nowMs(), // level
    Level.INFO, // message text
    "", // thread name
    "HTTPD", // exception information
    null, // current NDC string
    null, // caller location
    null, // MDC properties
    null);
    String uri = req.getRequestURI();
    uri = redactQueryString(uri, req.getQueryString());
    String user = (String) req.getAttribute(GetUserFilter.REQ_ATTR_KEY);
    if (user != null) {
        event.setProperty(P_USER, user);
    }
    set(event, P_HOST, req.getRemoteAddr());
    set(event, P_METHOD, req.getMethod());
    set(event, P_RESOURCE, uri);
    set(event, P_PROTOCOL, req.getProtocol());
    set(event, P_STATUS, rsp.getStatus());
    set(event, P_CONTENT_LENGTH, rsp.getContentCount());
    set(event, P_REFERER, req.getHeader("Referer"));
    set(event, P_USER_AGENT, req.getHeader("User-Agent"));
    async.append(event);
}
#end_block

#method_before
@Override
protected final void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    final long startNanos = System.nanoTime();
    long auditStartTs = TimeUtil.nowMs();
    res.setHeader("Content-Disposition", "attachment");
    res.setHeader("X-Content-Type-Options", "nosniff");
    int status = SC_OK;
    long responseBytes = -1;
    Object result = null;
    ListMultimap<String, String> xd = MultimapBuilder.hashKeys().arrayListValues().build();
    ListMultimap<String, String> params = MultimapBuilder.hashKeys().arrayListValues().build();
    ListMultimap<String, String> config = MultimapBuilder.hashKeys().arrayListValues().build();
    Object inputRequestBody = null;
    RestResource rsrc = TopLevelResource.INSTANCE;
    ViewData viewData = null;
    try {
        if (isCorsPreflight(req)) {
            doCorsPreflight(req, res);
            return;
        }
        ParameterParser.splitQueryString(req.getQueryString(), xd, config, params);
        checkCors(req, res, !xd.isEmpty());
        if (!xd.isEmpty()) {
            req = applyXdOverrides(req, xd);
        }
        checkUserSession(req);
        List<IdString> path = splitPath(req);
        RestCollection<RestResource, RestResource> rc = members.get();
        globals.permissionBackend.user(globals.currentUser).checkAny(GlobalPermission.fromAnnotation(rc.getClass()));
        viewData = new ViewData(null, null);
        if (path.isEmpty()) {
            if (rc instanceof NeedsParams) {
                ((NeedsParams) rc).setParams(params);
            }
            if (isRead(req)) {
                viewData = new ViewData(null, rc.list());
            } else if (rc instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                @SuppressWarnings("unchecked")
                AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) rc;
                viewData = new ViewData(null, ac.post(rsrc));
            } else {
                throw new MethodNotAllowedException();
            }
        } else {
            IdString id = path.remove(0);
            try {
                rsrc = rc.parse(rsrc, id);
                if (path.isEmpty()) {
                    checkPreconditions(req);
                }
            } catch (ResourceNotFoundException e) {
                if (rc instanceof AcceptsCreate && path.isEmpty() && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) rc;
                    viewData = new ViewData(null, ac.create(rsrc, id));
                    status = SC_CREATED;
                } else {
                    throw e;
                }
            }
            if (viewData.view == null) {
                viewData = view(rsrc, rc, req.getMethod(), path);
            }
        }
        checkRequiresCapability(viewData);
        while (viewData.view instanceof RestCollection<?, ?>) {
            @SuppressWarnings("unchecked")
            RestCollection<RestResource, RestResource> c = (RestCollection<RestResource, RestResource>) viewData.view;
            if (path.isEmpty()) {
                if (isRead(req)) {
                    viewData = new ViewData(null, c.list());
                } else if (c instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) c;
                    viewData = new ViewData(null, ac.post(rsrc));
                } else if (c instanceof AcceptsDelete && "DELETE".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsDelete<RestResource> ac = (AcceptsDelete<RestResource>) c;
                    viewData = new ViewData(null, ac.delete(rsrc, null));
                } else {
                    throw new MethodNotAllowedException();
                }
                break;
            }
            IdString id = path.remove(0);
            try {
                rsrc = c.parse(rsrc, id);
                checkPreconditions(req);
                viewData = new ViewData(null, null);
            } catch (ResourceNotFoundException e) {
                if (c instanceof AcceptsCreate && path.isEmpty() && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) c;
                    viewData = new ViewData(viewData.pluginName, ac.create(rsrc, id));
                    status = SC_CREATED;
                } else if (c instanceof AcceptsDelete && path.isEmpty() && "DELETE".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsDelete<RestResource> ac = (AcceptsDelete<RestResource>) c;
                    viewData = new ViewData(viewData.pluginName, ac.delete(rsrc, id));
                    status = SC_NO_CONTENT;
                } else {
                    throw e;
                }
            }
            if (viewData.view == null) {
                viewData = view(rsrc, c, req.getMethod(), path);
            }
            checkRequiresCapability(viewData);
        }
        if (notModified(req, rsrc, viewData.view)) {
            res.sendError(SC_NOT_MODIFIED);
            return;
        }
        if (!globals.paramParser.get().parse(viewData.view, params, req, res)) {
            return;
        }
        if (viewData.view instanceof RestReadView<?> && isRead(req)) {
            result = ((RestReadView<RestResource>) viewData.view).apply(rsrc);
        } else if (viewData.view instanceof RestModifyView<?, ?>) {
            @SuppressWarnings("unchecked")
            RestModifyView<RestResource, Object> m = (RestModifyView<RestResource, Object>) viewData.view;
            Type type = inputType(m);
            inputRequestBody = parseRequest(req, type);
            result = m.apply(rsrc, inputRequestBody);
            consumeRawInputRequestBody(req, type);
        } else {
            throw new ResourceNotFoundException();
        }
        if (result instanceof Response) {
            @SuppressWarnings("rawtypes")
            Response<?> r = (Response) result;
            status = r.statusCode();
            configureCaching(req, res, rsrc, viewData.view, r.caching());
        } else if (result instanceof Response.Redirect) {
            CacheHeaders.setNotCacheable(res);
            res.sendRedirect(((Response.Redirect) result).location());
            return;
        } else if (result instanceof Response.Accepted) {
            CacheHeaders.setNotCacheable(res);
            res.setStatus(SC_ACCEPTED);
            res.setHeader(HttpHeaders.LOCATION, ((Response.Accepted) result).location());
            return;
        } else {
            CacheHeaders.setNotCacheable(res);
        }
        res.setStatus(status);
        if (result != Response.none()) {
            result = Response.unwrap(result);
            if (result instanceof BinaryResult) {
                responseBytes = replyBinaryResult(req, res, (BinaryResult) result);
            } else {
                responseBytes = replyJson(req, res, config, result);
            }
        }
    } catch (MalformedJsonException e) {
        responseBytes = replyError(req, res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request", e);
    } catch (JsonParseException e) {
        responseBytes = replyError(req, res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request", e);
    } catch (BadRequestException e) {
        responseBytes = replyError(req, res, status = SC_BAD_REQUEST, messageOr(e, "Bad Request"), e.caching(), e);
    } catch (AuthException e) {
        responseBytes = replyError(req, res, status = SC_FORBIDDEN, messageOr(e, "Forbidden"), e.caching(), e);
    } catch (AmbiguousViewException e) {
        responseBytes = replyError(req, res, status = SC_NOT_FOUND, messageOr(e, "Ambiguous"), e);
    } catch (ResourceNotFoundException e) {
        responseBytes = replyError(req, res, status = SC_NOT_FOUND, messageOr(e, "Not Found"), e.caching(), e);
    } catch (MethodNotAllowedException e) {
        responseBytes = replyError(req, res, status = SC_METHOD_NOT_ALLOWED, messageOr(e, "Method Not Allowed"), e.caching(), e);
    } catch (ResourceConflictException e) {
        responseBytes = replyError(req, res, status = SC_CONFLICT, messageOr(e, "Conflict"), e.caching(), e);
    } catch (PreconditionFailedException e) {
        responseBytes = replyError(req, res, status = SC_PRECONDITION_FAILED, messageOr(e, "Precondition Failed"), e.caching(), e);
    } catch (UnprocessableEntityException e) {
        responseBytes = replyError(req, res, status = SC_UNPROCESSABLE_ENTITY, messageOr(e, "Unprocessable Entity"), e.caching(), e);
    } catch (NotImplementedException e) {
        responseBytes = replyError(req, res, status = SC_NOT_IMPLEMENTED, messageOr(e, "Not Implemented"), e);
    } catch (Exception e) {
        status = SC_INTERNAL_SERVER_ERROR;
        responseBytes = handleException(e, req, res);
    } finally {
        String metric = viewData != null && viewData.view != null ? globals.metrics.view(viewData) : "_unknown";
        globals.metrics.count.increment(metric);
        if (status >= SC_BAD_REQUEST) {
            globals.metrics.errorCount.increment(metric, status);
        }
        if (responseBytes != -1) {
            globals.metrics.responseBytes.record(metric, responseBytes);
        }
        globals.metrics.serverLatency.record(metric, System.nanoTime() - startNanos, TimeUnit.NANOSECONDS);
        globals.auditService.dispatch(new ExtendedHttpAuditEvent(globals.webSession.get().getSessionId(), globals.currentUser.get(), req, auditStartTs, params, inputRequestBody, status, result, rsrc, viewData == null ? null : viewData.view));
    }
}
#method_after
@Override
protected final void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    final long startNanos = System.nanoTime();
    long auditStartTs = TimeUtil.nowMs();
    res.setHeader("Content-Disposition", "attachment");
    res.setHeader("X-Content-Type-Options", "nosniff");
    int status = SC_OK;
    long responseBytes = -1;
    Object result = null;
    QueryParams qp = null;
    Object inputRequestBody = null;
    RestResource rsrc = TopLevelResource.INSTANCE;
    ViewData viewData = null;
    try {
        if (isCorsPreflight(req)) {
            doCorsPreflight(req, res);
            return;
        }
        qp = ParameterParser.getQueryParams(req);
        checkCors(req, res, qp.hasXdOverride());
        if (qp.hasXdOverride()) {
            req = applyXdOverrides(req, qp);
        }
        checkUserSession(req);
        List<IdString> path = splitPath(req);
        RestCollection<RestResource, RestResource> rc = members.get();
        globals.permissionBackend.user(globals.currentUser).checkAny(GlobalPermission.fromAnnotation(rc.getClass()));
        viewData = new ViewData(null, null);
        if (path.isEmpty()) {
            if (rc instanceof NeedsParams) {
                ((NeedsParams) rc).setParams(qp.params());
            }
            if (isRead(req)) {
                viewData = new ViewData(null, rc.list());
            } else if (rc instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                @SuppressWarnings("unchecked")
                AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) rc;
                viewData = new ViewData(null, ac.post(rsrc));
            } else {
                throw new MethodNotAllowedException();
            }
        } else {
            IdString id = path.remove(0);
            try {
                rsrc = rc.parse(rsrc, id);
                if (path.isEmpty()) {
                    checkPreconditions(req);
                }
            } catch (ResourceNotFoundException e) {
                if (rc instanceof AcceptsCreate && path.isEmpty() && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) rc;
                    viewData = new ViewData(null, ac.create(rsrc, id));
                    status = SC_CREATED;
                } else {
                    throw e;
                }
            }
            if (viewData.view == null) {
                viewData = view(rsrc, rc, req.getMethod(), path);
            }
        }
        checkRequiresCapability(viewData);
        while (viewData.view instanceof RestCollection<?, ?>) {
            @SuppressWarnings("unchecked")
            RestCollection<RestResource, RestResource> c = (RestCollection<RestResource, RestResource>) viewData.view;
            if (path.isEmpty()) {
                if (isRead(req)) {
                    viewData = new ViewData(null, c.list());
                } else if (c instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) c;
                    viewData = new ViewData(null, ac.post(rsrc));
                } else if (c instanceof AcceptsDelete && "DELETE".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsDelete<RestResource> ac = (AcceptsDelete<RestResource>) c;
                    viewData = new ViewData(null, ac.delete(rsrc, null));
                } else {
                    throw new MethodNotAllowedException();
                }
                break;
            }
            IdString id = path.remove(0);
            try {
                rsrc = c.parse(rsrc, id);
                checkPreconditions(req);
                viewData = new ViewData(null, null);
            } catch (ResourceNotFoundException e) {
                if (c instanceof AcceptsCreate && path.isEmpty() && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) c;
                    viewData = new ViewData(viewData.pluginName, ac.create(rsrc, id));
                    status = SC_CREATED;
                } else if (c instanceof AcceptsDelete && path.isEmpty() && "DELETE".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsDelete<RestResource> ac = (AcceptsDelete<RestResource>) c;
                    viewData = new ViewData(viewData.pluginName, ac.delete(rsrc, id));
                    status = SC_NO_CONTENT;
                } else {
                    throw e;
                }
            }
            if (viewData.view == null) {
                viewData = view(rsrc, c, req.getMethod(), path);
            }
            checkRequiresCapability(viewData);
        }
        if (notModified(req, rsrc, viewData.view)) {
            res.sendError(SC_NOT_MODIFIED);
            return;
        }
        if (!globals.paramParser.get().parse(viewData.view, qp.params(), req, res)) {
            return;
        }
        if (viewData.view instanceof RestReadView<?> && isRead(req)) {
            result = ((RestReadView<RestResource>) viewData.view).apply(rsrc);
        } else if (viewData.view instanceof RestModifyView<?, ?>) {
            @SuppressWarnings("unchecked")
            RestModifyView<RestResource, Object> m = (RestModifyView<RestResource, Object>) viewData.view;
            Type type = inputType(m);
            inputRequestBody = parseRequest(req, type);
            result = m.apply(rsrc, inputRequestBody);
            consumeRawInputRequestBody(req, type);
        } else {
            throw new ResourceNotFoundException();
        }
        if (result instanceof Response) {
            @SuppressWarnings("rawtypes")
            Response<?> r = (Response) result;
            status = r.statusCode();
            configureCaching(req, res, rsrc, viewData.view, r.caching());
        } else if (result instanceof Response.Redirect) {
            CacheHeaders.setNotCacheable(res);
            res.sendRedirect(((Response.Redirect) result).location());
            return;
        } else if (result instanceof Response.Accepted) {
            CacheHeaders.setNotCacheable(res);
            res.setStatus(SC_ACCEPTED);
            res.setHeader(HttpHeaders.LOCATION, ((Response.Accepted) result).location());
            return;
        } else {
            CacheHeaders.setNotCacheable(res);
        }
        res.setStatus(status);
        if (result != Response.none()) {
            result = Response.unwrap(result);
            if (result instanceof BinaryResult) {
                responseBytes = replyBinaryResult(req, res, (BinaryResult) result);
            } else {
                responseBytes = replyJson(req, res, qp.config(), result);
            }
        }
    } catch (MalformedJsonException e) {
        responseBytes = replyError(req, res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request", e);
    } catch (JsonParseException e) {
        responseBytes = replyError(req, res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request", e);
    } catch (BadRequestException e) {
        responseBytes = replyError(req, res, status = SC_BAD_REQUEST, messageOr(e, "Bad Request"), e.caching(), e);
    } catch (AuthException e) {
        responseBytes = replyError(req, res, status = SC_FORBIDDEN, messageOr(e, "Forbidden"), e.caching(), e);
    } catch (AmbiguousViewException e) {
        responseBytes = replyError(req, res, status = SC_NOT_FOUND, messageOr(e, "Ambiguous"), e);
    } catch (ResourceNotFoundException e) {
        responseBytes = replyError(req, res, status = SC_NOT_FOUND, messageOr(e, "Not Found"), e.caching(), e);
    } catch (MethodNotAllowedException e) {
        responseBytes = replyError(req, res, status = SC_METHOD_NOT_ALLOWED, messageOr(e, "Method Not Allowed"), e.caching(), e);
    } catch (ResourceConflictException e) {
        responseBytes = replyError(req, res, status = SC_CONFLICT, messageOr(e, "Conflict"), e.caching(), e);
    } catch (PreconditionFailedException e) {
        responseBytes = replyError(req, res, status = SC_PRECONDITION_FAILED, messageOr(e, "Precondition Failed"), e.caching(), e);
    } catch (UnprocessableEntityException e) {
        responseBytes = replyError(req, res, status = SC_UNPROCESSABLE_ENTITY, messageOr(e, "Unprocessable Entity"), e.caching(), e);
    } catch (NotImplementedException e) {
        responseBytes = replyError(req, res, status = SC_NOT_IMPLEMENTED, messageOr(e, "Not Implemented"), e);
    } catch (Exception e) {
        status = SC_INTERNAL_SERVER_ERROR;
        responseBytes = handleException(e, req, res);
    } finally {
        String metric = viewData != null && viewData.view != null ? globals.metrics.view(viewData) : "_unknown";
        globals.metrics.count.increment(metric);
        if (status >= SC_BAD_REQUEST) {
            globals.metrics.errorCount.increment(metric, status);
        }
        if (responseBytes != -1) {
            globals.metrics.responseBytes.record(metric, responseBytes);
        }
        globals.metrics.serverLatency.record(metric, System.nanoTime() - startNanos, TimeUnit.NANOSECONDS);
        globals.auditService.dispatch(new ExtendedHttpAuditEvent(globals.webSession.get().getSessionId(), globals.currentUser.get(), req, auditStartTs, qp != null ? qp.params() : ImmutableListMultimap.of(), inputRequestBody, status, result, rsrc, viewData == null ? null : viewData.view));
    }
}
#end_block

#method_before
private static HttpServletRequest applyXdOverrides(HttpServletRequest req, ListMultimap<String, String> xd) throws BadRequestException {
    String method = Iterables.getFirst(xd.get(XD_METHOD), null);
    if (!ALLOWED_XD_METHODS.contains(method)) {
        log.error("method " + method);
        throw new BadRequestException("method not allowed");
    }
    String contentType = Iterables.getFirst(xd.get(XD_CONTENT_TYPE), null);
    if (method.equals("POST") || method.equals("PUT")) {
        if (!"text/plain".equals(req.getContentType())) {
            throw new BadRequestException("invalid " + CONTENT_TYPE);
        } else if (Strings.isNullOrEmpty(contentType)) {
            throw new BadRequestException(XD_CONTENT_TYPE + " required");
        }
    }
    return new HttpServletRequestWrapper(req) {

        @Override
        public String getMethod() {
            return method;
        }

        @Override
        public String getContentType() {
            return contentType;
        }
    };
}
#method_after
private static HttpServletRequest applyXdOverrides(HttpServletRequest req, QueryParams qp) throws BadRequestException {
    if (!"POST".equals(req.getMethod())) {
        throw new BadRequestException("POST required");
    }
    String method = qp.xdMethod();
    String contentType = qp.xdContentType();
    if (method.equals("POST") || method.equals("PUT")) {
        if (!"text/plain".equals(req.getContentType())) {
            throw new BadRequestException("invalid " + CONTENT_TYPE);
        } else if (Strings.isNullOrEmpty(contentType)) {
            throw new BadRequestException(XD_CONTENT_TYPE + " required");
        }
    }
    return new HttpServletRequestWrapper(req) {

        @Override
        public String getMethod() {
            return method;
        }

        @Override
        public String getContentType() {
            return contentType;
        }
    };
}
#end_block

#method_before
private void doCorsPreflight(HttpServletRequest req, HttpServletResponse res) throws BadRequestException {
    CacheHeaders.setNotCacheable(res);
    res.setHeader(VARY, Joiner.on(", ").join(ImmutableList.of(ORIGIN, ACCESS_CONTROL_REQUEST_METHOD)));
    String origin = req.getHeader(ORIGIN);
    if (Strings.isNullOrEmpty(origin) || !isOriginAllowed(origin)) {
        throw new BadRequestException("CORS not allowed");
    }
    String headers = req.getHeader(ACCESS_CONTROL_REQUEST_HEADERS);
    if (headers != null) {
        res.addHeader(VARY, ACCESS_CONTROL_REQUEST_HEADERS);
        for (String reqHdr : Splitter.on(',').trimResults().split(headers)) {
            if (!isAllowedCorsRequestHeader(reqHdr)) {
                throw new BadRequestException(reqHdr + " not allowed in CORS");
            }
        }
    }
    res.setStatus(SC_OK);
    setCorsHeaders(res, origin);
    res.setContentType("text/plain");
    res.setContentLength(0);
}
#method_after
private void doCorsPreflight(HttpServletRequest req, HttpServletResponse res) throws BadRequestException {
    CacheHeaders.setNotCacheable(res);
    setHeaderList(res, VARY, ImmutableList.of(ORIGIN, ACCESS_CONTROL_REQUEST_METHOD, ACCESS_CONTROL_REQUEST_HEADERS));
    String origin = req.getHeader(ORIGIN);
    if (Strings.isNullOrEmpty(origin) || !isOriginAllowed(origin)) {
        throw new BadRequestException("CORS not allowed");
    }
    String method = req.getHeader(ACCESS_CONTROL_REQUEST_METHOD);
    if (!ALLOWED_CORS_METHODS.contains(method)) {
        throw new BadRequestException(method + " not allowed in CORS");
    }
    String headers = req.getHeader(ACCESS_CONTROL_REQUEST_HEADERS);
    if (headers != null) {
        res.addHeader(VARY, ACCESS_CONTROL_REQUEST_HEADERS);
        for (String reqHdr : Splitter.on(',').trimResults().split(headers)) {
            if (!ALLOWED_CORS_REQUEST_HEADERS.contains(reqHdr.toLowerCase(Locale.US))) {
                throw new BadRequestException(reqHdr + " not allowed in CORS");
            }
        }
    }
    res.setStatus(SC_OK);
    setCorsHeaders(res, origin);
    res.setContentType("text/plain");
    res.setContentLength(0);
}
#end_block

#method_before
private static void setCorsHeaders(HttpServletResponse res, String origin) {
    res.setHeader(ACCESS_CONTROL_ALLOW_ORIGIN, origin);
    res.setHeader(ACCESS_CONTROL_ALLOW_CREDENTIALS, "true");
    res.setHeader(ACCESS_CONTROL_MAX_AGE, "600");
    res.setHeader(ACCESS_CONTROL_ALLOW_METHODS, Joiner.on(", ").join(Iterables.concat(ALLOWED_XD_METHODS, ImmutableList.of("HEAD", "OPTIONS"))));
    res.setHeader(ACCESS_CONTROL_ALLOW_HEADERS, Joiner.on(", ").join(ALLOWED_CORS_REQUEST_HEADERS));
}
#method_after
private static void setCorsHeaders(HttpServletResponse res, String origin) {
    res.setHeader(ACCESS_CONTROL_ALLOW_ORIGIN, origin);
    res.setHeader(ACCESS_CONTROL_ALLOW_CREDENTIALS, "true");
    res.setHeader(ACCESS_CONTROL_MAX_AGE, "600");
    setHeaderList(res, ACCESS_CONTROL_ALLOW_METHODS, Iterables.concat(ALLOWED_CORS_METHODS, ImmutableList.of("OPTIONS")));
    setHeaderList(res, ACCESS_CONTROL_ALLOW_HEADERS, ALLOWED_CORS_REQUEST_HEADERS);
}
#end_block

#method_before
private String readCookie() {
    Cookie[] all = request.getCookies();
    if (all != null) {
        for (Cookie c : all) {
            if (ACCOUNT_COOKIE.equals(c.getName())) {
                String v = c.getValue();
                return v != null && !"".equals(v) ? v : null;
            }
        }
    }
    return getQueryParameter(XD_AUTHORIZATION);
}
#method_after
private static String readCookie(HttpServletRequest request) {
    Cookie[] all = request.getCookies();
    if (all != null) {
        for (Cookie c : all) {
            if (ACCOUNT_COOKIE.equals(c.getName())) {
                return Strings.emptyToNull(c.getValue());
            }
        }
    }
    return null;
}
#end_block

#method_before
protected String getSearch(SearchSourceBuilder searchSource, JsonArray sortArray) {
    JsonParser parser = new JsonParser();
    JsonObject search = parser.parse(searchSource.toString()).getAsJsonObject();
    search.add("sort", sortArray);
    return gson.toJson(search);
}
#method_after
protected String getSearch(SearchSourceBuilder searchSource, JsonArray sortArray) {
    JsonObject search = new JsonParser().parse(searchSource.toString()).getAsJsonObject();
    search.add("sort", sortArray);
    return gson.toJson(search);
}
#end_block

#method_before
private void writeValue(Object value) throws IOException {
    if (value == null) {
        generator.writeNull();
        return;
    }
    Class<?> type = value.getClass();
    if (type == String.class) {
        generator.writeString((String) value);
    } else if (type == Integer.class) {
        generator.writeNumber(((Integer) value));
    } else if (type == byte[].class) {
        generator.writeBinary((byte[]) value);
    } else if (value instanceof Date) {
        generator.writeString(XContentBuilder.defaultDatePrinter.print(((Date) value).getTime()));
    } else {
        // if this is a "value" object, like enum, DistanceUnit, ..., just toString it
        // yea, it can be misleading when toString a Java class, but really, jackson should be used in
        // that case
        generator.writeString(value.toString());
    // throw new ElasticsearchIllegalArgumentException("type not supported for generic value
    // conversion: " + type);
    }
}
#method_after
private void writeValue(Object value) throws IOException {
    if (value == null) {
        generator.writeNull();
        return;
    }
    Class<?> type = value.getClass();
    if (type == String.class) {
        generator.writeString((String) value);
    } else if (type == Integer.class) {
        generator.writeNumber(((Integer) value));
    } else if (type == byte[].class) {
        generator.writeBinary((byte[]) value);
    } else if (value instanceof Date) {
        generator.writeString(ISO_INSTANT.format(((Date) value).toInstant()));
    } else {
        // if this is a "value" object, like enum, DistanceUnit, ..., just toString it
        // yea, it can be misleading when toString a Java class, but really, jackson should be used in
        // that case
        generator.writeString(value.toString());
    // throw new ElasticsearchIllegalArgumentException("type not supported for generic value
    // conversion: " + type);
    }
}
#end_block

#method_before
@Override
public ResultSet<AccountState> read() throws OrmException {
    try {
        List<AccountState> results = Collections.emptyList();
        String uri = getURI(ACCOUNTS, SEARCH);
        Response response = performRequest(HttpPost.METHOD_NAME, search, uri, Collections.emptyMap());
        StatusLine statusLine = response.getStatusLine();
        if (statusLine.getStatusCode() == HttpStatus.SC_OK) {
            String content = getContent(response);
            JsonParser parser = new JsonParser();
            JsonObject obj = parser.parse(content).getAsJsonObject().getAsJsonObject("hits");
            if (obj.get("hits") != null) {
                JsonArray json = obj.getAsJsonArray("hits");
                results = Lists.newArrayListWithCapacity(json.size());
                for (int i = 0; i < json.size(); i++) {
                    results.add(toAccountState(json.get(i)));
                }
            }
        } else {
            log.error(statusLine.getReasonPhrase());
        }
        final List<AccountState> r = Collections.unmodifiableList(results);
        return new ResultSet<AccountState>() {

            @Override
            public Iterator<AccountState> iterator() {
                return r.iterator();
            }

            @Override
            public List<AccountState> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
@Override
public ResultSet<AccountState> read() throws OrmException {
    try {
        List<AccountState> results = Collections.emptyList();
        String uri = getURI(ACCOUNTS, SEARCH);
        Response response = performRequest(HttpPost.METHOD_NAME, search, uri, Collections.emptyMap());
        StatusLine statusLine = response.getStatusLine();
        if (statusLine.getStatusCode() == HttpStatus.SC_OK) {
            String content = getContent(response);
            JsonObject obj = new JsonParser().parse(content).getAsJsonObject().getAsJsonObject("hits");
            if (obj.get("hits") != null) {
                JsonArray json = obj.getAsJsonArray("hits");
                results = Lists.newArrayListWithCapacity(json.size());
                for (int i = 0; i < json.size(); i++) {
                    results.add(toAccountState(json.get(i)));
                }
            }
        } else {
            log.error(statusLine.getReasonPhrase());
        }
        final List<AccountState> r = Collections.unmodifiableList(results);
        return new ResultSet<AccountState>() {

            @Override
            public Iterator<AccountState> iterator() {
                return r.iterator();
            }

            @Override
            public List<AccountState> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
@Override
public ResultSet<ChangeData> read() throws OrmException {
    try {
        List<ChangeData> results = Collections.emptyList();
        String uri = getURI(types);
        Response response = performRequest(HttpPost.METHOD_NAME, search, uri, Collections.emptyMap());
        StatusLine statusLine = response.getStatusLine();
        if (statusLine.getStatusCode() == HttpStatus.SC_OK) {
            String content = getContent(response);
            JsonParser parser = new JsonParser();
            JsonObject obj = parser.parse(content).getAsJsonObject().getAsJsonObject("hits");
            if (obj.get("hits") != null) {
                JsonArray json = obj.getAsJsonArray("hits");
                results = Lists.newArrayListWithCapacity(json.size());
                for (int i = 0; i < json.size(); i++) {
                    results.add(toChangeData(json.get(i)));
                }
            }
        } else {
            log.error(statusLine.getReasonPhrase());
        }
        final List<ChangeData> r = Collections.unmodifiableList(results);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
@Override
public ResultSet<ChangeData> read() throws OrmException {
    try {
        List<ChangeData> results = Collections.emptyList();
        String uri = getURI(types);
        Response response = performRequest(HttpPost.METHOD_NAME, search, uri, Collections.emptyMap());
        StatusLine statusLine = response.getStatusLine();
        if (statusLine.getStatusCode() == HttpStatus.SC_OK) {
            String content = getContent(response);
            JsonObject obj = new JsonParser().parse(content).getAsJsonObject().getAsJsonObject("hits");
            if (obj.get("hits") != null) {
                JsonArray json = obj.getAsJsonArray("hits");
                results = Lists.newArrayListWithCapacity(json.size());
                for (int i = 0; i < json.size(); i++) {
                    results.add(toChangeData(json.get(i)));
                }
            }
        } else {
            log.error(statusLine.getReasonPhrase());
        }
        final List<ChangeData> r = Collections.unmodifiableList(results);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
@Override
public ResultSet<AccountGroup> read() throws OrmException {
    try {
        List<AccountGroup> results = Collections.emptyList();
        String uri = getURI(GROUPS, SEARCH);
        Response response = performRequest(HttpPost.METHOD_NAME, search, uri, Collections.emptyMap());
        StatusLine statusLine = response.getStatusLine();
        if (statusLine.getStatusCode() == HttpStatus.SC_OK) {
            String content = getContent(response);
            JsonParser parser = new JsonParser();
            JsonObject obj = parser.parse(content).getAsJsonObject().getAsJsonObject("hits");
            if (obj.get("hits") != null) {
                JsonArray json = obj.getAsJsonArray("hits");
                results = Lists.newArrayListWithCapacity(json.size());
                for (int i = 0; i < json.size(); i++) {
                    results.add(toAccountGroup(json.get(i)));
                }
            }
        } else {
            log.error(statusLine.getReasonPhrase());
        }
        final List<AccountGroup> r = Collections.unmodifiableList(results);
        return new ResultSet<AccountGroup>() {

            @Override
            public Iterator<AccountGroup> iterator() {
                return r.iterator();
            }

            @Override
            public List<AccountGroup> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
@Override
public ResultSet<AccountGroup> read() throws OrmException {
    try {
        List<AccountGroup> results = Collections.emptyList();
        String uri = getURI(GROUPS, SEARCH);
        Response response = performRequest(HttpPost.METHOD_NAME, search, uri, Collections.emptyMap());
        StatusLine statusLine = response.getStatusLine();
        if (statusLine.getStatusCode() == HttpStatus.SC_OK) {
            String content = getContent(response);
            JsonObject obj = new JsonParser().parse(content).getAsJsonObject().getAsJsonObject("hits");
            if (obj.get("hits") != null) {
                JsonArray json = obj.getAsJsonArray("hits");
                results = Lists.newArrayListWithCapacity(json.size());
                for (int i = 0; i < json.size(); i++) {
                    results.add(toAccountGroup(json.get(i)));
                }
            }
        } else {
            log.error(statusLine.getReasonPhrase());
        }
        final List<AccountGroup> r = Collections.unmodifiableList(results);
        return new ResultSet<AccountGroup>() {

            @Override
            public Iterator<AccountGroup> iterator() {
                return r.iterator();
            }

            @Override
            public List<AccountGroup> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
List<String> discover(String prefix, String indexName) throws IOException {
    String name = prefix + indexName + "_";
    Response response = client.performRequest(HttpGet.METHOD_NAME, name + "*/_aliases");
    int statusCode = response.getStatusLine().getStatusCode();
    if (statusCode == HttpStatus.SC_OK) {
        String content = AbstractElasticIndex.getContent(response);
        JsonParser parser = new JsonParser();
        JsonObject object = parser.parse(content).getAsJsonObject();
        List<String> versions = new ArrayList<>(object.size());
        for (Entry<String, JsonElement> entry : object.entrySet()) {
            versions.add(entry.getKey().replace(name, ""));
        }
        return versions;
    }
    return Collections.emptyList();
}
#method_after
List<String> discover(String prefix, String indexName) throws IOException {
    String name = prefix + indexName + "_";
    Response response = client.performRequest(HttpGet.METHOD_NAME, name + "*/_aliases");
    int statusCode = response.getStatusLine().getStatusCode();
    if (statusCode == HttpStatus.SC_OK) {
        String content = AbstractElasticIndex.getContent(response);
        JsonObject object = new JsonParser().parse(content).getAsJsonObject();
        List<String> versions = new ArrayList<>(object.size());
        for (Entry<String, JsonElement> entry : object.entrySet()) {
            versions.add(entry.getKey().replace(name, ""));
        }
        return versions;
    }
    return Collections.emptyList();
}
#end_block

#method_before
private String problemsForSubmittingChangeset(Change currentChange, ChangeData cd, ChangeSet cs, CurrentUser user) {
    try {
        if (cs.furtherHiddenChanges()) {
            return BLOCKED_HIDDEN_SUBMIT_TOOLTIP;
        }
        for (ChangeData c : cs.changes()) {
            if (currentChange.getId().equals(c.getId())) {
                continue;
            }
            Set<ChangePermission> can = permissionBackend.user(user).database(dbProvider).change(c).test(EnumSet.of(ChangePermission.READ, ChangePermission.SUBMIT));
            if (!can.contains(ChangePermission.READ)) {
                return BLOCKED_HIDDEN_SUBMIT_TOOLTIP;
            }
            if (!can.contains(ChangePermission.SUBMIT)) {
                return BLOCKED_SUBMIT_TOOLTIP.replace("changeId", c.getId().toString()).toString();
            }
            if (c.change().isWorkInProgress()) {
                return BLOCKED_WORK_IN_PROGRESS.replace("changeId", c.getId().toString()).toString();
            }
            try {
                MergeOp.checkSubmitRule(c, false);
            } catch (ResourceConflictException e) {
                return CHANGE_NOT_READY.replace("changeId", c.getId().toString()).replace("e", e.getMessage()).toString();
            }
        }
        Collection<ChangeData> unmergeable = unmergeableChanges(cs);
        if (unmergeable == null) {
            return CLICK_FAILURE_TOOLTIP;
        } else if (!unmergeable.isEmpty()) {
            for (ChangeData c : unmergeable) {
                if (c.change().getKey().equals(cd.change().getKey())) {
                    return CHANGE_UNMERGEABLE;
                }
            }
            return CHANGES_NOT_MERGEABLE.replace("changeIds", unmergeable.stream().map(c -> c.getId().toString()).collect(joining(", "))).toString();
        }
    } catch (PermissionBackendException | OrmException | IOException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    return null;
}
#method_after
private String problemsForSubmittingChangeset(ChangeData cd, ChangeSet cs, CurrentUser user) {
    try {
        if (cs.furtherHiddenChanges()) {
            return BLOCKED_HIDDEN_SUBMIT_TOOLTIP;
        }
        for (ChangeData c : cs.changes()) {
            if (cd.getId().equals(c.getId())) {
                // #apply and #getDescription methods.
                continue;
            }
            Set<ChangePermission> can = permissionBackend.user(user).database(dbProvider).change(c).test(EnumSet.of(ChangePermission.READ, ChangePermission.SUBMIT));
            if (!can.contains(ChangePermission.READ)) {
                return BLOCKED_HIDDEN_SUBMIT_TOOLTIP;
            }
            if (!can.contains(ChangePermission.SUBMIT)) {
                return "You don't have permission to submit change " + c.getId();
            }
            if (c.change().isWorkInProgress()) {
                return "Change " + c.getId() + " is marked work in progress";
            }
            try {
                MergeOp.checkSubmitRule(c, false);
            } catch (ResourceConflictException e) {
                return "Change " + c.getId() + " is not ready: " + e.getMessage();
            }
        }
        Collection<ChangeData> unmergeable = unmergeableChanges(cs);
        if (unmergeable == null) {
            return CLICK_FAILURE_TOOLTIP;
        } else if (!unmergeable.isEmpty()) {
            for (ChangeData c : unmergeable) {
                if (c.change().getKey().equals(cd.change().getKey())) {
                    return CHANGE_UNMERGEABLE;
                }
            }
            return "Problems with change(s): " + unmergeable.stream().map(c -> c.getId().toString()).collect(joining(", "));
        }
    } catch (PermissionBackendException | OrmException | IOException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    return null;
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    Change change = resource.getChange();
    if (!change.getStatus().isOpen() || change.isWorkInProgress() || !resource.isCurrent() || !resource.permissions().testOrFalse(ChangePermission.SUBMIT)) {
        // submit not visible
        return null;
    }
    try {
        if (!projectCache.checkedGet(resource.getProject()).statePermitsWrite()) {
            // submit not visible
            return null;
        }
    } catch (IOException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getNotes());
    try {
        MergeOp.checkSubmitRule(cd, false);
    } catch (ResourceConflictException e) {
        // submit not visible
        return null;
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    ChangeSet cs;
    try {
        cs = mergeSuperSet.get().completeChangeSet(db, cd.change(), resource.getUser());
    } catch (OrmException | IOException | PermissionBackendException e) {
        throw new OrmRuntimeException("Could not determine complete set of changes to be submitted", e);
    }
    String topic = change.getTopic();
    int topicSize = 0;
    if (!Strings.isNullOrEmpty(topic)) {
        topicSize = getChangesByTopic(topic).size();
    }
    boolean treatWithTopic = submitWholeTopic && !Strings.isNullOrEmpty(topic) && topicSize > 1;
    String submitProblems = problemsForSubmittingChangeset(change, cd, cs, resource.getUser());
    Boolean enabled;
    try {
        // Recheck mergeability rather than using value stored in the index,
        // which may be stale.
        // TODO(dborowitz): This is ugly; consider providing a way to not read
        // stored fields from the index in the first place.
        // cd.setMergeable(null);
        // That was done in unmergeableChanges which was called by
        // problemsForSubmittingChangeset, so now it is safe to read from
        // the cache, as it yields the same result.
        enabled = cd.isMergeable();
    } catch (OrmException e) {
        throw new OrmRuntimeException("Could not determine mergeability", e);
    }
    if (submitProblems != null) {
        return new UiAction.Description().setLabel(treatWithTopic ? submitTopicLabel : (cs.size() > 1) ? labelWithParents : label).setTitle(submitProblems).setVisible(true).setEnabled(false);
    }
    if (treatWithTopic) {
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(topicSize), "submitSize", String.valueOf(cs.size()));
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    }
    RevId revId = resource.getPatchSet().getRevision();
    Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", change.getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name(), "submitSize", String.valueOf(cs.size()));
    ParameterizedString tp = cs.size() > 1 ? titlePatternWithAncestors : titlePattern;
    return new UiAction.Description().setLabel(cs.size() > 1 ? labelWithParents : label).setTitle(Strings.emptyToNull(tp.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    Change change = resource.getChange();
    if (!change.getStatus().isOpen() || change.isWorkInProgress() || !resource.isCurrent() || !resource.permissions().testOrFalse(ChangePermission.SUBMIT)) {
        // submit not visible
        return null;
    }
    try {
        if (!projectCache.checkedGet(resource.getProject()).statePermitsWrite()) {
            // submit not visible
            return null;
        }
    } catch (IOException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getNotes());
    try {
        MergeOp.checkSubmitRule(cd, false);
    } catch (ResourceConflictException e) {
        // submit not visible
        return null;
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    ChangeSet cs;
    try {
        cs = mergeSuperSet.get().completeChangeSet(db, cd.change(), resource.getUser());
    } catch (OrmException | IOException | PermissionBackendException e) {
        throw new OrmRuntimeException("Could not determine complete set of changes to be submitted", e);
    }
    String topic = change.getTopic();
    int topicSize = 0;
    if (!Strings.isNullOrEmpty(topic)) {
        topicSize = getChangesByTopic(topic).size();
    }
    boolean treatWithTopic = submitWholeTopic && !Strings.isNullOrEmpty(topic) && topicSize > 1;
    String submitProblems = problemsForSubmittingChangeset(cd, cs, resource.getUser());
    Boolean enabled;
    try {
        // Recheck mergeability rather than using value stored in the index,
        // which may be stale.
        // TODO(dborowitz): This is ugly; consider providing a way to not read
        // stored fields from the index in the first place.
        // cd.setMergeable(null);
        // That was done in unmergeableChanges which was called by
        // problemsForSubmittingChangeset, so now it is safe to read from
        // the cache, as it yields the same result.
        enabled = cd.isMergeable();
    } catch (OrmException e) {
        throw new OrmRuntimeException("Could not determine mergeability", e);
    }
    if (submitProblems != null) {
        return new UiAction.Description().setLabel(treatWithTopic ? submitTopicLabel : (cs.size() > 1) ? labelWithParents : label).setTitle(submitProblems).setVisible(true).setEnabled(false);
    }
    if (treatWithTopic) {
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(topicSize), "submitSize", String.valueOf(cs.size()));
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    }
    RevId revId = resource.getPatchSet().getRevision();
    Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", change.getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name(), "submitSize", String.valueOf(cs.size()));
    ParameterizedString tp = cs.size() > 1 ? titlePatternWithAncestors : titlePattern;
    return new UiAction.Description().setLabel(cs.size() > 1 ? labelWithParents : label).setTitle(Strings.emptyToNull(tp.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
}
#end_block

#method_before
@Override
public DiffPreferencesInfo apply(AccountResource rsrc) throws AuthException, ConfigInvalidException, IOException, PermissionBackendException {
    if (!self.get().isSameAccountId(rsrc.getUser())) {
        permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER);
    }
    Account.Id id = rsrc.getUser().getAccountId();
    return readFromGit(id, gitMgr, allUsersName.get(), null);
}
#method_after
@Override
public DiffPreferencesInfo apply(AccountResource rsrc) throws AuthException, ConfigInvalidException, IOException {
    if (!self.get().hasSameAccountId(rsrc.getUser()) && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    Account.Id id = rsrc.getUser().getAccountId();
    return readFromGit(id, gitMgr, allUsersName.get(), null);
}
#end_block

#method_before
@Override
public Response<?> apply(AccountResource rsrc, List<ProjectWatchInfo> input) throws AuthException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException, PermissionBackendException {
    if (!self.get().isSameAccountId(rsrc.getUser())) {
        permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER);
    }
    if (input == null) {
        return Response.none();
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    watchConfig.deleteProjectWatches(accountId, input.stream().filter(Objects::nonNull).map(w -> ProjectWatchKey.create(new Project.NameKey(w.project), w.filter)).collect(toList()));
    accountCache.evict(accountId);
    return Response.none();
}
#method_after
@Override
public Response<?> apply(AccountResource rsrc, List<ProjectWatchInfo> input) throws AuthException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (!self.get().hasSameAccountId(rsrc.getUser()) && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("It is not allowed to edit project watches of other users");
    }
    if (input == null) {
        return Response.none();
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    watchConfig.deleteProjectWatches(accountId, input.stream().map(w -> ProjectWatchKey.create(new Project.NameKey(w.project), w.filter)).collect(toList()));
    accountCache.evict(accountId);
    return Response.none();
}
#end_block

#method_before
private Iterable<ExternalId> getGpgExtIds(AccountResource rsrc) throws IOException {
    return externalIds.byAccount(rsrc.getUser().getAccountId(), SCHEME_GPGKEY);
}
#method_after
@VisibleForTesting
public static FluentIterable<ExternalId> getGpgExtIds(ReviewDb db, Account.Id accountId) throws OrmException {
    return FluentIterable.from(ExternalId.from(db.accountExternalIds().byAccount(accountId).toList())).filter(in -> in.isScheme(SCHEME_GPGKEY));
}
#end_block

#method_before
private Iterable<ExternalId> getGpgExtIds(AccountResource rsrc) throws IOException {
    return externalIds.byAccount(rsrc.getUser().getAccountId(), SCHEME_GPGKEY);
}
#method_after
private Iterable<ExternalId> getGpgExtIds(AccountResource rsrc) throws OrmException {
    return getGpgExtIds(db.get(), rsrc.getUser().getAccountId());
}
#end_block

#method_before
static void checkVisible(Provider<CurrentUser> self, AccountResource rsrc) throws ResourceNotFoundException {
    if (!BouncyCastleUtil.havePGP()) {
        throw new ResourceNotFoundException("GPG not enabled");
    }
    if (!self.get().isSameAccountId(rsrc.getUser())) {
        throw new ResourceNotFoundException();
    }
}
#method_after
static void checkVisible(Provider<CurrentUser> self, AccountResource rsrc) throws ResourceNotFoundException {
    if (!BouncyCastleUtil.havePGP()) {
        throw new ResourceNotFoundException("GPG not enabled");
    }
    if (!self.get().hasSameAccountId(rsrc.getUser())) {
        throw new ResourceNotFoundException();
    }
}
#end_block

#method_before
public static GpgKeyInfo toJson(PGPPublicKey key, CheckResult checkResult) throws IOException {
    GpgKeyInfo info = new GpgKeyInfo();
    if (key != null) {
        info.id = PublicKeyStore.keyIdToString(key.getKeyID());
        info.fingerprint = Fingerprint.toString(key.getFingerprint());
        Iterator<String> userIds = key.getUserIDs();
        info.userIds = ImmutableList.copyOf(userIds);
        try (ByteArrayOutputStream out = new ByteArrayOutputStream(4096);
            ArmoredOutputStream aout = new ArmoredOutputStream(out)) {
            // This is not exactly the key stored in the store, but is equivalent. In
            // particular, it will have a Bouncy Castle version string. The armored
            // stream reader in PublicKeyStore doesn't give us an easy way to extract
            // the original ASCII armor.
            key.encode(aout);
            info.key = new String(out.toByteArray(), UTF_8);
        }
    }
    info.status = checkResult.getStatus();
    info.problems = checkResult.getProblems();
    return info;
}
#method_after
public static GpgKeyInfo toJson(PGPPublicKey key, CheckResult checkResult) throws IOException {
    GpgKeyInfo info = new GpgKeyInfo();
    if (key != null) {
        info.id = PublicKeyStore.keyIdToString(key.getKeyID());
        info.fingerprint = Fingerprint.toString(key.getFingerprint());
        @SuppressWarnings("unchecked")
        Iterator<String> userIds = key.getUserIDs();
        info.userIds = ImmutableList.copyOf(userIds);
        try (ByteArrayOutputStream out = new ByteArrayOutputStream(4096);
            ArmoredOutputStream aout = new ArmoredOutputStream(out)) {
            // This is not exactly the key stored in the store, but is equivalent. In
            // particular, it will have a Bouncy Castle version string. The armored
            // stream reader in PublicKeyStore doesn't give us an easy way to extract
            // the original ASCII armor.
            key.encode(aout);
            info.key = new String(out.toByteArray(), UTF_8);
        }
    }
    info.status = checkResult.getStatus();
    info.problems = checkResult.getProblems();
    return info;
}
#end_block

#method_before
@Override
public DiffPreferencesInfo apply(AccountResource rsrc, DiffPreferencesInfo in) throws AuthException, BadRequestException, ConfigInvalidException, RepositoryNotFoundException, IOException, PermissionBackendException {
    if (!self.get().isSameAccountId(rsrc.getUser())) {
        permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT);
    }
    if (in == null) {
        throw new BadRequestException("input must be provided");
    }
    Account.Id id = rsrc.getUser().getAccountId();
    return writeToGit(readFromGit(id, gitMgr, allUsersName, in), id);
}
#method_after
@Override
public DiffPreferencesInfo apply(AccountResource rsrc, DiffPreferencesInfo in) throws AuthException, BadRequestException, ConfigInvalidException, RepositoryNotFoundException, IOException {
    if (!self.get().hasSameAccountId(rsrc.getUser()) && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("requires Modify Account capability");
    }
    if (in == null) {
        throw new BadRequestException("input must be provided");
    }
    Account.Id id = rsrc.getUser().getAccountId();
    return writeToGit(readFromGit(id, gitMgr, allUsersName, in), id);
}
#end_block

#method_before
@Override
public Response<?> apply(AccountResource.SshKey rsrc, Input input) throws AuthException, OrmException, RepositoryNotFoundException, IOException, ConfigInvalidException, PermissionBackendException {
    if (!self.get().isSameAccountId(rsrc.getUser())) {
        permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER);
    }
    authorizedKeys.deleteKey(rsrc.getUser().getAccountId(), rsrc.getSshKey().getKey().get());
    sshKeyCache.evict(rsrc.getUser().getUserName());
    return Response.none();
}
#method_after
@Override
public Response<?> apply(AccountResource.SshKey rsrc, Input input) throws AuthException, OrmException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    if (!self.get().hasSameAccountId(rsrc.getUser()) && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to delete SSH keys");
    }
    authorizedKeys.deleteKey(rsrc.getUser().getAccountId(), rsrc.getSshKey().getKey().get());
    sshKeyCache.evict(rsrc.getUser().getUserName());
    return Response.none();
}
#end_block

#method_before
@Override
public AccountResource.SshKey parse(AccountResource rsrc, IdString id) throws ResourceNotFoundException, OrmException, IOException, ConfigInvalidException, PermissionBackendException {
    if (!self.get().isSameAccountId(rsrc.getUser())) {
        try {
            permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT);
        } catch (AuthException e) {
            // If lacking MODIFY_ACCOUNT claim the resource does not exist.
            throw new ResourceNotFoundException();
        }
    }
    return parse(rsrc.getUser(), id);
}
#method_after
@Override
public AccountResource.SshKey parse(AccountResource rsrc, IdString id) throws ResourceNotFoundException, OrmException, IOException, ConfigInvalidException {
    if (!self.get().hasSameAccountId(rsrc.getUser()) && !self.get().getCapabilities().canModifyAccount()) {
        throw new ResourceNotFoundException();
    }
    return parse(rsrc.getUser(), id);
}
#end_block

#method_before
@Override
public Response<String> apply(AccountResource.Email rsrc, Input input) throws AuthException, ResourceNotFoundException, OrmException, IOException, PermissionBackendException, ConfigInvalidException {
    if (!self.get().isSameAccountId(rsrc.getUser())) {
        permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT);
    }
    return apply(rsrc.getUser(), rsrc.getEmail());
}
#method_after
@Override
public Response<String> apply(AccountResource.Email rsrc, Input input) throws AuthException, ResourceNotFoundException, OrmException, IOException {
    if (!self.get().hasSameAccountId(rsrc.getUser()) && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("not allowed to set preferred email address");
    }
    return apply(rsrc.getUser(), rsrc.getEmail());
}
#end_block

#method_before
public Response<String> apply(IdentifiedUser user, String email) throws ResourceNotFoundException, IOException, ConfigInvalidException {
    AtomicBoolean alreadyPreferred = new AtomicBoolean(false);
    Account account = accountsUpdate.create().update(user.getAccountId(), a -> {
        if (email.equals(a.getPreferredEmail())) {
            alreadyPreferred.set(true);
        } else {
            a.setPreferredEmail(email);
        }
    });
    if (account == null) {
        throw new ResourceNotFoundException("account not found");
    }
    return alreadyPreferred.get() ? Response.ok("") : Response.created("");
}
#method_after
public Response<String> apply(IdentifiedUser user, String email) throws ResourceNotFoundException, OrmException, IOException {
    AtomicBoolean alreadyPreferred = new AtomicBoolean(false);
    Account a = dbProvider.get().accounts().atomicUpdate(user.getAccountId(), new AtomicUpdate<Account>() {

        @Override
        public Account update(Account a) {
            if (email.equals(a.getPreferredEmail())) {
                alreadyPreferred.set(true);
            } else {
                a.setPreferredEmail(email);
            }
            return a;
        }
    });
    if (a == null) {
        throw new ResourceNotFoundException("account not found");
    }
    dbProvider.get().accounts().update(Collections.singleton(a));
    byIdCache.evict(a.getId());
    return alreadyPreferred.get() ? Response.ok("") : Response.created("");
}
#end_block

#method_before
@Override
public EditPreferencesInfo apply(AccountResource rsrc, EditPreferencesInfo in) throws AuthException, BadRequestException, RepositoryNotFoundException, IOException, ConfigInvalidException, PermissionBackendException {
    if (!self.get().isSameAccountId(rsrc.getUser())) {
        permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT);
    }
    if (in == null) {
        throw new BadRequestException("input must be provided");
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    VersionedAccountPreferences prefs;
    EditPreferencesInfo out = new EditPreferencesInfo();
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName)) {
        prefs = VersionedAccountPreferences.forUser(accountId);
        prefs.load(md);
        storeSection(prefs.getConfig(), UserConfigSections.EDIT, null, readFromGit(accountId, gitMgr, allUsersName, in), EditPreferencesInfo.defaults());
        prefs.commit(md);
        out = loadSection(prefs.getConfig(), UserConfigSections.EDIT, null, out, EditPreferencesInfo.defaults(), null);
    }
    return out;
}
#method_after
@Override
public EditPreferencesInfo apply(AccountResource rsrc, EditPreferencesInfo in) throws AuthException, BadRequestException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    if (!self.get().hasSameAccountId(rsrc.getUser()) && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("requires Modify Account capability");
    }
    if (in == null) {
        throw new BadRequestException("input must be provided");
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    VersionedAccountPreferences prefs;
    EditPreferencesInfo out = new EditPreferencesInfo();
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName)) {
        prefs = VersionedAccountPreferences.forUser(accountId);
        prefs.load(md);
        storeSection(prefs.getConfig(), UserConfigSections.EDIT, null, readFromGit(accountId, gitMgr, allUsersName, in), EditPreferencesInfo.defaults());
        prefs.commit(md);
        out = loadSection(prefs.getConfig(), UserConfigSections.EDIT, null, out, EditPreferencesInfo.defaults(), null);
    }
    return out;
}
#end_block

#method_before
@Override
public Response<SshKeyInfo> apply(AccountResource rsrc, Input input) throws AuthException, BadRequestException, OrmException, IOException, ConfigInvalidException, PermissionBackendException {
    if (!self.get().isSameAccountId(rsrc.getUser())) {
        permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER);
    }
    return apply(rsrc.getUser(), input);
}
#method_after
@Override
public Response<SshKeyInfo> apply(AccountResource rsrc, Input input) throws AuthException, BadRequestException, OrmException, IOException, ConfigInvalidException {
    if (!self.get().hasSameAccountId(rsrc.getUser()) && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to add SSH keys");
    }
    return apply(rsrc.getUser(), input);
}
#end_block

#method_before
@Override
public String apply(AccountResource rsrc, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, ResourceConflictException, OrmException, IOException, ConfigInvalidException, PermissionBackendException {
    if (!self.get().isSameAccountId(rsrc.getUser())) {
        permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER);
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME)) {
        throw new MethodNotAllowedException("realm does not allow editing username");
    }
    if (input == null) {
        input = new Input();
    }
    try {
        changeUserNameFactory.create(rsrc.getUser(), input.username).call();
    } catch (IllegalStateException e) {
        if (ChangeUserName.USERNAME_CANNOT_BE_CHANGED.equals(e.getMessage())) {
            throw new MethodNotAllowedException(e.getMessage());
        }
        throw e;
    } catch (InvalidUserNameException e) {
        throw new UnprocessableEntityException("invalid username");
    } catch (NameAlreadyUsedException e) {
        throw new ResourceConflictException("username already used");
    }
    return input.username;
}
#method_after
@Override
public String apply(AccountResource rsrc, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, ResourceConflictException, OrmException, IOException, ConfigInvalidException {
    if (!self.get().hasSameAccountId(rsrc.getUser()) && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to set username");
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME)) {
        throw new MethodNotAllowedException("realm does not allow editing username");
    }
    if (input == null) {
        input = new Input();
    }
    try {
        changeUserNameFactory.create(db.get(), rsrc.getUser(), input.username).call();
    } catch (IllegalStateException e) {
        if (ChangeUserName.USERNAME_CANNOT_BE_CHANGED.equals(e.getMessage())) {
            throw new MethodNotAllowedException(e.getMessage());
        }
        throw e;
    } catch (InvalidUserNameException e) {
        throw new UnprocessableEntityException("invalid username");
    } catch (NameAlreadyUsedException e) {
        throw new ResourceConflictException("username already used");
    }
    return input.username;
}
#end_block

#method_before
@Override
public Response<?> apply(AccountResource rsrc, Input input) throws IOException, AuthException, PermissionBackendException {
    if (!self.get().isSameAccountId(rsrc.getUser())) {
        permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT);
    }
    // evicting the account from the cache, reindexes the account
    accountCache.evict(rsrc.getUser().getAccountId());
    return Response.none();
}
#method_after
@Override
public Response<?> apply(AccountResource rsrc, Input input) throws IOException, AuthException {
    if (!self.get().hasSameAccountId(rsrc.getUser()) && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("not allowed to index account");
    }
    // evicting the account from the cache, reindexes the account
    accountCache.evict(rsrc.getUser().getAccountId());
    return Response.none();
}
#end_block

#method_before
@Override
public Star parse(AccountResource parent, IdString id) throws ResourceNotFoundException, OrmException, PermissionBackendException {
    IdentifiedUser user = parent.getUser();
    ChangeResource change = changes.parse(TopLevelResource.INSTANCE, id);
    Set<String> labels = starredChangesUtil.getLabels(user.getAccountId(), change.getId());
    return new AccountResource.Star(user, change, labels);
}
#method_after
@Override
public Star parse(AccountResource parent, IdString id) throws ResourceNotFoundException, OrmException {
    IdentifiedUser user = parent.getUser();
    ChangeResource change = changes.parse(TopLevelResource.INSTANCE, id);
    Set<String> labels = starredChangesUtil.getLabels(user.getAccountId(), change.getId());
    return new AccountResource.Star(user, change, labels);
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public List<ChangeInfo> apply(AccountResource rsrc) throws BadRequestException, AuthException, OrmException {
    if (!self.get().isSameAccountId(rsrc.getUser())) {
        throw new AuthException("not allowed to list stars of another account");
    }
    QueryChanges query = changes.list();
    query.addQuery("has:stars");
    return (List<ChangeInfo>) query.apply(TopLevelResource.INSTANCE);
}
#method_after
@Override
@SuppressWarnings("unchecked")
public List<ChangeInfo> apply(AccountResource rsrc) throws BadRequestException, AuthException, OrmException {
    if (!self.get().hasSameAccountId(rsrc.getUser())) {
        throw new AuthException("not allowed to list stars of another account");
    }
    QueryChanges query = changes.list();
    query.addQuery("has:stars");
    return (List<ChangeInfo>) query.apply(TopLevelResource.INSTANCE);
}
#end_block

#method_before
@Override
public SortedSet<String> apply(AccountResource.Star rsrc) throws AuthException, OrmException {
    if (!self.get().isSameAccountId(rsrc.getUser())) {
        throw new AuthException("not allowed to get stars of another account");
    }
    return starredChangesUtil.getLabels(self.get().getAccountId(), rsrc.getChange().getId());
}
#method_after
@Override
public SortedSet<String> apply(AccountResource.Star rsrc) throws AuthException, OrmException {
    if (!self.get().hasSameAccountId(rsrc.getUser())) {
        throw new AuthException("not allowed to get stars of another account");
    }
    return starredChangesUtil.getLabels(self.get().getAccountId(), rsrc.getChange().getId());
}
#end_block

#method_before
@Override
public Collection<String> apply(AccountResource.Star rsrc, StarsInput in) throws AuthException, BadRequestException, OrmException {
    if (!self.get().isSameAccountId(rsrc.getUser())) {
        throw new AuthException("not allowed to update stars of another account");
    }
    try {
        return starredChangesUtil.star(self.get().getAccountId(), rsrc.getChange().getProject(), rsrc.getChange().getId(), in.add, in.remove);
    } catch (IllegalLabelException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#method_after
@Override
public Collection<String> apply(AccountResource.Star rsrc, StarsInput in) throws AuthException, BadRequestException, OrmException {
    if (!self.get().hasSameAccountId(rsrc.getUser())) {
        throw new AuthException("not allowed to update stars of another account");
    }
    try {
        return starredChangesUtil.star(self.get().getAccountId(), rsrc.getChange().getProject(), rsrc.getChange().getId(), in.add, in.remove);
    } catch (IllegalLabelException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
@Override
public Response<?> apply(AccountResource resource, List<String> extIds) throws RestApiException, IOException, OrmException, ConfigInvalidException, PermissionBackendException {
    if (!self.get().isSameAccountId(resource.getUser())) {
        permissionBackend.user(self).check(GlobalPermission.ACCESS_DATABASE);
    }
    if (extIds == null || extIds.size() == 0) {
        throw new BadRequestException("external IDs are required");
    }
    Map<ExternalId.Key, ExternalId> externalIdMap = externalIds.byAccount(resource.getUser().getAccountId()).stream().collect(toMap(i -> i.key(), i -> i));
    List<ExternalId> toDelete = new ArrayList<>();
    ExternalId.Key last = resource.getUser().getLastLoginExternalIdKey();
    for (String externalIdStr : extIds) {
        ExternalId id = externalIdMap.get(ExternalId.Key.parse(externalIdStr));
        if (id == null) {
            throw new UnprocessableEntityException(String.format("External id %s does not exist", externalIdStr));
        }
        if ((!id.isScheme(SCHEME_USERNAME)) && ((last == null) || (!last.get().equals(id.key().get())))) {
            toDelete.add(id);
        } else {
            throw new ResourceConflictException(String.format("External id %s cannot be deleted", externalIdStr));
        }
    }
    try {
        accountManager.unlink(resource.getUser().getAccountId(), toDelete.stream().map(e -> e.key()).collect(toSet()));
    } catch (AccountException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(AccountResource resource, List<String> externalIds) throws RestApiException, IOException, OrmException, ConfigInvalidException {
    if (!self.get().hasSameAccountId(resource.getUser())) {
        throw new AuthException("not allowed to delete external IDs");
    }
    if (externalIds == null || externalIds.size() == 0) {
        throw new BadRequestException("external IDs are required");
    }
    Account.Id accountId = resource.getUser().getAccountId();
    Map<ExternalId.Key, ExternalId> externalIdMap = dbProvider.get().accountExternalIds().byAccount(resource.getUser().getAccountId()).toList().stream().map(ExternalId::from).collect(toMap(i -> i.key(), i -> i));
    List<ExternalId> toDelete = new ArrayList<>();
    ExternalId.Key last = resource.getUser().getLastLoginExternalIdKey();
    for (String externalIdStr : externalIds) {
        ExternalId id = externalIdMap.get(ExternalId.Key.parse(externalIdStr));
        if (id == null) {
            throw new UnprocessableEntityException(String.format("External id %s does not exist", externalIdStr));
        }
        if ((!id.isScheme(SCHEME_USERNAME)) && ((last == null) || (!last.get().equals(id.key().get())))) {
            toDelete.add(id);
        } else {
            throw new ResourceConflictException(String.format("External id %s cannot be deleted", externalIdStr));
        }
    }
    if (!toDelete.isEmpty()) {
        externalIdsUpdateFactory.create().delete(dbProvider.get(), toDelete);
        accountCache.evict(accountId);
        for (ExternalId e : toDelete) {
            accountByEmailCache.evict(e.email());
        }
    }
    return Response.none();
}
#end_block

#method_before
@Override
public GeneralPreferencesInfo apply(AccountResource rsrc) throws AuthException, PermissionBackendException {
    if (!self.get().isSameAccountId(rsrc.getUser())) {
        permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT);
    }
    Account.Id id = rsrc.getUser().getAccountId();
    return accountCache.get(id).getAccount().getGeneralPreferencesInfo();
}
#method_after
@Override
public GeneralPreferencesInfo apply(AccountResource rsrc) throws AuthException {
    if (!self.get().hasSameAccountId(rsrc.getUser()) && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("requires Modify Account capability");
    }
    Account.Id id = rsrc.getUser().getAccountId();
    return accountCache.get(id).getAccount().getGeneralPreferencesInfo();
}
#end_block

#method_before
@Override
public Capability parse(AccountResource parent, IdString id) throws ResourceNotFoundException, AuthException, PermissionBackendException {
    IdentifiedUser target = parent.getUser();
    if (!self.get().isSameAccountId(target)) {
        permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER);
    }
    GlobalOrPluginPermission perm = parse(id);
    if (permissionBackend.user(target).test(perm)) {
        return new AccountResource.Capability(target, perm.permissionName());
    }
    throw new ResourceNotFoundException(id);
}
#method_after
@Override
public Capability parse(AccountResource parent, IdString id) throws ResourceNotFoundException, AuthException {
    if (!self.get().hasSameAccountId(parent.getUser()) && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    String name = id.get();
    CapabilityControl cap = parent.getUser().getCapabilities();
    if (cap.canPerform(name) || (cap.canAdministrateServer() && GlobalCapability.isCapability(name))) {
        return new AccountResource.Capability(parent.getUser(), name);
    }
    throw new ResourceNotFoundException(id);
}
#end_block

#method_before
@Override
public Object apply(AccountResource rsrc) throws AuthException, PermissionBackendException {
    PermissionBackend.WithUser perm = permissionBackend.user(self);
    if (!self.get().isSameAccountId(rsrc.getUser())) {
        perm.check(GlobalPermission.ADMINISTRATE_SERVER);
        perm = permissionBackend.user(rsrc.getUser());
    }
    Map<String, Object> have = new LinkedHashMap<>();
    for (GlobalOrPluginPermission p : perm.test(permissionsToTest())) {
        have.put(p.permissionName(), true);
    }
    AccountLimits limits = limitsFactory.create(rsrc.getUser());
    addRanges(have, limits);
    addPriority(have, limits);
    return OutputFormat.JSON.newGson().toJsonTree(have, new TypeToken<Map<String, Object>>() {
    }.getType());
}
#method_after
@Override
public Object apply(AccountResource resource) throws AuthException {
    if (!self.get().hasSameAccountId(resource.getUser()) && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    CapabilityControl cc = resource.getUser().getCapabilities();
    Map<String, Object> have = new LinkedHashMap<>();
    for (String name : GlobalCapability.getAllNames()) {
        if (!name.equals(PRIORITY) && want(name) && cc.canPerform(name)) {
            if (GlobalCapability.hasRange(name)) {
                have.put(name, new Range(cc.getRange(name)));
            } else {
                have.put(name, true);
            }
        }
    }
    for (String pluginName : pluginCapabilities.plugins()) {
        for (String capability : pluginCapabilities.byPlugin(pluginName).keySet()) {
            String name = String.format("%s-%s", pluginName, capability);
            if (want(name) && cc.canPerform(name)) {
                have.put(name, true);
            }
        }
    }
    have.put(ACCESS_DATABASE, cc.canAccessDatabase());
    have.put(CREATE_ACCOUNT, cc.canCreateAccount());
    have.put(CREATE_GROUP, cc.canCreateGroup());
    have.put(CREATE_PROJECT, cc.canCreateProject());
    have.put(EMAIL_REVIEWERS, cc.canEmailReviewers());
    have.put(FLUSH_CACHES, cc.canFlushCaches());
    have.put(KILL_TASK, cc.canKillTask());
    have.put(MAINTAIN_SERVER, cc.canMaintainServer());
    have.put(MODIFY_ACCOUNT, cc.canModifyAccount());
    have.put(RUN_GC, cc.canRunGC());
    have.put(STREAM_EVENTS, cc.canStreamEvents());
    have.put(VIEW_ALL_ACCOUNTS, cc.canViewAllAccounts());
    have.put(VIEW_CACHES, cc.canViewCaches());
    have.put(VIEW_CONNECTIONS, cc.canViewConnections());
    have.put(VIEW_PLUGINS, cc.canViewPlugins());
    have.put(VIEW_QUEUE, cc.canViewQueue());
    QueueProvider.QueueType queue = cc.getQueueType();
    if (queue != QueueProvider.QueueType.INTERACTIVE || (query != null && query.contains(PRIORITY))) {
        have.put(PRIORITY, queue);
    }
    Iterator<Map.Entry<String, Object>> itr = have.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Object> e = itr.next();
        if (!want(e.getKey())) {
            itr.remove();
        } else if (e.getValue() instanceof Boolean && !((Boolean) e.getValue())) {
            itr.remove();
        }
    }
    return OutputFormat.JSON.newGson().toJsonTree(have, new TypeToken<Map<String, Object>>() {
    }.getType());
}
#end_block

#method_before
@Override
public OAuthTokenInfo apply(AccountResource rsrc) throws AuthException, ResourceNotFoundException {
    if (!self.get().isSameAccountId(rsrc.getUser())) {
        throw new AuthException("not allowed to get access token");
    }
    Account a = rsrc.getUser().getAccount();
    OAuthToken accessToken = tokenCache.get(a.getId());
    if (accessToken == null) {
        throw new ResourceNotFoundException();
    }
    OAuthTokenInfo accessTokenInfo = new OAuthTokenInfo();
    accessTokenInfo.username = a.getUserName();
    accessTokenInfo.resourceHost = getHostName(canonicalWebUrlProvider.get());
    accessTokenInfo.accessToken = accessToken.getToken();
    accessTokenInfo.providerId = accessToken.getProviderId();
    accessTokenInfo.expiresAt = Long.toString(accessToken.getExpiresAt());
    accessTokenInfo.type = BEARER_TYPE;
    return accessTokenInfo;
}
#method_after
@Override
public OAuthTokenInfo apply(AccountResource rsrc) throws AuthException, ResourceNotFoundException {
    if (!self.get().hasSameAccountId(rsrc.getUser())) {
        throw new AuthException("not allowed to get access token");
    }
    Account a = rsrc.getUser().getAccount();
    OAuthToken accessToken = tokenCache.get(a.getId());
    if (accessToken == null) {
        throw new ResourceNotFoundException();
    }
    OAuthTokenInfo accessTokenInfo = new OAuthTokenInfo();
    accessTokenInfo.username = a.getUserName();
    accessTokenInfo.resourceHost = getHostName(canonicalWebUrlProvider.get());
    accessTokenInfo.accessToken = accessToken.getToken();
    accessTokenInfo.providerId = accessToken.getProviderId();
    accessTokenInfo.expiresAt = Long.toString(accessToken.getExpiresAt());
    accessTokenInfo.type = BEARER_TYPE;
    return accessTokenInfo;
}
#end_block

#method_before
private static String getHostName(String canonicalWebUrl) {
    if (canonicalWebUrl == null) {
        log.error("No canonicalWebUrl defined in gerrit.config, OAuth may not work properly");
        return null;
    }
    try {
        return new URI(canonicalWebUrl).getHost();
    } catch (URISyntaxException e) {
        log.error("Invalid canonicalWebUrl '" + canonicalWebUrl + "'", e);
        return null;
    }
}
#method_after
private static String getHostName(String canonicalWebUrl) {
    try {
        return new URI(canonicalWebUrl).getHost();
    } catch (URISyntaxException e) {
        return null;
    }
}
#end_block

#method_before
@Override
public List<AccountExternalIdInfo> apply(AccountResource resource) throws RestApiException, IOException, OrmException, PermissionBackendException {
    if (!self.get().isSameAccountId(resource.getUser())) {
        permissionBackend.user(self).check(GlobalPermission.ACCESS_DATABASE);
    }
    Collection<ExternalId> ids = externalIds.byAccount(resource.getUser().getAccountId());
    if (ids.isEmpty()) {
        return ImmutableList.of();
    }
    List<AccountExternalIdInfo> result = Lists.newArrayListWithCapacity(ids.size());
    for (ExternalId id : ids) {
        AccountExternalIdInfo info = new AccountExternalIdInfo();
        info.identity = id.key().get();
        info.emailAddress = id.email();
        info.trusted = toBoolean(authConfig.isIdentityTrustable(Collections.singleton(id)));
        // actually used to establish this web session.
        if (!id.isScheme(SCHEME_USERNAME)) {
            ExternalId.Key last = resource.getUser().getLastLoginExternalIdKey();
            info.canDelete = toBoolean(last == null || !last.get().equals(info.identity));
        }
        result.add(info);
    }
    return result;
}
#method_after
@Override
public List<AccountExternalIdInfo> apply(AccountResource resource) throws RestApiException, OrmException {
    if (!self.get().hasSameAccountId(resource.getUser())) {
        throw new AuthException("not allowed to get external IDs");
    }
    Collection<ExternalId> ids = ExternalId.from(db.get().accountExternalIds().byAccount(resource.getUser().getAccountId()).toList());
    if (ids.isEmpty()) {
        return ImmutableList.of();
    }
    List<AccountExternalIdInfo> result = Lists.newArrayListWithCapacity(ids.size());
    for (ExternalId id : ids) {
        AccountExternalIdInfo info = new AccountExternalIdInfo();
        info.identity = id.key().get();
        info.emailAddress = id.email();
        info.trusted = toBoolean(authConfig.isIdentityTrustable(Collections.singleton(id)));
        // actually used to establish this web session.
        if (!id.isScheme(SCHEME_USERNAME)) {
            ExternalId.Key last = resource.getUser().getLastLoginExternalIdKey();
            info.canDelete = toBoolean(last == null || !last.get().equals(info.identity));
        }
        result.add(info);
    }
    return result;
}
#end_block

#method_before
@Override
public GeneralPreferencesInfo apply(AccountResource rsrc, GeneralPreferencesInfo i) throws AuthException, BadRequestException, IOException, ConfigInvalidException, PermissionBackendException {
    if (!self.get().isSameAccountId(rsrc.getUser())) {
        permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT);
    }
    checkDownloadScheme(i.downloadScheme);
    Account.Id id = rsrc.getUser().getAccountId();
    GeneralPreferencesInfo n = loader.merge(id, i);
    n.changeTable = i.changeTable;
    n.my = i.my;
    n.urlAliases = i.urlAliases;
    writeToGit(id, n);
    return cache.get(id).getAccount().getGeneralPreferencesInfo();
}
#method_after
@Override
public GeneralPreferencesInfo apply(AccountResource rsrc, GeneralPreferencesInfo i) throws AuthException, BadRequestException, IOException, ConfigInvalidException {
    if (!self.get().hasSameAccountId(rsrc.getUser()) && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("requires Modify Account capability");
    }
    checkDownloadScheme(i.downloadScheme);
    Account.Id id = rsrc.getUser().getAccountId();
    GeneralPreferencesInfo n = loader.merge(id, i);
    n.changeTable = i.changeTable;
    n.my = i.my;
    n.urlAliases = i.urlAliases;
    writeToGit(id, n);
    return cache.get(id).getAccount().getGeneralPreferencesInfo();
}
#end_block

#method_before
private void writeToGit(Account.Id id, GeneralPreferencesInfo i) throws RepositoryNotFoundException, IOException, ConfigInvalidException, BadRequestException {
    VersionedAccountPreferences prefs;
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName)) {
        prefs = VersionedAccountPreferences.forUser(id);
        prefs.load(md);
        storeSection(prefs.getConfig(), UserConfigSections.GENERAL, null, i, loader.readDefaultsFromGit(md.getRepository(), null));
        storeMyChangeTableColumns(prefs, i.changeTable);
        storeMyMenus(prefs, i.my);
        storeUrlAliases(prefs, i.urlAliases);
        prefs.commit(md);
        cache.evict(id);
    }
}
#method_after
private void writeToGit(Account.Id id, GeneralPreferencesInfo i) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    VersionedAccountPreferences prefs;
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName)) {
        prefs = VersionedAccountPreferences.forUser(id);
        prefs.load(md);
        storeSection(prefs.getConfig(), UserConfigSections.GENERAL, null, i, loader.readDefaultsFromGit(md.getRepository(), null));
        storeMyChangeTableColumns(prefs, i.changeTable);
        storeMyMenus(prefs, i.my);
        storeUrlAliases(prefs, i.urlAliases);
        prefs.commit(md);
        cache.evict(id);
    }
}
#end_block

#method_before
public static void storeMyMenus(VersionedAccountPreferences prefs, List<MenuItem> my) throws BadRequestException {
    Config cfg = prefs.getConfig();
    if (my != null) {
        unsetSection(cfg, UserConfigSections.MY);
        for (MenuItem item : my) {
            checkRequiredMenuItemField(item.name, "name");
            checkRequiredMenuItemField(item.url, "URL");
            set(cfg, item.name, KEY_URL, item.url);
            set(cfg, item.name, KEY_TARGET, item.target);
            set(cfg, item.name, KEY_ID, item.id);
        }
    }
}
#method_after
public static void storeMyMenus(VersionedAccountPreferences prefs, List<MenuItem> my) {
    Config cfg = prefs.getConfig();
    if (my != null) {
        unsetSection(cfg, UserConfigSections.MY);
        for (MenuItem item : my) {
            set(cfg, item.name, KEY_URL, item.url);
            set(cfg, item.name, KEY_TARGET, item.target);
            set(cfg, item.name, KEY_ID, item.id);
        }
    }
}
#end_block

#method_before
private static void set(Config cfg, String section, String key, @Nullable String val) {
    if (val == null || val.trim().isEmpty()) {
        cfg.unset(UserConfigSections.MY, section.trim(), key);
    } else {
        cfg.setString(UserConfigSections.MY, section.trim(), key, val.trim());
    }
}
#method_after
private static void set(Config cfg, String section, String key, String val) {
    if (Strings.isNullOrEmpty(val)) {
        cfg.unset(UserConfigSections.MY, section, key);
    } else {
        cfg.setString(UserConfigSections.MY, section, key, val);
    }
}
#end_block

#method_before
@Override
public Response<String> apply(AccountResource rsrc, Input input) throws AuthException, ResourceNotFoundException, OrmException, IOException, PermissionBackendException, ConfigInvalidException {
    if (!self.get().isSameAccountId(rsrc.getUser())) {
        permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT);
    }
    return apply(rsrc.getUser(), input);
}
#method_after
@Override
public Response<String> apply(AccountResource rsrc, Input input) throws AuthException, ResourceNotFoundException, OrmException, IOException {
    if (!self.get().hasSameAccountId(rsrc.getUser()) && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("not allowed to set status");
    }
    return apply(rsrc.getUser(), input);
}
#end_block

#method_before
public Response<String> apply(IdentifiedUser user, Input input) throws ResourceNotFoundException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new Input();
    }
    String newStatus = input.status;
    Account account = accountsUpdate.create().update(user.getAccountId(), a -> a.setStatus(Strings.nullToEmpty(newStatus)));
    if (account == null) {
        throw new ResourceNotFoundException("account not found");
    }
    return Strings.isNullOrEmpty(account.getStatus()) ? Response.none() : Response.ok(account.getStatus());
}
#method_after
public Response<String> apply(IdentifiedUser user, Input input) throws ResourceNotFoundException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    String newStatus = input.status;
    Account a = dbProvider.get().accounts().atomicUpdate(user.getAccountId(), new AtomicUpdate<Account>() {

        @Override
        public Account update(Account a) {
            a.setStatus(Strings.nullToEmpty(newStatus));
            return a;
        }
    });
    if (a == null) {
        throw new ResourceNotFoundException("account not found");
    }
    byIdCache.evict(a.getId());
    return Strings.isNullOrEmpty(a.getStatus()) ? Response.none() : Response.ok(a.getStatus());
}
#end_block

#method_before
@Override
public List<ProjectWatchInfo> apply(AccountResource rsrc) throws OrmException, AuthException, IOException, ConfigInvalidException, PermissionBackendException {
    if (!self.get().isSameAccountId(rsrc.getUser())) {
        permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER);
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    List<ProjectWatchInfo> projectWatchInfos = new ArrayList<>();
    for (Map.Entry<ProjectWatchKey, Set<NotifyType>> e : watchConfig.getProjectWatches(accountId).entrySet()) {
        ProjectWatchInfo pwi = new ProjectWatchInfo();
        pwi.filter = e.getKey().filter();
        pwi.project = e.getKey().project().get();
        pwi.notifyAbandonedChanges = toBoolean(e.getValue().contains(NotifyType.ABANDONED_CHANGES));
        pwi.notifyNewChanges = toBoolean(e.getValue().contains(NotifyType.NEW_CHANGES));
        pwi.notifyNewPatchSets = toBoolean(e.getValue().contains(NotifyType.NEW_PATCHSETS));
        pwi.notifySubmittedChanges = toBoolean(e.getValue().contains(NotifyType.SUBMITTED_CHANGES));
        pwi.notifyAllComments = toBoolean(e.getValue().contains(NotifyType.ALL_COMMENTS));
        projectWatchInfos.add(pwi);
    }
    Collections.sort(projectWatchInfos, new Comparator<ProjectWatchInfo>() {

        @Override
        public int compare(ProjectWatchInfo pwi1, ProjectWatchInfo pwi2) {
            return ComparisonChain.start().compare(pwi1.project, pwi2.project).compare(Strings.nullToEmpty(pwi1.filter), Strings.nullToEmpty(pwi2.filter)).result();
        }
    });
    return projectWatchInfos;
}
#method_after
@Override
public List<ProjectWatchInfo> apply(AccountResource rsrc) throws OrmException, AuthException, IOException, ConfigInvalidException {
    if (!self.get().hasSameAccountId(rsrc.getUser()) && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("It is not allowed to list project watches of other users");
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    List<ProjectWatchInfo> projectWatchInfos = new ArrayList<>();
    for (Map.Entry<ProjectWatchKey, Set<NotifyType>> e : watchConfig.getProjectWatches(accountId).entrySet()) {
        ProjectWatchInfo pwi = new ProjectWatchInfo();
        pwi.filter = e.getKey().filter();
        pwi.project = e.getKey().project().get();
        pwi.notifyAbandonedChanges = toBoolean(e.getValue().contains(NotifyType.ABANDONED_CHANGES));
        pwi.notifyNewChanges = toBoolean(e.getValue().contains(NotifyType.NEW_CHANGES));
        pwi.notifyNewPatchSets = toBoolean(e.getValue().contains(NotifyType.NEW_PATCHSETS));
        pwi.notifySubmittedChanges = toBoolean(e.getValue().contains(NotifyType.SUBMITTED_CHANGES));
        pwi.notifyAllComments = toBoolean(e.getValue().contains(NotifyType.ALL_COMMENTS));
        projectWatchInfos.add(pwi);
    }
    Collections.sort(projectWatchInfos, new Comparator<ProjectWatchInfo>() {

        @Override
        public int compare(ProjectWatchInfo pwi1, ProjectWatchInfo pwi2) {
            return ComparisonChain.start().compare(pwi1.project, pwi2.project).compare(Strings.nullToEmpty(pwi1.filter), Strings.nullToEmpty(pwi2.filter)).result();
        }
    });
    return projectWatchInfos;
}
#end_block

#method_before
@Override
public Response<String> apply(AccountResource rsrc, Input input) throws AuthException, MethodNotAllowedException, ResourceNotFoundException, OrmException, IOException, PermissionBackendException, ConfigInvalidException {
    if (!self.get().isSameAccountId(rsrc.getUser())) {
        permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT);
    }
    return apply(rsrc.getUser(), input);
}
#method_after
@Override
public Response<String> apply(AccountResource rsrc, Input input) throws AuthException, MethodNotAllowedException, ResourceNotFoundException, OrmException, IOException {
    if (!self.get().hasSameAccountId(rsrc.getUser()) && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("not allowed to change name");
    }
    return apply(rsrc.getUser(), input);
}
#end_block

#method_before
public Response<String> apply(IdentifiedUser user, Input input) throws MethodNotAllowedException, ResourceNotFoundException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new Input();
    }
    if (!realm.allowsEdit(AccountFieldName.FULL_NAME)) {
        throw new MethodNotAllowedException("realm does not allow editing name");
    }
    String newName = input.name;
    Account account = accountsUpdate.create().update(user.getAccountId(), a -> a.setFullName(newName));
    if (account == null) {
        throw new ResourceNotFoundException("account not found");
    }
    return Strings.isNullOrEmpty(account.getFullName()) ? Response.none() : Response.ok(account.getFullName());
}
#method_after
public Response<String> apply(IdentifiedUser user, Input input) throws MethodNotAllowedException, ResourceNotFoundException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (!realm.allowsEdit(AccountFieldName.FULL_NAME)) {
        throw new MethodNotAllowedException("realm does not allow editing name");
    }
    String newName = input.name;
    Account a = dbProvider.get().accounts().atomicUpdate(user.getAccountId(), new AtomicUpdate<Account>() {

        @Override
        public Account update(Account a) {
            a.setFullName(newName);
            return a;
        }
    });
    if (a == null) {
        throw new ResourceNotFoundException("account not found");
    }
    byIdCache.evict(a.getId());
    return Strings.isNullOrEmpty(a.getFullName()) ? Response.<String>none() : Response.ok(a.getFullName());
}
#end_block

#method_before
@Override
public Response<EmailInfo> apply(AccountResource rsrc, EmailInput input) throws AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, OrmException, EmailException, MethodNotAllowedException, IOException, ConfigInvalidException, PermissionBackendException {
    if (input == null) {
        input = new EmailInput();
    }
    if (!self.get().isSameAccountId(rsrc.getUser()) || input.noConfirmation) {
        permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT);
    }
    if (!realm.allowsEdit(AccountFieldName.REGISTER_NEW_EMAIL)) {
        throw new MethodNotAllowedException("realm does not allow adding emails");
    }
    return apply(rsrc.getUser(), input);
}
#method_after
@Override
public Response<EmailInfo> apply(AccountResource rsrc, EmailInput input) throws AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, OrmException, EmailException, MethodNotAllowedException, IOException, ConfigInvalidException {
    if (!self.get().hasSameAccountId(rsrc.getUser()) && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("not allowed to add email address");
    }
    if (input == null) {
        input = new EmailInput();
    }
    if (input.noConfirmation && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("not allowed to use no_confirmation");
    }
    if (!realm.allowsEdit(AccountFieldName.REGISTER_NEW_EMAIL)) {
        throw new MethodNotAllowedException("realm does not allow adding emails");
    }
    return apply(rsrc.getUser(), input);
}
#end_block

#method_before
public Response<EmailInfo> apply(IdentifiedUser user, EmailInput input) throws AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, OrmException, EmailException, MethodNotAllowedException, IOException, ConfigInvalidException, PermissionBackendException {
    if (input == null) {
        input = new EmailInput();
    }
    if (input.email != null && !email.equals(input.email)) {
        throw new BadRequestException("email address must match URL");
    }
    if (!validator.isValid(email)) {
        throw new BadRequestException("invalid email address");
    }
    EmailInfo info = new EmailInfo();
    info.email = email;
    if (input.noConfirmation || isDevMode) {
        if (isDevMode) {
            log.warn("skipping email validation in developer mode");
        }
        try {
            accountManager.link(user.getAccountId(), AuthRequest.forEmail(email));
        } catch (AccountException e) {
            throw new ResourceConflictException(e.getMessage());
        }
        if (input.preferred) {
            putPreferred.apply(new AccountResource.Email(user, email), null);
            info.preferred = true;
        }
    } else {
        try {
            RegisterNewEmailSender sender = registerNewEmailFactory.create(email);
            if (!sender.isAllowed()) {
                throw new MethodNotAllowedException("Not allowed to add email address " + email);
            }
            sender.send();
            info.pendingConfirmation = true;
        } catch (EmailException | RuntimeException e) {
            log.error("Cannot send email verification message to " + email, e);
            throw e;
        }
    }
    return Response.created(info);
}
#method_after
public Response<EmailInfo> apply(IdentifiedUser user, EmailInput input) throws AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, OrmException, EmailException, MethodNotAllowedException, IOException {
    if (input == null) {
        input = new EmailInput();
    }
    if (input.email != null && !email.equals(input.email)) {
        throw new BadRequestException("email address must match URL");
    }
    if (!OutgoingEmailValidator.isValid(email)) {
        throw new BadRequestException("invalid email address");
    }
    EmailInfo info = new EmailInfo();
    info.email = email;
    if (input.noConfirmation || isDevMode) {
        if (isDevMode) {
            log.warn("skipping email validation in developer mode");
        }
        try {
            accountManager.link(user.getAccountId(), AuthRequest.forEmail(email));
        } catch (AccountException e) {
            throw new ResourceConflictException(e.getMessage());
        }
        if (input.preferred) {
            putPreferred.apply(new AccountResource.Email(user, email), null);
            info.preferred = true;
        }
    } else {
        try {
            RegisterNewEmailSender sender = registerNewEmailFactory.create(email);
            if (!sender.isAllowed()) {
                throw new MethodNotAllowedException("Not allowed to add email address " + email);
            }
            sender.send();
            info.pendingConfirmation = true;
        } catch (EmailException | RuntimeException e) {
            log.error("Cannot send email verification message to " + email, e);
            throw e;
        }
    }
    return Response.created(info);
}
#end_block

#method_before
@Override
public Response<String> apply(AccountResource resource, AgreementInput input) throws IOException, OrmException, RestApiException {
    if (!agreementsEnabled) {
        throw new MethodNotAllowedException("contributor agreements disabled");
    }
    if (!self.get().isSameAccountId(resource.getUser())) {
        throw new AuthException("not allowed to enter contributor agreement");
    }
    String agreementName = Strings.nullToEmpty(input.name);
    ContributorAgreement ca = projectCache.getAllProjects().getConfig().getContributorAgreement(agreementName);
    if (ca == null) {
        throw new UnprocessableEntityException("contributor agreement not found");
    }
    if (ca.getAutoVerify() == null) {
        throw new BadRequestException("cannot enter a non-autoVerify agreement");
    }
    AccountGroup.UUID uuid = ca.getAutoVerify().getUUID();
    if (uuid == null) {
        throw new ResourceConflictException("autoverify group uuid not found");
    }
    Account account = self.get().getAccount();
    try {
        addMembers.addMembers(uuid, ImmutableList.of(account.getId()));
    } catch (NoSuchGroupException e) {
        throw new ResourceConflictException("autoverify group not found");
    }
    agreementSignup.fire(account, agreementName);
    return Response.ok(agreementName);
}
#method_after
@Override
public Response<String> apply(AccountResource resource, AgreementInput input) throws IOException, OrmException, RestApiException {
    if (!agreementsEnabled) {
        throw new MethodNotAllowedException("contributor agreements disabled");
    }
    if (!self.get().hasSameAccountId(resource.getUser())) {
        throw new AuthException("not allowed to enter contributor agreement");
    }
    String agreementName = Strings.nullToEmpty(input.name);
    ContributorAgreement ca = projectCache.getAllProjects().getConfig().getContributorAgreement(agreementName);
    if (ca == null) {
        throw new UnprocessableEntityException("contributor agreement not found");
    }
    if (ca.getAutoVerify() == null) {
        throw new BadRequestException("cannot enter a non-autoVerify agreement");
    }
    AccountGroup.UUID uuid = ca.getAutoVerify().getUUID();
    if (uuid == null) {
        throw new ResourceConflictException("autoverify group uuid not found");
    }
    AccountGroup group = groupCache.get(uuid);
    if (group == null) {
        throw new ResourceConflictException("autoverify group not found");
    }
    Account account = self.get().getAccount();
    addMembers.addMembers(group.getId(), ImmutableList.of(account.getId()));
    agreementSignup.fire(account, agreementName);
    return Response.ok(agreementName);
}
#end_block

#method_before
@Override
public EditPreferencesInfo apply(AccountResource rsrc) throws AuthException, IOException, ConfigInvalidException, PermissionBackendException {
    if (!self.get().isSameAccountId(rsrc.getUser())) {
        permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT);
    }
    return readFromGit(rsrc.getUser().getAccountId(), gitMgr, allUsersName, null);
}
#method_after
@Override
public EditPreferencesInfo apply(AccountResource rsrc) throws AuthException, IOException, ConfigInvalidException {
    if (!self.get().hasSameAccountId(rsrc.getUser()) && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("requires Modify Account capability");
    }
    return readFromGit(rsrc.getUser().getAccountId(), gitMgr, allUsersName, null);
}
#end_block

#method_before
@Override
public List<SshKeyInfo> apply(AccountResource rsrc) throws AuthException, OrmException, RepositoryNotFoundException, IOException, ConfigInvalidException, PermissionBackendException {
    if (!self.get().isSameAccountId(rsrc.getUser())) {
        permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT);
    }
    return apply(rsrc.getUser());
}
#method_after
@Override
public List<SshKeyInfo> apply(AccountResource rsrc) throws AuthException, OrmException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    if (!self.get().hasSameAccountId(rsrc.getUser()) && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("not allowed to get SSH keys");
    }
    return apply(rsrc.getUser());
}
#end_block

#method_before
@Override
public AccountResource.StarredChange parse(AccountResource parent, IdString id) throws ResourceNotFoundException, OrmException, PermissionBackendException {
    IdentifiedUser user = parent.getUser();
    ChangeResource change = changes.parse(TopLevelResource.INSTANCE, id);
    if (starredChangesUtil.getLabels(user.getAccountId(), change.getId()).contains(StarredChangesUtil.DEFAULT_LABEL)) {
        return new AccountResource.StarredChange(user, change);
    }
    throw new ResourceNotFoundException(id);
}
#method_after
@Override
public AccountResource.StarredChange parse(AccountResource parent, IdString id) throws ResourceNotFoundException, OrmException {
    IdentifiedUser user = parent.getUser();
    ChangeResource change = changes.parse(TopLevelResource.INSTANCE, id);
    if (starredChangesUtil.getLabels(user.getAccountId(), change.getId()).contains(StarredChangesUtil.DEFAULT_LABEL)) {
        return new AccountResource.StarredChange(user, change);
    }
    throw new ResourceNotFoundException(id);
}
#end_block

#method_before
@Override
public RestModifyView<AccountResource, EmptyInput> create(AccountResource parent, IdString id) throws UnprocessableEntityException {
    try {
        return createProvider.get().setChange(changes.parse(TopLevelResource.INSTANCE, id));
    } catch (ResourceNotFoundException e) {
        throw new UnprocessableEntityException(String.format("change %s not found", id.get()));
    } catch (OrmException | PermissionBackendException e) {
        log.error("cannot resolve change", e);
        throw new UnprocessableEntityException("internal server error");
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public RestModifyView<AccountResource, EmptyInput> create(AccountResource parent, IdString id) throws UnprocessableEntityException {
    try {
        return createProvider.get().setChange(changes.parse(TopLevelResource.INSTANCE, id));
    } catch (ResourceNotFoundException e) {
        throw new UnprocessableEntityException(String.format("change %s not found", id.get()));
    } catch (OrmException e) {
        log.error("cannot resolve change", e);
        throw new UnprocessableEntityException("internal server error");
    }
}
#end_block

#method_before
@Override
public Response<?> apply(AccountResource rsrc, EmptyInput in) throws RestApiException, OrmException, IOException {
    if (!self.get().isSameAccountId(rsrc.getUser())) {
        throw new AuthException("not allowed to add starred change");
    }
    try {
        starredChangesUtil.star(self.get().getAccountId(), change.getProject(), change.getId(), StarredChangesUtil.DEFAULT_LABELS, null);
    } catch (MutuallyExclusiveLabelsException e) {
        throw new ResourceConflictException(e.getMessage());
    } catch (IllegalLabelException e) {
        throw new BadRequestException(e.getMessage());
    } catch (OrmDuplicateKeyException e) {
        return Response.none();
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(AccountResource rsrc, EmptyInput in) throws AuthException, OrmException, IOException {
    if (!self.get().hasSameAccountId(rsrc.getUser())) {
        throw new AuthException("not allowed to add starred change");
    }
    try {
        starredChangesUtil.star(self.get().getAccountId(), change.getProject(), change.getId(), StarredChangesUtil.DEFAULT_LABELS, null);
    } catch (OrmDuplicateKeyException e) {
        return Response.none();
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Response<?> apply(AccountResource.StarredChange rsrc, EmptyInput in) throws AuthException {
    if (!self.get().isSameAccountId(rsrc.getUser())) {
        throw new AuthException("not allowed update starred changes");
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(AccountResource.StarredChange rsrc, EmptyInput in) throws AuthException {
    if (!self.get().hasSameAccountId(rsrc.getUser())) {
        throw new AuthException("not allowed update starred changes");
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Response<?> apply(AccountResource.StarredChange rsrc, EmptyInput in) throws AuthException, OrmException, IOException, IllegalLabelException {
    if (!self.get().isSameAccountId(rsrc.getUser())) {
        throw new AuthException("not allowed remove starred change");
    }
    starredChangesUtil.star(self.get().getAccountId(), rsrc.getChange().getProject(), rsrc.getChange().getId(), null, StarredChangesUtil.DEFAULT_LABELS);
    return Response.none();
}
#method_after
@Override
public Response<?> apply(AccountResource.StarredChange rsrc, EmptyInput in) throws AuthException, OrmException, IOException {
    if (!self.get().hasSameAccountId(rsrc.getUser())) {
        throw new AuthException("not allowed remove starred change");
    }
    starredChangesUtil.star(self.get().getAccountId(), rsrc.getChange().getProject(), rsrc.getChange().getId(), null, StarredChangesUtil.DEFAULT_LABELS);
    return Response.none();
}
#end_block

#method_before
@Override
public Response<?> apply(AccountResource.Email rsrc, Input input) throws AuthException, ResourceNotFoundException, ResourceConflictException, MethodNotAllowedException, OrmException, IOException, ConfigInvalidException, PermissionBackendException {
    if (!self.get().isSameAccountId(rsrc.getUser())) {
        permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT);
    }
    return apply(rsrc.getUser(), rsrc.getEmail());
}
#method_after
@Override
public Response<?> apply(AccountResource.Email rsrc, Input input) throws AuthException, ResourceNotFoundException, ResourceConflictException, MethodNotAllowedException, OrmException, IOException, ConfigInvalidException {
    if (!self.get().hasSameAccountId(rsrc.getUser()) && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("not allowed to delete email address");
    }
    return apply(rsrc.getUser(), rsrc.getEmail());
}
#end_block

#method_before
public Response<?> apply(IdentifiedUser user, String email) throws ResourceNotFoundException, ResourceConflictException, MethodNotAllowedException, OrmException, IOException, ConfigInvalidException {
    if (!realm.allowsEdit(AccountFieldName.REGISTER_NEW_EMAIL)) {
        throw new MethodNotAllowedException("realm does not allow deleting emails");
    }
    Set<ExternalId> extIds = externalIds.byAccount(user.getAccountId()).stream().filter(e -> email.equals(e.email())).collect(toSet());
    if (extIds.isEmpty()) {
        throw new ResourceNotFoundException(email);
    }
    try {
        accountManager.unlink(user.getAccountId(), extIds.stream().map(e -> e.key()).collect(toSet()));
    } catch (AccountException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#method_after
public Response<?> apply(IdentifiedUser user, String email) throws ResourceNotFoundException, ResourceConflictException, MethodNotAllowedException, OrmException, IOException {
    if (!realm.allowsEdit(AccountFieldName.REGISTER_NEW_EMAIL)) {
        throw new MethodNotAllowedException("realm does not allow deleting emails");
    }
    Set<ExternalId> extIds = dbProvider.get().accountExternalIds().byAccount(user.getAccountId()).toList().stream().map(ExternalId::from).filter(e -> email.equals(e.email())).collect(toSet());
    if (extIds.isEmpty()) {
        throw new ResourceNotFoundException(email);
    }
    try {
        for (ExternalId extId : extIds) {
            AuthRequest authRequest = new AuthRequest(extId.key());
            authRequest.setEmailAddress(email);
            accountManager.unlink(user.getAccountId(), authRequest);
        }
    } catch (AccountException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Response<String> apply(AccountResource rsrc, Input input) throws AuthException, ResourceNotFoundException, ResourceConflictException, OrmException, IOException, ConfigInvalidException, PermissionBackendException {
    if (!self.get().isSameAccountId(rsrc.getUser())) {
        permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER);
    }
    if (input == null) {
        input = new Input();
    }
    input.httpPassword = Strings.emptyToNull(input.httpPassword);
    String newPassword;
    if (input.generate) {
        newPassword = generate();
    } else if (input.httpPassword == null) {
        newPassword = null;
    } else {
        // Only administrators can explicitly set the password.
        permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER);
        newPassword = input.httpPassword;
    }
    return apply(rsrc.getUser(), newPassword);
}
#method_after
@Override
public Response<String> apply(AccountResource rsrc, Input input) throws AuthException, ResourceNotFoundException, ResourceConflictException, OrmException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new Input();
    }
    input.httpPassword = Strings.emptyToNull(input.httpPassword);
    String newPassword;
    if (input.generate) {
        if (!self.get().hasSameAccountId(rsrc.getUser()) && !self.get().getCapabilities().canAdministrateServer()) {
            throw new AuthException("not allowed to generate HTTP password");
        }
        newPassword = generate();
    } else if (input.httpPassword == null) {
        if (!self.get().hasSameAccountId(rsrc.getUser()) && !self.get().getCapabilities().canAdministrateServer()) {
            throw new AuthException("not allowed to clear HTTP password");
        }
        newPassword = null;
    } else {
        if (!self.get().getCapabilities().canAdministrateServer()) {
            throw new AuthException("not allowed to set HTTP password directly, " + "requires the Administrate Server permission");
        }
        newPassword = input.httpPassword;
    }
    return apply(rsrc.getUser(), newPassword);
}
#end_block

#method_before
public Response<String> apply(IdentifiedUser user, String newPassword) throws ResourceNotFoundException, ResourceConflictException, OrmException, IOException, ConfigInvalidException {
    if (user.getUserName() == null) {
        throw new ResourceConflictException("username must be set");
    }
    ExternalId extId = externalIds.get(ExternalId.Key.create(SCHEME_USERNAME, user.getUserName()));
    if (extId == null) {
        throw new ResourceNotFoundException();
    }
    ExternalId newExtId = ExternalId.createWithPassword(extId.key(), extId.accountId(), extId.email(), newPassword);
    externalIdsUpdate.create().upsert(newExtId);
    return Strings.isNullOrEmpty(newPassword) ? Response.<String>none() : Response.ok(newPassword);
}
#method_after
public Response<String> apply(IdentifiedUser user, String newPassword) throws ResourceNotFoundException, ResourceConflictException, OrmException, IOException {
    if (user.getUserName() == null) {
        throw new ResourceConflictException("username must be set");
    }
    ExternalId extId = ExternalId.from(dbProvider.get().accountExternalIds().get(ExternalId.Key.create(SCHEME_USERNAME, user.getUserName()).asAccountExternalIdKey()));
    if (extId == null) {
        throw new ResourceNotFoundException();
    }
    ExternalId newExtId = ExternalId.createWithPassword(extId.key(), extId.accountId(), extId.email(), newPassword);
    externalIdsUpdate.create().upsert(dbProvider.get(), newExtId);
    return Strings.isNullOrEmpty(newPassword) ? Response.<String>none() : Response.ok(newPassword);
}
#end_block

#method_before
@Override
public List<ProjectWatchInfo> apply(AccountResource rsrc, List<ProjectWatchInfo> input) throws OrmException, RestApiException, IOException, ConfigInvalidException, PermissionBackendException {
    if (!self.get().isSameAccountId(rsrc.getUser())) {
        permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER);
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    watchConfig.upsertProjectWatches(accountId, asMap(input));
    accountCache.evict(accountId);
    return getWatchedProjects.apply(rsrc);
}
#method_after
@Override
public List<ProjectWatchInfo> apply(AccountResource rsrc, List<ProjectWatchInfo> input) throws OrmException, RestApiException, IOException, ConfigInvalidException {
    if (!self.get().hasSameAccountId(rsrc.getUser()) && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to edit project watches");
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    watchConfig.upsertProjectWatches(accountId, asMap(input));
    accountCache.evict(accountId);
    return getWatchedProjects.apply(rsrc);
}
#end_block

#method_before
private Map<ProjectWatchKey, Set<NotifyType>> asMap(List<ProjectWatchInfo> input) throws BadRequestException, UnprocessableEntityException, IOException, PermissionBackendException {
    Map<ProjectWatchKey, Set<NotifyType>> m = new HashMap<>();
    for (ProjectWatchInfo info : input) {
        if (info.project == null) {
            throw new BadRequestException("project name must be specified");
        }
        ProjectWatchKey key = ProjectWatchKey.create(projectsCollection.parse(info.project).getNameKey(), info.filter);
        if (m.containsKey(key)) {
            throw new BadRequestException("duplicate entry for project " + format(info.project, info.filter));
        }
        Set<NotifyType> notifyValues = EnumSet.noneOf(NotifyType.class);
        if (toBoolean(info.notifyAbandonedChanges)) {
            notifyValues.add(NotifyType.ABANDONED_CHANGES);
        }
        if (toBoolean(info.notifyAllComments)) {
            notifyValues.add(NotifyType.ALL_COMMENTS);
        }
        if (toBoolean(info.notifyNewChanges)) {
            notifyValues.add(NotifyType.NEW_CHANGES);
        }
        if (toBoolean(info.notifyNewPatchSets)) {
            notifyValues.add(NotifyType.NEW_PATCHSETS);
        }
        if (toBoolean(info.notifySubmittedChanges)) {
            notifyValues.add(NotifyType.SUBMITTED_CHANGES);
        }
        m.put(key, notifyValues);
    }
    return m;
}
#method_after
private Map<ProjectWatchKey, Set<NotifyType>> asMap(List<ProjectWatchInfo> input) throws BadRequestException, UnprocessableEntityException, IOException {
    Map<ProjectWatchKey, Set<NotifyType>> m = new HashMap<>();
    for (ProjectWatchInfo info : input) {
        if (info.project == null) {
            throw new BadRequestException("project name must be specified");
        }
        ProjectWatchKey key = ProjectWatchKey.create(projectsCollection.parse(info.project).getNameKey(), info.filter);
        if (m.containsKey(key)) {
            throw new BadRequestException("duplicate entry for project " + format(info.project, info.filter));
        }
        Set<NotifyType> notifyValues = EnumSet.noneOf(NotifyType.class);
        if (toBoolean(info.notifyAbandonedChanges)) {
            notifyValues.add(NotifyType.ABANDONED_CHANGES);
        }
        if (toBoolean(info.notifyAllComments)) {
            notifyValues.add(NotifyType.ALL_COMMENTS);
        }
        if (toBoolean(info.notifyNewChanges)) {
            notifyValues.add(NotifyType.NEW_CHANGES);
        }
        if (toBoolean(info.notifyNewPatchSets)) {
            notifyValues.add(NotifyType.NEW_PATCHSETS);
        }
        if (toBoolean(info.notifySubmittedChanges)) {
            notifyValues.add(NotifyType.SUBMITTED_CHANGES);
        }
        m.put(key, notifyValues);
    }
    return m;
}
#end_block

#method_before
private String getMetricName(String queueName, String metricsName) {
    String name = CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, queueName.replaceFirst("SSH", "Ssh").replaceAll("-", ""));
    return String.format("queue/%s/%s", name, metricsName);
}
#method_after
private String getMetricName(String queueName, String metricName) {
    String name = CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, queueName.replaceFirst("SSH", "Ssh").replaceAll("-", ""));
    return String.format("queue/%s/%s", name, metricName);
}
#end_block

#method_before
@Override
public Result indexAll(ChangeIndex index) {
    ProgressMonitor pm = new TextProgressMonitor();
    pm.beginTask("Collecting projects", ProgressMonitor.UNKNOWN);
    SortedSet<ProjectHolder> projects = new TreeSet<>();
    int changeCount = 0;
    for (Project.NameKey name : projectCache.all()) {
        try (Repository repo = repoManager.openRepository(name)) {
            int size = ChangeNotes.Factory.scan(repo).size();
            changeCount += size;
            projects.add(new ProjectHolder(name, size));
        } catch (IOException e) {
            log.error("Error collecting projects", e);
        }
        pm.update(1);
    }
    pm.endTask();
    setTotalWork(changeCount);
    return indexAll(index, projects);
}
#method_after
@Override
public Result indexAll(ChangeIndex index) {
    ProgressMonitor pm = new TextProgressMonitor();
    pm.beginTask("Collecting projects", ProgressMonitor.UNKNOWN);
    SortedSet<ProjectHolder> projects = new TreeSet<>();
    int changeCount = 0;
    for (Project.NameKey name : projectCache.all()) {
        try (Repository repo = repoManager.openRepository(name)) {
            int size = ChangeNotes.Factory.scan(repo).size();
            changeCount += size;
            projects.add(new ProjectHolder(name, size));
        } catch (IOException e) {
            log.error("Error collecting changes for project {}", name, e);
        }
        pm.update(1);
    }
    pm.endTask();
    setTotalWork(changeCount);
    return indexAll(index, projects);
}
#end_block

#method_before
@Test
public void testGetJGroupsMyUrlFromListenUrlWhenNoListenUrlSpecified() {
    exception.expect(ProvisionException.class);
    exception.expectMessage("exactly 1 value configured; found 0");
    getMyUrlProvider();
}
#method_after
@Test
public void testGetJGroupsMyUrlFromListenUrlWhenNoListenUrlSpecified() throws Exception {
    exception.expect(ProvisionException.class);
    exception.expectMessage("exactly 1 value configured; found 0");
    getMyUrlProvider();
}
#end_block

#method_before
@Test
public void testGetJGroupsMyUrlFromListenUrlWhenMultipleListenUrlsSpecified() {
    gerritServerConfig.setStringList(HTTPD, null, LISTEN_URL, Lists.newArrayList("a", "b"));
    exception.expect(ProvisionException.class);
    exception.expectMessage("exactly 1 value configured; found 2");
    getMyUrlProvider();
}
#method_after
@Test
public void testGetJGroupsMyUrlFromListenUrlWhenMultipleListenUrlsSpecified() throws Exception {
    gerritServerConfig.setStringList(HTTPD, null, LISTEN_URL, Lists.newArrayList("a", "b"));
    exception.expect(ProvisionException.class);
    exception.expectMessage("exactly 1 value configured; found 2");
    getMyUrlProvider();
}
#end_block

#method_before
@Test
public void testGetJGroupsMyUrlFromListenUrlWhenReverseProxyConfigured() {
    gerritServerConfig.setString(HTTPD, null, LISTEN_URL, "proxy-https://foo");
    exception.expect(ProvisionException.class);
    exception.expectMessage("when configured as reverse-proxy");
    getMyUrlProvider();
}
#method_after
@Test
public void testGetJGroupsMyUrlFromListenUrlWhenReverseProxyConfigured() throws Exception {
    gerritServerConfig.setString(HTTPD, null, LISTEN_URL, "proxy-https://foo");
    exception.expect(ProvisionException.class);
    exception.expectMessage("when configured as reverse-proxy");
    getMyUrlProvider();
}
#end_block

#method_before
@Test
public void testGetJGroupsMyUrlFromListenUrlWhenWildcardConfigured() {
    gerritServerConfig.setString(HTTPD, null, LISTEN_URL, "https://*");
    exception.expect(ProvisionException.class);
    exception.expectMessage("when configured with wildcard");
    getMyUrlProvider();
}
#method_after
@Test
public void testGetJGroupsMyUrlFromListenUrlWhenWildcardConfigured() throws Exception {
    gerritServerConfig.setString(HTTPD, null, LISTEN_URL, "https://*");
    exception.expect(ProvisionException.class);
    exception.expectMessage("when configured with wildcard");
    getMyUrlProvider();
}
#end_block

#method_before
@Test
public void testGetJGroupsMyUrlOverridesListenUrl() {
    when(configurationMock.peerInfoJGroups().myUrl()).thenReturn("http://somehost");
    assertThat(getMyUrlProvider().get()).isEqualTo("http://somehost");
}
#method_after
@Test
public void testGetJGroupsMyUrlOverridesListenUrl() throws Exception {
    when(configurationMock.peerInfoJGroups().myUrl()).thenReturn("http://somehost");
    assertThat(getMyUrlProvider().get()).isEqualTo("http://somehost");
}
#end_block

#method_before
private Set<Account.Id> accountIds(Collection<String> refs) {
    return refs.stream().filter(r -> r.startsWith(REFS_USERS)).map(Id::fromRef).filter(Objects::nonNull).collect(toSet());
}
#method_after
private Set<Account.Id> accountIds(Collection<String> refs) {
    return refs.stream().filter(r -> r.startsWith(REFS_USERS)).map(Account.Id::fromRef).filter(Objects::nonNull).collect(toSet());
}
#end_block

#method_before
private Set<AccountGroup.UUID> groupUUIDs(Collection<String> refs) {
    return refs.stream().filter(RefNames::isRefsGroups).map(UUID::fromRef).filter(Objects::nonNull).collect(toSet());
}
#method_after
private Set<AccountGroup.UUID> groupUUIDs(Collection<String> refs) {
    return refs.stream().filter(RefNames::isRefsGroups).map(AccountGroup.UUID::fromRef).filter(Objects::nonNull).collect(toSet());
}
#end_block

#method_before
@Override
public ProjectAccessInfo apply(ProjectResource rsrc) throws ResourceNotFoundException, ResourceConflictException, IOException, PermissionBackendException {
    // Load the current configuration from the repository, ensuring it's the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    Project.NameKey projectName = rsrc.getNameKey();
    ProjectAccessInfo info = new ProjectAccessInfo();
    ProjectState projectState = projectCache.checkedGet(projectName);
    PermissionBackend.ForProject perm = permissionBackend.currentUser().project(projectName);
    ProjectConfig config;
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        config = ProjectConfig.read(md);
        info.configWebLinks = new ArrayList<>();
        // config may have a null revision if the repo doesn't have its own refs/meta/config.
        if (config.getRevision() != null) {
            // gone, WebLinks should be fixed to use the extension data types.
            for (WebLinkInfoCommon wl : webLinks.getFileHistoryLinks(projectName.get(), config.getRevision().getName(), ProjectConfig.PROJECT_CONFIG)) {
                info.configWebLinks.add(new WebLinkInfo(wl.name, wl.imageUrl, wl.url, wl.target));
            }
        }
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            config.commit(md);
            projectCache.evict(config.getProject());
            projectState = projectCache.checkedGet(projectName);
            perm = permissionBackend.currentUser().project(projectName);
        } else if (config.getRevision() != null && !config.getRevision().equals(projectState.getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            projectState = projectCache.checkedGet(projectName);
            perm = permissionBackend.currentUser().project(projectName);
        }
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(e.getMessage());
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    }
    // The following implementation must match the ProjectAccessFactory JSON RPC endpoint.
    info.local = new HashMap<>();
    info.ownerOf = new HashSet<>();
    Map<AccountGroup.UUID, GroupInfo> groups = new HashMap<>();
    boolean canReadConfig = check(perm, RefNames.REFS_CONFIG, READ);
    boolean canWriteConfig = check(perm, ProjectPermission.WRITE_CONFIG);
    // config to set the project state to any state that is not HIDDEN.
    if (!canWriteConfig) {
        projectState.checkStatePermitsRead();
    }
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (canWriteConfig) {
                info.local.put(name, createAccessSection(groups, section));
                info.ownerOf.add(name);
            } else if (canReadConfig) {
                info.local.put(section.getName(), createAccessSection(groups, section));
            }
        } else if (RefConfigSection.isValid(name)) {
            if (check(perm, name, WRITE_CONFIG)) {
                info.local.put(name, createAccessSection(groups, section));
                info.ownerOf.add(name);
            } else if (canReadConfig) {
                info.local.put(name, createAccessSection(groups, section));
            } else if (check(perm, name, READ)) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID groupId = srcRule.getGroup().getUUID();
                        if (groupId == null) {
                            continue;
                        }
                        loadGroup(groups, groupId);
                        if (dstPerm == null) {
                            if (dst == null) {
                                dst = new AccessSection(name);
                                info.local.put(name, createAccessSection(groups, dst));
                            }
                            dstPerm = dst.getPermission(srcPerm.getName(), true);
                        }
                        dstPerm.add(srcRule);
                    }
                }
            }
        }
    }
    if (info.ownerOf.isEmpty() && permissionBackend.currentUser().test(GlobalPermission.ADMINISTRATE_SERVER)) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Fall back to site administrators.
        info.ownerOf.add(AccessSection.ALL);
    }
    if (config.getRevision() != null) {
        info.revision = config.getRevision().name();
    }
    ProjectState parent = Iterables.getFirst(projectState.parents(), null);
    if (parent != null) {
        info.inheritsFrom = projectJson.format(parent.getProject());
    }
    if (projectName.equals(allProjectsName) && permissionBackend.currentUser().testOrFalse(ADMINISTRATE_SERVER)) {
        info.ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
    }
    info.isOwner = toBoolean(canWriteConfig);
    info.canUpload = toBoolean(projectState.statePermitsWrite() && (canWriteConfig || (canReadConfig && perm.ref(RefNames.REFS_CONFIG).testOrFalse(CREATE_CHANGE))));
    info.canAdd = toBoolean(perm.testOrFalse(CREATE_REF));
    info.configVisible = canReadConfig || canWriteConfig;
    info.groups = groups.entrySet().stream().filter(e -> e.getValue() != null).collect(toMap(e -> e.getKey().get(), Entry::getValue));
    return info;
}
#method_after
@Override
public ProjectAccessInfo apply(ProjectResource rsrc) throws ResourceNotFoundException, ResourceConflictException, IOException, PermissionBackendException {
    // Load the current configuration from the repository, ensuring it's the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    Project.NameKey projectName = rsrc.getNameKey();
    ProjectAccessInfo info = new ProjectAccessInfo();
    ProjectState projectState = projectCache.checkedGet(projectName);
    PermissionBackend.ForProject perm = permissionBackend.currentUser().project(projectName);
    ProjectConfig config;
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        config = ProjectConfig.read(md);
        info.configWebLinks = new ArrayList<>();
        // config may have a null revision if the repo doesn't have its own refs/meta/config.
        if (config.getRevision() != null) {
            // gone, WebLinks should be fixed to use the extension data types.
            for (WebLinkInfoCommon wl : webLinks.getFileHistoryLinks(projectName.get(), config.getRevision().getName(), ProjectConfig.PROJECT_CONFIG)) {
                info.configWebLinks.add(new WebLinkInfo(wl.name, wl.imageUrl, wl.url, wl.target));
            }
        }
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            config.commit(md);
            projectCache.evict(config.getProject());
            projectState = projectCache.checkedGet(projectName);
            perm = permissionBackend.currentUser().project(projectName);
        } else if (config.getRevision() != null && !config.getRevision().equals(projectState.getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            projectState = projectCache.checkedGet(projectName);
            perm = permissionBackend.currentUser().project(projectName);
        }
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(e.getMessage());
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    }
    // The following implementation must match the ProjectAccessFactory JSON RPC endpoint.
    info.local = new HashMap<>();
    info.ownerOf = new HashSet<>();
    Map<AccountGroup.UUID, GroupInfo> groups = new HashMap<>();
    boolean canReadConfig = check(perm, RefNames.REFS_CONFIG, READ);
    boolean canWriteConfig = check(perm, ProjectPermission.WRITE_CONFIG);
    // config to set the project state to any state that is not HIDDEN.
    if (!canWriteConfig) {
        projectState.checkStatePermitsRead();
    }
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (canWriteConfig) {
                info.local.put(name, createAccessSection(groups, section));
                info.ownerOf.add(name);
            } else if (canReadConfig) {
                info.local.put(section.getName(), createAccessSection(groups, section));
            }
        } else if (RefConfigSection.isValid(name)) {
            if (check(perm, name, WRITE_CONFIG)) {
                info.local.put(name, createAccessSection(groups, section));
                info.ownerOf.add(name);
            } else if (canReadConfig) {
                info.local.put(name, createAccessSection(groups, section));
            } else if (check(perm, name, READ)) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID groupId = srcRule.getGroup().getUUID();
                        if (groupId == null) {
                            continue;
                        }
                        loadGroup(groups, groupId);
                        if (dstPerm == null) {
                            if (dst == null) {
                                dst = new AccessSection(name);
                                info.local.put(name, createAccessSection(groups, dst));
                            }
                            dstPerm = dst.getPermission(srcPerm.getName(), true);
                        }
                        dstPerm.add(srcRule);
                    }
                }
            }
        }
    }
    if (info.ownerOf.isEmpty() && permissionBackend.currentUser().test(GlobalPermission.ADMINISTRATE_SERVER)) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Fall back to site administrators.
        info.ownerOf.add(AccessSection.ALL);
    }
    if (config.getRevision() != null) {
        info.revision = config.getRevision().name();
    }
    ProjectState parent = Iterables.getFirst(projectState.parents(), null);
    if (parent != null) {
        info.inheritsFrom = projectJson.format(parent.getProject());
    }
    if (projectName.equals(allProjectsName) && permissionBackend.currentUser().testOrFalse(ADMINISTRATE_SERVER)) {
        info.ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
    }
    info.isOwner = toBoolean(canWriteConfig);
    info.canUpload = toBoolean(projectState.statePermitsWrite() && (canWriteConfig || (canReadConfig && perm.ref(RefNames.REFS_CONFIG).testOrFalse(CREATE_CHANGE))));
    info.canAdd = toBoolean(perm.testOrFalse(CREATE_REF));
    info.configVisible = canReadConfig || canWriteConfig;
    info.groups = groups.entrySet().stream().filter(e -> e.getValue() != null).collect(toMap(e -> e.getKey().get(), Map.Entry::getValue));
    return info;
}
#end_block

#method_before
@Test
public void reviewerin() throws Exception {
    Account.Id user1 = accountManager.authenticate(AuthRequest.forUser("user1")).getAccountId();
    Account.Id user2 = accountManager.authenticate(AuthRequest.forUser("user2")).getAccountId();
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo));
    Change change2 = insert(repo, newChange(repo));
    insert(repo, newChange(repo));
    AddReviewerInput rin = new AddReviewerInput();
    rin.reviewer = user1.toString();
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change1.getId().get()).addReviewer(rin);
    rin = new AddReviewerInput();
    rin.reviewer = user2.toString();
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change2.getId().get()).addReviewer(rin);
    String group = gApi.groups().create("foo").get().name;
    gApi.groups().id(group).addMembers(user2.toString());
    List<String> members = gApi.groups().id(group).members().stream().map(a -> a._accountId.toString()).collect(toList());
    assertThat(members).contains(user2.toString());
    assertQuery("reviewerin:\"Registered Users\"", change2, change1);
    assertQuery("reviewerin:" + group, change2);
    gApi.changes().id(change2.getId().get()).current().review(ReviewInput.approve());
    gApi.changes().id(change2.getId().get()).current().submit();
    assertQuery("reviewerin:" + group, change2);
    assertQuery("project:repo reviewerin:" + group, change2);
    assertQuery("status:merged reviewerin:" + group, change2);
}
#method_after
@Test
public void reviewerin() throws Exception {
    Account.Id user1 = accountManager.authenticate(AuthRequest.forUser("user1")).getAccountId();
    Account.Id user2 = accountManager.authenticate(AuthRequest.forUser("user2")).getAccountId();
    Account.Id user3 = accountManager.authenticate(AuthRequest.forUser("user3")).getAccountId();
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo));
    Change change2 = insert(repo, newChange(repo));
    Change change3 = insert(repo, newChange(repo));
    AddReviewerInput rin = new AddReviewerInput();
    rin.reviewer = user1.toString();
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change1.getId().get()).addReviewer(rin);
    rin = new AddReviewerInput();
    rin.reviewer = user2.toString();
    rin.state = ReviewerState.REVIEWER;
    gApi.changes().id(change2.getId().get()).addReviewer(rin);
    rin = new AddReviewerInput();
    rin.reviewer = user3.toString();
    rin.state = ReviewerState.CC;
    gApi.changes().id(change3.getId().get()).addReviewer(rin);
    String group = gApi.groups().create("foo").get().name;
    gApi.groups().id(group).addMembers(user2.toString(), user3.toString());
    List<String> members = gApi.groups().id(group).members().stream().map(a -> a._accountId.toString()).collect(toList());
    assertThat(members).contains(user2.toString());
    if (notesMigration.readChanges()) {
        // CC and REVIEWER are separate in NoteDB
        assertQuery("reviewerin:\"Registered Users\"", change2, change1);
        assertQuery("reviewerin:" + group, change2);
    } else {
        // CC and REVIEWER are the same in ReviewDb
        assertQuery("reviewerin:\"Registered Users\"", change3, change2, change1);
        assertQuery("reviewerin:" + group, change3, change2);
    }
    gApi.changes().id(change2.getId().get()).current().review(ReviewInput.approve());
    gApi.changes().id(change2.getId().get()).current().submit();
    if (notesMigration.readChanges()) {
        // CC and REVIEWER are separate in NoteDB
        assertQuery("reviewerin:" + group, change2);
        assertQuery("project:repo reviewerin:" + group, change2);
        assertQuery("status:merged reviewerin:" + group, change2);
    } else {
        // CC and REVIEWER are the same in ReviewDb
        assertQuery("reviewerin:" + group, change2, change3);
        assertQuery("project:repo reviewerin:" + group, change2, change3);
        assertQuery("status:merged reviewerin:" + group, change2);
    }
}
#end_block

#method_before
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, Providers.of(otherUser), permissionBackend, notesFactory, changeDataFactory, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, childProjects, submitDryRun, conflictsCache, index, indexConfig, starredChangesUtil, accountCache, notesMigration, groupMembers);
}
#method_after
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, Providers.of(otherUser), permissionBackend, notesFactory, changeDataFactory, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, childProjects, submitDryRun, conflictsCache, index, indexConfig, starredChangesUtil, accountCache, notesMigration, groupMembers, anonymousUserProvider);
}
#end_block

#method_before
public Predicate<ChangeData> visibleto(CurrentUser user) {
    return new ChangeIsVisibleToPredicate(args.db, args.notesFactory, user, args.permissionBackend, args.projectCache);
}
#method_after
public Predicate<ChangeData> visibleto(CurrentUser user) {
    return new ChangeIsVisibleToPredicate(args.db, args.notesFactory, user, args.permissionBackend, args.projectCache, args.anonymousUserProvider);
}
#end_block

#method_before
private Optional<ReviewerState> getReviewerState(String changeId, Account.Id accountId) throws Exception {
    ChangeInfo c = gApi.changes().id(changeId).get(DETAILED_LABELS);
    Set<ReviewerState> states = c.reviewers.entrySet().stream().filter(e -> e.getValue().stream().anyMatch(a -> a._accountId == accountId.get())).map(Entry::getKey).collect(toSet());
    assertThat(states.size()).named(states.toString()).isAtMost(1);
    return states.stream().findFirst();
}
#method_after
private Optional<ReviewerState> getReviewerState(String changeId, Account.Id accountId) throws Exception {
    ChangeInfo c = gApi.changes().id(changeId).get(DETAILED_LABELS);
    Set<ReviewerState> states = c.reviewers.entrySet().stream().filter(e -> e.getValue().stream().anyMatch(a -> a._accountId == accountId.get())).map(Map.Entry::getKey).collect(toSet());
    assertThat(states.size()).named(states.toString()).isAtMost(1);
    return states.stream().findFirst();
}
#end_block

#method_before
public ChangeAttribute asChangeAttribute(ReviewDb db, Change change) {
    ChangeAttribute a = new ChangeAttribute();
    a.project = change.getProject().get();
    a.branch = change.getDest().getShortName();
    a.topic = change.getTopic();
    a.id = change.getKey().get();
    a.number = change.getId().get();
    a.subject = change.getSubject();
    try {
        a.commitMessage = changeDataFactory.create(db, change).commitMessage();
    } catch (Exception e) {
        log.error("Error while getting full commit message for change " + a.number);
    }
    a.url = getChangeUrl(change);
    a.owner = asAccountAttribute(change.getOwner());
    a.assignee = asAccountAttribute(change.getAssignee());
    a.status = change.getStatus();
    a.createdOn = change.getCreatedOn().getTime() / 1000L;
    a.wip = change.isWorkInProgress() ? true : null;
    a.isPrivate = change.isPrivate() ? true : null;
    return a;
}
#method_after
public ChangeAttribute asChangeAttribute(ReviewDb db, Change change) {
    ChangeAttribute a = new ChangeAttribute();
    a.project = change.getProject().get();
    a.branch = change.getDest().getShortName();
    a.topic = change.getTopic();
    a.id = change.getKey().get();
    a.number = change.getId().get();
    a.subject = change.getSubject();
    try {
        a.commitMessage = changeDataFactory.create(db, change).commitMessage();
    } catch (Exception e) {
        log.error("Error while getting full commit message for change " + a.number, e);
    }
    a.url = getChangeUrl(change);
    a.owner = asAccountAttribute(change.getOwner());
    a.assignee = asAccountAttribute(change.getAssignee());
    a.status = change.getStatus();
    a.createdOn = change.getCreatedOn().getTime() / 1000L;
    a.wip = change.isWorkInProgress() ? true : null;
    a.isPrivate = change.isPrivate() ? true : null;
    return a;
}
#end_block

#method_before
public void addPatchSetFileNames(PatchSetAttribute patchSetAttribute, Change change, PatchSet patchSet) {
    try {
        PatchList patchList = patchListCache.get(change, patchSet);
        for (PatchListEntry patch : patchList.getPatches()) {
            if (patchSetAttribute.files == null) {
                patchSetAttribute.files = new ArrayList<>();
            }
            PatchAttribute p = new PatchAttribute();
            p.file = patch.getNewName();
            p.fileOld = patch.getOldName();
            p.type = patch.getChangeType();
            p.deletions -= patch.getDeletions();
            p.insertions = patch.getInsertions();
            patchSetAttribute.files.add(p);
        }
    } catch (PatchListObjectTooLargeException e) {
        log.warn("Cannot get patch list: " + e.getMessage());
    } catch (PatchListNotAvailableException e) {
        log.warn("Cannot get patch list", e);
    }
}
#method_after
public void addPatchSetFileNames(PatchSetAttribute patchSetAttribute, Change change, PatchSet patchSet) {
    try {
        PatchList patchList = patchListCache.get(change, patchSet);
        for (PatchListEntry patch : patchList.getPatches()) {
            if (patchSetAttribute.files == null) {
                patchSetAttribute.files = new ArrayList<>();
            }
            PatchAttribute p = new PatchAttribute();
            p.file = patch.getNewName();
            p.fileOld = patch.getOldName();
            p.type = patch.getChangeType();
            p.deletions -= patch.getDeletions();
            p.insertions = patch.getInsertions();
            patchSetAttribute.files.add(p);
        }
    } catch (PatchListObjectTooLargeException e) {
        log.warn("Cannot get patch list: " + e.getMessage());
    } catch (PatchListNotAvailableException e) {
        log.error("Cannot get patch list", e);
    }
}
#end_block

#method_before
private List<ChangeInfo> toChangeInfos(List<ChangeData> changes, Map<Change.Id, ChangeInfo> cache) {
    try (Timer0.Context ignored = metrics.toChangeInfosLatency.start()) {
        // Create a list of formatting calls that can be called sequentially or in parallel
        List<Callable<Optional<ChangeInfo>>> formattingCalls = new ArrayList<>(changes.size());
        for (ChangeData cd : changes) {
            formattingCalls.add(() -> {
                ChangeInfo i = cache.get(cd.getId());
                if (i != null) {
                    return Optional.of(i);
                }
                try {
                    ensureLoaded(Collections.singleton(cd));
                    return Optional.of(format(cd, Optional.empty(), false));
                } catch (OrmException | RuntimeException e) {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    return Optional.empty();
                }
            });
        }
        long numProjects = changes.stream().map(ChangeData::project).distinct().count();
        if (!lazyLoad || changes.size() < 3 || numProjects < 2) {
            // Format these changes in the request thread as the multithreading overhead would be too
            // high.
            List<ChangeInfo> result = new ArrayList<>(changes.size());
            for (Callable<Optional<ChangeInfo>> c : formattingCalls) {
                try {
                    c.call().ifPresent(result::add);
                } catch (Exception e) {
                    log.warn("Omitting change due to exception", e);
                }
            }
            return result;
        }
        // Format the changes in parallel on the executor
        List<ChangeInfo> result = new ArrayList<>(changes.size());
        try {
            for (Future<Optional<ChangeInfo>> f : fanOutExecutor.invokeAll(formattingCalls)) {
                f.get().ifPresent(result::add);
            }
        } catch (InterruptedException | ExecutionException e) {
            throw new IllegalStateException(e);
        }
        return result;
    }
}
#method_after
private List<ChangeInfo> toChangeInfos(List<ChangeData> changes, Map<Change.Id, ChangeInfo> cache) {
    try (Timer0.Context ignored = metrics.toChangeInfosLatency.start()) {
        // Create a list of formatting calls that can be called sequentially or in parallel
        List<Callable<Optional<ChangeInfo>>> formattingCalls = new ArrayList<>(changes.size());
        for (ChangeData cd : changes) {
            formattingCalls.add(() -> {
                ChangeInfo i = cache.get(cd.getId());
                if (i != null) {
                    return Optional.of(i);
                }
                try {
                    ensureLoaded(Collections.singleton(cd));
                    return Optional.of(format(cd, Optional.empty(), false));
                } catch (OrmException | RuntimeException e) {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    return Optional.empty();
                }
            });
        }
        long numProjects = changes.stream().map(ChangeData::project).distinct().count();
        if (!enableParallelFormatting || !lazyLoad || changes.size() < 3 || numProjects < 2) {
            // Format these changes in the request thread as the multithreading overhead would be too
            // high.
            List<ChangeInfo> result = new ArrayList<>(changes.size());
            for (Callable<Optional<ChangeInfo>> c : formattingCalls) {
                try {
                    c.call().ifPresent(result::add);
                } catch (Exception e) {
                    log.warn("Omitting change due to exception", e);
                }
            }
            return result;
        }
        // Format the changes in parallel on the executor
        List<ChangeInfo> result = new ArrayList<>(changes.size());
        try {
            for (Future<Optional<ChangeInfo>> f : fanOutExecutor.invokeAll(formattingCalls)) {
                f.get().ifPresent(result::add);
            }
        } catch (InterruptedException | ExecutionException e) {
            throw new IllegalStateException(e);
        }
        return result;
    }
}
#end_block

#method_before
private ChangeInfo toChangeInfoImpl(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, PermissionBackendException, IOException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.notes(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        if (!has(SKIP_MERGEABLE)) {
            out.mergeable = cd.isMergeable();
        }
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate() ? true : null;
    out.workInProgress = in.isWorkInProgress() ? true : null;
    out.hasReviewStarted = in.hasReviewStarted();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        out.reviewed = cd.isReviewedBy(user.getAccountId()) ? true : null;
    }
    out.labels = labelsFor(cd, has(LABELS), has(DETAILED_LABELS));
    out.requirements = requirementsFor(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (user.isIdentifiedUser() && (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId()))) {
            PermissionBackend.ForChange perm = permissionBackendForChange(user, cd);
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(perm, cd) : ImmutableMap.of();
        }
        out.reviewers = reviewerMap(cd.reviewers(), cd.reviewersByEmail(), false);
        out.pendingReviewers = reviewerMap(cd.pendingReviewers(), cd.pendingReviewersByEmail(), true);
        out.removableReviewers = removableReviewers(cd, out);
    }
    setSubmitter(cd, out);
    out.plugins = pluginDefinedAttributesFactory != null ? pluginDefinedAttributesFactory.create(cd) : null;
    out.revertOf = cd.change().getRevertOf() != null ? cd.change().getRevertOf().get() : null;
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(cd);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(cd, src, limitToPsId, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, cd.notes());
    }
    if (has(TRACKING_IDS)) {
        ListMultimap<String, String> set = trackingFooters.extract(cd.commitFooters());
        out.trackingIds = set.entries().stream().map(e -> new TrackingIdInfo(e.getKey(), e.getValue())).collect(toList());
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfoImpl(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, PermissionBackendException, IOException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.notes(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.assignee = in.getAssignee() != null ? accountLoader.get(in.getAssignee()) : null;
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        if (!has(SKIP_MERGEABLE)) {
            out.mergeable = cd.isMergeable();
        }
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate() ? true : null;
    out.workInProgress = in.isWorkInProgress() ? true : null;
    out.hasReviewStarted = in.hasReviewStarted();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        out.reviewed = cd.isReviewedBy(user.getAccountId()) ? true : null;
    }
    out.labels = labelsFor(cd, has(LABELS), has(DETAILED_LABELS));
    out.requirements = requirementsFor(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (user.isIdentifiedUser() && (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId()))) {
            PermissionBackend.ForChange perm = permissionBackendForChange(user, cd);
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(perm, cd) : ImmutableMap.of();
        }
        out.reviewers = reviewerMap(cd.reviewers(), cd.reviewersByEmail(), false);
        out.pendingReviewers = reviewerMap(cd.pendingReviewers(), cd.pendingReviewersByEmail(), true);
        out.removableReviewers = removableReviewers(cd, out);
    }
    setSubmitter(cd, out);
    out.plugins = pluginDefinedAttributesFactory != null ? pluginDefinedAttributesFactory.create(cd) : null;
    out.revertOf = cd.change().getRevertOf() != null ? cd.change().getRevertOf().get() : null;
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(cd);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(cd, src, limitToPsId, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, cd.notes());
    }
    if (has(TRACKING_IDS)) {
        ListMultimap<String, String> set = trackingFooters.extract(cd.commitFooters());
        out.trackingIds = set.entries().stream().map(e -> new TrackingIdInfo(e.getKey(), e.getValue())).collect(toList());
    }
    return out;
}
#end_block

#method_before
private Collection<ChangeMessageInfo> messages(ChangeData cd) throws OrmException {
    List<ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes());
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        ChangeMessageInfo cmi = new ChangeMessageInfo();
        cmi.id = message.getKey().get();
        cmi.author = accountLoader.get(message.getAuthor());
        cmi.date = message.getWrittenOn();
        cmi.message = message.getMessage();
        cmi.tag = message.getTag();
        cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
        Account.Id realAuthor = message.getRealAuthor();
        if (realAuthor != null) {
            cmi.realAuthor = accountLoader.get(realAuthor);
        }
        result.add(cmi);
    }
    return result;
}
#method_after
private Collection<ChangeMessageInfo> messages(ChangeData cd) throws OrmException {
    List<ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes());
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    for (ChangeMessage message : messages) {
        result.add(createChangeMessageInfo(message, accountLoader));
    }
    return result;
}
#end_block

#method_before
public List<Account.Id> firstNIds(int n) throws IOException {
    return readUserRefs().sorted(comparing(Id::get)).limit(n).collect(toList());
}
#method_after
public List<Account.Id> firstNIds(int n) throws IOException {
    return readUserRefs().sorted(comparing(Account.Id::get)).limit(n).collect(toList());
}
#end_block

#method_before
@Override
public ExternalIdNotes load(Repository allUsersRepo) throws IOException, ConfigInvalidException {
    return new ExternalIdNotes(externalIdCache, accountCache, accountIndexer, allUsersRepo).load();
}
#method_after
@Override
public ExternalIdNotes load(Repository allUsersRepo) throws IOException, ConfigInvalidException {
    return new ExternalIdNotes(externalIdCache, accountCache, accountIndexer, metricMaker, allUsersRepo).load();
}
#end_block

#method_before
@Override
public ExternalIdNotes load(Repository allUsersRepo, @Nullable ObjectId rev) throws IOException, ConfigInvalidException {
    return new ExternalIdNotes(externalIdCache, accountCache, accountIndexer, allUsersRepo).load(rev);
}
#method_after
@Override
public ExternalIdNotes load(Repository allUsersRepo, @Nullable ObjectId rev) throws IOException, ConfigInvalidException {
    return new ExternalIdNotes(externalIdCache, accountCache, accountIndexer, metricMaker, allUsersRepo).load(rev);
}
#end_block

#method_before
@Override
public ExternalIdNotes load(Repository allUsersRepo) throws IOException, ConfigInvalidException {
    return new ExternalIdNotes(externalIdCache, null, null, allUsersRepo).load();
}
#method_after
@Override
public ExternalIdNotes load(Repository allUsersRepo) throws IOException, ConfigInvalidException {
    return new ExternalIdNotes(externalIdCache, null, null, metricMaker, allUsersRepo).load();
}
#end_block

#method_before
@Override
public ExternalIdNotes load(Repository allUsersRepo, @Nullable ObjectId rev) throws IOException, ConfigInvalidException {
    return new ExternalIdNotes(externalIdCache, null, null, allUsersRepo).load(rev);
}
#method_after
@Override
public ExternalIdNotes load(Repository allUsersRepo, @Nullable ObjectId rev) throws IOException, ConfigInvalidException {
    return new ExternalIdNotes(externalIdCache, null, null, metricMaker, allUsersRepo).load(rev);
}
#end_block

#method_before
public static ExternalIdNotes loadReadOnly(Repository allUsersRepo) throws IOException, ConfigInvalidException {
    return new ExternalIdNotes(new DisabledExternalIdCache(), null, null, allUsersRepo).setReadOnly().load();
}
#method_after
public static ExternalIdNotes loadReadOnly(Repository allUsersRepo) throws IOException, ConfigInvalidException {
    return new ExternalIdNotes(new DisabledExternalIdCache(), null, null, new DisabledMetricMaker(), allUsersRepo).setReadOnly().load();
}
#end_block

#method_before
public static ExternalIdNotes loadReadOnly(Repository allUsersRepo, @Nullable ObjectId rev) throws IOException, ConfigInvalidException {
    return new ExternalIdNotes(new DisabledExternalIdCache(), null, null, allUsersRepo).setReadOnly().load(rev);
}
#method_after
public static ExternalIdNotes loadReadOnly(Repository allUsersRepo, @Nullable ObjectId rev) throws IOException, ConfigInvalidException {
    return new ExternalIdNotes(new DisabledExternalIdCache(), null, null, new DisabledMetricMaker(), allUsersRepo).setReadOnly().load(rev);
}
#end_block

#method_before
public static ExternalIdNotes loadNoCacheUpdate(Repository allUsersRepo) throws IOException, ConfigInvalidException {
    return new ExternalIdNotes(new DisabledExternalIdCache(), null, null, allUsersRepo).load();
}
#method_after
public static ExternalIdNotes loadNoCacheUpdate(Repository allUsersRepo) throws IOException, ConfigInvalidException {
    return new ExternalIdNotes(new DisabledExternalIdCache(), null, null, new DisabledMetricMaker(), allUsersRepo).load();
}
#end_block

#method_before
@Override
public RevCommit commit(MetaDataUpdate update) throws IOException {
    oldRev = revision != null ? revision.copy() : ObjectId.zeroId();
    return super.commit(update);
}
#method_after
@Override
public RevCommit commit(MetaDataUpdate update) throws IOException {
    oldRev = revision != null ? revision.copy() : ObjectId.zeroId();
    RevCommit commit = super.commit(update);
    updateCount.increment();
    return commit;
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    checkState(!readOnly, "Updating external IDs is disabled");
    if (noteMapUpdates.isEmpty()) {
        return false;
    }
    if (Strings.isNullOrEmpty(commit.getMessage())) {
        commit.setMessage("Update external IDs\n");
    }
    try (RevWalk rw = new RevWalk(reader)) {
        Set<String> footers = new HashSet<>();
        Multimap<String, ExternalId.Key> extIdsByEmailBefore = !disableCheckForNewDuplicateEmails ? getExternalIdsByEmail(rw, noteMap) : null;
        for (NoteMapUpdate noteMapUpdate : noteMapUpdates) {
            try {
                noteMapUpdate.execute(rw, noteMap, footers);
            } catch (DuplicateExternalIdKeyException e) {
                throw new IOException(e);
            }
        }
        if (!disableCheckForNewDuplicateEmails) {
            Multimap<String, ExternalId.Key> extIdsByEmailAfter = getExternalIdsByEmail(rw, noteMap);
            checkForNewDuplicateEmails(extIdsByEmailBefore, extIdsByEmailAfter);
        }
        noteMapUpdates.clear();
        if (!footers.isEmpty()) {
            commit.setMessage(footers.stream().sorted().collect(joining("\n", commit.getMessage().trim() + "\n\n", "")));
        }
        RevTree oldTree = revision != null ? rw.parseTree(revision) : null;
        ObjectId newTreeId = noteMap.writeTree(inserter);
        if (newTreeId.equals(oldTree)) {
            return false;
        }
        commit.setTreeId(newTreeId);
        return true;
    }
}
#method_after
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    checkState(!readOnly, "Updating external IDs is disabled");
    if (noteMapUpdates.isEmpty()) {
        return false;
    }
    if (Strings.isNullOrEmpty(commit.getMessage())) {
        commit.setMessage("Update external IDs\n");
    }
    try (RevWalk rw = new RevWalk(reader)) {
        Set<String> footers = new HashSet<>();
        for (NoteMapUpdate noteMapUpdate : noteMapUpdates) {
            try {
                noteMapUpdate.execute(rw, noteMap, footers);
            } catch (DuplicateExternalIdKeyException e) {
                throw new IOException(e);
            }
        }
        noteMapUpdates.clear();
        if (!footers.isEmpty()) {
            commit.setMessage(footers.stream().sorted().collect(joining("\n", commit.getMessage().trim() + "\n\n", "")));
        }
        RevTree oldTree = revision != null ? rw.parseTree(revision) : null;
        ObjectId newTreeId = noteMap.writeTree(inserter);
        if (newTreeId.equals(oldTree)) {
            return false;
        }
        commit.setTreeId(newTreeId);
        return true;
    }
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    SortedSet<Project.NameKey> repoList = repoManager.list();
    SortedSet<Project.NameKey> repoUpgraded = new TreeSet<>();
    ui.message("\tMigrating " + repoList.size() + " repositories ...");
    for (Project.NameKey projectName : repoList) {
        try (Repository git = repoManager.openRepository(projectName);
            MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, projectName, git)) {
            ProjectConfigSchemaUpdate cfg = ProjectConfigSchemaUpdate.read(md);
            cfg.removeForceFromPermission("pushTag");
            if (cfg.isUpdated()) {
                repoUpgraded.add(projectName);
            }
            cfg.save(serverUser, COMMIT_MSG);
        } catch (ConfigInvalidException | IOException ex) {
            throw new OrmException("Cannot migrate project " + projectName, ex);
        }
    }
    ui.message("\tMigration completed:  " + repoUpgraded.size() + " repositories updated:");
    ui.message("\t" + repoUpgraded.stream().map(NameKey::get).collect(joining(" ")));
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    SortedSet<Project.NameKey> repoList = repoManager.list();
    SortedSet<Project.NameKey> repoUpgraded = new TreeSet<>();
    ui.message("\tMigrating " + repoList.size() + " repositories ...");
    for (Project.NameKey projectName : repoList) {
        try (Repository git = repoManager.openRepository(projectName);
            MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, projectName, git)) {
            ProjectConfigSchemaUpdate cfg = ProjectConfigSchemaUpdate.read(md);
            cfg.removeForceFromPermission("pushTag");
            if (cfg.isUpdated()) {
                repoUpgraded.add(projectName);
            }
            cfg.save(serverUser, COMMIT_MSG);
        } catch (ConfigInvalidException | IOException ex) {
            throw new OrmException("Cannot migrate project " + projectName, ex);
        }
    }
    ui.message("\tMigration completed:  " + repoUpgraded.size() + " repositories updated:");
    ui.message("\t" + repoUpgraded.stream().map(Project.NameKey::get).collect(joining(" ")));
}
#end_block

#method_before
private List<Comment> getDeletedComments(Map<String, Comment> parMap, Map<String, Comment> curMap) {
    return parMap.entrySet().stream().filter(c -> !curMap.containsKey(c.getKey())).map(Entry::getValue).collect(toList());
}
#method_after
private List<Comment> getDeletedComments(Map<String, Comment> parMap, Map<String, Comment> curMap) {
    return parMap.entrySet().stream().filter(c -> !curMap.containsKey(c.getKey())).map(Map.Entry::getValue).collect(toList());
}
#end_block

#method_before
PermissionCollection filter(Iterable<SectionMatcher> matcherList, String ref, CurrentUser user) {
    if (isRE(ref)) {
        ref = RefPattern.shortestExample(ref);
    } else if (ref.endsWith("/*")) {
        ref = ref.substring(0, ref.length() - 1);
    }
    // LinkedHashMap to maintain input ordering.
    Map<AccessSection, Project.NameKey> sectionToProject = new LinkedHashMap<>();
    boolean perUser = filterRefMatchingSections(matcherList, ref, user, sectionToProject);
    List<AccessSection> sections = Lists.newArrayList(sectionToProject.keySet());
    // Sort by ref pattern specificity. For equally specific patterns, the sections from the
    // project closer to the current one come first.
    sorter.sort(ref, sections);
    // For block permissions, we want a different order: first, we want to go from parent to
    // child.
    List<Map.Entry<AccessSection, Project.NameKey>> accessDescending = Lists.reverse(Lists.newArrayList(sectionToProject.entrySet()));
    Map<Project.NameKey, List<AccessSection>> accessByProject = accessDescending.stream().collect(Collectors.groupingBy(Entry::getValue, LinkedHashMap::new, mapping(Entry::getKey, toList())));
    // Within each project, sort by ref specificity.
    for (List<AccessSection> secs : accessByProject.values()) {
        sorter.sort(ref, secs);
    }
    return new PermissionCollection(Lists.newArrayList(accessByProject.values()), sections, perUser);
}
#method_after
PermissionCollection filter(Iterable<SectionMatcher> matcherList, String ref, CurrentUser user) {
    if (isRE(ref)) {
        ref = RefPattern.shortestExample(ref);
    } else if (ref.endsWith("/*")) {
        ref = ref.substring(0, ref.length() - 1);
    }
    // LinkedHashMap to maintain input ordering.
    Map<AccessSection, Project.NameKey> sectionToProject = new LinkedHashMap<>();
    boolean perUser = filterRefMatchingSections(matcherList, ref, user, sectionToProject);
    List<AccessSection> sections = Lists.newArrayList(sectionToProject.keySet());
    // Sort by ref pattern specificity. For equally specific patterns, the sections from the
    // project closer to the current one come first.
    sorter.sort(ref, sections);
    // For block permissions, we want a different order: first, we want to go from parent to
    // child.
    List<Map.Entry<AccessSection, Project.NameKey>> accessDescending = Lists.reverse(Lists.newArrayList(sectionToProject.entrySet()));
    Map<Project.NameKey, List<AccessSection>> accessByProject = accessDescending.stream().collect(Collectors.groupingBy(Map.Entry::getValue, LinkedHashMap::new, mapping(Map.Entry::getKey, toList())));
    // Within each project, sort by ref specificity.
    for (List<AccessSection> secs : accessByProject.values()) {
        sorter.sort(ref, secs);
    }
    return new PermissionCollection(Lists.newArrayList(accessByProject.values()), sections, perUser);
}
#end_block

#method_before
public Multimap<String, AccountState> byPreferredEmail(String... emails) throws OrmException {
    List<String> emailList = Arrays.asList(emails);
    if (hasPreferredEmailExact()) {
        List<List<AccountState>> r = query(emailList.stream().map(AccountPredicates::preferredEmailExact).collect(toList()));
        Multimap<String, AccountState> accountsByEmail = ArrayListMultimap.create();
        for (int i = 0; i < emailList.size(); i++) {
            accountsByEmail.putAll(emailList.get(i), r.get(i));
        }
        return accountsByEmail;
    }
    if (!hasPreferredEmail()) {
        return ImmutableListMultimap.of();
    }
    List<List<AccountState>> r = query(emailList.stream().map(AccountPredicates::preferredEmail).collect(toList()));
    Multimap<String, AccountState> accountsByEmail = ArrayListMultimap.create();
    for (int i = 0; i < emailList.size(); i++) {
        String email = emailList.get(i);
        Set<AccountState> matchingAccounts = r.get(i).stream().filter(a -> a.getAccount().getPreferredEmail().equals(email)).collect(toSet());
        accountsByEmail.putAll(email, matchingAccounts);
    }
    return accountsByEmail;
}
#method_after
public List<AccountState> byPreferredEmail(String email) throws OrmException {
    if (hasPreferredEmailExact()) {
        return query(AccountPredicates.preferredEmailExact(email));
    }
    if (!hasPreferredEmail()) {
        return ImmutableList.of();
    }
    return query(AccountPredicates.preferredEmail(email)).stream().filter(a -> a.getAccount().getPreferredEmail().equals(email)).collect(toList());
}
#end_block

#method_before
private CommitValidationMessage getMissingChangeIdErrorMsg(String errMsg, RevCommit c) {
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    if (c.getFullMessage().indexOf(CHANGE_ID_PREFIX) >= 0) {
        String lastLine = Iterables.getLast(Splitter.on('\n').split(c.getFullMessage()), "");
        if (lastLine.indexOf(CHANGE_ID_PREFIX) == -1) {
            sb.append('\n');
            sb.append('\n');
            sb.append("Hint: A potential ");
            sb.append(FooterConstants.CHANGE_ID.getName());
            sb.append("Change-Id was found, but it was not in the ");
            sb.append("footer (last paragraph) of the commit message.");
        }
    }
    sb.append('\n');
    sb.append('\n');
    sb.append("Hint: To automatically insert ");
    sb.append(FooterConstants.CHANGE_ID.getName());
    sb.append(", install the hook:\n");
    sb.append(getCommitMessageHookInstallationHint());
    sb.append('\n');
    sb.append("And then amend the commit:\n");
    sb.append("  git commit --amend\n");
    return new CommitValidationMessage(sb.toString(), false);
}
#method_after
private CommitValidationMessage getMissingChangeIdErrorMsg(String errMsg, RevCommit c) {
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    if (c.getFullMessage().contains(CHANGE_ID_PREFIX)) {
        String lastLine = Iterables.getLast(Splitter.on('\n').split(c.getFullMessage()), "");
        if (!lastLine.contains(CHANGE_ID_PREFIX)) {
            sb.append('\n');
            sb.append('\n');
            sb.append("Hint: A potential ");
            sb.append(FooterConstants.CHANGE_ID.getName());
            sb.append("Change-Id was found, but it was not in the ");
            sb.append("footer (last paragraph) of the commit message.");
        }
    }
    sb.append('\n');
    sb.append('\n');
    sb.append("Hint: To automatically insert ");
    sb.append(FooterConstants.CHANGE_ID.getName());
    sb.append(", install the hook:\n");
    sb.append(getCommitMessageHookInstallationHint());
    sb.append('\n');
    sb.append("And then amend the commit:\n");
    sb.append("  git commit --amend\n");
    return new CommitValidationMessage(sb.toString(), false);
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    SortedSet<Project.NameKey> repoList = repoManager.list();
    SortedSet<Project.NameKey> repoUpgraded = new TreeSet<>();
    ui.message("\tMigrating " + repoList.size() + " repositories ...");
    for (Project.NameKey projectName : repoList) {
        try (Repository git = repoManager.openRepository(projectName);
            MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, projectName, git)) {
            ProjectConfig config = ProjectConfig.read(md);
            if (config.hasLegacyPermissions()) {
                md.getCommitBuilder().setAuthor(serverUser);
                md.getCommitBuilder().setCommitter(serverUser);
                md.setMessage(COMMIT_MSG);
                config.commit(md);
                repoUpgraded.add(projectName);
            }
        } catch (ConfigInvalidException | IOException ex) {
            throw new OrmException("Cannot migrate project " + projectName, ex);
        }
    }
    ui.message("\tMigration completed:  " + repoUpgraded.size() + " repositories updated:");
    ui.message("\t" + repoUpgraded.stream().map(NameKey::get).collect(joining(" ")));
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    SortedSet<Project.NameKey> repoList = repoManager.list();
    SortedSet<Project.NameKey> repoUpgraded = new TreeSet<>();
    ui.message("\tMigrating " + repoList.size() + " repositories ...");
    for (Project.NameKey projectName : repoList) {
        try (Repository git = repoManager.openRepository(projectName);
            MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, projectName, git)) {
            ProjectConfig config = ProjectConfig.read(md);
            if (config.hasLegacyPermissions()) {
                md.getCommitBuilder().setAuthor(serverUser);
                md.getCommitBuilder().setCommitter(serverUser);
                md.setMessage(COMMIT_MSG);
                config.commit(md);
                repoUpgraded.add(projectName);
            }
        } catch (ConfigInvalidException | IOException ex) {
            throw new OrmException("Cannot migrate project " + projectName, ex);
        }
    }
    ui.message("\tMigration completed:  " + repoUpgraded.size() + " repositories updated:");
    ui.message("\t" + repoUpgraded.stream().map(Project.NameKey::get).collect(joining(" ")));
}
#end_block

#method_before
public SubmoduleOp create(Set<Branch.NameKey> updatedBranches, MergeOpRepoManager orm) throws SubmoduleException {
    return new SubmoduleOp(gitmodulesFactory, myIdent, cfg, projectCache, batchUpdateFactory, updatedBranches, orm);
}
#method_after
public SubmoduleOp create(Set<Branch.NameKey> updatedBranches, MergeOpRepoManager orm) throws SubmoduleException {
    return new SubmoduleOp(gitmodulesFactory, serverIdent.get(), cfg, projectCache, batchUpdateFactory, updatedBranches, orm);
}
#end_block

#method_before
public static <T> Key<T> create(Class<T> clazz, Object... identifiers) {
    return new Key<>(clazz, ImmutableList.copyOf(identifiers));
}
#method_after
public static <T> Key<T> create(Class<T> clazz, Object identifier) {
    return new Key<>(clazz, ImmutableList.of(identifier));
}
#end_block

#method_before
@Test
public void enforceMaxSize() {
    try (PerThreadCache ignored = PerThreadCache.create()) {
        PerThreadCache cache = PerThreadCache.get();
        // Fill the cache
        for (int i = 0; i < 50; i++) {
            PerThreadCache.Key<String> key = PerThreadCache.Key.create(String.class, i);
            cache.get(key, () -> "cached value");
        }
        // Check that the previously added value is present (hence the loader was not called)
        PerThreadCache.Key<String> key1 = PerThreadCache.Key.create(String.class, 0);
        String value1 = cache.get(key1, () -> "never called");
        assertThat(value1).isEqualTo("cached value");
        // Since the cache is now full, check that we directly get the loader's value
        PerThreadCache.Key<String> key2 = PerThreadCache.Key.create(String.class, 1000);
        String value2 = cache.get(key2, () -> "new value");
        assertThat(value2).isEqualTo("new value");
        // Assert that the value was not persisted
        String value3 = cache.get(key2, () -> "directly served");
        assertThat(value3).isEqualTo("directly served");
    }
}
#method_after
@Test
public void enforceMaxSize() {
    try (PerThreadCache cache = PerThreadCache.create()) {
        // Fill the cache
        for (int i = 0; i < 50; i++) {
            PerThreadCache.Key<String> key = PerThreadCache.Key.create(String.class, i);
            cache.get(key, () -> "cached value");
        }
        // Assert that the value was not persisted
        PerThreadCache.Key<String> key = PerThreadCache.Key.create(String.class, 1000);
        cache.get(key, () -> "new value");
        String value = cache.get(key, () -> "directly served");
        assertThat(value).isEqualTo("directly served");
    }
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException {
    CurrentUser user = userProvider.get();
    if (user != null && user.isIdentifiedUser()) {
        IdentifiedUser who = user.asIdentifiedUser();
        String loggableName;
        if (who.getUserName() != null && who.getUserName().isPresent()) {
            loggableName = who.getUserName().get();
        } else {
            loggableName = "a/" + who.getAccountId();
        }
        if (reqEnabled) {
            req.setAttribute(USER_ATTR_KEY, loggableName);
        }
        if (resEnabled && resp instanceof HttpServletResponse) {
            ((HttpServletResponse) resp).addHeader(USER_ATTR_KEY, loggableName);
        }
    }
    chain.doFilter(req, resp);
}
#method_after
@Override
public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException {
    CurrentUser user = userProvider.get();
    if (user != null && user.isIdentifiedUser()) {
        String loggableName = user.asIdentifiedUser().getLoggableName();
        if (reqEnabled) {
            req.setAttribute(USER_ATTR_KEY, loggableName);
        }
        if (resEnabled && resp instanceof HttpServletResponse) {
            ((HttpServletResponse) resp).addHeader(USER_ATTR_KEY, loggableName);
        }
    }
    chain.doFilter(req, resp);
}
#end_block

#method_before
@Provides
@Singleton
@ChangeJsonExecutor
public ExecutorService createChangeJsonExecutor() {
    return MoreExecutors.newDirectExecutorService();
}
#method_after
@Provides
@Singleton
@FanOutExecutor
public ExecutorService createChangeJsonExecutor() {
    return MoreExecutors.newDirectExecutorService();
}
#end_block

#method_before
public List<List<ChangeInfo>> formatQueryResults(List<QueryResult<ChangeData>> in) throws OrmException {
    try (Timer0.Context ignored = metrics.formatQueryResultsLatency.start()) {
        accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
        List<List<ChangeInfo>> res = new ArrayList<>(in.size());
        Map<Change.Id, ChangeInfo> cache = new HashMap<>(in.size());
        for (QueryResult<ChangeData> r : in) {
            List<ChangeInfo> infos = toChangeInfos(r.entities(), cache);
            infos.forEach(i -> cache.put(new Change.Id(i._number), i));
            if (!infos.isEmpty() && r.more()) {
                infos.get(infos.size() - 1)._moreChanges = true;
            }
            res.add(infos);
        }
        accountLoader.fill();
        return res;
    }
}
#method_after
public List<List<ChangeInfo>> formatQueryResults(List<QueryResult<ChangeData>> in) throws OrmException {
    try (Timer0.Context ignored = metrics.formatQueryResultsLatency.start()) {
        accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
        List<List<ChangeInfo>> res = new ArrayList<>(in.size());
        Map<Change.Id, ChangeInfo> cache = Maps.newHashMapWithExpectedSize(in.size());
        for (QueryResult<ChangeData> r : in) {
            List<ChangeInfo> infos = toChangeInfos(r.entities(), cache);
            infos.forEach(c -> cache.put(new Change.Id(c._number), c));
            if (!infos.isEmpty() && r.more()) {
                infos.get(infos.size() - 1)._moreChanges = true;
            }
            res.add(infos);
        }
        accountLoader.fill();
        return res;
    }
}
#end_block

#method_before
private List<ChangeInfo> toChangeInfos(List<ChangeData> changes, Map<Change.Id, ChangeInfo> cache) {
    try (Timer0.Context ignored = metrics.toChangeInfosLatency.start()) {
        // Create a list of formatting calls that can be called sequentially or in parallel
        List<Callable<Optional<ChangeInfo>>> formattingCalls = new ArrayList<>(changes.size());
        for (ChangeData cd : changes) {
            formattingCalls.add(() -> {
                ChangeInfo i = cache.get(cd.getId());
                if (i != null) {
                    return Optional.of(i);
                }
                try {
                    ensureLoaded(Collections.singleton(cd));
                    return Optional.of(format(cd, Optional.empty(), false));
                } catch (OrmException e) {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    return Optional.empty();
                }
            });
        }
        if (!lazyLoad || changes.size() < 3) {
            // Format these changes in the request thread as the multithreading overhead would be too high.
            List<ChangeInfo> result = new ArrayList<>(changes.size());
            for (Callable<Optional<ChangeInfo>> c : formattingCalls) {
                try {
                    c.call().ifPresent(result::add);
                } catch (Exception e) {
                    log.warn("Omitting change due to exception", e);
                }
            }
            return result;
        }
        // Format the changes in parallel on the executor
        List<ChangeInfo> result = new ArrayList<>(changes.size());
        try {
            for (Future<Optional<ChangeInfo>> f : executor.invokeAll(formattingCalls)) {
                f.get().ifPresent(result::add);
            }
        } catch (InterruptedException | ExecutionException e) {
            throw new IllegalStateException(e);
        }
        return result;
    }
}
#method_after
private List<ChangeInfo> toChangeInfos(List<ChangeData> changes, Map<Change.Id, ChangeInfo> cache) {
    try (Timer0.Context ignored = metrics.toChangeInfosLatency.start()) {
        // Create a list of formatting calls that can be called sequentially or in parallel
        List<Callable<Optional<ChangeInfo>>> formattingCalls = new ArrayList<>(changes.size());
        for (ChangeData cd : changes) {
            formattingCalls.add(() -> {
                ChangeInfo i = cache.get(cd.getId());
                if (i != null) {
                    return Optional.of(i);
                }
                try {
                    ensureLoaded(Collections.singleton(cd));
                    return Optional.of(format(cd, Optional.empty(), false));
                } catch (OrmException | RuntimeException e) {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    return Optional.empty();
                }
            });
        }
        long numProjects = changes.stream().map(c -> c.project()).distinct().count();
        if (!lazyLoad || changes.size() < 3 || numProjects < 2) {
            // Format these changes in the request thread as the multithreading overhead would be too
            // high.
            List<ChangeInfo> result = new ArrayList<>(changes.size());
            for (Callable<Optional<ChangeInfo>> c : formattingCalls) {
                try {
                    c.call().ifPresent(result::add);
                } catch (Exception e) {
                    log.warn("Omitting change due to exception", e);
                }
            }
            return result;
        }
        // Format the changes in parallel on the executor
        List<ChangeInfo> result = new ArrayList<>(changes.size());
        try {
            for (Future<Optional<ChangeInfo>> f : fanOutExecutor.invokeAll(formattingCalls)) {
                f.get().ifPresent(result::add);
            }
        } catch (InterruptedException | ExecutionException e) {
            throw new IllegalStateException(e);
        }
        return result;
    }
}
#end_block

#method_before
private ChangeInfo toChangeInfoImpl(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, PermissionBackendException, IOException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.notes(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        if (!has(SKIP_MERGEABLE)) {
            out.mergeable = cd.isMergeable();
        }
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate() ? true : null;
    out.workInProgress = in.isWorkInProgress() ? true : null;
    out.hasReviewStarted = in.hasReviewStarted();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        out.reviewed = cd.isReviewedBy(user.getAccountId()) ? true : null;
    }
    out.labels = labelsFor(cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (user.isIdentifiedUser() && (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId()))) {
            PermissionBackend.ForChange perm = permissionBackendForChange(user, cd);
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(perm, cd) : ImmutableMap.of();
        }
        out.reviewers = reviewerMap(cd.reviewers(), cd.reviewersByEmail(), false);
        out.pendingReviewers = reviewerMap(cd.pendingReviewers(), cd.pendingReviewersByEmail(), true);
        out.removableReviewers = removableReviewers(cd, out);
    }
    setSubmitter(cd, out);
    out.plugins = pluginDefinedAttributesFactory != null ? pluginDefinedAttributesFactory.create(cd) : null;
    out.revertOf = cd.change().getRevertOf() != null ? cd.change().getRevertOf().get() : null;
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(cd);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(cd, src, limitToPsId, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, cd.notes());
    }
    if (has(TRACKING_IDS)) {
        ListMultimap<String, String> set = trackingFooters.extract(cd.commitFooters());
        out.trackingIds = set.entries().stream().map(e -> new TrackingIdInfo(e.getKey(), e.getValue())).collect(toList());
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfoImpl(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, PermissionBackendException, IOException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.notes(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        if (!has(SKIP_MERGEABLE)) {
            out.mergeable = cd.isMergeable();
        }
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate() ? true : null;
    out.workInProgress = in.isWorkInProgress() ? true : null;
    out.hasReviewStarted = in.hasReviewStarted();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        out.reviewed = cd.isReviewedBy(user.getAccountId()) ? true : null;
    }
    out.labels = labelsFor(cd, has(LABELS), has(DETAILED_LABELS));
    out.requirements = requirementsFor(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (user.isIdentifiedUser() && (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId()))) {
            PermissionBackend.ForChange perm = permissionBackendForChange(user, cd);
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(perm, cd) : ImmutableMap.of();
        }
        out.reviewers = reviewerMap(cd.reviewers(), cd.reviewersByEmail(), false);
        out.pendingReviewers = reviewerMap(cd.pendingReviewers(), cd.pendingReviewersByEmail(), true);
        out.removableReviewers = removableReviewers(cd, out);
    }
    setSubmitter(cd, out);
    out.plugins = pluginDefinedAttributesFactory != null ? pluginDefinedAttributesFactory.create(cd) : null;
    out.revertOf = cd.change().getRevertOf() != null ? cd.change().getRevertOf().get() : null;
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(cd);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(cd, src, limitToPsId, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, cd.notes());
    }
    if (has(TRACKING_IDS)) {
        ListMultimap<String, String> set = trackingFooters.extract(cd.commitFooters());
        out.trackingIds = set.entries().stream().map(e -> new TrackingIdInfo(e.getKey(), e.getValue())).collect(toList());
    }
    return out;
}
#end_block

#method_before
@Override
public ChangeMessageInfo get() {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeMessageInfo get() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<ChangeMessageInfo> messages() {
    throw new NotImplementedException();
}
#method_after
@Override
public List<ChangeMessageInfo> messages() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeMessageApi message(String id) {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeMessageApi message(String id) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Test
public void listChangeMessages() throws Exception {
    int changeNum = createOneChange();
    List<ChangeMessageInfo> messages1 = gApi.changes().id(changeNum).messages();
    List<ChangeMessageInfo> messages2 = new ArrayList<>(gApi.changes().id(changeNum).get().messages);
    assertThat(messages1).containsExactlyElementsIn(messages2).inOrder();
}
#method_after
@Test
public void listChangeMessages() throws Exception {
    int changeNum = createOneChangeWithMultipleChangeMessagesInHistory();
    List<ChangeMessageInfo> messages1 = gApi.changes().id(changeNum).messages();
    List<ChangeMessageInfo> messages2 = new ArrayList<>(gApi.changes().id(changeNum).get().messages);
    assertThat(messages1).containsExactlyElementsIn(messages2).inOrder();
}
#end_block

#method_before
@Test
public void getOneChangeMessage() throws Exception {
    int changeNum = createOneChange();
    List<ChangeMessageInfo> messages = new ArrayList<>(gApi.changes().id(changeNum).get().messages);
    for (ChangeMessageInfo messageInfo : messages) {
        String id = messageInfo.id;
        assertThat(gApi.changes().id(changeNum).message(id).get()).isEqualTo(messageInfo);
    }
}
#method_after
@Test
public void getOneChangeMessage() throws Exception {
    int changeNum = createOneChangeWithMultipleChangeMessagesInHistory();
    List<ChangeMessageInfo> messages = new ArrayList<>(gApi.changes().id(changeNum).get().messages);
    for (ChangeMessageInfo messageInfo : messages) {
        String id = messageInfo.id;
        assertThat(gApi.changes().id(changeNum).message(id).get()).isEqualTo(messageInfo);
    }
}
#end_block

#method_before
@Override
public List<ChangeMessageInfo> messages() {
    throw new NotImplementedException();
}
#method_after
@Override
public List<ChangeMessageInfo> messages() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
private ChangeInfo toChangeInfoImpl(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, PermissionBackendException, IOException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.notes(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        if (!has(SKIP_MERGEABLE)) {
            out.mergeable = cd.isMergeable();
        }
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate() ? true : null;
    out.workInProgress = in.isWorkInProgress() ? true : null;
    out.hasReviewStarted = in.hasReviewStarted();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        out.reviewed = cd.isReviewedBy(user.getAccountId()) ? true : null;
    }
    out.labels = labelsFor(cd, has(LABELS), has(DETAILED_LABELS));
    out.requirements = requirementsFor(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (user.isIdentifiedUser() && (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId()))) {
            PermissionBackend.ForChange perm = permissionBackendForChange(user, cd);
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(perm, cd) : ImmutableMap.of();
        }
        out.reviewers = reviewerMap(cd.reviewers(), cd.reviewersByEmail(), false);
        out.pendingReviewers = reviewerMap(cd.pendingReviewers(), cd.pendingReviewersByEmail(), true);
        out.removableReviewers = removableReviewers(cd, out);
    }
    setSubmitter(cd, out);
    out.plugins = pluginDefinedAttributesFactory != null ? pluginDefinedAttributesFactory.create(cd) : null;
    out.revertOf = cd.change().getRevertOf() != null ? cd.change().getRevertOf().get() : null;
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(cd);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(cd, src, limitToPsId, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, cd.notes());
    }
    if (has(TRACKING_IDS)) {
        ListMultimap<String, String> set = trackingFooters.extract(cd.commitFooters());
        out.trackingIds = set.entries().stream().map(e -> new TrackingIdInfo(e.getKey(), e.getValue())).collect(toList());
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfoImpl(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, PermissionBackendException, IOException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.notes(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.assignee = in.getAssignee() != null ? accountLoader.get(in.getAssignee()) : null;
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        if (!has(SKIP_MERGEABLE)) {
            out.mergeable = cd.isMergeable();
        }
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate() ? true : null;
    out.workInProgress = in.isWorkInProgress() ? true : null;
    out.hasReviewStarted = in.hasReviewStarted();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        out.reviewed = cd.isReviewedBy(user.getAccountId()) ? true : null;
    }
    out.labels = labelsFor(cd, has(LABELS), has(DETAILED_LABELS));
    out.requirements = requirementsFor(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (user.isIdentifiedUser() && (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId()))) {
            PermissionBackend.ForChange perm = permissionBackendForChange(user, cd);
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(perm, cd) : ImmutableMap.of();
        }
        out.reviewers = reviewerMap(cd.reviewers(), cd.reviewersByEmail(), false);
        out.pendingReviewers = reviewerMap(cd.pendingReviewers(), cd.pendingReviewersByEmail(), true);
        out.removableReviewers = removableReviewers(cd, out);
    }
    setSubmitter(cd, out);
    out.plugins = pluginDefinedAttributesFactory != null ? pluginDefinedAttributesFactory.create(cd) : null;
    out.revertOf = cd.change().getRevertOf() != null ? cd.change().getRevertOf().get() : null;
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(cd);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(cd, src, limitToPsId, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, cd.notes());
    }
    if (has(TRACKING_IDS)) {
        ListMultimap<String, String> set = trackingFooters.extract(cd.commitFooters());
        out.trackingIds = set.entries().stream().map(e -> new TrackingIdInfo(e.getKey(), e.getValue())).collect(toList());
    }
    return out;
}
#end_block

#method_before
@Test
public void listChangeMessages() throws Exception {
    int changeNum = createOneChange();
    List<ChangeMessageInfo> messages1 = gApi.changes().id(changeNum).messages();
    List<ChangeMessageInfo> messages2 = new ArrayList<>(gApi.changes().id(changeNum).get().messages);
    assertThat(messages1).containsExactlyElementsIn(messages2).inOrder();
}
#method_after
@Test
public void listChangeMessages() throws Exception {
    int changeNum = createOneChangeWithMultipleChangeMessagesInHistory();
    List<ChangeMessageInfo> messages1 = gApi.changes().id(changeNum).messages();
    List<ChangeMessageInfo> messages2 = new ArrayList<>(gApi.changes().id(changeNum).get().messages);
    assertThat(messages1).containsExactlyElementsIn(messages2).inOrder();
}
#end_block

#method_before
@Override
protected Response<ChangeInfo> applyImpl(BatchUpdate.Factory updateFactory, TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException, PermissionBackendException, ConfigInvalidException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW) {
            throw new BadRequestException("unsupported change status");
        }
    }
    if (input.baseChange != null && input.baseCommit != null) {
        throw new BadRequestException("only provide one of base_change or base_commit");
    }
    ProjectResource rsrc = projectsCollection.parse(input.project);
    boolean privateByDefault = rsrc.getProjectState().is(BooleanProjectConfig.PRIVATE_BY_DEFAULT);
    boolean isPrivate = input.isPrivate == null ? privateByDefault : input.isPrivate;
    if (isPrivate && disablePrivateChanges) {
        throw new MethodNotAllowedException("private changes are disabled");
    }
    contributorAgreements.check(rsrc.getNameKey(), rsrc.getUser());
    Project.NameKey project = rsrc.getNameKey();
    String refName = RefNames.fullName(input.branch);
    permissionBackend.currentUser().project(project).ref(refName).check(RefPermission.CREATE_CHANGE);
    rsrc.getProjectState().checkStatePermitsWrite();
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        ObjectId parentCommit;
        List<String> groups;
        Ref destRef = git.getRefDatabase().exactRef(refName);
        if (input.baseChange != null) {
            List<ChangeNotes> notes = changeFinder.find(input.baseChange);
            if (notes.size() != 1) {
                throw new UnprocessableEntityException("Base change not found: " + input.baseChange);
            }
            ChangeNotes change = Iterables.getOnlyElement(notes);
            try {
                permissionBackend.currentUser().change(change).database(db).check(ChangePermission.READ);
            } catch (AuthException e) {
                throw new UnprocessableEntityException("Read not permitted for " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), change);
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else if (input.baseCommit != null) {
            try {
                parentCommit = ObjectId.fromString(input.baseCommit);
            } catch (InvalidObjectIdException e) {
                throw new UnprocessableEntityException(String.format("Base %s doesn't represent a valid SHA-1", input.baseCommit));
            }
            RevCommit parentRevCommit = rw.parseCommit(parentCommit);
            RevCommit destRefRevCommit = rw.parseCommit(destRef.getObjectId());
            if (!rw.isMergedInto(parentRevCommit, destRefRevCommit)) {
                throw new BadRequestException(String.format("Commit %s doesn't exist on ref %s", input.baseCommit, input.branch));
            }
            groups = Collections.emptyList();
        } else {
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", refName));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new BadRequestException("Must provide a destination branch");
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        AccountState accountState = me.state();
        GeneralPreferencesInfo info = accountState.getGeneralPreferences();
        // Add a Change-Id line if there isn't already one
        String commitMessage = input.subject;
        if (ChangeIdUtil.indexOfChangeId(commitMessage, "\n") == -1) {
            ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
            ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, commitMessage);
            commitMessage = ChangeIdUtil.insertId(commitMessage, id);
        }
        if (Boolean.TRUE.equals(info.signedOffBy)) {
            commitMessage = Joiner.on("\n").join(commitMessage.trim(), String.format("%s%s", SIGNED_OFF_BY_TAG, accountState.getAccount().getNameEmail(anonymousCowardName)));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            if (!(submitType.equals(SubmitType.MERGE_ALWAYS) || submitType.equals(SubmitType.MERGE_IF_NECESSARY))) {
                throw new BadRequestException("Submit type: " + submitType + " is not supported");
            }
            c = newMergeCommit(git, oi, rw, rsrc.getProjectState(), mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, refName);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        String topic = input.topic;
        if (topic != null) {
            topic = Strings.emptyToNull(topic.trim());
        }
        ins.setTopic(topic);
        ins.setPrivate(isPrivate);
        ins.setWorkInProgress(input.workInProgress != null && input.workInProgress);
        ins.setGroups(groups);
        ins.setNotify(input.notify);
        ins.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
        try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.noOptions();
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#method_after
@Override
protected Response<ChangeInfo> applyImpl(BatchUpdate.Factory updateFactory, TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException, PermissionBackendException, ConfigInvalidException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW) {
            throw new BadRequestException("unsupported change status");
        }
    }
    if (input.baseChange != null && input.baseCommit != null) {
        throw new BadRequestException("only provide one of base_change or base_commit");
    }
    ProjectResource rsrc = projectsCollection.parse(input.project);
    boolean privateByDefault = rsrc.getProjectState().is(BooleanProjectConfig.PRIVATE_BY_DEFAULT);
    boolean isPrivate = input.isPrivate == null ? privateByDefault : input.isPrivate;
    if (isPrivate && disablePrivateChanges) {
        throw new MethodNotAllowedException("private changes are disabled");
    }
    contributorAgreements.check(rsrc.getNameKey(), rsrc.getUser());
    Project.NameKey project = rsrc.getNameKey();
    String refName = RefNames.fullName(input.branch);
    permissionBackend.currentUser().project(project).ref(refName).check(RefPermission.CREATE_CHANGE);
    rsrc.getProjectState().checkStatePermitsWrite();
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        ObjectId parentCommit;
        List<String> groups;
        Ref destRef = git.getRefDatabase().exactRef(refName);
        if (input.baseChange != null) {
            List<ChangeNotes> notes = changeFinder.find(input.baseChange);
            if (notes.size() != 1) {
                throw new UnprocessableEntityException("Base change not found: " + input.baseChange);
            }
            ChangeNotes change = Iterables.getOnlyElement(notes);
            try {
                permissionBackend.currentUser().change(change).database(db).check(ChangePermission.READ);
            } catch (AuthException e) {
                throw new UnprocessableEntityException("Read not permitted for " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), change);
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else if (input.baseCommit != null) {
            try {
                parentCommit = ObjectId.fromString(input.baseCommit);
            } catch (InvalidObjectIdException e) {
                throw new UnprocessableEntityException(String.format("Base %s doesn't represent a valid SHA-1", input.baseCommit));
            }
            RevCommit parentRevCommit = rw.parseCommit(parentCommit);
            RevCommit destRefRevCommit = rw.parseCommit(destRef.getObjectId());
            if (!rw.isMergedInto(parentRevCommit, destRefRevCommit)) {
                throw new BadRequestException(String.format("Commit %s doesn't exist on ref %s", input.baseCommit, refName));
            }
            groups = Collections.emptyList();
        } else {
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", refName));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new BadRequestException("Must provide a destination branch");
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        AccountState accountState = me.state();
        GeneralPreferencesInfo info = accountState.getGeneralPreferences();
        // Add a Change-Id line if there isn't already one
        String commitMessage = input.subject;
        if (ChangeIdUtil.indexOfChangeId(commitMessage, "\n") == -1) {
            ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
            ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, commitMessage);
            commitMessage = ChangeIdUtil.insertId(commitMessage, id);
        }
        if (Boolean.TRUE.equals(info.signedOffBy)) {
            commitMessage = Joiner.on("\n").join(commitMessage.trim(), String.format("%s%s", SIGNED_OFF_BY_TAG, accountState.getAccount().getNameEmail(anonymousCowardName)));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            if (!(submitType.equals(SubmitType.MERGE_ALWAYS) || submitType.equals(SubmitType.MERGE_IF_NECESSARY))) {
                throw new BadRequestException("Submit type: " + submitType + " is not supported");
            }
            c = newMergeCommit(git, oi, rw, rsrc.getProjectState(), mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, refName);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        String topic = input.topic;
        if (topic != null) {
            topic = Strings.emptyToNull(topic.trim());
        }
        ins.setTopic(topic);
        ins.setPrivate(isPrivate);
        ins.setWorkInProgress(input.workInProgress != null && input.workInProgress);
        ins.setGroups(groups);
        ins.setNotify(input.notify);
        ins.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
        try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.noOptions();
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
@Test
public void createChangeWithParentCommitOnWrongBranchFails() throws Exception {
    Map<String, PushOneCommit.Result> setup = changeInTwoBranches("foo", "foo.txt", "bar", "bar.txt");
    ChangeInput input = newChangeInput(ChangeStatus.NEW);
    input.branch = "foo";
    input.baseCommit = setup.get("bar").getCommit().getId().name();
    assertCreateFails(input, BadRequestException.class, String.format("Commit %s doesn't exist on ref foo", input.baseCommit));
}
#method_after
@Test
public void createChangeWithParentCommitOnWrongBranchFails() throws Exception {
    Map<String, PushOneCommit.Result> setup = changeInTwoBranches("foo", "foo.txt", "bar", "bar.txt");
    ChangeInput input = newChangeInput(ChangeStatus.NEW);
    input.branch = "foo";
    input.baseCommit = setup.get("bar").getCommit().getId().name();
    assertCreateFails(input, BadRequestException.class, String.format("Commit %s doesn't exist on ref refs/heads/foo", input.baseCommit));
}
#end_block

#method_before
@Override
public void beforeTest(Description description) throws Exception {
    super.beforeTest(description);
    createItsDir();
    createItsRulesConfig();
}
#method_after
@Override
public void beforeTest(Description description) throws Exception {
    super.beforeTest(description);
    createItsDir();
}
#end_block

#method_before
public void start() {
    if (running.compareAndSet(false, true)) {
        Thread t = new Thread() {

            @Override
            public void run() {
                boolean ok = false;
                try {
                    reindex();
                    ok = true;
                } catch (IOException e) {
                    log.error("Failed to reindex the changes online. Cause: {}", e);
                } finally {
                    running.set(false);
                    if (!ok) {
                        for (OnlineUpgradeListener listener : listeners) {
                            listener.onFailure(name, oldVersion, newVersion);
                        }
                    }
                }
            }
        };
        t.setName(String.format("Reindex %s v%d-v%d", name, version(indexes.getSearchIndex()), newVersion));
        t.start();
    }
}
#method_after
public void start() {
    if (running.compareAndSet(false, true)) {
        Thread t = new Thread() {

            @Override
            public void run() {
                boolean ok = false;
                try {
                    reindex();
                    ok = true;
                } catch (IOException e) {
                    log.error("Online reindex of {} schema version {} failed", name, version(index), e);
                } finally {
                    running.set(false);
                    if (!ok) {
                        for (OnlineUpgradeListener listener : listeners) {
                            listener.onFailure(name, oldVersion, newVersion);
                        }
                    }
                }
            }
        };
        t.setName(String.format("Reindex %s v%d-v%d", name, version(indexes.getSearchIndex()), newVersion));
        t.start();
    }
}
#end_block

#method_before
public void delete(Project project) throws OrmException {
    // TODO(davido): Why not to use 1.7 features?
    // http://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.20.3.2
    Connection conn = ((JdbcSchema) db).getConnection();
    try {
        conn.setAutoCommit(false);
        try {
            java.sql.ResultSet resultSet = conn.createStatement().executeQuery("select change_id from changes where dest_project_name ='" + project.getName() + "';");
            List<Change.Id> changeIds = new ArrayList<>();
            while (resultSet.next()) {
                changeIds.add(new Change.Id(resultSet.getInt(1)));
            }
            atomicDelete(project, changeIds);
            conn.commit();
        } finally {
            conn.setAutoCommit(true);
        }
    } catch (SQLException e) {
        try {
            conn.rollback();
        } catch (SQLException ex) {
            throw new OrmException(ex);
        }
        throw new OrmException(e);
    }
}
#method_after
public void delete(Project project) throws OrmException {
    // TODO(davido): Why not to use 1.7 features?
    // http://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.20.3.2
    Connection conn = ((JdbcSchema) db).getConnection();
    try {
        conn.setAutoCommit(false);
        try {
            PreparedStatement changesForProject = conn.prepareStatement("SELECT change_id FROM changes WHERE dest_project_name = ?");
            changesForProject.setString(1, project.getName());
            java.sql.ResultSet resultSet = changesForProject.executeQuery();
            List<Change.Id> changeIds = new ArrayList<>();
            while (resultSet.next()) {
                changeIds.add(new Change.Id(resultSet.getInt(1)));
            }
            atomicDelete(project, changeIds);
            conn.commit();
        } finally {
            conn.setAutoCommit(true);
        }
    } catch (SQLException e) {
        try {
            conn.rollback();
        } catch (SQLException ex) {
            throw new OrmException(ex);
        }
        throw new OrmException(e);
    }
}
#end_block

#method_before
@Test
public void addEmail() throws Exception {
    List<String> emails = ImmutableList.of("new.email@example.com", "new.email@example.systems");
    for (String email : emails) {
        EmailInput input = new EmailInput();
        input.email = email;
        input.noConfirmation = true;
        gApi.accounts().self().addEmail(input);
    }
}
#method_after
@Test
public void addEmail() throws Exception {
    List<String> emails = ImmutableList.of("new.email@example.com", "new.email@example.systems", // Not in the list of TLDs but added to override in OutgoingEmailValidator
    "new.email@example.local");
    for (String email : emails) {
        EmailInput input = new EmailInput();
        input.email = email;
        input.noConfirmation = true;
        gApi.accounts().self().addEmail(input);
    }
}
#end_block

#method_before
@Test
public void putStatus() throws Exception {
    List<String> statuses = ImmutableList.of("OOO", "Busy");
    for (String status : statuses) {
        gApi.accounts().self().putStatus(status);
    }
}
#method_after
@Test
public void putStatus() throws Exception {
    List<String> statuses = ImmutableList.of("OOO", "Busy");
    AccountInfo info;
    for (String status : statuses) {
        gApi.accounts().self().setStatus(status);
        admin.status = status;
        info = gApi.accounts().self().get();
        assertUser(info, admin);
    }
}
#end_block

#method_before
@Test
public void addInvalidEmail() throws Exception {
    EmailInput input = new EmailInput();
    input.email = "invalid@";
    input.noConfirmation = true;
    exception.expect(BadRequestException.class);
    exception.expectMessage("invalid email address");
    gApi.accounts().self().addEmail(input);
}
#method_after
@Test
public void addInvalidEmail() throws Exception {
    List<String> emails = ImmutableList.of(// Missing domain part
    "new.email", // Missing domain part
    "new.email@", // Missing user part
    "@example.com", // Non-supported TLD  (see tlds-alpha-by-domain.txt)
    "new.email@example.blog");
    for (String email : emails) {
        EmailInput input = new EmailInput();
        input.email = email;
        input.noConfirmation = true;
        try {
            gApi.accounts().self().addEmail(input);
            fail("Expected BadRequestException for invalid email address: " + email);
        } catch (BadRequestException e) {
            assertThat(e).hasMessage("invalid email address");
        }
    }
}
#end_block

#method_before
@Override
public Response<String> apply(AccountResource rsrc, Input input) throws AuthException, ResourceNotFoundException, OrmException, IOException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("not allowed to change name");
    }
    return apply(rsrc.getUser(), input);
}
#method_after
@Override
public Response<String> apply(AccountResource rsrc, Input input) throws AuthException, ResourceNotFoundException, OrmException, IOException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("not allowed to set status");
    }
    return apply(rsrc.getUser(), input);
}
#end_block

#method_before
public Response<String> apply(IdentifiedUser user, Input input) throws ResourceNotFoundException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    Account a = dbProvider.get().accounts().get(user.getAccountId());
    if (a == null) {
        throw new ResourceNotFoundException("account not found");
    }
    a.setStatus(input.status);
    dbProvider.get().accounts().update(Collections.singleton(a));
    byIdCache.evict(a.getId());
    return Strings.isNullOrEmpty(a.getFullName()) ? Response.<String>none() : Response.ok(a.getFullName());
}
#method_after
public Response<String> apply(IdentifiedUser user, Input input) throws ResourceNotFoundException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    Account a = dbProvider.get().accounts().get(user.getAccountId());
    if (a == null) {
        throw new ResourceNotFoundException("account not found");
    }
    a.setStatus(Strings.nullToEmpty(input.status));
    dbProvider.get().accounts().update(Collections.singleton(a));
    byIdCache.evict(a.getId());
    return Strings.isNullOrEmpty(a.getStatus()) ? Response.none() : Response.ok(a.getStatus());
}
#end_block

#method_before
@Test
public void driveByComment() throws Exception {
    // Create change owned by admin.
    PushOneCommit.Result r = createChange();
    // Post drive-by message as user.
    ReviewInput input = new ReviewInput().message("hello");
    RestResponse resp = userRestSession.post("/changes/" + r.getChangeId() + "/revisions/" + r.getCommit().getName() + "/review", input);
    ReviewResult result = readContentFromJson(resp, 200, ReviewResult.class);
    assertThat(result.labels).isNull();
    assertThat(result.reviewers).isNull();
    // Verify user is not added as reviewer.
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    if (notesMigration.readChanges()) {
        assertReviewers(c, REVIEWER);
        assertReviewers(c, CC, user);
    } else {
        assertReviewers(c, REVIEWER, user);
        assertReviewers(c, CC);
    }
}
#method_after
@Test
public void driveByComment() throws Exception {
    // Create change owned by admin.
    PushOneCommit.Result r = createChange();
    // Post drive-by message as user.
    ReviewInput input = new ReviewInput().message("hello");
    RestResponse resp = userRestSession.post("/changes/" + r.getChangeId() + "/revisions/" + r.getCommit().getName() + "/review", input);
    ReviewResult result = readContentFromJson(resp, 200, ReviewResult.class);
    assertThat(result.labels).isNull();
    assertThat(result.reviewers).isNull();
    // Verify user is added to CC list.
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    if (notesMigration.readChanges()) {
        assertReviewers(c, REVIEWER);
        assertReviewers(c, CC, user);
    } else {
        // If we aren't reading from NoteDb, the user will appear as a
        // reviewer.
        assertReviewers(c, REVIEWER, user);
        assertReviewers(c, CC);
    }
}
#end_block

#method_before
public Response<ReviewResult> apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    } else if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            // Prevent notifications because setting reviewers is batched.
            reviewerInput.notify = NotifyHandling.NONE;
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        Account.Id selfId = bu.getUser().getAccountId();
        ReviewerSet currentReviewers = approvalsUtil.getReviewers(db.get(), revision.getChangeResource().getNotes());
        boolean isSelfReviewer = currentReviewers.all().contains(selfId);
        // updated set of reviewers.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
            if (!isSelfReviewer && reviewerResult.result.reviewers != null) {
                for (ReviewerInfo reviewerInfo : reviewerResult.result.reviewers) {
                    if (selfId.equals(reviewerInfo._accountId)) {
                        isSelfReviewer = true;
                        break;
                    }
                }
            }
            if (!isSelfReviewer && reviewerResult.result.ccs != null) {
                for (AccountInfo accountInfo : reviewerResult.result.ccs) {
                    if (selfId.equals(accountInfo._accountId)) {
                        isSelfReviewer = true;
                        break;
                    }
                }
            }
        }
        if (!isSelfReviewer) {
            // User posting this review isn't currently in the reviewer or CC list.
            // Automatically CC them on this change so they receive replies.
            Map<Account.Id, ChangeControl> selfMap = ImmutableMap.of(selfId, revision.getControl());
            PostReviewers.Addition selfAddition = postReviewers.ccCurrentUser(bu.getUser(), revision);
            bu.addOp(revision.getChange().getId(), selfAddition.op);
        }
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input, reviewerResults));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
        emailReviewers(revision.getChange(), reviewerResults, input.notify);
    }
    return Response.ok(output);
}
#method_after
public Response<ReviewResult> apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    } else if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            // Prevent notifications because setting reviewers is batched.
            reviewerInput.notify = NotifyHandling.NONE;
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        Account.Id id = bu.getUser().getAccountId();
        boolean ccOrReviewer = input.labels != null;
        if (!ccOrReviewer) {
            // Check if user was already CCed or reviewing prior to this review.
            ReviewerSet currentReviewers = approvalsUtil.getReviewers(db.get(), revision.getChangeResource().getNotes());
            ccOrReviewer = currentReviewers.all().contains(id);
        }
        // themselves as a reviewer or to the CC list.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
            if (!ccOrReviewer && reviewerResult.result.reviewers != null) {
                for (ReviewerInfo reviewerInfo : reviewerResult.result.reviewers) {
                    if (id.equals(reviewerInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
            if (!ccOrReviewer && reviewerResult.result.ccs != null) {
                for (AccountInfo accountInfo : reviewerResult.result.ccs) {
                    if (id.equals(accountInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
        }
        if (!ccOrReviewer) {
            // User posting this review isn't currently in the reviewer or CC list,
            // isn't being explicitly added, and isn't voting on any label.
            // Automatically CC them on this change so they receive replies.
            PostReviewers.Addition selfAddition = postReviewers.ccCurrentUser(bu.getUser(), revision);
            bu.addOp(revision.getChange().getId(), selfAddition.op);
        }
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input, reviewerResults));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
        emailReviewers(revision.getChange(), reviewerResults, input.notify);
    }
    return Response.ok(output);
}
#end_block

#method_before
private boolean updateLabels(ChangeContext ctx) throws OrmException, ResourceConflictException {
    Map<String, Short> inLabels = MoreObjects.firstNonNull(in.labels, Collections.<String, Short>emptyMap());
    // losing access to a label after the change was submitted.
    if (inLabels.isEmpty() && ctx.getChange().getStatus().isClosed()) {
        return false;
    }
    List<PatchSetApproval> del = new ArrayList<>();
    List<PatchSetApproval> ups = new ArrayList<>();
    Map<String, PatchSetApproval> current = scanLabels(ctx, del);
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Map<String, Short> allApprovals = getAllApprovals(labelTypes, approvalsByKey(current.values()), inLabels);
    Map<String, Short> previous = getPreviousApprovals(allApprovals, approvalsByKey(current.values()));
    ChangeUpdate update = ctx.getUpdate(psId);
    for (Map.Entry<String, Short> ent : allApprovals.entrySet()) {
        String name = ent.getKey();
        LabelType lt = checkNotNull(labelTypes.byLabel(name), name);
        PatchSetApproval c = current.remove(lt.getName());
        String normName = lt.getName();
        approvals.put(normName, (short) 0);
        if (ent.getValue() == null || ent.getValue() == 0) {
            // User requested delete of this label.
            oldApprovals.put(normName, null);
            if (c != null) {
                if (c.getValue() != 0) {
                    addLabelDelta(normName, (short) 0);
                    oldApprovals.put(normName, previous.get(normName));
                }
                del.add(c);
                update.putApproval(normName, (short) 0);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(ctx.getWhen());
            c.setTag(in.tag);
            ctx.getUser().updateRealAccountId(c::setRealAccountId);
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putApproval(normName, ent.getValue());
        } else if (c != null && c.getValue() == ent.getValue()) {
            current.put(normName, c);
            oldApprovals.put(normName, null);
            approvals.put(normName, c.getValue());
        } else if (c == null) {
            c = ApprovalsUtil.newApproval(psId, user, lt.getLabelId(), ent.getValue(), ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putReviewer(user.getAccountId(), REVIEWER);
            update.putApproval(normName, ent.getValue());
        }
    }
    validatePostSubmitLabels(ctx, labelTypes, previous, ups, del);
    // This allows us to preserve their CC status.
    if (current.isEmpty() && del.isEmpty() && ups.isEmpty() && !isReviewer(ctx)) {
        return false;
    }
    forceCallerAsReviewer(ctx, current, ups, del);
    ctx.getDb().patchSetApprovals().delete(del);
    ctx.getDb().patchSetApprovals().upsert(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#method_after
private boolean updateLabels(ChangeContext ctx) throws OrmException, ResourceConflictException {
    Map<String, Short> inLabels = MoreObjects.firstNonNull(in.labels, Collections.<String, Short>emptyMap());
    // losing access to a label after the change was submitted.
    if (inLabels.isEmpty() && ctx.getChange().getStatus().isClosed()) {
        return false;
    }
    List<PatchSetApproval> del = new ArrayList<>();
    List<PatchSetApproval> ups = new ArrayList<>();
    Map<String, PatchSetApproval> current = scanLabels(ctx, del);
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Map<String, Short> allApprovals = getAllApprovals(labelTypes, approvalsByKey(current.values()), inLabels);
    Map<String, Short> previous = getPreviousApprovals(allApprovals, approvalsByKey(current.values()));
    ChangeUpdate update = ctx.getUpdate(psId);
    for (Map.Entry<String, Short> ent : allApprovals.entrySet()) {
        String name = ent.getKey();
        LabelType lt = checkNotNull(labelTypes.byLabel(name), name);
        PatchSetApproval c = current.remove(lt.getName());
        String normName = lt.getName();
        approvals.put(normName, (short) 0);
        if (ent.getValue() == null || ent.getValue() == 0) {
            // User requested delete of this label.
            oldApprovals.put(normName, null);
            if (c != null) {
                if (c.getValue() != 0) {
                    addLabelDelta(normName, (short) 0);
                    oldApprovals.put(normName, previous.get(normName));
                }
                del.add(c);
                update.putApproval(normName, (short) 0);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(ctx.getWhen());
            c.setTag(in.tag);
            ctx.getUser().updateRealAccountId(c::setRealAccountId);
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putApproval(normName, ent.getValue());
        } else if (c != null && c.getValue() == ent.getValue()) {
            current.put(normName, c);
            oldApprovals.put(normName, null);
            approvals.put(normName, c.getValue());
        } else if (c == null) {
            c = ApprovalsUtil.newApproval(psId, user, lt.getLabelId(), ent.getValue(), ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putReviewer(user.getAccountId(), REVIEWER);
            update.putApproval(normName, ent.getValue());
        }
    }
    validatePostSubmitLabels(ctx, labelTypes, previous, ups, del);
    // This allows us to preserve their CC status.
    if (current.isEmpty() && del.isEmpty() && ups.isEmpty() && !isReviewer(ctx)) {
        return false;
    }
    forceCallerAsReviewer(ctx, current, ups, del);
    if (PrimaryStorage.of(update.getChange()) == REVIEW_DB) {
        // Avoid OrmConcurrencyException trying to delete non-existent entities.
        ctx.getDb().patchSetApprovals().delete(del);
        ctx.getDb().patchSetApprovals().upsert(ups);
    }
    return !del.isEmpty() || !ups.isEmpty();
}
#end_block

#method_before
public boolean hasInlineComments() {
    return !inlineComments.isEmpty();
}
#method_after
@Deprecated
public boolean hasInlineComments() {
    return !inlineComments.isEmpty();
}
#end_block

#method_before
public String getInlineComments() {
    return getInlineComments(1);
}
#method_after
@Deprecated
public String getInlineComments() {
    return getInlineComments(1);
}
#end_block

#method_before
public String getInlineComments(int lines) {
    StringBuilder cmts = new StringBuilder();
    for (FileCommentGroup group : getGroupedInlineComments()) {
        String link = group.getLink();
        if (link != null) {
            cmts.append(link).append('\n');
        }
        cmts.append(group.getTitle()).append(":\n\n");
        for (Comment c : group.comments) {
            appendComment(cmts, lines, group.fileData, c);
        }
        cmts.append("\n\n");
    }
    return cmts.toString();
}
#method_after
@Deprecated
public String getInlineComments(int lines) {
    StringBuilder cmts = new StringBuilder();
    for (FileCommentGroup group : getGroupedInlineComments()) {
        String link = group.getLink();
        if (link != null) {
            cmts.append(link).append('\n');
        }
        cmts.append(group.getTitle()).append(":\n\n");
        for (Comment c : group.comments) {
            appendComment(cmts, lines, group.fileData, c);
        }
        cmts.append("\n\n");
    }
    return cmts.toString();
}
#end_block

#method_before
private void appendComment(StringBuilder out, int contextLines, PatchFile currentFileData, Comment comment) {
    if (comment.range != null) {
        appendRangedComment(out, contextLines, currentFileData, comment);
    } else {
        appendLineComment(out, contextLines, currentFileData, comment);
    }
}
#method_after
@Deprecated
private void appendComment(StringBuilder out, int contextLines, PatchFile currentFileData, Comment comment) {
    if (comment instanceof RobotComment) {
        RobotComment robotComment = (RobotComment) comment;
        out.append("Robot Comment from ").append(robotComment.robotId).append(" (run ID ").append(robotComment.robotRunId).append("):\n");
    }
    if (comment.range != null) {
        appendRangedComment(out, contextLines, currentFileData, comment);
    } else {
        appendLineComment(out, contextLines, currentFileData, comment);
    }
}
#end_block

#method_before
private void appendRangedComment(StringBuilder out, int contextLines, PatchFile fileData, Comment comment) {
    String prefix = "PS" + comment.key.patchSetId + ", Line " + comment.range.startLine + ": ";
    boolean firstLine = true;
    for (String line : getLinesByRange(comment.range, fileData, comment.side)) {
        out.append(firstLine ? prefix : Strings.padStart(": ", prefix.length(), ' ')).append(line).append('\n');
        firstLine = false;
    }
    appendQuotedParent(out, comment);
    out.append(comment.message.trim()).append('\n');
}
#method_after
@Deprecated
private void appendRangedComment(StringBuilder out, int contextLines, PatchFile fileData, Comment comment) {
    String prefix = getCommentLinePrefix(comment);
    String emptyPrefix = Strings.padStart(": ", prefix.length(), ' ');
    boolean firstLine = true;
    for (String line : getLinesByRange(comment.range, fileData, comment.side)) {
        out.append(firstLine ? prefix : emptyPrefix).append(line).append('\n');
        firstLine = false;
    }
    appendQuotedParent(out, comment);
    out.append(comment.message.trim()).append('\n');
}
#end_block

#method_before
private List<String> getLinesByRange(Comment.Range range, PatchFile fileData, short side) {
    List<String> lines = new ArrayList<>();
    for (int n = range.startLine; n <= range.endLine; n++) {
        try {
            String s = fileData.getLine(side, n);
            if (n == range.startLine && n == range.endLine) {
                s = s.substring(Math.min(range.startChar, s.length()), Math.min(range.endChar, s.length()));
            } else if (n == range.startLine) {
                s = s.substring(Math.min(range.startChar, s.length()));
            } else if (n == range.endLine) {
                s = s.substring(0, Math.min(range.endChar, s.length()));
            }
            lines.add(s);
        } catch (Throwable e) {
            // If we can't safely convert the line, then default to an empty string.
            lines.add("");
        }
    }
    return lines;
}
#method_after
private List<String> getLinesByRange(Comment.Range range, PatchFile fileData, short side) {
    List<String> lines = new ArrayList<>();
    for (int n = range.startLine; n <= range.endLine; n++) {
        String s = getLine(fileData, side, n);
        if (n == range.startLine && n == range.endLine) {
            s = s.substring(Math.min(range.startChar, s.length()), Math.min(range.endChar, s.length()));
        } else if (n == range.startLine) {
            s = s.substring(Math.min(range.startChar, s.length()));
        } else if (n == range.endLine) {
            s = s.substring(0, Math.min(range.endChar, s.length()));
        }
        lines.add(s);
    }
    return lines;
}
#end_block

#method_before
private void appendLineComment(StringBuilder out, int contextLines, PatchFile currentFileData, Comment comment) {
    short side = comment.side;
    int lineNbr = comment.lineNbr;
    int maxLines;
    try {
        maxLines = currentFileData.getLineCount(side);
    } catch (Throwable e) {
        maxLines = lineNbr;
    }
    final int startLine = Math.max(1, lineNbr - contextLines + 1);
    final int stopLine = Math.min(maxLines, lineNbr + contextLines);
    for (int line = startLine; line <= lineNbr; ++line) {
        appendFileLine(out, currentFileData, side, line);
    }
    appendQuotedParent(out, comment);
    out.append(comment.message.trim()).append('\n');
    for (int line = lineNbr + 1; line < stopLine; ++line) {
        appendFileLine(out, currentFileData, side, line);
    }
}
#method_after
@Deprecated
private void appendLineComment(StringBuilder out, int contextLines, PatchFile currentFileData, Comment comment) {
    short side = comment.side;
    int lineNbr = comment.lineNbr;
    // Initialize maxLines to the known line number.
    int maxLines = lineNbr;
    try {
        maxLines = currentFileData.getLineCount(side);
    } catch (IOException err) {
        // The file could not be read, leave the max as is.
        log.warn(String.format("Failed to read file %s on side %d", comment.key.filename, side), err);
    } catch (NoSuchEntityException err) {
        // The file could not be read, leave the max as is.
        log.warn(String.format("Side %d of file %s didn't exist", side, comment.key.filename), err);
    }
    int startLine = Math.max(1, lineNbr - contextLines + 1);
    int stopLine = Math.min(maxLines, lineNbr + contextLines);
    for (int line = startLine; line <= lineNbr; ++line) {
        appendFileLine(out, currentFileData, side, line);
    }
    appendQuotedParent(out, comment);
    out.append(comment.message.trim()).append('\n');
    for (int line = lineNbr + 1; line < stopLine; ++line) {
        appendFileLine(out, currentFileData, side, line);
    }
}
#end_block

#method_before
private void appendFileLine(StringBuilder cmts, PatchFile fileData, short side, int line) {
    cmts.append("Line " + line);
    try {
        final String lineStr = fileData.getLine(side, line);
        cmts.append(": ");
        cmts.append(lineStr);
    } catch (Throwable e) {
        // If we can't safely convert the line, then default to an empty string.
        cmts.append("");
    }
    cmts.append("\n");
}
#method_after
@Deprecated
private void appendFileLine(StringBuilder cmts, PatchFile fileData, short side, int line) {
    String lineStr = getLine(fileData, side, line);
    cmts.append("Line ").append(line).append(": ").append(lineStr).append("\n");
}
#end_block

#method_before
private void appendQuotedParent(StringBuilder out, Comment child) {
    Optional<Comment> parent = getParent(child);
    if (parent.isPresent()) {
        out.append("> ").append(getShortenedCommentMessage(parent.get())).append('\n');
    }
}
#method_after
@Deprecated
private void appendQuotedParent(StringBuilder out, Comment child) {
    Optional<Comment> parent = getParent(child);
    if (parent.isPresent()) {
        out.append("> ").append(getShortenedCommentMessage(parent.get())).append('\n');
    }
}
#end_block

#method_before
private Optional<Comment> getParent(Comment child) {
    if (child.parentUuid == null) {
        return Optional.absent();
    }
    Optional<Comment> parent;
    Comment.Key key = new Comment.Key(child.parentUuid, child.key.filename, child.key.patchSetId);
    try {
        return commentsUtil.get(args.db.get(), changeData.notes(), key);
    } catch (OrmException e) {
        log.warn("Could not find the parent of this comment: " + child.toString());
        return Optional.absent();
    }
}
#method_after
private Optional<Comment> getParent(Comment child) {
    if (child.parentUuid == null) {
        return Optional.empty();
    }
    Optional<Comment> parent;
    Comment.Key key = new Comment.Key(child.parentUuid, child.key.filename, child.key.patchSetId);
    try {
        return commentsUtil.get(args.db.get(), changeData.notes(), key);
    } catch (OrmException e) {
        log.warn("Could not find the parent of this comment: " + child.toString());
        return Optional.empty();
    }
}
#end_block

#method_before
private List<String> getLinesOfComment(Comment comment, PatchFile fileData) {
    List<String> lines = new ArrayList<>();
    if (comment.range == null) {
        try {
            lines.add(fileData.getLine(comment.side, comment.lineNbr));
        } catch (Throwable e) {
            // If we can't safely convert the line, then default to an empty string.
            lines.add("");
        }
    } else {
        lines.addAll(getLinesByRange(comment.range, fileData, comment.side));
    }
    return lines;
}
#method_after
private List<String> getLinesOfComment(Comment comment, PatchFile fileData) {
    List<String> lines = new ArrayList<>();
    if (comment.range == null) {
        lines.add(getLine(fileData, comment.side, comment.lineNbr));
    } else {
        lines.addAll(getLinesByRange(comment.range, fileData, comment.side));
    }
    return lines;
}
#end_block

#method_before
private List<Map<String, Object>> getCommentGroupsTemplateData() {
    List<Map<String, Object>> commentGroups = new ArrayList<>();
    for (CommentSender.FileCommentGroup group : getGroupedInlineComments()) {
        Map<String, Object> groupData = new HashMap<>();
        groupData.put("link", group.getLink());
        groupData.put("title", group.getTitle());
        groupData.put("patchSetId", group.patchSetId);
        List<Map<String, Object>> commentsList = new ArrayList<>();
        for (Comment comment : group.comments) {
            Map<String, Object> commentData = new HashMap<>();
            commentData.put("lines", getLinesOfComment(comment, group.fileData));
            commentData.put("message", comment.message.trim());
            if (comment.range == null) {
                commentData.put("startLine", comment.lineNbr);
            } else {
                commentData.put("startLine", comment.range.startLine);
                commentData.put("endLine", comment.range.endLine);
            }
            Optional<Comment> parent = getParent(comment);
            if (parent.isPresent()) {
                commentData.put("parentMessage", getShortenedCommentMessage(parent.get()));
            }
            commentsList.add(commentData);
        }
        groupData.put("comments", commentsList);
        commentGroups.add(groupData);
    }
    return commentGroups;
}
#method_after
private List<Map<String, Object>> getCommentGroupsTemplateData() {
    List<Map<String, Object>> commentGroups = new ArrayList<>();
    for (CommentSender.FileCommentGroup group : getGroupedInlineComments()) {
        Map<String, Object> groupData = new HashMap<>();
        groupData.put("link", group.getLink());
        groupData.put("title", group.getTitle());
        groupData.put("patchSetId", group.patchSetId);
        List<Map<String, Object>> commentsList = new ArrayList<>();
        for (Comment comment : group.comments) {
            Map<String, Object> commentData = new HashMap<>();
            commentData.put("lines", getLinesOfComment(comment, group.fileData));
            commentData.put("message", comment.message.trim());
            String prefix = getCommentLinePrefix(comment);
            commentData.put("linePrefix", prefix);
            commentData.put("linePrefixEmpty", Strings.padStart(": ", prefix.length(), ' '));
            if (comment.range == null) {
                commentData.put("startLine", comment.lineNbr);
            } else {
                commentData.put("startLine", comment.range.startLine);
                commentData.put("endLine", comment.range.endLine);
            }
            if (comment instanceof RobotComment) {
                RobotComment robotComment = (RobotComment) comment;
                commentData.put("isRobotComment", true);
                commentData.put("robotId", robotComment.robotId);
                commentData.put("robotRunId", robotComment.robotRunId);
            } else {
                commentData.put("isRobotComment", false);
            }
            Optional<Comment> parent = getParent(comment);
            if (parent.isPresent()) {
                commentData.put("parentMessage", getShortenedCommentMessage(parent.get()));
            }
            commentsList.add(commentData);
        }
        groupData.put("comments", commentsList);
        commentGroups.add(groupData);
    }
    return commentGroups;
}
#end_block

#method_before
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("inlineCommentGroups", getCommentGroupsTemplateData());
}
#method_after
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("commentFiles", getCommentGroupsTemplateData());
}
#end_block

#method_before
@Override
public void send(final Address from, Collection<Address> rcpt, final Map<String, EmailHeader> callerHeaders, String body) throws EmailException {
/* noop */
}
#method_after
@Override
public void send(final Address from, Collection<Address> rcpt, final Map<String, EmailHeader> callerHeaders, String body) throws EmailException {
    send(from, rcpt, callerHeaders, body, null);
}
#end_block

#method_before
public CodeReviewCommit createCherryPickFromCommit(Repository repo, ObjectInserter inserter, RevCommit mergeTip, RevCommit originalCommit, PersonIdent cherryPickCommitterIdent, String commitMsg, CodeReviewRevWalk rw) throws MissingObjectException, IncorrectObjectTypeException, IOException, MergeIdenticalTreeException, MergeConflictException {
    final ThreeWayMerger m = newThreeWayMerger(repo, inserter);
    m.setBase(originalCommit.getParent(0));
    if (m.merge(mergeTip, originalCommit)) {
        ObjectId tree = m.getResultTreeId();
        if (tree.equals(mergeTip.getTree())) {
            throw new MergeIdenticalTreeException("identical tree");
        }
        CommitBuilder mergeCommit = new CommitBuilder();
        mergeCommit.setTreeId(tree);
        mergeCommit.setParentId(mergeTip);
        mergeCommit.setAuthor(originalCommit.getAuthorIdent());
        mergeCommit.setCommitter(cherryPickCommitterIdent);
        mergeCommit.setMessage(commitMsg);
        return rw.parseCommit(inserter.insert(mergeCommit));
    } else {
        throw new MergeConflictException("merge conflict");
    }
}
#method_after
public CodeReviewCommit createCherryPickFromCommit(Repository repo, ObjectInserter inserter, RevCommit mergeTip, RevCommit originalCommit, PersonIdent cherryPickCommitterIdent, String commitMsg, CodeReviewRevWalk rw) throws MissingObjectException, IncorrectObjectTypeException, IOException, MergeIdenticalTreeException, MergeConflictException {
    final ThreeWayMerger m = newThreeWayMerger(repo, inserter);
    m.setBase(originalCommit.getParent(0));
    if (m.merge(mergeTip, originalCommit)) {
        ObjectId tree = m.getResultTreeId();
        if (tree.equals(mergeTip.getTree())) {
            throw new MergeIdenticalTreeException("identical tree");
        }
        CommitBuilder mergeCommit = new CommitBuilder();
        mergeCommit.setTreeId(tree);
        mergeCommit.setParentId(mergeTip);
        mergeCommit.setAuthor(originalCommit.getAuthorIdent());
        mergeCommit.setCommitter(cherryPickCommitterIdent);
        mergeCommit.setMessage(commitMsg);
        return rw.parseCommit(inserter.insert(mergeCommit));
    }
    throw new MergeConflictException("merge conflict");
}
#end_block

#method_before
public RevCommit createMergeCommit(Repository repo, ObjectInserter inserter, RevCommit mergeTip, RevCommit originalCommit, PersonIdent committerIndent, String commitMsg, RevWalk rw) throws IOException, MergeIdenticalTreeException, MergeConflictException {
    final ThreeWayMerger m = newThreeWayMerger(repo, inserter);
    if (m.merge(mergeTip, originalCommit)) {
        ObjectId tree = m.getResultTreeId();
        if (tree.equals(mergeTip.getTree())) {
            throw new MergeIdenticalTreeException("identical tree");
        }
        CommitBuilder mergeCommit = new CommitBuilder();
        mergeCommit.setTreeId(tree);
        mergeCommit.setParentIds(mergeTip, originalCommit);
        mergeCommit.setAuthor(originalCommit.getAuthorIdent());
        mergeCommit.setCommitter(committerIndent);
        mergeCommit.setMessage(commitMsg);
        return rw.parseCommit(inserter.insert(mergeCommit));
    } else {
        throw new MergeConflictException("merge conflict");
    }
}
#method_after
public static ObjectId createMergeCommit(Repository repo, ObjectInserter inserter, RevCommit mergeTip, RevCommit originalCommit, String mergeStrategy, PersonIdent committerIndent, String commitMsg, RevWalk rw) throws IOException, MergeIdenticalTreeException, MergeConflictException {
    if (rw.isMergedInto(originalCommit, mergeTip)) {
        throw new MergeIdenticalTreeException("merge identical tree: change(s) has been already merged!");
    }
    Merger m = newMerger(repo, inserter, mergeStrategy);
    if (m.merge(false, mergeTip, originalCommit)) {
        ObjectId tree = m.getResultTreeId();
        CommitBuilder mergeCommit = new CommitBuilder();
        mergeCommit.setTreeId(tree);
        mergeCommit.setParentIds(mergeTip, originalCommit);
        mergeCommit.setAuthor(committerIndent);
        mergeCommit.setCommitter(committerIndent);
        mergeCommit.setMessage(commitMsg);
        return inserter.insert(mergeCommit);
    } else {
        List<String> conflicts = ImmutableList.of();
        if (m instanceof ResolveMerger) {
            conflicts = ((ResolveMerger) m).getUnmergedPaths();
        }
        throw new MergeConflictException(createConflictMessage(conflicts));
    }
}
#end_block

#method_before
public boolean canMerge(final MergeSorter mergeSorter, final Repository repo, final CodeReviewCommit mergeTip, final CodeReviewCommit toMerge) throws IntegrationException {
    if (hasMissingDependencies(mergeSorter, toMerge)) {
        return false;
    }
    ThreeWayMerger m = newThreeWayMerger(repo, createDryRunInserter(repo));
    try {
        return m.merge(new AnyObjectId[] { mergeTip, toMerge });
    } catch (LargeObjectException e) {
        log.warn("Cannot merge due to LargeObjectException: " + toMerge.name());
        return false;
    } catch (NoMergeBaseException e) {
        return false;
    } catch (IOException e) {
        throw new IntegrationException("Cannot merge " + toMerge.name(), e);
    }
}
#method_after
public boolean canMerge(final MergeSorter mergeSorter, final Repository repo, final CodeReviewCommit mergeTip, final CodeReviewCommit toMerge) throws IntegrationException {
    if (hasMissingDependencies(mergeSorter, toMerge)) {
        return false;
    }
    try (ObjectInserter ins = new InMemoryInserter(repo)) {
        return newThreeWayMerger(repo, ins).merge(new AnyObjectId[] { mergeTip, toMerge });
    } catch (LargeObjectException e) {
        log.warn("Cannot merge due to LargeObjectException: " + toMerge.name());
        return false;
    } catch (NoMergeBaseException e) {
        return false;
    } catch (IOException e) {
        throw new IntegrationException("Cannot merge " + toMerge.name(), e);
    }
}
#end_block

#method_before
public boolean canCherryPick(MergeSorter mergeSorter, Repository repo, CodeReviewCommit mergeTip, CodeReviewRevWalk rw, CodeReviewCommit toMerge) throws IntegrationException {
    if (mergeTip == null) {
        // 
        return true;
    }
    if (toMerge.getParentCount() == 0) {
        // 
        return false;
    }
    if (toMerge.getParentCount() == 1) {
        // 
        try {
            ThreeWayMerger m = newThreeWayMerger(repo, createDryRunInserter(repo));
            m.setBase(toMerge.getParent(0));
            return m.merge(mergeTip, toMerge);
        } catch (IOException e) {
            throw new IntegrationException("Cannot merge " + toMerge.name(), e);
        }
    }
    // 
    return canFastForward(mergeSorter, mergeTip, rw, toMerge) || canMerge(mergeSorter, repo, mergeTip, toMerge);
}
#method_after
public boolean canCherryPick(MergeSorter mergeSorter, Repository repo, CodeReviewCommit mergeTip, CodeReviewRevWalk rw, CodeReviewCommit toMerge) throws IntegrationException {
    if (mergeTip == null) {
        // 
        return true;
    }
    if (toMerge.getParentCount() == 0) {
        // 
        return false;
    }
    if (toMerge.getParentCount() == 1) {
        // 
        try (ObjectInserter ins = new InMemoryInserter(repo)) {
            ThreeWayMerger m = newThreeWayMerger(repo, ins);
            m.setBase(toMerge.getParent(0));
            return m.merge(mergeTip, toMerge);
        } catch (IOException e) {
            throw new IntegrationException("Cannot merge " + toMerge.name(), e);
        }
    }
    // 
    return canFastForward(mergeSorter, mergeTip, rw, toMerge) || canMerge(mergeSorter, repo, mergeTip, toMerge);
}
#end_block

#method_before
public CodeReviewCommit mergeOneCommit(PersonIdent author, PersonIdent committer, Repository repo, CodeReviewRevWalk rw, ObjectInserter inserter, Branch.NameKey destBranch, CodeReviewCommit mergeTip, CodeReviewCommit n) throws IntegrationException {
    final ThreeWayMerger m = newThreeWayMerger(repo, inserter);
    try {
        if (m.merge(new AnyObjectId[] { mergeTip, n })) {
            return writeMergeCommit(author, committer, rw, inserter, destBranch, mergeTip, m.getResultTreeId(), n);
        } else {
            failed(rw, mergeTip, n, CommitMergeStatus.PATH_CONFLICT);
        }
    } catch (NoMergeBaseException e) {
        try {
            failed(rw, mergeTip, n, getCommitMergeStatus(e.getReason()));
        } catch (IOException e2) {
            throw new IntegrationException("Cannot merge " + n.name(), e);
        }
    } catch (IOException e) {
        throw new IntegrationException("Cannot merge " + n.name(), e);
    }
    return mergeTip;
}
#method_after
public CodeReviewCommit mergeOneCommit(PersonIdent author, PersonIdent committer, Repository repo, CodeReviewRevWalk rw, ObjectInserter inserter, Branch.NameKey destBranch, CodeReviewCommit mergeTip, CodeReviewCommit n) throws IntegrationException {
    final ThreeWayMerger m = newThreeWayMerger(repo, inserter);
    try {
        if (m.merge(new AnyObjectId[] { mergeTip, n })) {
            return writeMergeCommit(author, committer, rw, inserter, destBranch, mergeTip, m.getResultTreeId(), n);
        }
        failed(rw, mergeTip, n, CommitMergeStatus.PATH_CONFLICT);
    } catch (NoMergeBaseException e) {
        try {
            failed(rw, mergeTip, n, getCommitMergeStatus(e.getReason()));
        } catch (IOException e2) {
            throw new IntegrationException("Cannot merge " + n.name(), e);
        }
    } catch (IOException e) {
        throw new IntegrationException("Cannot merge " + n.name(), e);
    }
    return mergeTip;
}
#end_block

#method_before
public static String mergeStrategyName(boolean useContentMerge, boolean useRecursiveMerge) {
    if (useContentMerge) {
        // new recursive merger, and instruct to operate in core.
        if (useRecursiveMerge) {
            return MergeStrategy.RECURSIVE.getName();
        } else {
            return MergeStrategy.RESOLVE.getName();
        }
    } else {
        // affected files was modified, merge will fail.
        return MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.getName();
    }
}
#method_after
public static String mergeStrategyName(boolean useContentMerge, boolean useRecursiveMerge) {
    if (useContentMerge) {
        // new recursive merger, and instruct to operate in core.
        if (useRecursiveMerge) {
            return MergeStrategy.RECURSIVE.getName();
        }
        return MergeStrategy.RESOLVE.getName();
    }
    // affected files was modified, merge will fail.
    return MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.getName();
}
#end_block

#method_before
public static ThreeWayMerger newThreeWayMerger(Repository repo, final ObjectInserter inserter, String strategyName) {
    MergeStrategy strategy = MergeStrategy.get(strategyName);
    checkArgument(strategy != null, "invalid merge strategy: %s", strategyName);
    Merger m = strategy.newMerger(repo, true);
    checkArgument(m instanceof ThreeWayMerger, "merge strategy %s does not support three-way merging", strategyName);
    m.setObjectInserter(new ObjectInserter.Filter() {

        @Override
        protected ObjectInserter delegate() {
            return inserter;
        }

        @Override
        public void flush() {
        }

        @Override
        public void close() {
        }
    });
    return (ThreeWayMerger) m;
}
#method_after
public static ThreeWayMerger newThreeWayMerger(Repository repo, final ObjectInserter inserter, String strategyName) {
    Merger m = newMerger(repo, inserter, strategyName);
    checkArgument(m instanceof ThreeWayMerger, "merge strategy %s does not support three-way merging", strategyName);
    return (ThreeWayMerger) m;
}
#end_block

#method_before
@Override
public Response<ChangeInfo> apply(TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("draft workflow is disabled");
        }
    }
    String refName = RefNames.fullName(input.branch);
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    try (Repository git = gitManager.openRepository(project);
        RevWalk rw = new RevWalk(git)) {
        ObjectId parentCommit;
        List<String> groups;
        if (input.baseChange != null) {
            List<ChangeControl> ctls = changeFinder.find(input.baseChange, rsrc.getControl().getUser());
            if (ctls.size() != 1) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            ChangeControl ctl = Iterables.getOnlyElement(ctls);
            if (!ctl.isVisible(db.get())) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), ctl.getNotes());
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else {
            Ref destRef = git.getRefDatabase().exactRef(refName);
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", refName));
                } else {
                    parentCommit = destRef.getObjectId();
                }
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        AccountState account = accountCache.get(me.getAccountId());
        GeneralPreferencesInfo info = account.getAccount().getGeneralPreferencesInfo();
        try (ObjectInserter oi = git.newObjectInserter()) {
            ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
            ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, input.subject);
            String commitMessage = ChangeIdUtil.insertId(input.subject, id);
            if (Boolean.TRUE.equals(info.signedOffBy)) {
                commitMessage += String.format("%s%s", SIGNED_OFF_BY_TAG, account.getAccount().getNameEmail(anonymousCowardName));
            }
            RevCommit c;
            if (!Strings.isNullOrEmpty(input.merge)) {
                // create a merge commit
                try {
                    RevCommit sourceCommit = resolveCommitFromString(input.merge, git, rw);
                    MergeUtil mergeUtil = mergeUtilFactory.create(rsrc.getControl().getProjectState());
                    c = mergeUtil.createMergeCommit(git, oi, mergeTip, sourceCommit, author, commitMessage, rw);
                } catch (MergeIdenticalTreeException e) {
                    throw new UpdateException("merge failed: " + e.getMessage());
                }
            } else {
                // create an empty commit
                c = newCommit(oi, rw, author, mergeTip, commitMessage);
            }
            Change.Id changeId = new Change.Id(seq.nextChangeId());
            ChangeInserter ins = changeInserterFactory.create(changeId, c, refName).setValidatePolicy(CommitValidators.Policy.GERRIT);
            ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
            String topic = input.topic;
            if (topic != null) {
                topic = Strings.emptyToNull(topic.trim());
            }
            ins.setTopic(topic);
            ins.setDraft(input.status != null && input.status == ChangeStatus.DRAFT);
            ins.setGroups(groups);
            try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
                bu.setRepository(git, rw, oi);
                bu.insertChange(ins);
                bu.execute();
            }
            ChangeJson json = jsonFactory.create(ChangeJson.NO_OPTIONS);
            return Response.created(json.format(ins.getChange()));
        }
    }
}
#method_after
@Override
public Response<ChangeInfo> apply(TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("draft workflow is disabled");
        }
    }
    String refName = RefNames.fullName(input.branch);
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        RevWalk rw = new RevWalk(oi.newReader())) {
        ObjectId parentCommit;
        List<String> groups;
        if (input.baseChange != null) {
            List<ChangeControl> ctls = changeFinder.find(input.baseChange, rsrc.getControl().getUser());
            if (ctls.size() != 1) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            ChangeControl ctl = Iterables.getOnlyElement(ctls);
            if (!ctl.isVisible(db.get())) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), ctl.getNotes());
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else {
            Ref destRef = git.getRefDatabase().exactRef(refName);
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", refName));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        AccountState account = accountCache.get(me.getAccountId());
        GeneralPreferencesInfo info = account.getAccount().getGeneralPreferencesInfo();
        ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
        ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, input.subject);
        String commitMessage = ChangeIdUtil.insertId(input.subject, id);
        if (Boolean.TRUE.equals(info.signedOffBy)) {
            commitMessage += String.format("%s%s", SIGNED_OFF_BY_TAG, account.getAccount().getNameEmail(anonymousCowardName));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            c = newMergeCommit(git, oi, rw, rsrc.getControl(), mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, refName).setValidatePolicy(CommitValidators.Policy.GERRIT);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        String topic = input.topic;
        if (topic != null) {
            topic = Strings.emptyToNull(topic.trim());
        }
        ins.setTopic(topic);
        ins.setDraft(input.status == ChangeStatus.DRAFT);
        ins.setGroups(groups);
        try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.create(ChangeJson.NO_OPTIONS);
        return Response.created(json.format(ins.getChange()));
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(GitModules.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(GitModules.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
public void addRefSpec(String spec) {
    refSpecs.add(new RefSpec(spec));
}
#method_after
public void addRefSpec(RefSpec spec) {
    refSpecs.add(spec);
}
#end_block

#method_before
public Collection<RefSpec> getRefSpecs() {
    return refSpecs;
}
#method_after
public Collection<RefSpec> getRefSpecs() {
    return Collections.unmodifiableCollection(refSpecs);
}
#end_block

#method_before
public Collection<SubscribeSection> getSubscribeSections(Branch.NameKey branch) {
    Collection<SubscribeSection> ret = Collections.emptyList();
    for (SubscribeSection s : subscribeSections.values()) {
        if (s.appliesTo(branch)) {
            ret.add(s);
        }
    }
    return ret;
}
#method_after
public Collection<SubscribeSection> getSubscribeSections(Branch.NameKey branch) {
    Collection<SubscribeSection> ret = new ArrayList<>();
    for (SubscribeSection s : subscribeSections.values()) {
        if (s.appliesTo(branch)) {
            ret.add(s);
        }
    }
    return ret;
}
#end_block

#method_before
private void loadSubscribeSections(Config rc) {
    Set<String> subsections = rc.getSubsections(SUBSCRIBE_SECTION);
    subscribeSections = new HashMap<>();
    for (String projectName : subsections) {
        Project.NameKey p = new Project.NameKey(projectName);
        SubscribeSection ss = new SubscribeSection(p);
        for (String s : rc.getStringList(SUBSCRIBE_SECTION, projectName, SUBSCRIBE_REFS)) {
            ss.addRefSpec(s);
        }
        subscribeSections.put(p, ss);
    }
}
#method_after
private void loadSubscribeSections(Config rc) throws ConfigInvalidException {
    Set<String> subsections = rc.getSubsections(SUBSCRIBE_SECTION);
    subscribeSections = new HashMap<>();
    try {
        for (String projectName : subsections) {
            Project.NameKey p = new Project.NameKey(projectName);
            SubscribeSection ss = new SubscribeSection(p);
            for (String s : rc.getStringList(SUBSCRIBE_SECTION, projectName, SUBSCRIBE_REFS)) {
                ss.addRefSpec(s);
            }
            subscribeSections.put(p, ss);
        }
    } catch (IllegalArgumentException e) {
        throw new ConfigInvalidException(e.getMessage());
    }
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.getUseContributorAgreements(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.getUseSignedOffBy(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.getRequireChangeID(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, p.getCreateNewChangeForAllNotInTarget(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, validMaxObjectSizeLimit(p.getMaxObjectSizeLimit()));
    set(rc, RECEIVE, null, KEY_ENABLE_SIGNED_PUSH, p.getEnableSignedPush(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_PUSH, p.getRequireSignedPush(), InheritableBoolean.INHERIT);
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.getUseContentMerge(), InheritableBoolean.INHERIT);
    set(rc, PROJECT, null, KEY_STATE, p.getState(), defaultStateValue);
    set(rc, DASHBOARD, null, KEY_DEFAULT, p.getDefaultDashboard());
    set(rc, DASHBOARD, null, KEY_LOCAL_DEFAULT, p.getLocalDefaultDashboard());
    Set<AccountGroup.UUID> keepGroups = new HashSet<>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    savePluginSections(rc, keepGroups);
    groupList.retainUUIDs(keepGroups);
    saveLabelSections(rc);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
    return true;
}
#method_after
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.getUseContributorAgreements(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.getUseSignedOffBy(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.getRequireChangeID(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, p.getCreateNewChangeForAllNotInTarget(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, validMaxObjectSizeLimit(p.getMaxObjectSizeLimit()));
    set(rc, RECEIVE, null, KEY_ENABLE_SIGNED_PUSH, p.getEnableSignedPush(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_PUSH, p.getRequireSignedPush(), InheritableBoolean.INHERIT);
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.getUseContentMerge(), InheritableBoolean.INHERIT);
    set(rc, PROJECT, null, KEY_STATE, p.getState(), defaultStateValue);
    set(rc, DASHBOARD, null, KEY_DEFAULT, p.getDefaultDashboard());
    set(rc, DASHBOARD, null, KEY_LOCAL_DEFAULT, p.getLocalDefaultDashboard());
    Set<AccountGroup.UUID> keepGroups = new HashSet<>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    savePluginSections(rc, keepGroups);
    groupList.retainUUIDs(keepGroups);
    saveLabelSections(rc);
    saveSubscribeSections(rc);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
    return true;
}
#end_block

#method_before
private void saveLabelSections(Config rc) {
    List<String> existing = Lists.newArrayList(rc.getSubsections(LABEL));
    if (!Lists.newArrayList(labelSections.keySet()).equals(existing)) {
        // Order of sections changed, remove and rewrite them all.
        for (String name : existing) {
            rc.unsetSection(LABEL, name);
        }
    }
    Set<String> toUnset = Sets.newHashSet(existing);
    for (Map.Entry<String, LabelType> e : labelSections.entrySet()) {
        String name = e.getKey();
        LabelType label = e.getValue();
        toUnset.remove(name);
        rc.setString(LABEL, name, KEY_FUNCTION, label.getFunctionName());
        rc.setInt(LABEL, name, KEY_DEFAULT_VALUE, label.getDefaultValue());
        setBooleanConfigKey(rc, name, KEY_COPY_MIN_SCORE, label.isCopyMinScore(), LabelType.DEF_COPY_MIN_SCORE);
        setBooleanConfigKey(rc, name, KEY_COPY_MAX_SCORE, label.isCopyMaxScore(), LabelType.DEF_COPY_MAX_SCORE);
        setBooleanConfigKey(rc, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE, label.isCopyAllScoresOnTrivialRebase(), LabelType.DEF_COPY_ALL_SCORES_ON_TRIVIAL_REBASE);
        setBooleanConfigKey(rc, name, KEY_COPY_ALL_SCORES_IF_NO_CODE_CHANGE, label.isCopyAllScoresIfNoCodeChange(), LabelType.DEF_COPY_ALL_SCORES_IF_NO_CODE_CHANGE);
        setBooleanConfigKey(rc, name, KEY_COPY_ALL_SCORES_IF_NO_CHANGE, label.isCopyAllScoresIfNoChange(), LabelType.DEF_COPY_ALL_SCORES_IF_NO_CHANGE);
        setBooleanConfigKey(rc, name, KEY_CAN_OVERRIDE, label.canOverride(), LabelType.DEF_CAN_OVERRIDE);
        List<String> values = Lists.newArrayListWithCapacity(label.getValues().size());
        for (LabelValue value : label.getValues()) {
            values.add(value.format());
        }
        rc.setStringList(LABEL, name, KEY_VALUE, values);
    }
    for (String name : toUnset) {
        rc.unsetSection(LABEL, name);
    }
}
#method_after
private void saveLabelSections(Config rc) {
    List<String> existing = Lists.newArrayList(rc.getSubsections(LABEL));
    if (!Lists.newArrayList(labelSections.keySet()).equals(existing)) {
        // Order of sections changed, remove and rewrite them all.
        for (String name : existing) {
            rc.unsetSection(LABEL, name);
        }
    }
    Set<String> toUnset = Sets.newHashSet(existing);
    for (Map.Entry<String, LabelType> e : labelSections.entrySet()) {
        String name = e.getKey();
        LabelType label = e.getValue();
        toUnset.remove(name);
        rc.setString(LABEL, name, KEY_FUNCTION, label.getFunctionName());
        rc.setInt(LABEL, name, KEY_DEFAULT_VALUE, label.getDefaultValue());
        setBooleanConfigKey(rc, name, KEY_COPY_MIN_SCORE, label.isCopyMinScore(), LabelType.DEF_COPY_MIN_SCORE);
        setBooleanConfigKey(rc, name, KEY_COPY_MAX_SCORE, label.isCopyMaxScore(), LabelType.DEF_COPY_MAX_SCORE);
        setBooleanConfigKey(rc, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE, label.isCopyAllScoresOnTrivialRebase(), LabelType.DEF_COPY_ALL_SCORES_ON_TRIVIAL_REBASE);
        setBooleanConfigKey(rc, name, KEY_COPY_ALL_SCORES_IF_NO_CODE_CHANGE, label.isCopyAllScoresIfNoCodeChange(), LabelType.DEF_COPY_ALL_SCORES_IF_NO_CODE_CHANGE);
        setBooleanConfigKey(rc, name, KEY_COPY_ALL_SCORES_IF_NO_CHANGE, label.isCopyAllScoresIfNoChange(), LabelType.DEF_COPY_ALL_SCORES_IF_NO_CHANGE);
        setBooleanConfigKey(rc, name, KEY_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE, label.isCopyAllScoresOnMergeFirstParentUpdate(), LabelType.DEF_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE);
        setBooleanConfigKey(rc, name, KEY_CAN_OVERRIDE, label.canOverride(), LabelType.DEF_CAN_OVERRIDE);
        List<String> values = Lists.newArrayListWithCapacity(label.getValues().size());
        for (LabelValue value : label.getValues()) {
            values.add(value.format());
        }
        rc.setStringList(LABEL, name, KEY_VALUE, values);
    }
    for (String name : toUnset) {
        rc.unsetSection(LABEL, name);
    }
}
#end_block

#method_before
void load() throws SubmoduleException {
    try (Repository repo = repoManager.openRepository(branch.getParentKey());
        RevWalk rw = new RevWalk(repo)) {
        ObjectId id = repo.resolve(branch.get());
        if (id == null) {
            throw new IOException("Cannot open branch " + branch.get());
        }
        RevCommit commit = rw.parseCommit(id);
        TreeWalk tw = TreeWalk.forPath(repo, GIT_MODULES, commit.getTree());
        if (tw != null && (FileMode.REGULAR_FILE.equals(tw.getRawMode(0)) || FileMode.EXECUTABLE_FILE.equals(tw.getRawMode(0)))) {
            BlobBasedConfig bbc = new BlobBasedConfig(null, repo, commit, GIT_MODULES);
            String thisServer = new URI(urlProvider.get()).getHost();
            subscriptions = subSecParserFactory.create(bbc, thisServer, branch).parseAllSections();
        }
    } catch (ConfigInvalidException | IOException e) {
        logAndThrowSubmoduleException("Could not read .gitmodule file of super project: " + branch.getParentKey(), e);
    } catch (URISyntaxException e) {
        logAndThrowSubmoduleException("Incorrect Gerrit canonical web url " + "provided in gerrit.config file.", e);
    }
}
#method_after
void load() throws SubmoduleException {
    Project.NameKey project = branch.getParentKey();
    logDebug("Loading .gitmodules of {} for project {}", branch, project);
    try (Repository repo = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(repo)) {
        ObjectId id = repo.resolve(branch.get());
        if (id == null) {
            throw new IOException("Cannot open branch " + branch.get());
        }
        RevCommit commit = rw.parseCommit(id);
        TreeWalk tw = TreeWalk.forPath(repo, GIT_MODULES, commit.getTree());
        if (tw == null || (tw.getRawMode(0) & FileMode.TYPE_MASK) != FileMode.TYPE_FILE) {
            return;
        }
        BlobBasedConfig bbc = new BlobBasedConfig(null, repo, commit, GIT_MODULES);
        subscriptions = subSecParserFactory.create(bbc, thisServer, branch).parseAllSections();
    } catch (ConfigInvalidException | IOException e) {
        throw new SubmoduleException("Could not read .gitmodule file of super project: " + branch.getParentKey(), e);
    }
}
#end_block

#method_before
public Collection<SubmoduleSubscription> subscribedTo(Branch.NameKey src) {
    Collection<SubmoduleSubscription> ret = Collections.emptyList();
    for (SubmoduleSubscription s : subscriptions) {
        if (s.getSubmodule().equals(src)) {
            ret.add(s);
        }
    }
    return ret;
}
#method_after
public Collection<SubmoduleSubscription> subscribedTo(Branch.NameKey src) {
    logDebug("Checking for a subscription of " + src);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    for (SubmoduleSubscription s : subscriptions) {
        if (s.getSubmodule().equals(src)) {
            logDebug("Found " + s);
            ret.add(s);
        }
    }
    return ret;
}
#end_block

#method_before
public Collection<Branch.NameKey> getDestinationBranches(Branch.NameKey src, SubscribeSection s) throws IOException {
    Collection<Branch.NameKey> ret = Collections.emptyList();
    for (RefSpec r : s.getRefSpecs()) {
        if (r.matchSource(src.get())) {
            if (r.getDestination() == null) {
                // no need to care for wildcard, as we matched already
                try (Repository repo = repoManager.openRepository(s.getProject())) {
                    for (Ref ref : repo.getAllRefs().values()) {
                        ret.add(new Branch.NameKey(s.getProject(), ref.getName()));
                    }
                }
            } else {
                if (r.isWildcard()) {
                    // refs/heads/*:refs/heads/*
                    ret.add(new Branch.NameKey(s.getProject(), r.expandFromSource(src.get()).getDestination()));
                } else {
                    // e.g. refs/heads/master:refs/heads/stable
                    ret.add(new Branch.NameKey(s.getProject(), r.getDestination()));
                }
            }
        }
    }
    return ret;
}
#method_after
public Collection<Branch.NameKey> getDestinationBranches(Branch.NameKey src, SubscribeSection s) throws IOException {
    Collection<Branch.NameKey> ret = new ArrayList<>();
    logDebug("Inspecting SubscribeSection " + s);
    for (RefSpec r : s.getRefSpecs()) {
        logDebug("Inspecting ref " + r);
        if (r.matchSource(src.get())) {
            if (r.getDestination() == null) {
                // no need to care for wildcard, as we matched already
                try (Repository repo = repoManager.openRepository(s.getProject())) {
                    for (Ref ref : repo.getRefDatabase().getRefs(RefNames.REFS_HEADS).values()) {
                        ret.add(new Branch.NameKey(s.getProject(), ref.getName()));
                    }
                }
            } else if (r.isWildcard()) {
                // refs/heads/*:refs/heads/*
                ret.add(new Branch.NameKey(s.getProject(), r.expandFromSource(src.get()).getDestination()));
            } else {
                // e.g. refs/heads/master:refs/heads/stable
                ret.add(new Branch.NameKey(s.getProject(), r.getDestination()));
            }
        }
    }
    logDebug("Returning possible branches: " + ret + "for project " + s.getProject());
    return ret;
}
#end_block

#method_before
private Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(Branch.NameKey branch) throws SubmoduleException {
    Collection<SubmoduleSubscription> ret = Collections.emptyList();
    try (Repository repo = repoManager.openRepository(branch.getParentKey())) {
        ProjectConfig cfg = new ProjectConfig(branch.getParentKey());
        cfg.load(repo);
        for (SubscribeSection s : cfg.getSubscribeSections(branch)) {
            Collection<Branch.NameKey> branches = getDestinationBranches(branch, s);
            for (Branch.NameKey targetBranch : branches) {
                GitModules m = gitmodulesFactory.create(targetBranch);
                m.load();
                ret.addAll(m.subscribedTo(branch));
            }
        }
    } catch (IOException e) {
        logAndThrowSubmoduleException("Could not update superproject", e);
    } catch (ConfigInvalidException e) {
        logAndThrowSubmoduleException("Error in project.config in " + "refs/meta/config of project" + branch.getParentKey(), e);
    }
    return ret;
}
#method_after
private Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(Branch.NameKey branch) throws SubmoduleException {
    logDebug("Calculating possible superprojects for " + branch);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    Project.NameKey project = branch.getParentKey();
    ProjectConfig cfg = projectCache.get(project).getConfig();
    try {
        for (SubscribeSection s : cfg.getSubscribeSections(branch)) {
            Collection<Branch.NameKey> branches = getDestinationBranches(branch, s);
            for (Branch.NameKey targetBranch : branches) {
                GitModules m = gitmodulesFactory.create(targetBranch, updateId);
                m.load();
                ret.addAll(m.subscribedTo(branch));
            }
        }
    } catch (IOException e) {
        throw new SubmoduleException("Could not update superproject", e);
    }
    logDebug("Calculated superprojects for " + branch + " are " + ret);
    return ret;
}
#end_block

#method_before
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches) throws SubmoduleException {
    if (!enableSuperProjectSubscriptions) {
        return;
    }
    // These (repo/branch) will be updated later with all the given
    // individual submodule subscriptions
    Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
    for (Branch.NameKey updatedBranch : updatedBranches) {
        for (SubmoduleSubscription sub : superProjectSubscriptionsForSubmoduleBranch(updatedBranch)) {
            targets.put(sub.getSuperProject(), sub);
        }
    }
    updatedSubscribers.addAll(updatedBranches);
    // Update subscribers.
    for (Branch.NameKey dest : targets.keySet()) {
        try {
            if (!updatedSubscribers.add(dest)) {
                log.error("Possible circular subscription involving " + dest);
            } else {
                updateGitlinks(db, dest, targets.get(dest));
            }
        } catch (SubmoduleException e) {
            log.warn("Cannot update gitlinks for " + dest, e);
        }
    }
}
#method_after
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches, String updateId) throws SubmoduleException {
    if (!enableSuperProjectSubscriptions) {
        logDebug("Updating superprojects disabled");
        return;
    }
    this.updateId = updateId;
    logDebug("Updating superprojects");
    // These (repo/branch) will be updated later with all the given
    // individual submodule subscriptions
    Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
    for (Branch.NameKey updatedBranch : updatedBranches) {
        for (SubmoduleSubscription sub : superProjectSubscriptionsForSubmoduleBranch(updatedBranch)) {
            targets.put(sub.getSuperProject(), sub);
        }
    }
    updatedSubscribers.addAll(updatedBranches);
    // Update subscribers.
    for (Branch.NameKey dest : targets.keySet()) {
        try {
            if (!updatedSubscribers.add(dest)) {
                log.error("Possible circular subscription involving " + dest);
            } else {
                updateGitlinks(db, dest, targets.get(dest));
            }
        } catch (SubmoduleException e) {
            log.warn("Cannot update gitlinks for " + dest, e);
        }
    }
}
#end_block

#method_before
private void updateGitlinks(ReviewDb db, Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try (Repository pdb = repoManager.openRepository(subscriber.getParentKey())) {
        if (pdb.exactRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(pdb, pdb.exactRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try (Repository subrepo = repoManager.openRepository(s.getSubmodule().getParentKey());
                RevWalk rw = CodeReviewCommit.newRevWalk(subrepo)) {
                Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
                if (ref == null) {
                    ed.add(new DeletePath(s.getPath()));
                    continue;
                }
                final ObjectId updateTo = ref.getObjectId();
                RevCommit newCommit = rw.parseCommit(updateTo);
                if (author == null) {
                    author = newCommit.getAuthorIdent();
                } else if (!author.equals(newCommit.getAuthorIdent())) {
                    sameAuthorForAll = false;
                }
                DirCacheEntry dce = dc.getEntry(s.getPath());
                ObjectId oldId;
                if (dce != null) {
                    if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                        log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                        continue;
                    }
                    oldId = dce.getObjectId();
                } else {
                    // This submodule did not exist before. We do not want to add
                    // the full submodule history to the commit message, so omit it.
                    oldId = updateTo;
                }
                ed.add(new PathEdit(s.getPath()) {

                    @Override
                    public void apply(DirCacheEntry ent) {
                        ent.setFileMode(FileMode.GITLINK);
                        ent.setObjectId(updateTo);
                    }
                });
                if (verboseSuperProject) {
                    msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                    msgbuf.append(" " + s.getSubmodule().getShortName());
                    msgbuf.append(" " + updateTo.getName());
                    msgbuf.append("\n\n");
                    try {
                        rw.markStart(newCommit);
                        rw.markUninteresting(rw.parseCommit(oldId));
                        for (RevCommit c : rw) {
                            msgbuf.append(c.getFullMessage() + "\n\n");
                        }
                    } catch (IOException e) {
                        logAndThrowSubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                    }
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = pdb.exactRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            case FORCED:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new IOException(rfu.getResult().name());
        }
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(db, Sets.newHashSet(subscriber));
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#method_after
private void updateGitlinks(ReviewDb db, Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try (Repository pdb = repoManager.openRepository(subscriber.getParentKey())) {
        if (pdb.exactRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(pdb, pdb.exactRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try (Repository subrepo = repoManager.openRepository(s.getSubmodule().getParentKey());
                RevWalk rw = CodeReviewCommit.newRevWalk(subrepo)) {
                Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
                if (ref == null) {
                    ed.add(new DeletePath(s.getPath()));
                    continue;
                }
                final ObjectId updateTo = ref.getObjectId();
                RevCommit newCommit = rw.parseCommit(updateTo);
                if (author == null) {
                    author = newCommit.getAuthorIdent();
                } else if (!author.equals(newCommit.getAuthorIdent())) {
                    sameAuthorForAll = false;
                }
                DirCacheEntry dce = dc.getEntry(s.getPath());
                ObjectId oldId;
                if (dce != null) {
                    if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                        log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                        continue;
                    }
                    oldId = dce.getObjectId();
                } else {
                    // This submodule did not exist before. We do not want to add
                    // the full submodule history to the commit message, so omit it.
                    oldId = updateTo;
                }
                ed.add(new PathEdit(s.getPath()) {

                    @Override
                    public void apply(DirCacheEntry ent) {
                        ent.setFileMode(FileMode.GITLINK);
                        ent.setObjectId(updateTo);
                    }
                });
                if (verboseSuperProject) {
                    msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                    msgbuf.append(" " + s.getSubmodule().getShortName());
                    msgbuf.append(" " + updateTo.getName());
                    msgbuf.append("\n\n");
                    try {
                        rw.markStart(newCommit);
                        rw.markUninteresting(rw.parseCommit(oldId));
                        for (RevCommit c : rw) {
                            msgbuf.append(c.getFullMessage() + "\n\n");
                        }
                    } catch (IOException e) {
                        throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                    }
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = pdb.exactRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            case FORCED:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new IOException(rfu.getResult().name());
        }
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(db, Sets.newHashSet(subscriber), updateId);
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#end_block

#method_before
protected void allowSubmoduleSubscription(String submodule, String subBranch, String superproject, String superBranch) throws Exception {
    Project.NameKey sub = new Project.NameKey(name(submodule));
    grant(Permission.SUBMIT, sub, "refs/for/refs/meta/config");
    grant(Permission.PUSH, sub, "refs/for/refs/meta/config");
    TestRepository<?> repo = cloneProject(project);
    repo.git().fetch().setRemote("origin").setRefSpecs(new RefSpec("refs/meta/config:refs/meta/config")).call();
    repo.reset("refs/meta/config");
    RevCommit rev = repo.commit(// 
    repo.tree(repo.file("project.config", repo.blob(// 
    "" + "[subscribe \"" + name(superproject) + // 
    "\"]\n" + "  refs = " + subBranch + ":" + superBranch + // 
    "\n"))));
    repo.branch("refs/meta/config").update(rev);
    repo.git().push().setRemote("origin").setRefSpecs(new RefSpec("refs/meta/config:refs/meta/config")).call();
}
#method_after
protected void allowSubmoduleSubscription(String submodule, String subBranch, String superproject, String superBranch) throws Exception {
    Project.NameKey sub = new Project.NameKey(name(submodule));
    Project.NameKey superName = new Project.NameKey(name(superproject));
    try (MetaDataUpdate md = metaDataUpdateFactory.create(sub)) {
        md.setMessage("Added superproject subscription");
        ProjectConfig pc = ProjectConfig.read(md);
        SubscribeSection s = new SubscribeSection(superName);
        if (superBranch == null) {
            s.addRefSpec(subBranch);
        } else {
            s.addRefSpec(subBranch + ":" + superBranch);
        }
        pc.addSubscribeSection(s);
        ObjectId oldId = pc.getRevision();
        ObjectId newId = pc.commit(md);
        assertThat(newId).isNotEqualTo(oldId);
        projectCache.evict(pc.getProject());
    }
}
#end_block

#method_before
@Test
public void testSubscriptionToEmptyRepo() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEAD);
}
#method_after
@Test
public void testSubscriptionToEmptyRepo() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    pushChangeTo(subRepo, "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEAD);
}
#end_block

#method_before
@Test
public void testSubscriptionToExistingRepo() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEAD);
}
#method_after
@Test
public void testSubscriptionToExistingRepo() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEAD);
}
#end_block

#method_before
@Test
@GerritConfig(name = "submodule.verboseSuperprojectUpdate", value = "false")
public void testSubmoduleShortCommitMessage() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    // The first update doesn't include any commit messages
    ObjectId subRepoId = pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subRepoId);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n");
    // Any following update also has a short message
    subRepoId = pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subRepoId);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n");
}
#method_after
@Test
@GerritConfig(name = "submodule.verboseSuperprojectUpdate", value = "false")
public void testSubmoduleShortCommitMessage() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    // The first update doesn't include any commit messages
    ObjectId subRepoId = pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subRepoId);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n");
    // Any following update also has a short message
    subRepoId = pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subRepoId);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n");
}
#end_block

#method_before
@Test
public void testSubmoduleCommitMessage() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    // The first update doesn't include the rev log
    RevWalk rw = subRepo.getRevWalk();
    RevCommit subCommitMsg = rw.parseCommit(subHEAD);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "Project: " + name("subscribed-to-project") + " master " + subHEAD.name() + "\n\n");
    // The next commit should generate only its commit message,
    // omitting previous commit logs
    subHEAD = pushChangeTo(subRepo, "master");
    subCommitMsg = rw.parseCommit(subHEAD);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "Project: " + name("subscribed-to-project") + " master " + subHEAD.name() + "\n\n" + subCommitMsg.getFullMessage() + "\n\n");
}
#method_after
@Test
public void testSubmoduleCommitMessage() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    // The first update doesn't include the rev log
    RevWalk rw = subRepo.getRevWalk();
    RevCommit subCommitMsg = rw.parseCommit(subHEAD);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "Project: " + name("subscribed-to-project") + " master " + subHEAD.name() + "\n\n");
    // The next commit should generate only its commit message,
    // omitting previous commit logs
    subHEAD = pushChangeTo(subRepo, "master");
    subCommitMsg = rw.parseCommit(subHEAD);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "Project: " + name("subscribed-to-project") + " master " + subHEAD.name() + "\n\n" + subCommitMsg.getFullMessage() + "\n\n");
}
#end_block

#method_before
@Test
public void testSubscriptionUnsubscribe() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    pushChangeTo(subRepo, "master");
    ObjectId subHEADbeforeUnsubscribing = pushChangeTo(subRepo, "master");
    deleteAllSubscriptions(superRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEADbeforeUnsubscribing);
    pushChangeTo(superRepo, "refs/heads/master", "commit after unsubscribe", "");
    pushChangeTo(subRepo, "refs/heads/master", "commit after unsubscribe", "");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEADbeforeUnsubscribing);
}
#method_after
@Test
public void testSubscriptionUnsubscribe() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    pushChangeTo(subRepo, "master");
    ObjectId subHEADbeforeUnsubscribing = pushChangeTo(subRepo, "master");
    deleteAllSubscriptions(superRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEADbeforeUnsubscribing);
    pushChangeTo(superRepo, "refs/heads/master", "commit after unsubscribe", "");
    pushChangeTo(subRepo, "refs/heads/master", "commit after unsubscribe", "");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEADbeforeUnsubscribing);
}
#end_block

#method_before
@Test
public void testSubscriptionUnsubscribeByDeletingGitModules() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    pushChangeTo(subRepo, "master");
    ObjectId subHEADbeforeUnsubscribing = pushChangeTo(subRepo, "master");
    deleteGitModulesFile(superRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEADbeforeUnsubscribing);
    pushChangeTo(superRepo, "refs/heads/master", "commit after unsubscribe", "");
    pushChangeTo(subRepo, "refs/heads/master", "commit after unsubscribe", "");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEADbeforeUnsubscribing);
}
#method_after
@Test
public void testSubscriptionUnsubscribeByDeletingGitModules() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    pushChangeTo(subRepo, "master");
    ObjectId subHEADbeforeUnsubscribing = pushChangeTo(subRepo, "master");
    deleteGitModulesFile(superRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEADbeforeUnsubscribing);
    pushChangeTo(superRepo, "refs/heads/master", "commit after unsubscribe", "");
    pushChangeTo(subRepo, "refs/heads/master", "commit after unsubscribe", "");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEADbeforeUnsubscribing);
}
#end_block

#method_before
@Test
public void testSubscriptionToDifferentBranches() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "foo");
    ObjectId subFoo = pushChangeTo(subRepo, "foo");
    pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subFoo);
}
#method_after
@Test
public void testSubscriptionToDifferentBranches() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/foo", "super-project", "refs/heads/master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "foo");
    ObjectId subFoo = pushChangeTo(subRepo, "foo");
    pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subFoo);
}
#end_block

#method_before
@Test
public void testCircularSubscriptionIsDetected() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("super-project", "master", "subscribed-to-project", "master");
    allowSubmoduleSubscription("subscribed-to-project", "master", "super-project", "master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    createSubmoduleSubscription(subRepo, "master", "super-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    pushChangeTo(superRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEAD);
    assertThat(hasSubmodule(subRepo, "master", "super-project")).isFalse();
}
#method_after
@Test
public void testCircularSubscriptionIsDetected() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    allowSubmoduleSubscription("super-project", "refs/heads/master", "subscribed-to-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    createSubmoduleSubscription(subRepo, "master", "super-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    pushChangeTo(superRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEAD);
    assertThat(hasSubmodule(subRepo, "master", "super-project")).isFalse();
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = Sets.newHashSet();
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), c.getRefName()));
                        break;
                    case DELETE:
                        ResultSet<SubmoduleSubscription> submoduleSubscriptions = null;
                        Branch.NameKey projRef = new Branch.NameKey(project.getNameKey(), c.getRefName());
                        try {
                            submoduleSubscriptions = db.submoduleSubscriptions().bySuperProject(projRef);
                            db.submoduleSubscriptions().delete(submoduleSubscriptions);
                        } catch (OrmException e) {
                            log.error("Cannot delete submodule subscription(s) of branch " + projRef + ": " + submoduleSubscriptions, e);
                        }
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c);
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    SubmoduleOp op = subOpProvider.get();
    try {
        op.updateSuperProjects(db, branches);
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = Sets.newHashSet();
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), c.getRefName()));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c);
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    SubmoduleOp op = subOpProvider.get();
    try {
        op.updateSuperProjects(db, branches, "receiveID");
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    checkNotNull(magicBranch);
    recipients.add(magicBranch.getMailRecipients());
    approvals = magicBranch.labels;
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(psId.get(), null, approvals, Collections.<String, PatchSetApproval>emptyMap());
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch.submit) {
        submit(projectControl.controlFor(state.db, change), ins.getPatchSet());
    }
}
#method_after
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    checkNotNull(magicBranch);
    recipients.add(magicBranch.getMailRecipients());
    approvals = magicBranch.labels;
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(psId.get(), null, approvals, Collections.<String, PatchSetApproval>emptyMap());
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch.submit) {
        submit(projectControl.controlFor(state.db, change), ins.getPatchSet());
    }
}
#end_block

#method_before
private void markChangeMergedByPush(ReviewDb db, final PatchSetInfo info, final String mergedIntoRef) throws UpdateException, RestApiException {
    try (BatchUpdate bu = batchUpdateFactory.create(db, project.getNameKey(), user, TimeUtil.nowTs())) {
        bu.addOp(info.getKey().getParentKey(), new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws OrmException {
                Change change = ctx.getChange();
                ChangeUpdate update = ctx.getUpdate(info.getKey());
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(info);
                    change.setStatus(Change.Status.MERGED);
                    ctx.saveChange();
                    // we cannot reconstruct the submit records for when this change was
                    // submitted, this is why we must fix the status
                    update.fixStatus(Change.Status.MERGED);
                }
                StringBuilder msgBuf = new StringBuilder();
                msgBuf.append("Change has been successfully pushed");
                if (!mergedIntoRef.equals(change.getDest().get())) {
                    msgBuf.append(" into ");
                    if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                        msgBuf.append("branch ");
                        msgBuf.append(Repository.shortenRefName(mergedIntoRef));
                    } else {
                        msgBuf.append(mergedIntoRef);
                    }
                }
                msgBuf.append(".");
                ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), info.getKey());
                msg.setMessage(msgBuf.toString());
                cmUtil.addChangeMessage(ctx.getDb(), update, msg);
                return true;
            }
        });
        bu.execute();
    }
}
#method_after
private void markChangeMergedByPush(ReviewDb db, final PatchSetInfo info, final String mergedIntoRef) throws UpdateException, RestApiException {
    try (BatchUpdate bu = batchUpdateFactory.create(db, project.getNameKey(), user, TimeUtil.nowTs())) {
        bu.addOp(info.getKey().getParentKey(), new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws OrmException {
                Change change = ctx.getChange();
                ChangeUpdate update = ctx.getUpdate(info.getKey());
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(info);
                    change.setStatus(Change.Status.MERGED);
                    ctx.saveChange();
                    // we cannot reconstruct the submit records for when this change was
                    // submitted, this is why we must fix the status
                    update.fixStatus(Change.Status.MERGED);
                }
                StringBuilder msgBuf = new StringBuilder();
                msgBuf.append("Change has been successfully pushed");
                if (!mergedIntoRef.equals(change.getDest().get())) {
                    msgBuf.append(" into ");
                    if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                        msgBuf.append("branch ");
                        msgBuf.append(Repository.shortenRefName(mergedIntoRef));
                    } else {
                        msgBuf.append(mergedIntoRef);
                    }
                }
                msgBuf.append(".");
                ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), info.getKey());
                msg.setMessage(msgBuf.toString());
                cmUtil.addChangeMessage(ctx.getDb(), update, msg);
                PatchSetApproval submitter = new PatchSetApproval(new PatchSetApproval.Key(change.currentPatchSetId(), ctx.getUser().getAccountId(), LabelId.legacySubmit()), (short) 1, ctx.getWhen());
                update.putApproval(submitter.getLabel(), submitter.getValue());
                ctx.getDb().patchSetApprovals().upsert(Collections.singleton(submitter));
                return true;
            }
        });
        bu.execute();
    }
}
#end_block

#method_before
private void updateSuperProjects(SubmoduleOp subOp, Collection<Branch.NameKey> branches) {
    logDebug("Updating superprojects");
    try {
        subOp.updateSuperProjects(db, branches);
    } catch (SubmoduleException e) {
        logError("The gitlinks were not updated according to the " + "subscriptions", e);
    }
}
#method_after
private void updateSuperProjects(SubmoduleOp subOp, Collection<Branch.NameKey> branches) {
    logDebug("Updating superprojects");
    try {
        subOp.updateSuperProjects(db, branches, submissionId);
        logDebug("Updating superprojects done");
    } catch (SubmoduleException e) {
        logError("The gitlinks were not updated according to the " + "subscriptions", e);
    }
}
#end_block

#method_before
private void abandonAllOpenChangeForDeletedProject(Project.NameKey destProject) {
    try {
        for (ChangeData cd : internalChangeQuery.byProjectOpen(destProject)) {
            try (BatchUpdate bu = batchUpdateFactory.create(db, destProject, internalUserFactory.create(), TimeUtil.nowTs())) {
                bu.addOp(cd.getId(), new BatchUpdate.Op() {

                    @Override
                    public boolean updateChange(ChangeContext ctx) throws OrmException {
                        Change change = ctx.getChange();
                        if (!change.getStatus().isOpen()) {
                            return false;
                        }
                        change.setStatus(Change.Status.ABANDONED);
                        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), null, change.getLastUpdatedOn(), change.currentPatchSetId());
                        msg.setMessage("Project was deleted.");
                        cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(change.currentPatchSetId()), msg);
                        ctx.saveChange();
                        return true;
                    }
                });
                try {
                    bu.execute();
                } catch (UpdateException | RestApiException e) {
                    logWarn("Cannot abandon changes for deleted project " + destProject, e);
                }
            }
        }
    } catch (OrmException e) {
        logWarn("Cannot abandon changes for deleted project " + destProject, e);
    }
}
#method_after
private void abandonAllOpenChangeForDeletedProject(Project.NameKey destProject) {
    try {
        for (ChangeData cd : internalChangeQuery.byProjectOpen(destProject)) {
            try (BatchUpdate bu = batchUpdateFactory.create(db, destProject, internalUserFactory.create(), ts)) {
                bu.addOp(cd.getId(), new BatchUpdate.Op() {

                    @Override
                    public boolean updateChange(ChangeContext ctx) throws OrmException {
                        Change change = ctx.getChange();
                        if (!change.getStatus().isOpen()) {
                            return false;
                        }
                        change.setStatus(Change.Status.ABANDONED);
                        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), null, change.getLastUpdatedOn(), change.currentPatchSetId());
                        msg.setMessage("Project was deleted.");
                        cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(change.currentPatchSetId()), msg);
                        ctx.saveChange();
                        return true;
                    }
                });
                try {
                    bu.execute();
                } catch (UpdateException | RestApiException e) {
                    logWarn("Cannot abandon changes for deleted project " + destProject, e);
                }
            }
        }
    } catch (OrmException e) {
        logWarn("Cannot abandon changes for deleted project " + destProject, e);
    }
}
#end_block

#method_before
@Override
public List<SubmitStrategyOp> buildOps(Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge);
    List<SubmitStrategyOp> ops = new ArrayList<>(sorted.size());
    CodeReviewCommit firstFastForward;
    if (args.mergeTip.getInitialTip() == null) {
        if (!sorted.isEmpty()) {
            firstFastForward = sorted.remove(0);
        } else {
            throw new IntegrationException("nothing to merge!");
        }
    } else {
        firstFastForward = args.mergeUtil.getFirstFastForward(args.mergeTip.getInitialTip(), args.rw, sorted);
    }
    if (!firstFastForward.equals(args.mergeTip.getInitialTip())) {
        ops.add(new FastForwardOp(args, firstFastForward));
    }
    // For every other commit do a pair-wise merge.
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        ops.add(new MergeOneOp(args, n));
    }
    return ops;
}
#method_after
@Override
public List<SubmitStrategyOp> buildOps(Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge);
    List<SubmitStrategyOp> ops = new ArrayList<>(sorted.size());
    CodeReviewCommit firstFastForward;
    if (args.mergeTip.getInitialTip() == null) {
        if (sorted.isEmpty()) {
            throw new IntegrationException("nothing to merge");
        }
        firstFastForward = sorted.remove(0);
    } else {
        firstFastForward = args.mergeUtil.getFirstFastForward(args.mergeTip.getInitialTip(), args.rw, sorted);
    }
    if (!firstFastForward.equals(args.mergeTip.getInitialTip())) {
        ops.add(new FastForwardOp(args, firstFastForward));
    }
    // For every other commit do a pair-wise merge.
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        ops.add(new MergeOneOp(args, n));
    }
    return ops;
}
#end_block

#method_before
private PluginConfigInfo getPluginInfo() {
    PluginConfigInfo info = new PluginConfigInfo();
    info.hasAvatars = toBoolean(avatar.get() != null);
    info.jsResourcePaths = Lists.newArrayList();
    for (WebUiPlugin u : plugins) {
        info.jsResourcePaths.add(String.format("plugins/%s/%s", u.getPluginName(), u.getJavaScriptResourcePath()));
    }
    return info;
}
#method_after
private PluginConfigInfo getPluginInfo() {
    PluginConfigInfo info = new PluginConfigInfo();
    info.hasAvatars = toBoolean(avatar.get() != null);
    info.jsResourcePaths = new ArrayList<>();
    for (WebUiPlugin u : plugins) {
        info.jsResourcePaths.add(String.format("plugins/%s/%s", u.getPluginName(), u.getJavaScriptResourcePath()));
    }
    return info;
}
#end_block

#method_before
@Test
public void testSubscriptionWithoutServerSetting() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    pushChangeTo(subRepo, "master");
    assertThat(hasSubmodule(superRepo, "master", "subscribed-to-project")).isFalse();
}
#method_after
@Test
@GerritConfig(name = "submodule.enableSuperProjectSubscriptions", value = "false")
public void testSubscriptionWithoutServerSetting() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    pushChangeTo(subRepo, "master");
    assertThat(hasSubmodule(superRepo, "master", "subscribed-to-project")).isFalse();
}
#end_block

#method_before
@Test
@GerritConfig(name = "submodule.enableSuperProjectSubscriptions", value = "true")
public void testSubscriptionToEmptyRepo() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEAD);
}
#method_after
@Test
public void testSubscriptionToEmptyRepo() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEAD);
}
#end_block

#method_before
@Test
@GerritConfig(name = "submodule.enableSuperProjectSubscriptions", value = "true")
public void testSubscriptionToExistingRepo() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEAD);
}
#method_after
@Test
public void testSubscriptionToExistingRepo() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEAD);
}
#end_block

#method_before
@Test
@GerritConfigs({ @GerritConfig(name = "submodule.verboseSuperprojectUpdate", value = "false"), @GerritConfig(name = "submodule.enableSuperProjectSubscriptions", value = "true") })
public void testSubmoduleShortCommitMessage() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    // The first update doesn't include any commit messages
    ObjectId subRepoId = pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subRepoId);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n");
    // Any following update also has a short message
    subRepoId = pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subRepoId);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n");
}
#method_after
@Test
@GerritConfig(name = "submodule.verboseSuperprojectUpdate", value = "false")
public void testSubmoduleShortCommitMessage() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    // The first update doesn't include any commit messages
    ObjectId subRepoId = pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subRepoId);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n");
    // Any following update also has a short message
    subRepoId = pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subRepoId);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n");
}
#end_block

#method_before
@Test
@GerritConfig(name = "submodule.enableSuperProjectSubscriptions", value = "true")
public void testSubmoduleCommitMessage() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    // The first update doesn't include the rev log
    RevWalk rw = subRepo.getRevWalk();
    RevCommit subCommitMsg = rw.parseCommit(subHEAD);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "Project: " + name("subscribed-to-project") + " master " + subHEAD.name() + "\n\n");
    // The next commit should generate only its commit message,
    // omitting previous commit logs
    subHEAD = pushChangeTo(subRepo, "master");
    subCommitMsg = rw.parseCommit(subHEAD);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "Project: " + name("subscribed-to-project") + " master " + subHEAD.name() + "\n\n" + subCommitMsg.getFullMessage() + "\n\n");
}
#method_after
@Test
public void testSubmoduleCommitMessage() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    // The first update doesn't include the rev log
    RevWalk rw = subRepo.getRevWalk();
    RevCommit subCommitMsg = rw.parseCommit(subHEAD);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "Project: " + name("subscribed-to-project") + " master " + subHEAD.name() + "\n\n");
    // The next commit should generate only its commit message,
    // omitting previous commit logs
    subHEAD = pushChangeTo(subRepo, "master");
    subCommitMsg = rw.parseCommit(subHEAD);
    expectToHaveCommitMessage(superRepo, "master", "Update git submodules\n\n" + "Project: " + name("subscribed-to-project") + " master " + subHEAD.name() + "\n\n" + subCommitMsg.getFullMessage() + "\n\n");
}
#end_block

#method_before
@Test
@GerritConfig(name = "submodule.enableSuperProjectSubscriptions", value = "true")
public void testSubscriptionUnsubscribe() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    pushChangeTo(subRepo, "master");
    ObjectId subHEADbeforeUnsubscribing = pushChangeTo(subRepo, "master");
    deleteAllSubscriptions(superRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEADbeforeUnsubscribing);
    pushChangeTo(superRepo, "refs/heads/master", "commit after unsubscribe", "");
    pushChangeTo(subRepo, "refs/heads/master", "commit after unsubscribe", "");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEADbeforeUnsubscribing);
}
#method_after
@Test
public void testSubscriptionUnsubscribe() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    pushChangeTo(subRepo, "master");
    ObjectId subHEADbeforeUnsubscribing = pushChangeTo(subRepo, "master");
    deleteAllSubscriptions(superRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEADbeforeUnsubscribing);
    pushChangeTo(superRepo, "refs/heads/master", "commit after unsubscribe", "");
    pushChangeTo(subRepo, "refs/heads/master", "commit after unsubscribe", "");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEADbeforeUnsubscribing);
}
#end_block

#method_before
@Test
@GerritConfig(name = "submodule.enableSuperProjectSubscriptions", value = "true")
public void testSubscriptionUnsubscribeByDeletingGitModules() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    pushChangeTo(subRepo, "master");
    ObjectId subHEADbeforeUnsubscribing = pushChangeTo(subRepo, "master");
    deleteGitModulesFile(superRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEADbeforeUnsubscribing);
    pushChangeTo(superRepo, "refs/heads/master", "commit after unsubscribe", "");
    pushChangeTo(subRepo, "refs/heads/master", "commit after unsubscribe", "");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEADbeforeUnsubscribing);
}
#method_after
@Test
public void testSubscriptionUnsubscribeByDeletingGitModules() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    pushChangeTo(subRepo, "master");
    ObjectId subHEADbeforeUnsubscribing = pushChangeTo(subRepo, "master");
    deleteGitModulesFile(superRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEADbeforeUnsubscribing);
    pushChangeTo(superRepo, "refs/heads/master", "commit after unsubscribe", "");
    pushChangeTo(subRepo, "refs/heads/master", "commit after unsubscribe", "");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEADbeforeUnsubscribing);
}
#end_block

#method_before
@Test
@GerritConfig(name = "submodule.enableSuperProjectSubscriptions", value = "true")
public void testSubscriptionToDifferentBranches() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "foo");
    ObjectId subFoo = pushChangeTo(subRepo, "foo");
    pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subFoo);
}
#method_after
@Test
public void testSubscriptionToDifferentBranches() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "foo");
    ObjectId subFoo = pushChangeTo(subRepo, "foo");
    pushChangeTo(subRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subFoo);
}
#end_block

#method_before
@Test
@GerritConfig(name = "submodule.enableSuperProjectSubscriptions", value = "true")
public void testCircularSubscriptionIsDetected() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    createSubmoduleSubscription(subRepo, "master", "super-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    pushChangeTo(superRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEAD);
    assertThat(hasSubmodule(subRepo, "master", "super-project")).isFalse();
}
#method_after
@Test
public void testCircularSubscriptionIsDetected() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    createSubmoduleSubscription(subRepo, "master", "super-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    pushChangeTo(superRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEAD);
    assertThat(hasSubmodule(subRepo, "master", "super-project")).isFalse();
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunUploadPack()) {
        throw new Failure(1, "fatal: upload-pack not permitted on this server");
    }
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeCache, repo, projectControl, db.get(), true));
    }
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    up.setPostUploadHook(new PostUploadHook() {

        @Override
        public void onPostUpload(PackStatistics stats) {
            String prefix = name("sshd", projectControl.getProject().getName(), "upload");
            MetricRegistry registry = metrics.getRegistry();
            registry.histogram(name(prefix, "timecounting")).update(stats.getTimeCounting());
            registry.histogram(name(prefix, "timecompressing")).update(stats.getTimeCompressing());
            registry.histogram(name(prefix, "bitmapindexmisses")).update(stats.getBitmapIndexMisses());
            registry.histogram(name(prefix, "timewriting")).update(stats.getTimeWriting());
            registry.histogram(name(prefix, "transferrate")).update((int) stats.getTransferRate());
            registry.meter(name(prefix, "upload-pack")).mark();
        }
    });
    List<PreUploadHook> allPreUploadHooks = Lists.newArrayList(preUploadHooks);
    allPreUploadHooks.add(uploadValidatorsFactory.create(project, repo, session.getRemoteAddressAsString()));
    up.setPreUploadHook(PreUploadHookChain.newChain(allPreUploadHooks));
    try {
        up.upload(in, out, err);
    } catch (UploadValidationException e) {
        // internal server error to the client.
        if (!e.isOutput()) {
            up.sendMessage(e.getMessage());
        }
    }
}
#method_after
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunUploadPack()) {
        throw new Failure(1, "fatal: upload-pack not permitted on this server");
    }
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeCache, repo, projectControl, db.get(), true));
    }
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    up.setPostUploadHook(uploadMetrics);
    List<PreUploadHook> allPreUploadHooks = Lists.newArrayList(preUploadHooks);
    allPreUploadHooks.add(uploadValidatorsFactory.create(project, repo, session.getRemoteAddressAsString()));
    up.setPreUploadHook(PreUploadHookChain.newChain(allPreUploadHooks));
    try {
        up.upload(in, out, err);
        session.setPeerAgent(up.getPeerUserAgent());
    } catch (UploadValidationException e) {
        // internal server error to the client.
        if (!e.isOutput()) {
            up.sendMessage(e.getMessage());
        }
    }
}
#end_block

#method_before
@Test
public void testSubscriptionUpdateOfManyChanges() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    createSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = subRepo.branch("HEAD").commit().insertChangeId().message("some change").add("a.txt", "a contents ").create();
    subRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    RevCommit c = subRepo.getRevWalk().parseCommit(subHEAD);
    RevCommit c1 = subRepo.branch("HEAD").commit().insertChangeId().message("first change").add("asdf", "asdf\n").parent(c).create();
    subRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/for/master/" + name("topic-foo"))).call();
    subRepo.reset(c.getId());
    RevCommit c2 = subRepo.branch("HEAD").commit().insertChangeId().message("qwerty").add("qwerty", "qwerty").parent(c).create();
    RevCommit c3 = subRepo.branch("HEAD").commit().insertChangeId().message("qwerty followup").add("qwerty", "qwerty\nqwerty\n").parent(c2).create();
    subRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/for/master/" + name("topic-foo"))).call();
    String id1 = getChangeId(subRepo, c1).get();
    String id2 = getChangeId(subRepo, c2).get();
    String id3 = getChangeId(subRepo, c3).get();
    gApi.changes().id(id1).current().review(ReviewInput.approve());
    gApi.changes().id(id2).current().review(ReviewInput.approve());
    gApi.changes().id(id3).current().review(ReviewInput.approve());
    gApi.changes().id(id1).current().submit();
    ObjectId subRepoId = subRepo.git().fetch().setRemote("origin").call().getAdvertisedRef("refs/heads/master").getObjectId();
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subRepoId);
}
#method_after
@Test
public void testSubscriptionUpdateOfManyChanges() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    createSubscription(superRepo, "master", "subscribed-to-project", "master");
    ObjectId subHEAD = subRepo.branch("HEAD").commit().insertChangeId().message("some change").add("a.txt", "a contents ").create();
    subRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/heads/master")).call();
    RevCommit c = subRepo.getRevWalk().parseCommit(subHEAD);
    RevCommit c1 = subRepo.branch("HEAD").commit().insertChangeId().message("first change").add("asdf", "asdf\n").create();
    subRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/for/master/" + name("topic-foo"))).call();
    subRepo.reset(c.getId());
    RevCommit c2 = subRepo.branch("HEAD").commit().insertChangeId().message("qwerty").add("qwerty", "qwerty").create();
    RevCommit c3 = subRepo.branch("HEAD").commit().insertChangeId().message("qwerty followup").add("qwerty", "qwerty\nqwerty\n").create();
    subRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/for/master/" + name("topic-foo"))).call();
    String id1 = getChangeId(subRepo, c1).get();
    String id2 = getChangeId(subRepo, c2).get();
    String id3 = getChangeId(subRepo, c3).get();
    gApi.changes().id(id1).current().review(ReviewInput.approve());
    gApi.changes().id(id2).current().review(ReviewInput.approve());
    gApi.changes().id(id3).current().review(ReviewInput.approve());
    gApi.changes().id(id1).current().submit();
    ObjectId subRepoId = subRepo.git().fetch().setRemote("origin").call().getAdvertisedRef("refs/heads/master").getObjectId();
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subRepoId);
}
#end_block

#method_before
@Test
public void testUpdateManySubmodules() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> sub1 = createProjectWithPush("sub1");
    TestRepository<?> sub2 = createProjectWithPush("sub2");
    TestRepository<?> sub3 = createProjectWithPush("sub3");
    Config config = new Config();
    addSubmoduleSubscription(config, "sub1", "master");
    addSubmoduleSubscription(config, "sub2", "master");
    addSubmoduleSubscription(config, "sub3", "master");
    pushSubscriptionConfig(superRepo, "master", config);
    ObjectId superPreviousId = pushChangeTo(superRepo, "master");
    ObjectId sub1Id = uploadChangeTo(sub1, "master");
    ObjectId sub2Id = uploadChangeTo(sub2, "master");
    ObjectId sub3Id = uploadChangeTo(sub3, "master");
    gApi.changes().id(getChangeId(sub1, sub1Id).get()).current().submit();
    expectToHaveSubmoduleState(superRepo, "master", "sub1", sub1Id);
    expectToHaveSubmoduleState(superRepo, "master", "sub2", sub2Id);
    expectToHaveSubmoduleState(superRepo, "master", "sub3", sub3Id);
    superRepo.git().fetch().setRemote("origin").call().getAdvertisedRef("refs/heads/master").getObjectId();
    // check we made just one commit:
    ObjectId newId = superRepo.getRepository().resolve("origin/master~1");
    assertThat(superPreviousId).isEqualTo(newId);
}
#method_after
@Test
public void testUpdateManySubmodules() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> sub1 = createProjectWithPush("sub1");
    TestRepository<?> sub2 = createProjectWithPush("sub2");
    TestRepository<?> sub3 = createProjectWithPush("sub3");
    Config config = new Config();
    prepareSubscriptionConfigEntry(config, "sub1", "master");
    prepareSubscriptionConfigEntry(config, "sub2", "master");
    prepareSubscriptionConfigEntry(config, "sub3", "master");
    pushSubscriptionConfig(superRepo, "master", config);
    ObjectId superPreviousId = pushChangeTo(superRepo, "master");
    ObjectId sub1Id = pushChangeTo(sub1, "refs/for/master", "some message", "same-topic");
    ObjectId sub2Id = pushChangeTo(sub2, "refs/for/master", "some message", "same-topic");
    ObjectId sub3Id = pushChangeTo(sub3, "refs/for/master", "some message", "same-topic");
    approve(getChangeId(sub1, sub1Id).get());
    approve(getChangeId(sub2, sub2Id).get());
    approve(getChangeId(sub3, sub3Id).get());
    gApi.changes().id(getChangeId(sub1, sub1Id).get()).current().submit();
    expectToHaveSubmoduleState(superRepo, "master", "sub1", sub1Id);
    expectToHaveSubmoduleState(superRepo, "master", "sub2", sub2Id);
    expectToHaveSubmoduleState(superRepo, "master", "sub3", sub3Id);
    superRepo.git().fetch().setRemote("origin").call().getAdvertisedRef("refs/heads/master").getObjectId();
    assertWithMessage("submodule subscription update " + "should have made one commit").that(superRepo.getRepository().resolve("origin/master^")).isEqualTo(superPreviousId);
}
#end_block

#method_before
public static void submit(int id, String commit, AsyncCallback<SubmitInfo> cb) {
    SubmitInput in = SubmitInput.create();
    in.waitForMerge(true);
    call(id, commit, "submit").post(in, cb);
}
#method_after
public static void submit(int id, String commit, AsyncCallback<SubmitInfo> cb) {
    JavaScriptObject in = JavaScriptObject.createObject();
    call(id, commit, "submit").post(in, cb);
}
#end_block

#method_before
@Override
public Response<BlameInfo> apply(FileResource resource) throws QueryParseException, OrmException, IOException, ResourceNotFoundException, AuthException, InvalidChangeOperationException, ResourceConflictException {
    Project.NameKey project = resource.getRevision().getChange().getProject();
    try (Repository repository = repoManager.openRepository(project)) {
        String refName = resource.getRevision().getEdit().isPresent() ? resource.getRevision().getEdit().get().getRefName() : resource.getRevision().getPatchSet().getRefName();
        Ref ref = repository.getRef(refName);
        if (ref == null) {
            throw new IllegalStateException("unknown ref " + refName);
        }
        ObjectId objectId = ref.getObjectId();
        RevWalk revWalk = new RevWalk(repository);
        RevCommit revCommit = revWalk.parseCommit(objectId);
        RevCommit[] parents = revCommit.getParents();
        String path = resource.getPatchKey().getFileName();
        String blameRef;
        if (base && parents.length == 1) {
            blameRef = parents[0].getName();
        } else {
            blameRef = revCommit.getName();
        }
        List<BlameInfo.BlameLine> commonBlames = blame(repository.resolve(blameRef), path, repository);
        final List<BlameInfo.BlameLine> blames;
        if (parents.length <= 1 || !base) {
            blames = commonBlames;
        } else if (parents.length == 2) {
            List<BlameInfo.BlameLine> localBlames = blame(parents[0].getId(), path, repository);
            List<BlameInfo.BlameLine> remoteBlames = blame(parents[1].getId(), path, repository);
            Response<DiffInfo> diffResponse = getDiff.apply(resource);
            DiffInfo diff = diffResponse.value();
            blames = blameMergeBase(diff, commonBlames, localBlames, remoteBlames);
        } else {
            throw new IllegalStateException("Cannot generate blame for merge commit" + " with more than 2 parents");
        }
        BlameInfo result = new BlameInfo();
        result.blames = packBlames(blames);
        for (BlameInfo.Blame blame : result.blames) {
            QueryResult queryResult = queryProcessor.queryChanges(qb.commit(blame.meta.id));
            for (ChangeData changeData : queryResult.changes()) {
                PatchSet.Id patchSetId = changeData.change().currentPatchSetId();
                if (patchSetId != null) {
                    blame.meta.changeId = changeData.change().getId().get();
                    blame.meta.patchSetId = patchSetId.get();
                }
            }
        }
        Response<BlameInfo> r = Response.ok(result);
        if (resource.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    } catch (GitAPIException e) {
        throw new ResourceNotFoundException(e.getMessage());
    }
}
#method_after
@Override
public Response<List<BlameInfo>> apply(FileResource resource) throws RestApiException, OrmException, IOException, InvalidChangeOperationException {
    if (!allowBlame) {
        throw new BadRequestException("blame is disabled");
    }
    Project.NameKey project = resource.getRevision().getChange().getProject();
    try (Repository repository = repoManager.openRepository(project);
        RevWalk revWalk = new RevWalk(repository)) {
        String refName = resource.getRevision().getEdit().isPresent() ? resource.getRevision().getEdit().get().getRefName() : resource.getRevision().getPatchSet().getRefName();
        Ref ref = repository.findRef(refName);
        if (ref == null) {
            throw new ResourceNotFoundException("unknown ref " + refName);
        }
        ObjectId objectId = ref.getObjectId();
        RevCommit revCommit = revWalk.parseCommit(objectId);
        RevCommit[] parents = revCommit.getParents();
        String path = resource.getPatchKey().getFileName();
        List<BlameInfo> result;
        if (!base) {
            result = blame(revCommit, path, repository, revWalk);
        } else if (parents.length == 0) {
            throw new ResourceNotFoundException("Initial commit doesn't have base");
        } else if (parents.length == 1) {
            result = blame(parents[0], path, repository, revWalk);
        } else if (parents.length == 2) {
            ObjectId automerge = autoMerger.merge(repository, revWalk, revCommit, mergeStrategy);
            result = blame(automerge, path, repository, revWalk);
        } else {
            throw new ResourceNotFoundException("Cannot generate blame for merge commit with more than 2 parents");
        }
        Response<List<BlameInfo>> r = Response.ok(result);
        if (resource.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    }
}
#end_block

#method_before
private static List<BlameInfo.BlameLine> blame(AnyObjectId id, String path, Repository repository) throws GitAPIException, QueryParseException, OrmException {
    BlameCommand blameCommand = new BlameCommand(repository);
    blameCommand.setFilePath(path);
    blameCommand.setStartCommit(id);
    BlameResult blameResult = blameCommand.call();
    List<BlameInfo.BlameLine> result = new ArrayList<>();
    int numLines = blameResult.getResultContents().size();
    for (int i = 1; i <= numLines; ++i) {
        RevCommit commit = blameResult.getSourceCommit(i - 1);
        BlameInfo.BlameMeta meta = new BlameInfo.BlameMeta();
        meta.author = commit.getAuthorIdent().getName();
        meta.id = commit.getId().getName();
        meta.commitMsg = commit.getFullMessage();
        meta.time = commit.getCommitTime();
        BlameInfo.BlameLine line = new BlameInfo.BlameLine();
        line.meta = meta;
        line.from = i;
        line.to = i;
        result.add(line);
    }
    return result;
}
#method_after
private List<BlameInfo> blame(ObjectId id, String path, Repository repository, RevWalk revWalk) throws IOException {
    ListMultimap<BlameInfo, RangeInfo> ranges = ArrayListMultimap.create();
    List<BlameInfo> result = new ArrayList<>();
    if (blameCache.findLastCommit(repository, id, path) == null) {
        return result;
    }
    List<Region> blameRegions = blameCache.get(repository, id, path);
    int from = 1;
    for (Region region : blameRegions) {
        RevCommit commit = revWalk.parseCommit(region.getSourceCommit());
        BlameInfo blameInfo = toBlameInfo(commit, region.getSourceAuthor());
        ranges.put(blameInfo, new RangeInfo(from, from + region.getCount() - 1));
        from += region.getCount();
    }
    for (BlameInfo key : ranges.keySet()) {
        key.ranges = ranges.get(key);
        result.add(key);
    }
    return result;
}
#end_block

#method_before
void setUpPatchSetNav(JsArray<RevisionInfo> list, DiffInfo.FileMeta meta, ClickHandler onBlame, boolean editExists, boolean current, boolean open, boolean binary) {
    InlineHyperlink baseLink = null;
    InlineHyperlink selectedLink = null;
    if (sideA) {
        baseLink = createLink(PatchUtil.C.patchBase(), null);
        linkPanel.add(baseLink);
    }
    for (int i = 0; i < list.length(); i++) {
        RevisionInfo r = list.get(i);
        InlineHyperlink link = createLink(r.id(), new PatchSet.Id(changeId, r._number()));
        linkPanel.add(link);
        if (revision != null && r.id().equals(revision.getId())) {
            selectedLink = link;
        }
    }
    if (selectedLink != null) {
        selectedLink.setStyleName(style.selected());
    } else if (sideA) {
        baseLink.setStyleName(style.selected());
    }
    if (meta == null) {
        return;
    }
    if (!Patch.COMMIT_MSG.equals(path)) {
        linkPanel.add(createDownloadLink());
    }
    if (!binary && open && idActive != null && Gerrit.isSignedIn()) {
        if ((editExists && idActive.get() == 0) || (!editExists && current)) {
            linkPanel.add(createEditIcon());
        }
    }
    if (!Patch.COMMIT_MSG.equals(path)) {
        linkPanel.add(createBlameIcon(onBlame));
    }
    List<WebLinkInfo> webLinks = Natives.asList(meta.webLinks());
    if (webLinks != null) {
        for (WebLinkInfo webLink : webLinks) {
            linkPanel.add(webLink.toAnchor());
        }
    }
}
#method_after
void setUpPatchSetNav(JsArray<RevisionInfo> list, DiffInfo.FileMeta meta, boolean editExists, boolean current, boolean open, boolean binary) {
    InlineHyperlink baseLink = null;
    InlineHyperlink selectedLink = null;
    if (sideA) {
        baseLink = createLink(PatchUtil.C.patchBase(), null);
        linkPanel.add(baseLink);
    }
    for (int i = 0; i < list.length(); i++) {
        RevisionInfo r = list.get(i);
        InlineHyperlink link = createLink(r.id(), new PatchSet.Id(changeId, r._number()));
        linkPanel.add(link);
        if (revision != null && r.id().equals(revision.getId())) {
            selectedLink = link;
        }
    }
    if (selectedLink != null) {
        selectedLink.setStyleName(style.selected());
    } else if (sideA) {
        baseLink.setStyleName(style.selected());
    }
    if (meta == null) {
        return;
    }
    if (!Patch.COMMIT_MSG.equals(path)) {
        linkPanel.add(createDownloadLink());
    }
    if (!binary && open && idActive != null && Gerrit.isSignedIn()) {
        if ((editExists && idActive.get() == 0) || (!editExists && current)) {
            linkPanel.add(createEditIcon());
        }
    }
    List<WebLinkInfo> webLinks = Natives.asList(meta.webLinks());
    if (webLinks != null) {
        for (WebLinkInfo webLink : webLinks) {
            linkPanel.add(webLink.toAnchor());
        }
    }
}
#end_block

#method_before
private Widget createBlameIcon(final ClickHandler onClick) {
    Anchor anchor = new Anchor(new ImageResourceRenderer().render(Gerrit.RESOURCES.blame()));
    anchor.setTitle(PatchUtil.C.blame());
    anchor.addClickHandler(onClick);
    return anchor;
}
#method_after
private Anchor createBlameIcon() {
    Anchor anchor = new Anchor(new ImageResourceRenderer().render(Gerrit.RESOURCES.blame()));
    anchor.setTitle(PatchUtil.C.blame());
    return anchor;
}
#end_block

#method_before
private InlineHyperlink createLink(String label, PatchSet.Id id) {
    assert other != null;
    if (sideA) {
        assert other.idActive != null;
    }
    return new InlineHyperlink(label, Dispatcher.toSideBySide(sideA ? id : other.idActive, sideA ? other.idActive : id, path));
}
#method_after
private InlineHyperlink createLink(String label, PatchSet.Id id) {
    assert other != null;
    if (sideA) {
        assert other.idActive != null;
    }
    PatchSet.Id diffBase = sideA ? id : other.idActive;
    PatchSet.Id revision = sideA ? other.idActive : id;
    return new InlineHyperlink(label, parent.isSideBySide() ? Dispatcher.toSideBySide(diffBase, revision, path) : Dispatcher.toUnified(diffBase, revision, path));
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetHashtagsOp.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetHashtagsOp.Factory.class);
}
#end_block

#method_before
void setHeaderVisible(boolean show) {
    if (show != UIObject.isVisible(patchSetNavRow)) {
        UIObject.setVisible(patchSetNavRow, show);
        UIObject.setVisible(diffHeaderRow, show && header);
        if (show) {
            parent.header.removeStyleName(style.fullscreen());
        } else {
            parent.header.addStyleName(style.fullscreen());
        }
        parent.resizeCodeMirror();
    }
}
#method_after
void setHeaderVisible(boolean show) {
    DiffScreen parent = getDiffScreen();
    if (show != UIObject.isVisible(patchSetNavRow)) {
        UIObject.setVisible(patchSetNavRow, show);
        UIObject.setVisible(diffHeaderRow, show && header);
        if (show) {
            parent.header.removeStyleName(Resources.I.diffTableStyle().fullscreen());
        } else {
            parent.header.addStyleName(Resources.I.diffTableStyle().fullscreen());
        }
        parent.resizeCodeMirror();
    }
}
#end_block

#method_before
void set(DiffPreferences prefs, JsArray<RevisionInfo> list, DiffInfo info, ClickHandler onBlameA, ClickHandler onBlameB, boolean editExists, boolean current, boolean open, boolean binary) {
    this.changeType = info.changeType();
    patchSetSelectBoxA.setUpPatchSetNav(list, info.metaA(), onBlameA, editExists, current, open, binary);
    patchSetSelectBoxB.setUpPatchSetNav(list, info.metaB(), onBlameB, editExists, current, open, binary);
    JsArrayString hdr = info.diffHeader();
    if (hdr != null) {
        StringBuilder b = new StringBuilder();
        for (int i = 1; i < hdr.length(); i++) {
            String s = hdr.get(i);
            if (s.startsWith("diff --git ") || s.startsWith("index ") || s.startsWith("+++ ") || s.startsWith("--- ")) {
                continue;
            }
            b.append(s).append('\n');
        }
        String hdrTxt = b.toString().trim();
        header = !hdrTxt.isEmpty();
        diffHeaderText.setInnerText(hdrTxt);
        UIObject.setVisible(diffHeaderRow, header);
    } else {
        header = false;
        UIObject.setVisible(diffHeaderRow, false);
    }
    setHideEmptyPane(prefs.hideEmptyPane());
}
#method_after
void set(DiffPreferences prefs, JsArray<RevisionInfo> list, DiffInfo info, boolean editExists, boolean current, boolean open, boolean binary) {
    this.changeType = info.changeType();
    patchSetSelectBoxA.setUpPatchSetNav(list, info.metaA(), editExists, current, open, binary);
    patchSetSelectBoxB.setUpPatchSetNav(list, info.metaB(), editExists, current, open, binary);
    JsArrayString hdr = info.diffHeader();
    if (hdr != null) {
        StringBuilder b = new StringBuilder();
        for (int i = 1; i < hdr.length(); i++) {
            String s = hdr.get(i);
            if (!info.binary() && (s.startsWith("diff --git ") || s.startsWith("index ") || s.startsWith("+++ ") || s.startsWith("--- "))) {
                continue;
            }
            b.append(s).append('\n');
        }
        String hdrTxt = b.toString().trim();
        header = !hdrTxt.isEmpty();
        diffHeaderText.setInnerText(hdrTxt);
        UIObject.setVisible(diffHeaderRow, header);
    } else {
        header = false;
        UIObject.setVisible(diffHeaderRow, false);
    }
    setHideEmptyPane(prefs.hideEmptyPane());
}
#end_block

#method_before
void refresh() {
    if (header) {
        CodeMirror cm = parent.getCmFromSide(DisplaySide.A);
        diffHeaderText.getStyle().setMarginLeft(cm.getGutterElement().getOffsetWidth(), Unit.PX);
    }
}
#method_after
void refresh() {
    if (header) {
        CodeMirror cm = getDiffScreen().getCmFromSide(DisplaySide.A);
        diffHeaderText.getStyle().setMarginLeft(cm.getGutterElement().getOffsetWidth(), Unit.PX);
    }
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    Window.enableScrolling(false);
    JumpKeys.enable(false);
    if (prefs.hideTopMenu()) {
        Gerrit.setHeaderVisible(false);
    }
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
        }
    });
    operation(new Runnable() {

        @Override
        public void run() {
            resizeCodeMirror();
            chunkManager.adjustPadding();
            cmA.refresh();
            cmB.refresh();
        }
    });
    setLineLength(Patch.COMMIT_MSG.equals(path) ? 72 : prefs.lineLength());
    diffTable.refresh();
    if (startLine == 0) {
        DiffChunkInfo d = chunkManager.getFirst();
        if (d != null) {
            if (d.isEdit() && d.getSide() == DisplaySide.A) {
                startSide = DisplaySide.B;
                startLine = lineOnOther(d.getSide(), d.getStart()).getLine() + 1;
            } else {
                startSide = d.getSide();
                startLine = d.getStart() + 1;
            }
        }
    }
    if (startSide != null && startLine > 0) {
        CodeMirror cm = getCmFromSide(startSide);
        cm.scrollToLine(startLine - 1);
        cm.focus();
    } else {
        cmA.setCursor(Pos.create(0));
        cmA.focus();
    }
    if (Gerrit.isSignedIn() && prefs.autoReview()) {
        header.autoReview();
    }
    prefetchNextFile();
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    operation(new Runnable() {

        @Override
        public void run() {
            resizeCodeMirror();
            chunkManager.adjustPadding();
            cmA.refresh();
            cmB.refresh();
        }
    });
    setLineLength(Patch.COMMIT_MSG.equals(path) ? 72 : prefs.lineLength());
    diffTable.refresh();
    if (getStartLine() == 0) {
        DiffChunkInfo d = chunkManager.getFirst();
        if (d != null) {
            if (d.edit && d.side == DisplaySide.A) {
                setStartSide(DisplaySide.B);
                setStartLine(lineOnOther(d.side, d.start).getLine() + 1);
            } else {
                setStartSide(d.side);
                setStartLine(d.start + 1);
            }
        }
    }
    if (getStartSide() != null && getStartLine() > 0) {
        CodeMirror cm = getCmFromSide(getStartSide());
        cm.scrollToLine(getStartLine() - 1);
        cm.focus();
    } else {
        cmA.setCursor(Pos.create(0));
        cmA.focus();
    }
    if (Gerrit.isSignedIn() && prefs.autoReview()) {
        header.autoReview();
    }
    prefetchNextFile();
}
#end_block

#method_before
private void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("focus", updateActiveLine(cm));
    KeyMap keyMap = KeyMap.create().on("A", upToChange(true)).on("U", upToChange(false)).on("[", header.navigate(Direction.PREV)).on("]", header.navigate(Direction.NEXT)).on("R", header.toggleReviewed()).on("O", commentManager.toggleOpenBox(cm)).on("Enter", commentManager.toggleOpenBox(cm)).on("N", maybeNextVimSearch(cm)).on("E", openEditScreen(cm)).on("P", chunkManager.diffChunkNav(cm, Direction.PREV)).on("Shift-A", diffTable.toggleA()).on("Shift-M", header.reviewedAndNext()).on("Shift-N", maybePrevVimSearch(cm)).on("Shift-P", commentManager.commentNav(cm, Direction.PREV)).on("Shift-O", commentManager.openCloseAll(cm)).on("Shift-Left", moveCursorToSide(cm, DisplaySide.A)).on("Shift-Right", moveCursorToSide(cm, DisplaySide.B)).on("I", new Runnable() {

        @Override
        public void run() {
            switch(getIntraLineStatus()) {
                case OFF:
                case OK:
                    toggleShowIntraline();
                    break;
                default:
                    break;
            }
        }
    }).on("','", new Runnable() {

        @Override
        public void run() {
            prefsAction.show();
        }
    }).on("Shift-/", new Runnable() {

        @Override
        public void run() {
            new ShowHelpCommand().onKeyPress(null);
        }
    }).on("Space", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("<C-d>");
        }
    }).on("Shift-Space", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("<C-u>");
        }
    }).on("Ctrl-F", new Runnable() {

        @Override
        public void run() {
            cm.vim().handleKey("/");
        }
    }).on("Ctrl-A", new Runnable() {

        @Override
        public void run() {
            cm.execCommand("selectAll");
        }
    });
    if (revision.get() != 0) {
        cm.on("beforeSelectionChange", onSelectionChange(cm));
        cm.on("gutterClick", onGutterClick(cm));
        keyMap.on("C", commentManager.insertNewDraft(cm));
    }
    cm.addKeyMap(keyMap);
    if (renderEntireFile()) {
        cm.addKeyMap(RENDER_ENTIRE_FILE_KEYMAP);
    }
}
#method_after
@Override
void registerCmEvents(final CodeMirror cm) {
    super.registerCmEvents(cm);
    KeyMap keyMap = KeyMap.create().on("Shift-A", diffTable.toggleA()).on("Shift-Left", moveCursorToSide(cm, DisplaySide.A)).on("Shift-Right", moveCursorToSide(cm, DisplaySide.B));
    cm.addKeyMap(keyMap);
    maybeRegisterRenderEntireFileKeyMap(cm);
}
#end_block

#method_before
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation.add(new UpToChangeCommand(revision, 0, 'u'));
    keysNavigation.add(new NoOpKeyCommand(KeyCommand.M_SHIFT, KeyCodes.KEY_LEFT, PatchUtil.C.focusSideA()), new NoOpKeyCommand(KeyCommand.M_SHIFT, KeyCodes.KEY_RIGHT, PatchUtil.C.focusSideB()));
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()), new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysNavigation.add(new NoOpKeyCommand(0, 'n', PatchUtil.C.chunkNext2()), new NoOpKeyCommand(0, 'p', PatchUtil.C.chunkPrev2()));
    keysNavigation.add(new NoOpKeyCommand(KeyCommand.M_SHIFT, 'n', PatchUtil.C.commentNext()), new NoOpKeyCommand(KeyCommand.M_SHIFT, 'p', PatchUtil.C.commentPrev()));
    keysNavigation.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 'f', Gerrit.C.keySearch()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, 'e', PatchUtil.C.openEditScreen()));
    keysAction.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysAction.add(new NoOpKeyCommand(KeyCommand.M_SHIFT, 'o', PatchUtil.C.expandAllCommentsOnCurrentLine()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new KeyCommand(0, 'r', PatchUtil.C.toggleReviewed()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                header.toggleReviewed().run();
            }
        });
    }
    keysAction.add(new KeyCommand(KeyCommand.M_SHIFT, 'm', PatchUtil.C.markAsReviewedAndGoToNext()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            header.reviewedAndNext().run();
        }
    });
    keysAction.add(new KeyCommand(0, 'a', PatchUtil.C.openReply()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            upToChange(true).run();
        }
    });
    keysAction.add(new KeyCommand(KeyCommand.M_SHIFT, 'a', PatchUtil.C.toggleSideA()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            diffTable.toggleA().run();
        }
    });
    keysAction.add(new KeyCommand(0, ',', PatchUtil.C.showPreferences()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            prefsAction.show();
        }
    });
    if (getIntraLineStatus() == DiffInfo.IntraLineStatus.OFF || getIntraLineStatus() == DiffInfo.IntraLineStatus.OK) {
        keysAction.add(new KeyCommand(0, 'i', PatchUtil.C.toggleIntraline()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                toggleShowIntraline();
            }
        });
    }
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
    removeKeyHandlerRegistrations();
    handlers.add(GlobalKey.add(this, keysAction));
    handlers.add(GlobalKey.add(this, keysNavigation));
    if (keysComment != null) {
        handlers.add(GlobalKey.add(this, keysComment));
    }
    handlers.add(ShowHelpCommand.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            cmB.focus();
        }
    }));
}
#method_after
@Override
public void registerKeys() {
    super.registerKeys();
    getKeysNavigation().add(new NoOpKeyCommand(KeyCommand.M_SHIFT, KeyCodes.KEY_LEFT, PatchUtil.C.focusSideA()), new NoOpKeyCommand(KeyCommand.M_SHIFT, KeyCodes.KEY_RIGHT, PatchUtil.C.focusSideB()));
    getKeysAction().add(new KeyCommand(KeyCommand.M_SHIFT, 'a', PatchUtil.C.toggleSideA()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            diffTable.toggleA().run();
        }
    });
    registerHandlers();
}
#end_block

#method_before
private void display(final CommentsCollections comments) {
    setThemeStyles(prefs.theme().isDark());
    setShowIntraline(prefs.intralineDifference());
    if (prefs.showLineNumbers()) {
        diffTable.addStyleName(DiffTable.style.showLineNumbers());
    }
    cmA = newCM(diff.metaA(), diff.textA(), diffTable.cmA);
    cmB = newCM(diff.metaB(), diff.textB(), diffTable.cmB);
    cmA.extras().side(DisplaySide.A);
    cmB.extras().side(DisplaySide.B);
    setShowTabs(prefs.showTabs());
    chunkManager = new ChunkManager(this, cmA, cmB, diffTable.scrollbar);
    skipManager = new SkipManager(this, commentManager);
    operation(new Runnable() {

        @Override
        public void run() {
            // Estimate initial CM3 height, fixed up in onShowView.
            int height = Window.getClientHeight() - (Gerrit.getHeaderFooterHeight() + 18);
            cmA.setHeight(height);
            cmB.setHeight(height);
            render(diff);
            commentManager.render(comments, prefs.expandAllComments());
            skipManager.render(prefs.context(), diff);
        }
    });
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    scrollSynchronizer = new ScrollSynchronizer(diffTable, cmA, cmB, chunkManager.getLineMapper());
    prefsAction = new PreferencesAction(this, prefs);
    header.init(prefsAction, getLinks(), diff.sideBySideWebLinks());
    scrollSynchronizer.setAutoHideDiffTableHeader(prefs.autoHideDiffTableHeader());
    if (prefs.syntaxHighlighting() && fileSize.compareTo(FileSize.SMALL) > 0) {
        Scheduler.get().scheduleFixedDelay(new RepeatingCommand() {

            @Override
            public boolean execute() {
                if (prefs.syntaxHighlighting() && isAttached()) {
                    setSyntaxHighlighting(prefs.syntaxHighlighting());
                }
                return false;
            }
        }, 250);
    }
}
#method_after
private void display(final CommentsCollections comments) {
    final DiffInfo diff = getDiff();
    setThemeStyles(prefs.theme().isDark());
    setShowIntraline(prefs.intralineDifference());
    if (prefs.showLineNumbers()) {
        diffTable.addStyleName(Resources.I.diffTableStyle().showLineNumbers());
    }
    cmA = newCm(diff.metaA(), diff.textA(), diffTable.cmA);
    cmB = newCm(diff.metaB(), diff.textB(), diffTable.cmB);
    boolean reviewingBase = base == null;
    getDiffTable().setUpBlameIconA(cmA, reviewingBase, reviewingBase ? revision : base, path);
    getDiffTable().setUpBlameIconB(cmB, revision, path);
    cmA.extras().side(DisplaySide.A);
    cmB.extras().side(DisplaySide.B);
    setShowTabs(prefs.showTabs());
    chunkManager = new SideBySideChunkManager(this, cmA, cmB, diffTable.scrollbar);
    operation(new Runnable() {

        @Override
        public void run() {
            // Estimate initial CodeMirror height, fixed up in onShowView.
            int height = Window.getClientHeight() - (Gerrit.getHeaderFooterHeight() + 18);
            cmA.setHeight(height);
            cmB.setHeight(height);
            render(diff);
            commentManager.render(comments, prefs.expandAllComments());
            skipManager.render(prefs.context(), diff);
        }
    });
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    scrollSynchronizer = new ScrollSynchronizer(diffTable, cmA, cmB, chunkManager.lineMapper);
    setPrefsAction(new PreferencesAction(this, prefs));
    header.init(getPrefsAction(), getUnifiedDiffLink(), diff.sideBySideWebLinks());
    scrollSynchronizer.setAutoHideDiffTableHeader(prefs.autoHideDiffTableHeader());
    setupSyntaxHighlighting();
}
#end_block

#method_before
void setShowLineNumbers(boolean b) {
    cmA.setOption("lineNumbers", b);
    cmB.setOption("lineNumbers", b);
    if (b) {
        diffTable.addStyleName(DiffTable.style.showLineNumbers());
    } else {
        diffTable.removeStyleName(DiffTable.style.showLineNumbers());
    }
}
#method_after
@Override
void setShowLineNumbers(boolean b) {
    super.setShowLineNumbers(b);
    cmA.setOption("lineNumbers", b);
    cmB.setOption("lineNumbers", b);
}
#end_block

#method_before
void setSyntaxHighlighting(boolean b) {
    if (b) {
        injectMode(diff, new AsyncCallback<Void>() {

            @Override
            public void onSuccess(Void result) {
                if (prefs.syntaxHighlighting()) {
                    cmA.setOption("mode", getContentType(diff.metaA()));
                    cmB.setOption("mode", getContentType(diff.metaB()));
                }
            }

            @Override
            public void onFailure(Throwable caught) {
                prefs.syntaxHighlighting(false);
            }
        });
    } else {
        cmA.setOption("mode", (String) null);
        cmB.setOption("mode", (String) null);
    }
}
#method_after
@Override
void setSyntaxHighlighting(boolean b) {
    final DiffInfo diff = getDiff();
    if (b) {
        injectMode(diff, new AsyncCallback<Void>() {

            @Override
            public void onSuccess(Void result) {
                if (prefs.syntaxHighlighting()) {
                    cmA.setOption("mode", getContentType(diff.metaA()));
                    cmB.setOption("mode", getContentType(diff.metaB()));
                }
            }

            @Override
            public void onFailure(Throwable caught) {
                prefs.syntaxHighlighting(false);
            }
        });
    } else {
        cmA.setOption("mode", (String) null);
        cmB.setOption("mode", (String) null);
    }
}
#end_block

#method_before
void setAutoHideDiffHeader(boolean hide) {
    scrollSynchronizer.setAutoHideDiffTableHeader(hide);
}
#method_after
@Override
void setAutoHideDiffHeader(boolean hide) {
    scrollSynchronizer.setAutoHideDiffTableHeader(hide);
}
#end_block

#method_before
CodeMirror getCmFromSide(DisplaySide side) {
    return side == DisplaySide.A ? cmA : cmB;
}
#method_after
@Override
CodeMirror getCmFromSide(DisplaySide side) {
    return side == DisplaySide.A ? cmA : cmB;
}
#end_block

#method_before
private Runnable updateActiveLine(final CodeMirror cm) {
    final CodeMirror other = otherCm(cm);
    return new Runnable() {

        @Override
        public void run() {
            // The rendering of active lines has to be deferred. Reflow
            // caused by adding and removing styles chokes Firefox when arrow
            // key (or j/k) is held down. Performance on Chrome is fine
            // without the deferral.
            // 
            Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                @Override
                public void execute() {
                    operation(new Runnable() {

                        @Override
                        public void run() {
                            LineHandle handle = cm.getLineHandleVisualStart(cm.getCursor("end").line());
                            if (!cm.extras().activeLine(handle)) {
                                return;
                            }
                            LineOnOtherInfo info = lineOnOther(cm.side(), cm.getLineNumber(handle));
                            if (info.isAligned()) {
                                other.extras().activeLine(other.getLineHandle(info.getLine()));
                            } else {
                                other.extras().clearActiveLine();
                            }
                        }
                    });
                }
            });
        }
    };
}
#method_after
@Override
Runnable updateActiveLine(final CodeMirror cm) {
    final CodeMirror other = otherCm(cm);
    return new Runnable() {

        @Override
        public void run() {
            // The rendering of active lines has to be deferred. Reflow
            // caused by adding and removing styles chokes Firefox when arrow
            // key (or j/k) is held down. Performance on Chrome is fine
            // without the deferral.
            // 
            Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                @Override
                public void execute() {
                    operation(new Runnable() {

                        @Override
                        public void run() {
                            LineHandle handle = cm.getLineHandleVisualStart(cm.getCursor("end").line());
                            if (!cm.extras().activeLine(handle)) {
                                return;
                            }
                            LineOnOtherInfo info = lineOnOther(cm.side(), cm.getLineNumber(handle));
                            if (info.isAligned()) {
                                other.extras().activeLine(other.getLineHandle(info.getLine()));
                            } else {
                                other.extras().clearActiveLine();
                            }
                        }
                    });
                }
            });
        }
    };
}
#end_block

#method_before
void operation(final Runnable apply) {
    cmA.operation(new Runnable() {

        @Override
        public void run() {
            cmB.operation(new Runnable() {

                @Override
                public void run() {
                    apply.run();
                }
            });
        }
    });
}
#method_after
@Override
void operation(final Runnable apply) {
    cmA.operation(new Runnable() {

        @Override
        public void run() {
            cmB.operation(new Runnable() {

                @Override
                public void run() {
                    apply.run();
                }
            });
        }
    });
}
#end_block

#method_before
ChunkManager getChunkManager() {
    return chunkManager;
}
#method_after
@Override
SideBySideChunkManager getChunkManager() {
    return chunkManager;
}
#end_block

#method_before
CommentManager getCommentManager() {
    return commentManager;
}
#method_after
@Override
SideBySideCommentManager getCommentManager() {
    return commentManager;
}
#end_block

#method_before
@Override
public Object apply(RemoteResource rsrc, Input input) throws RepositoryNotFoundException, IOException, ConfigInvalidException, AuthException {
    if (!permissions.canUpdate(rsrc.getProject())) {
        throw new AuthException("not allowed to update webhooks");
    }
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(rsrc.getProject())) {
        WebhooksConfig wh = webhooksConfig.get();
        wh.load(md);
        wh.deleteRemote(rsrc.getRemoteConfig().getName());
        wh.commit(md);
    }
    projectCache.evict(rsrc.getProject());
    return Response.none();
}
#method_after
@Override
public Object apply(RemoteResource rsrc, Input input) throws RepositoryNotFoundException, IOException, ConfigInvalidException, AuthException {
    if (!permissions.canUpdate(rsrc.getProject())) {
        throw new AuthException("not allowed to update webhooks");
    }
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(rsrc.getProject())) {
        WebhooksConfig whc = webhooksConfig.get();
        whc.load(md);
        whc.deleteRemote(rsrc.getRemoteConfig().getName());
        whc.commit(md);
    }
    projectCache.evict(rsrc.getProject());
    return Response.none();
}
#end_block

#method_before
@Test
public void oneCaller() throws Exception {
    int max = 20;
    for (int batchSize = 1; batchSize <= 10; batchSize++) {
        String name = "batch-size-" + batchSize;
        RepoSequence s = newSequence(name, 1, batchSize);
        for (int i = 1; i <= max; i++) {
            try {
                assertThat(s.next()).named("next for " + name).isEqualTo(i);
            } catch (Exception e) {
                throw new AssertionError("failed batchSize=" + batchSize + ", i=" + i, e);
            }
        }
        assertThat(s.acquireCount).named("acquireCount for " + name).isEqualTo(divCeil(max, batchSize));
    }
}
#method_after
@Test
public void oneCaller() throws Exception {
    int max = 20;
    for (int batchSize = 1; batchSize <= 10; batchSize++) {
        String name = "batch-size-" + batchSize;
        RepoSequence s = newSequence(name, 1, batchSize);
        for (int i = 1; i <= max; i++) {
            try {
                assertThat(s.next()).named("next for " + name).isEqualTo(i);
            } catch (OrmException e) {
                throw new AssertionError("failed batchSize=" + batchSize + ", i=" + i, e);
            }
        }
        assertThat(s.acquireCount).named("acquireCount for " + name).isEqualTo(divCeil(max, batchSize));
    }
}
#end_block

#method_before
@Test
public void twoCallers() throws Exception {
    RepoSequence s1 = newSequence("id", 1, 3);
    RepoSequence s2 = newSequence("id", 1, 3);
    // s1 acquires 1-3; s2 acquires 4-6.
    assertThat(s1.next()).isEqualTo(1);
    assertThat(s2.next()).isEqualTo(4);
    assertThat(s1.next()).isEqualTo(2);
    assertThat(s2.next()).isEqualTo(5);
    assertThat(s1.next()).isEqualTo(3);
    assertThat(s2.next()).isEqualTo(6);
    // s2 acquires 7-9; s3 acquires 10-12.
    assertThat(s2.next()).isEqualTo(7);
    assertThat(s1.next()).isEqualTo(10);
    assertThat(s2.next()).isEqualTo(8);
    assertThat(s1.next()).isEqualTo(11);
    assertThat(s2.next()).isEqualTo(9);
    assertThat(s1.next()).isEqualTo(12);
}
#method_after
@Test
public void twoCallers() throws Exception {
    RepoSequence s1 = newSequence("id", 1, 3);
    RepoSequence s2 = newSequence("id", 1, 3);
    // s1 acquires 1-3; s2 acquires 4-6.
    assertThat(s1.next()).isEqualTo(1);
    assertThat(s2.next()).isEqualTo(4);
    assertThat(s1.next()).isEqualTo(2);
    assertThat(s2.next()).isEqualTo(5);
    assertThat(s1.next()).isEqualTo(3);
    assertThat(s2.next()).isEqualTo(6);
    // s2 acquires 7-9; s1 acquires 10-12.
    assertThat(s2.next()).isEqualTo(7);
    assertThat(s1.next()).isEqualTo(10);
    assertThat(s2.next()).isEqualTo(8);
    assertThat(s1.next()).isEqualTo(11);
    assertThat(s2.next()).isEqualTo(9);
    assertThat(s1.next()).isEqualTo(12);
}
#end_block

#method_before
@Test
public void failOnInvalidValue() throws Exception {
    ObjectId id = writeBlob("id", "not a number");
    exception.expect(IOException.class);
    exception.expectMessage("invalid value in refs/sequences/id blob at " + id.name());
    newSequence("id", 1, 3).next();
}
#method_after
@Test
public void failOnInvalidValue() throws Exception {
    ObjectId id = writeBlob("id", "not a number");
    exception.expect(OrmException.class);
    exception.expectMessage("invalid value in refs/sequences/id blob at " + id.name());
    newSequence("id", 1, 3).next();
}
#end_block

#method_before
@Test
public void failOnWrongType() throws Exception {
    try (Repository repo = repoManager.openRepository(project)) {
        TestRepository<Repository> tr = new TestRepository<>(repo);
        tr.branch(REFS_SEQUENCES + "id").commit().create();
        exception.expect(IncorrectObjectTypeException.class);
        newSequence("id", 1, 3).next();
    }
}
#method_after
@Test
public void failOnWrongType() throws Exception {
    try (Repository repo = repoManager.openRepository(project)) {
        TestRepository<Repository> tr = new TestRepository<>(repo);
        tr.branch(RefNames.REFS_SEQUENCES + "id").commit().create();
        try {
            newSequence("id", 1, 3).next();
            fail();
        } catch (OrmException e) {
            assertThat(e.getCause()).isInstanceOf(ExecutionException.class);
            assertThat(e.getCause().getCause()).isInstanceOf(IncorrectObjectTypeException.class);
        }
    }
}
#end_block

#method_before
@Test
public void failAfterRetryerGivesUp() throws Exception {
    final AtomicInteger bgCounter = new AtomicInteger(1234);
    Runnable bgUpdate = new Runnable() {

        @Override
        public void run() {
            writeBlob("id", Integer.toString(bgCounter.getAndAdd(1000)));
        }
    };
    RepoSequence s = newSequence("id", 1, 10, bgUpdate, RetryerBuilder.<RefUpdate.Result>newBuilder().withStopStrategy(StopStrategies.stopAfterAttempt(3)).build());
    exception.expect(IOException.class);
    exception.expectMessage("failed to update refs/sequences/id: LOCK_FAILURE");
    s.next();
}
#method_after
@Test
public void failAfterRetryerGivesUp() throws Exception {
    final AtomicInteger bgCounter = new AtomicInteger(1234);
    Runnable bgUpdate = new Runnable() {

        @Override
        public void run() {
            writeBlob("id", Integer.toString(bgCounter.getAndAdd(1000)));
        }
    };
    RepoSequence s = newSequence("id", 1, 10, bgUpdate, RetryerBuilder.<RefUpdate.Result>newBuilder().withStopStrategy(StopStrategies.stopAfterAttempt(3)).build());
    exception.expect(OrmException.class);
    exception.expectMessage("failed to update refs/sequences/id: LOCK_FAILURE");
    s.next();
}
#end_block

#method_before
private ObjectId writeBlob(String sequenceName, String value) {
    String refName = REFS_SEQUENCES + sequenceName;
    try (Repository repo = repoManager.openRepository(project);
        ObjectInserter ins = repo.newObjectInserter()) {
        ObjectId newId = ins.insert(OBJ_BLOB, value.getBytes(UTF_8));
        ins.flush();
        RefUpdate ru = repo.updateRef(refName);
        ru.setNewObjectId(newId);
        assertThat(ru.forceUpdate()).isAnyOf(RefUpdate.Result.NEW, RefUpdate.Result.FORCED);
        return newId;
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
}
#method_after
private ObjectId writeBlob(String sequenceName, String value) {
    String refName = RefNames.REFS_SEQUENCES + sequenceName;
    try (Repository repo = repoManager.openRepository(project);
        ObjectInserter ins = repo.newObjectInserter()) {
        ObjectId newId = ins.insert(OBJ_BLOB, value.getBytes(UTF_8));
        ins.flush();
        RefUpdate ru = repo.updateRef(refName);
        ru.setNewObjectId(newId);
        assertThat(ru.forceUpdate()).isAnyOf(RefUpdate.Result.NEW, RefUpdate.Result.FORCED);
        return newId;
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
private String readBlob(String sequenceName) throws Exception {
    String refName = REFS_SEQUENCES + sequenceName;
    try (Repository repo = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(repo)) {
        ObjectId id = repo.exactRef(refName).getObjectId();
        return new String(rw.getObjectReader().open(id).getCachedBytes(), UTF_8);
    }
}
#method_after
private String readBlob(String sequenceName) throws Exception {
    String refName = RefNames.REFS_SEQUENCES + sequenceName;
    try (Repository repo = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(repo)) {
        ObjectId id = repo.exactRef(refName).getObjectId();
        return new String(rw.getObjectReader().open(id).getCachedBytes(), UTF_8);
    }
}
#end_block

#method_before
public int next() throws IOException {
    counterLock.lock();
    try {
        if (!initialized || counter >= limit) {
            acquire();
        }
        return counter++;
    } finally {
        counterLock.unlock();
    }
}
#method_after
public int next() throws OrmException {
    counterLock.lock();
    try {
        if (counter >= limit) {
            acquire();
        }
        return counter++;
    } finally {
        counterLock.unlock();
    }
}
#end_block

#method_before
private void acquire() throws IOException {
    try (Repository repo = repoManager.openRepository(projectName);
        RevWalk rw = new RevWalk(repo)) {
        TryAcquire attempt = new TryAcquire(repo, rw);
        RefUpdate.Result result = retryer.call(attempt);
        if (result != RefUpdate.Result.NEW && result != RefUpdate.Result.FORCED) {
            throw new IOException("failed to update " + refName + ": " + result);
        }
        counter = attempt.next;
        limit = counter + batchSize;
        initialized = true;
        acquireCount++;
    } catch (ExecutionException | RetryException e) {
        Throwables.propagateIfInstanceOf(e.getCause(), IOException.class);
        throw new IOException(e);
    }
}
#method_after
private void acquire() throws OrmException {
    try (Repository repo = repoManager.openRepository(projectName);
        RevWalk rw = new RevWalk(repo)) {
        TryAcquire attempt = new TryAcquire(repo, rw);
        RefUpdate.Result result = retryer.call(attempt);
        if (result != RefUpdate.Result.NEW && result != RefUpdate.Result.FORCED) {
            throw new OrmException("failed to update " + refName + ": " + result);
        }
        counter = attempt.next;
        limit = counter + batchSize;
        acquireCount++;
    } catch (ExecutionException | RetryException e) {
        Throwables.propagateIfInstanceOf(e.getCause(), OrmException.class);
        throw new OrmException(e);
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
@Override
public RefUpdate.Result call() throws Exception {
    Ref ref = repo.exactRef(refName);
    afterReadRef.run();
    ObjectId oldId;
    if (ref == null) {
        next = start;
        oldId = ObjectId.zeroId();
    } else {
        oldId = ref.getObjectId();
        next = parse(oldId);
    }
    return store(oldId, next + batchSize);
}
#method_after
@Override
public RefUpdate.Result call() throws Exception {
    Ref ref = repo.exactRef(refName);
    afterReadRef.run();
    ObjectId oldId;
    if (ref == null) {
        oldId = ObjectId.zeroId();
        next = start;
    } else {
        oldId = ref.getObjectId();
        next = parse(oldId);
    }
    return store(oldId, next + batchSize);
}
#end_block

#method_before
private int parse(ObjectId id) throws IOException {
    ObjectLoader ol = rw.getObjectReader().open(id, OBJ_BLOB);
    if (ol.getType() != OBJ_BLOB) {
        // may do it properly (certainly InMemoryRepository) doesn't.
        throw new IncorrectObjectTypeException(id, OBJ_BLOB);
    }
    String str = CharMatcher.WHITESPACE.trimFrom(new String(ol.getCachedBytes(), UTF_8));
    Integer val = Ints.tryParse(str);
    if (val == null) {
        throw new IOException("invalid value in " + refName + " blob at " + id.name());
    }
    return val;
}
#method_after
private int parse(ObjectId id) throws IOException, OrmException {
    ObjectLoader ol = rw.getObjectReader().open(id, OBJ_BLOB);
    if (ol.getType() != OBJ_BLOB) {
        // may do it properly (certainly InMemoryRepository doesn't).
        throw new IncorrectObjectTypeException(id, OBJ_BLOB);
    }
    String str = CharMatcher.WHITESPACE.trimFrom(new String(ol.getCachedBytes(), UTF_8));
    Integer val = Ints.tryParse(str);
    if (val == null) {
        throw new OrmException("invalid value in " + refName + " blob at " + id.name());
    }
    return val;
}
#end_block

#method_before
private RefUpdate.Result store(ObjectId oldId, int val) throws IOException {
    ObjectId newId;
    try (ObjectInserter ins = repo.newObjectInserter()) {
        newId = ins.insert(OBJ_BLOB, Integer.toString(val).getBytes());
        ins.flush();
    }
    RefUpdate ru = repo.updateRef(refName);
    ru.setExpectedOldObjectId(oldId);
    ru.setNewObjectId(newId);
    // Required for non-commitish updates.
    ru.setForceUpdate(true);
    return ru.update(rw);
}
#method_after
private RefUpdate.Result store(ObjectId oldId, int val) throws IOException {
    ObjectId newId;
    try (ObjectInserter ins = repo.newObjectInserter()) {
        newId = ins.insert(OBJ_BLOB, Integer.toString(val).getBytes(UTF_8));
        ins.flush();
    }
    RefUpdate ru = repo.updateRef(refName);
    ru.setExpectedOldObjectId(oldId);
    ru.setNewObjectId(newId);
    // Required for non-commitish updates.
    ru.setForceUpdate(true);
    return ru.update(rw);
}
#end_block

#method_before
public void addPermission(Permission p) {
    List<Permission> l = getPermissions();
    if (!l.contains(p)) {
        l.add(p);
    }
}
#method_after
public void addPermission(Permission permission) {
    List<Permission> permissions = getPermissions();
    for (Permission p : permissions) {
        if (p.getName().equalsIgnoreCase(permission.getName())) {
            throw new IllegalArgumentException();
        }
    }
    permissions.add(permission);
}
#end_block

#method_before
@Test
@UseSsh
public void sshKeys() throws Exception {
    // The test account should initially have exactly one ssh key
    List<SshKeyInfo> info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(1);
    assertSequenceNumbers(info);
    SshKeyInfo key = info.get(0);
    String inital = AccountCreator.publicKey(admin.sshKey, admin.email);
    assertThat(key.sshPublicKey).isEqualTo(inital);
    accountIndexedCounter.assertNoReindex();
    // Add a new key
    String newKey = AccountCreator.publicKey(AccountCreator.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertSequenceNumbers(info);
    accountIndexedCounter.assertReindexOf(admin);
    // Add an existing key (the request succeeds, but the key isn't added again)
    gApi.accounts().self().addSshKey(inital);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertSequenceNumbers(info);
    accountIndexedCounter.assertNoReindex();
    // Add another new key
    String newKey2 = AccountCreator.publicKey(AccountCreator.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey2);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(3);
    assertSequenceNumbers(info);
    accountIndexedCounter.assertReindexOf(admin);
    // Delete second key
    gApi.accounts().self().deleteSshKey(2);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertThat(info.get(0).seq).isEqualTo(1);
    assertThat(info.get(1).seq).isEqualTo(3);
    accountIndexedCounter.assertReindexOf(admin);
    // Mark first key as invalid
    assertThat(info.get(0).valid).isTrue();
    authorizedKeys.markKeyInvalid(admin.id, 1);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertThat(info.get(0).seq).isEqualTo(1);
    assertThat(info.get(0).valid).isFalse();
    assertThat(info.get(1).seq).isEqualTo(3);
    accountIndexedCounter.assertReindexOf(admin);
}
#method_after
@Test
@UseSsh
public void sshKeys() throws Exception {
    // The test account should initially have exactly one ssh key
    List<SshKeyInfo> info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(1);
    assertSequenceNumbers(info);
    SshKeyInfo key = info.get(0);
    KeyPair keyPair = sshKeys.getKeyPair(admin);
    String inital = TestSshKeys.publicKey(keyPair, admin.email);
    assertThat(key.sshPublicKey).isEqualTo(inital);
    accountIndexedCounter.assertNoReindex();
    // Add a new key
    String newKey = TestSshKeys.publicKey(TestSshKeys.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertSequenceNumbers(info);
    accountIndexedCounter.assertReindexOf(admin);
    // Add an existing key (the request succeeds, but the key isn't added again)
    gApi.accounts().self().addSshKey(inital);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertSequenceNumbers(info);
    accountIndexedCounter.assertNoReindex();
    // Add another new key
    String newKey2 = TestSshKeys.publicKey(TestSshKeys.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey2);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(3);
    assertSequenceNumbers(info);
    accountIndexedCounter.assertReindexOf(admin);
    // Delete second key
    gApi.accounts().self().deleteSshKey(2);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertThat(info.get(0).seq).isEqualTo(1);
    assertThat(info.get(1).seq).isEqualTo(3);
    accountIndexedCounter.assertReindexOf(admin);
    // Mark first key as invalid
    assertThat(info.get(0).valid).isTrue();
    authorizedKeys.markKeyInvalid(admin.id, 1);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertThat(info.get(0).seq).isEqualTo(1);
    assertThat(info.get(0).valid).isFalse();
    assertThat(info.get(1).seq).isEqualTo(3);
    accountIndexedCounter.assertReindexOf(admin);
}
#end_block

#method_before
private void evictAndReindexGroups() throws IOException {
    if (groupCache != null || groupIndexer != null) {
        Set<AccountGroup.UUID> modifiedGroups = new HashSet<>(groupUUIDs(restoredRefsByProject.get(allUsersName)));
        Set<AccountGroup.UUID> deletedGroups = new HashSet<>(groupUUIDs(deletedRefsByProject.get(allUsersName)));
        // Evict and reindex all modified and deleted accounts.
        for (AccountGroup.UUID uuid : Sets.union(modifiedGroups, deletedGroups)) {
            evictAndReindexGroup(uuid);
        }
    }
}
#method_after
private void evictAndReindexGroups() throws IOException {
    if (groupCache != null || groupIndexer != null) {
        Set<AccountGroup.UUID> modifiedGroups = new HashSet<>(groupUUIDs(restoredRefsByProject.get(allUsersName)));
        Set<AccountGroup.UUID> deletedGroups = new HashSet<>(groupUUIDs(deletedRefsByProject.get(allUsersName)));
        // Evict and reindex all modified and deleted groups.
        for (AccountGroup.UUID uuid : Sets.union(modifiedGroups, deletedGroups)) {
            evictAndReindexGroup(uuid);
        }
    }
}
#end_block

#method_before
private Set<AccountGroup.UUID> groupUUIDs(Collection<String> refs) {
    return refs.stream().filter(r -> r.startsWith(REFS_GROUPS)).map(r -> AccountGroup.UUID.fromRef(r)).filter(Objects::nonNull).collect(toSet());
}
#method_after
private Set<AccountGroup.UUID> groupUUIDs(Collection<String> refs) {
    return refs.stream().filter(RefNames::isRefsGroups).map(r -> AccountGroup.UUID.fromRef(r)).filter(Objects::nonNull).collect(toSet());
}
#end_block

#method_before
@Before
public final void setUpTestPlugin() throws Exception {
    TestPlugin testPlugin = getTestPlugin(getClass());
    String name = testPlugin.name();
    plugin = new TestServerPlugin(name, canonicalWebUrl.get() + "plugins/" + name, pluginUserFactory.create(name), getClass().getClassLoader(), testPlugin.sysModule(), testPlugin.httpModule(), testPlugin.sshModule(), tempDataDir.getRoot().toPath());
    plugin.start(env);
    env.onStartPlugin(plugin);
}
#method_after
@Before
public void setUpTestPlugin() throws Exception {
    TestPlugin testPlugin = getTestPlugin(getClass());
    String name = testPlugin.name();
    plugin = new TestServerPlugin(name, canonicalWebUrl.get() + "plugins/" + name, pluginUserFactory.create(name), getClass().getClassLoader(), testPlugin.sysModule(), testPlugin.httpModule(), testPlugin.sshModule(), tempDataDir.getRoot().toPath());
    plugin.start(env);
    env.onStartPlugin(plugin);
}
#end_block

#method_before
@After
public final void tearDownTestPlugin() {
    if (plugin != null) {
        // plugin will be null if the plugin test requires ssh, but the command
        // line flag says we are running tests without ssh as the assume()
        // statement in AbstractDaemonTest will prevent the execution of setUp()
        // in this class
        plugin.stop(env);
        env.onStopPlugin(plugin);
    }
}
#method_after
@After
public void tearDownTestPlugin() {
    if (plugin != null) {
        // plugin will be null if the plugin test requires ssh, but the command
        // line flag says we are running tests without ssh as the assume()
        // statement in AbstractDaemonTest will prevent the execution of setUp()
        // in this class
        plugin.stop(env);
        env.onStopPlugin(plugin);
    }
}
#end_block

#method_before
@Test
public void fetchUserBranch() throws Exception {
    setApiUser(user);
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers, user);
    String userRefName = RefNames.refsUsers(user.id);
    // remove default READ permissions
    ProjectConfig cfg = projectCache.checkedGet(allUsers).getConfig();
    cfg.getAccessSection(RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", true).remove(new Permission(Permission.READ));
    saveProjectConfig(allUsers, cfg);
    // deny READ permission that is inherited from All-Projects
    deny(allUsers, RefNames.REFS + "*", Permission.READ, ANONYMOUS_USERS);
    // fetching user branch without READ permission fails
    try {
        fetch(allUsersRepo, userRefName + ":userRef");
        fail("user branch is visible although no READ permission is granted");
    } catch (TransportException e) {
    // expected because no READ granted on user branch
    }
    // allow each user to read its own user branch
    grant(allUsers, RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", Permission.READ, false, REGISTERED_USERS);
    // fetch user branch using refs/users/YY/XXXXXXX
    fetch(allUsersRepo, userRefName + ":userRef");
    Ref userRef = allUsersRepo.getRepository().exactRef("userRef");
    assertThat(userRef).isNotNull();
    // fetch user branch using refs/users/self
    fetch(allUsersRepo, RefNames.REFS_USERS_SELF + ":userSelfRef");
    Ref userSelfRef = allUsersRepo.getRepository().getRefDatabase().exactRef("userSelfRef");
    assertThat(userSelfRef).isNotNull();
    assertThat(userSelfRef.getObjectId()).isEqualTo(userRef.getObjectId());
    accountIndexedCounter.assertNoReindex();
    // fetching user branch of another user fails
    String otherUserRefName = RefNames.refsUsers(admin.id);
    exception.expect(TransportException.class);
    exception.expectMessage("Remote does not have " + otherUserRefName + " available for fetch.");
    fetch(allUsersRepo, otherUserRefName + ":otherUserRef");
}
#method_after
@Test
public void fetchUserBranch() throws Exception {
    setApiUser(user);
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers, user);
    String userRefName = RefNames.refsUsers(user.id);
    // remove default READ permissions
    try (ProjectConfigUpdate u = updateProject(allUsers)) {
        u.getConfig().getAccessSection(RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", true).remove(new Permission(Permission.READ));
        u.save();
    }
    // deny READ permission that is inherited from All-Projects
    deny(allUsers, RefNames.REFS + "*", Permission.READ, ANONYMOUS_USERS);
    // fetching user branch without READ permission fails
    try {
        fetch(allUsersRepo, userRefName + ":userRef");
        fail("user branch is visible although no READ permission is granted");
    } catch (TransportException e) {
    // expected because no READ granted on user branch
    }
    // allow each user to read its own user branch
    grant(allUsers, RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", Permission.READ, false, REGISTERED_USERS);
    // fetch user branch using refs/users/YY/XXXXXXX
    fetch(allUsersRepo, userRefName + ":userRef");
    Ref userRef = allUsersRepo.getRepository().exactRef("userRef");
    assertThat(userRef).isNotNull();
    // fetch user branch using refs/users/self
    fetch(allUsersRepo, RefNames.REFS_USERS_SELF + ":userSelfRef");
    Ref userSelfRef = allUsersRepo.getRepository().getRefDatabase().exactRef("userSelfRef");
    assertThat(userSelfRef).isNotNull();
    assertThat(userSelfRef.getObjectId()).isEqualTo(userRef.getObjectId());
    accountIndexedCounter.assertNoReindex();
    // fetching user branch of another user fails
    String otherUserRefName = RefNames.refsUsers(admin.id);
    exception.expect(TransportException.class);
    exception.expectMessage("Remote does not have " + otherUserRefName + " available for fetch.");
    fetch(allUsersRepo, otherUserRefName + ":otherUserRef");
}
#end_block

#method_before
@Test
@UseSsh
public void sshKeys() throws Exception {
    // The test account should initially have exactly one ssh key
    List<SshKeyInfo> info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(1);
    assertSequenceNumbers(info);
    SshKeyInfo key = info.get(0);
    Optional<KeyPair> keyPair = sshKeys.getKeyPair(admin);
    assertThat(keyPair).isPresent();
    String inital = TestSshKeys.publicKey(keyPair.get(), admin.email);
    assertThat(key.sshPublicKey).isEqualTo(inital);
    accountIndexedCounter.assertNoReindex();
    // Add a new key
    String newKey = TestSshKeys.publicKey(TestSshKeys.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertSequenceNumbers(info);
    accountIndexedCounter.assertReindexOf(admin);
    // Add an existing key (the request succeeds, but the key isn't added again)
    gApi.accounts().self().addSshKey(inital);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertSequenceNumbers(info);
    accountIndexedCounter.assertNoReindex();
    // Add another new key
    String newKey2 = TestSshKeys.publicKey(TestSshKeys.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey2);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(3);
    assertSequenceNumbers(info);
    accountIndexedCounter.assertReindexOf(admin);
    // Delete second key
    gApi.accounts().self().deleteSshKey(2);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertThat(info.get(0).seq).isEqualTo(1);
    assertThat(info.get(1).seq).isEqualTo(3);
    accountIndexedCounter.assertReindexOf(admin);
    // Mark first key as invalid
    assertThat(info.get(0).valid).isTrue();
    authorizedKeys.markKeyInvalid(admin.id, 1);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertThat(info.get(0).seq).isEqualTo(1);
    assertThat(info.get(0).valid).isFalse();
    assertThat(info.get(1).seq).isEqualTo(3);
    accountIndexedCounter.assertReindexOf(admin);
}
#method_after
@Test
@UseSsh
public void sshKeys() throws Exception {
    // The test account should initially have exactly one ssh key
    List<SshKeyInfo> info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(1);
    assertSequenceNumbers(info);
    SshKeyInfo key = info.get(0);
    KeyPair keyPair = sshKeys.getKeyPair(admin);
    String inital = TestSshKeys.publicKey(keyPair, admin.email);
    assertThat(key.sshPublicKey).isEqualTo(inital);
    accountIndexedCounter.assertNoReindex();
    // Add a new key
    String newKey = TestSshKeys.publicKey(TestSshKeys.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertSequenceNumbers(info);
    accountIndexedCounter.assertReindexOf(admin);
    // Add an existing key (the request succeeds, but the key isn't added again)
    gApi.accounts().self().addSshKey(inital);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertSequenceNumbers(info);
    accountIndexedCounter.assertNoReindex();
    // Add another new key
    String newKey2 = TestSshKeys.publicKey(TestSshKeys.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey2);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(3);
    assertSequenceNumbers(info);
    accountIndexedCounter.assertReindexOf(admin);
    // Delete second key
    gApi.accounts().self().deleteSshKey(2);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertThat(info.get(0).seq).isEqualTo(1);
    assertThat(info.get(1).seq).isEqualTo(3);
    accountIndexedCounter.assertReindexOf(admin);
    // Mark first key as invalid
    assertThat(info.get(0).valid).isTrue();
    authorizedKeys.markKeyInvalid(admin.id, 1);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertThat(info.get(0).seq).isEqualTo(1);
    assertThat(info.get(0).valid).isFalse();
    assertThat(info.get(1).seq).isEqualTo(3);
    accountIndexedCounter.assertReindexOf(admin);
}
#end_block

#method_before
public Optional<KeyPair> getKeyPair(com.google.gerrit.acceptance.TestAccount account) throws Exception {
    if (!sshEnabled || account.username == null) {
        return Optional.empty();
    }
    String username = account.username;
    KeyPair keyPair = sshKeyPairs.get(username);
    if (keyPair == null) {
        keyPair = genSshKey();
        authorizedKeys.addKey(account.id, publicKey(keyPair, account.email));
        sshKeyCache.evict(username);
        sshKeyPairs.put(username, keyPair);
    }
    return Optional.of(keyPair);
}
#method_after
public KeyPair getKeyPair(com.google.gerrit.acceptance.TestAccount account) throws Exception {
    checkState(sshEnabled, "Requested SSH key pair, but SSH is disabled");
    checkState(account.username != null, "Requested SSH key pair for account %s, but username is not set", account.id);
    String username = account.username;
    KeyPair keyPair = sshKeyPairs.get(username);
    if (keyPair == null) {
        keyPair = createKeyPair(account.id, username, account.email);
        sshKeyPairs.put(username, keyPair);
    }
    return keyPair;
}
#end_block

#method_before
public Optional<KeyPair> getKeyPair(TestAccount account) throws Exception {
    if (!sshEnabled || !account.username().isPresent()) {
        return Optional.empty();
    }
    String username = account.username().get();
    KeyPair keyPair = sshKeyPairs.get(username);
    if (keyPair == null) {
        keyPair = genSshKey();
        authorizedKeys.addKey(account.accountId(), publicKey(keyPair, account.preferredEmail().orElse(null)));
        sshKeyCache.evict(username);
        sshKeyPairs.put(username, keyPair);
    }
    return Optional.of(keyPair);
}
#method_after
public KeyPair getKeyPair(TestAccount account) throws Exception {
    checkState(sshEnabled, "Requested SSH key pair, but SSH is disabled");
    checkState(account.username().isPresent(), "Requested SSH key pair for account %s, but username is not set", account.accountId());
    String username = account.username().get();
    KeyPair keyPair = sshKeyPairs.get(username);
    if (keyPair == null) {
        keyPair = createKeyPair(account.accountId(), username, account.preferredEmail().orElse(null));
        sshKeyPairs.put(username, keyPair);
    }
    return keyPair;
}
#end_block

#method_before
public static KeyPair genSshKey() throws JSchException {
    JSch jsch = new JSch();
    return KeyPair.genKeyPair(jsch, KeyPair.RSA);
}
#method_after
public static KeyPair genSshKey() throws JSchException {
    JSch jsch = new JSch();
    return KeyPair.genKeyPair(jsch, KeyPair.ECDSA, 256);
}
#end_block

#method_before
private AccountState createAccount(Consumer<TestAccountUpdate.Builder> accountUpdate) throws OrmException, IOException, ConfigInvalidException {
    Account.Id accountId = new Account.Id(seq.nextAccountId());
    return accountsUpdate.insert("Create Test Account", accountId, (account, updateBuilder) -> applyUpdate(account, updateBuilder, toAccountUpdate(accountUpdate)));
}
#method_after
private TestAccount createAccount(TestAccountCreation accountCreation) throws Exception {
    AccountsUpdate.AccountUpdater accountUpdater = (account, updateBuilder) -> fillBuilder(updateBuilder, accountCreation, account.getAccount().getId());
    AccountState createdAccount = createAccount(accountUpdater);
    return toTestAccount(createdAccount);
}
#end_block

#method_before
public void open() throws JSchException {
    getSession();
}
#method_after
public void open() throws Exception {
    getSession();
}
#end_block

#method_before
@SuppressWarnings("resource")
public String exec(String command, InputStream opt) throws JSchException, IOException {
    ChannelExec channel = (ChannelExec) getSession().openChannel("exec");
    try {
        channel.setCommand(command);
        channel.setInputStream(opt);
        InputStream in = channel.getInputStream();
        InputStream err = channel.getErrStream();
        channel.connect();
        Scanner s = new Scanner(err).useDelimiter("\\A");
        error = s.hasNext() ? s.next() : null;
        s = new Scanner(in).useDelimiter("\\A");
        return s.hasNext() ? s.next() : "";
    } finally {
        channel.disconnect();
    }
}
#method_after
@SuppressWarnings("resource")
public String exec(String command, InputStream opt) throws Exception {
    ChannelExec channel = (ChannelExec) getSession().openChannel("exec");
    try {
        channel.setCommand(command);
        channel.setInputStream(opt);
        InputStream in = channel.getInputStream();
        InputStream err = channel.getErrStream();
        channel.connect();
        Scanner s = new Scanner(err).useDelimiter("\\A");
        error = s.hasNext() ? s.next() : null;
        s = new Scanner(in).useDelimiter("\\A");
        return s.hasNext() ? s.next() : "";
    } finally {
        channel.disconnect();
    }
}
#end_block

#method_before
public InputStream exec2(String command, InputStream opt) throws JSchException, IOException {
    ChannelExec channel = (ChannelExec) getSession().openChannel("exec");
    channel.setCommand(command);
    channel.setInputStream(opt);
    InputStream in = channel.getInputStream();
    channel.connect();
    return in;
}
#method_after
public InputStream exec2(String command, InputStream opt) throws Exception {
    ChannelExec channel = (ChannelExec) getSession().openChannel("exec");
    channel.setCommand(command);
    channel.setInputStream(opt);
    InputStream in = channel.getInputStream();
    channel.connect();
    return in;
}
#end_block

#method_before
public String exec(String command) throws JSchException, IOException {
    return exec(command, null);
}
#method_after
public String exec(String command) throws Exception {
    return exec(command, null);
}
#end_block

#method_before
private Session getSession() throws JSchException {
    if (session == null) {
        checkState(keyPair.isPresent(), "Expected SSH key pair to be available");
        JSch jsch = new JSch();
        jsch.addIdentity("KeyPair", TestSshKeys.privateKey(keyPair.get()), keyPair.get().getPublicKeyBlob(), null);
        session = jsch.getSession(account.username, addr.getAddress().getHostAddress(), addr.getPort());
        session.setConfig("StrictHostKeyChecking", "no");
        session.connect();
    }
    return session;
}
#method_after
private Session getSession() throws Exception {
    if (session == null) {
        KeyPair keyPair = sshKeys.getKeyPair(account);
        JSch jsch = new JSch();
        jsch.addIdentity("KeyPair", TestSshKeys.privateKey(keyPair), keyPair.getPublicKeyBlob(), null);
        session = jsch.getSession(account.username, addr.getAddress().getHostAddress(), addr.getPort());
        session.setConfig("StrictHostKeyChecking", "no");
        session.connect();
    }
    return session;
}
#end_block

#method_before
protected void beforeTest(Description description) throws Exception {
    this.description = description;
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    testRequiresSsh = classDesc.useSshAnnotation() || methodDesc.useSshAnnotation();
    if (!testRequiresSsh) {
        baseConfig.setString("sshd", null, "listenAddress", "off");
    }
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    Module module = createModule();
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.initAndStart(classDesc, baseConfig, module);
        }
        server = commonServer;
    } else {
        server = GerritServer.initAndStart(methodDesc, baseConfig, module);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    db = reviewDbProvider.open();
    // All groups which were added during the server start (e.g. in SchemaCreator) aren't contained
    // in the instance of the group index which is available here and in tests. There are two
    // reasons:
    // 1) No group index is available in SchemaCreator when using an in-memory database. (This could
    // be fixed by using the IndexManagerOnInit in InMemoryDatabase similar as BaseInit uses it.)
    // 2) During the on-init part of the server start, we use another instance of the index than
    // later on. As test indexes are non-permanent, closing an instance and opening another one
    // removes all indexed data.
    // As a workaround, we simply reindex all available groups here.
    reindexAllGroups();
    admin = accountCreator.admin();
    user = accountCreator.user();
    // Evict and reindex accounts in case tests modify them.
    evictAndReindexAccount(admin.getId());
    evictAndReindexAccount(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    initSsh();
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#method_after
protected void beforeTest(Description description) throws Exception {
    this.description = description;
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    testRequiresSsh = classDesc.useSshAnnotation() || methodDesc.useSshAnnotation();
    if (!testRequiresSsh) {
        baseConfig.setString("sshd", null, "listenAddress", "off");
    }
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    Module module = createModule();
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.initAndStart(classDesc, baseConfig, module);
        }
        server = commonServer;
    } else {
        server = GerritServer.initAndStart(methodDesc, baseConfig, module);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    db = reviewDbProvider.open();
    // All groups which were added during the server start (e.g. in SchemaCreator) aren't contained
    // in the instance of the group index which is available here and in tests. There are two
    // reasons:
    // 1) No group index is available in SchemaCreator when using an in-memory database. (This could
    // be fixed by using the IndexManagerOnInit in InMemoryDatabase similar as BaseInit uses it.)
    // 2) During the on-init part of the server start, we use another instance of the index than
    // later on. As test indexes are non-permanent, closing an instance and opening another one
    // removes all indexed data.
    // As a workaround, we simply reindex all available groups here.
    reindexAllGroups();
    admin = accountCreator.admin();
    user = accountCreator.user();
    // Evict and reindex accounts in case tests modify them.
    evictAndReindexAccount(admin.getId());
    evictAndReindexAccount(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    initSsh();
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    ProjectInput in = projectInput(description);
    gApi.projects().create(in);
    project = new Project.NameKey(in.name);
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#end_block

#method_before
protected void initSsh() throws Exception {
    if (testRequiresSsh && SshMode.useSsh() && (adminSshSession == null || userSshSession == null)) {
        // Create Ssh sessions
        Optional<KeyPair> adminKeyPair = sshKeys.getKeyPair(admin);
        checkState(adminKeyPair.isPresent(), "Expected SSH key pair to be available");
        GitUtil.initSsh(adminKeyPair.get());
        Context ctx = newRequestContext(user);
        atrScope.set(ctx);
        userSshSession = ctx.getSession();
        userSshSession.open();
        ctx = newRequestContext(admin);
        atrScope.set(ctx);
        adminSshSession = ctx.getSession();
        adminSshSession.open();
    }
}
#method_after
protected void initSsh() throws Exception {
    if (testRequiresSsh && SshMode.useSsh() && (adminSshSession == null || userSshSession == null)) {
        // Create Ssh sessions
        KeyPair adminKeyPair = sshKeys.getKeyPair(admin);
        GitUtil.initSsh(adminKeyPair);
        Context ctx = newRequestContext(user);
        atrScope.set(ctx);
        userSshSession = ctx.getSession();
        userSshSession.open();
        ctx = newRequestContext(admin);
        atrScope.set(ctx);
        adminSshSession = ctx.getSession();
        adminSshSession.open();
    }
}
#end_block

#method_before
protected Project.NameKey createProject(String nameSuffix, Project.NameKey parent, boolean createEmptyCommit, SubmitType submitType) throws RestApiException {
    ProjectInput in = new ProjectInput();
    in.name = name(nameSuffix);
    in.parent = parent != null ? parent.get() : null;
    in.submitType = submitType;
    in.createEmptyCommit = createEmptyCommit;
    return createProject(in);
}
#method_after
protected Project.NameKey createProject(String nameSuffix, Project.NameKey parent, boolean createEmptyCommit, SubmitType submitType) throws RestApiException {
    ProjectInput in = new ProjectInput();
    in.name = name(nameSuffix);
    in.parent = parent != null ? parent.get() : null;
    in.submitType = submitType;
    in.createEmptyCommit = createEmptyCommit;
    gApi.projects().create(in);
    return new Project.NameKey(in.name);
}
#end_block

#method_before
private Context newRequestContext(TestAccount account) throws Exception {
    return atrScope.newContext(reviewDbProvider, new SshSession(server, account, sshKeys.getKeyPair(account)), identifiedUserFactory.create(account.getId()));
}
#method_after
private Context newRequestContext(TestAccount account) {
    return atrScope.newContext(reviewDbProvider, new SshSession(sshKeys, server, account), identifiedUserFactory.create(account.getId()));
}
#end_block

#method_before
protected Context resetCurrentApiUser() throws Exception {
    return atrScope.set(newRequestContext(atrScope.get().getSession().getAccount()));
}
#method_after
protected Context resetCurrentApiUser() {
    return atrScope.set(newRequestContext(atrScope.get().getSession().getAccount()));
}
#end_block

#method_before
protected Context setApiUser(TestAccount account) throws Exception {
    return atrScope.set(newRequestContext(account));
}
#method_after
protected Context setApiUser(TestAccount account) {
    return atrScope.set(newRequestContext(account));
}
#end_block

#method_before
protected void allow(Project.NameKey p, String ref, String permission, AccountGroup.UUID id) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, permission, id, ref);
    saveProjectConfig(p, cfg);
}
#method_after
protected void allow(Project.NameKey p, String ref, String permission, AccountGroup.UUID id) throws Exception {
    try (ProjectConfigUpdate u = updateProject(p)) {
        Util.allow(u.getConfig(), permission, id, ref);
        u.save();
    }
}
#end_block

#method_before
protected void allowGlobalCapabilities(AccountGroup.UUID id, Iterable<String> capabilityNames) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    for (String capabilityName : capabilityNames) {
        Util.allow(cfg, capabilityName, id);
    }
    saveProjectConfig(allProjects, cfg);
}
#method_after
protected void allowGlobalCapabilities(AccountGroup.UUID id, Iterable<String> capabilityNames) throws Exception {
    try (ProjectConfigUpdate u = updateProject(allProjects)) {
        for (String capabilityName : capabilityNames) {
            Util.allow(u.getConfig(), capabilityName, id);
        }
        u.save();
    }
}
#end_block

#method_before
protected void removeGlobalCapabilities(AccountGroup.UUID id, Iterable<String> capabilityNames) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    for (String capabilityName : capabilityNames) {
        Util.remove(cfg, capabilityName, id);
    }
    saveProjectConfig(allProjects, cfg);
}
#method_after
protected void removeGlobalCapabilities(AccountGroup.UUID id, Iterable<String> capabilityNames) throws Exception {
    try (ProjectConfigUpdate u = updateProject(allProjects)) {
        for (String capabilityName : capabilityNames) {
            Util.remove(u.getConfig(), capabilityName, id);
        }
        u.save();
    }
}
#end_block

#method_before
protected void deny(Project.NameKey p, String ref, String permission, AccountGroup.UUID id) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.deny(cfg, permission, id, ref);
    saveProjectConfig(p, cfg);
}
#method_after
protected void deny(Project.NameKey p, String ref, String permission, AccountGroup.UUID id) throws Exception {
    try (ProjectConfigUpdate u = updateProject(p)) {
        Util.deny(u.getConfig(), permission, id, ref);
        u.save();
    }
}
#end_block

#method_before
protected PermissionRule block(Project.NameKey project, String ref, String permission, AccountGroup.UUID id) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    PermissionRule rule = Util.block(cfg, permission, id, ref);
    saveProjectConfig(project, cfg);
    return rule;
}
#method_after
protected PermissionRule block(Project.NameKey project, String ref, String permission, AccountGroup.UUID id) throws Exception {
    try (ProjectConfigUpdate u = updateProject(project)) {
        PermissionRule rule = Util.block(u.getConfig(), permission, id, ref);
        u.save();
        return rule;
    }
}
#end_block

#method_before
protected void blockLabel(String label, int min, int max, AccountGroup.UUID id, String ref, Project.NameKey project) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.block(cfg, Permission.LABEL + label, min, max, id, ref);
    saveProjectConfig(project, cfg);
}
#method_after
protected void blockLabel(String label, int min, int max, AccountGroup.UUID id, String ref, Project.NameKey project) throws Exception {
    try (ProjectConfigUpdate u = updateProject(project)) {
        Util.block(u.getConfig(), Permission.LABEL + label, min, max, id, ref);
        u.save();
    }
}
#end_block

#method_before
protected void assertSubmittedTogether(String chId, String... expected) throws Exception {
    List<ChangeInfo> actual = gApi.changes().id(chId).submittedTogether();
    SubmittedTogetherInfo info = gApi.changes().id(chId).submittedTogether(EnumSet.of(NON_VISIBLE_CHANGES));
    assertThat(info.nonVisibleChanges).isEqualTo(0);
    assertThat(changeIds(actual)).containsExactly((Object[]) expected).inOrder();
    assertThat(changeIds(info.changes)).containsExactly((Object[]) expected).inOrder();
}
#method_after
protected void assertSubmittedTogether(String chId, String... expected) throws Exception {
    List<ChangeInfo> actual = gApi.changes().id(chId).submittedTogether();
    SubmittedTogetherInfo info = gApi.changes().id(chId).submittedTogether(EnumSet.of(NON_VISIBLE_CHANGES));
    assertThat(info.nonVisibleChanges).isEqualTo(0);
    assertThat(Iterables.transform(actual, i1 -> i1.changeId)).containsExactly((Object[]) expected).inOrder();
    assertThat(Iterables.transform(info.changes, i -> i.changeId)).containsExactly((Object[]) expected).inOrder();
}
#end_block

#method_before
protected ContributorAgreement configureContributorAgreement(boolean autoVerify) throws Exception {
    ContributorAgreement ca;
    if (autoVerify) {
        String g = createGroup("cla-test-group");
        GroupApi groupApi = gApi.groups().id(g);
        groupApi.description("CLA test group");
        InternalGroup caGroup = group(new AccountGroup.UUID(groupApi.detail().id));
        GroupReference groupRef = new GroupReference(caGroup.getGroupUUID(), caGroup.getName());
        PermissionRule rule = new PermissionRule(groupRef);
        rule.setAction(PermissionRule.Action.ALLOW);
        ca = new ContributorAgreement("cla-test");
        ca.setAutoVerify(groupRef);
        ca.setAccepted(ImmutableList.of(rule));
    } else {
        ca = new ContributorAgreement("cla-test-no-auto-verify");
    }
    ca.setDescription("description");
    ca.setAgreementUrl("agreement-url");
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    cfg.replace(ca);
    saveProjectConfig(allProjects, cfg);
    return ca;
}
#method_after
protected ContributorAgreement configureContributorAgreement(boolean autoVerify) throws Exception {
    ContributorAgreement ca;
    if (autoVerify) {
        String g = createGroup("cla-test-group");
        GroupApi groupApi = gApi.groups().id(g);
        groupApi.description("CLA test group");
        InternalGroup caGroup = group(new AccountGroup.UUID(groupApi.detail().id));
        GroupReference groupRef = new GroupReference(caGroup.getGroupUUID(), caGroup.getName());
        PermissionRule rule = new PermissionRule(groupRef);
        rule.setAction(PermissionRule.Action.ALLOW);
        ca = new ContributorAgreement("cla-test");
        ca.setAutoVerify(groupRef);
        ca.setAccepted(ImmutableList.of(rule));
    } else {
        ca = new ContributorAgreement("cla-test-no-auto-verify");
    }
    ca.setDescription("description");
    ca.setAgreementUrl("agreement-url");
    try (ProjectConfigUpdate u = updateProject(allProjects)) {
        u.getConfig().replace(ca);
        u.save();
        return ca;
    }
}
#end_block

#method_before
protected Map<Branch.NameKey, ObjectId> fetchFromSubmitPreview(String changeId) throws Exception {
    try (BinaryResult result = submitPreview(changeId)) {
        return fetchFromBundles(result);
    }
}
#method_after
protected Map<Branch.NameKey, ObjectId> fetchFromSubmitPreview(String changeId) throws Exception {
    try (BinaryResult result = gApi.changes().id(changeId).current().submitPreview()) {
        return fetchFromBundles(result);
    }
}
#end_block

#method_before
private void assertPermission(Permission permission, String expectedName, boolean expectedExclusive, @Nullable String expectedLabelName) {
    assertThat(permission).isNotNull();
    assertThat(permission.getName()).isEqualTo(expectedName);
    assertThat(permission.getExclusiveGroup()).isEqualTo(expectedExclusive);
    assertThat(permission.getLabel()).isEqualTo(expectedLabelName);
}
#method_after
protected void assertPermission(Permission permission, String expectedName, boolean expectedExclusive, @Nullable String expectedLabelName) {
    assertThat(permission).isNotNull();
    assertThat(permission.getName()).isEqualTo(expectedName);
    assertThat(permission.getExclusiveGroup()).isEqualTo(expectedExclusive);
    assertThat(permission.getLabel()).isEqualTo(expectedLabelName);
}
#end_block

#method_before
private void assertPermissionRule(PermissionRule rule, GroupReference expectedGroupReference, Action expectedAction, boolean expectedForce, int expectedMin, int expectedMax) {
    assertThat(rule.getGroup()).isEqualTo(expectedGroupReference);
    assertThat(rule.getAction()).isEqualTo(expectedAction);
    assertThat(rule.getForce()).isEqualTo(expectedForce);
    assertThat(rule.getMin()).isEqualTo(expectedMin);
    assertThat(rule.getMax()).isEqualTo(expectedMax);
}
#method_after
protected void assertPermissionRule(PermissionRule rule, GroupReference expectedGroupReference, Action expectedAction, boolean expectedForce, int expectedMin, int expectedMax) {
    assertThat(rule.getGroup()).isEqualTo(expectedGroupReference);
    assertThat(rule.getAction()).isEqualTo(expectedAction);
    assertThat(rule.getForce()).isEqualTo(expectedForce);
    assertThat(rule.getMin()).isEqualTo(expectedMin);
    assertThat(rule.getMax()).isEqualTo(expectedMax);
}
#end_block

#method_before
protected void configLabel(Project.NameKey project, String label, LabelFunction func, LabelValue... value) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType labelType = category(label, value);
    labelType.setFunction(func);
    cfg.getLabelSections().put(labelType.getName(), labelType);
    saveProjectConfig(project, cfg);
}
#method_after
protected void configLabel(Project.NameKey project, String label, LabelFunction func, LabelValue... value) throws Exception {
    try (ProjectConfigUpdate u = updateProject(project)) {
        LabelType labelType = category(label, value);
        labelType.setFunction(func);
        u.getConfig().getLabelSections().put(labelType.getName(), labelType);
        u.save();
    }
}
#end_block

#method_before
protected void enableCreateNewChangeForAllNotInTarget() throws Exception {
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    config.getProject().setBooleanConfig(BooleanProjectConfig.CREATE_NEW_CHANGE_FOR_ALL_NOT_IN_TARGET, InheritableBoolean.TRUE);
    saveProjectConfig(project, config);
}
#method_after
protected void enableCreateNewChangeForAllNotInTarget() throws Exception {
    try (ProjectConfigUpdate u = updateProject(project)) {
        u.getConfig().getProject().setBooleanConfig(BooleanProjectConfig.CREATE_NEW_CHANGE_FOR_ALL_NOT_IN_TARGET, InheritableBoolean.TRUE);
        u.save();
    }
}
#end_block

#method_before
public AuthResult authenticate(AuthRequest who) throws AccountException, IOException {
    who = realm.authenticate(who);
    try {
        try (ReviewDb db = schema.open()) {
            ExternalId id = findExternalId(db, who.getExternalIdKey());
            if (id == null) {
                if (who.getUserName() != null) {
                    ExternalId.Key key = ExternalId.Key.create(SCHEME_USERNAME, who.getUserName());
                    ExternalId existingId = findExternalId(db, key);
                    if (existingId != null) {
                        // An inconsistency is detected in the database, having a record for scheme
                        // "username:"
                        // but no record for scheme "gerrit:". Try to recover by linking
                        // "gerrit:" identity to the existing account.
                        log.warn("User {} already has an account; link new identity to the existing account.", who.getUserName());
                        return link(existingId.accountId(), who);
                    }
                }
                // New account, automatically create and return.
                // 
                log.info("External ID not found. Attempting to create new account.");
                return create(db, who);
            }
            // Account exists
            Account act = byIdCache.get(id.accountId()).getAccount();
            if (!act.isActive()) {
                throw new AccountException("Authentication error, account inactive");
            }
            // return the identity to the caller.
            update(db, who, id);
            return new AuthResult(id.accountId(), who.getExternalIdKey(), false);
        }
    } catch (OrmException | ConfigInvalidException e) {
        throw new AccountException("Authentication error", e);
    }
}
#method_after
public AuthResult authenticate(AuthRequest who) throws AccountException, IOException {
    who = realm.authenticate(who);
    try {
        try (ReviewDb db = schema.open()) {
            ExternalId id = findExternalId(db, who.getExternalIdKey());
            if (id == null) {
                if (who.getUserName() != null) {
                    ExternalId.Key key = ExternalId.Key.create(SCHEME_USERNAME, who.getUserName());
                    ExternalId existingId = findExternalId(db, key);
                    if (existingId != null) {
                        // An inconsistency is detected in the database, having a record for scheme
                        // "username:"
                        // but no record for scheme "gerrit:". Try to recover by linking
                        // "gerrit:" identity to the existing account.
                        log.warn("User {} already has an account; link new identity to the existing account.", who.getUserName());
                        return link(existingId.accountId(), who);
                    }
                }
                // New account, automatically create and return.
                // 
                log.debug("External ID not found. Attempting to create new account.");
                return create(db, who);
            }
            // Account exists
            Account act = byIdCache.get(id.accountId()).getAccount();
            if (!act.isActive()) {
                throw new AccountException("Authentication error, account inactive");
            }
            // return the identity to the caller.
            update(db, who, id);
            return new AuthResult(id.accountId(), who.getExternalIdKey(), false);
        }
    } catch (OrmException | ConfigInvalidException e) {
        throw new AccountException("Authentication error", e);
    }
}
#end_block

#method_before
private void update(ReviewDb db, AuthRequest who, ExternalId extId) throws OrmException, IOException {
    IdentifiedUser user = userFactory.create(extId.accountId());
    Account toUpdate = null;
    // If the email address was modified by the authentication provider,
    // update our records to match the changed email.
    // 
    String newEmail = who.getEmailAddress();
    String oldEmail = extId.email();
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        if (oldEmail != null && oldEmail.equals(user.getAccount().getPreferredEmail())) {
            toUpdate = load(toUpdate, user.getAccountId(), db);
            toUpdate.setPreferredEmail(newEmail);
        }
        externalIdsUpdateFactory.create().replace(db, extId, ExternalId.create(extId.key(), extId.accountId(), newEmail, extId.password()));
    }
    if (!realm.allowsEdit(AccountFieldName.FULL_NAME) && !Strings.isNullOrEmpty(who.getDisplayName()) && !eq(user.getAccount().getFullName(), who.getDisplayName())) {
        toUpdate = load(toUpdate, user.getAccountId(), db);
        toUpdate.setFullName(who.getDisplayName());
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME) && who.getUserName() != null && !eq(user.getUserName(), who.getUserName())) {
        log.warn(String.format("Not changing already set username %s to %s", user.getUserName(), who.getUserName()));
    }
    if (toUpdate != null) {
        db.accounts().update(Collections.singleton(toUpdate));
    }
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        byEmailCache.evict(oldEmail);
        byEmailCache.evict(newEmail);
    }
    if (toUpdate != null) {
        byIdCache.evict(toUpdate.getId());
    }
}
#method_after
private void update(ReviewDb db, AuthRequest who, ExternalId extId) throws OrmException, IOException {
    IdentifiedUser user = userFactory.create(extId.accountId());
    Account toUpdate = null;
    // If the email address was modified by the authentication provider,
    // update our records to match the changed email.
    // 
    String newEmail = who.getEmailAddress();
    String oldEmail = extId.email();
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        if (oldEmail != null && oldEmail.equals(user.getAccount().getPreferredEmail())) {
            toUpdate = load(toUpdate, user.getAccountId(), db);
            toUpdate.setPreferredEmail(newEmail);
        }
        externalIdsUpdateFactory.create().replace(db, extId, ExternalId.create(extId.key(), extId.accountId(), newEmail, extId.password()));
    }
    if (!realm.allowsEdit(AccountFieldName.FULL_NAME) && !Strings.isNullOrEmpty(who.getDisplayName()) && !eq(user.getAccount().getFullName(), who.getDisplayName())) {
        toUpdate = load(toUpdate, user.getAccountId(), db);
        toUpdate.setFullName(who.getDisplayName());
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME) && who.getUserName() != null && !eq(user.getUserName(), who.getUserName())) {
        log.warn("Not changing already set username {} to {}", user.getUserName(), who.getUserName());
    }
    if (toUpdate != null) {
        db.accounts().update(Collections.singleton(toUpdate));
    }
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        byEmailCache.evict(oldEmail);
        byEmailCache.evict(newEmail);
    }
    if (toUpdate != null) {
        byIdCache.evict(toUpdate.getId());
    }
}
#end_block

#method_before
private AuthResult create(ReviewDb db, AuthRequest who) throws OrmException, AccountException, IOException, ConfigInvalidException {
    Account.Id newId = new Account.Id(db.nextAccountId());
    log.info("Assigning newId to account: {}", newId);
    Account account = new Account(newId, TimeUtil.nowTs());
    ExternalId extId = ExternalId.createWithEmail(who.getExternalIdKey(), newId, who.getEmailAddress());
    log.info("Created externalID: {}", extId.toString());
    account.setFullName(who.getDisplayName());
    account.setPreferredEmail(extId.email());
    boolean isFirstAccount = awaitsFirstAccountCheck.getAndSet(false) && db.accounts().anyAccounts().toList().isEmpty();
    try {
        db.accounts().upsert(Collections.singleton(account));
        ExternalId existingExtId = ExternalId.from(db.accountExternalIds().get(extId.key().asAccountExternalIdKey()));
        if (existingExtId != null && !existingExtId.accountId().equals(extId.accountId())) {
            // external ID is assigned to another account, do not overwrite
            db.accounts().delete(Collections.singleton(account));
            throw new AccountException("Cannot assign external ID \"" + extId.key().get() + "\" to account " + newId + "; external ID already in use.");
        }
        externalIdsUpdateFactory.create().upsert(db, extId);
    } finally {
        // If adding the account failed, it may be that it actually was the
        // first account. So we reset the 'check for first account'-guard, as
        // otherwise the first account would not get administration permissions.
        awaitsFirstAccountCheck.set(isFirstAccount);
    }
    if (isFirstAccount) {
        // This is the first user account on our site. Assume this user
        // is going to be the site's administrator and just make them that
        // to bootstrap the authentication database.
        // 
        Permission admin = projectCache.getAllProjects().getConfig().getAccessSection(AccessSection.GLOBAL_CAPABILITIES).getPermission(GlobalCapability.ADMINISTRATE_SERVER);
        AccountGroup.UUID uuid = admin.getRules().get(0).getGroup().getUUID();
        Iterator<AccountGroup> adminGroupIt = db.accountGroups().byUUID(uuid).iterator();
        if (!adminGroupIt.hasNext()) {
            throw new OrmException("Administrator group's UUID is misaligned in backend and All-Projects repository");
        }
        AccountGroup g = adminGroupIt.next();
        AccountGroup.Id adminId = g.getId();
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(newId, adminId));
        auditService.dispatchAddAccountsToGroup(newId, Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    log.info("Username from AuthRequest: {}", who.getUserName());
    if (who.getUserName() != null) {
        log.info("Setting username for: {}", who.getUserName());
        // Only set if the name hasn't been used yet, but was given to us.
        // 
        IdentifiedUser user = userFactory.create(newId);
        log.info("Identified user was created from: {} : {}", who.getUserName(), user.toString());
        try {
            changeUserNameFactory.create(db, user, who.getUserName()).call();
        } catch (NameAlreadyUsedException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name already in use.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (InvalidUserNameException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name does not conform.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (OrmException e) {
            String message = "Cannot assign user name";
            handleSettingUserNameFailure(db, account, extId, message, e, true);
        }
    }
    byEmailCache.evict(account.getPreferredEmail());
    byIdCache.evict(account.getId());
    realm.onCreateAccount(who, account);
    return new AuthResult(newId, extId.key(), true);
}
#method_after
private AuthResult create(ReviewDb db, AuthRequest who) throws OrmException, AccountException, IOException, ConfigInvalidException {
    Account.Id newId = new Account.Id(db.nextAccountId());
    log.debug("Assigning new Id {} to account", newId);
    Account account = new Account(newId, TimeUtil.nowTs());
    ExternalId extId = ExternalId.createWithEmail(who.getExternalIdKey(), newId, who.getEmailAddress());
    log.debug("Created external Id: {}", extId);
    account.setFullName(who.getDisplayName());
    account.setPreferredEmail(extId.email());
    boolean isFirstAccount = awaitsFirstAccountCheck.getAndSet(false) && db.accounts().anyAccounts().toList().isEmpty();
    try {
        db.accounts().upsert(Collections.singleton(account));
        ExternalId existingExtId = ExternalId.from(db.accountExternalIds().get(extId.key().asAccountExternalIdKey()));
        if (existingExtId != null && !existingExtId.accountId().equals(extId.accountId())) {
            // external ID is assigned to another account, do not overwrite
            db.accounts().delete(Collections.singleton(account));
            throw new AccountException("Cannot assign external ID \"" + extId.key().get() + "\" to account " + newId + "; external ID already in use.");
        }
        externalIdsUpdateFactory.create().upsert(db, extId);
    } finally {
        // If adding the account failed, it may be that it actually was the
        // first account. So we reset the 'check for first account'-guard, as
        // otherwise the first account would not get administration permissions.
        awaitsFirstAccountCheck.set(isFirstAccount);
    }
    if (isFirstAccount) {
        // This is the first user account on our site. Assume this user
        // is going to be the site's administrator and just make them that
        // to bootstrap the authentication database.
        // 
        Permission admin = projectCache.getAllProjects().getConfig().getAccessSection(AccessSection.GLOBAL_CAPABILITIES).getPermission(GlobalCapability.ADMINISTRATE_SERVER);
        AccountGroup.UUID uuid = admin.getRules().get(0).getGroup().getUUID();
        Iterator<AccountGroup> adminGroupIt = db.accountGroups().byUUID(uuid).iterator();
        if (!adminGroupIt.hasNext()) {
            throw new OrmException("Administrator group's UUID is misaligned in backend and All-Projects repository");
        }
        AccountGroup g = adminGroupIt.next();
        AccountGroup.Id adminId = g.getId();
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(newId, adminId));
        auditService.dispatchAddAccountsToGroup(newId, Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    log.debug("Username from AuthRequest: {}", who.getUserName());
    if (who.getUserName() != null) {
        log.debug("Setting username for: {}", who.getUserName());
        // Only set if the name hasn't been used yet, but was given to us.
        // 
        IdentifiedUser user = userFactory.create(newId);
        log.debug("Identified user {} was created from {}", user, who.getUserName());
        try {
            changeUserNameFactory.create(db, user, who.getUserName()).call();
        } catch (NameAlreadyUsedException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name already in use.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (InvalidUserNameException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name does not conform.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (OrmException e) {
            String message = "Cannot assign user name";
            handleSettingUserNameFailure(db, account, extId, message, e, true);
        }
    }
    byEmailCache.evict(account.getPreferredEmail());
    byIdCache.evict(account.getId());
    realm.onCreateAccount(who, account);
    return new AuthResult(newId, extId.key(), true);
}
#end_block

#method_before
public AuthResult link(Account.Id to, AuthRequest who) throws AccountException, OrmException, IOException {
    try (ReviewDb db = schema.open()) {
        log.info("Link another authentication identity to an existing account");
        ExternalId extId = findExternalId(db, who.getExternalIdKey());
        if (extId != null) {
            if (!extId.accountId().equals(to)) {
                throw new AccountException("Identity in use by another account");
            }
            log.info("Updating existing external ID data");
            update(db, who, extId);
        } else {
            log.info("Linking new external ID to the existing account");
            externalIdsUpdateFactory.create().insert(db, ExternalId.createWithEmail(who.getExternalIdKey(), to, who.getEmailAddress()));
            if (who.getEmailAddress() != null) {
                Account a = db.accounts().get(to);
                if (a.getPreferredEmail() == null) {
                    a.setPreferredEmail(who.getEmailAddress());
                    db.accounts().update(Collections.singleton(a));
                    byIdCache.evict(to);
                }
                byEmailCache.evict(who.getEmailAddress());
            }
        }
        return new AuthResult(to, who.getExternalIdKey(), false);
    }
}
#method_after
public AuthResult link(Account.Id to, AuthRequest who) throws AccountException, OrmException, IOException {
    try (ReviewDb db = schema.open()) {
        log.debug("Link another authentication identity to an existing account");
        ExternalId extId = findExternalId(db, who.getExternalIdKey());
        if (extId != null) {
            if (!extId.accountId().equals(to)) {
                throw new AccountException("Identity in use by another account");
            }
            log.debug("Updating existing external ID data");
            update(db, who, extId);
        } else {
            log.debug("Linking new external ID to the existing account");
            externalIdsUpdateFactory.create().insert(db, ExternalId.createWithEmail(who.getExternalIdKey(), to, who.getEmailAddress()));
            if (who.getEmailAddress() != null) {
                Account a = db.accounts().get(to);
                if (a.getPreferredEmail() == null) {
                    a.setPreferredEmail(who.getEmailAddress());
                    db.accounts().update(Collections.singleton(a));
                    byIdCache.evict(to);
                }
                byEmailCache.evict(who.getEmailAddress());
            }
        }
        return new AuthResult(to, who.getExternalIdKey(), false);
    }
}
#end_block

#method_before
@Override
public VoidResult call() throws OrmException, NameAlreadyUsedException, InvalidUserNameException, IOException, ConfigInvalidException {
    Collection<ExternalId> old = ExternalId.from(db.accountExternalIds().byAccount(user.getAccountId()).toList()).stream().filter(e -> e.isScheme(SCHEME_USERNAME)).collect(toSet());
    if (!old.isEmpty()) {
        log.error("External id with scheme \"username:\" already exists  for the user.");
        throw new IllegalStateException(USERNAME_CANNOT_BE_CHANGED);
    }
    ExternalIdsUpdate externalIdsUpdate = externalIdsUpdateFactory.create();
    if (newUsername != null && !newUsername.isEmpty()) {
        if (!USER_NAME_PATTERN.matcher(newUsername).matches()) {
            throw new InvalidUserNameException();
        }
        ExternalId.Key key = ExternalId.Key.create(SCHEME_USERNAME, newUsername);
        try {
            String password = null;
            for (ExternalId i : old) {
                if (i.password() != null) {
                    password = i.password();
                }
            }
            externalIdsUpdate.insert(db, ExternalId.create(key, user.getAccountId(), null, password));
            log.info("Created the new external Id with key: {}", key);
        } catch (OrmDuplicateKeyException dupeErr) {
            // If we are using this identity, don't report the exception.
            // 
            ExternalId other = ExternalId.from(db.accountExternalIds().get(key.asAccountExternalIdKey()));
            if (other != null && other.accountId().equals(user.getAccountId())) {
                return VoidResult.INSTANCE;
            }
            // 
            throw new NameAlreadyUsedException(newUsername);
        }
    }
    // If we have any older user names, remove them.
    // 
    externalIdsUpdate.delete(db, old);
    for (ExternalId extId : old) {
        sshKeyCache.evict(extId.key().id());
        accountCache.evictByUsername(extId.key().id());
    }
    accountCache.evictByUsername(newUsername);
    sshKeyCache.evict(newUsername);
    return VoidResult.INSTANCE;
}
#method_after
@Override
public VoidResult call() throws OrmException, NameAlreadyUsedException, InvalidUserNameException, IOException, ConfigInvalidException {
    Collection<ExternalId> old = ExternalId.from(db.accountExternalIds().byAccount(user.getAccountId()).toList()).stream().filter(e -> e.isScheme(SCHEME_USERNAME)).collect(toSet());
    if (!old.isEmpty()) {
        log.error("External id with scheme \"username:\" already exists for the user {}", user.getAccountId());
        throw new IllegalStateException(USERNAME_CANNOT_BE_CHANGED);
    }
    ExternalIdsUpdate externalIdsUpdate = externalIdsUpdateFactory.create();
    if (newUsername != null && !newUsername.isEmpty()) {
        if (!USER_NAME_PATTERN.matcher(newUsername).matches()) {
            throw new InvalidUserNameException();
        }
        ExternalId.Key key = ExternalId.Key.create(SCHEME_USERNAME, newUsername);
        try {
            String password = null;
            for (ExternalId i : old) {
                if (i.password() != null) {
                    password = i.password();
                }
            }
            externalIdsUpdate.insert(db, ExternalId.create(key, user.getAccountId(), null, password));
            log.info("Created the new external Id with key: {}", key);
        } catch (OrmDuplicateKeyException dupeErr) {
            // If we are using this identity, don't report the exception.
            // 
            ExternalId other = ExternalId.from(db.accountExternalIds().get(key.asAccountExternalIdKey()));
            if (other != null && other.accountId().equals(user.getAccountId())) {
                return VoidResult.INSTANCE;
            }
            // 
            throw new NameAlreadyUsedException(newUsername);
        }
    }
    // If we have any older user names, remove them.
    // 
    externalIdsUpdate.delete(db, old);
    for (ExternalId extId : old) {
        sshKeyCache.evict(extId.key().id());
        accountCache.evictByUsername(extId.key().id());
    }
    accountCache.evictByUsername(newUsername);
    sshKeyCache.evict(newUsername);
    return VoidResult.INSTANCE;
}
#end_block

#method_before
protected void beforeTest(Description description) throws Exception {
    this.description = description;
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    testRequiresSsh = classDesc.useSshAnnotation() || methodDesc.useSshAnnotation();
    if (!testRequiresSsh) {
        baseConfig.setString("sshd", null, "listenAddress", "off");
    }
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    Module module = createModule();
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.initAndStart(classDesc, baseConfig, module);
        }
        server = commonServer;
    } else {
        server = GerritServer.initAndStart(methodDesc, baseConfig, module);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    db = reviewDbProvider.open();
    // All groups which were added during the server start (e.g. in SchemaCreator) aren't contained
    // in the instance of the group index which is available here and in tests. There are two
    // reasons:
    // 1) No group index is available in SchemaCreator when using an in-memory database. (This could
    // be fixed by using the IndexManagerOnInit in InMemoryDatabase similar as BaseInit uses it.)
    // 2) During the on-init part of the server start, we use another instance of the index than
    // later on. As test indexes are non-permanent, closing an instance and opening another one
    // removes all indexed data.
    // As a workaround, we simply reindex all available groups here.
    reindexAllGroups();
    admin = accountCreator.admin();
    user = accountCreator.user();
    // Evict and reindex accounts in case tests modify them.
    evictAndReindexAccount(admin.getId());
    evictAndReindexAccount(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    initSsh();
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#method_after
protected void beforeTest(Description description) throws Exception {
    this.description = description;
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    testRequiresSsh = classDesc.useSshAnnotation() || methodDesc.useSshAnnotation();
    if (!testRequiresSsh) {
        baseConfig.setString("sshd", null, "listenAddress", "off");
    }
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    Module module = createModule();
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.initAndStart(classDesc, baseConfig, module);
        }
        server = commonServer;
    } else {
        server = GerritServer.initAndStart(methodDesc, baseConfig, module);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    db = reviewDbProvider.open();
    // All groups which were added during the server start (e.g. in SchemaCreator) aren't contained
    // in the instance of the group index which is available here and in tests. There are two
    // reasons:
    // 1) No group index is available in SchemaCreator when using an in-memory database. (This could
    // be fixed by using the IndexManagerOnInit in InMemoryDatabase similar as BaseInit uses it.)
    // 2) During the on-init part of the server start, we use another instance of the index than
    // later on. As test indexes are non-permanent, closing an instance and opening another one
    // removes all indexed data.
    // As a workaround, we simply reindex all available groups here.
    reindexAllGroups();
    admin = accountCreator.admin();
    user = accountCreator.user();
    // Evict and reindex accounts in case tests modify them.
    evictAndReindexAccount(admin.getId());
    evictAndReindexAccount(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    initSsh();
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    ProjectInput in = projectInput(description);
    gApi.projects().create(in);
    project = new Project.NameKey(in.name);
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#end_block

#method_before
protected Project.NameKey createProject(String nameSuffix, Project.NameKey parent, boolean createEmptyCommit, SubmitType submitType) throws RestApiException {
    ProjectInput in = new ProjectInput();
    in.name = name(nameSuffix);
    in.parent = parent != null ? parent.get() : null;
    in.submitType = submitType;
    in.createEmptyCommit = createEmptyCommit;
    return createProject(in);
}
#method_after
protected Project.NameKey createProject(String nameSuffix, Project.NameKey parent, boolean createEmptyCommit, SubmitType submitType) throws RestApiException {
    ProjectInput in = new ProjectInput();
    in.name = name(nameSuffix);
    in.parent = parent != null ? parent.get() : null;
    in.submitType = submitType;
    in.createEmptyCommit = createEmptyCommit;
    gApi.projects().create(in);
    return new Project.NameKey(in.name);
}
#end_block

#method_before
protected void allow(Project.NameKey p, String ref, String permission, AccountGroup.UUID id) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, permission, id, ref);
    saveProjectConfig(p, cfg);
}
#method_after
protected void allow(Project.NameKey p, String ref, String permission, AccountGroup.UUID id) throws Exception {
    try (ProjectConfigUpdate u = updateProject(p)) {
        Util.allow(u.getConfig(), permission, id, ref);
        u.save();
    }
}
#end_block

#method_before
protected void allowGlobalCapabilities(AccountGroup.UUID id, Iterable<String> capabilityNames) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    for (String capabilityName : capabilityNames) {
        Util.allow(cfg, capabilityName, id);
    }
    saveProjectConfig(allProjects, cfg);
}
#method_after
protected void allowGlobalCapabilities(AccountGroup.UUID id, Iterable<String> capabilityNames) throws Exception {
    try (ProjectConfigUpdate u = updateProject(allProjects)) {
        for (String capabilityName : capabilityNames) {
            Util.allow(u.getConfig(), capabilityName, id);
        }
        u.save();
    }
}
#end_block

#method_before
protected void removeGlobalCapabilities(AccountGroup.UUID id, Iterable<String> capabilityNames) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    for (String capabilityName : capabilityNames) {
        Util.remove(cfg, capabilityName, id);
    }
    saveProjectConfig(allProjects, cfg);
}
#method_after
protected void removeGlobalCapabilities(AccountGroup.UUID id, Iterable<String> capabilityNames) throws Exception {
    try (ProjectConfigUpdate u = updateProject(allProjects)) {
        for (String capabilityName : capabilityNames) {
            Util.remove(u.getConfig(), capabilityName, id);
        }
        u.save();
    }
}
#end_block

#method_before
protected void deny(Project.NameKey p, String ref, String permission, AccountGroup.UUID id) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.deny(cfg, permission, id, ref);
    saveProjectConfig(p, cfg);
}
#method_after
protected void deny(Project.NameKey p, String ref, String permission, AccountGroup.UUID id) throws Exception {
    try (ProjectConfigUpdate u = updateProject(p)) {
        Util.deny(u.getConfig(), permission, id, ref);
        u.save();
    }
}
#end_block

#method_before
protected PermissionRule block(Project.NameKey project, String ref, String permission, AccountGroup.UUID id) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    PermissionRule rule = Util.block(cfg, permission, id, ref);
    saveProjectConfig(project, cfg);
    return rule;
}
#method_after
protected PermissionRule block(Project.NameKey project, String ref, String permission, AccountGroup.UUID id) throws Exception {
    try (ProjectConfigUpdate u = updateProject(project)) {
        PermissionRule rule = Util.block(u.getConfig(), permission, id, ref);
        u.save();
        return rule;
    }
}
#end_block

#method_before
protected void blockLabel(String label, int min, int max, AccountGroup.UUID id, String ref, Project.NameKey project) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.block(cfg, Permission.LABEL + label, min, max, id, ref);
    saveProjectConfig(project, cfg);
}
#method_after
protected void blockLabel(String label, int min, int max, AccountGroup.UUID id, String ref, Project.NameKey project) throws Exception {
    try (ProjectConfigUpdate u = updateProject(project)) {
        Util.block(u.getConfig(), Permission.LABEL + label, min, max, id, ref);
        u.save();
    }
}
#end_block

#method_before
protected ContributorAgreement configureContributorAgreement(boolean autoVerify) throws Exception {
    ContributorAgreement ca;
    if (autoVerify) {
        String g = createGroup("cla-test-group");
        GroupApi groupApi = gApi.groups().id(g);
        groupApi.description("CLA test group");
        InternalGroup caGroup = group(new AccountGroup.UUID(groupApi.detail().id));
        GroupReference groupRef = new GroupReference(caGroup.getGroupUUID(), caGroup.getName());
        PermissionRule rule = new PermissionRule(groupRef);
        rule.setAction(PermissionRule.Action.ALLOW);
        ca = new ContributorAgreement("cla-test");
        ca.setAutoVerify(groupRef);
        ca.setAccepted(ImmutableList.of(rule));
    } else {
        ca = new ContributorAgreement("cla-test-no-auto-verify");
    }
    ca.setDescription("description");
    ca.setAgreementUrl("agreement-url");
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    cfg.replace(ca);
    saveProjectConfig(allProjects, cfg);
    return ca;
}
#method_after
protected ContributorAgreement configureContributorAgreement(boolean autoVerify) throws Exception {
    ContributorAgreement ca;
    if (autoVerify) {
        String g = createGroup("cla-test-group");
        GroupApi groupApi = gApi.groups().id(g);
        groupApi.description("CLA test group");
        InternalGroup caGroup = group(new AccountGroup.UUID(groupApi.detail().id));
        GroupReference groupRef = new GroupReference(caGroup.getGroupUUID(), caGroup.getName());
        PermissionRule rule = new PermissionRule(groupRef);
        rule.setAction(PermissionRule.Action.ALLOW);
        ca = new ContributorAgreement("cla-test");
        ca.setAutoVerify(groupRef);
        ca.setAccepted(ImmutableList.of(rule));
    } else {
        ca = new ContributorAgreement("cla-test-no-auto-verify");
    }
    ca.setDescription("description");
    ca.setAgreementUrl("agreement-url");
    try (ProjectConfigUpdate u = updateProject(allProjects)) {
        u.getConfig().replace(ca);
        u.save();
        return ca;
    }
}
#end_block

#method_before
protected Map<Branch.NameKey, ObjectId> fetchFromSubmitPreview(String changeId) throws Exception {
    try (BinaryResult result = submitPreview(changeId)) {
        return fetchFromBundles(result);
    }
}
#method_after
protected Map<Branch.NameKey, ObjectId> fetchFromSubmitPreview(String changeId) throws Exception {
    try (BinaryResult result = gApi.changes().id(changeId).current().submitPreview()) {
        return fetchFromBundles(result);
    }
}
#end_block

#method_before
private void assertPermission(Permission permission, String expectedName, boolean expectedExclusive, @Nullable String expectedLabelName) {
    assertThat(permission).isNotNull();
    assertThat(permission.getName()).isEqualTo(expectedName);
    assertThat(permission.getExclusiveGroup()).isEqualTo(expectedExclusive);
    assertThat(permission.getLabel()).isEqualTo(expectedLabelName);
}
#method_after
protected void assertPermission(Permission permission, String expectedName, boolean expectedExclusive, @Nullable String expectedLabelName) {
    assertThat(permission).isNotNull();
    assertThat(permission.getName()).isEqualTo(expectedName);
    assertThat(permission.getExclusiveGroup()).isEqualTo(expectedExclusive);
    assertThat(permission.getLabel()).isEqualTo(expectedLabelName);
}
#end_block

#method_before
private void assertPermissionRule(PermissionRule rule, GroupReference expectedGroupReference, Action expectedAction, boolean expectedForce, int expectedMin, int expectedMax) {
    assertThat(rule.getGroup()).isEqualTo(expectedGroupReference);
    assertThat(rule.getAction()).isEqualTo(expectedAction);
    assertThat(rule.getForce()).isEqualTo(expectedForce);
    assertThat(rule.getMin()).isEqualTo(expectedMin);
    assertThat(rule.getMax()).isEqualTo(expectedMax);
}
#method_after
protected void assertPermissionRule(PermissionRule rule, GroupReference expectedGroupReference, Action expectedAction, boolean expectedForce, int expectedMin, int expectedMax) {
    assertThat(rule.getGroup()).isEqualTo(expectedGroupReference);
    assertThat(rule.getAction()).isEqualTo(expectedAction);
    assertThat(rule.getForce()).isEqualTo(expectedForce);
    assertThat(rule.getMin()).isEqualTo(expectedMin);
    assertThat(rule.getMax()).isEqualTo(expectedMax);
}
#end_block

#method_before
protected void configLabel(Project.NameKey project, String label, LabelFunction func, LabelValue... value) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType labelType = category(label, value);
    labelType.setFunction(func);
    cfg.getLabelSections().put(labelType.getName(), labelType);
    saveProjectConfig(project, cfg);
}
#method_after
protected void configLabel(Project.NameKey project, String label, LabelFunction func, LabelValue... value) throws Exception {
    try (ProjectConfigUpdate u = updateProject(project)) {
        LabelType labelType = category(label, value);
        labelType.setFunction(func);
        u.getConfig().getLabelSections().put(labelType.getName(), labelType);
        u.save();
    }
}
#end_block

#method_before
protected void enableCreateNewChangeForAllNotInTarget() throws Exception {
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    config.getProject().setBooleanConfig(BooleanProjectConfig.CREATE_NEW_CHANGE_FOR_ALL_NOT_IN_TARGET, InheritableBoolean.TRUE);
    saveProjectConfig(project, config);
}
#method_after
protected void enableCreateNewChangeForAllNotInTarget() throws Exception {
    try (ProjectConfigUpdate u = updateProject(project)) {
        u.getConfig().getProject().setBooleanConfig(BooleanProjectConfig.CREATE_NEW_CHANGE_FOR_ALL_NOT_IN_TARGET, InheritableBoolean.TRUE);
        u.save();
    }
}
#end_block

#method_before
@Test
public void fetchUserBranch() throws Exception {
    setApiUser(user);
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers, user);
    String userRefName = RefNames.refsUsers(user.id);
    // remove default READ permissions
    ProjectConfig cfg = projectCache.checkedGet(allUsers).getConfig();
    cfg.getAccessSection(RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", true).remove(new Permission(Permission.READ));
    saveProjectConfig(allUsers, cfg);
    // deny READ permission that is inherited from All-Projects
    deny(allUsers, RefNames.REFS + "*", Permission.READ, ANONYMOUS_USERS);
    // fetching user branch without READ permission fails
    try {
        fetch(allUsersRepo, userRefName + ":userRef");
        fail("user branch is visible although no READ permission is granted");
    } catch (TransportException e) {
    // expected because no READ granted on user branch
    }
    // allow each user to read its own user branch
    grant(allUsers, RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", Permission.READ, false, REGISTERED_USERS);
    // fetch user branch using refs/users/YY/XXXXXXX
    fetch(allUsersRepo, userRefName + ":userRef");
    Ref userRef = allUsersRepo.getRepository().exactRef("userRef");
    assertThat(userRef).isNotNull();
    // fetch user branch using refs/users/self
    fetch(allUsersRepo, RefNames.REFS_USERS_SELF + ":userSelfRef");
    Ref userSelfRef = allUsersRepo.getRepository().getRefDatabase().exactRef("userSelfRef");
    assertThat(userSelfRef).isNotNull();
    assertThat(userSelfRef.getObjectId()).isEqualTo(userRef.getObjectId());
    accountIndexedCounter.assertNoReindex();
    // fetching user branch of another user fails
    String otherUserRefName = RefNames.refsUsers(admin.id);
    exception.expect(TransportException.class);
    exception.expectMessage("Remote does not have " + otherUserRefName + " available for fetch.");
    fetch(allUsersRepo, otherUserRefName + ":otherUserRef");
}
#method_after
@Test
public void fetchUserBranch() throws Exception {
    setApiUser(user);
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers, user);
    String userRefName = RefNames.refsUsers(user.id);
    // remove default READ permissions
    try (ProjectConfigUpdate u = updateProject(allUsers)) {
        u.getConfig().getAccessSection(RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", true).remove(new Permission(Permission.READ));
        u.save();
    }
    // deny READ permission that is inherited from All-Projects
    deny(allUsers, RefNames.REFS + "*", Permission.READ, ANONYMOUS_USERS);
    // fetching user branch without READ permission fails
    try {
        fetch(allUsersRepo, userRefName + ":userRef");
        fail("user branch is visible although no READ permission is granted");
    } catch (TransportException e) {
    // expected because no READ granted on user branch
    }
    // allow each user to read its own user branch
    grant(allUsers, RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", Permission.READ, false, REGISTERED_USERS);
    // fetch user branch using refs/users/YY/XXXXXXX
    fetch(allUsersRepo, userRefName + ":userRef");
    Ref userRef = allUsersRepo.getRepository().exactRef("userRef");
    assertThat(userRef).isNotNull();
    // fetch user branch using refs/users/self
    fetch(allUsersRepo, RefNames.REFS_USERS_SELF + ":userSelfRef");
    Ref userSelfRef = allUsersRepo.getRepository().getRefDatabase().exactRef("userSelfRef");
    assertThat(userSelfRef).isNotNull();
    assertThat(userSelfRef.getObjectId()).isEqualTo(userRef.getObjectId());
    accountIndexedCounter.assertNoReindex();
    // fetching user branch of another user fails
    String otherUserRefName = RefNames.refsUsers(admin.id);
    exception.expect(TransportException.class);
    exception.expectMessage("Remote does not have " + otherUserRefName + " available for fetch.");
    fetch(allUsersRepo, otherUserRefName + ":otherUserRef");
}
#end_block

#method_before
private void deleteGroupRef(String groupId) throws Exception {
    AccountGroup.UUID uuid = new AccountGroup.UUID(groupId);
    try (Repository repo = repoManager.openRepository(allUsers)) {
        RefUpdate ru = repo.updateRef(RefNames.refsGroups(uuid));
        ru.setForceUpdate(true);
        ru.setNewObjectId(ObjectId.zeroId());
        assertThat(ru.delete()).isEqualTo(RefUpdate.Result.FORCED);
    }
    // Reindex the group.
    gApi.groups().id(uuid.get()).index();
    // Verify "sub-group" has been deleted.
    try {
        gApi.groups().id(uuid.get()).get();
        fail();
    } catch (ResourceNotFoundException e) {
    }
}
#method_after
private void deleteGroupRef(String groupId) throws Exception {
    AccountGroup.UUID uuid = new AccountGroup.UUID(groupId);
    try (Repository repo = repoManager.openRepository(allUsers)) {
        RefUpdate ru = repo.updateRef(RefNames.refsGroups(uuid));
        ru.setForceUpdate(true);
        ru.setNewObjectId(ObjectId.zeroId());
        assertThat(ru.delete()).isEqualTo(RefUpdate.Result.FORCED);
    }
    // Reindex the group.
    gApi.groups().id(uuid.get()).index();
    // Verify "sub-group" has been deleted.
    try {
        gApi.groups().id(uuid.get()).get();
        fail("expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    }
}
#end_block

#method_before
public Set<Project.NameKey> filter(ProjectPermission perm, Collection<Project.NameKey> projects) throws PermissionBackendException {
    checkNotNull(perm, "ProjectPermission");
    checkNotNull(projects, "projects");
    Set<Project.NameKey> allowed = Sets.newHashSetWithExpectedSize(projects.size());
    for (Project.NameKey project : projects) {
        try {
            project(project).check(perm);
            allowed.add(project);
        } catch (AuthException e) {
        // Do not include this project in allowed.
        } catch (PermissionBackendException e) {
            if (e.getCause() instanceof RepositoryNotFoundException) {
            // Do not include this project because doesn't exist
            } else {
                throw e;
            }
        }
    }
    return allowed;
}
#method_after
public Set<Project.NameKey> filter(ProjectPermission perm, Collection<Project.NameKey> projects) throws PermissionBackendException {
    checkNotNull(perm, "ProjectPermission");
    checkNotNull(projects, "projects");
    Set<Project.NameKey> allowed = Sets.newHashSetWithExpectedSize(projects.size());
    for (Project.NameKey project : projects) {
        try {
            project(project).check(perm);
            allowed.add(project);
        } catch (AuthException e) {
        // Do not include this project in allowed.
        } catch (PermissionBackendException e) {
            if (e.getCause() instanceof RepositoryNotFoundException) {
                logger.warn("Could not find repository of the project {} : ", project.get(), e);
            // Do not include this project because doesn't exist
            } else {
                throw e;
            }
        }
    }
    return allowed;
}
#end_block

#method_before
public static List<Module> override(List<Module> modules, List<Module> overrideCandidates) {
    if (overrideCandidates == null || overrideCandidates.isEmpty()) {
        return modules;
    }
    // group candidates by annotation existence
    Map<Boolean, List<Module>> grouped = overrideCandidates.stream().collect(Collectors.groupingBy(m -> m.getClass().getAnnotation(Module.class) != null));
    // add all non annotated libs to modules list
    List<Module> libs = grouped.get(Boolean.FALSE);
    if (libs != null) {
        modules.addAll(libs);
    }
    List<Module> overrides = grouped.get(Boolean.TRUE);
    if (overrides == null) {
        return modules;
    }
    // swipe cache implementation with alternative provided in lib
    return modules.stream().map(m -> {
        Module a = m.getClass().getAnnotation(Module.class);
        if (a == null) {
            return m;
        }
        return overrides.stream().filter(o -> o.getClass().getAnnotation(Module.class).name().equalsIgnoreCase(a.name())).findFirst().orElse(m);
    }).collect(Collectors.toList());
}
#method_after
public static List<Module> override(List<Module> modules, List<Module> overrideCandidates) {
    if (overrideCandidates == null || overrideCandidates.isEmpty()) {
        return modules;
    }
    // group candidates by annotation existence
    Map<Boolean, List<Module>> grouped = overrideCandidates.stream().collect(Collectors.groupingBy(m -> m.getClass().getAnnotation(ModuleImpl.class) != null));
    // add all non annotated libs to modules list
    List<Module> libs = grouped.get(Boolean.FALSE);
    if (libs != null) {
        modules.addAll(libs);
    }
    List<Module> overrides = grouped.get(Boolean.TRUE);
    if (overrides == null) {
        return modules;
    }
    // swipe cache implementation with alternative provided in lib
    return modules.stream().map(m -> {
        ModuleImpl a = m.getClass().getAnnotation(ModuleImpl.class);
        if (a == null) {
            return m;
        }
        return overrides.stream().filter(o -> o.getClass().getAnnotation(ModuleImpl.class).name().equalsIgnoreCase(a.name())).findFirst().orElse(m);
    }).collect(Collectors.toList());
}
#end_block

#method_before
public static List<Module> override(List<Module> modules, List<Module> overrideCandidates) {
    if (overrideCandidates == null || overrideCandidates.isEmpty()) {
        return modules;
    }
    // group candidates by annotation existence
    Map<Boolean, List<Module>> grouped = overrideCandidates.stream().collect(Collectors.groupingBy(m -> {
        return m.getClass().getAnnotation(CacheImpl.class) != null;
    }));
    // add all non annotated libs to modules list
    List<Module> libs = grouped.get(Boolean.FALSE);
    if (libs != null) {
        modules.addAll(libs);
    }
    List<Module> overrides = grouped.get(Boolean.TRUE);
    if (overrides == null) {
        return modules;
    }
    // swipe cache implementation with alternative provided in lib
    return modules.stream().map(m -> {
        CacheImpl a = m.getClass().getAnnotation(CacheImpl.class);
        if (a == null) {
            return m;
        }
        return overrides.stream().filter(o -> {
            return o.getClass().getAnnotation(CacheImpl.class).type() == a.type();
        }).findFirst().orElse(m);
    }).collect(Collectors.toList());
}
#method_after
public static List<Module> override(List<Module> modules, List<Module> overrideCandidates) {
    if (overrideCandidates == null || overrideCandidates.isEmpty()) {
        return modules;
    }
    // group candidates by annotation existence
    Map<Boolean, List<Module>> grouped = overrideCandidates.stream().collect(Collectors.groupingBy(m -> m.getClass().getAnnotation(CacheImpl.class) != null));
    // add all non annotated libs to modules list
    List<Module> libs = grouped.get(Boolean.FALSE);
    if (libs != null) {
        modules.addAll(libs);
    }
    List<Module> overrides = grouped.get(Boolean.TRUE);
    if (overrides == null) {
        return modules;
    }
    // swipe cache implementation with alternative provided in lib
    return modules.stream().map(m -> {
        CacheImpl a = m.getClass().getAnnotation(CacheImpl.class);
        if (a == null) {
            return m;
        }
        return overrides.stream().filter(o -> o.getClass().getAnnotation(CacheImpl.class).type() == a.type()).findFirst().orElse(m);
    }).collect(Collectors.toList());
}
#end_block

#method_before
@SuppressWarnings({ "unchecked" })
@Override
public <K, V> Cache<K, V> build(CacheBinding<K, V> in) {
    H2CacheBindingProxy<K, V> def = new H2CacheBindingProxy<>(in);
    long limit = config.getLong("cache", def.name(), "diskLimit", def.diskLimit());
    if (cacheDir == null || limit <= 0) {
        return memCacheFactory.build(def);
    }
    SqlStore<K, V> store = newSqlStore(def.name(), def.keyType(), limit, def.expireAfterWrite(TimeUnit.SECONDS));
    H2CacheImpl<K, V> cache = new H2CacheImpl<>(executor, store, def.keyType(), (Cache<K, ValueHolder<V>>) memCacheFactory.build(def));
    synchronized (caches) {
        caches.add(cache);
    }
    return cache;
}
#method_after
@SuppressWarnings({ "unchecked" })
@Override
public <K, V> Cache<K, V> build(CacheBinding<K, V> in) {
    long limit = config.getLong("cache", in.name(), "diskLimit", in.diskLimit());
    if (cacheDir == null || limit <= 0) {
        return memCacheFactory.build(in);
    }
    H2CacheBindingProxy<K, V> def = new H2CacheBindingProxy<>(in);
    SqlStore<K, V> store = newSqlStore(def.name(), def.keyType(), limit, def.expireAfterWrite(TimeUnit.SECONDS));
    H2CacheImpl<K, V> cache = new H2CacheImpl<>(executor, store, def.keyType(), (Cache<K, ValueHolder<V>>) memCacheFactory.build(def));
    synchronized (caches) {
        caches.add(cache);
    }
    return cache;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public <K, V> LoadingCache<K, V> build(CacheBinding<K, V> in, CacheLoader<K, V> loader) {
    H2CacheBindingProxy<K, V> def = new H2CacheBindingProxy<>(in);
    long limit = config.getLong("cache", def.name(), "diskLimit", def.diskLimit());
    if (cacheDir == null || limit <= 0) {
        return memCacheFactory.build(def, loader);
    }
    SqlStore<K, V> store = newSqlStore(def.name(), def.keyType(), limit, def.expireAfterWrite(TimeUnit.SECONDS));
    Cache<K, ValueHolder<V>> mem = (Cache<K, ValueHolder<V>>) memCacheFactory.build(def, (CacheLoader<K, V>) new H2CacheImpl.Loader<>(executor, store, loader));
    H2CacheImpl<K, V> cache = new H2CacheImpl<>(executor, store, def.keyType(), mem);
    caches.add(cache);
    return cache;
}
#method_after
@SuppressWarnings("unchecked")
@Override
public <K, V> LoadingCache<K, V> build(CacheBinding<K, V> in, CacheLoader<K, V> loader) {
    long limit = config.getLong("cache", in.name(), "diskLimit", in.diskLimit());
    if (cacheDir == null || limit <= 0) {
        return memCacheFactory.build(in, loader);
    }
    H2CacheBindingProxy<K, V> def = new H2CacheBindingProxy<>(in);
    SqlStore<K, V> store = newSqlStore(def.name(), def.keyType(), limit, def.expireAfterWrite(TimeUnit.SECONDS));
    Cache<K, ValueHolder<V>> mem = (Cache<K, ValueHolder<V>>) memCacheFactory.build(def, (CacheLoader<K, V>) new H2CacheImpl.Loader<>(executor, store, loader));
    H2CacheImpl<K, V> cache = new H2CacheImpl<>(executor, store, def.keyType(), mem);
    synchronized (caches) {
        caches.add(cache);
    }
    return cache;
}
#end_block

#method_before
@Override
public CacheBinding<K, V> maximumWeight(long weight) {
    throw NOT_SUPPORTED;
}
#method_after
@Override
public CacheBinding<K, V> maximumWeight(long weight) {
    throw new RuntimeException(MSG_NOT_SUPPORTED);
}
#end_block

#method_before
@Override
public CacheBinding<K, V> diskLimit(long limit) {
    throw NOT_SUPPORTED;
}
#method_after
@Override
public CacheBinding<K, V> diskLimit(long limit) {
    throw new RuntimeException(MSG_NOT_SUPPORTED);
}
#end_block

#method_before
@Override
public CacheBinding<K, V> expireAfterWrite(long duration, TimeUnit durationUnits) {
    throw NOT_SUPPORTED;
}
#method_after
@Override
public CacheBinding<K, V> expireAfterWrite(long duration, TimeUnit durationUnits) {
    throw new RuntimeException(MSG_NOT_SUPPORTED);
}
#end_block

#method_before
@Override
public CacheBinding<K, V> loader(Class<? extends CacheLoader<K, V>> clazz) {
    throw NOT_SUPPORTED;
}
#method_after
@Override
public CacheBinding<K, V> loader(Class<? extends CacheLoader<K, V>> clazz) {
    throw new RuntimeException(MSG_NOT_SUPPORTED);
}
#end_block

#method_before
@Override
public CacheBinding<K, V> weigher(Class<? extends Weigher<K, V>> clazz) {
    throw NOT_SUPPORTED;
}
#method_after
@Override
public CacheBinding<K, V> weigher(Class<? extends Weigher<K, V>> clazz) {
    throw new RuntimeException(MSG_NOT_SUPPORTED);
}
#end_block

