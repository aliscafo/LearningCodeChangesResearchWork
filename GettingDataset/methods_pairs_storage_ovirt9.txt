311
#method_before
private MapSqlParameterSource getClusterParamSource(Cluster cluster) {
    return getCustomMapSqlParameterSource().addValue("description", cluster.getDescription()).addValue("name", cluster.getName()).addValue("free_text_comment", cluster.getComment()).addValue("cluster_id", cluster.getId()).addValue("cpu_name", cluster.getCpuName()).addValue("storage_pool_id", cluster.getStoragePoolId()).addValue("max_vds_memory_over_commit", cluster.getMaxVdsMemoryOverCommit()).addValue("count_threads_as_cores", cluster.getCountThreadsAsCores()).addValue("transparent_hugepages", cluster.getTransparentHugepages()).addValue("compatibility_version", cluster.getCompatibilityVersion()).addValue("migrate_on_error", cluster.getMigrateOnError()).addValue("virt_service", cluster.supportsVirtService()).addValue("gluster_service", cluster.supportsGlusterService()).addValue("gluster_cli_based_snapshot_scheduled", cluster.isGlusterCliBasedSchedulingOn()).addValue("tunnel_migration", cluster.isTunnelMigration()).addValue(ADDITIONAL_RNG_SOURCES, VmRngDevice.sourcesToCsv(cluster.getAdditionalRngSources())).addValue("emulated_machine", cluster.getEmulatedMachine()).addValue("detect_emulated_machine", cluster.isDetectEmulatedMachine()).addValue("trusted_service", cluster.supportsTrustedService()).addValue("ha_reservation", cluster.supportsHaReservation()).addValue("optional_reason", cluster.isOptionalReasonRequired()).addValue("maintenance_reason_required", cluster.isMaintenanceReasonRequired()).addValue("cluster_policy_id", cluster.getClusterPolicyId()).addValue("cluster_policy_custom_properties", SerializationFactory.getSerializer().serialize(cluster.getClusterPolicyProperties())).addValue("architecture", cluster.getArchitecture()).addValue("enable_balloon", cluster.isEnableBallooning()).addValue("optimization_type", cluster.getOptimizationType()).addValue("enable_ksm", cluster.isEnableKsm()).addValue("spice_proxy", cluster.getSpiceProxy()).addValue("serial_number_policy", cluster.getSerialNumberPolicy() == null ? null : cluster.getSerialNumberPolicy().getValue()).addValue("custom_serial_number", cluster.getCustomSerialNumber()).addValue("skip_fencing_if_sd_active", cluster.getFencingPolicy().isSkipFencingIfSDActive()).addValue("skip_fencing_if_connectivity_broken", cluster.getFencingPolicy().isSkipFencingIfConnectivityBroken()).addValue("hosts_with_broken_connectivity_threshold", cluster.getFencingPolicy().getHostsWithBrokenConnectivityThreshold()).addValue("fencing_enabled", cluster.getFencingPolicy().isFencingEnabled()).addValue("is_auto_converge", cluster.getAutoConverge()).addValue("is_migrate_compressed", cluster.getMigrateCompressed()).addValue("gluster_tuned_profile", cluster.getGlusterTunedProfile()).addValue("ksm_merge_across_nodes", cluster.isKsmMergeAcrossNumaNodes()).addValue("migration_bandwidth_limit_type", cluster.getMigrationBandwidthLimitType().name()).addValue("custom_migration_bandwidth_limit", cluster.getCustomMigrationNetworkBandwidth()).addValue("migration_policy_id", cluster.getMigrationPolicyId()).addValue("mac_pool_id", cluster.getMacPoolId()).addValue("switch_type", cluster.getRequiredSwitchTypeForCluster().getOptionValue()).addValue("skip_fencing_if_gluster_bricks_up", cluster.getFencingPolicy().isSkipFencingIfGlusterBricksUp()).addValue("skip_fencing_if_gluster_quorum_not_met", cluster.getFencingPolicy().isSkipFencingIfGlusterQuorumNotMet());
}
#method_after
private MapSqlParameterSource getClusterParamSource(Cluster cluster) {
    return getCustomMapSqlParameterSource().addValue("description", cluster.getDescription()).addValue("name", cluster.getName()).addValue("free_text_comment", cluster.getComment()).addValue("cluster_id", cluster.getId()).addValue("cpu_name", cluster.getCpuName()).addValue("storage_pool_id", cluster.getStoragePoolId()).addValue("max_vds_memory_over_commit", cluster.getMaxVdsMemoryOverCommit()).addValue("count_threads_as_cores", cluster.getCountThreadsAsCores()).addValue("transparent_hugepages", cluster.getTransparentHugepages()).addValue("compatibility_version", cluster.getCompatibilityVersion()).addValue("migrate_on_error", cluster.getMigrateOnError()).addValue("virt_service", cluster.supportsVirtService()).addValue("gluster_service", cluster.supportsGlusterService()).addValue("gluster_cli_based_snapshot_scheduled", cluster.isGlusterCliBasedSchedulingOn()).addValue("tunnel_migration", cluster.isTunnelMigration()).addValue("additional_rng_sources", VmRngDevice.sourcesToCsv(cluster.getAdditionalRngSources())).addValue("emulated_machine", cluster.getEmulatedMachine()).addValue("detect_emulated_machine", cluster.isDetectEmulatedMachine()).addValue("trusted_service", cluster.supportsTrustedService()).addValue("ha_reservation", cluster.supportsHaReservation()).addValue("optional_reason", cluster.isOptionalReasonRequired()).addValue("maintenance_reason_required", cluster.isMaintenanceReasonRequired()).addValue("cluster_policy_id", cluster.getClusterPolicyId()).addValue("cluster_policy_custom_properties", SerializationFactory.getSerializer().serialize(cluster.getClusterPolicyProperties())).addValue("architecture", cluster.getArchitecture()).addValue("enable_balloon", cluster.isEnableBallooning()).addValue("optimization_type", cluster.getOptimizationType()).addValue("enable_ksm", cluster.isEnableKsm()).addValue("spice_proxy", cluster.getSpiceProxy()).addValue("serial_number_policy", cluster.getSerialNumberPolicy() == null ? null : cluster.getSerialNumberPolicy().getValue()).addValue("custom_serial_number", cluster.getCustomSerialNumber()).addValue("skip_fencing_if_sd_active", cluster.getFencingPolicy().isSkipFencingIfSDActive()).addValue("skip_fencing_if_connectivity_broken", cluster.getFencingPolicy().isSkipFencingIfConnectivityBroken()).addValue("hosts_with_broken_connectivity_threshold", cluster.getFencingPolicy().getHostsWithBrokenConnectivityThreshold()).addValue("fencing_enabled", cluster.getFencingPolicy().isFencingEnabled()).addValue("is_auto_converge", cluster.getAutoConverge()).addValue("is_migrate_compressed", cluster.getMigrateCompressed()).addValue("gluster_tuned_profile", cluster.getGlusterTunedProfile()).addValue("ksm_merge_across_nodes", cluster.isKsmMergeAcrossNumaNodes()).addValue("migration_bandwidth_limit_type", cluster.getMigrationBandwidthLimitType().name()).addValue("custom_migration_bandwidth_limit", cluster.getCustomMigrationNetworkBandwidth()).addValue("migration_policy_id", cluster.getMigrationPolicyId()).addValue("mac_pool_id", cluster.getMacPoolId()).addValue("switch_type", cluster.getRequiredSwitchTypeForCluster().getOptionValue()).addValue("skip_fencing_if_gluster_bricks_up", cluster.getFencingPolicy().isSkipFencingIfGlusterBricksUp()).addValue("skip_fencing_if_gluster_quorum_not_met", cluster.getFencingPolicy().isSkipFencingIfGlusterQuorumNotMet());
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    if (oldCluster == null) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldCluster.getName(), getCluster().getName())) {
        if (!isClusterUnique(getCluster().getName())) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getCluster().getCompatibilityVersion())) {
        addValidationMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForCluster = getVdsDao().getAllForCluster(oldCluster.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getCluster().getCompatibilityVersion().compareTo(oldCluster.getCompatibilityVersion()) < 0) {
        if (!allForCluster.isEmpty()) {
            result = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_CLUSTER_WITH_HOSTS_COMPATIBILITY_VERSION);
        }
        if (oldCluster.getStoragePoolId() != null) {
            ClusterValidator validator = new ClusterValidator(getDbFacade(), oldCluster, getCpuFlagsManagerHandler());
            if (!validate(validator.dataCenterVersionMismatch())) {
                result = false;
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldCluster.getStoragePoolId() != null && !oldCluster.getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForCluster);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getCluster().supportsVirtService() && (oldCluster.getCpuName() != null || getCluster().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addValidationMessage(EngineMessage.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldCluster.getCpuName()) && !checkIfCpusSameManufacture(oldCluster) && !allVdssInMaintenance) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDao().getAllForCluster(oldCluster.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForCluster.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getCluster().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldCluster.getCpuName(), getCluster().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldCluster.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldCluster) && hasVmOrHost) {
            addValidationMessage(EngineMessage.CLUSTER_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result && !oldCluster.getCompatibilityVersion().equals(getCluster().getCompatibilityVersion())) {
        for (VM vm : vmList) {
            if (vm.isPreviewSnapshot()) {
                // can't change cluster version when a VM is in preview
                if (result) {
                    addValidationMessage(EngineMessage.CLUSTER_VERSION_CHANGE_VM_PREVIEW);
                    // and continue with adding validation messages
                    result = false;
                }
                addValidationMessage(vm.getName());
            }
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldCluster.getStoragePoolId() == null && getCluster().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetworkAttachement()) {
            return false;
        }
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getCluster().getCompatibilityVersion(), vds)) {
                result = false;
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getCluster().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
            if (!isSupportedEmulatedMachinesMatchClusterLevel(vds)) {
                return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_INCOMPATIBLE_EMULATED_MACHINE);
            }
        }
        if (result) {
            Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
            // New Features cannot be enabled if all up hosts are not supporting the selected feature
            if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(vdss, additionalClusterFeaturesAdded)) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
                result = false;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldCluster);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("Cluster", getParameters().getCluster().getName());
                        auditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getCluster().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDao().get(getCluster().getStoragePoolId());
        if (oldCluster.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getClusterDao().getAllForStoragePool(getCluster().getStoragePoolId()).isEmpty()) {
                getReturnValue().getValidationMessages().add(EngineMessage.CLUSTER_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultClusterID).equals(getCluster().getId())) {
                addValidationMessage(EngineMessage.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (result) {
        if (!(getCluster().supportsGlusterService() || getCluster().supportsVirtService())) {
            addValidationMessage(EngineMessage.CLUSTER_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getCluster().supportsGlusterService() && getCluster().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addValidationMessage(EngineMessage.CLUSTER_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getCluster().supportsVirtService()) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getCluster().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getCluster().getId());
        if (volumes != null && volumes.size() > 0) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getCluster().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getCluster().getCompatibilityVersion()) && getCluster().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failValidation(EngineMessage.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy(oldCluster);
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                addValidationMessage(EngineMessage.CLUSTER_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    if (result && Version.v3_6.compareTo(getCluster().getCompatibilityVersion()) <= 0) {
        List<String> names = new ArrayList<>();
        for (VDS host : allForCluster) {
            if (VdsProtocol.XML == host.getProtocol()) {
                names.add(host.getName());
            }
        }
        if (!names.isEmpty()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_WRONG_PROTOCOL_FOR_CLUSTER_VERSION);
        }
    }
    if (!result) {
        return result;
    }
    final ClusterValidator clusterValidator = new ClusterValidator(getDbFacade(), getCluster(), cpuFlagsManagerHandler);
    if (validate(clusterValidator.rngSourcesAllowed())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    if (oldCluster == null) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldCluster.getName(), getCluster().getName())) {
        if (!isClusterUnique(getCluster().getName())) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getCluster().getCompatibilityVersion())) {
        addValidationMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForCluster = getVdsDao().getAllForCluster(oldCluster.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getCluster().getCompatibilityVersion().compareTo(oldCluster.getCompatibilityVersion()) < 0) {
        if (!allForCluster.isEmpty()) {
            result = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_CLUSTER_WITH_HOSTS_COMPATIBILITY_VERSION);
        }
        if (oldCluster.getStoragePoolId() != null) {
            ClusterValidator validator = new ClusterValidator(getDbFacade(), oldCluster, getCpuFlagsManagerHandler());
            if (!validate(validator.dataCenterVersionMismatch())) {
                result = false;
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldCluster.getStoragePoolId() != null && !oldCluster.getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForCluster);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getCluster().supportsVirtService() && (oldCluster.getCpuName() != null || getCluster().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addValidationMessage(EngineMessage.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldCluster.getCpuName()) && !checkIfCpusSameManufacture(oldCluster) && !allVdssInMaintenance) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDao().getAllForCluster(oldCluster.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForCluster.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getCluster().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldCluster.getCpuName(), getCluster().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldCluster.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldCluster) && hasVmOrHost) {
            addValidationMessage(EngineMessage.CLUSTER_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result && !oldCluster.getCompatibilityVersion().equals(getCluster().getCompatibilityVersion())) {
        for (VM vm : vmList) {
            if (vm.isPreviewSnapshot()) {
                // can't change cluster version when a VM is in preview
                if (result) {
                    addValidationMessage(EngineMessage.CLUSTER_VERSION_CHANGE_VM_PREVIEW);
                    // and continue with adding validation messages
                    result = false;
                }
                addValidationMessage(vm.getName());
            }
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldCluster.getStoragePoolId() == null && getCluster().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetworkAttachement()) {
            return false;
        }
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getCluster().getCompatibilityVersion(), vds)) {
                result = false;
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getCluster().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
            if (!isSupportedEmulatedMachinesMatchClusterLevel(vds)) {
                return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_INCOMPATIBLE_EMULATED_MACHINE);
            }
        }
        if (result) {
            Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
            // New Features cannot be enabled if all up hosts are not supporting the selected feature
            if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(vdss, additionalClusterFeaturesAdded)) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
                result = false;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldCluster);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("Cluster", getParameters().getCluster().getName());
                        auditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getCluster().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDao().get(getCluster().getStoragePoolId());
        if (oldCluster.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getClusterDao().getAllForStoragePool(getCluster().getStoragePoolId()).isEmpty()) {
                getReturnValue().getValidationMessages().add(EngineMessage.CLUSTER_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultClusterID).equals(getCluster().getId())) {
                addValidationMessage(EngineMessage.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (result) {
        if (!(getCluster().supportsGlusterService() || getCluster().supportsVirtService())) {
            addValidationMessage(EngineMessage.CLUSTER_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getCluster().supportsGlusterService() && getCluster().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addValidationMessage(EngineMessage.CLUSTER_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getCluster().supportsVirtService()) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getCluster().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getCluster().getId());
        if (volumes != null && volumes.size() > 0) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getCluster().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getCluster().getCompatibilityVersion()) && getCluster().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failValidation(EngineMessage.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy(oldCluster);
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                addValidationMessage(EngineMessage.CLUSTER_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    if (result && Version.v3_6.compareTo(getCluster().getCompatibilityVersion()) <= 0) {
        List<String> names = new ArrayList<>();
        for (VDS host : allForCluster) {
            if (VdsProtocol.XML == host.getProtocol()) {
                names.add(host.getName());
            }
        }
        if (!names.isEmpty()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_WRONG_PROTOCOL_FOR_CLUSTER_VERSION);
        }
    }
    result = result && validate(new ClusterValidator(getDbFacade(), getCluster(), cpuFlagsManagerHandler).rngSourcesAllowed());
    return result;
}
#end_block

#method_before
public ValidationResult rngSourcesAllowed() {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_RANDOM_RNG_SOURCE_CANT_BE_ADDED_TO_CLUSTER_ADDITIONAL_RNG_SOURCES).unless(Collections.singleton(VmRngDevice.Source.HWRNG).containsAll(cluster.getAdditionalRngSources()));
}
#method_after
public ValidationResult rngSourcesAllowed() {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_RANDOM_RNG_SOURCE_CANT_BE_ADDED_TO_CLUSTER_ADDITIONAL_RNG_SOURCES).unless(ALLOWED_ADDITIONAL_RNG_SOURCES.containsAll(cluster.getAdditionalRngSources()));
}
#end_block

#method_before
List getNetworkInterfaces(VM vm) {
    List net = new ArrayList();
    List<Device> nicDevices = vm.getDevicesByType(Device.DeviceType.NIC);
    for (Device device : nicDevices) {
        Map resultMap = new HashMap();
        List templist = new ArrayList();
        List templist2 = new ArrayList();
        resultMap.put("name", "eth0");
        templist.add("fe80::21a:4aff:fe16:2016");
        templist.add("2620:52:0:2380:21a:4aff:fe16:2016");
        resultMap.put("inet6", templist);
        templist2.add(vm.getIp());
        resultMap.put("inet", templist2);
        resultMap.put("hw", vm.getMacAddress());
        net.add(resultMap);
        break;
    }
    log.debug("network list is {}", net.toString());
    return net;
}
#method_after
List<Map<String, Object>> getNetworkInterfaces(VM vm) {
    Map<String, Object> resultMap = new HashMap();
    List<String> inet6Addresses = new ArrayList<>();
    List<String> inet4Addresses = new ArrayList<>();
    List<Map<String, Object>> nets = new ArrayList<>();
    resultMap.put("name", "eth0");
    inet6Addresses.add("fe80::21a:4aff:fe16:2016");
    inet6Addresses.add("2620:52:0:2380:21a:4aff:fe16:2016");
    resultMap.put("inet6", inet6Addresses);
    inet4Addresses.add(vm.getIp());
    resultMap.put("inet", inet4Addresses);
    resultMap.put("hw", vm.getMacAddress());
    nets.add(resultMap);
    log.debug("network list is {}", nets.toString());
    return nets;
}
#end_block

#method_before
Map getNetworkStatsMap(VM vm) {
    List<Device> nicDevices = vm.getDevicesByType(Device.DeviceType.NIC);
    String macAddress = vm.getMacAddress();
    if (macAddress.equals(VM.NONE_STRING)) {
        log.debug("no mac address for vm {}", vm.getId());
        return map();
    }
    Map resultMap = map();
    int count = 0;
    for (Device device : nicDevices) {
        Map netStats = map();
        String dName = "vnet" + count;
        netStats.put("txErrors", "0");
        netStats.put("state", "unknown");
        // 00:1a:4a:16:01:51
        netStats.put("macAddr", device.getMacAddr());
        netStats.put("name", dName);
        netStats.put("txDropped", "0");
        netStats.put("txRate", Utils.rangeParsser(AppConfig.getInstance().getNetworkLoadValues()));
        netStats.put("rxErrors", "0");
        netStats.put("rxRate", Utils.rangeParsser(AppConfig.getInstance().getNetworkLoadValues()));
        netStats.put("tx", Utils.rangeParsser(AppConfig.getInstance().getNetworkLoadValues()));
        netStats.put("rx", Utils.rangeParsser(AppConfig.getInstance().getNetworkLoadValues()));
        netStats.put("rxDropped", "0");
        netStats.put("speed", "1000");
        netStats.put("sampleTime", "4318787.08");
        resultMap.put(dName, netStats);
        ++count;
    }
    return resultMap;
}
#method_after
Map getNetworkStatsMap(VM vm) {
    List<Device> nicDevices = vm.getDevicesByType(Device.DeviceType.NIC);
    String macAddress = vm.getMacAddress();
    if (macAddress.equals(VM.NONE_STRING)) {
        log.debug("no mac address for vm {}", vm.getId());
        return map();
    }
    Map resultMap = map();
    int count = 0;
    for (Device device : nicDevices) {
        ArrayList loadValues = AppConfig.getInstance().getNetworkLoadValues();
        Map netStats = map();
        String dName = "vnet" + count;
        netStats.put("txErrors", "0");
        netStats.put("state", "unknown");
        netStats.put("macAddr", device.getMacAddr());
        netStats.put("name", dName);
        netStats.put("txDropped", "0");
        netStats.put("txRate", Utils.rangeParsser(loadValues));
        netStats.put("rxErrors", "0");
        netStats.put("rxRate", Utils.rangeParsser(loadValues));
        netStats.put("tx", Utils.rangeParsser(loadValues));
        netStats.put("rx", Utils.rangeParsser(loadValues));
        netStats.put("rxDropped", "0");
        netStats.put("speed", "1000");
        netStats.put("sampleTime", "4318787.08");
        resultMap.put(dName, netStats);
        ++count;
    }
    return resultMap;
}
#end_block

#method_before
private Map fillVmStatsMap(VM vm) {
    AppConfig appConfig = AppConfig.getInstance();
    Map vmStatMap = VMInfoService.getInstance().getFromKeys(vm, VmStatsKeys);
    vmStatMap.put("status", vm.getStatus().toString());
    // ip validation if no exist set ip, for vms which already registered in the setup
    if (vm.getIp() == null || vm.getIp().equals("0.0.0.0") || vm.getIp().isEmpty() || vm.getIp().equals("?")) {
        vm.setIp(Utils.ipGenerator());
    }
    // missing data
    Map dis = map();
    ArrayList display = new ArrayList();
    dis.put("tlsPort", "5900");
    dis.put("ipAddress", vm.getIp());
    dis.put("type", "spice");
    dis.put("port", "-1");
    display.add(dis);
    vmStatMap.put("displayInfo", display);
    vmStatMap.put("pid", "1111");
    vmStatMap.put("session", "Unknown");
    vmStatMap.put("timeOffset", "0");
    vmStatMap.put("pauseCode", "NOERR");
    Map ballon = map();
    // TODO: compute 10% from the actual mem for ballooning.
    ballon.put("balloon_max", "2048");
    ballon.put("balloon_min", "1024");
    ballon.put("balloon_target", "2048");
    ballon.put("balloon_cur", "512");
    vmStatMap.put("balloonInfo", ballon);
    vmStatMap.put("guestIPs", vm.getIp());
    vmStatMap.put("guestName", "localhost.localdomain");
    vmStatMap.put("guestFQDN", "localhost.localdomain");
    vmStatMap.put("guestOs", " 2.6.32-504.1.3.el6.x86_64");
    vmStatMap.put("guestCPUCount", "-1");
    // cpu
    vmStatMap.put("cpuSys", Utils.rangeParsser(appConfig.getCpuLoadValues()));
    vmStatMap.put("cpuLoad", Utils.rangeParsser(appConfig.getCpuLoadValues()));
    vmStatMap.put("cpuUser", Utils.rangeParsser(appConfig.getCpuLoadValues()));
    // memory
    vmStatMap.put("memUsage", Utils.rangeParsser(appConfig.getMemLoadValues()));
    // network
    vmStatMap.put("netIfaces", getNetworkInterfaces(vm));
    Map network = getNetworkStatsMap(vm);
    if (!network.isEmpty()) {
        vmStatMap.put("network", network);
    }
    Map disks = getVMDisksMap(vm);
    if (!disks.isEmpty()) {
        vmStatMap.put("disks", disks);
    }
    vmStatMap.put("elapsedTime", vm.getElapsedTimeInSeconds());
    vmStatMap.put("vcpuCount", "1");
    vmStatMap.put("clientIp", "");
    vmStatMap.put("hash", Integer.toString(vm.hashCode()));
    vmStatMap.put("vmType", "kvm");
    vmStatMap.put("vmId", vm.getId());
    vmStatMap.put("displayIp", vm.getIp());
    vmStatMap.put("vcpuPeriod", 100000);
    vmStatMap.put("displayPort", "-1");
    vmStatMap.put("vcpuQuota", "-1");
    vmStatMap.put("kvmEnable", "true");
    vmStatMap.put("monitorResponse", "0");
    vmStatMap.put("statsAge", "2.46");
    vmStatMap.put("username", "None");
    vmStatMap.put("lastLogin", 1426169218.410367);
    ArrayList emptylist = new ArrayList();
    vmStatMap.put("ioTune", emptylist);
    vmStatMap.put("displaySecurePort", "5900");
    vmStatMap.put("vmJobs", map());
    Map memstats = map();
    if (!vmStatMap.get("memUsage").toString().isEmpty()) {
        memstats.put("swap_out", "0");
        memstats.put("majflt", "0");
        memstats.put("swap_usage", "0");
        memstats.put("swap_total", "0");
        memstats.put("swap_in", "0");
        memstats.put("mem_free", Integer.toString(vm.getMemSize() - Integer.valueOf(vmStatMap.get("memUsage").toString())));
        memstats.put("pageflt", "131");
        memstats.put("mem_total", Integer.toString(vm.getMemSize()));
        memstats.put("mem_unused", memstats.get("mem_free"));
        vmStatMap.put("memoryStats", memstats);
    }
    // adding app list
    ArrayList applist = new ArrayList();
    applist.add("kernel-2.6.32-431.el6");
    applist.add("rhevm-guest-agent-common-1.0.9-1.el6ev");
    vmStatMap.put("appsList", applist);
    vmStatMap.put("displayType", "qxl");
    return vmStatMap;
}
#method_after
private Map fillVmStatsMap(VM vm) {
    AppConfig appConfig = AppConfig.getInstance();
    Map vmStatMap = VMInfoService.getInstance().getFromKeys(vm, VmStatsKeys);
    vmStatMap.put("status", vm.getStatus().toString());
    // ip validation if no exist set ip, for vms which already registered in the setup
    if (vm.getIp() == null || vm.getIp().equals("0.0.0.0") || vm.getIp().isEmpty() || vm.getIp().equals("?")) {
        vm.setIp(Utils.ipGenerator());
    }
    // missing data
    Map dis = map();
    ArrayList display = new ArrayList();
    dis.put("tlsPort", "5900");
    dis.put("ipAddress", vm.getIp());
    dis.put("type", "spice");
    dis.put("port", "-1");
    display.add(dis);
    vmStatMap.put("displayInfo", display);
    vmStatMap.put("pid", "1111");
    vmStatMap.put("session", "Unknown");
    vmStatMap.put("timeOffset", "0");
    vmStatMap.put("pauseCode", "NOERR");
    Map ballon = map();
    // TODO: compute 10% from the actual mem for ballooning.
    ballon.put("balloon_max", "2048");
    ballon.put("balloon_min", "1024");
    ballon.put("balloon_target", "2048");
    ballon.put("balloon_cur", "512");
    vmStatMap.put("balloonInfo", ballon);
    vmStatMap.put("guestIPs", vm.getIp());
    vmStatMap.put("guestName", "localhost.localdomain");
    vmStatMap.put("guestFQDN", "localhost.localdomain");
    vmStatMap.put("guestOs", "2.6.32-642.el6.x86_64");
    vmStatMap.put("guestOsInfo", getGuestOsInto());
    vmStatMap.put("guestCPUCount", "1");
    vmStatMap.put("guestTimezone", getGuestTimeZone());
    // cpu
    vmStatMap.put("cpuSys", Utils.rangeParsser(appConfig.getCpuLoadValues()));
    vmStatMap.put("cpuLoad", Utils.rangeParsser(appConfig.getCpuLoadValues()));
    vmStatMap.put("cpuUser", Utils.rangeParsser(appConfig.getCpuLoadValues()));
    // memory
    vmStatMap.put("memUsage", Utils.rangeParsser(appConfig.getMemLoadValues()));
    // network
    vmStatMap.put("netIfaces", getNetworkInterfaces(vm));
    Map network = getNetworkStatsMap(vm);
    if (!network.isEmpty()) {
        vmStatMap.put("network", network);
    }
    Map disks = getVMDisksMap(vm);
    if (!disks.isEmpty()) {
        vmStatMap.put("disks", disks);
    }
    vmStatMap.put("elapsedTime", vm.getElapsedTimeInSeconds());
    vmStatMap.put("vcpuCount", "1");
    vmStatMap.put("clientIp", "");
    vmStatMap.put("hash", Integer.toString(vm.hashCode()));
    vmStatMap.put("vmType", "kvm");
    vmStatMap.put("vmId", vm.getId());
    vmStatMap.put("displayIp", vm.getIp());
    vmStatMap.put("vcpuPeriod", 100000);
    vmStatMap.put("displayPort", "-1");
    vmStatMap.put("vcpuQuota", "-1");
    vmStatMap.put("kvmEnable", "true");
    vmStatMap.put("monitorResponse", "0");
    vmStatMap.put("statsAge", "2.46");
    vmStatMap.put("username", "None");
    vmStatMap.put("lastLogin", 1426169218.410367);
    ArrayList emptylist = new ArrayList();
    vmStatMap.put("ioTune", emptylist);
    vmStatMap.put("displaySecurePort", "5900");
    vmStatMap.put("vmJobs", map());
    Map memstats = map();
    if (!vmStatMap.get("memUsage").toString().isEmpty()) {
        memstats.put("swap_out", "0");
        memstats.put("majflt", "0");
        memstats.put("swap_usage", "0");
        memstats.put("swap_total", "0");
        memstats.put("swap_in", "0");
        memstats.put("mem_free", Integer.toString(vm.getMemSize() - Integer.valueOf(vmStatMap.get("memUsage").toString())));
        memstats.put("pageflt", "131");
        memstats.put("mem_total", Integer.toString(vm.getMemSize()));
        memstats.put("mem_unused", memstats.get("mem_free"));
        vmStatMap.put("memoryStats", memstats);
    }
    // adding app list
    ArrayList applist = new ArrayList();
    applist.add("kernel-2.6.32-431.el6");
    applist.add("rhevm-guest-agent-common-1.0.9-1.el6ev");
    vmStatMap.put("appsList", applist);
    vmStatMap.put("displayType", "qxl");
    return vmStatMap;
}
#end_block

#method_before
@Override
public Optional<BalanceResult> balance(final Cluster cluster, List<VDS> hosts, Map<String, String> parameters, ArrayList<String> messages) {
    Objects.requireNonNull(hosts);
    Objects.requireNonNull(cluster);
    if (hosts.size() < 2) {
        log.debug("No balancing for cluster '{}', contains only {} host(s)", cluster.getName(), hosts.size());
        return Optional.empty();
    }
    final List<VDS> overUtilizedPrimaryHosts = getPrimarySources(cluster, hosts, parameters);
    final List<VDS> overUtilizedSecondaryHosts = getSecondarySources(cluster, hosts, parameters);
    // if there aren't any overutilized hosts, then there is nothing to balance...
    if ((overUtilizedPrimaryHosts == null || overUtilizedPrimaryHosts.size() == 0) && (overUtilizedSecondaryHosts == null || overUtilizedSecondaryHosts.size() == 0)) {
        log.debug("There is no over-utilized host in cluster '{}'", cluster.getName());
        return Optional.empty();
    }
    List<VDS> destinationHosts = null;
    VM vmToMigrate = null;
    FindVmAndDestinations findVmAndDestinations = getFindVmAndDestinations(cluster, parameters);
    // try balancing based on CPU first
    if (overUtilizedPrimaryHosts != null && overUtilizedPrimaryHosts.size() > 0) {
        // returns hosts with utilization lower than the specified threshold
        List<VDS> underUtilizedHosts = getPrimaryDestinations(cluster, hosts, parameters);
        /* if no host has a spare power, then there is nothing we can do to balance it here, try
               the secondary aporoach */
        if (underUtilizedHosts == null || underUtilizedHosts.size() == 0) {
            log.warn("All candidate hosts have been filtered, can't balance the cluster '{}'" + " based on the CPU usage, will try memory based approach", cluster.getName());
        } else {
            Optional<FindVmAndDestinations.Result> result = findVmAndDestinations.invoke(overUtilizedPrimaryHosts, underUtilizedHosts, getVmDao(), getVmStatisticsDao());
            if (result.isPresent()) {
                destinationHosts = result.get().getDestinationHosts();
                vmToMigrate = result.get().getVmToMigrate();
            }
        }
    }
    // if it is not possible (or necessary) to balance based on CPU, try with memory
    if ((destinationHosts == null || destinationHosts.size() == 0 || vmToMigrate == null) && (overUtilizedSecondaryHosts != null && overUtilizedSecondaryHosts.size() > 0)) {
        // returns hosts with more free memory than the specified threshold
        List<VDS> underUtilizedHosts = getSecondaryDestinations(cluster, hosts, parameters);
        // if no host has memory to spare, then there is nothing we can do to balance it..
        if (underUtilizedHosts == null || underUtilizedHosts.size() == 0) {
            log.warn("All candidate hosts have been filtered, can't balance the cluster '{}'" + " using memory based approach", cluster.getName());
            return Optional.empty();
        }
        Optional<FindVmAndDestinations.Result> result = findVmAndDestinations.invoke(overUtilizedSecondaryHosts, underUtilizedHosts, getVmDao(), getVmStatisticsDao());
        if (result.isPresent()) {
            destinationHosts = result.get().getDestinationHosts();
            vmToMigrate = result.get().getVmToMigrate();
        }
    }
    if (destinationHosts == null || destinationHosts.size() == 0 || vmToMigrate == null) {
        return Optional.empty();
    }
    List<Guid> destinationHostsKeys = destinationHosts.stream().map(VDS::getId).collect(Collectors.toList());
    return Optional.of(new BalanceResult(vmToMigrate.getId(), destinationHostsKeys));
}
#method_after
@Override
public Optional<BalanceResult> balance(final Cluster cluster, List<VDS> hosts, Map<String, String> parameters, ArrayList<String> messages) {
    Objects.requireNonNull(hosts);
    Objects.requireNonNull(cluster);
    if (hosts.size() < 2) {
        log.debug("No balancing for cluster '{}', contains only {} host(s)", cluster.getName(), hosts.size());
        return Optional.empty();
    }
    final List<VDS> overUtilizedPrimaryHosts = getPrimarySources(cluster, hosts, parameters);
    final List<VDS> overUtilizedSecondaryHosts = getSecondarySources(cluster, hosts, parameters);
    // if there aren't any overutilized hosts, then there is nothing to balance...
    if ((overUtilizedPrimaryHosts == null || overUtilizedPrimaryHosts.size() == 0) && (overUtilizedSecondaryHosts == null || overUtilizedSecondaryHosts.size() == 0)) {
        log.debug("There is no over-utilized host in cluster '{}'", cluster.getName());
        return Optional.empty();
    }
    FindVmAndDestinations findVmAndDestinations = getFindVmAndDestinations(cluster, parameters);
    Optional<BalanceResult> result = Optional.empty();
    // try balancing based on CPU first
    if (overUtilizedPrimaryHosts != null && overUtilizedPrimaryHosts.size() > 0) {
        // returns hosts with utilization lower than the specified threshold
        List<VDS> underUtilizedHosts = getPrimaryDestinations(cluster, hosts, parameters);
        /* if no host has a spare power, then there is nothing we can do to balance it here, try
               the secondary aporoach */
        if (underUtilizedHosts == null || underUtilizedHosts.size() == 0) {
            log.warn("All candidate hosts have been filtered, can't balance the cluster '{}'" + " based on the CPU usage, will try memory based approach", cluster.getName());
        } else {
            result = getBalance(findVmAndDestinations, overUtilizedPrimaryHosts, underUtilizedHosts);
        }
    }
    // if it is not possible (or necessary) to balance based on CPU, try with memory
    if (!result.isPresent() && (overUtilizedSecondaryHosts != null && overUtilizedSecondaryHosts.size() > 0)) {
        // returns hosts with more free memory than the specified threshold
        List<VDS> underUtilizedHosts = getSecondaryDestinations(cluster, hosts, parameters);
        // if no host has memory to spare, then there is nothing we can do to balance it..
        if (underUtilizedHosts == null || underUtilizedHosts.size() == 0) {
            log.warn("All candidate hosts have been filtered, can't balance the cluster '{}'" + " using memory based approach", cluster.getName());
            return Optional.empty();
        }
        result = getBalance(findVmAndDestinations, overUtilizedSecondaryHosts, underUtilizedHosts);
    }
    return result;
}
#end_block

#method_before
private static IpVersion getIpVersion(IpAddressAssignment ipAddressAssignment) {
    // Get the IP address, as we need to do multiple accesses and checks:
    Ip ip = ipAddressAssignment.getIp();
    if (ip == null) {
        return null;
    }
    // If the IP version is explicitly specified, then use it:
    if (ip.isSetVersion()) {
        return ip.getVersion();
    }
    // If there is no explicit IP version then we can try to infer it from the address, but only if it has been
    // provided:
    String address = ip.getAddress();
    if (address == null) {
        return null;
    }
    // IPv4 address can contain a colon, and all valid IPv6 addresses must contain at least one colon.
    return address.indexOf(':') == -1 ? IpVersion.V4 : IpVersion.V6;
}
#method_after
private static IpVersion getIpVersion(IpAddressAssignment ipAddressAssignment) {
    return IpHelper.getVersion(ipAddressAssignment.getIp());
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.network.NetworkAttachment.class, to = NetworkAttachment.class)
public static NetworkAttachment map(org.ovirt.engine.core.common.businessentities.network.NetworkAttachment entity, NetworkAttachment template) {
    NetworkAttachment model = template == null ? new NetworkAttachment() : template;
    if (entity.getId() != null) {
        model.setId(entity.getId().toString());
    }
    if (entity.getNetworkId() != null) {
        getModelNetwork(model).setId(entity.getNetworkId().toString());
    }
    if (entity.getNetworkName() != null) {
        if (model.getNetwork() == null) {
            model.setNetwork(new Network());
        }
        model.getNetwork().setName(entity.getNetworkName());
    }
    if (entity.getNicId() != null) {
        getModelHostNic(model).setId(entity.getNicId().toString());
    }
    if (entity.hasProperties()) {
        model.setProperties(CustomPropertiesParser.fromMap(entity.getProperties()));
    }
    org.ovirt.engine.core.common.businessentities.network.IpConfiguration entityIpConfiguration = entity.getIpConfiguration();
    if (entityIpConfiguration != null) {
        model.setIpAddressAssignments(new IpAddressAssignments());
        if (!entityIpConfiguration.getIPv4Addresses().isEmpty()) {
            entityIpConfiguration.getIPv4Addresses().stream().map(NetworkAttachmentMapper::mapIpv4Address).forEach(model.getIpAddressAssignments().getIpAddressAssignments()::add);
        }
        if (!entityIpConfiguration.getIpV6Addresses().isEmpty()) {
            entityIpConfiguration.getIpV6Addresses().stream().map(NetworkAttachmentMapper::mapIpv6AddressAssignment).forEach(model.getIpAddressAssignments().getIpAddressAssignments()::add);
        }
    }
    if (entity.getReportedConfigurations() != null) {
        model.setInSync(entity.getReportedConfigurations().isNetworkInSync());
        model.setReportedConfigurations(ReportedConfigurationsMapper.map(entity.getReportedConfigurations(), null));
    }
    AnonymousHostNetworkQos hostNetworkQos = entity.getHostNetworkQos();
    if (hostNetworkQos != null) {
        model.setQos(QosMapper.map(HostNetworkQos.fromAnonymousHostNetworkQos(hostNetworkQos), null));
    }
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.network.NetworkAttachment.class, to = NetworkAttachment.class)
public static NetworkAttachment map(org.ovirt.engine.core.common.businessentities.network.NetworkAttachment entity, NetworkAttachment template) {
    NetworkAttachment model = template == null ? new NetworkAttachment() : template;
    if (entity.getId() != null) {
        model.setId(entity.getId().toString());
    }
    if (entity.getNetworkId() != null) {
        getModelNetwork(model).setId(entity.getNetworkId().toString());
    }
    if (entity.getNicId() != null) {
        getModelHostNic(model).setId(entity.getNicId().toString());
    }
    if (entity.hasProperties()) {
        model.setProperties(CustomPropertiesParser.fromMap(entity.getProperties()));
    }
    org.ovirt.engine.core.common.businessentities.network.IpConfiguration entityIpConfiguration = entity.getIpConfiguration();
    if (entityIpConfiguration != null) {
        model.setIpAddressAssignments(new IpAddressAssignments());
        if (!entityIpConfiguration.getIPv4Addresses().isEmpty()) {
            entityIpConfiguration.getIPv4Addresses().stream().map(NetworkAttachmentMapper::mapIpv4Address).forEach(model.getIpAddressAssignments().getIpAddressAssignments()::add);
        }
        if (!entityIpConfiguration.getIpV6Addresses().isEmpty()) {
            entityIpConfiguration.getIpV6Addresses().stream().map(NetworkAttachmentMapper::mapIpv6AddressAssignment).forEach(model.getIpAddressAssignments().getIpAddressAssignments()::add);
        }
    }
    if (entity.getReportedConfigurations() != null) {
        model.setInSync(entity.getReportedConfigurations().isNetworkInSync());
        model.setReportedConfigurations(ReportedConfigurationsMapper.map(entity.getReportedConfigurations(), null));
    }
    AnonymousHostNetworkQos hostNetworkQos = entity.getHostNetworkQos();
    if (hostNetworkQos != null) {
        model.setQos(QosMapper.map(HostNetworkQos.fromAnonymousHostNetworkQos(hostNetworkQos), null));
    }
    return model;
}
#end_block

#method_before
@Test
public void validateFailedUpdateReadOnly() {
    when(diskDao.get(diskImageGuid)).thenReturn(createDiskImage());
    command.getParameters().getDiskInfo().setReadOnly(true);
    initializeCommand(Collections.singletonList(createVm(VMStatus.Up)));
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
}
#method_after
@Test
public void validateFailedUpdateReadOnly() {
    when(diskDao.get(diskImageGuid)).thenReturn(createDiskImage());
    command.getParameters().getDiskInfo().setReadOnly(true);
    initializeCommand(createVm(VMStatus.Up));
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
}
#end_block

#method_before
@Test
public void validateFailedROVmAttachedToPool() {
    when(diskDao.get(diskImageGuid)).thenReturn(createDiskImage());
    command.getParameters().getDiskInfo().setReadOnly(true);
    VM vm = createVm(VMStatus.Down);
    vm.setVmPoolId(Guid.newGuid());
    initializeCommand(Collections.singletonList(vm));
    // Default RO is false
    VmDevice vmDevice = stubVmDevice(diskImageGuid, vmId);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_ATTACHED_TO_POOL);
    vmDevice.setIsReadOnly(true);
    command.getParameters().getDiskInfo().setReadOnly(false);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_ATTACHED_TO_POOL);
}
#method_after
@Test
public void validateFailedROVmAttachedToPool() {
    when(diskDao.get(diskImageGuid)).thenReturn(createDiskImage());
    command.getParameters().getDiskInfo().setReadOnly(true);
    VM vm = createVm(VMStatus.Down);
    vm.setVmPoolId(Guid.newGuid());
    initializeCommand(vm);
    // Default RO is false
    VmDevice vmDevice = stubVmDevice(diskImageGuid, vmId);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_ATTACHED_TO_POOL);
    vmDevice.setIsReadOnly(true);
    command.getParameters().getDiskInfo().setReadOnly(false);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_ATTACHED_TO_POOL);
}
#end_block

#method_before
@Test
public void validateFailedWipeVmAttachedToPool() {
    Disk oldDisk = createDiskImage();
    oldDisk.setWipeAfterDelete(true);
    when(diskDao.get(diskImageGuid)).thenReturn(oldDisk);
    command.getParameters().getDiskInfo().setWipeAfterDelete(false);
    VM vm = createVm(VMStatus.Down);
    vm.setVmPoolId(Guid.newGuid());
    initializeCommand(Collections.singletonList(vm));
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_ATTACHED_TO_POOL);
    oldDisk.setWipeAfterDelete(false);
    command.getParameters().getDiskInfo().setWipeAfterDelete(true);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_ATTACHED_TO_POOL);
}
#method_after
@Test
public void validateFailedWipeVmAttachedToPool() {
    Disk oldDisk = createDiskImage();
    oldDisk.setWipeAfterDelete(true);
    when(diskDao.get(diskImageGuid)).thenReturn(oldDisk);
    command.getParameters().getDiskInfo().setWipeAfterDelete(false);
    VM vm = createVm(VMStatus.Down);
    vm.setVmPoolId(Guid.newGuid());
    initializeCommand(vm);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_ATTACHED_TO_POOL);
    oldDisk.setWipeAfterDelete(false);
    command.getParameters().getDiskInfo().setWipeAfterDelete(true);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_ATTACHED_TO_POOL);
}
#end_block

#method_before
private void validateUpdateWipeAfterDelete(VMStatus status) {
    DiskImage disk = createDiskImage();
    disk.setReadOnly(false);
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    command.getParameters().getDiskInfo().setReadOnly(false);
    command.getParameters().getDiskInfo().setWipeAfterDelete(true);
    initializeCommand(Collections.singletonList(createVm(status)));
    ValidateTestUtils.runAndAssertValidateSuccess(command);
}
#method_after
private void validateUpdateWipeAfterDelete(VMStatus status) {
    DiskImage disk = createDiskImage();
    disk.setReadOnly(false);
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    command.getParameters().getDiskInfo().setReadOnly(false);
    command.getParameters().getDiskInfo().setWipeAfterDelete(true);
    initializeCommand(createVm(status));
    ValidateTestUtils.runAndAssertValidateSuccess(command);
}
#end_block

#method_before
private void validateUpdateDescription(VMStatus status) {
    DiskImage disk = createDiskImage();
    disk.setReadOnly(false);
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    command.getParameters().getDiskInfo().setReadOnly(false);
    disk.setDescription(RandomUtils.instance().nextString(10));
    initializeCommand(Collections.singletonList(createVm(status)));
    ValidateTestUtils.runAndAssertValidateSuccess(command);
}
#method_after
private void validateUpdateDescription(VMStatus status) {
    DiskImage disk = createDiskImage();
    disk.setReadOnly(false);
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    command.getParameters().getDiskInfo().setReadOnly(false);
    disk.setDescription(RandomUtils.instance().nextString(10));
    initializeCommand(createVm(status));
    ValidateTestUtils.runAndAssertValidateSuccess(command);
}
#end_block

#method_before
@Test
public void testUpdateDiskInterfaceUnsupported() {
    command.getParameters().getDiskVmElement().setDiskInterface(DiskInterface.IDE);
    initializeCommand();
    mockVdsCommandSetVolumeDescription();
    DiskVmElement dve = new DiskVmElement(diskImageGuid, vmId);
    dve.setDiskInterface(DiskInterface.VirtIO);
    doReturn(dve).when(command).getOldDiskVmElement();
    doReturn(createDiskImage()).when(command).getOldDisk();
    when(diskValidator.isReadOnlyPropertyCompatibleWithInterface(any(DiskVmElement.class))).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskInterfaceSupported(any(VM.class), any(DiskVmElement.class))).thenReturn(new ValidationResult(EngineMessage.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED));
    when(command.getDiskValidator(command.getParameters().getDiskInfo())).thenReturn(diskValidator);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED);
}
#method_after
@Test
public void testUpdateDiskInterfaceUnsupported() {
    command.getParameters().getDiskVmElement().setDiskInterface(DiskInterface.IDE);
    initializeCommand();
    mockVdsCommandSetVolumeDescription();
    DiskVmElement dve = new DiskVmElement(diskImageGuid, vmId);
    dve.setDiskInterface(DiskInterface.VirtIO);
    doReturn(dve).when(command).getOldDiskVmElement();
    doReturn(createDiskImage()).when(command).getOldDisk();
    when(diskVmElementValidator.isReadOnlyPropertyCompatibleWithInterface()).thenReturn(ValidationResult.VALID);
    when(diskVmElementValidator.isDiskInterfaceSupported(any(VM.class))).thenReturn(new ValidationResult(EngineMessage.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED));
    when(command.getDiskValidator(command.getParameters().getDiskInfo())).thenReturn(diskValidator);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED);
}
#end_block

#method_before
@Test
public void testFailInterfaceCanUpdateReadOnly() {
    initializeCommand();
    doReturn(true).when(command).updateReadOnlyRequested();
    doReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_INTERFACE_DOES_NOT_SUPPORT_READ_ONLY_ATTR)).when(diskValidator).isReadOnlyPropertyCompatibleWithInterface(any(DiskVmElement.class));
    assertFalse(command.validateCanUpdateReadOnly(diskValidator));
}
#method_after
@Test
public void testFailInterfaceCanUpdateReadOnly() {
    initializeCommand();
    doReturn(true).when(command).updateReadOnlyRequested();
    doReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_INTERFACE_DOES_NOT_SUPPORT_READ_ONLY_ATTR)).when(diskVmElementValidator).isReadOnlyPropertyCompatibleWithInterface();
    assertFalse(command.validateCanUpdateReadOnly());
}
#end_block

#method_before
@Test
public void testSucceedInterfaceCanUpdateReadOnly() {
    initializeCommand();
    doReturn(true).when(command).updateReadOnlyRequested();
    doReturn(ValidationResult.VALID).when(diskValidator).isReadOnlyPropertyCompatibleWithInterface(any(DiskVmElement.class));
    assertTrue(command.validateCanUpdateReadOnly(diskValidator));
}
#method_after
@Test
public void testSucceedInterfaceCanUpdateReadOnly() {
    initializeCommand();
    doReturn(true).when(command).updateReadOnlyRequested();
    doReturn(ValidationResult.VALID).when(diskVmElementValidator).isReadOnlyPropertyCompatibleWithInterface();
    assertTrue(command.validateCanUpdateReadOnly());
}
#end_block

#method_before
private void initializeCommand() {
    initializeCommand(Collections.singletonList(createVmStatusDown()));
}
#method_after
private void initializeCommand() {
    initializeCommand(createVmStatusDown());
}
#end_block

#method_before
protected void initializeCommand(List<VM> vms) {
    mockGetForDisk(vms);
    mockGetVmsListForDisk(vms);
    doReturn(snapshotDao).when(command).getSnapshotDao();
    doReturn(diskImageDao).when(command).getDiskImageDao();
    doReturn(storagePoolDao).when(command).getStoragePoolDao();
    doReturn(storageDomainStaticDao).when(command).getStorageDomainStaticDao();
    doReturn(storageDomainDao).when(command).getStorageDomainDao();
    doReturn(vmStaticDao).when(command).getVmStaticDao();
    doReturn(baseDiskDao).when(command).getBaseDiskDao();
    doReturn(imageDao).when(command).getImageDao();
    doReturn(vmDeviceDao).when(command).getVmDeviceDao();
    doReturn(vmDao).when(command).getVmDao();
    doReturn(diskDao).when(command).getDiskDao();
    doReturn(diskVmElementDao).when(command).getDiskVmElementDao();
    doNothing().when(command).reloadDisks();
    doNothing().when(command).updateBootOrder();
    doReturn(quotaManager).when(command).getQuotaManager();
    doAnswer(invocation -> invocation.getArguments()[0] != null ? invocation.getArguments()[0] : Guid.newGuid()).when(quotaManager).getDefaultQuotaIfNull(any(Guid.class), any(Guid.class));
    SnapshotsValidator snapshotsValidator = mock(SnapshotsValidator.class);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    when(diskValidator.isVirtIoScsiValid(any(VM.class), any(DiskVmElement.class))).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskUsedAsOvfStore()).thenReturn(ValidationResult.VALID);
    doReturn(ValidationResult.VALID).when(diskValidator).isDiskAttachedToVm(any(VM.class));
    doReturn(ValidationResult.VALID).when(diskValidator).isDiskExists();
    doReturn(ValidationResult.VALID).when(diskValidator).validateNotHostedEngineDisk();
    doReturn(ValidationResult.VALID).when(diskValidator).isReadOnlyPropertyCompatibleWithInterface(any(DiskVmElement.class));
    doReturn(diskValidator).when(command).getDiskValidator(any(Disk.class));
    doReturn(true).when(command).setAndValidateDiskProfiles();
    doReturn(true).when(command).validateQuota();
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    mockVds();
    mockVmsStoragePoolInfo(vms);
    mockToUpdateDiskVm(vms);
    StorageDomain sd = new StorageDomain();
    sd.setAvailableDiskSize(Integer.MAX_VALUE);
    sd.setStatus(StorageDomainStatus.Active);
    when(storageDomainDao.getForStoragePool(any(Guid.class), any(Guid.class))).thenReturn(sd);
    StorageDomainValidator sdValidator = new StorageDomainValidator(sd);
    doReturn(sdValidator).when(command).getStorageDomainValidator(any(DiskImage.class));
    command.init();
}
#method_after
protected void initializeCommand(VM vm) {
    mockGetForDisk(vm);
    mockGetVmsListForDisk(vm);
    doReturn(snapshotDao).when(command).getSnapshotDao();
    doReturn(diskImageDao).when(command).getDiskImageDao();
    doReturn(storagePoolDao).when(command).getStoragePoolDao();
    doReturn(storageDomainStaticDao).when(command).getStorageDomainStaticDao();
    doReturn(storageDomainDao).when(command).getStorageDomainDao();
    doReturn(vmStaticDao).when(command).getVmStaticDao();
    doReturn(baseDiskDao).when(command).getBaseDiskDao();
    doReturn(imageDao).when(command).getImageDao();
    doReturn(vmDeviceDao).when(command).getVmDeviceDao();
    doReturn(vmDao).when(command).getVmDao();
    doReturn(diskDao).when(command).getDiskDao();
    doReturn(diskVmElementDao).when(command).getDiskVmElementDao();
    doNothing().when(command).reloadDisks();
    doNothing().when(command).updateBootOrder();
    doReturn(quotaManager).when(command).getQuotaManager();
    doAnswer(invocation -> invocation.getArguments()[0] != null ? invocation.getArguments()[0] : Guid.newGuid()).when(quotaManager).getDefaultQuotaIfNull(any(Guid.class), any(Guid.class));
    SnapshotsValidator snapshotsValidator = mock(SnapshotsValidator.class);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    when(diskVmElementValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskUsedAsOvfStore()).thenReturn(ValidationResult.VALID);
    doReturn(ValidationResult.VALID).when(diskValidator).isDiskAttachedToVm(any(VM.class));
    doReturn(ValidationResult.VALID).when(diskValidator).isDiskExists();
    doReturn(ValidationResult.VALID).when(diskValidator).validateNotHostedEngineDisk();
    doReturn(ValidationResult.VALID).when(diskVmElementValidator).isReadOnlyPropertyCompatibleWithInterface();
    doReturn(diskValidator).when(command).getDiskValidator(any(Disk.class));
    doReturn(diskVmElementValidator).when(command).getDiskVmElementValidator(any(Disk.class), any(DiskVmElement.class));
    doReturn(true).when(command).setAndValidateDiskProfiles();
    doReturn(true).when(command).validateQuota();
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    mockVds();
    mockVmsStoragePoolInfo(vm);
    mockToUpdateDiskVm(vm);
    StorageDomain sd = new StorageDomain();
    sd.setAvailableDiskSize(Integer.MAX_VALUE);
    sd.setStatus(StorageDomainStatus.Active);
    when(storageDomainDao.getForStoragePool(any(Guid.class), any(Guid.class))).thenReturn(sd);
    StorageDomainValidator sdValidator = new StorageDomainValidator(sd);
    doReturn(sdValidator).when(command).getStorageDomainValidator(any(DiskImage.class));
    command.init();
}
#end_block

#method_before
private void mockToUpdateDiskVm(List<VM> vms) {
    vms.stream().filter(vm -> vm.getId().equals(command.getParameters().getVmId())).findFirst().ifPresent(vm -> {
        when(vmDao.get(command.getParameters().getVmId())).thenReturn(vm);
        when(diskVmElementDao.get(new VmDeviceId(command.getParameters().getDiskInfo().getId(), vm.getId()))).thenReturn(new DiskVmElement());
    });
}
#method_after
private void mockToUpdateDiskVm(VM vm) {
    when(vmDao.get(command.getParameters().getVmId())).thenReturn(vm);
    when(diskVmElementDao.get(new VmDeviceId(command.getParameters().getDiskInfo().getId(), vm.getId()))).thenReturn(new DiskVmElement());
}
#end_block

#method_before
private void mockNullVm() {
    mockGetForDisk((VM) null);
    mockGetVmsListForDisk(null);
    when(vmDao.get(command.getParameters().getVmId())).thenReturn(null);
}
#method_after
private void mockNullVm() {
    mockGetForDisk(null);
    when(vmDao.get(command.getParameters().getVmId())).thenReturn(null);
}
#end_block

#method_before
private void mockVmsStoragePoolInfo(List<VM> vms) {
    StoragePool storagePool = mockStoragePool();
    for (VM vm : vms) {
        vm.setStoragePoolId(storagePool.getId());
    }
}
#method_after
private void mockVmsStoragePoolInfo(VM vm) {
    StoragePool storagePool = mockStoragePool();
    vm.setStoragePoolId(storagePool.getId());
}
#end_block

#method_before
private void mockGetForDisk(VM vm) {
    mockGetForDisk(Collections.singletonList(vm));
}
#method_after
private void mockGetForDisk(VM vm) {
    when(vmDao.getForDisk(diskImageGuid, true)).thenReturn(Collections.singletonMap(Boolean.TRUE, Collections.singletonList(vm)));
}
#end_block

#method_before
private void mockGetVmsListForDisk(List<VM> vms) {
    List<Pair<VM, VmDevice>> vmsWithVmDevice = new ArrayList<>();
    if (vms != null) {
        for (VM vm : vms) {
            VmDevice device = createVmDevice(diskImageGuid, vm.getId());
            vmsWithVmDevice.add(new Pair<>(vm, device));
        }
    }
    when(vmDao.getVmsWithPlugInfo(diskImageGuid)).thenReturn(vmsWithVmDevice);
}
#method_after
private void mockGetVmsListForDisk(VM vm) {
    VmDevice device = createVmDevice(diskImageGuid, vm.getId());
    when(vmDao.getVmsWithPlugInfo(diskImageGuid)).thenReturn(Collections.singletonList(new Pair<>(vm, device)));
}
#end_block

#method_before
@Before
public void setUp() {
    Guid vmId = Guid.newGuid();
    Guid poolId = Guid.newGuid();
    Guid storageDomainId = Guid.newGuid();
    Guid vdsId = Guid.newGuid();
    disk = new DiskImage();
    disk.setId(diskId);
    disk.setVmEntityType(VmEntityType.VM);
    disk.setImageStatus(ImageStatus.OK);
    disk.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomainId)));
    vm = new VM();
    vm.setId(vmId);
    vm.setStatus(VMStatus.Down);
    vm.setStoragePoolId(poolId);
    vm.setClusterId(groupId);
    VmDeviceId vmDeviceId = new VmDeviceId(diskId, vmId);
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(vmDeviceId);
    Cluster cluster = new Cluster();
    cluster.setId(groupId);
    VDS vds = new VDS();
    vds.setId(vdsId);
    storagePool = new StoragePool();
    storagePool.setStatus(StoragePoolStatus.Up);
    storageDomain = new StorageDomain();
    storageDomain.setStorageType(StorageType.ISCSI);
    when(vmDao.getVmsListForDisk(diskId, Boolean.FALSE)).thenReturn(Collections.singletonList(vm));
    when(vmDeviceDao.get(vmDeviceId)).thenReturn(vmDevice);
    when(vdsDao.getAllForClusterWithStatus(groupId, VDSStatus.Up)).thenReturn(Collections.singletonList(vds));
    when(spDao.get(poolId)).thenReturn(storagePool);
    when(clusterDao.get(groupId)).thenReturn(cluster);
    when(storageDomainStaticDao.get(storageDomainId)).thenReturn(storageDomain.getStorageStaticData());
    doReturn(disk).when(cmd).getDisk();
    doReturn(vdsDao).when(cmd).getVdsDao();
    doReturn(vmDao).when(cmd).getVmDao();
    doReturn(spDao).when(cmd).getStoragePoolDao();
    doReturn(clusterDao).when(cmd).getClusterDao();
    doReturn(storageDomainStaticDao).when(cmd).getStorageDomainStaticDao();
}
#method_after
@Before
public void setUp() {
    Guid vmId = Guid.newGuid();
    Guid poolId = Guid.newGuid();
    Guid storageDomainId = Guid.newGuid();
    groupId = Guid.newGuid();
    Guid vdsId = Guid.newGuid();
    disk = new DiskImage();
    disk.setId(diskId);
    disk.setVmEntityType(VmEntityType.VM);
    disk.setImageStatus(ImageStatus.OK);
    disk.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomainId)));
    vm = new VM();
    vm.setId(vmId);
    vm.setStatus(VMStatus.Down);
    vm.setStoragePoolId(poolId);
    vm.setClusterId(groupId);
    VmDeviceId vmDeviceId = new VmDeviceId(diskId, vmId);
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(vmDeviceId);
    Cluster cluster = new Cluster();
    cluster.setId(groupId);
    VDS vds = new VDS();
    vds.setId(vdsId);
    storagePool = new StoragePool();
    storagePool.setStatus(StoragePoolStatus.Up);
    storageDomain = new StorageDomain();
    storageDomain.setStorageType(StorageType.ISCSI);
    when(vmDao.getVmsListForDisk(diskId, Boolean.FALSE)).thenReturn(Collections.singletonList(vm));
    when(vmDeviceDao.get(vmDeviceId)).thenReturn(vmDevice);
    when(vdsDao.getAllForClusterWithStatus(groupId, VDSStatus.Up)).thenReturn(Collections.singletonList(vds));
    when(spDao.get(poolId)).thenReturn(storagePool);
    when(clusterDao.get(groupId)).thenReturn(cluster);
    when(storageDomainStaticDao.get(storageDomainId)).thenReturn(storageDomain.getStorageStaticData());
    doReturn(disk).when(cmd).getDisk();
    doReturn(vdsDao).when(cmd).getVdsDao();
    doReturn(vmDao).when(cmd).getVmDao();
    doReturn(spDao).when(cmd).getStoragePoolDao();
    doReturn(clusterDao).when(cmd).getClusterDao();
    doReturn(storageDomainStaticDao).when(cmd).getStorageDomainStaticDao();
}
#end_block

#method_before
@Before
public void setUp() {
    sdId = Guid.newGuid();
    StorageDomainStatic sdStatic = createStorageDomain();
    spId = Guid.newGuid();
    sd = new StorageDomain();
    sd.setStorageStaticData(sdStatic);
    sd.setStatus(StorageDomainStatus.Active);
    sd.setStoragePoolId(spId);
    StoragePool sp = new StoragePool();
    sp.setId(spId);
    sp.setStatus(StoragePoolStatus.Up);
    sp.setIsLocal(false);
    sp.setCompatibilityVersion(Version.v3_6);
    doReturn(sd).when(cmd).getStorageDomain();
    doReturn(sp).when(cmd).getStoragePool();
    doReturn(sdsDao).when(cmd).getStorageDomainStaticDao();
    when(sdsDao.get(sdId)).thenReturn(sdStatic);
    doReturn(lunsDao).when(cmd).getLunDao();
    LUNs lun1 = new LUNs();
    lun1.setLUNId("1");
    lun1.setStorageDomainId(sdId);
    LUNs lun2 = new LUNs();
    lun2.setLUNId("2");
    lun2.setStorageDomainId(sdId);
    when(lunsDao.getAll()).thenReturn(Arrays.asList(lun1, lun2));
}
#method_after
@Before
public void setUp() {
    StorageDomainStatic sdStatic = createStorageDomain();
    spId = Guid.newGuid();
    sd = new StorageDomain();
    sd.setStorageStaticData(sdStatic);
    sd.setStatus(StorageDomainStatus.Active);
    sd.setStoragePoolId(spId);
    StoragePool sp = new StoragePool();
    sp.setId(spId);
    sp.setStatus(StoragePoolStatus.Up);
    sp.setIsLocal(false);
    sp.setCompatibilityVersion(Version.v3_6);
    doReturn(sd).when(cmd).getStorageDomain();
    doReturn(sp).when(cmd).getStoragePool();
    doReturn(sdsDao).when(cmd).getStorageDomainStaticDao();
    when(sdsDao.get(sdId)).thenReturn(sdStatic);
    doReturn(lunsDao).when(cmd).getLunDao();
    LUNs lun1 = new LUNs();
    lun1.setLUNId("1");
    lun1.setStorageDomainId(sdId);
    LUNs lun2 = new LUNs();
    lun2.setLUNId("2");
    lun2.setStorageDomainId(sdId);
    when(lunsDao.getAll()).thenReturn(Arrays.asList(lun1, lun2));
}
#end_block

#method_before
@Override
protected AddVmCommand<AddVmParameters> createCommand() {
    initVM();
    AddVmParameters param = new AddVmParameters(vm);
    return new AddVmCommand<>(param, null);
}
#method_after
@Override
protected AddVmCommand<AddVmParameters> createCommand() {
    initVM();
    return new AddVmCommand<>(new AddVmParameters(vm), null);
}
#end_block

#method_before
@Override
protected AddVmFromTemplateCommand<AddVmParameters> createCommand() {
    initVM();
    AddVmParameters param = new AddVmParameters(vm);
    return new AddVmFromTemplateCommand<>(param, null);
}
#method_after
@Override
protected AddVmFromTemplateCommand<AddVmParameters> createCommand() {
    initVM();
    return new AddVmFromTemplateCommand<>(new AddVmParameters(vm), null);
}
#end_block

#method_before
@Test
public void validateSufficientSpaceOnDestinationDomains() {
    setupForStorageTests();
    assertTrue(command.checkDestDomains());
    verify(multipleSdValidator).allDomainsWithinThresholds();
    verify(multipleSdValidator).allDomainsHaveSpaceForNewDisks(anyListOf(DiskImage.class));
}
#method_after
@Test
public void validateSufficientSpaceOnDestinationDomains() {
    setupForStorageTests();
    command.ensureDestinationImageMap();
    assertTrue(command.checkDestDomains());
    verify(multipleSdValidator).allDomainsWithinThresholds();
    verify(multipleSdValidator).allDomainsHaveSpaceForNewDisks(anyListOf(DiskImage.class));
}
#end_block

#method_before
@Before
public void setupMocks() {
    mockGlobalParameters();
    setUpCommand();
    mockVds();
    mockDbDao();
    command.init();
}
#method_after
@Before
public void setupMocks() {
    setUpCommand();
    mockVds();
    mockDbDao();
    command.init();
}
#end_block

#method_before
private void generateStruct(StructType type) {
    // Begin class:
    generateClassDeclaration(type);
    buffer.addLine();
    // Attributes and links:
    List<StructMember> members = new ArrayList<>();
    members.addAll(type.getAttributes());
    members.addAll(type.getLinks());
    Collections.sort(members);
    members.forEach(this::generateMember);
    // Constructor with a named parameter for each attribute:
    RubyName typeName = rubyNames.getTypeName(type);
    buffer.addComment();
    buffer.addComment("Creates a new instance of the {%1$s} class.", typeName.getClassName());
    buffer.addComment();
    buffer.addYardTag("param", "opts [Hash] A hash containing the attributes of the object. The keys of the hash\n" + "should be symbols corresponding to the names of the attributes. The values of the hash\n" + "should be the values of the attributes.");
    buffer.addComment();
    members.forEach(member -> {
        Type memberType = member.getType();
        Name memberName = member.getName();
        String docType = yardDoc.getType(memberType);
        String docName = rubyNames.getMemberStyleName(memberName);
        if (memberType instanceof PrimitiveType || memberType instanceof EnumType) {
            buffer.addYardTag("option", "opts [%1$s] :%2$s The value of attribute `%2$s`.", docType, docName);
            buffer.addComment();
        } else if (memberType instanceof StructType) {
            buffer.addYardTag("option", "opts [%1$s, Hash] :%2$s The value of attribute `%2$s`.", docType, docName);
            buffer.addComment();
        } else if (memberType instanceof ListType) {
            buffer.addYardTag("option", "opts [%1$s, Array<Hash>] :%2$s The values of attribute `%2$s`.", docType, docName);
            buffer.addComment();
        }
    });
    buffer.addComment();
    buffer.addLine("def initialize(opts = {})");
    buffer.addLine("super(opts)");
    members.forEach(member -> {
        String memberName = rubyNames.getMemberStyleName(member.getName());
        buffer.addLine("self.%1$s = opts[:%1$s]", memberName);
    });
    buffer.addLine("end");
    buffer.addLine();
    // Method that returns the state of the object:
    buffer.addComment();
    buffer.addComment("Returns the state of this object.");
    buffer.addComment();
    buffer.addYardTag("return", "[Array<Object>] An array containing the state of the object.");
    buffer.addComment();
    buffer.addYardTag("api", "private");
    buffer.addComment();
    buffer.addLine("def state");
    buffer.addLine("result = super");
    members.forEach(member -> {
        String memberName = rubyNames.getMemberStyleName(member.getName());
        buffer.addLine("result << @%1$s", memberName);
    });
    buffer.addLine("result");
    buffer.addLine("end");
    buffer.addLine();
    // End class:
    buffer.addLine("end");
    buffer.addLine();
}
#method_after
private void generateStruct(StructType type) {
    // Begin class:
    generateClassDeclaration(type);
    buffer.addLine();
    // Get the list of members, including those declared in the base types:
    List<StructMember> allMembers = new ArrayList<>();
    allMembers.addAll(type.getAttributes());
    allMembers.addAll(type.getLinks());
    Collections.sort(allMembers);
    // Get the list of members declared directly in this type:
    List<StructMember> declaredMembers = new ArrayList<>();
    declaredMembers.addAll(type.getDeclaredAttributes());
    declaredMembers.addAll(type.getDeclaredLinks());
    Collections.sort(declaredMembers);
    // Generate getters and setters, only for members declared directly in this class:
    allMembers.forEach(this::generateMember);
    // The constructor should have documentation for all the parameters, including those of the base types, but the
    // code only needs to handle the members declared in this type, as the others are handled by the constructor of
    // the base class:
    RubyName typeName = rubyNames.getTypeName(type);
    buffer.addComment();
    buffer.addComment("Creates a new instance of the {%1$s} class.", typeName.getClassName());
    buffer.addComment();
    buffer.addYardTag("param", "opts [Hash] A hash containing the attributes of the object. The keys of the hash\n" + "should be symbols corresponding to the names of the attributes. The values of the hash\n" + "should be the values of the attributes.");
    buffer.addComment();
    allMembers.forEach(member -> {
        Type memberType = member.getType();
        Name memberName = member.getName();
        String docType = yardDoc.getType(memberType);
        String docName = rubyNames.getMemberStyleName(memberName);
        if (memberType instanceof PrimitiveType || memberType instanceof EnumType) {
            buffer.addYardTag("option", "opts [%1$s] :%2$s The value of attribute `%2$s`.", docType, docName);
            buffer.addComment();
        } else if (memberType instanceof StructType) {
            buffer.addYardTag("option", "opts [%1$s, Hash] :%2$s The value of attribute `%2$s`.", docType, docName);
            buffer.addComment();
        } else if (memberType instanceof ListType) {
            buffer.addYardTag("option", "opts [%1$s, Array<Hash>] :%2$s The values of attribute `%2$s`.", docType, docName);
            buffer.addComment();
        }
    });
    buffer.addComment();
    buffer.addLine("def initialize(opts = {})");
    buffer.addLine("super(opts)");
    declaredMembers.forEach(member -> {
        String memberName = rubyNames.getMemberStyleName(member.getName());
        buffer.addLine("self.%1$s = opts[:%1$s]", memberName);
    });
    buffer.addLine("end");
    buffer.addLine();
    // Operator to compare two objects:
    if (!declaredMembers.isEmpty()) {
        buffer.addComment();
        buffer.addComment("Returns `true` if `self` and `other` have the same attributes and values.");
        buffer.addComment();
        buffer.addLine("def ==(other)");
        buffer.addLine("super &&");
        for (int i = 0; i < declaredMembers.size(); i++) {
            String memberName = rubyNames.getMemberStyleName(declaredMembers.get(i).getName());
            String line = String.format("@%1$s == other.%1$s", memberName);
            if (i < declaredMembers.size() - 1) {
                line += " &&";
            }
            buffer.addLine(line);
        }
        buffer.addLine("end");
        buffer.addLine();
    }
    // Method to calculate the hash code:
    if (!declaredMembers.isEmpty()) {
        buffer.addComment();
        buffer.addComment("Generates a hash value for this object.");
        buffer.addComment();
        buffer.addLine("def hash");
        buffer.addLine("super +");
        for (int i = 0; i < declaredMembers.size(); i++) {
            String memberName = rubyNames.getMemberStyleName(declaredMembers.get(i).getName());
            String line = String.format("@%1$s.hash", memberName);
            if (i < declaredMembers.size() - 1) {
                line += " +";
            }
            buffer.addLine(line);
        }
        buffer.addLine("end");
        buffer.addLine();
    }
    // End class:
    buffer.addLine("end");
    buffer.addLine();
}
#end_block

#method_before
private void generateSetter(StructMember member) {
    Name name = member.getName();
    Type type = member.getType();
    String property = rubyNames.getMemberStyleName(name);
    buffer.addComment();
    buffer.addComment("Sets the value of the `%1$s` attribute.", property);
    buffer.addComment();
    if (type instanceof PrimitiveType || type instanceof EnumType) {
        buffer.addYardTag("param", "value [%1$s]", yardDoc.getType(type));
        buffer.addComment();
        buffer.addLine("def %1$s=(value)", property);
        buffer.addLine("@%1$s = value", property);
        buffer.addLine("end");
    } else if (type instanceof StructType) {
        RubyName typeName = rubyNames.getTypeName(type);
        buffer.addYardTag("param", "value [%1$s, Hash]", yardDoc.getType(type));
        buffer.addComment();
        buffer.addComment("The `value` parameter can be an instance of {%1$s} or a hash.", typeName);
        buffer.addComment("If it is a hash then a new instance will be created passing the hash as the ");
        buffer.addComment("`opts` parameter to the constructor.");
        buffer.addComment();
        buffer.addLine("def %1$s=(value)", property);
        buffer.addLine("if value.is_a?(Hash)");
        buffer.addLine("value = %1$s.new(value)", typeName.getClassName());
        buffer.addLine("end");
        buffer.addLine("@%1$s = value", property);
        buffer.addLine("end");
    } else if (type instanceof ListType) {
        buffer.addYardTag("param", "list [%1$s]", yardDoc.getType(type));
        ListType listType = (ListType) type;
        Type elementType = listType.getElementType();
        if (elementType instanceof PrimitiveType || elementType instanceof EnumType) {
            buffer.addLine("def %1$s=(list)", property);
            buffer.addLine("@%1$s = list", property);
            buffer.addLine("end");
        } else if (elementType instanceof StructType) {
            RubyName elementTypeName = rubyNames.getTypeName(elementType);
            buffer.addLine("def %1$s=(list)", property);
            buffer.addLine("if list.class == Array");
            buffer.addLine("list = List.new(list)");
            buffer.addLine("list.each_with_index do |value, index|");
            buffer.addLine("if value.is_a?(Hash)");
            buffer.addLine("list[index] = %1$s.new(value)", elementTypeName.getClassName());
            buffer.addLine("end");
            buffer.addLine("end");
            buffer.addLine("end");
            buffer.addLine("@%1$s = list", property);
            buffer.addLine("end");
        }
    }
    buffer.addLine();
}
#method_after
private void generateSetter(StructMember member) {
    Name name = member.getName();
    Type type = member.getType();
    String property = rubyNames.getMemberStyleName(name);
    buffer.addComment();
    buffer.addComment("Sets the value of the `%1$s` attribute.", property);
    buffer.addComment();
    if (type instanceof PrimitiveType || type instanceof EnumType) {
        buffer.addYardTag("param", "value [%1$s]", yardDoc.getType(type));
        buffer.addComment();
        buffer.addLine("def %1$s=(value)", property);
        buffer.addLine("@%1$s = value", property);
        buffer.addLine("end");
    } else if (type instanceof StructType) {
        RubyName typeName = rubyNames.getTypeName(type);
        buffer.addYardTag("param", "value [%1$s, Hash]", yardDoc.getType(type));
        buffer.addComment();
        buffer.addComment("The `value` parameter can be an instance of {%1$s} or a hash.", typeName);
        buffer.addComment("If it is a hash then a new instance will be created passing the hash as the ");
        buffer.addComment("`opts` parameter to the constructor.");
        buffer.addComment();
        buffer.addLine("def %1$s=(value)", property);
        buffer.addLine("if value.is_a?(Hash)");
        buffer.addLine("value = %1$s.new(value)", typeName.getClassName());
        buffer.addLine("end");
        buffer.addLine("@%1$s = value", property);
        buffer.addLine("end");
    } else if (type instanceof ListType) {
        buffer.addYardTag("param", "list [%1$s]", yardDoc.getType(type));
        buffer.addComment();
        ListType listType = (ListType) type;
        Type elementType = listType.getElementType();
        if (elementType instanceof PrimitiveType || elementType instanceof EnumType) {
            buffer.addLine("def %1$s=(list)", property);
            buffer.addLine("@%1$s = list", property);
            buffer.addLine("end");
        } else if (elementType instanceof StructType) {
            RubyName elementTypeName = rubyNames.getTypeName(elementType);
            buffer.addLine("def %1$s=(list)", property);
            buffer.addLine("if list.class == Array");
            buffer.addLine("list = List.new(list)");
            buffer.addLine("list.each_with_index do |value, index|");
            buffer.addLine("if value.is_a?(Hash)");
            buffer.addLine("list[index] = %1$s.new(value)", elementTypeName.getClassName());
            buffer.addLine("end");
            buffer.addLine("end");
            buffer.addLine("end");
            buffer.addLine("@%1$s = list", property);
            buffer.addLine("end");
        }
    }
    buffer.addLine();
}
#end_block

#method_before
@Override
public ValidationResult validate(Object value) {
    ValidationResult result = new ValidationResult();
    if (value == null) {
        value = EMPTY_STRING;
    }
    if (value instanceof String) {
        final String stringValue = (String) value;
        if (getIsNegate() ^ !Regex.isMatch(stringValue, getExpression())) {
            result.setSuccess(false);
            result.getReasons().add(getMessage());
        }
    }
    return result;
}
#method_after
@Override
public ValidationResult validate(Object value) {
    if (value == null) {
        value = EMPTY_STRING;
    }
    if (value instanceof String) {
        final String stringValue = (String) value;
        if (getIsNegate() ^ !Regex.isMatch(stringValue, getExpression())) {
            return ValidationResult.fail(getMessage());
        } else {
            return ValidationResult.ok();
        }
    } else {
        // $NON-NLS-1$
        return ValidationResult.fail("Unable to do Regex validation on non String input");
    }
}
#end_block

#method_before
protected final String start() {
    // $NON-NLS-1$
    return "^";
}
#method_after
protected String start() {
    // $NON-NLS-1$
    return "^";
}
#end_block

#method_before
protected final String end() {
    // $NON-NLS-1$
    return "$";
}
#method_after
protected String end() {
    // $NON-NLS-1$
    return "$";
}
#end_block

#method_before
@Test
public void testAlteringPatternsWithMultipleFailingPatterns() throws Exception {
    List<IValidation> validations = Arrays.<IValidation>asList(new RegexValidation("^$", ""), new RegexValidation("^b$", ""));
    doTest(validations, false);
}
#method_after
@Test
public void testAlteringPatternsWithMultipleFailingPatterns() throws Exception {
    // $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
    List<IValidation> validations = Arrays.<IValidation>asList(new RegexValidation("^$", ""), new RegexValidation("^b$", ""));
    doTest(validations, false);
}
#end_block

#method_before
@Test
public void testAlteringPatternsWithMultiplePatternsSecondValid() throws Exception {
    List<IValidation> validations = Arrays.<IValidation>asList(new RegexValidation("^$", ""), new RegexValidation("^a.*$", ""));
    doTest(validations, true);
}
#method_after
@Test
public void testAlteringPatternsWithMultiplePatternsSecondValid() throws Exception {
    // $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
    List<IValidation> validations = Arrays.<IValidation>asList(new RegexValidation("^$", ""), new RegexValidation("^a.*$", ""));
    doTest(validations, true);
}
#end_block

#method_before
@Test
public void testAlteringPatternsWithMultiplePatternsFirstValid() throws Exception {
    List<IValidation> validations = Arrays.<IValidation>asList(new RegexValidation("^a.*$", ""), new RegexValidation("^$", ""));
    doTest(validations, true);
}
#method_after
@Test
public void testAlteringPatternsWithMultiplePatternsFirstValid() throws Exception {
    // $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
    List<IValidation> validations = Arrays.<IValidation>asList(new RegexValidation("^a.*$", ""), new RegexValidation("^$", ""));
    doTest(validations, true);
}
#end_block

#method_before
private void doTest(List<IValidation> validations, boolean expectedToSucceed) {
    String reason = "reason";
    ValidationResult validationResult = new AlternativeValidation(reason, validations).validate("abc");
    assertThat(validationResult.getSuccess(), is(expectedToSucceed));
    if (expectedToSucceed) {
        assertThat(validationResult.getReasons(), is(emptyCollectionOf(String.class)));
    } else {
        assertThat(validationResult.getReasons(), is(Matchers.containsInAnyOrder(reason)));
    }
}
#method_after
private void doTest(List<IValidation> validations, boolean expectedToSucceed) {
    // $NON-NLS-1$
    String reason = "reason";
    // $NON-NLS-1$
    ValidationResult validationResult = new AlternativeValidation(reason, validations).validate("abc");
    assertThat(validationResult.getSuccess(), is(expectedToSucceed));
    if (expectedToSucceed) {
        assertThat(validationResult.getReasons(), is(emptyCollectionOf(String.class)));
    } else {
        assertThat(validationResult.getReasons(), is(Matchers.containsInAnyOrder(reason)));
    }
}
#end_block

#method_before
@Override
protected String composeRegex() {
    // $NON-NLS-1$ //$NON-NLS-2$
    return "^[\u0000-\u007F" + "]*$";
}
#method_after
@Override
protected String composeRegex() {
    // $NON-NLS-1$
    return "^[\u0000-\u007F]*$";
}
#end_block

#method_before
@Override
protected String composeRegex() {
    return start() + onlyTheseChars() + end();
}
#method_after
@Override
protected String composeRegex() {
    return start() + letters() + numbers() + specialCharacters() + end();
}
#end_block

#method_before
private void createCommand(final Cluster group) {
    setValidCpuVersionMap();
    cmd.getParameters().setManagementNetworkId(managementNetworkId);
    cmd.getParameters().setCluster(group);
    cmd.setClusterId(group.getId());
    doReturn(0).when(cmd).compareCpuLevels(any(Cluster.class));
    doReturn(vmStaticDao).when(cmd).getVmStaticDao();
    doReturn(cpuFlagsManagerHandler).when(cmd).getCpuFlagsManagerHandler();
    doReturn(dbFacadeMock).when(cmd).getDbFacade();
    doReturn(clusterDao).when(cmd).getClusterDao();
    doReturn(clusterDao).when(dbFacadeMock).getClusterDao();
    doReturn(vdsDao).when(cmd).getVdsDao();
    doReturn(storagePoolDao).when(cmd).getStoragePoolDao();
    doReturn(storagePoolDao).when(dbFacadeMock).getStoragePoolDao();
    doReturn(glusterVolumeDao).when(cmd).getGlusterVolumeDao();
    doReturn(vmDao).when(cmd).getVmDao();
    doReturn(networkDao).when(cmd).getNetworkDao();
    doReturn(defaultManagementNetworkFinder).when(cmd).getDefaultManagementNetworkFinder();
    doReturn(clusterFeatureDao).when(cmd).getClusterFeatureDao();
    doReturn(hostFeatureDao).when(cmd).getHostFeatureDao();
    doReturn(networkClusterValidator).when(cmd).createManagementNetworkClusterValidator();
    doReturn(true).when(cmd).isSupportedEmulatedMachinesMatchClusterLevel(any(VDS.class));
    // cluster upgrade
    doReturn(schedulingManager).when(cmd).getSchedulingManager();
    doReturn(vmNumaNodeDao).when(cmd).getVmNumaNodeDao();
    doReturn(inClusterUpgradeValidator).when(cmd).getUpgradeValidator();
    doReturn(new ClusterPolicy()).when(schedulingManager).getClusterPolicy(any(Guid.class));
    final ClusterPolicy clusterPolicy = new ClusterPolicy();
    clusterPolicy.setId(ClusterPolicy.UPGRADE_POLICY_GUID);
    doReturn(clusterPolicy).when(schedulingManager).getClusterPolicy(eq(ClusterPolicy.UPGRADE_POLICY_GUID));
    doReturn(ValidationResult.VALID).when(inClusterUpgradeValidator).isUpgradeDone(anyList());
    doReturn(ValidationResult.VALID).when(inClusterUpgradeValidator).isUpgradePossible(anyList(), anyList());
    doReturn(new HashMap<Guid, List<VmNumaNode>>()).when(vmNumaNodeDao).getVmNumaNodeInfoByClusterIdAsMap(any(Guid.class));
    if (StringUtils.isEmpty(group.getCpuName())) {
        doReturn(ArchitectureType.undefined).when(cmd).getArchitecture();
    } else {
        doReturn(ArchitectureType.x86_64).when(cmd).getArchitecture();
    }
    when(clusterDao.get(any(Guid.class))).thenReturn(createDefaultCluster());
    when(clusterDao.getByName(anyString())).thenReturn(createDefaultCluster());
    List<Cluster> clusterList = new ArrayList<>();
    clusterList.add(createDefaultCluster());
    when(clusterDao.getByName(anyString(), anyBoolean())).thenReturn(clusterList);
}
#method_after
private void createCommand(final Cluster group) {
    setValidCpuVersionMap();
    cmd.getParameters().setManagementNetworkId(managementNetworkId);
    cmd.getParameters().setCluster(group);
    cmd.setClusterId(group.getId());
    doReturn(0).when(cmd).compareCpuLevels(any(Cluster.class));
    doReturn(vmStaticDao).when(cmd).getVmStaticDao();
    doReturn(dbFacadeMock).when(cmd).getDbFacade();
    doReturn(clusterDao).when(cmd).getClusterDao();
    doReturn(clusterDao).when(dbFacadeMock).getClusterDao();
    doReturn(vdsDao).when(cmd).getVdsDao();
    doReturn(storagePoolDao).when(cmd).getStoragePoolDao();
    doReturn(storagePoolDao).when(dbFacadeMock).getStoragePoolDao();
    doReturn(glusterVolumeDao).when(cmd).getGlusterVolumeDao();
    doReturn(vmDao).when(cmd).getVmDao();
    doReturn(networkDao).when(cmd).getNetworkDao();
    doReturn(clusterFeatureDao).when(cmd).getClusterFeatureDao();
    doReturn(hostFeatureDao).when(cmd).getHostFeatureDao();
    doReturn(networkClusterValidator).when(cmd).createManagementNetworkClusterValidator();
    doReturn(true).when(cmd).isSupportedEmulatedMachinesMatchClusterLevel(any(VDS.class));
    // cluster upgrade
    doReturn(vmNumaNodeDao).when(cmd).getVmNumaNodeDao();
    doReturn(inClusterUpgradeValidator).when(cmd).getUpgradeValidator();
    doReturn(new ClusterPolicy()).when(schedulingManager).getClusterPolicy(any(Guid.class));
    final ClusterPolicy clusterPolicy = new ClusterPolicy();
    clusterPolicy.setId(ClusterPolicy.UPGRADE_POLICY_GUID);
    doReturn(clusterPolicy).when(schedulingManager).getClusterPolicy(eq(ClusterPolicy.UPGRADE_POLICY_GUID));
    doReturn(ValidationResult.VALID).when(inClusterUpgradeValidator).isUpgradeDone(anyList());
    doReturn(ValidationResult.VALID).when(inClusterUpgradeValidator).isUpgradePossible(anyList(), anyList());
    doReturn(new HashMap<Guid, List<VmNumaNode>>()).when(vmNumaNodeDao).getVmNumaNodeInfoByClusterIdAsMap(any(Guid.class));
    if (StringUtils.isEmpty(group.getCpuName())) {
        doReturn(ArchitectureType.undefined).when(cmd).getArchitecture();
    } else {
        doReturn(ArchitectureType.x86_64).when(cmd).getArchitecture();
    }
    when(clusterDao.get(any(Guid.class))).thenReturn(createDefaultCluster());
    when(clusterDao.getByName(anyString())).thenReturn(createDefaultCluster());
    List<Cluster> clusterList = new ArrayList<>();
    clusterList.add(createDefaultCluster());
    when(clusterDao.getByName(anyString(), anyBoolean())).thenReturn(clusterList);
}
#end_block

#method_before
@Test
public void test200codeDontThrowException() {
    vmsService.add().vm(vm()).send();
}
#method_after
@Test
public void test200codeDontThrowException() throws Exception {
    setXmlResponse("vms", 200, "<vms/>");
    startServer();
    Connection connection = testConnection();
    VmsService vmsService = connection.systemService().vmsService();
    vmsService.add().vm(vm()).send();
    connection.close();
    stopServer();
}
#end_block

#method_before
@Test
public void test201codeDontThrowException() {
    vmsService.add().vm(vm()).send();
}
#method_after
@Test
public void test201codeDontThrowException() throws Exception {
    setXmlResponse("vms", 201, "<vms/>");
    startServer();
    Connection connection = testConnection();
    VmsService vmsService = connection.systemService().vmsService();
    vmsService.add().vm(vm()).send();
    connection.close();
    stopServer();
}
#end_block

#method_before
@Test
public void test202codeDontThrowException() {
    vmsService.add().vm(vm()).send();
}
#method_after
@Test
public void test202codeDontThrowException() throws Exception {
    setXmlResponse("vms", 202, "<vms/>");
    startServer();
    Connection connection = testConnection();
    VmsService vmsService = connection.systemService().vmsService();
    vmsService.add().vm(vm()).send();
    connection.close();
    stopServer();
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    String password = null;
    try {
        final String token = sessionDataContainer.getSsoAccessToken(getParameters().getSessionId());
        if (StringUtils.isEmpty(token)) {
            throw new RuntimeException("Unable to get sso access token for session.");
        }
        password = FiltersHelper.getPassword(token);
    } catch (Exception ex) {
        log.error("Unable to execute IsPasswordDelegationPossibleQuery with message {}", ex.getMessage());
        log.debug("Exception", ex);
    }
    getQueryReturnValue().setReturnValue(password != null);
    getQueryReturnValue().setSucceeded(true);
}
#method_after
@Override
protected void executeQueryCommand() {
    String password = null;
    try {
        password = SsoUtils.getPassword(sessionDataContainer.getSsoAccessToken(getParameters().getSessionId()));
    } catch (Exception ex) {
        log.error("Unable to execute IsPasswordDelegationPossibleQuery with message {}", ex.getMessage());
        log.debug("Exception", ex);
    }
    getQueryReturnValue().setReturnValue(password != null);
    getQueryReturnValue().setSucceeded(true);
}
#end_block

#method_before
@Override
protected void perform() {
    // Send the log on command to the virtual machine:
    final DbUser currentUser = getCurrentUser();
    final String password;
    try {
        final String token = sessionDataContainer.getSsoAccessToken(getParameters().getSessionId());
        if (StringUtils.isEmpty(token)) {
            throw new RuntimeException("Unable to get sso access token for session.");
        }
        password = FiltersHelper.getPassword(token);
        final String domainController = currentUser != null ? currentUser.getDomain() : "";
        final boolean sentToVM = runVdsCommand(VDSCommandType.VmLogon, new VmLogonVDSCommandParameters(getVdsId(), getVm().getId(), domainController, getUserName(), password)).getSucceeded();
        setSucceeded(sentToVM);
    } catch (Exception ex) {
        log.error("Unable to execute VmLogon with message {}", ex.getMessage());
        log.debug("Exception", ex);
    }
}
#method_after
@Override
protected void perform() {
    try {
        // Send the log on command to the virtual machine:
        final DbUser currentUser = getCurrentUser();
        final String password = SsoUtils.getPassword(sessionDataContainer.getSsoAccessToken(getParameters().getSessionId()));
        final String domainController = currentUser != null ? currentUser.getDomain() : "";
        final boolean sentToVM = runVdsCommand(VDSCommandType.VmLogon, new VmLogonVDSCommandParameters(getVdsId(), getVm().getId(), domainController, getUserName(), password)).getSucceeded();
        setSucceeded(sentToVM);
    } catch (Exception ex) {
        log.error("Unable to execute VmLogon with message {}", ex.getMessage());
        log.debug("Exception", ex);
    }
}
#end_block

#method_before
public void validatePmModels() {
    EntityModel<String> ip = getManagementIp();
    EntityModel<String> userName = getPmUserName();
    EntityModel<String> password = getPmPassword();
    ListModel<String> type = getPmType();
    EntityModel<Integer> port = getPmPort();
    EntityModel<String> options = getPmOptions();
    ip.validateEntity(new IValidation[] { new NotEmptyValidation(), new HostAddressValidation() });
    userName.validateEntity(new IValidation[] { new NotEmptyValidation() });
    password.validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(50) });
    type.validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    port.validateEntity(new IValidation[] { new IntegerValidation(1, 65535) });
    options.validateEntity(new IValidation[] { new KeyValuePairValidation(true, Arrays.asList(PM_PORT_KEY)) });
}
#method_after
public void validatePmModels() {
    EntityModel<String> ip = getManagementIp();
    EntityModel<String> userName = getPmUserName();
    EntityModel<String> password = getPmPassword();
    ListModel<String> type = getPmType();
    EntityModel<Integer> port = getPmPort();
    EntityModel<String> options = getPmOptions();
    ip.validateEntity(new IValidation[] { new NotEmptyValidation(), new HostAddressValidation() });
    userName.validateEntity(new IValidation[] { new NotEmptyValidation() });
    password.validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(50) });
    type.validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    port.validateEntity(new IValidation[] { new IntegerValidation(1, 65535) });
    options.validateEntity(new IValidation[] { new KeyValuePairValidation(true) {

        @Override
        protected void validateKeyValuePair(String key, String value, ValidationResult result) {
            super.validateKeyValuePair(key, value, result);
            IntegerValidation intValidation = new IntegerValidation();
            ValidationResult intResult = intValidation.validate(value);
            if (!intResult.getSuccess()) {
                result.getReasons().addAll(intResult.getReasons());
                result.setSuccess(false);
            }
        }
    } });
}
#end_block

#method_before
@Override
public ValidationResult validate(Object value) {
    ValidationResult result = new ValidationResult();
    if (value != null && value instanceof String && !value.equals("")) {
        // $NON-NLS-1$
        String strValue = (String) value;
        if (strValue.endsWith(",")) {
            // $NON-NLS-1$
            result.setSuccess(false);
        } else {
            // Try parse value.
            for (String pair : strValue.split("[,]", -1)) {
                // $NON-NLS-1$
                if (!result.getSuccess()) {
                    break;
                }
                // $NON-NLS-1$
                String[] array = pair.split("[=]", -1);
                // if the split length is 1 (key), we accept only when we allow it (allowAlsoKey==true)
                if (getallowAlsoKey()) {
                    if (array.length < 1 || array.length > 2) {
                        result.setSuccess(false);
                        break;
                    }
                } else {
                    if (array.length != 2) {
                        result.setSuccess(false);
                        break;
                    }
                }
                for (String t : array) {
                    if (StringUtils.isEmpty(t.trim())) {
                        result.setSuccess(false);
                        break;
                    }
                }
                if (result.getSuccess() && array.length == 2) {
                    // No problems so far, check if there are type issues.
                    validateInteger(array[0], array[1], result);
                }
            }
        }
    }
    if (!result.getSuccess()) {
        if (!getallowAlsoKey()) {
            result.getReasons().add(ConstantsManager.getInstance().getConstants().valueDoesntNotMatchPatternKeyValueKeyValueInvalidReason());
        } else {
            result.getReasons().add(ConstantsManager.getInstance().getConstants().valueDoesntNotNatchPatternKeyValueKeyKeyValueInvalidReason());
        }
    }
    return result;
}
#method_after
@Override
public ValidationResult validate(Object value) {
    ValidationResult result = new ValidationResult();
    if (value != null && value instanceof String && !value.equals("")) {
        // $NON-NLS-1$
        String strValue = (String) value;
        if (strValue.endsWith(",")) {
            // $NON-NLS-1$
            result.setSuccess(false);
        } else {
            // Try parse value.
            for (String pair : strValue.split("[,]", -1)) {
                // $NON-NLS-1$
                if (!result.getSuccess()) {
                    break;
                }
                // $NON-NLS-1$
                String[] array = pair.split("[=]", -1);
                // if the split length is 1 (key), we accept only when we allow it (allowAlsoKey==true)
                if (allowAlsoKey) {
                    if (array.length < 1 || array.length > 2) {
                        result.setSuccess(false);
                        break;
                    }
                } else {
                    if (array.length != 2) {
                        result.setSuccess(false);
                        break;
                    }
                }
                for (String t : array) {
                    if (StringUtils.isEmpty(t.trim())) {
                        result.setSuccess(false);
                        break;
                    }
                }
                if (result.getSuccess() && array.length == 2) {
                    // No problems so far, check if there are type issues.
                    validateKeyValuePair(array[0], array[1], result);
                }
            }
        }
    }
    if (!result.getSuccess()) {
        if (!allowAlsoKey) {
            result.getReasons().add(ConstantsManager.getInstance().getConstants().valueDoesntNotMatchPatternKeyValueKeyValueInvalidReason());
        } else {
            result.getReasons().add(ConstantsManager.getInstance().getConstants().valueDoesntNotNatchPatternKeyValueKeyKeyValueInvalidReason());
        }
    }
    return result;
}
#end_block

#method_before
public void addItem(Column<T, ?> column) {
    if (containsItem(column)) {
        return;
    }
    ColumnContextMenuItem<T> item = new ColumnContextMenuItem<>(controller, column);
    items.put(column, item);
    container.add(item);
}
#method_after
public void addItem(Column<T, ?> column) {
    if (containsItem(column)) {
        return;
    }
    ColumnContextMenuItem<T> newItem = new ColumnContextMenuItem<>(controller, column);
    items.put(column, newItem);
    container.add(newItem);
}
#end_block

#method_before
public void removeItem(Column<T, ?> column) {
    ColumnContextMenuItem<T> item = items.get(column);
    if (item != null) {
        items.remove(column);
        container.remove(item);
    }
}
#method_after
public void removeItem(Column<T, ?> column) {
    ColumnContextMenuItem<T> removedItem = items.remove(column);
    if (removedItem != null) {
        container.remove(removedItem);
    }
}
#end_block

#method_before
public void update() {
    title.setText(controller.getColumnContextMenuTitle(column));
    checkBox.setValue(controller.isColumnVisible(column));
    container.removeStyleName(style.dragOver());
}
#method_after
public void update() {
    title.setText(controller.getColumnContextMenuTitle(column));
    checkBox.setValue(controller.isColumnVisible(column));
    container.setStyleName(style.highlightable(), true);
    container.setStyleName(style.dragSource(), false);
    container.setStyleName(style.validDropTarget(), false);
}
#end_block

#method_before
@UiHandler("container")
void onDragStart(DragStartEvent event) {
    event.setData(DRAG_INDEX, String.valueOf(controller.getColumnIndex(column)));
    event.getDataTransfer().setDragImage(getElement(), event.getNativeEvent().getClientX() - getAbsoluteLeft(), event.getNativeEvent().getClientY() - getAbsoluteTop());
}
#method_after
@UiHandler("container")
void onDragStart(DragStartEvent event) {
    int itemColumnIndex = controller.getColumnIndex(column);
    // While the HTML5 DnD spec allows setting "drag data" within
    // "dragstart" event, it prevents access to that data in every
    // other event, except for the "drop" event. This way, it's not
    // possible to check "drag data" _during_ a drag operation, e.g.
    // in order to visually highlight a possible drop target.
    controller.setDragIndex(itemColumnIndex);
    // Without this, the DnD behavior doesn't seem to be triggered.
    // $NON-NLS-1$
    event.getDataTransfer().setData("text", String.valueOf(itemColumnIndex));
    // Define a custom drag image.
    event.getDataTransfer().setDragImage(getElement(), event.getNativeEvent().getClientX() - getAbsoluteLeft(), event.getNativeEvent().getClientY() - getAbsoluteTop());
}
#end_block

#method_before
@UiHandler("container")
void onDragOver(DragOverEvent event) {
    container.addStyleName(style.dragOver());
}
#method_after
@UiHandler("container")
void onDragOver(DragOverEvent event) {
    // This is actually needed for the "drop" event to fire at all.
    event.preventDefault();
    int draggedColumnIndex = controller.getDragIndex();
    int itemColumnIndex = controller.getColumnIndex(column);
    // Highlight the drop target.
    container.setStyleName(style.validDropTarget(), draggedColumnIndex != itemColumnIndex);
}
#end_block

#method_before
@UiHandler("container")
void onDragLeave(DragLeaveEvent event) {
    container.removeStyleName(style.dragOver());
}
#method_after
@UiHandler("container")
void onDragLeave(DragLeaveEvent event) {
    container.setStyleName(style.validDropTarget(), false);
}
#end_block

#method_before
@UiHandler("container")
void onDrop(DropEvent event) {
    event.preventDefault();
    int sourceIndex = Integer.valueOf(event.getData(DRAG_INDEX));
    Column<T, ?> sourceColumn = controller.getColumn(sourceIndex);
    if (sourceIndex != controller.getColumnIndex(column)) {
        controller.swapColumns(sourceColumn, column);
    }
}
#method_after
@UiHandler("container")
void onDrop(DropEvent event) {
    // Make sure to prevent the (useless) default browser action,
    // e.g. "open as link" for the dropped element.
    event.preventDefault();
    int draggedColumnIndex = controller.getDragIndex();
    int itemColumnIndex = controller.getColumnIndex(column);
    // Swap the columns.
    if (draggedColumnIndex != itemColumnIndex) {
        controller.swapColumns(controller.getColumn(draggedColumnIndex), column);
    }
    // Reset the drag index.
    controller.setDragIndex(ColumnController.NO_DRAG);
}
#end_block

#method_before
private void handleEndedTask() {
    AsyncTask asyncTask = getParameters().getDbAsyncTask();
    log.debug("Task of command: {} with id: {} has ended.", asyncTask.getActionType(), getCommandId());
    // last access time to now.
    if (getState() != AsyncTaskState.Ended) {
        setState(AsyncTaskState.Ended);
        setLastStatusAccessTime();
    }
    CommandEntity rootCmdEntity = coco.getCommandEntity(asyncTask.getRootCommandId());
    // if the task's root command has failed
    if (rootCmdEntity != null && !rootCmdEntity.isExecuted()) {
        // mark it as a task of a partially completed command
        // Will result in failure of the command
        setPartiallyCompletedCommandTask(true);
        log.debug("Marking task of command: {} with id: {} as partially completed.", asyncTask.getActionType(), getCommandId());
    }
    // Fail zombie task and task that belongs to a partially submitted command
    if (isZombieTask() || isPartiallyCompletedCommandTask()) {
        log.debug("Task of command: {} with id: {} is a zombie or is partially completed, executing failure logic.", asyncTask.getActionType(), getCommandId());
        getParameters().getDbAsyncTask().getTaskParameters().setTaskGroupSuccess(false);
        ExecutionHandler.getInstance().endTaskStep(parameters.getDbAsyncTask().getStepId(), JobExecutionStatus.FAILED);
        onTaskEndFailure();
    }
    if (hasTaskEndedSuccessfully()) {
        log.debug("Task of command: {} with id: {} has succeeded, executing success logic.", asyncTask.getActionType(), getCommandId());
        ExecutionHandler.getInstance().endTaskStep(parameters.getDbAsyncTask().getStepId(), JobExecutionStatus.FINISHED);
        onTaskEndSuccess();
    } else if (hasTaskEndedInFailure()) {
        log.debug("Task of command: {} with id: {} has failed, executing failure logic.", asyncTask.getActionType(), getCommandId());
        ExecutionHandler.getInstance().endTaskStep(parameters.getDbAsyncTask().getStepId(), JobExecutionStatus.FAILED);
        onTaskEndFailure();
    } else if (!doesTaskExist()) {
        log.debug("Task of command: {} with id: {} does not exist, executing cleanup logic.", asyncTask.getActionType(), getCommandId());
        ExecutionHandler.getInstance().endTaskStep(parameters.getDbAsyncTask().getStepId(), JobExecutionStatus.UNKNOWN);
        onTaskDoesNotExist();
    }
}
#method_after
private void handleEndedTask() {
    AsyncTask asyncTask = getParameters().getDbAsyncTask();
    log.debug("Task of command {} with id '{}' has ended.", asyncTask.getActionType(), getCommandId());
    // last access time to now.
    if (getState() != AsyncTaskState.Ended) {
        setState(AsyncTaskState.Ended);
        setLastStatusAccessTime();
    }
    CommandEntity rootCmdEntity = coco.getCommandEntity(asyncTask.getRootCommandId());
    // if the task's root command has failed
    if (rootCmdEntity != null && !rootCmdEntity.isExecuted()) {
        // mark it as a task of a partially completed command
        // Will result in failure of the command
        setPartiallyCompletedCommandTask(true);
        log.debug("Marking task of command {} with id '{}' as partially completed.", asyncTask.getActionType(), getCommandId());
    }
    // Fail zombie task and task that belongs to a partially submitted command
    if (isZombieTask() || isPartiallyCompletedCommandTask()) {
        log.debug("Task of command {} with id '{}' is a zombie or is partially completed, executing failure logic.", asyncTask.getActionType(), getCommandId());
        getParameters().getDbAsyncTask().getTaskParameters().setTaskGroupSuccess(false);
        ExecutionHandler.getInstance().endTaskStep(parameters.getDbAsyncTask().getStepId(), JobExecutionStatus.FAILED);
        onTaskEndFailure();
    }
    if (hasTaskEndedSuccessfully()) {
        log.debug("Task of command {} with id '{}' has succeeded, executing success logic.", asyncTask.getActionType(), getCommandId());
        ExecutionHandler.getInstance().endTaskStep(parameters.getDbAsyncTask().getStepId(), JobExecutionStatus.FINISHED);
        onTaskEndSuccess();
    } else if (hasTaskEndedInFailure()) {
        log.debug("Task of command {} with id '{}' has failed, executing failure logic.", asyncTask.getActionType(), getCommandId());
        ExecutionHandler.getInstance().endTaskStep(parameters.getDbAsyncTask().getStepId(), JobExecutionStatus.FAILED);
        onTaskEndFailure();
    } else if (!doesTaskExist()) {
        log.debug("Task of command {} with id '{}' does not exist, executing cleanup logic.", asyncTask.getActionType(), getCommandId());
        ExecutionHandler.getInstance().endTaskStep(parameters.getDbAsyncTask().getStepId(), JobExecutionStatus.UNKNOWN);
        onTaskDoesNotExist();
    }
}
#end_block

#method_before
private void updateTaskStatuses(Map<Guid, Map<Guid, AsyncTaskStatus>> poolsAllTasksMap) {
    for (SPMTask task : _tasks.values()) {
        if (task.getShouldPoll()) {
            Map<Guid, AsyncTaskStatus> asyncTasksForPoolMap = poolsAllTasksMap.get(task.getStoragePoolID());
            // If the storage pool id exists
            if (asyncTasksForPoolMap != null) {
                AsyncTaskStatus cachedAsyncTaskStatus = asyncTasksForPoolMap.get(task.getVdsmTaskId());
                log.debug("Updating task of command: {} with id: {} to status: {}.", task.getParameters().getDbAsyncTask().getActionType(), task.getCommandId(), cachedAsyncTaskStatus);
                // task found in VDSM.
                task.updateTask(cachedAsyncTaskStatus);
            }
        } else {
            log.debug("Not updating task of command: {} with id: {} and status: {}.", task.getParameters().getDbAsyncTask().getActionType(), task.getCommandId(), task.getLastTaskStatus());
        }
    }
}
#method_after
private void updateTaskStatuses(Map<Guid, Map<Guid, AsyncTaskStatus>> poolsAllTasksMap) {
    for (SPMTask task : _tasks.values()) {
        if (task.getShouldPoll()) {
            Map<Guid, AsyncTaskStatus> asyncTasksForPoolMap = poolsAllTasksMap.get(task.getStoragePoolID());
            // If the storage pool id exists
            if (asyncTasksForPoolMap != null) {
                AsyncTaskStatus cachedAsyncTaskStatus = asyncTasksForPoolMap.get(task.getVdsmTaskId());
                log.debug("Updating task of command {} with id '{}' to status '{}'.", task.getParameters().getDbAsyncTask().getActionType(), task.getCommandId(), cachedAsyncTaskStatus);
                // task found in VDSM.
                task.updateTask(cachedAsyncTaskStatus);
            }
        } else {
            log.debug("Not updating task of command {} with id '{}' and status '{}'.", task.getParameters().getDbAsyncTask().getActionType(), task.getCommandId(), task.getLastTaskStatus());
        }
    }
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    if (isVmExist()) {
        Version compatibilityVersion = getEffectiveCompatibilityVersion();
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getParameters().getVmStaticData());
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getVm().getStaticData());
    }
    VmHandler.updateDefaultTimeZone(getParameters().getVmStaticData());
    VmHandler.autoSelectUsbPolicy(getParameters().getVmStaticData(), getCluster());
    VmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getVmStaticData(), getCluster(), getParameters().getGraphicsDevices());
    updateParametersVmFromInstanceType();
    // we always need to verify new or existing numa nodes with the updated VM configuration
    if (!getParameters().isUpdateNuma()) {
        getParameters().getVm().setvNumaNodeList(getDbFacade().getVmNumaNodeDao().getAllVmNumaNodeByVmId(getParameters().getVmId()));
    }
}
#method_after
@Override
protected void init() {
    super.init();
    if (isVmExist()) {
        Version compatibilityVersion = getEffectiveCompatibilityVersion();
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getParameters().getVmStaticData());
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getVm().getStaticData());
    }
    VmHandler.updateDefaultTimeZone(getParameters().getVmStaticData());
    VmHandler.autoSelectUsbPolicy(getParameters().getVmStaticData());
    VmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getVmStaticData(), getCluster(), getParameters().getGraphicsDevices());
    updateParametersVmFromInstanceType();
    // we always need to verify new or existing numa nodes with the updated VM configuration
    if (!getParameters().isUpdateNuma()) {
        getParameters().getVm().setvNumaNodeList(getDbFacade().getVmNumaNodeDao().getAllVmNumaNodeByVmId(getParameters().getVmId()));
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    int numOfSockets = newVmStatic.getNumOfSockets();
    int threadsPerCpu = newVmStatic.getThreadsPerCpu();
    int memSizeMb = newVmStatic.getMemSizeMb();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(cpuPerSocket, numOfSockets, threadsPerCpu);
        hotSetMemory(memSizeMb);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDao().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    // Trigger OVF store update for hosted engine edits
    if (newVmStatic.getOrigin() == OriginType.MANAGED_HOSTED_ENGINE) {
        OvfDataUpdater.getInstance().triggerNow();
    }
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // Trigger OVF update for hosted engine VM only
    if (getVm().isHostedEngine()) {
        registerRollbackHandler(new HostedEngineEditNotifier(getVm()));
    }
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDao().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
private void createNextRunSnapshot() {
    // first remove existing snapshot
    Snapshot runSnap = getSnapshotDao().get(getVmId(), Snapshot.SnapshotType.NEXT_RUN);
    if (runSnap != null) {
        getSnapshotDao().remove(runSnap.getId());
    }
    VM vm = new VM();
    vm.setStaticData(getParameters().getVmStaticData());
    // create new snapshot with new configuration
    new SnapshotsManager().addSnapshot(Guid.newGuid(), "Next Run configuration snapshot", Snapshot.SnapshotStatus.OK, Snapshot.SnapshotType.NEXT_RUN, vm, true, StringUtils.EMPTY, Collections.<DiskImage>emptyList(), VmDeviceUtils.getVmDevicesForNextRun(getVm(), getParameters()), getCompensationContext());
}
#method_after
private void createNextRunSnapshot() {
    // first remove existing snapshot
    Snapshot runSnap = getSnapshotDao().get(getVmId(), Snapshot.SnapshotType.NEXT_RUN);
    if (runSnap != null) {
        getSnapshotDao().remove(runSnap.getId());
    }
    VM vm = new VM();
    vm.setStaticData(getParameters().getVmStaticData());
    // create new snapshot with new configuration
    new SnapshotsManager().addSnapshot(Guid.newGuid(), "Next Run configuration snapshot", Snapshot.SnapshotStatus.OK, Snapshot.SnapshotType.NEXT_RUN, vm, true, StringUtils.EMPTY, Collections.<DiskImage>emptyList(), getVmDeviceUtils().getVmDevicesForNextRun(getVm(), getParameters()), getCompensationContext());
}
#end_block

#method_before
private void hotSetCpus(int cpuPerSocket, int newNumOfSockets, int newThreadsPerCpu) {
    int currentSockets = getVm().getNumOfSockets();
    int currentCpuPerSocket = getVm().getCpuPerSocket();
    int currentThreadsPerCpu = getVm().getThreadsPerCpu();
    // try hotplug only if topology (cpuPerSocket, threadsPerCpu) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && currentSockets != newNumOfSockets && currentCpuPerSocket == cpuPerSocket && currentThreadsPerCpu == newThreadsPerCpu) {
        HotSetNumberOfCpusParameters params = new HotSetNumberOfCpusParameters(newVmStatic, currentSockets < newNumOfSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        setNumberOfCpusResult = runInternalAction(VdcActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newNumOfSockets : currentSockets);
        hotSetCpusLog(params);
    }
}
#method_after
private void hotSetCpus(VM newVm) {
    int currentSockets = getVm().getNumOfSockets();
    int newNumOfSockets = newVm.getNumOfSockets();
    // try hotplug only if topology (cpuPerSocket, threadsPerCpu) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && VmCommonUtils.isCpusToBeHotplugged(getVm(), newVm)) {
        HotSetNumberOfCpusParameters params = new HotSetNumberOfCpusParameters(newVmStatic, currentSockets < newNumOfSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        setNumberOfCpusResult = runInternalAction(VdcActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        // into the OVF store and automatically used during the next HE VM start
        if (!getVm().isHostedEngine()) {
            newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newNumOfSockets : currentSockets);
        }
        hotSetCpusLog(params);
    }
}
#end_block

#method_before
private void hotSetMemory(int newAmountOfMemory) {
    int currentMemory = getVm().getMemSizeMb();
    if (getVm().getStatus() == VMStatus.Up && currentMemory != newAmountOfMemory) {
        HotSetAmountOfMemoryParameters params = new HotSetAmountOfMemoryParameters(newVmStatic, currentMemory < newAmountOfMemory ? PlugAction.PLUG : PlugAction.UNPLUG, // We always use node 0, auto-numa should handle the allocation
        0);
        VdcReturnValueBase setAmountOfMemoryResult = runInternalAction(VdcActionType.HotSetAmountOfMemory, params, cloneContextAndDetachFromParent());
        newVmStatic.setMemSizeMb(setAmountOfMemoryResult.getSucceeded() ? newAmountOfMemory : currentMemory);
        hotSetMemlog(params, setAmountOfMemoryResult);
    }
}
#method_after
private void hotSetMemory(int currentMemory, int newAmountOfMemory) {
    HotSetAmountOfMemoryParameters params = new HotSetAmountOfMemoryParameters(newVmStatic, currentMemory < newAmountOfMemory ? PlugAction.PLUG : PlugAction.UNPLUG, // We always use node 0, auto-numa should handle the allocation
    0);
    VdcReturnValueBase setAmountOfMemoryResult = runInternalAction(VdcActionType.HotSetAmountOfMemory, params, cloneContextAndDetachFromParent());
    // into the OVF store and automatically used during the next HE VM start
    if (!getVm().isHostedEngine()) {
        newVmStatic.setMemSizeMb(setAmountOfMemoryResult.getSucceeded() ? newAmountOfMemory : currentMemory);
    }
    hotSetMemlog(params, setAmountOfMemoryResult);
}
#end_block

#method_before
private void hotSetCpusLog(HotSetNumberOfCpusParameters params) {
    if (!setNumberOfCpusResult.isValid()) {
        AuditLogableBase logable = new HotSetNumberOfCpusCommand<>(params);
        List<String> validationMessages = getBackend().getErrorsTranslator().translateErrorText(setNumberOfCpusResult.getValidationMessages());
        logable.addCustomValue(HotSetNumberOfCpusCommand.LOGABLE_FIELD_ERROR_MESSAGE, StringUtils.join(validationMessages, ","));
        auditLogDirector.log(logable, AuditLogType.FAILED_HOT_SET_NUMBER_OF_CPUS);
    }
}
#method_after
private void hotSetCpusLog(HotSetNumberOfCpusParameters params) {
    if (!setNumberOfCpusResult.isValid()) {
        AuditLogableBase logable = new HotSetNumberOfCpusCommand<>(params, null);
        List<String> validationMessages = getBackend().getErrorsTranslator().translateErrorText(setNumberOfCpusResult.getValidationMessages());
        logable.addCustomValue(HotSetNumberOfCpusCommand.LOGABLE_FIELD_ERROR_MESSAGE, StringUtils.join(validationMessages, ","));
        auditLogDirector.log(logable, AuditLogType.FAILED_HOT_SET_NUMBER_OF_CPUS);
    }
}
#end_block

#method_before
private void hotSetMemlog(HotSetAmountOfMemoryParameters params, VdcReturnValueBase setAmountOfMemoryResult) {
    if (!setAmountOfMemoryResult.isValid()) {
        AuditLogableBase logable = new HotSetAmountOfMemoryCommand<>(params);
        List<String> validationMessages = getBackend().getErrorsTranslator().translateErrorText(setAmountOfMemoryResult.getValidationMessages());
        logable.addCustomValue(HotSetAmountOfMemoryCommand.LOGABLE_FIELD_ERROR_MESSAGE, StringUtils.join(validationMessages, ","));
        auditLogDirector.log(logable, AuditLogType.FAILED_HOT_SET_NUMBER_OF_CPUS);
    }
}
#method_after
private void hotSetMemlog(HotSetAmountOfMemoryParameters params, VdcReturnValueBase setAmountOfMemoryResult) {
    if (!setAmountOfMemoryResult.isValid()) {
        AuditLogableBase logable = new HotSetAmountOfMemoryCommand<>(params, null);
        List<String> validationMessages = getBackend().getErrorsTranslator().translateErrorText(setAmountOfMemoryResult.getValidationMessages());
        logable.addCustomValue(HotSetAmountOfMemoryCommand.LOGABLE_FIELD_ERROR_MESSAGE, StringUtils.join(validationMessages, ","));
        auditLogDirector.log(logable, AuditLogType.FAILED_HOT_SET_MEMORY);
    }
}
#end_block

#method_before
protected void updateVmPayload() {
    VmDeviceDao dao = getVmDeviceDao();
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null || getParameters().isClearPayload()) {
        List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.DISK);
        VmDevice oldPayload = null;
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                oldPayload = disk;
                break;
            }
        }
        if (oldPayload != null) {
            List<VmDeviceId> devs = new ArrayList<>();
            devs.add(oldPayload.getId());
            dao.removeAll(devs);
        }
        if (!getParameters().isClearPayload()) {
            VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true);
        }
    }
}
#method_after
protected void updateVmPayload() {
    VmDeviceDao dao = getVmDeviceDao();
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null || getParameters().isClearPayload()) {
        List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.DISK);
        VmDevice oldPayload = null;
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                oldPayload = disk;
                break;
            }
        }
        if (oldPayload != null) {
            List<VmDeviceId> devs = new ArrayList<>();
            devs.add(oldPayload.getId());
            dao.removeAll(devs);
        }
        if (!getParameters().isClearPayload()) {
            getVmDeviceUtils().addManagedDevice(new VmDeviceId(Guid.newGuid(), getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true);
        }
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion())).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (isVirtioScsiEnabled()) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getEffectiveCompatibilityVersion())) {
            return failValidation(EngineMessage.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId()) && !setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(Injector.get(InClusterUpgradeValidator.class).isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<Disk> allDisks = getDbFacade().getDiskDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), vmFromParams.getNumOfMonitors(), interfaces, allDisks, isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), isSoundDeviceEnabled(), getReturnValue().getValidationMessages());
}
#method_after
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<DiskVmElement> diskVmElements = getDbFacade().getDiskVmElementDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), vmFromParams.getNumOfMonitors(), interfaces, diskVmElements, isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), isSoundDeviceEnabled(), getReturnValue().getValidationMessages());
}
#end_block

#method_before
private boolean isRunningConfigurationNeeded() {
    return getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus(), isHotSetEnabled()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters());
}
#method_after
private boolean isRunningConfigurationNeeded() {
    if (getVm().isHostedEngine()) {
        // Hosted Engine never uses the next run configuration
        return false;
    }
    return getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus(), isHotSetEnabled()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters());
}
#end_block

#method_before
public boolean isVirtioScsiEnabledForVm(Guid vmId) {
    return VmDeviceUtils.hasVirtioScsiController(vmId);
}
#method_after
public boolean isVirtioScsiEnabledForVm(Guid vmId) {
    return getVmDeviceUtils().hasVirtioScsiController(vmId);
}
#end_block

#method_before
protected boolean isBalloonEnabled() {
    Boolean balloonEnabled = getParameters().isBalloonEnabled();
    return balloonEnabled != null ? balloonEnabled : VmDeviceUtils.hasMemoryBalloon(getVmId());
}
#method_after
protected boolean isBalloonEnabled() {
    Boolean balloonEnabled = getParameters().isBalloonEnabled();
    return balloonEnabled != null ? balloonEnabled : getVmDeviceUtils().hasMemoryBalloon(getVmId());
}
#end_block

#method_before
protected boolean isSoundDeviceEnabled() {
    Boolean soundDeviceEnabled = getParameters().isSoundDeviceEnabled();
    return soundDeviceEnabled != null ? soundDeviceEnabled : VmDeviceUtils.hasSoundDevice(getVmId());
}
#method_after
protected boolean isSoundDeviceEnabled() {
    Boolean soundDeviceEnabled = getParameters().isSoundDeviceEnabled();
    return soundDeviceEnabled != null ? soundDeviceEnabled : getVmDeviceUtils().hasSoundDevice(getVmId());
}
#end_block

#method_before
@Test
public void validateSucceedsOnDiskDomainCheckWhenNoDisks() throws Exception {
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId);
    mockVm();
    mockEntities(storageId);
    runAndAssertValidateSuccess();
}
#method_after
@Test
public void validateSucceedsOnDiskDomainCheckWhenNoDisks() throws Exception {
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId);
    mockEntities(storageId);
    runAndAssertValidateSuccess();
}
#end_block

#method_before
@Test
public void validateFailWithUnsupportedDiskInterface() throws Exception {
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId);
    mockVm();
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    mockMaxPciSlots();
    when(diskValidator.isReadOnlyPropertyCompatibleWithInterface(any(DiskVmElement.class))).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskInterfaceSupported(any(VM.class), any(DiskVmElement.class))).thenReturn(new ValidationResult(EngineMessage.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED));
    when(diskValidator.isVirtIoScsiValid(any(VM.class), any(DiskVmElement.class))).thenReturn(ValidationResult.VALID);
    when(command.getDiskValidator(any(Disk.class))).thenReturn(diskValidator);
    assertFalse(command.validate());
    assertTrue(command.getReturnValue().getValidationMessages().contains(EngineMessage.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED.toString()));
}
#method_after
@Test
public void validateFailWithUnsupportedDiskInterface() throws Exception {
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId);
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    mockMaxPciSlots();
    when(diskVmElementValidator.isReadOnlyPropertyCompatibleWithInterface()).thenReturn(ValidationResult.VALID);
    when(diskVmElementValidator.isDiskInterfaceSupported(any(VM.class))).thenReturn(new ValidationResult(EngineMessage.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED));
    when(diskVmElementValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(command.getDiskVmElementValidator(any(Disk.class), any(DiskVmElement.class))).thenReturn(diskVmElementValidator);
    assertFalse(command.validate());
    assertTrue(command.getReturnValue().getValidationMessages().contains(EngineMessage.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED.toString()));
}
#end_block

#method_before
@Test
public void validateSpaceValidationSucceeds() {
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId, VolumeType.Preallocated);
    mockVm();
    mockEntities(storageId);
    doReturn(mockStorageDomainValidatorWithSpace()).when(command).createStorageDomainValidator();
    assertTrue(command.validate());
}
#method_after
@Test
public void validateSpaceValidationSucceeds() {
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId, VolumeType.Preallocated);
    mockEntities(storageId);
    doReturn(mockStorageDomainValidatorWithSpace()).when(command).createStorageDomainValidator();
    assertTrue(command.validate());
}
#end_block

#method_before
@Test
public void validateSpaceValidationFails() {
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId, VolumeType.Sparse);
    mockVm();
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    mockMaxPciSlots();
    doReturn(mockStorageDomainValidatorWithoutSpace()).when(command).createStorageDomainValidator();
    assertFalse(command.validate());
    assertTrue(command.getReturnValue().getValidationMessages().contains(EngineMessage.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN.toString()));
}
#method_after
@Test
public void validateSpaceValidationFails() {
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId, VolumeType.Sparse);
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    mockMaxPciSlots();
    doReturn(mockStorageDomainValidatorWithoutSpace()).when(command).createStorageDomainValidator();
    assertFalse(command.validate());
    assertTrue(command.getReturnValue().getValidationMessages().contains(EngineMessage.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN.toString()));
}
#end_block

#method_before
@Test
public void validateMaxBlockDiskSizeCheckSucceeds() {
    Guid storageId = Guid.newGuid();
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(createDiskImage(MAX_BLOCK_SIZE));
    initializeCommand(storageId, parameters);
    mockVm();
    mockStorageDomain(storageId, StorageType.ISCSI);
    mockStoragePoolIsoMap();
    mockInterfaceList();
    mockMaxPciSlots();
    runAndAssertValidateSuccess();
}
#method_after
@Test
public void validateMaxBlockDiskSizeCheckSucceeds() {
    Guid storageId = Guid.newGuid();
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(createDiskImage(MAX_BLOCK_SIZE));
    initializeCommand(storageId, parameters);
    mockStorageDomain(storageId, StorageType.ISCSI);
    mockStoragePoolIsoMap();
    mockInterfaceList();
    mockMaxPciSlots();
    runAndAssertValidateSuccess();
}
#end_block

#method_before
@Test
public void validateMaxBlockDiskSizeCheckFails() {
    Guid storageId = Guid.newGuid();
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(createDiskImage(MAX_BLOCK_SIZE * 2));
    initializeCommand(storageId, parameters);
    mockVm();
    mockStorageDomain(storageId, StorageType.ISCSI);
    mockStoragePoolIsoMap();
    mockMaxPciSlots();
    assertFalse(command.validate());
    assertTrue(command.getReturnValue().getValidationMessages().contains(EngineMessage.ACTION_TYPE_FAILED_DISK_MAX_SIZE_EXCEEDED.toString()));
}
#method_after
@Test
public void validateMaxBlockDiskSizeCheckFails() {
    Guid storageId = Guid.newGuid();
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(createDiskImage(MAX_BLOCK_SIZE * 2));
    initializeCommand(storageId, parameters);
    mockStorageDomain(storageId, StorageType.ISCSI);
    mockStoragePoolIsoMap();
    mockMaxPciSlots();
    assertFalse(command.validate());
    assertTrue(command.getReturnValue().getValidationMessages().contains(EngineMessage.ACTION_TYPE_FAILED_DISK_MAX_SIZE_EXCEEDED.toString()));
}
#end_block

#method_before
@Test
public void validateShareableDiskVolumeFormatSucceeds() {
    DiskImage image = createShareableDiskImage();
    image.setVolumeFormat(VolumeFormat.RAW);
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(image);
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId, parameters);
    mockVm();
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    mockInterfaceList();
    mockMaxPciSlots();
    runAndAssertValidateSuccess();
}
#method_after
@Test
public void validateShareableDiskVolumeFormatSucceeds() {
    DiskImage image = createShareableDiskImage();
    image.setVolumeFormat(VolumeFormat.RAW);
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(image);
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId, parameters);
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    mockInterfaceList();
    mockMaxPciSlots();
    runAndAssertValidateSuccess();
}
#end_block

#method_before
@Test
public void validateShareableDiskVolumeFormatFails() {
    DiskImage image = createShareableDiskImage();
    image.setVolumeFormat(VolumeFormat.COW);
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(image);
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId, parameters);
    mockVm();
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    mockMaxPciSlots();
    assertFalse(command.validate());
    assertTrue(command.getReturnValue().getValidationMessages().contains(EngineMessage.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT.toString()));
}
#method_after
@Test
public void validateShareableDiskVolumeFormatFails() {
    DiskImage image = createShareableDiskImage();
    image.setVolumeFormat(VolumeFormat.COW);
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(image);
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId, parameters);
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    mockMaxPciSlots();
    assertFalse(command.validate());
    assertTrue(command.getReturnValue().getValidationMessages().contains(EngineMessage.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT.toString()));
}
#end_block

#method_before
@Test
public void validateShareableDiskOnGlusterFails() {
    DiskImage image = createShareableDiskImage();
    image.setVolumeFormat(VolumeFormat.RAW);
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(image);
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId, parameters);
    mockVm();
    mockStorageDomain(storageId, StorageType.GLUSTERFS);
    mockStoragePoolIsoMap();
    mockMaxPciSlots();
    assertFalse(command.validate());
    assertTrue(command.getReturnValue().getValidationMessages().contains(EngineMessage.ACTION_TYPE_FAILED_SHAREABLE_DISKS_NOT_SUPPORTED_ON_GLUSTER_DOMAIN.toString()));
}
#method_after
@Test
public void validateShareableDiskOnGlusterFails() {
    DiskImage image = createShareableDiskImage();
    image.setVolumeFormat(VolumeFormat.RAW);
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(image);
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId, parameters);
    mockStorageDomain(storageId, StorageType.GLUSTERFS);
    mockStoragePoolIsoMap();
    mockMaxPciSlots();
    assertFalse(command.validate());
    assertTrue(command.getReturnValue().getValidationMessages().contains(EngineMessage.ACTION_TYPE_FAILED_SHAREABLE_DISKS_NOT_SUPPORTED_ON_GLUSTER_DOMAIN.toString()));
}
#end_block

#method_before
private void initializeCommand(Guid storageId, AddDiskParameters params) {
    params.setStorageDomainId(storageId);
    command = spy(new AddDiskCommand<>(params, null));
    doReturn(storageDomainDao).when(command).getStorageDomainDao();
    doReturn(storagePoolIsoMapDao).when(command).getStoragePoolIsoMapDao();
    doReturn(storagePoolDao).when(command).getStoragePoolDao();
    doReturn(vmNicDao).when(command).getVmNicDao();
    doReturn(diskLunMapDao).when(command).getDiskLunMapDao();
    doReturn(diskVmElementDao).when(command).getDiskVmElementDao();
    doReturn(vmDao).when(command).getVmDao();
    doNothing().when(command).updateDisksFromDb();
    doReturn(true).when(command).checkImageConfiguration();
    doReturn(mockSnapshotValidator()).when(command).getSnapshotsValidator();
    doReturn(false).when(command).isVirtioScsiControllerAttached(any(Guid.class));
    doReturn(false).when(command).hasWatchdog(any(Guid.class));
    doReturn(false).when(command).isBalloonEnabled(any(Guid.class));
    doReturn(false).when(command).isSoundDeviceEnabled(any(Guid.class));
    doReturn(true).when(command).setAndValidateDiskProfiles();
    doReturn(new ArrayList<>()).when(diskVmElementDao).getAllForVm(vmId);
    doReturn(true).when(command).validateQuota();
    doReturn(quotaManager).when(command).getQuotaManager();
    doAnswer(invocation -> invocation.getArguments()[0] != null ? invocation.getArguments()[0] : Guid.newGuid()).when(quotaManager).getDefaultQuotaIfNull(any(Guid.class), any(Guid.class));
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
}
#method_after
private void initializeCommand(Guid storageId, AddDiskParameters params) {
    params.setStorageDomainId(storageId);
    command = spy(new AddDiskCommand<>(params, null));
    doReturn(storageDomainDao).when(command).getStorageDomainDao();
    doReturn(storagePoolIsoMapDao).when(command).getStoragePoolIsoMapDao();
    doReturn(storagePoolDao).when(command).getStoragePoolDao();
    doReturn(vmNicDao).when(command).getVmNicDao();
    doReturn(diskLunMapDao).when(command).getDiskLunMapDao();
    doReturn(diskVmElementDao).when(command).getDiskVmElementDao();
    doReturn(vmDao).when(command).getVmDao();
    doNothing().when(command).updateDisksFromDb();
    doReturn(true).when(command).checkImageConfiguration();
    doReturn(mockSnapshotValidator()).when(command).getSnapshotsValidator();
    doReturn(false).when(command).isVirtioScsiControllerAttached(any(Guid.class));
    doReturn(false).when(command).hasWatchdog(any(Guid.class));
    doReturn(false).when(command).isBalloonEnabled(any(Guid.class));
    doReturn(false).when(command).isSoundDeviceEnabled(any(Guid.class));
    doReturn(true).when(command).setAndValidateDiskProfiles();
    doReturn(new ArrayList<>()).when(diskVmElementDao).getAllForVm(vmId);
    doReturn(true).when(command).validateQuota();
    doReturn(quotaManager).when(command).getQuotaManager();
    doAnswer(invocation -> invocation.getArguments()[0] != null ? invocation.getArguments()[0] : Guid.newGuid()).when(quotaManager).getDefaultQuotaIfNull(any(Guid.class), any(Guid.class));
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    SimpleDependencyInjector.getInstance().bind(VmDeviceUtils.class, vmDeviceUtils);
}
#end_block

#method_before
private DiskValidator spyDiskValidator(Disk disk) {
    DiskValidator diskValidator = spy(new DiskValidator(disk, vmDeviceUtils));
    doReturn(diskValidator).when(command).getDiskValidator(disk);
    return diskValidator;
}
#method_after
private DiskValidator spyDiskValidator(Disk disk) {
    DiskValidator diskValidator = spy(new DiskValidator(disk));
    doReturn(diskValidator).when(command).getDiskValidator(disk);
    return diskValidator;
}
#end_block

#method_before
private static LunDisk createISCSILunDisk() {
    LunDisk disk = new LunDisk();
    LUNs lun = new LUNs();
    lun.setLUNId("lunid");
    lun.setLunType(StorageType.ISCSI);
    StorageServerConnections connection = new StorageServerConnections();
    connection.setIqn("a");
    connection.setConnection("0.0.0.0");
    connection.setPort("1234");
    ArrayList<StorageServerConnections> connections = new ArrayList<>();
    connections.add(connection);
    lun.setLunConnections(connections);
    disk.setLun(lun);
    disk.setId(Guid.newGuid());
    DiskVmElement dve = new DiskVmElement(disk.getId(), vmId);
    disk.setDiskVmElements(Collections.singletonList(dve));
    return disk;
}
#method_after
private static LunDisk createISCSILunDisk() {
    LunDisk disk = new LunDisk();
    LUNs lun = new LUNs();
    lun.setLUNId("lunid");
    lun.setLunType(StorageType.ISCSI);
    StorageServerConnections connection = new StorageServerConnections();
    connection.setIqn("a");
    connection.setConnection("0.0.0.0");
    connection.setPort("1234");
    ArrayList<StorageServerConnections> connections = new ArrayList<>();
    connections.add(connection);
    lun.setLunConnections(connections);
    disk.setLun(lun);
    disk.setId(Guid.newGuid());
    return disk;
}
#end_block

#method_before
@Test
public void testIscsiLunCannotBeAddedIfSgioIsFilteredAndScsiReservationEnabled() {
    LunDisk disk = createISCSILunDisk(ScsiGenericIO.FILTERED, true, DiskInterface.IDE);
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(disk);
    initializeCommand(Guid.newGuid(), parameters);
    mockVm();
    mockInterfaceList();
    assertFalse("Lun disk added successfully WHILE sgio is filtered and scsi reservation is enabled", command.checkIfLunDiskCanBeAdded(spyDiskValidator(disk)));
    verifyValidationMessagesContainMessage(EngineMessage.ACTION_TYPE_FAILED_SGIO_IS_FILTERED);
}
#method_after
@Test
public void testIscsiLunCannotBeAddedIfSgioIsFilteredAndScsiReservationEnabled() {
    LunDisk disk = createISCSILunDisk(ScsiGenericIO.FILTERED, true, DiskInterface.IDE);
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(disk);
    initializeCommand(Guid.newGuid(), parameters);
    mockInterfaceList();
    assertFalse("Lun disk added successfully WHILE sgio is filtered and scsi reservation is enabled", command.checkIfLunDiskCanBeAdded(spyDiskValidator(disk)));
    verifyValidationMessagesContainMessage(EngineMessage.ACTION_TYPE_FAILED_SGIO_IS_FILTERED);
}
#end_block

#method_before
@Test
public void testLunDiskInvalid() {
    VDS vds = mockVds();
    LunDisk disk = createISCSILunDisk();
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(disk);
    parameters.setVdsId(vds.getId());
    initializeCommand(Guid.newGuid(), parameters);
    command.setVds(vds);
    mockVm();
    mockMaxPciSlots();
    mockInterfaceList();
    List<LUNs> luns = Collections.emptyList();
    doReturn(luns).when(command).executeGetDeviceList(any(Guid.class), any(StorageType.class), any(String.class));
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_INVALID);
}
#method_after
@Test
public void testLunDiskInvalid() {
    VDS vds = mockVds();
    LunDisk disk = createISCSILunDisk();
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(disk);
    parameters.setVdsId(vds.getId());
    initializeCommand(Guid.newGuid(), parameters);
    command.setVds(vds);
    mockMaxPciSlots();
    mockInterfaceList();
    List<LUNs> luns = Collections.emptyList();
    doReturn(luns).when(command).executeGetDeviceList(any(Guid.class), any(StorageType.class), any(String.class));
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_INVALID);
}
#end_block

#method_before
@Test
public void testAddingIDELunExceedsSlotLimit() {
    mockInterfaceList();
    LunDisk disk = createISCSILunDisk();
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(disk);
    parameters.getDiskVmElement().setDiskInterface(DiskInterface.IDE);
    initializeCommand(Guid.newGuid(), parameters);
    VM vm = mockVm();
    mockMaxPciSlots();
    // use maximum slots for IDE - validate expected to succeed.
    mockOtherVmDisks(vm, VmCommand.MAX_IDE_SLOTS - 1, DiskInterface.IDE);
    ValidateTestUtils.runAndAssertValidateSuccess(command);
    LunDisk newDisk = createISCSILunDisk();
    newDisk.getDiskVmElementForVm(vmId).setDiskInterface(DiskInterface.IDE);
    vm.getDiskMap().put(newDisk.getId(), newDisk);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_IDE_SLOTS);
}
#method_after
@Test
public void testAddingIDELunExceedsSlotLimit() {
    mockInterfaceList();
    LunDisk disk = createISCSILunDisk();
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(disk);
    parameters.getDiskVmElement().setDiskInterface(DiskInterface.IDE);
    initializeCommand(Guid.newGuid(), parameters);
    VM vm = mockVm();
    mockMaxPciSlots();
    // use maximum slots for IDE - validate expected to succeed.
    mockOtherVmDisks(vm, VmCommand.MAX_IDE_SLOTS - 1, DiskInterface.IDE);
    ValidateTestUtils.runAndAssertValidateSuccess(command);
    LunDisk newDisk = createISCSILunDisk();
    DiskVmElement dve = new DiskVmElement(disk.getId(), vmId);
    dve.setDiskInterface(DiskInterface.IDE);
    newDisk.setDiskVmElements(Collections.singletonList(dve));
    vm.getDiskMap().put(newDisk.getId(), newDisk);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_IDE_SLOTS);
}
#end_block

#method_before
@Test
public void testAddingPCILunExceedsSlotLimit() {
    mockInterfaceList();
    LunDisk disk = createISCSILunDisk();
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(disk);
    parameters.getDiskVmElement().setDiskInterface(DiskInterface.VirtIO);
    initializeCommand(Guid.newGuid(), parameters);
    VM vm = mockVm();
    mockMaxPciSlots();
    // use maximum slots for PCI. validate expected to succeed.
    mockOtherVmDisks(vm, MAX_PCI_SLOTS - 2, DiskInterface.VirtIO);
    ValidateTestUtils.runAndAssertValidateSuccess(command);
    LunDisk newDisk = createISCSILunDisk();
    newDisk.getDiskVmElementForVm(vmId).setDiskInterface(DiskInterface.VirtIO);
    vm.getDiskMap().put(newDisk.getId(), newDisk);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_PCI_SLOTS);
}
#method_after
@Test
public void testAddingPCILunExceedsSlotLimit() {
    mockInterfaceList();
    LunDisk disk = createISCSILunDisk();
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(disk);
    parameters.getDiskVmElement().setDiskInterface(DiskInterface.VirtIO);
    initializeCommand(Guid.newGuid(), parameters);
    VM vm = mockVm();
    mockMaxPciSlots();
    // use maximum slots for PCI. validate expected to succeed.
    mockOtherVmDisks(vm, MAX_PCI_SLOTS - 2, DiskInterface.VirtIO);
    ValidateTestUtils.runAndAssertValidateSuccess(command);
    LunDisk newDisk = createISCSILunDisk();
    DiskVmElement dve = new DiskVmElement(disk.getId(), vmId);
    dve.setDiskInterface(DiskInterface.VirtIO);
    newDisk.setDiskVmElements(Collections.singletonList(dve));
    vm.getDiskMap().put(newDisk.getId(), newDisk);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_PCI_SLOTS);
}
#end_block

#method_before
@Test
public void testVirtIoScsiNotSupportedByOs() {
    DiskImage disk = new DiskImage();
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(disk);
    parameters.getDiskVmElement().setDiskInterface(DiskInterface.VirtIO_SCSI);
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId, parameters);
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    mockVm();
    mockMaxPciSlots();
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Collections.singletonList("VirtIO")));
    DiskValidator diskValidator = spyDiskValidator(disk);
    doReturn(true).when(diskValidator).isVirtioScsiControllerAttached(any(Guid.class));
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
}
#method_after
@Test
public void testVirtIoScsiNotSupportedByOs() {
    DiskImage disk = new DiskImage();
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(disk);
    parameters.getDiskVmElement().setDiskInterface(DiskInterface.VirtIO_SCSI);
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId, parameters);
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    mockVm();
    mockMaxPciSlots();
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Collections.singletonList("VirtIO")));
    doReturn(true).when(vmDeviceUtils).hasVirtioScsiController(any(Guid.class));
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
}
#end_block

#method_before
@Test
public void testVirtioScsiDiskWithoutControllerCantBeAdded() {
    DiskImage disk = new DiskImage();
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(disk);
    parameters.getDiskVmElement().setDiskInterface(DiskInterface.VirtIO_SCSI);
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId, parameters);
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    mockVm();
    mockMaxPciSlots();
    DiskValidator diskValidator = spyDiskValidator(disk);
    doReturn(false).when(diskValidator).isVirtioScsiControllerAttached(any(Guid.class));
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.CANNOT_PERFORM_ACTION_VIRTIO_SCSI_IS_DISABLED);
}
#method_after
@Test
public void testVirtioScsiDiskWithoutControllerCantBeAdded() {
    DiskImage disk = new DiskImage();
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(disk);
    parameters.getDiskVmElement().setDiskInterface(DiskInterface.VirtIO_SCSI);
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId, parameters);
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    mockVm();
    mockMaxPciSlots();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.CANNOT_PERFORM_ACTION_VIRTIO_SCSI_IS_DISABLED);
}
#end_block

#method_before
@Test
public void testDiskImageWithSgioCantBeAdded() {
    DiskImage disk = new DiskImage();
    disk.setSgio(ScsiGenericIO.UNFILTERED);
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(disk);
    parameters.getDiskVmElement().setDiskInterface(DiskInterface.VirtIO_SCSI);
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId, parameters);
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    mockMaxPciSlots();
    DiskValidator diskValidator = spyDiskValidator(disk);
    doReturn(true).when(diskValidator).isVirtioScsiControllerAttached(any(Guid.class));
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.SCSI_GENERIC_IO_IS_NOT_SUPPORTED_FOR_IMAGE_DISK);
}
#method_after
@Test
public void testDiskImageWithSgioCantBeAdded() {
    DiskImage disk = new DiskImage();
    disk.setSgio(ScsiGenericIO.UNFILTERED);
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(disk);
    parameters.getDiskVmElement().setDiskInterface(DiskInterface.VirtIO_SCSI);
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId, parameters);
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    mockMaxPciSlots();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.SCSI_GENERIC_IO_IS_NOT_SUPPORTED_FOR_IMAGE_DISK);
}
#end_block

#method_before
@Test
public void testLunDiskWithSgioCanBeAdded() {
    LunDisk disk = createISCSILunDisk();
    disk.setSgio(ScsiGenericIO.UNFILTERED);
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(disk);
    initializeCommand(Guid.newGuid(), parameters);
    mockVm();
    mockMaxPciSlots();
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Collections.singletonList("VirtIO_SCSI")));
    DiskValidator diskValidator = spyDiskValidator(disk);
    doReturn(true).when(diskValidator).isVirtioScsiControllerAttached(any(Guid.class));
    mockInterfaceList();
    ValidateTestUtils.runAndAssertValidateSuccess(command);
}
#method_after
@Test
public void testLunDiskWithSgioCanBeAdded() {
    LunDisk disk = createISCSILunDisk();
    disk.setSgio(ScsiGenericIO.UNFILTERED);
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(disk);
    initializeCommand(Guid.newGuid(), parameters);
    mockVm();
    mockMaxPciSlots();
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Collections.singletonList("VirtIO_SCSI")));
    mockInterfaceList();
    ValidateTestUtils.runAndAssertValidateSuccess(command);
}
#end_block

#method_before
@Test
public void testValidateFailReadOnlyOnInterface() {
    AddDiskParameters parameters = createParameters();
    initializeCommand(Guid.newGuid(), parameters);
    mockVm();
    doReturn(true).when(command).isDiskPassPciAndIdeLimit();
    doReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_INTERFACE_DOES_NOT_SUPPORT_READ_ONLY_ATTR)).when(diskValidator).isReadOnlyPropertyCompatibleWithInterface(parameters.getDiskVmElement());
    doReturn(diskValidator).when(command).getDiskValidator(any(Disk.class));
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_INTERFACE_DOES_NOT_SUPPORT_READ_ONLY_ATTR);
}
#method_after
@Test
public void testValidateFailReadOnlyOnInterface() {
    AddDiskParameters parameters = createParameters();
    initializeCommand(Guid.newGuid(), parameters);
    doReturn(true).when(command).isDiskPassPciAndIdeLimit();
    doReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_INTERFACE_DOES_NOT_SUPPORT_READ_ONLY_ATTR)).when(diskVmElementValidator).isReadOnlyPropertyCompatibleWithInterface();
    doReturn(diskVmElementValidator).when(command).getDiskVmElementValidator(any(Disk.class), any(DiskVmElement.class));
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_INTERFACE_DOES_NOT_SUPPORT_READ_ONLY_ATTR);
}
#end_block

#method_before
@Test
public void testValidateSucceedReadOnly() {
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId);
    mockVm();
    mockEntities(storageId);
    doReturn(true).when(command).isDiskPassPciAndIdeLimit();
    doReturn(true).when(command).checkIfImageDiskCanBeAdded(any(VM.class), any(DiskValidator.class));
    doReturn(ValidationResult.VALID).when(diskValidator).isReadOnlyPropertyCompatibleWithInterface(any(DiskVmElement.class));
    doReturn(diskValidator).when(command).getDiskValidator(any(Disk.class));
    ValidateTestUtils.runAndAssertValidateSuccess(command);
}
#method_after
@Test
public void testValidateSucceedReadOnly() {
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId);
    mockVm();
    mockEntities(storageId);
    doReturn(true).when(command).isDiskPassPciAndIdeLimit();
    doReturn(true).when(command).checkIfImageDiskCanBeAdded(any(VM.class), any(DiskVmElementValidator.class));
    doReturn(ValidationResult.VALID).when(diskVmElementValidator).isReadOnlyPropertyCompatibleWithInterface();
    doReturn(diskVmElementValidator).when(command).getDiskVmElementValidator(any(Disk.class), any(DiskVmElement.class));
    ValidateTestUtils.runAndAssertValidateSuccess(command);
}
#end_block

#method_before
@Test
public void testNonExistingQuota() {
    DiskImage img = createDiskImage(10);
    img.setQuotaId(Guid.newGuid());
    AddDiskParameters params = createParameters();
    params.setDiskInfo(img);
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId, params);
    mockVm();
    mockEntities(storageId);
    QuotaDao quotaDaoMock = mock(QuotaDao.class);
    doReturn(quotaDaoMock).when(command).getQuotaDao();
    doCallRealMethod().when(command).validateQuota();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
}
#method_after
@Test
public void testNonExistingQuota() {
    DiskImage img = createDiskImage(10);
    img.setQuotaId(Guid.newGuid());
    AddDiskParameters params = createParameters();
    params.setDiskInfo(img);
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId, params);
    mockEntities(storageId);
    QuotaDao quotaDaoMock = mock(QuotaDao.class);
    doReturn(quotaDaoMock).when(command).getQuotaDao();
    doCallRealMethod().when(command).validateQuota();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
}
#end_block

#method_before
private void registerListeners() {
    SuggestBoxFocusHandler handlers = new SuggestBoxFocusHandler();
    suggestBox.getValueBox().addBlurHandler(handlers);
    suggestBox.getValueBox().addFocusHandler(handlers);
    // not listening to focus because it would show the suggestions also after the whole browser
    // gets the focus back (after loosing it) if this was the last element with focus
    suggestBox.getValueBox().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            switchSuggestions();
        }
    });
    dropdownIcon.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            switchSuggestions();
        }
    }, ClickEvent.getType());
    getSuggestionMenu().getParent().addDomHandler(new FocusHandlerEnablingMouseHandlers(handlers), MouseDownEvent.getType());
    // no need to do additional switchSuggestions() - it is processed by MenuBar itself
    getSuggestionMenu().getParent().addDomHandler(new FocusHandlerEnablingMouseHandlers(handlers), MouseUpEvent.getType());
    addValueChangeHandler(new ValueChangeHandler<T>() {

        @Override
        public void onValueChange(ValueChangeEvent<T> event) {
            // if the value has been changed using the mouse
            setValue(event.getValue());
        }
    });
}
#method_after
private void registerListeners() {
    SuggestBoxFocusHandler handlers = new SuggestBoxFocusHandler();
    handlerRegistrations.add(suggestBox.getValueBox().addBlurHandler(handlers));
    handlerRegistrations.add(suggestBox.getValueBox().addFocusHandler(handlers));
    // not listening to focus because it would show the suggestions also after the whole browser
    // gets the focus back (after loosing it) if this was the last element with focus
    handlerRegistrations.add(suggestBox.getValueBox().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            switchSuggestions();
        }
    }));
    handlerRegistrations.add(dropdownIcon.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            switchSuggestions();
        }
    }, ClickEvent.getType()));
    handlerRegistrations.add(getSuggestionMenu().getParent().addDomHandler(new FocusHandlerEnablingMouseHandlers(handlers), MouseDownEvent.getType()));
    // no need to do additional switchSuggestions() - it is processed by MenuBar itself
    handlerRegistrations.add(getSuggestionMenu().getParent().addDomHandler(new FocusHandlerEnablingMouseHandlers(handlers), MouseUpEvent.getType()));
    handlerRegistrations.add(addValueChangeHandler(new ValueChangeHandler<T>() {

        @Override
        public void onValueChange(ValueChangeEvent<T> event) {
            // if the value has been changed using the mouse
            setValue(event.getValue());
        }
    }));
}
#end_block

#method_before
public void setSelected() {
    getElement().addClassName(SELECTED);
    SafeHtml anchor;
    if (ListModelListBox.this.isMultiSelect) {
        anchor = ListModelListBox.this.anchorText.anchor(ListModelListBox.this.listItemTemplate.multiSelectListItem(this.anchorText, style.inlineBlock(), style.checkIcon()).asString(), style.selected());
    } else {
        anchor = ListModelListBox.this.anchorText.anchor(anchorText, style.selected());
    }
    getElement().setInnerHTML(anchor.asString());
}
#method_after
public void setSelected() {
    getElement().addClassName(SELECTED);
    SafeHtml anchor;
    if (ListModelListBox.this.isMultiSelect) {
        anchor = ListModelListBox.this.anchorText.anchor(ListModelListBox.this.listItemTemplate.multiSelectListItem(this.anchorText, style.inlineBlock(), style.checkIcon()), style.selected());
    } else {
        anchor = ListModelListBox.this.anchorText.anchor(SafeHtmlUtils.fromTrustedString(anchorText), style.selected());
    }
    getElement().setInnerHTML(anchor.asString());
}
#end_block

#method_before
public void removeSelected() {
    getElement().removeClassName(SELECTED);
    // $NON-NLS-1$
    getElement().setInnerHTML(ListModelListBox.this.anchorText.anchor(anchorText, "").asString());
}
#method_after
public void removeSelected() {
    getElement().removeClassName(SELECTED);
    getElement().setInnerHTML(ListModelListBox.this.anchorText.anchor(SafeHtmlUtils.fromTrustedString(anchorText), "").asString());
}
#end_block

#method_before
@Override
public void init(final ClusterModel model) {
    super.init(model);
    model.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if ("AllowClusterWithVirtGlusterEnabled".equals(propName)) {
                // $NON-NLS-1$
                getView().allowClusterWithVirtGlusterEnabled(model.getAllowClusterWithVirtGlusterEnabled());
            }
        }
    });
    String spiceProxyInConfig = (String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.SpiceProxyDefault);
    String spiceProxyMessage = StringHelper.isNullOrEmpty(spiceProxyInConfig) ? messages.noSpiceProxyDefined() : spiceProxyInConfig;
    getView().setSpiceProxyOverrideExplanation(messages.consoleOverrideSpiceProxyMessage(messages.consoleOverrideDefinedInGlobalConfig(), spiceProxyMessage));
    getModel().getVersion().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            final Version selectedVersion = getModel().getVersion().getSelectedItem();
            if (selectedVersion == null) {
                return;
            }
            if (AsyncDataProvider.getInstance().isMigrationPoliciesSupported(selectedVersion)) {
                getView().getMigrationBandwidthLimitTypeEditor().setEnabled(true);
                updateCustomMigrationBandwidthLimitEnabledState(model, null);
            } else {
                final String supportedVersions = StringUtils.join(AsyncDataProvider.getInstance().getMigrationPoliciesSupportedVersions(), // $NON-NLS-1$
                ", ");
                final String message = messages.onlyAvailableInCompatibilityVersions(supportedVersions);
                getView().getMigrationBandwidthLimitTypeEditor().setEnabled(false);
                updateCustomMigrationBandwidthLimitEnabledState(model, message);
            }
        }
    });
    getModel().getMigrationBandwidthLimitType().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            updateCustomMigrationBandwidthLimitEnabledState(model, null);
        }
    });
    model.getMacPoolModel().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            getView().updateMacPool(model.getMacPoolModel());
        }
    });
    getView().getMacPoolButton().setCommand(model.getAddMacPoolCommand());
    getView().getMacPoolButton().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            getView().getMacPoolButton().getCommand().execute(model);
        }
    });
}
#method_after
@Override
public void init(final ClusterModel model) {
    super.init(model);
    model.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if ("AllowClusterWithVirtGlusterEnabled".equals(propName)) {
                // $NON-NLS-1$
                getView().allowClusterWithVirtGlusterEnabled(model.getAllowClusterWithVirtGlusterEnabled());
            }
        }
    });
    String spiceProxyInConfig = (String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.SpiceProxyDefault);
    String spiceProxyMessage = StringHelper.isNullOrEmpty(spiceProxyInConfig) ? messages.noSpiceProxyDefined() : spiceProxyInConfig;
    getView().setSpiceProxyOverrideExplanation(messages.consoleOverrideSpiceProxyMessage(messages.consoleOverrideDefinedInGlobalConfig(), spiceProxyMessage));
    getModel().getVersion().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            final Version selectedVersion = getModel().getVersion().getSelectedItem();
            if (selectedVersion == null) {
                return;
            }
            if (AsyncDataProvider.getInstance().isMigrationPoliciesSupported(selectedVersion)) {
                getView().getMigrationBandwidthLimitTypeEditor().setEnabled(true);
                updateCustomMigrationBandwidthLimitEnabledState(model, null);
            } else {
                final String supportedVersions = StringUtils.join(AsyncDataProvider.getInstance().getMigrationPoliciesSupportedVersions(), // $NON-NLS-1$
                ", ");
                final String message = messages.onlyAvailableInCompatibilityVersions(supportedVersions);
                getView().getMigrationBandwidthLimitTypeEditor().disable(message);
                getView().getMigrationBandwidthLimitTypeEditor().setEnabled(false);
                updateCustomMigrationBandwidthLimitEnabledState(model, message);
            }
        }
    });
    getModel().getMigrationBandwidthLimitType().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            updateCustomMigrationBandwidthLimitEnabledState(model, null);
        }
    });
    model.getMacPoolModel().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            getView().updateMacPool(model.getMacPoolModel());
        }
    });
    final UICommand addMacPoolCommand = model.getAddMacPoolCommand();
    if (addMacPoolCommand == null) {
        getView().makeMacPoolButtonInvisible();
    } else {
        getView().getMacPoolButton().setCommand(addMacPoolCommand);
        registerHandler(getView().getMacPoolButton().addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                getView().getMacPoolButton().getCommand().execute(model);
            }
        }));
    }
}
#end_block

#method_before
private void initCheckBoxEditors() {
    enableOvirtServiceEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableGlusterServiceEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    importGlusterConfigurationEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    countThreadsAsCoresEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableTrustedServiceEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableHaReservationEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableOptionalReasonEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableHostMaintenanceReasonEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableKsm = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    enableKsm.getContentWidgetContainer().setWidth("350px");
    enableBallooning = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    enableBallooning.getContentWidgetContainer().setWidth("350px");
    rngRandomSourceRequired = new EntityModelCheckBoxEditor(Align.RIGHT);
    rngHwrngSourceRequired = new EntityModelCheckBoxEditor(Align.RIGHT);
    fencingEnabledCheckBox = new EntityModelCheckBoxEditor(Align.RIGHT);
    skipFencingIfSDActiveCheckBox = new EntityModelCheckBoxEditor(Align.RIGHT);
    skipFencingIfConnectivityBrokenCheckBox = new EntityModelCheckBoxEditor(Align.RIGHT);
    skipFencingIfConnectivityBrokenCheckBox.hideLabel();
    spiceProxyOverrideEnabled = new EntityModelCheckBoxEditor(Align.RIGHT);
    spiceProxyOverrideEnabled.hideLabel();
    additionalFeaturesEditor = new ListModelCheckBoxGroup<>(new AbstractRenderer<AdditionalFeature>() {

        @Override
        public String render(AdditionalFeature feature) {
            return feature.getDescription();
        }
    });
}
#method_after
private void initCheckBoxEditors() {
    enableOvirtServiceEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableGlusterServiceEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    importGlusterConfigurationEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    countThreadsAsCoresEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableTrustedServiceEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableHaReservationEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableOptionalReasonEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableHostMaintenanceReasonEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableKsm = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    enableKsm.getContentWidgetContainer().setWidth("350px");
    enableBallooning = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    enableBallooning.getContentWidgetContainer().setWidth("350px");
    rngRandomSourceRequired = new EntityModelCheckBoxEditor(Align.RIGHT);
    rngHwrngSourceRequired = new EntityModelCheckBoxEditor(Align.RIGHT);
    fencingEnabledCheckBox = new EntityModelCheckBoxEditor(Align.RIGHT);
    skipFencingIfSDActiveCheckBox = new EntityModelCheckBoxEditor(Align.RIGHT);
    skipFencingIfConnectivityBrokenCheckBox = new EntityModelCheckBoxEditor(Align.RIGHT);
    skipFencingIfConnectivityBrokenCheckBox.hideLabel();
    skipFencingIfGlusterBricksUpCheckBox = new EntityModelCheckBoxEditor(Align.RIGHT);
    skipFencingIfGlusterQuorumNotMetCheckBox = new EntityModelCheckBoxEditor(Align.RIGHT);
    spiceProxyOverrideEnabled = new EntityModelCheckBoxEditor(Align.RIGHT);
    spiceProxyOverrideEnabled.hideLabel();
    additionalFeaturesEditor = new ListModelCheckBoxGroup<>(new AbstractRenderer<AdditionalFeature>() {

        @Override
        public String render(AdditionalFeature feature) {
            return feature.getDescription();
        }
    });
}
#end_block

#method_before
private void initInfoIcons() {
    memoryOptimizationInfo = new InfoIcon(templates.italicText(constants.clusterPopupMemoryOptimizationInfo()));
    cpuThreadsInfo = new InfoIcon(templates.italicText(constants.clusterPopupCpuThreadsInfo()));
    schedulerOptimizationInfoIcon = new InfoIcon(SafeHtmlUtils.EMPTY_SAFE_HTML);
    allowOverbookingInfoIcon = new InfoIcon(SafeHtmlUtils.EMPTY_SAFE_HTML);
    fencingEnabledInfo = new InfoIcon(templates.italicText(constants.fencingEnabledInfo()));
    skipFencingIfSDActiveInfo = new InfoIcon(templates.italicText(constants.skipFencingIfSDActiveInfo()));
    skipFencingIfConnectivityBrokenInfo = new InfoIcon(templates.italicText(constants.skipFencingWhenConnectivityBrokenInfo()));
    // $NON-NLS-1$
    isVirtioScsiEnabledInfoIcon = new InfoIcon(templates.italicText(""));
}
#method_after
private void initInfoIcons() {
    memoryOptimizationInfo = new InfoIcon(templates.italicText(constants.clusterPopupMemoryOptimizationInfo()));
    cpuThreadsInfo = new InfoIcon(templates.italicText(constants.clusterPopupCpuThreadsInfo()));
    schedulerOptimizationInfoIcon = new InfoIcon(SafeHtmlUtils.EMPTY_SAFE_HTML);
    allowOverbookingInfoIcon = new InfoIcon(SafeHtmlUtils.EMPTY_SAFE_HTML);
    fencingEnabledInfo = new InfoIcon(templates.italicText(constants.fencingEnabledInfo()));
    skipFencingIfSDActiveInfo = new InfoIcon(templates.italicText(constants.skipFencingIfSDActiveInfo()));
    skipFencingIfConnectivityBrokenInfo = new InfoIcon(templates.italicText(constants.skipFencingWhenConnectivityBrokenInfo()));
    skipFencingIfGlusterBricksUpInfo = new InfoIcon(templates.italicText(constants.skipFencingIfGlusterBricksUpInfo()));
    skipFencingIfGlusterBricksUpInfo.setVisible(false);
    skipFencingIfGlusterQuorumNotMetInfo = new InfoIcon(templates.italicText(constants.skipFencingIfGlusterQuorumNotMetInfo()));
    skipFencingIfGlusterQuorumNotMetInfo.setVisible(false);
    // $NON-NLS-1$
    isVirtioScsiEnabledInfoIcon = new InfoIcon(templates.italicText(""));
}
#end_block

#method_before
@Override
public void edit(final ClusterModel object) {
    driver.edit(object);
    updateMacPool(object.getMacPoolModel());
    customPropertiesSheetEditor.edit(object.getCustomPropertySheet());
    enableOvirtServiceEditor.setVisible(object.getAllowClusterWithVirtGlusterEnabled());
    enableGlusterServiceEditor.setVisible(object.getAllowClusterWithVirtGlusterEnabled());
    enableOvirtServiceOptionEditor.setVisible(!object.getAllowClusterWithVirtGlusterEnabled());
    enableGlusterServiceOptionEditor.setVisible(!object.getAllowClusterWithVirtGlusterEnabled());
    serialNumberPolicyEditor.edit(object.getSerialNumberPolicy());
    optimizationForServerFormatter(object);
    optimizationForDesktopFormatter(object);
    optimizationCustomFormatter(object);
    object.getOptimizationForServer().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            optimizationForServerFormatter(object);
        }
    });
    object.getOptimizationForDesktop().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            optimizationForDesktopFormatter(object);
        }
    });
    object.getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (object.getOptimizationCustom_IsSelected().getEntity()) {
                optimizationCustomFormatter(object);
                optimizationCustomEditor.setVisible(true);
            }
        }
    });
    object.getDataCenter().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            migrationTab.setVisible(object.isMigrationTabAvailable());
            applyModeCustomizations();
        }
    });
    object.getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
        }
    });
    importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
    object.getVersionSupportsCpuThreads().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            cpuThreadsRow.setVisible(object.getVersionSupportsCpuThreads().getEntity());
        }
    });
    schedulerOptimizationInfoIcon.setText(SafeHtmlUtils.fromTrustedString(templates.italicText(object.getSchedulerOptimizationInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingInfoIcon.setText(SafeHtmlUtils.fromTrustedString(templates.italicText(object.getAllowOverbookingInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingRow.setVisible(allowOverbookingEditor.isVisible());
    object.getVersion().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (object.getVersion().getSelectedItem() != null) {
                Version clusterVersion = object.getVersion().getSelectedItem();
                migrationPolicyDetails.setVisible(AsyncDataProvider.getInstance().isMigrationPoliciesSupported(clusterVersion));
            }
        }
    });
    object.getAdditionalClusterFeatures().getItemsChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            List<List<AdditionalFeature>> items = (List<List<AdditionalFeature>>) object.getAdditionalClusterFeatures().getItems();
            // Hide the fields if there is no feature to show
            additionalFeaturesExpander.setVisible(!items.get(0).isEmpty());
            additionalFeaturesExpanderContent.setVisible(!items.get(0).isEmpty());
        }
    });
    object.getMigrationPolicies().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            MigrationPolicy selectedPolicy = object.getMigrationPolicies().getSelectedItem();
            if (selectedPolicy != null) {
                migrationPolicyDetails.setHTML(templates.migrationPolicyDetails(selectedPolicy.getName(), selectedPolicy.getDescription()));
            } else {
                // $NON-NLS-1$
                migrationPolicyDetails.setText("");
            }
        }
    });
}
#method_after
@Override
public void edit(final ClusterModel object) {
    driver.edit(object);
    updateMacPool(object.getMacPoolModel());
    customPropertiesSheetEditor.edit(object.getCustomPropertySheet());
    enableOvirtServiceEditor.setVisible(object.getAllowClusterWithVirtGlusterEnabled());
    enableGlusterServiceEditor.setVisible(object.getAllowClusterWithVirtGlusterEnabled());
    enableOvirtServiceOptionEditor.setVisible(!object.getAllowClusterWithVirtGlusterEnabled());
    enableGlusterServiceOptionEditor.setVisible(!object.getAllowClusterWithVirtGlusterEnabled());
    serialNumberPolicyEditor.edit(object.getSerialNumberPolicy());
    optimizationForServerFormatter(object);
    optimizationForDesktopFormatter(object);
    optimizationCustomFormatter(object);
    object.getOptimizationForServer().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            optimizationForServerFormatter(object);
        }
    });
    object.getOptimizationForDesktop().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            optimizationForDesktopFormatter(object);
        }
    });
    object.getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (object.getOptimizationCustom_IsSelected().getEntity()) {
                optimizationCustomFormatter(object);
                optimizationCustomEditor.setVisible(true);
            }
        }
    });
    object.getDataCenter().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            migrationTab.setVisible(object.isMigrationTabAvailable());
            applyModeCustomizations();
        }
    });
    object.getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            updateGlusterFencingPolicyVisibility(object);
        }
    });
    object.getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
            updateGlusterFencingPolicyVisibility(object);
        }
    });
    updateGlusterFencingPolicyVisibility(object);
    importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
    object.getVersionSupportsCpuThreads().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            cpuThreadsRow.setVisible(object.getVersionSupportsCpuThreads().getEntity());
        }
    });
    schedulerOptimizationInfoIcon.setText(SafeHtmlUtils.fromTrustedString(templates.italicText(object.getSchedulerOptimizationInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingInfoIcon.setText(SafeHtmlUtils.fromTrustedString(templates.italicText(object.getAllowOverbookingInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingRow.setVisible(allowOverbookingEditor.isVisible());
    object.getVersion().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (object.getVersion().getSelectedItem() != null) {
                Version clusterVersion = object.getVersion().getSelectedItem();
                migrationPolicyDetails.setVisible(AsyncDataProvider.getInstance().isMigrationPoliciesSupported(clusterVersion));
            }
        }
    });
    object.getAdditionalClusterFeatures().getItemsChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            List<List<AdditionalFeature>> items = (List<List<AdditionalFeature>>) object.getAdditionalClusterFeatures().getItems();
            // Hide the fields if there is no feature to show
            additionalFeaturesExpander.setVisible(!items.get(0).isEmpty());
            additionalFeaturesExpanderContent.setVisible(!items.get(0).isEmpty());
        }
    });
    object.getMigrationPolicies().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            MigrationPolicy selectedPolicy = object.getMigrationPolicies().getSelectedItem();
            if (selectedPolicy != null) {
                migrationPolicyDetails.setHTML(templates.migrationPolicyDetails(selectedPolicy.getName(), selectedPolicy.getDescription()));
            } else {
                // $NON-NLS-1$
                migrationPolicyDetails.setText("");
            }
        }
    });
}
#end_block

#method_before
@Override
public HasUiCommandClickHandlers getMacPoolButton() {
    return addMacPoolButton;
}
#method_after
@Override
public UiCommandButton getMacPoolButton() {
    return addMacPoolButton;
}
#end_block

#method_before
@Override
public HasEnabled getMigrationBandwidthLimitTypeEditor() {
    return migrationBandwidthLimitTypeEditor;
}
#method_after
@Override
public HasEnabledWithHints getMigrationBandwidthLimitTypeEditor() {
    return migrationBandwidthLimitTypeEditor;
}
#end_block

#method_before
private void addDiskAllocation(UnitVmModel model) {
    if (!model.getIsDisksAvailable()) {
        return;
    }
    disksAllocationView.edit(model.getDisksAllocationModel());
    model.getDisksAllocationModel().setDisks(model.getDisks());
}
#method_after
private void addDiskAllocation(UnitVmModel model) {
    disksAllocationView.edit(model.getDisksAllocationModel());
    model.getDisksAllocationModel().setDisks(model.getDisks());
}
#end_block

#method_before
@Override
public HandlerRegistration addKeyUpHandler(KeyUpHandler handler) {
    return asSuggestBox().addKeyUpHandler(handler);
}
#method_after
@Override
public HandlerRegistration addKeyUpHandler(KeyUpHandler handler) {
    HandlerRegistration handlerRegistration = asSuggestBox().addKeyUpHandler(handler);
    handlerRegistrations.add(handlerRegistration);
    return handlerRegistration;
}
#end_block

#method_before
@Override
public HandlerRegistration addKeyDownHandler(KeyDownHandler handler) {
    return asSuggestBox().addKeyDownHandler(handler);
}
#method_after
@Override
public HandlerRegistration addKeyDownHandler(KeyDownHandler handler) {
    HandlerRegistration handlerRegistration = asSuggestBox().addKeyDownHandler(handler);
    handlerRegistrations.add(handlerRegistration);
    return handlerRegistration;
}
#end_block

#method_before
@Override
public HandlerRegistration addKeyPressHandler(KeyPressHandler handler) {
    return asSuggestBox().addKeyPressHandler(handler);
}
#method_after
@Override
public HandlerRegistration addKeyPressHandler(KeyPressHandler handler) {
    HandlerRegistration handlerRegistration = asSuggestBox().addKeyPressHandler(handler);
    handlerRegistrations.add(handlerRegistration);
    return handlerRegistration;
}
#end_block

#method_before
@Override
public HandlerRegistration addValueChangeHandler(final ValueChangeHandler<T> handler) {
    return asSuggestBox().addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(ValueChangeEvent<String> event) {
            try {
                T value = asEntity(event.getValue());
                handler.onValueChange(new ValueChangeEvent<T>(value) {
                });
            } catch (IllegalArgumentException e) {
            // ignore - the user entered an incorrect string. Just do not notify the listeners
            }
        }
    });
}
#method_after
@Override
public HandlerRegistration addValueChangeHandler(final ValueChangeHandler<T> handler) {
    HandlerRegistration handlerRegistration = asSuggestBox().addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(ValueChangeEvent<String> event) {
            try {
                T value = asEntity(event.getValue());
                handler.onValueChange(new ValueChangeEvent<T>(value) {
                });
            } catch (IllegalArgumentException e) {
            // ignore - the user entered an incorrect string. Just do not notify the listeners
            }
        }
    });
    handlerRegistrations.add(handlerRegistration);
    return handlerRegistration;
}
#end_block

#method_before
private void fixIe9Scrollbar() {
    // $NON-NLS-1$
    boolean isIe9 = Window.Navigator.getUserAgent().contains("MSIE 9.0");
    if (isIe9 && super.isSuggestionListShowing()) {
        final Style suggestionMenuStyle = getSuggestionMenu().getElement().getStyle();
        final Overflow originalOverflowY = valueOfOverflow(getComputedOverflowY(getSuggestionMenu().getElement()), Overflow.SCROLL);
        suggestionMenuStyle.setOverflowY(Overflow.HIDDEN);
        suggestionMenuStyle.setOverflowY(originalOverflowY);
        // px
        final int scrollbarWidthEstimate = 32;
        // $NON-NLS-1$ $NON-NLS-2$
        suggestionMenuStyle.setProperty("width", "");
        suggestionMenuStyle.setWidth(getSuggestionMenu().getElement().getClientWidth() + scrollbarWidthEstimate, Unit.PX);
    }
}
#method_after
/**
 * IE9 hack solving wrong scrollbar rendering.
 * ie9 counts the width of block without scrollbar event if the scrollbar should be visible, then
 * the scrollbar is show, content shifted to left and trimmed on left side.
 * Resetting 'overflow-y' to 'hidden' and back to 'scroll' prevents the shift to left, extending the width
 * adds space for scrollbar.
 *
 * <p>To be dropped together with IE9 support.</p>
 *
 * @see <a href="https://bugzilla.redhat.com/show_bug.cgi?id=1160774">Bug 1160774</a>
 */
private void fixIe9Scrollbar() {
    // $NON-NLS-1$
    boolean isIe9 = Window.Navigator.getUserAgent().contains("MSIE 9.0");
    if (isIe9 && super.isSuggestionListShowing()) {
        final Style suggestionMenuStyle = getSuggestionMenu().getElement().getStyle();
        final Overflow originalOverflowY = valueOfOverflow(getComputedOverflowY(getSuggestionMenu().getElement()), Overflow.SCROLL);
        suggestionMenuStyle.setOverflowY(Overflow.HIDDEN);
        suggestionMenuStyle.setOverflowY(originalOverflowY);
        // px
        final int scrollbarWidthEstimate = 32;
        // $NON-NLS-1$ $NON-NLS-2$
        suggestionMenuStyle.setProperty("width", "");
        suggestionMenuStyle.setWidth(getSuggestionMenu().getElement().getClientWidth() + scrollbarWidthEstimate, Unit.PX);
    }
}
#end_block

#method_before
protected LabelWithTooltip getFormLabel() {
    if (label instanceof LabelWithTooltip) {
        return (LabelWithTooltip) label;
    }
    return null;
}
#method_after
protected LabelWithTooltip getFormLabel() {
    if (label instanceof LabelWithTooltip) {
        return (LabelWithTooltip) label;
    }
    // $NON-NLS-1$
    throw new IllegalStateException("No label defined in widget that requires a label");
}
#end_block

#method_before
public void setLabelColSize(ColumnSize size) {
    if (label instanceof LabelWithTooltip) {
        ((LabelWithTooltip) label).setAddStyleNames(size.getCssName());
    }
}
#method_after
public void setLabelColSize(ColumnSize size) {
    getFormLabel().setAddStyleNames(size.getCssName());
}
#end_block

#method_before
@Override
public void setLabel(String labelText) {
    if (label instanceof LabelWithTooltip) {
        ((LabelWithTooltip) label).setText(labelText);
    }
}
#method_after
@Override
public void setLabel(String labelText) {
    getFormLabel().setText(labelText);
}
#end_block

#method_before
public void setLabelTooltip(String tooltip) {
    if (label instanceof LabelWithTooltip) {
        ((LabelWithTooltip) label).setTooltip(tooltip);
    }
}
#method_after
public void setLabelTooltip(String tooltip) {
    getFormLabel().setTooltip(tooltip);
}
#end_block

#method_before
public String getLabel() {
    String result = null;
    if (label instanceof LabelWithTooltip) {
        result = ((LabelWithTooltip) label).getText();
    }
    return result;
}
#method_after
public String getLabel() {
    return getFormLabel().getText();
}
#end_block

#method_before
public Object read() {
    try {
        // Do nothing if there aren't more tags:
        if (!forward()) {
            return null;
        }
        // Select the specific reader according to the tag:
        String tag = getLocalName();
        Method m = readers.get(tag);
        if (m == null) {
            throw new RuntimeException(String.format("Can't find a reader for tag '%s'", tag));
        }
        // Read the object using the specific reader:
        return m.invoke(null, this);
    } catch (IllegalAccessException | InvocationTargetException e) {
        throw new RuntimeException("Failed to invoke read method.");
    } finally {
        close();
    }
}
#method_after
public Object read() {
    String tag = null;
    Method method = null;
    try {
        // Do nothing if there aren't more tags:
        if (!forward()) {
            return null;
        }
        tag = getLocalName();
        method = readers.get(tag);
        // Select the specific reader according to the tag:
        if (method == null) {
            throw new RuntimeException(String.format("Can't find a reader for tag '%s'", tag));
        }
        // Read the object using the specific reader:
        return method.invoke(null, this);
    } catch (IllegalAccessException | InvocationTargetException exception) {
        throw new RuntimeException(String.format("Failed to invoke method '%1$s' to read element for tag '%2$s'", method, tag), exception);
    } finally {
        close();
    }
}
#end_block

#method_before
public void generate(Model model) {
    // Generate classes for each struct type:
    model.types().filter(StructType.class::isInstance).map(StructType.class::cast).forEach(this::generateStructSupportClasses);
    // Generate classes for each enum type:
    model.types().filter(EnumType.class::isInstance).map(EnumType.class::cast).forEach(this::generateEnumSupportClasses);
    generateXmlRegisterClass(model);
}
#method_after
public void generate(Model model) {
    // Generate classes for each struct type:
    model.types().filter(StructType.class::isInstance).map(StructType.class::cast).forEach(this::generateStructSupportClasses);
    // Generate classes for each enum type:
    model.types().filter(EnumType.class::isInstance).map(EnumType.class::cast).forEach(this::generateEnumSupportClasses);
    generateXmlTagsPropertiesFile(model);
}
#end_block

#method_before
public String getSessionIdBySeqId(long sessionSequenceId) {
    String sessionId = null;
    for (SessionInfo sessionInfo : sessionInfoMap.values()) {
        if (sessionInfo.contentOfSession.get(ENGINE_SESSION_SEQ_ID).equals(sessionSequenceId)) {
            sessionId = (String) sessionInfo.contentOfSession.get(ENGINE_SESSION_ID);
            break;
        }
    }
    return sessionId;
}
#method_after
public String getSessionIdBySeqId(long sessionSequenceId) {
    String sessionId = null;
    for (SessionInfo sessionInfo : sessionInfoMap.values()) {
        if (Long.valueOf(sessionSequenceId).equals(sessionInfo.contentOfSession.get(ENGINE_SESSION_SEQ_ID))) {
            sessionId = (String) sessionInfo.contentOfSession.get(ENGINE_SESSION_ID);
            break;
        }
    }
    return sessionId;
}
#end_block

#method_before
public String getSessionIdBySsoAccessToken(String ssoToken) {
    String sessionId = null;
    for (SessionInfo sessionInfo : sessionInfoMap.values()) {
        if (sessionInfo.contentOfSession.get(SSO_ACCESS_TOKEN_PARAMETER_NAME).equals(ssoToken)) {
            sessionId = (String) sessionInfo.contentOfSession.get(ENGINE_SESSION_ID);
            break;
        }
    }
    return sessionId;
}
#method_after
public String getSessionIdBySsoAccessToken(String ssoToken) {
    String sessionId = null;
    if (StringUtils.isNotEmpty(ssoToken)) {
        for (SessionInfo sessionInfo : sessionInfoMap.values()) {
            if (ssoToken.equals(sessionInfo.contentOfSession.get(SSO_ACCESS_TOKEN_PARAMETER_NAME))) {
                sessionId = (String) sessionInfo.contentOfSession.get(ENGINE_SESSION_ID);
                break;
            }
        }
    }
    return sessionId;
}
#end_block

#method_before
public void cleanupEngineSessionsForSsoAccessToken(String ssoAccessToken) {
    Iterator<Entry<String, SessionInfo>> iter = sessionInfoMap.entrySet().iterator();
    while (iter.hasNext()) {
        Entry<String, SessionInfo> entry = iter.next();
        ConcurrentMap<String, Object> sessionMap = entry.getValue().contentOfSession;
        if (ssoAccessToken.equals(sessionMap.get(SSO_ACCESS_TOKEN_PARAMETER_NAME))) {
            removeSessionImpl(entry.getKey(), Acct.ReportReason.PRINCIPAL_SESSION_EXPIRED, "Session has expired for principal %1$s", getUserName(entry.getKey()));
        }
    }
}
#method_after
public void cleanupEngineSessionsForSsoAccessToken(String ssoAccessToken) {
    if (StringUtils.isNotEmpty(ssoAccessToken)) {
        Iterator<Entry<String, SessionInfo>> iter = sessionInfoMap.entrySet().iterator();
        while (iter.hasNext()) {
            Entry<String, SessionInfo> entry = iter.next();
            ConcurrentMap<String, Object> sessionMap = entry.getValue().contentOfSession;
            if (ssoAccessToken.equals(sessionMap.get(SSO_ACCESS_TOKEN_PARAMETER_NAME))) {
                removeSessionImpl(entry.getKey(), Acct.ReportReason.PRINCIPAL_SESSION_EXPIRED, "Session has expired for principal %1$s", getUserName(entry.getKey()));
            }
        }
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("cleanExpiredUsersSessions")
public final void cleanExpiredUsersSessions() {
    Date now = new Date();
    Iterator<Entry<String, SessionInfo>> iter = sessionInfoMap.entrySet().iterator();
    Set<String> tokens = sessionInfoMap.values().stream().map(sessionInfo -> (String) sessionInfo.contentOfSession.get(SSO_ACCESS_TOKEN_PARAMETER_NAME)).collect(Collectors.toSet());
    // retrieve session statues from SSO
    Map<String, Boolean> sessionStatuses = ssoSessionValidator.getSessionStatuses(tokens);
    while (iter.hasNext()) {
        Entry<String, SessionInfo> entry = iter.next();
        ConcurrentMap<String, Object> sessionMap = entry.getValue().contentOfSession;
        Date hardLimit = (Date) sessionMap.get(HARD_LIMIT_PARAMETER_NAME);
        Date softLimit = (Date) sessionMap.get(SOFT_LIMIT_PARAMETER_NAME);
        boolean sessionValid = sessionStatuses.getOrDefault(sessionMap.get(SSO_ACCESS_TOKEN_PARAMETER_NAME), false);
        if (((hardLimit != null && hardLimit.before(now)) || (softLimit != null && softLimit.before(now))) || !(boolean) sessionMap.get(SESSION_VALID_PARAMETER_NAME) || !sessionValid) {
            removeSessionImpl(entry.getKey(), Acct.ReportReason.PRINCIPAL_SESSION_EXPIRED, "Session has expired for principal %1$s", getUserName(entry.getKey()));
            if (sessionValid) {
                SsoOAuthServiceUtils.revoke((String) sessionMap.get(SSO_ACCESS_TOKEN_PARAMETER_NAME), "");
            }
        }
    }
}
#method_after
@OnTimerMethodAnnotation("cleanExpiredUsersSessions")
public final void cleanExpiredUsersSessions() {
    Date now = new Date();
    Iterator<Entry<String, SessionInfo>> iter = sessionInfoMap.entrySet().iterator();
    Set<String> tokens = sessionInfoMap.values().stream().map(sessionInfo -> (String) sessionInfo.contentOfSession.get(SSO_ACCESS_TOKEN_PARAMETER_NAME)).collect(Collectors.toSet());
    // retrieve session statues from SSO
    Map<String, Boolean> sessionStatuses = ssoSessionValidator.getSessionStatuses(tokens);
    while (iter.hasNext()) {
        Entry<String, SessionInfo> entry = iter.next();
        ConcurrentMap<String, Object> sessionMap = entry.getValue().contentOfSession;
        Date hardLimit = (Date) sessionMap.get(HARD_LIMIT_PARAMETER_NAME);
        Date softLimit = (Date) sessionMap.get(SOFT_LIMIT_PARAMETER_NAME);
        String token = (String) sessionMap.get(SSO_ACCESS_TOKEN_PARAMETER_NAME);
        boolean sessionValid = StringUtils.isEmpty(token) ? false : sessionStatuses.getOrDefault(token, false);
        if (((hardLimit != null && hardLimit.before(now)) || (softLimit != null && softLimit.before(now))) || !(boolean) sessionMap.get(SESSION_VALID_PARAMETER_NAME) || !sessionValid) {
            removeSessionImpl(entry.getKey(), Acct.ReportReason.PRINCIPAL_SESSION_EXPIRED, "Session has expired for principal %1$s", getUserName(entry.getKey()));
            if (sessionValid) {
                SsoOAuthServiceUtils.revoke((String) sessionMap.get(SSO_ACCESS_TOKEN_PARAMETER_NAME), "");
            }
        }
    }
}
#end_block

#method_before
@Override
public void cleanup() {
    if (disks != null) {
        for (final DiskModel diskModel : disks) {
            diskModel.cleanup();
        }
    }
    super.cleanup();
}
#method_after
@Override
public void cleanup() {
    if (disks != null) {
        for (DiskModel diskModel : disks) {
            diskModel.cleanup();
        }
    }
    super.cleanup();
}
#end_block

#method_before
protected void compensate() {
    internalCompensate();
}
#method_after
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected void compensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    // If the compensation data is not for the command do not perform compensation.
    if (!commandId.equals(getCompensationContext().getCommandId())) {
        return;
    }
    TransactionSupport.executeInNewTransaction(() -> {
        Deserializer deserializer = SerializationFactory.getDeserializer();
        List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDao().getAllForCommandId(commandId);
        log.debug("Command [id={}]: {} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
        for (BusinessEntitySnapshot snapshot : entitySnapshots) {
            Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
            Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
            log.info("Command [id={}]: Compensating {} of {}; snapshot: {}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), snapshot.getSnapshotType() == SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString());
            Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
            switch(snapshot.getSnapshotType()) {
                case CHANGED_STATUS_ONLY:
                    EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                    ((StatusAwareDao<Serializable, Enum<?>>) getDaoForEntity(entityClass)).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                    break;
                case DELETED_OR_UPDATED_ENTITY:
                    deletedOrUpdateEntity(entityClass, (BusinessEntity<Serializable>) snapshotData);
                    break;
                case UPDATED_ONLY_ENTITY:
                    getDaoForEntity(entityClass).update((BusinessEntity<Serializable>) snapshotData);
                    break;
                case NEW_ENTITY_ID:
                    getDaoForEntity(entityClass).remove(snapshotData);
                    break;
                case TRANSIENT_ENTITY:
                    objectCompensation.compensate(CommandBase.this, (TransientCompensationBusinessEntity) snapshotData);
                    break;
                default:
                    throw new IllegalArgumentException(String.format("Unknown %s value, unable to compensate value %s.", SnapshotType.class.getName(), snapshot.getSnapshotType()));
            }
        }
        getCompensationContext().afterCompensationCleanup();
        return null;
    });
}
#end_block

#method_before
@Test
public void logRenamedEntity() {
    abstract class RenameCommand extends CommandBaseDummy implements RenamedEntityInfoProvider {

        protected RenameCommand(VdcActionParametersBase params) {
            super(params);
        }
    }
    RenameCommand command = mock(RenameCommand.class);
    when(command.getEntityOldName()).thenReturn(null);
    when(command.getEntityNewName()).thenReturn(null);
    doCallRealMethod().when(command).logRenamedEntity();
    command.logRenamedEntity();
    when(command.getEntityOldName()).thenReturn("foo");
    when(command.getEntityNewName()).thenReturn("bar");
    when(command.getCurrentUser()).thenReturn(mock(DbUser.class));
    command.logRenamedEntity();
    when(command.getEntityOldName()).thenReturn(null);
    when(command.getEntityNewName()).thenReturn("bar");
    command.logRenamedEntity();
    when(command.getEntityOldName()).thenReturn("foo");
    when(command.getEntityNewName()).thenReturn(null);
    command.logRenamedEntity();
}
#method_after
@Test
public void logRenamedEntity() {
    abstract class RenameCommand extends CommandBaseDummy implements RenamedEntityInfoProvider {

        protected RenameCommand(VdcActionParametersBase params) {
            super(params);
        }
    }
    RenameCommand command = mock(RenameCommand.class);
    doCallRealMethod().when(command).logRenamedEntity();
    command.logRenamedEntity();
    when(command.getEntityOldName()).thenReturn("foo");
    when(command.getEntityNewName()).thenReturn("bar");
    when(command.getCurrentUser()).thenReturn(mock(DbUser.class));
    command.logRenamedEntity();
    when(command.getEntityNewName()).thenReturn("bar");
    command.logRenamedEntity();
    when(command.getEntityOldName()).thenReturn("foo");
    command.logRenamedEntity();
}
#end_block

#method_before
protected void compensate() {
    internalCompensate();
}
#method_after
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected void compensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    // If the compensation data is not for the command do not perform compensation.
    if (!commandId.equals(getCompensationContext().getCommandId())) {
        return;
    }
    TransactionSupport.executeInNewTransaction(() -> {
        Deserializer deserializer = SerializationFactory.getDeserializer();
        List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDao().getAllForCommandId(commandId);
        log.debug("Command [id={}]: {} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
        for (BusinessEntitySnapshot snapshot : entitySnapshots) {
            Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
            Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
            log.info("Command [id={}]: Compensating {} of {}; snapshot: {}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), snapshot.getSnapshotType() == SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString());
            Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
            switch(snapshot.getSnapshotType()) {
                case CHANGED_STATUS_ONLY:
                    EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                    ((StatusAwareDao<Serializable, Enum<?>>) getDaoForEntity(entityClass)).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                    break;
                case DELETED_OR_UPDATED_ENTITY:
                    deletedOrUpdateEntity(entityClass, (BusinessEntity<Serializable>) snapshotData);
                    break;
                case UPDATED_ONLY_ENTITY:
                    getDaoForEntity(entityClass).update((BusinessEntity<Serializable>) snapshotData);
                    break;
                case NEW_ENTITY_ID:
                    getDaoForEntity(entityClass).remove(snapshotData);
                    break;
                case TRANSIENT_ENTITY:
                    objectCompensation.compensate(CommandBase.this, (TransientCompensationBusinessEntity) snapshotData);
                    break;
                default:
                    throw new IllegalArgumentException(String.format("Unknown %s value, unable to compensate value %s.", SnapshotType.class.getName(), snapshot.getSnapshotType()));
            }
        }
        getCompensationContext().afterCompensationCleanup();
        return null;
    });
}
#end_block

#method_before
private void mockNullVm() {
    when(vmDao.get(command.getParameters().getVmId())).thenReturn(null);
    createVirtIODisk();
}
#method_after
private void mockNullVm() {
    createVirtIODisk();
}
#end_block

#method_before
@Test
public void testIscsiLunCanBeAdded() {
    LunDisk disk = createISCSILunDisk();
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(disk);
    initializeCommand(Guid.newGuid(), parameters);
    when(diskLunMapDao.getDiskIdByLunId(disk.getLun().getLUNId())).thenReturn(null);
    assertTrue("checkIfLunDiskCanBeAdded() failed for valid iscsi lun", command.checkIfLunDiskCanBeAdded(spyDiskValidator(disk)));
}
#method_after
@Test
public void testIscsiLunCanBeAdded() {
    LunDisk disk = createISCSILunDisk();
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(disk);
    initializeCommand(Guid.newGuid(), parameters);
    assertTrue("checkIfLunDiskCanBeAdded() failed for valid iscsi lun", command.checkIfLunDiskCanBeAdded(spyDiskValidator(disk)));
}
#end_block

#method_before
@Test
public void testAddingIDELunExceedsSlotLimit() {
    mockInterfaceList();
    LunDisk disk = createISCSILunDisk();
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(disk);
    parameters.getDiskVmElement().setDiskInterface(DiskInterface.IDE);
    initializeCommand(Guid.newGuid(), parameters);
    when(diskLunMapDao.getDiskIdByLunId(disk.getLun().getLUNId())).thenReturn(null);
    VM vm = mockVm();
    mockMaxPciSlots();
    // use maximum slots for IDE - validate expected to succeed.
    mockOtherVmDisks(vm, VmCommand.MAX_IDE_SLOTS - 1, DiskInterface.IDE);
    ValidateTestUtils.runAndAssertValidateSuccess(command);
    LunDisk newDisk = createISCSILunDisk();
    newDisk.getDiskVmElementForVm(vmId).setDiskInterface(DiskInterface.IDE);
    vm.getDiskMap().put(newDisk.getId(), newDisk);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_IDE_SLOTS);
}
#method_after
@Test
public void testAddingIDELunExceedsSlotLimit() {
    mockInterfaceList();
    LunDisk disk = createISCSILunDisk();
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(disk);
    parameters.getDiskVmElement().setDiskInterface(DiskInterface.IDE);
    initializeCommand(Guid.newGuid(), parameters);
    VM vm = mockVm();
    mockMaxPciSlots();
    // use maximum slots for IDE - validate expected to succeed.
    mockOtherVmDisks(vm, VmCommand.MAX_IDE_SLOTS - 1, DiskInterface.IDE);
    ValidateTestUtils.runAndAssertValidateSuccess(command);
    LunDisk newDisk = createISCSILunDisk();
    newDisk.getDiskVmElementForVm(vmId).setDiskInterface(DiskInterface.IDE);
    vm.getDiskMap().put(newDisk.getId(), newDisk);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_IDE_SLOTS);
}
#end_block

#method_before
@Test
public void testAddingPCILunExceedsSlotLimit() {
    mockInterfaceList();
    LunDisk disk = createISCSILunDisk();
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(disk);
    parameters.getDiskVmElement().setDiskInterface(DiskInterface.VirtIO);
    initializeCommand(Guid.newGuid(), parameters);
    when(diskLunMapDao.getDiskIdByLunId(disk.getLun().getLUNId())).thenReturn(null);
    VM vm = mockVm();
    mockMaxPciSlots();
    // use maximum slots for PCI. validate expected to succeed.
    mockOtherVmDisks(vm, MAX_PCI_SLOTS - 2, DiskInterface.VirtIO);
    ValidateTestUtils.runAndAssertValidateSuccess(command);
    LunDisk newDisk = createISCSILunDisk();
    newDisk.getDiskVmElementForVm(vmId).setDiskInterface(DiskInterface.VirtIO);
    vm.getDiskMap().put(newDisk.getId(), newDisk);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_PCI_SLOTS);
}
#method_after
@Test
public void testAddingPCILunExceedsSlotLimit() {
    mockInterfaceList();
    LunDisk disk = createISCSILunDisk();
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(disk);
    parameters.getDiskVmElement().setDiskInterface(DiskInterface.VirtIO);
    initializeCommand(Guid.newGuid(), parameters);
    VM vm = mockVm();
    mockMaxPciSlots();
    // use maximum slots for PCI. validate expected to succeed.
    mockOtherVmDisks(vm, MAX_PCI_SLOTS - 2, DiskInterface.VirtIO);
    ValidateTestUtils.runAndAssertValidateSuccess(command);
    LunDisk newDisk = createISCSILunDisk();
    newDisk.getDiskVmElementForVm(vmId).setDiskInterface(DiskInterface.VirtIO);
    vm.getDiskMap().put(newDisk.getId(), newDisk);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_PCI_SLOTS);
}
#end_block

#method_before
@Test
public void testExistingQuota() {
    Quota quota = new Quota();
    quota.setId(Guid.newGuid());
    DiskImage img = createDiskImage(10);
    img.setQuotaId(quota.getId());
    AddDiskParameters params = createParameters();
    params.setDiskInfo(img);
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId, params);
    StoragePool pool = mockStoragePool();
    command.setStoragePoolId(pool.getId());
    quota.setStoragePoolId(pool.getId());
    mockVm();
    mockEntities(storageId);
    QuotaDao quotaDaoMock = mock(QuotaDao.class);
    when(quotaDaoMock.getById(any(Guid.class))).thenReturn(null);
    when(quotaDaoMock.getById(quota.getId())).thenReturn(quota);
    doReturn(quotaDaoMock).when(command).getQuotaDao();
    doCallRealMethod().when(command).validateQuota();
    ValidateTestUtils.runAndAssertValidateSuccess(command);
}
#method_after
@Test
public void testExistingQuota() {
    Quota quota = new Quota();
    quota.setId(Guid.newGuid());
    DiskImage img = createDiskImage(10);
    img.setQuotaId(quota.getId());
    AddDiskParameters params = createParameters();
    params.setDiskInfo(img);
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId, params);
    StoragePool pool = mockStoragePool();
    command.setStoragePoolId(pool.getId());
    quota.setStoragePoolId(pool.getId());
    mockVm();
    mockEntities(storageId);
    QuotaDao quotaDaoMock = mock(QuotaDao.class);
    when(quotaDaoMock.getById(quota.getId())).thenReturn(quota);
    doReturn(quotaDaoMock).when(command).getQuotaDao();
    doCallRealMethod().when(command).validateQuota();
    ValidateTestUtils.runAndAssertValidateSuccess(command);
}
#end_block

#method_before
@Test
public void testNonExistingQuota() {
    DiskImage img = createDiskImage(10);
    img.setQuotaId(Guid.newGuid());
    AddDiskParameters params = createParameters();
    params.setDiskInfo(img);
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId, params);
    mockVm();
    mockEntities(storageId);
    QuotaDao quotaDaoMock = mock(QuotaDao.class);
    when(quotaDaoMock.getById(any(Guid.class))).thenReturn(null);
    doReturn(quotaDaoMock).when(command).getQuotaDao();
    doCallRealMethod().when(command).validateQuota();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
}
#method_after
@Test
public void testNonExistingQuota() {
    DiskImage img = createDiskImage(10);
    img.setQuotaId(Guid.newGuid());
    AddDiskParameters params = createParameters();
    params.setDiskInfo(img);
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId, params);
    mockVm();
    mockEntities(storageId);
    QuotaDao quotaDaoMock = mock(QuotaDao.class);
    doReturn(quotaDaoMock).when(command).getQuotaDao();
    doCallRealMethod().when(command).validateQuota();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
}
#end_block

#method_before
private void mockNullVm() {
    when(vmDao.get(command.getParameters().getVmId())).thenReturn(null);
    createVirtIODisk();
}
#method_after
private void mockNullVm() {
    createVirtIODisk();
}
#end_block

#method_before
protected void initializeCommand(VmDiskOperationParameterBase params, List<VM> vms) {
    // Done before creating the spy to have correct values during the ctor run
    mockCtorRelatedDaoCalls(vms);
    command = spy(new UpdateVmDiskCommand<VmDiskOperationParameterBase>(params, CommandContext.createContext(params.getSessionId())) {

        // Overridden here and not during spying, since it's called in the constructor
        @SuppressWarnings("synthetic-access")
        @Override
        public DiskDao getDiskDao() {
            return diskDao;
        }

        @Override
        public VmDao getVmDao() {
            return vmDao;
        }
    });
    doReturn(snapshotDao).when(command).getSnapshotDao();
    doReturn(diskImageDao).when(command).getDiskImageDao();
    doReturn(storagePoolDao).when(command).getStoragePoolDao();
    doReturn(storageDomainStaticDao).when(command).getStorageDomainStaticDao();
    doReturn(storageDomainDao).when(command).getStorageDomainDao();
    doReturn(vmStaticDao).when(command).getVmStaticDao();
    doReturn(baseDiskDao).when(command).getBaseDiskDao();
    doReturn(imageDao).when(command).getImageDao();
    doReturn(vmDeviceDao).when(command).getVmDeviceDao();
    doReturn(vmDao).when(command).getVmDao();
    doReturn(diskDao).when(command).getDiskDao();
    doReturn(diskVmElementDao).when(command).getDiskVmElementDao();
    doNothing().when(command).reloadDisks();
    doNothing().when(command).updateBootOrder();
    doNothing().when(vmStaticDao).incrementDbGeneration(any(Guid.class));
    doReturn(quotaManager).when(command).getQuotaManager();
    doAnswer(invocation -> invocation.getArguments()[0] != null ? invocation.getArguments()[0] : Guid.newGuid()).when(quotaManager).getDefaultQuotaIfNull(any(Guid.class), any(Guid.class));
    SnapshotsValidator snapshotsValidator = mock(SnapshotsValidator.class);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    when(diskVmElementValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskUsedAsOvfStore()).thenReturn(ValidationResult.VALID);
    doReturn(ValidationResult.VALID).when(diskValidator).isDiskAttachedToVm(any(VM.class));
    doReturn(ValidationResult.VALID).when(diskValidator).isDiskExists();
    doReturn(ValidationResult.VALID).when(diskValidator).validateNotHostedEngineDisk();
    doReturn(ValidationResult.VALID).when(diskVmElementValidator).isReadOnlyPropertyCompatibleWithInterface();
    doReturn(diskValidator).when(command).getDiskValidator(any(Disk.class));
    doReturn(diskVmElementValidator).when(command).getDiskVmElementValidator(any(Disk.class), any(DiskVmElement.class));
    doReturn(true).when(command).setAndValidateDiskProfiles();
    doReturn(true).when(command).validateQuota();
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    mockVds();
    mockVmsStoragePoolInfo(vms);
    mockToUpdateDiskVm(vms);
    StorageDomain sd = new StorageDomain();
    sd.setAvailableDiskSize(Integer.MAX_VALUE);
    sd.setStatus(StorageDomainStatus.Active);
    when(storageDomainDao.getForStoragePool(any(Guid.class), any(Guid.class))).thenReturn(sd);
    StorageDomainValidator sdValidator = new StorageDomainValidator(sd);
    doReturn(sdValidator).when(command).getStorageDomainValidator(any(DiskImage.class));
    command.init();
}
#method_after
protected void initializeCommand(VmDiskOperationParameterBase params, List<VM> vms) {
    // Done before creating the spy to have correct values during the ctor run
    mockCtorRelatedDaoCalls(vms);
    command = spy(new UpdateVmDiskCommand<VmDiskOperationParameterBase>(params, CommandContext.createContext(params.getSessionId())) {

        // Overridden here and not during spying, since it's called in the constructor
        @SuppressWarnings("synthetic-access")
        @Override
        public DiskDao getDiskDao() {
            return diskDao;
        }

        @Override
        public VmDao getVmDao() {
            return vmDao;
        }
    });
    doReturn(snapshotDao).when(command).getSnapshotDao();
    doReturn(diskImageDao).when(command).getDiskImageDao();
    doReturn(storagePoolDao).when(command).getStoragePoolDao();
    doReturn(storageDomainStaticDao).when(command).getStorageDomainStaticDao();
    doReturn(storageDomainDao).when(command).getStorageDomainDao();
    doReturn(vmStaticDao).when(command).getVmStaticDao();
    doReturn(baseDiskDao).when(command).getBaseDiskDao();
    doReturn(imageDao).when(command).getImageDao();
    doReturn(vmDeviceDao).when(command).getVmDeviceDao();
    doReturn(vmDao).when(command).getVmDao();
    doReturn(diskDao).when(command).getDiskDao();
    doReturn(diskVmElementDao).when(command).getDiskVmElementDao();
    doNothing().when(command).reloadDisks();
    doNothing().when(command).updateBootOrder();
    doReturn(quotaManager).when(command).getQuotaManager();
    doAnswer(invocation -> invocation.getArguments()[0] != null ? invocation.getArguments()[0] : Guid.newGuid()).when(quotaManager).getDefaultQuotaIfNull(any(Guid.class), any(Guid.class));
    SnapshotsValidator snapshotsValidator = mock(SnapshotsValidator.class);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    when(diskVmElementValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskUsedAsOvfStore()).thenReturn(ValidationResult.VALID);
    doReturn(ValidationResult.VALID).when(diskValidator).isDiskAttachedToVm(any(VM.class));
    doReturn(ValidationResult.VALID).when(diskValidator).isDiskExists();
    doReturn(ValidationResult.VALID).when(diskValidator).validateNotHostedEngineDisk();
    doReturn(ValidationResult.VALID).when(diskVmElementValidator).isReadOnlyPropertyCompatibleWithInterface();
    doReturn(diskValidator).when(command).getDiskValidator(any(Disk.class));
    doReturn(diskVmElementValidator).when(command).getDiskVmElementValidator(any(Disk.class), any(DiskVmElement.class));
    doReturn(true).when(command).setAndValidateDiskProfiles();
    doReturn(true).when(command).validateQuota();
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    mockVds();
    mockVmsStoragePoolInfo(vms);
    mockToUpdateDiskVm(vms);
    StorageDomain sd = new StorageDomain();
    sd.setAvailableDiskSize(Integer.MAX_VALUE);
    sd.setStatus(StorageDomainStatus.Active);
    when(storageDomainDao.getForStoragePool(any(Guid.class), any(Guid.class))).thenReturn(sd);
    StorageDomainValidator sdValidator = new StorageDomainValidator(sd);
    doReturn(sdValidator).when(command).getStorageDomainValidator(any(DiskImage.class));
    command.init();
}
#end_block

#method_before
public ValidationResult isOsSupportedForVirtIoScsi(VM vm) {
    if (!VmValidationUtils.isDiskInterfaceSupportedByOs(vm.getOs(), vm.getCompatibilityVersion(), DiskInterface.VirtIO_SCSI)) {
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
    }
    return ValidationResult.VALID;
}
#method_after
private ValidationResult isOsSupportedForVirtIoScsi(VM vm) {
    if (!VmValidationUtils.isDiskInterfaceSupportedByOs(vm.getOs(), vm.getCompatibilityVersion(), DiskInterface.VirtIO_SCSI)) {
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!isFloatingDisk() && !validate(new VmValidator(getVm()).isVmExists()) && !validateDiskVmData()) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE || diskInfo.getDiskStorageType() == DiskStorageType.CINDER) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (vm != null) {
        if (!validateDiskVmData() || !canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        if (getDiskVmElement().isBoot() && !validate(diskValidator.isVmNotContainsBootDisk(vm))) {
            return false;
        }
        // if user sent drive check that its not in use
        if (!isDiskPassPciAndIdeLimit()) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failValidation(EngineMessage.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    DiskVmElementValidator diskVmElementValidator = getDiskVmElementValidator(getParameters().getDiskInfo(), getDiskVmElement());
    if (!validate(diskVmElementValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (!validateQuota()) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        if (!checkIfImageDiskCanBeAdded(vm, getDiskVmElementValidator(getParameters().getDiskInfo(), getDiskVmElement()))) {
            return false;
        }
        return setAndValidateDiskProfiles();
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    if (DiskStorageType.CINDER == getParameters().getDiskInfo().getDiskStorageType()) {
        CinderDisk cinderDisk = (CinderDisk) getParameters().getDiskInfo();
        cinderDisk.setStorageIds(new ArrayList<>(Collections.singletonList(getStorageDomainId())));
        StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisk);
        return validate(storageDomainValidator.isDomainExistAndActive()) && validate(cinderDisksValidator.validateCinderDiskLimits()) && validate(cinderDisksValidator.validateCinderVolumeTypesExist());
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!isFloatingDisk() && !validate(new VmValidator(getVm()).isVmExists()) && !validateDiskVmData()) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE || diskInfo.getDiskStorageType() == DiskStorageType.CINDER) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (vm != null) {
        if (!validateDiskVmData() || !canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        if (getDiskVmElement().isBoot() && !validate(diskValidator.isVmNotContainsBootDisk(vm))) {
            return false;
        }
        // if user sent drive check that its not in use
        if (!isDiskPassPciAndIdeLimit()) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failValidation(EngineMessage.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    DiskVmElementValidator diskVmElementValidator = getDiskVmElementValidator(getParameters().getDiskInfo(), getDiskVmElement());
    if (!validate(diskVmElementValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (!validateQuota()) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        if (!checkIfImageDiskCanBeAdded(vm, diskVmElementValidator)) {
            return false;
        }
        return setAndValidateDiskProfiles();
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    if (DiskStorageType.CINDER == getParameters().getDiskInfo().getDiskStorageType()) {
        CinderDisk cinderDisk = (CinderDisk) getParameters().getDiskInfo();
        cinderDisk.setStorageIds(new ArrayList<>(Collections.singletonList(getStorageDomainId())));
        StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisk);
        return validate(storageDomainValidator.isDomainExistAndActive()) && validate(cinderDisksValidator.validateCinderDiskLimits()) && validate(cinderDisksValidator.validateCinderVolumeTypesExist());
    }
    return true;
}
#end_block

#method_before
@Test
public void testIscsiLunCanBeAdded() {
    LunDisk disk = createISCSILunDisk();
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(disk);
    initializeCommand(Guid.newGuid(), parameters);
    when(diskLunMapDao.getDiskIdByLunId(disk.getLun().getLUNId())).thenReturn(null);
    assertTrue("checkIfLunDiskCanBeAdded() failed for valid iscsi lun", command.checkIfLunDiskCanBeAdded(spyDiskValidator(disk)));
}
#method_after
@Test
public void testIscsiLunCanBeAdded() {
    LunDisk disk = createISCSILunDisk();
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(disk);
    initializeCommand(Guid.newGuid(), parameters);
    assertTrue("checkIfLunDiskCanBeAdded() failed for valid iscsi lun", command.checkIfLunDiskCanBeAdded(spyDiskValidator(disk)));
}
#end_block

#method_before
@Test
public void testAddingIDELunExceedsSlotLimit() {
    mockInterfaceList();
    LunDisk disk = createISCSILunDisk();
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(disk);
    parameters.getDiskVmElement().setDiskInterface(DiskInterface.IDE);
    initializeCommand(Guid.newGuid(), parameters);
    when(diskLunMapDao.getDiskIdByLunId(disk.getLun().getLUNId())).thenReturn(null);
    VM vm = mockVm();
    mockMaxPciSlots();
    // use maximum slots for IDE - validate expected to succeed.
    mockOtherVmDisks(vm, VmCommand.MAX_IDE_SLOTS - 1, DiskInterface.IDE);
    ValidateTestUtils.runAndAssertValidateSuccess(command);
    LunDisk newDisk = createISCSILunDisk();
    newDisk.getDiskVmElementForVm(vmId).setDiskInterface(DiskInterface.IDE);
    vm.getDiskMap().put(newDisk.getId(), newDisk);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_IDE_SLOTS);
}
#method_after
@Test
public void testAddingIDELunExceedsSlotLimit() {
    mockInterfaceList();
    LunDisk disk = createISCSILunDisk();
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(disk);
    parameters.getDiskVmElement().setDiskInterface(DiskInterface.IDE);
    initializeCommand(Guid.newGuid(), parameters);
    VM vm = mockVm();
    mockMaxPciSlots();
    // use maximum slots for IDE - validate expected to succeed.
    mockOtherVmDisks(vm, VmCommand.MAX_IDE_SLOTS - 1, DiskInterface.IDE);
    ValidateTestUtils.runAndAssertValidateSuccess(command);
    LunDisk newDisk = createISCSILunDisk();
    newDisk.getDiskVmElementForVm(vmId).setDiskInterface(DiskInterface.IDE);
    vm.getDiskMap().put(newDisk.getId(), newDisk);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_IDE_SLOTS);
}
#end_block

#method_before
@Test
public void testAddingPCILunExceedsSlotLimit() {
    mockInterfaceList();
    LunDisk disk = createISCSILunDisk();
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(disk);
    parameters.getDiskVmElement().setDiskInterface(DiskInterface.VirtIO);
    initializeCommand(Guid.newGuid(), parameters);
    when(diskLunMapDao.getDiskIdByLunId(disk.getLun().getLUNId())).thenReturn(null);
    VM vm = mockVm();
    mockMaxPciSlots();
    // use maximum slots for PCI. validate expected to succeed.
    mockOtherVmDisks(vm, MAX_PCI_SLOTS - 2, DiskInterface.VirtIO);
    ValidateTestUtils.runAndAssertValidateSuccess(command);
    LunDisk newDisk = createISCSILunDisk();
    newDisk.getDiskVmElementForVm(vmId).setDiskInterface(DiskInterface.VirtIO);
    vm.getDiskMap().put(newDisk.getId(), newDisk);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_PCI_SLOTS);
}
#method_after
@Test
public void testAddingPCILunExceedsSlotLimit() {
    mockInterfaceList();
    LunDisk disk = createISCSILunDisk();
    AddDiskParameters parameters = createParameters();
    parameters.setDiskInfo(disk);
    parameters.getDiskVmElement().setDiskInterface(DiskInterface.VirtIO);
    initializeCommand(Guid.newGuid(), parameters);
    VM vm = mockVm();
    mockMaxPciSlots();
    // use maximum slots for PCI. validate expected to succeed.
    mockOtherVmDisks(vm, MAX_PCI_SLOTS - 2, DiskInterface.VirtIO);
    ValidateTestUtils.runAndAssertValidateSuccess(command);
    LunDisk newDisk = createISCSILunDisk();
    newDisk.getDiskVmElementForVm(vmId).setDiskInterface(DiskInterface.VirtIO);
    vm.getDiskMap().put(newDisk.getId(), newDisk);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_PCI_SLOTS);
}
#end_block

#method_before
@Test
public void testExistingQuota() {
    Quota quota = new Quota();
    quota.setId(Guid.newGuid());
    DiskImage img = createDiskImage(10);
    img.setQuotaId(quota.getId());
    AddDiskParameters params = createParameters();
    params.setDiskInfo(img);
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId, params);
    StoragePool pool = mockStoragePool();
    command.setStoragePoolId(pool.getId());
    quota.setStoragePoolId(pool.getId());
    mockVm();
    mockEntities(storageId);
    QuotaDao quotaDaoMock = mock(QuotaDao.class);
    when(quotaDaoMock.getById(any(Guid.class))).thenReturn(null);
    when(quotaDaoMock.getById(quota.getId())).thenReturn(quota);
    doReturn(quotaDaoMock).when(command).getQuotaDao();
    doCallRealMethod().when(command).validateQuota();
    ValidateTestUtils.runAndAssertValidateSuccess(command);
}
#method_after
@Test
public void testExistingQuota() {
    Quota quota = new Quota();
    quota.setId(Guid.newGuid());
    DiskImage img = createDiskImage(10);
    img.setQuotaId(quota.getId());
    AddDiskParameters params = createParameters();
    params.setDiskInfo(img);
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId, params);
    StoragePool pool = mockStoragePool();
    command.setStoragePoolId(pool.getId());
    quota.setStoragePoolId(pool.getId());
    mockVm();
    mockEntities(storageId);
    QuotaDao quotaDaoMock = mock(QuotaDao.class);
    when(quotaDaoMock.getById(quota.getId())).thenReturn(quota);
    doReturn(quotaDaoMock).when(command).getQuotaDao();
    doCallRealMethod().when(command).validateQuota();
    ValidateTestUtils.runAndAssertValidateSuccess(command);
}
#end_block

#method_before
@Test
public void testNonExistingQuota() {
    DiskImage img = createDiskImage(10);
    img.setQuotaId(Guid.newGuid());
    AddDiskParameters params = createParameters();
    params.setDiskInfo(img);
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId, params);
    mockVm();
    mockEntities(storageId);
    QuotaDao quotaDaoMock = mock(QuotaDao.class);
    when(quotaDaoMock.getById(any(Guid.class))).thenReturn(null);
    doReturn(quotaDaoMock).when(command).getQuotaDao();
    doCallRealMethod().when(command).validateQuota();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
}
#method_after
@Test
public void testNonExistingQuota() {
    DiskImage img = createDiskImage(10);
    img.setQuotaId(Guid.newGuid());
    AddDiskParameters params = createParameters();
    params.setDiskInfo(img);
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId, params);
    mockVm();
    mockEntities(storageId);
    QuotaDao quotaDaoMock = mock(QuotaDao.class);
    doReturn(quotaDaoMock).when(command).getQuotaDao();
    doCallRealMethod().when(command).validateQuota();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
}
#end_block

#method_before
public void loadVmData(VM vm) {
    vmDeviceUtils.setVmDevices(vm.getStaticData());
    if (vm.getInterfaces().isEmpty()) {
        vm.setInterfaces(getVmNetworkInterfaceDao().getAllForVm(vm.getId()));
    }
    if (StringUtils.isEmpty(vm.getVmtName())) {
        if (!Guid.Empty.equals(vm.getVmtGuid())) {
            VmTemplate t = getVmTemplateDao().get(vm.getVmtGuid());
            vm.setVmtName(t.getName());
        } else {
            vm.setVmtName(VmTemplateHandler.BLANK_VM_TEMPLATE_NAME);
        }
    }
}
#method_after
public void loadVmData(VM vm) {
    vmDeviceUtils.setVmDevices(vm.getStaticData());
    if (vm.getInterfaces().isEmpty()) {
        vm.setInterfaces(vmNetworkInterfaceDao.getAllForVm(vm.getId()));
    }
    if (StringUtils.isEmpty(vm.getVmtName())) {
        if (!Guid.Empty.equals(vm.getVmtGuid())) {
            VmTemplate t = vmTemplateDao.get(vm.getVmtGuid());
            vm.setVmtName(t.getName());
        } else {
            vm.setVmtName(VmTemplateHandler.BLANK_VM_TEMPLATE_NAME);
        }
    }
}
#end_block

#method_before
public ArrayList<DiskImage> getVmImagesFromDb(VM vm) {
    ArrayList<DiskImage> allVmImages = new ArrayList<>();
    List<DiskImage> filteredDisks = DisksFilter.filterImageDisks(vm.getDiskList(), ONLY_SNAPABLE, ONLY_ACTIVE);
    for (DiskImage diskImage : filteredDisks) {
        allVmImages.addAll(getAllImageSnapshots(diskImage));
    }
    for (DiskImage disk : allVmImages) {
        DiskVmElement dve = DbFacade.getInstance().getDiskVmElementDao().get(new VmDeviceId(disk.getId(), vm.getId()));
        disk.setDiskVmElements(Collections.singletonList(dve));
    }
    return allVmImages;
}
#method_after
public ArrayList<DiskImage> getVmImagesFromDb(VM vm) {
    ArrayList<DiskImage> allVmImages = new ArrayList<>();
    List<DiskImage> filteredDisks = DisksFilter.filterImageDisks(vm.getDiskList(), ONLY_SNAPABLE, ONLY_ACTIVE);
    for (DiskImage diskImage : filteredDisks) {
        allVmImages.addAll(getAllImageSnapshots(diskImage));
    }
    for (DiskImage disk : allVmImages) {
        DiskVmElement dve = diskVmElementDao.get(new VmDeviceId(disk.getId(), vm.getId()));
        disk.setDiskVmElements(Collections.singletonList(dve));
    }
    return allVmImages;
}
#end_block

#method_before
public void loadTemplateData(VmTemplate template) {
    vmDeviceUtils.setVmDevices(template);
    if (template.getInterfaces() == null || template.getInterfaces().isEmpty()) {
        template.setInterfaces(getVmNetworkInterfaceDao().getAllForTemplate(template.getId()));
    }
}
#method_after
public void loadTemplateData(VmTemplate template) {
    vmDeviceUtils.setVmDevices(template);
    if (template.getInterfaces() == null || template.getInterfaces().isEmpty()) {
        template.setInterfaces(vmNetworkInterfaceDao.getAllForTemplate(template.getId()));
    }
}
#end_block

#method_before
public boolean executeUpdateVmInSpmCommand(Guid storagePoolId, Map<Guid, KeyValuePairCompat<String, List<Guid>>> metaDictionary, Guid storageDomainId) {
    UpdateVMVDSCommandParameters tempVar = new UpdateVMVDSCommandParameters(storagePoolId, metaDictionary);
    tempVar.setStorageDomainId(storageDomainId);
    return Backend.getInstance().getResourceManager().runVdsCommand(VDSCommandType.UpdateVM, tempVar).getSucceeded();
}
#method_after
public boolean executeUpdateVmInSpmCommand(Guid storagePoolId, Map<Guid, KeyValuePairCompat<String, List<Guid>>> metaDictionary, Guid storageDomainId) {
    UpdateVMVDSCommandParameters tempVar = new UpdateVMVDSCommandParameters(storagePoolId, metaDictionary);
    tempVar.setStorageDomainId(storageDomainId);
    return resourceManager.runVdsCommand(VDSCommandType.UpdateVM, tempVar).getSucceeded();
}
#end_block

#method_before
protected boolean executeRemoveVmInSpm(Guid storagePoolId, Guid id, Guid storageDomainId) {
    return Backend.getInstance().getResourceManager().runVdsCommand(VDSCommandType.RemoveVM, new RemoveVMVDSCommandParameters(storagePoolId, id, storageDomainId)).getSucceeded();
}
#method_after
protected boolean executeRemoveVmInSpm(Guid storagePoolId, Guid id, Guid storageDomainId) {
    return resourceManager.runVdsCommand(VDSCommandType.RemoveVM, new RemoveVMVDSCommandParameters(storagePoolId, id, storageDomainId)).getSucceeded();
}
#end_block

#method_before
protected Map<Guid, KeyValuePairCompat<String, List<Guid>>> populateTemplatesMetadataForOvfUpdate(List<Guid> idsToProcess) {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndTemplateMetadata = new HashMap<>();
    List<VmTemplate> templates = getVmTemplateDao().getVmTemplatesByIds(idsToProcess);
    for (VmTemplate template : templates) {
        if (VmTemplateStatus.Locked != template.getStatus()) {
            updateTemplateDisksFromDb(template);
            boolean verifyDisksNotLocked = verifyImagesStatus(template.getDiskList());
            if (verifyDisksNotLocked) {
                getOvfUpdateProcessHelper().loadTemplateData(template);
                Long currentDbGeneration = getVmStaticDao().getDbGeneration(template.getId());
                // currentDbGeneration can be null in case that the template was deleted during the run of OvfDataUpdater.
                if (currentDbGeneration != null && template.getDbGeneration() == currentDbGeneration) {
                    proccessedOvfConfigurationsInfo.add(getOvfUpdateProcessHelper().buildMetadataDictionaryForTemplate(template, vmsAndTemplateMetadata));
                    proccessedIdsInfo.add(template.getId());
                    proccessedOvfGenerationsInfo.add(template.getDbGeneration());
                    proccessDisksDomains(template.getDiskList());
                }
            }
        }
    }
    return vmsAndTemplateMetadata;
}
#method_after
protected Map<Guid, KeyValuePairCompat<String, List<Guid>>> populateTemplatesMetadataForOvfUpdate(List<Guid> idsToProcess) {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndTemplateMetadata = new HashMap<>();
    List<VmTemplate> templates = getVmTemplateDao().getVmTemplatesByIds(idsToProcess);
    for (VmTemplate template : templates) {
        if (VmTemplateStatus.Locked != template.getStatus()) {
            updateTemplateDisksFromDb(template);
            boolean verifyDisksNotLocked = verifyImagesStatus(template.getDiskList());
            if (verifyDisksNotLocked) {
                ovfUpdateProcessHelper.loadTemplateData(template);
                Long currentDbGeneration = getVmStaticDao().getDbGeneration(template.getId());
                // currentDbGeneration can be null in case that the template was deleted during the run of OvfDataUpdater.
                if (currentDbGeneration != null && template.getDbGeneration() == currentDbGeneration) {
                    proccessedOvfConfigurationsInfo.add(ovfUpdateProcessHelper.buildMetadataDictionaryForTemplate(template, vmsAndTemplateMetadata));
                    proccessedIdsInfo.add(template.getId());
                    proccessedOvfGenerationsInfo.add(template.getDbGeneration());
                    proccessDisksDomains(template.getDiskList());
                }
            }
        }
    }
    return vmsAndTemplateMetadata;
}
#end_block

#method_before
protected Map<Guid, KeyValuePairCompat<String, List<Guid>>> populateVmsMetadataForOvfUpdate(List<Guid> idsToProcess) {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndTemplateMetadata = new HashMap<>();
    List<VM> vms = getVmDao().getVmsByIds(idsToProcess);
    for (VM vm : vms) {
        if (VMStatus.ImageLocked != vm.getStatus()) {
            updateVmDisksFromDb(vm);
            if (!verifyImagesStatus(vm.getDiskList())) {
                continue;
            }
            ArrayList<DiskImage> vmImages = getOvfUpdateProcessHelper().getVmImagesFromDb(vm);
            if (!verifyImagesStatus(vmImages)) {
                continue;
            }
            vm.setSnapshots(getSnapshotDao().getAllWithConfiguration(vm.getId()));
            if (!verifySnapshotsStatus(vm.getSnapshots())) {
                continue;
            }
            getOvfUpdateProcessHelper().loadVmData(vm);
            Long currentDbGeneration = getVmStaticDao().getDbGeneration(vm.getId());
            if (currentDbGeneration == null) {
                log.warn("currentDbGeneration of VM (name: '{}', id: '{}') is null, probably because the VM was deleted during the run of OvfDataUpdater.", vm.getName(), vm.getId());
                continue;
            }
            if (vm.getStaticData().getDbGeneration() == currentDbGeneration) {
                proccessedOvfConfigurationsInfo.add(getOvfUpdateProcessHelper().buildMetadataDictionaryForVm(vm, vmsAndTemplateMetadata, vmImages));
                proccessedIdsInfo.add(vm.getId());
                proccessedOvfGenerationsInfo.add(vm.getStaticData().getDbGeneration());
                proccessDisksDomains(vm.getDiskList());
            }
        }
    }
    return vmsAndTemplateMetadata;
}
#method_after
protected Map<Guid, KeyValuePairCompat<String, List<Guid>>> populateVmsMetadataForOvfUpdate(List<Guid> idsToProcess) {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndTemplateMetadata = new HashMap<>();
    List<VM> vms = getVmDao().getVmsByIds(idsToProcess);
    for (VM vm : vms) {
        if (VMStatus.ImageLocked != vm.getStatus()) {
            updateVmDisksFromDb(vm);
            if (!verifyImagesStatus(vm.getDiskList())) {
                continue;
            }
            ArrayList<DiskImage> vmImages = ovfUpdateProcessHelper.getVmImagesFromDb(vm);
            if (!verifyImagesStatus(vmImages)) {
                continue;
            }
            vm.setSnapshots(getSnapshotDao().getAllWithConfiguration(vm.getId()));
            if (!verifySnapshotsStatus(vm.getSnapshots())) {
                continue;
            }
            ovfUpdateProcessHelper.loadVmData(vm);
            Long currentDbGeneration = getVmStaticDao().getDbGeneration(vm.getId());
            if (currentDbGeneration == null) {
                log.warn("currentDbGeneration of VM (name: '{}', id: '{}') is null, probably because the VM was deleted during the run of OvfDataUpdater.", vm.getName(), vm.getId());
                continue;
            }
            if (vm.getStaticData().getDbGeneration() == currentDbGeneration) {
                proccessedOvfConfigurationsInfo.add(ovfUpdateProcessHelper.buildMetadataDictionaryForVm(vm, vmsAndTemplateMetadata, vmImages));
                proccessedIdsInfo.add(vm.getId());
                proccessedOvfGenerationsInfo.add(vm.getStaticData().getDbGeneration());
                proccessDisksDomains(vm.getDiskList());
            }
        }
    }
    return vmsAndTemplateMetadata;
}
#end_block

#method_before
@Before
public void setUp() {
    command = spy(new ProcessOvfUpdateForStoragePoolCommand<>(new ProcessOvfUpdateForStoragePoolParameters(), null));
    doReturn(ovfUpdateProcessHelper).when(command).getOvfUpdateProcessHelper();
    doReturn(ITEMS_COUNT_PER_UPDATE).when(command).loadConfigValue();
    doReturn(new ArrayList<DiskImage>()).when(ovfUpdateProcessHelper).getAllImageSnapshots(any(DiskImage.class));
    doCallRealMethod().when(command).executeCommand();
    // init members
    initMembers();
    // init daos
    doReturn(storagePoolDao).when(command).getStoragePoolDao();
    doReturn(vmAndTemplatesGenerationsDao).when(command).getVmAndTemplatesGenerationsDao();
    doReturn(vmDao).when(command).getVmDao();
    doReturn(vmStaticDao).when(command).getVmStaticDao();
    doReturn(snapshotDao).when(command).getSnapshotDao();
    doReturn(vmTemplateDao).when(command).getVmTemplateDao();
    doReturn(storageDomainOvfInfoDao).when(command).getStorageDomainOvfInfoDao();
    doReturn(storageDomainDao).when(command).getStorageDomainDao();
    // mock ovf data updater methods
    doNothing().when(ovfUpdateProcessHelper).loadTemplateData(any(VmTemplate.class));
    doNothing().when(ovfUpdateProcessHelper).loadVmData(any(VM.class));
    doNothing().when(command).updateVmDisksFromDb(any(VM.class));
    doNothing().when(command).updateTemplateDisksFromDb(any(VmTemplate.class));
    // dao related mocks.
    doReturn(1L).when(vmStaticDao).getDbGeneration(any(Guid.class));
    doReturn(pool1).when(command).getStoragePool();
    List<Snapshot> snapshots = new ArrayList<>();
    doReturn(snapshots).when(snapshotDao).getAllWithConfiguration(any(Guid.class));
    mockAnswers();
}
#method_after
@Before
public void setUp() {
    doReturn(ITEMS_COUNT_PER_UPDATE).when(command).loadConfigValue();
    doReturn(new ArrayList<DiskImage>()).when(ovfUpdateProcessHelper).getAllImageSnapshots(any(DiskImage.class));
    doCallRealMethod().when(command).executeCommand();
    // init members
    initMembers();
    // init daos
    doReturn(storagePoolDao).when(command).getStoragePoolDao();
    doReturn(vmAndTemplatesGenerationsDao).when(command).getVmAndTemplatesGenerationsDao();
    doReturn(vmDao).when(command).getVmDao();
    doReturn(vmStaticDao).when(command).getVmStaticDao();
    doReturn(snapshotDao).when(command).getSnapshotDao();
    doReturn(vmTemplateDao).when(command).getVmTemplateDao();
    doReturn(storageDomainOvfInfoDao).when(command).getStorageDomainOvfInfoDao();
    doReturn(storageDomainDao).when(command).getStorageDomainDao();
    // mock ovf data updater methods
    doNothing().when(ovfUpdateProcessHelper).loadTemplateData(any(VmTemplate.class));
    doNothing().when(ovfUpdateProcessHelper).loadVmData(any(VM.class));
    doNothing().when(command).updateVmDisksFromDb(any(VM.class));
    doNothing().when(command).updateTemplateDisksFromDb(any(VmTemplate.class));
    // dao related mocks.
    doReturn(1L).when(vmStaticDao).getDbGeneration(any(Guid.class));
    doReturn(pool1).when(command).getStoragePool();
    List<Snapshot> snapshots = new ArrayList<>();
    doReturn(snapshots).when(snapshotDao).getAllWithConfiguration(any(Guid.class));
    mockAnswers();
}
#end_block

#method_before
@Test
public void storageDomainWithId() {
    b.setStorageDomainId(GUID);
    b.setStoragePoolId(GUID);
    final StorageDomain s = b.getStorageDomain();
    assertEquals(StorageDomainStatus.Active, s.getStatus());
}
#method_after
@Test
public void storageDomainWithId() {
    b.setStorageDomainId(GUID);
    b.setStoragePoolId(GUID);
    final StorageDomain s = b.getStorageDomain();
    assertEquals(STORAGE_DOMAIN, s);
}
#end_block

#method_before
@Test
public void storageDomainWithNullId() {
    b.setStorageDomainId(GUID2);
    final StorageDomain s = b.getStorageDomain();
    assertEquals(StorageDomainStatus.Active, s.getStatus());
}
#method_after
@Test
public void storageDomainWithNullId() {
    b.setStorageDomainId(GUID2);
    final StorageDomain s = b.getStorageDomain();
    assertEquals(STORAGE_DOMAIN, s);
}
#end_block

#method_before
protected void sortImages() {
    // merge (and we can't yet run isLiveMerge()), so we just use an explicit flag.
    if (!getParameters().isImageIdsSorted()) {
        // Retrieve and sort the entire chain of images
        List<DiskImage> images = getAllImagesForDisk();
        ImagesHandler.sortImageList(images);
        // Get a sorted list of the selected images
        List<DiskImage> sortedImages = images.stream().filter(image -> image.getDiskStorageType() == DiskStorageType.IMAGE).filter(image -> getImages().contains(image)).collect(Collectors.toList());
        getParameters().setImageIds(new ArrayList<>(ImagesHandler.getDiskImageIds(sortedImages)));
        getParameters().setImageIdsSorted(true);
        List<Guid> snapshotIds = sortedImages.stream().map(DiskImage::getSnapshotId).collect(Collectors.toList());
        getParameters().setSnapshotIds(snapshotIds);
        getParameters().setImageGroupID(getImageGroupId());
    }
}
#method_after
private void sortImages() {
    // merge (and we can't yet run isLiveMerge()), so we just use an explicit flag.
    if (!getParameters().isImageIdsSorted()) {
        // Retrieve and sort the entire chain of images
        List<DiskImage> images = getAllImagesForDisk();
        ImagesHandler.sortImageList(images);
        // Get a sorted list of the selected images
        List<DiskImage> sortedImages = images.stream().filter(image -> image.getDiskStorageType() == DiskStorageType.IMAGE).filter(image -> getImages().contains(image)).collect(Collectors.toList());
        getParameters().setImageIds(new ArrayList<>(ImagesHandler.getDiskImageIds(sortedImages)));
        getParameters().setImageIdsSorted(true);
        getParameters().setImageGroupID(getImageGroupId());
    }
}
#end_block

#method_before
@Override
public CommandCallback getCallback() {
    if (getParameters().isUseCinderCommandCallback()) {
        return new ConcurrentChildCommandsExecutionCallback();
    }
    return new SerialChildCommandsExecutionCallback();
}
#method_after
@Override
public CommandCallback getCallback() {
    return getParameters().isUseCinderCommandCallback() ? new ConcurrentChildCommandsExecutionCallback() : new SerialChildCommandsExecutionCallback();
}
#end_block

#method_before
private boolean isLiveMerge() {
    return (getParameters().isLiveMerge() || (getVm() != null && getVm().isQualifiedForLiveSnapshotMerge())) && !ImagesHandler.filterImageDisks(getImages(), false, false, false).isEmpty();
}
#method_after
private boolean isLiveMerge() {
    return (getParameters().isLiveMerge() || (getVm() != null && getVm().isQualifiedForLiveSnapshotMerge())) && !DisksFilter.filterImageDisks(getImages()).isEmpty();
}
#end_block

#method_before
@Override
public boolean performNextOperation(int completedChildren) {
    if (completedChildren != 0 && !isLiveMerge()) {
        updateSnapshotVmConfiguration(getParameters().getImageIds().get(completedChildren - 1), getParameters().getSnapshotIds().get(completedChildren - 1));
    }
    if (completedChildren == getParameters().getImageIds().size()) {
        return false;
    }
    if (completedChildren == 0) {
        // Lock all disk images in advance
        ImagesHandler.updateAllDiskImageSnapshotsStatus(getImageGroupId(), ImageStatus.LOCKED);
    } else {
        if (isLiveMerge()) {
            checkImageIdConsistency(completedChildren - 1);
        }
    }
    Guid nextImageId = getParameters().getImageIds().get(completedChildren);
    log.info("Starting child command {} of {}, image '{}'", completedChildren + 1, getParameters().getImageIds().size(), nextImageId);
    ImagesContainterParametersBase parameters = isLiveMerge() ? buildRemoveSnapshotSingleDiskLiveParameters(nextImageId) : buildRemoveSnapshotSingleDiskParameters(nextImageId);
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    if (getParameters().getChildImageIds() == null) {
        getParameters().setChildImageIds(Arrays.asList(new Guid[getParameters().getImageIds().size()]));
    }
    getParameters().getChildImageIds().set(completedChildren, parameters.getDestinationImageId());
    persistCommand(getParameters().getParentCommand(), true);
    CommandCoordinatorUtil.executeAsyncCommand(isLiveMerge() ? VdcActionType.RemoveSnapshotSingleDiskLive : VdcActionType.RemoveSnapshotSingleDisk, parameters, cloneContextAndDetachFromParent());
    return true;
}
#method_after
@Override
public boolean performNextOperation(int completedChildren) {
    if (completedChildren == getParameters().getImageIds().size()) {
        return false;
    }
    if (completedChildren == 0) {
        // Lock all disk images in advance
        ImagesHandler.updateAllDiskImageSnapshotsStatus(getImageGroupId(), ImageStatus.LOCKED);
    }
    return isLiveMerge() ? performNextOperationLiveMerge(completedChildren) : performNextOperationColdMerge(completedChildren);
}
#end_block

#method_before
private RemoveSnapshotSingleDiskParameters buildRemoveSnapshotSingleDiskLiveParameters(Guid imageId) {
    DiskImage dest = getDiskImageDao().getAllSnapshotsForParent(imageId).get(0);
    RemoveSnapshotSingleDiskParameters parameters = new RemoveSnapshotSingleDiskParameters(imageId, getVmId());
    parameters.setDestinationImageId(dest.getImageId());
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setParentParameters(getParameters());
    parameters.setParentCommand(getActionType());
    parameters.setCommandType(VdcActionType.RemoveSnapshotSingleDiskLive);
    parameters.setVdsId(getVm().getRunOnVds());
    parameters.setSessionId(getParameters().getSessionId());
    return parameters;
}
#method_after
private RemoveSnapshotSingleDiskParameters buildRemoveSnapshotSingleDiskLiveParameters(Guid imageId, int completedChildren) {
    DiskImage dest = getDiskImageDao().getAllSnapshotsForParent(imageId).get(0);
    RemoveSnapshotSingleDiskParameters parameters = new RemoveSnapshotSingleDiskParameters(imageId, getVmId());
    parameters.setDestinationImageId(dest.getImageId());
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setParentParameters(getParameters());
    parameters.setParentCommand(getActionType());
    parameters.setCommandType(VdcActionType.RemoveSnapshotSingleDiskLive);
    parameters.setVdsId(getVm().getRunOnVds());
    parameters.setSessionId(getParameters().getSessionId());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    return parameters;
}
#end_block

#method_before
private ImagesContainterParametersBase buildRemoveSnapshotSingleDiskParameters(Guid imageId) {
    ImagesContainterParametersBase parameters = new ImagesContainterParametersBase(imageId, getVmId());
    DiskImage dest = DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForParent(imageId).get(0);
    parameters.setDestinationImageId(dest.getImageId());
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setParentParameters(getParameters());
    parameters.setParentCommand(getActionType());
    parameters.setWipeAfterDelete(dest.isWipeAfterDelete());
    parameters.setSessionId(getParameters().getSessionId());
    return parameters;
}
#method_after
private ImagesContainterParametersBase buildRemoveSnapshotSingleDiskParameters(Guid imageId) {
    ImagesContainterParametersBase parameters = new ImagesContainterParametersBase(imageId, getVmId());
    DiskImage dest = getDiskImageDao().getAllSnapshotsForParent(imageId).get(0);
    parameters.setDestinationImageId(dest.getImageId());
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setParentParameters(getParameters());
    parameters.setParentCommand(getActionType());
    parameters.setWipeAfterDelete(dest.isWipeAfterDelete());
    parameters.setSessionId(getParameters().getSessionId());
    parameters.setVmSnapshotId(getDiskImageDao().getSnapshotById(imageId).getVmSnapshotId());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    return parameters;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    addAuditLogCustomValues();
    switch(getActionState()) {
        case EXECUTE:
            if (!getParameters().isUseCinderCommandCallback()) {
                return getParameters().getTaskGroupSuccess() ? AuditLogType.USER_REMOVE_DISK_SNAPSHOT : AuditLogType.USER_REMOVE_DISK_SNAPSHOT_FINISHED_FAILURE;
            }
            if (!getParameters().getTaskGroupSuccess()) {
                return AuditLogType.USER_FAILED_REMOVE_DISK_SNAPSHOT;
            }
            break;
        case END_SUCCESS:
            return AuditLogType.USER_REMOVE_DISK_SNAPSHOT_FINISHED_SUCCESS;
        case END_FAILURE:
            return AuditLogType.USER_REMOVE_DISK_SNAPSHOT_FINISHED_FAILURE;
    }
    return AuditLogType.UNASSIGNED;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    addAuditLogCustomValues();
    switch(getActionState()) {
        case EXECUTE:
            return AuditLogType.USER_REMOVE_DISK_SNAPSHOT;
        case END_SUCCESS:
            return AuditLogType.USER_REMOVE_DISK_SNAPSHOT_FINISHED_SUCCESS;
        case END_FAILURE:
            return AuditLogType.USER_REMOVE_DISK_SNAPSHOT_FINISHED_FAILURE;
    }
    return AuditLogType.UNASSIGNED;
}
#end_block

#method_before
protected void initUser() {
    DbUser user = getSessionDataContainer().getUser(context.getEngineContext().getSessionId(), true);
    if (user != null) {
        setCurrentUser(user);
    }
    if (getSessionDataContainer().getPrincipalName(context.getEngineContext().getSessionId()) == null) {
        // command was most probably executed from Quartz job, so session doesn't contain any user info
        // we need to set username to fake internal user so audit logs will not contain "null@N/A" as username
        setUserName("SYSTEM");
    } else {
        setUserName(getSessionDataContainer().getUserName(context.getEngineContext().getSessionId()));
    }
}
#method_after
protected void initUser() {
    DbUser user = getSessionDataContainer().getUser(context.getEngineContext().getSessionId(), true);
    if (user != null) {
        setCurrentUser(user);
    }
    if (getSessionDataContainer().getPrincipalName(context.getEngineContext().getSessionId()) == null) {
        // command was most probably executed from Quartz job, so session doesn't contain any user info
        // we need to set username to fake internal user so audit logs will not contain "null@N/A" as username
        setUserName(SYSTEM_USER_NAME);
    } else {
        setUserName(getSessionDataContainer().getUserName(context.getEngineContext().getSessionId()));
    }
}
#end_block

#method_before
protected void handleStepsOnEnd() {
    if (getCommandStep() != null && getExecutionContext().getStep() != null) {
        executionHandler.endTaskStep(getExecutionContext().getStep().getId(), isEndSuccessfully() ? JobExecutionStatus.FINISHED : JobExecutionStatus.FAILED);
    }
    if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) {
        executionHandler.startFinalizingStep(getExecutionContext());
    }
}
#method_after
protected void handleStepsOnEnd() {
    if (getCommandStep() != null && getExecutionContext().getStep() != null) {
        executionHandler.endTaskStep(getExecutionContext().getStep().getId(), isEndSuccessfully() ? JobExecutionStatus.FINISHED : JobExecutionStatus.FAILED);
    }
    if (getCommandStep() == null && (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1)) {
        executionHandler.startFinalizingStep(getExecutionContext());
    }
}
#end_block

#method_before
protected QuotaManager getQuotaManager() {
    return quotaManager;
}
#method_after
public QuotaManager getQuotaManager() {
    return quotaManager;
}
#end_block

#method_before
protected VdcReturnValueBase runInternalActionWithTasksContext(VdcActionType actionType, VdcActionParametersBase parameters, EngineLock lock) {
    return runInternalAction(actionType, parameters, executionHandler.createDefaultContextForTasks(getContext(), lock));
}
#method_after
protected VdcReturnValueBase runInternalActionWithTasksContext(VdcActionType actionType, VdcActionParametersBase parameters, EngineLock lock) {
    return runInternalAction(actionType, parameters, ExecutionHandler.createDefaultContextForTasks(getContext(), lock));
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    // original state (before the merge-attempt).
    if (getDestinationDiskImage() != null) {
        Set<Guid> imagesToUpdate = new HashSet<>();
        DiskImage curr = getDestinationDiskImage();
        while (!curr.getParentId().equals(getDiskImage().getParentId())) {
            curr = getDiskImageDao().getSnapshotById(curr.getParentId());
            imagesToUpdate.add(curr.getImageId());
        }
        syncDbRecords(VmBlockJobType.PULL, getImageInfoFromVdsm(getDestinationDiskImage()), imagesToUpdate, true);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    // original state (before the merge-attempt).
    if (getDestinationDiskImage() != null) {
        Set<Guid> imagesToUpdate = new HashSet<>();
        DiskImage curr = getDestinationDiskImage();
        while (!curr.getParentId().equals(getDiskImage().getParentId())) {
            curr = getDiskImageDao().getSnapshotById(curr.getParentId());
            imagesToUpdate.add(curr.getImageId());
        }
        syncDbRecords(VmBlockJobType.PULL, getImageInfoFromVdsm(getDestinationDiskImage()), imagesToUpdate, true);
    }
    if (getParameters().getVmSnapshotId() != null) {
        lockVmSnapshotsWithWait(getVm());
        Snapshot snapshot = getSnapshotDao().get(getParameters().getVmSnapshotId());
        Snapshot snapshotWithoutImage = ImagesHandler.prepareSnapshotConfigWithoutImageSingleImage(snapshot, getParameters().getImageId());
        getSnapshotDao().update(snapshotWithoutImage);
        if (getSnapshotsEngineLock() != null) {
            getLockManager().releaseLock(getSnapshotsEngineLock());
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    // Initially we set the command as failed:
    VdcQueryReturnValue queryReturnValue = getQueryReturnValue();
    queryReturnValue.setSucceeded(false);
    // Check if the virtual machine is running on a host, and if does then retrieve the host and copy the subject
    // of the host of the certificate to the value returned by the query:
    Guid vmId = getParameters().getId();
    if (vmId != null) {
        VM vm = getDbFacade().getVmDao().get(vmId);
        if (vm != null) {
            Guid vdsId = vm.getRunOnVds();
            if (vdsId != null) {
                VDS vds = getDbFacade().getVdsDao().get(vdsId);
                queryReturnValue.setSucceeded(true);
                queryReturnValue.setReturnValue(vds.getCertificateSubject());
            }
        }
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    // Initially we set the command as failed:
    VdcQueryReturnValue queryReturnValue = getQueryReturnValue();
    queryReturnValue.setSucceeded(false);
    // Check if the virtual machine is running on a host, and if does then retrieve the host and copy the subject
    // of the certificate to the value returned by the query:
    Guid vmId = getParameters().getId();
    if (vmId != null) {
        VM vm = getDbFacade().getVmDao().get(vmId);
        if (vm != null) {
            Guid vdsId = vm.getRunOnVds();
            if (vdsId != null) {
                VDS vds = getDbFacade().getVdsDao().get(vdsId);
                queryReturnValue.setSucceeded(true);
                queryReturnValue.setReturnValue(vds.getCertificateSubject());
            }
        }
    }
}
#end_block

#method_before
private void generateAddMethod(Method method) {
    // Find the main parameter of the method, as this is the only one that appears in the JAX-RS interfaces, the
    // rest of the methods are extracted explicitly by the implementation:
    Parameter mainParameter = method.getParameters().stream().filter(x -> x.getType() instanceof StructType || x.getType() instanceof ListType).findFirst().orElse(null);
    if (mainParameter == null) {
        System.err.println("Method \"" + method + "\" doesn't have any struct parameter");
        return;
    }
    // Calculate the Java type of the main parameter:
    Type mainType = mainParameter.getType();
    JavaTypeReference mainTypeReference = schemaNames.getXjcTypeReference(mainType);
    // Generate the imports:
    javaBuffer.addImport(Consumes.class);
    javaBuffer.addImport(POST.class);
    javaBuffer.addImport(Response.class);
    javaBuffer.addImports(mainTypeReference.getImports());
    // Generate the method:
    generateDoc(method);
    javaBuffer.addLine("@POST");
    javaBuffer.addLine("@Consumes({ %s })", generateMediaTypes());
    javaBuffer.addLine(generateResponseReturnMethodSignature("add(%s %s)", mainTypeReference.getText(), javaNames.getJavaMemberStyleName(mainParameter.getName())));
    javaBuffer.addLine();
}
#method_after
private void generateAddMethod(Method method) {
    // Find the main parameter of the method, as this is the only one that appears in the JAX-RS interfaces, the
    // rest of the methods are extracted explicitly by the implementation:
    Parameter mainParameter = method.getParameters().stream().filter(x -> x.getType() instanceof StructType || x.getType() instanceof ListType).findFirst().orElse(null);
    if (mainParameter == null) {
        System.err.println("Method \"" + method + "\" doesn't have any struct parameter");
        return;
    }
    // Calculate the Java type of the main parameter:
    Type mainType = mainParameter.getType();
    JavaTypeReference mainTypeReference = schemaNames.getXjcTypeReference(mainType);
    // Generate the imports:
    javaBuffer.addImport(Consumes.class);
    javaBuffer.addImport(POST.class);
    javaBuffer.addImport(Response.class);
    javaBuffer.addImports(mainTypeReference.getImports());
    // Generate the method:
    generateDoc(method);
    javaBuffer.addLine("@POST");
    javaBuffer.addLine("@Consumes({ %s })", generateMediaTypes());
    addResponseReturnMethod("add(%s %s)", mainTypeReference.getText(), javaNames.getJavaMemberStyleName(mainParameter.getName()));
    javaBuffer.addLine();
}
#end_block

#method_before
private void generateGetMethod(Method method) {
    // Find the main parameter of the method, as this is the only one that appears in the JAX-RS interfaces, the
    // rest of the methods are extracted explicitly by the implementation:
    Parameter mainParameter = method.getParameters().stream().filter(x -> x.getType() instanceof StructType).findFirst().orElse(null);
    if (mainParameter == null) {
        System.err.println("Method \"" + method + "\" doesn't have any struct parameter");
        return;
    }
    // Most "Get" methods return the type that is declared in the model, but the root resource needs to return
    // "Response", because it has to be able to return the type declared in the model and also the XML schema and
    // the RSDL.
    Service service = method.getDeclaringService();
    boolean isRoot = service == service.getModel().getRoot();
    generateDoc(method);
    javaBuffer.addImport(GET.class);
    javaBuffer.addLine("@GET");
    if (isRoot) {
        javaBuffer.addImport(Response.class);
        javaBuffer.addLine(generateResponseReturnMethodSignature("get()"));
    } else {
        Type mainType = mainParameter.getType();
        JavaTypeReference mainTypeReference = schemaNames.getXjcTypeReference(mainType);
        javaBuffer.addImports(mainTypeReference.getImports());
        javaBuffer.addLine(generateMethodSignature(mainTypeReference.getText(), "get()"));
    }
    javaBuffer.addLine();
}
#method_after
private void generateGetMethod(Method method) {
    // Find the main parameter of the method, as this is the only one that appears in the JAX-RS interfaces, the
    // rest of the methods are extracted explicitly by the implementation:
    Parameter mainParameter = method.getParameters().stream().filter(x -> x.getType() instanceof StructType).findFirst().orElse(null);
    if (mainParameter == null) {
        System.err.println("Method \"" + method + "\" doesn't have any struct parameter");
        return;
    }
    // Most "Get" methods return the type that is declared in the model, but the root resource needs to return
    // "Response", because it has to be able to return the type declared in the model and also the XML schema and
    // the RSDL.
    Service service = method.getDeclaringService();
    boolean isRoot = service == service.getModel().getRoot();
    generateDoc(method);
    javaBuffer.addImport(GET.class);
    javaBuffer.addLine("@GET");
    if (isRoot) {
        javaBuffer.addImport(Response.class);
        addResponseReturnMethod("get()");
    } else {
        Type mainType = mainParameter.getType();
        JavaTypeReference mainTypeReference = schemaNames.getXjcTypeReference(mainType);
        javaBuffer.addImports(mainTypeReference.getImports());
        addMethod(mainTypeReference.getText(), "get()");
    }
    javaBuffer.addLine();
}
#end_block

#method_before
private void generateListMethod(Method method) {
    // Find the main parameter of the method, as this is the only one that appears in the JAX-RS interfaces, the
    // rest of the methods are extracted explicitly by the implementation:
    Parameter mainParameter = method.getParameters().stream().filter(x -> x.getType() instanceof ListType).findFirst().orElse(null);
    if (mainParameter == null) {
        System.err.println("Method \"" + method + "\" doesn't have any list parameter");
        return;
    }
    // Calculate the Java type of the main parameter:
    Type mainType = mainParameter.getType();
    JavaTypeReference mainTypeReference = schemaNames.getXjcTypeReference(mainType);
    // Generate the imports:
    javaBuffer.addImport(GET.class);
    javaBuffer.addImports(mainTypeReference.getImports());
    // Generate the method:
    generateDoc(method);
    javaBuffer.addLine("@GET");
    javaBuffer.addLine(generateMethodSignature(mainTypeReference.getText(), "list()"));
    javaBuffer.addLine();
}
#method_after
private void generateListMethod(Method method) {
    // Find the main parameter of the method, as this is the only one that appears in the JAX-RS interfaces, the
    // rest of the methods are extracted explicitly by the implementation:
    Parameter mainParameter = method.getParameters().stream().filter(x -> x.getType() instanceof ListType).findFirst().orElse(null);
    if (mainParameter == null) {
        System.err.println("Method \"" + method + "\" doesn't have any list parameter");
        return;
    }
    // Calculate the Java type of the main parameter:
    Type mainType = mainParameter.getType();
    JavaTypeReference mainTypeReference = schemaNames.getXjcTypeReference(mainType);
    // Generate the imports:
    javaBuffer.addImport(GET.class);
    javaBuffer.addImports(mainTypeReference.getImports());
    // Generate the method:
    generateDoc(method);
    javaBuffer.addLine("@GET");
    addMethod(mainTypeReference.getText(), "list()");
    javaBuffer.addLine();
}
#end_block

#method_before
private void generateRemoveMethod(Method method) {
    // Generate the imports:
    javaBuffer.addImport(DELETE.class);
    javaBuffer.addImport(Response.class);
    // The remove methods that have structured parameters (currently only the method that removes a set of Gluster
    // bricks) need to receive an "Action" to carry those parameters.
    // TODO: Fix this renaming that method to "RemoveBricks" or something similar.
    boolean needsAction = method.parameters().map(Parameter::getType).anyMatch(x -> x instanceof StructType || x instanceof ListType);
    generateDoc(method);
    javaBuffer.addLine("@DELETE");
    if (needsAction) {
        javaBuffer.addImport(javaPackages.getXjcPackageName(), "Action");
        javaBuffer.addLine(generateResponseReturnMethodSignature("remove(Action action)"));
    } else {
        javaBuffer.addLine(generateResponseReturnMethodSignature("remove()"));
    }
    javaBuffer.addLine();
}
#method_after
private void generateRemoveMethod(Method method) {
    // Generate the imports:
    javaBuffer.addImport(DELETE.class);
    javaBuffer.addImport(Response.class);
    // The remove methods that have structured parameters (currently only the method that removes a set of Gluster
    // bricks) need to receive an "Action" to carry those parameters.
    // TODO: Fix this renaming that method to "RemoveBricks" or something similar.
    boolean needsAction = method.parameters().map(Parameter::getType).anyMatch(x -> x instanceof StructType || x instanceof ListType);
    generateDoc(method);
    javaBuffer.addLine("@DELETE");
    if (needsAction) {
        javaBuffer.addImport(javaPackages.getXjcPackageName(), "Action");
        addResponseReturnMethod("remove(Action action)");
    } else {
        addResponseReturnMethod("remove()");
    }
    javaBuffer.addLine();
}
#end_block

#method_before
private void generateUpdateMethod(Method method) {
    // Find the main parameter of the method, as this is the only one that appears in the JAX-RS interfaces, the
    // rest of the methods are extracted explicitly by the implementation:
    Parameter mainParameter = method.getParameters().stream().filter(x -> x.getType() instanceof StructType).findFirst().orElse(null);
    if (mainParameter == null) {
        System.err.println("Method \"" + method + "\" doesn't have any struct parameter");
        return;
    }
    // Calculate the Java type of the main parameter:
    Type mainType = mainParameter.getType();
    JavaTypeReference mainTypeReference = schemaNames.getXjcTypeReference(mainType);
    // Generate the imports:
    javaBuffer.addImport(Consumes.class);
    javaBuffer.addImport(PUT.class);
    javaBuffer.addImports(mainTypeReference.getImports());
    // Generate the method:
    generateDoc(method);
    javaBuffer.addLine("@PUT");
    javaBuffer.addLine("@Consumes({ %s })", generateMediaTypes());
    javaBuffer.addLine(generateMethodSignature(mainTypeReference.getText(), "update(%s %s)", mainTypeReference.getText(), javaNames.getJavaMemberStyleName(mainParameter.getName())));
    javaBuffer.addLine();
}
#method_after
private void generateUpdateMethod(Method method) {
    // Find the main parameter of the method, as this is the only one that appears in the JAX-RS interfaces, the
    // rest of the methods are extracted explicitly by the implementation:
    Parameter mainParameter = method.getParameters().stream().filter(x -> x.getType() instanceof StructType).findFirst().orElse(null);
    if (mainParameter == null) {
        System.err.println("Method \"" + method + "\" doesn't have any struct parameter");
        return;
    }
    // Calculate the Java type of the main parameter:
    Type mainType = mainParameter.getType();
    JavaTypeReference mainTypeReference = schemaNames.getXjcTypeReference(mainType);
    // Generate the imports:
    javaBuffer.addImport(Consumes.class);
    javaBuffer.addImport(PUT.class);
    javaBuffer.addImports(mainTypeReference.getImports());
    // Generate the method:
    generateDoc(method);
    javaBuffer.addLine("@PUT");
    javaBuffer.addLine("@Consumes({ %s })", generateMediaTypes());
    addMethod(mainTypeReference.getText(), "update(%s %s)", mainTypeReference.getText(), javaNames.getJavaMemberStyleName(mainParameter.getName()));
    javaBuffer.addLine();
}
#end_block

#method_before
private void generateActionMethod(Method method) {
    // Generate the imports:
    javaBuffer.addImport(Consumes.class);
    javaBuffer.addImport(POST.class);
    javaBuffer.addImport(Path.class);
    javaBuffer.addImport(Response.class);
    javaBuffer.addImport(javaPackages.getXjcPackageName(), "Action");
    javaBuffer.addImport(javaPackages.getXjcPackageName(), "Actionable");
    // Generate the method:
    generateDoc(method);
    javaBuffer.addLine("@POST");
    javaBuffer.addLine("@Consumes({ %s })", generateMediaTypes());
    javaBuffer.addLine("@Actionable");
    javaBuffer.addLine("@Path(\"%s\")", jaxrsNames.getActionPath(method.getName()));
    javaBuffer.addLine(generateResponseReturnMethodSignature(jaxrsNames.getMethodName(method.getName()) + "(Action action)"));
    javaBuffer.addLine();
}
#method_after
private void generateActionMethod(Method method) {
    // Generate the imports:
    javaBuffer.addImport(Consumes.class);
    javaBuffer.addImport(POST.class);
    javaBuffer.addImport(Path.class);
    javaBuffer.addImport(Response.class);
    javaBuffer.addImport(javaPackages.getXjcPackageName(), "Action");
    javaBuffer.addImport(javaPackages.getXjcPackageName(), "Actionable");
    // Generate the method:
    generateDoc(method);
    javaBuffer.addLine("@POST");
    javaBuffer.addLine("@Consumes({ %s })", generateMediaTypes());
    javaBuffer.addLine("@Actionable");
    javaBuffer.addLine("@Path(\"%s\")", jaxrsNames.getActionPath(method.getName()));
    addResponseReturnMethod(jaxrsNames.getMethodName(method.getName()) + "(Action action)");
    javaBuffer.addLine();
}
#end_block

#method_before
protected RunVmFlow getFlow() {
    RunVmFlow cachedFlow = getParameters().getCachedFlow();
    if (cachedFlow != null) {
        return cachedFlow;
    }
    switch(getVm().getStatus()) {
        case Paused:
            return setFlow(RunVmFlow.RESUME_PAUSE);
        case Suspended:
            return setFlow(RunVmFlow.RESUME_HIBERNATE);
        default:
    }
    if (isRunAsStateless()) {
        fetchVmDisksFromDb();
        if (getVm().getDiskList().isEmpty()) {
            // If there are no snappable disks, there is no meaning for
            // running as stateless, log a warning and run normally
            warnIfNotAllDisksPermitSnapshots();
            return setFlow(RunVmFlow.RUN);
        }
        if (isStatelessSnapshotExistsForVm()) {
            log.error("VM '{}' ({}) already contains stateless snapshot, removing it", getVm().getName(), getVm().getId());
            return setFlow(RunVmFlow.REMOVE_STATELESS_IMAGES);
        }
        return setFlow(RunVmFlow.CREATE_STATELESS_IMAGES);
    }
    if (!isInternalExecution() && isStatelessSnapshotExistsForVm() && !isVmPartOfManualPool()) {
        return setFlow(RunVmFlow.REMOVE_STATELESS_IMAGES);
    }
    return setFlow(RunVmFlow.RUN);
}
#method_after
protected RunVmFlow getFlow() {
    RunVmFlow cachedFlow = getParameters().getCachedFlow();
    if (cachedFlow != null) {
        return cachedFlow;
    }
    switch(getVm().getStatus()) {
        case Paused:
            return setFlow(RunVmFlow.RESUME_PAUSE);
        case Suspended:
            return setFlow(RunVmFlow.RESUME_HIBERNATE);
        default:
    }
    if (isRunAsStateless()) {
        fetchVmDisksFromDb();
        if (isStatelessSnapshotExistsForVm()) {
            log.error("VM '{}' ({}) already contains stateless snapshot, removing it", getVm().getName(), getVm().getId());
            return setFlow(RunVmFlow.REMOVE_STATELESS_IMAGES);
        }
        return setFlow(RunVmFlow.CREATE_STATELESS_IMAGES);
    }
    if (!isInternalExecution() && isStatelessSnapshotExistsForVm() && !isVmPartOfManualPool()) {
        return setFlow(RunVmFlow.REMOVE_STATELESS_IMAGES);
    }
    return setFlow(RunVmFlow.RUN);
}
#end_block

#method_before
@OnTimerMethodAnnotation("fetchIsoDomains")
public synchronized void fetchIsoDomains() {
    // Gets all the active Iso storage domains.
    List<RepoImage> repofileList = repoStorageDom.getAllRepoFilesForAllStoragePools(StorageDomainType.ISO, StoragePoolStatus.Up, StorageDomainStatus.Active, VDSStatus.Up);
    resetProblematicList();
    // Iterate for each storage domain.
    List<Callable<Void>> tasks = new ArrayList<>();
    for (final RepoImage repoImage : repofileList) {
        // from the DB.
        if (shouldRefreshIsoDomain(repoImage.getLastRefreshed())) {
            tasks.add(() -> {
                updateCachedIsoFileListFromVdsm(repoImage);
                return null;
            });
        } else {
            log.debug("Automatic refresh process for '{}' file type in storage domain id '{}' was not performed" + " since refresh time out did not passed yet.", repoImage.getFileType(), repoImage.getRepoDomainId());
        }
    }
    ThreadPoolUtil.invokeAll(tasks);
    // After refresh for all Iso domains finished, handle the log.
    handleErrorLog(new ArrayList<>(problematicRepoFileList));
}
#method_after
@OnTimerMethodAnnotation("fetchIsoDomains")
public synchronized void fetchIsoDomains() {
    // Gets all the active Iso storage domains.
    List<RepoImage> repofileList = repoFileMetaDataDao.getAllRepoFilesForAllStoragePools(StorageDomainType.ISO, StoragePoolStatus.Up, StorageDomainStatus.Active, VDSStatus.Up);
    resetProblematicList();
    // Iterate for each storage domain.
    List<Callable<Void>> tasks = new ArrayList<>();
    for (final RepoImage repoImage : repofileList) {
        // from the DB.
        if (shouldRefreshIsoDomain(repoImage.getLastRefreshed())) {
            tasks.add(() -> {
                updateCachedIsoFileListFromVdsm(repoImage);
                return null;
            });
        } else {
            log.debug("Automatic refresh process for '{}' file type in storage domain id '{}' was not performed" + " since refresh time out did not passed yet.", repoImage.getFileType(), repoImage.getRepoDomainId());
        }
    }
    ThreadPoolUtil.invokeAll(tasks);
    // After refresh for all Iso domains finished, handle the log.
    handleErrorLog(new ArrayList<>(problematicRepoFileList));
}
#end_block

#method_before
private boolean refreshImageDomain(final StorageDomain storageDomain, final ImageFileType imageType) {
    final RepoFileMetaDataDao repoFileMetaDataDao = repoStorageDom;
    Provider provider = providerDao.get(new Guid(storageDomain.getStorage()));
    final OpenStackImageProviderProxy client = ProviderProxyFactory.getInstance().create(provider);
    Lock syncObject = getSyncObject(storageDomain.getId(), imageType);
    try {
        syncObject.lock();
        return TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, () -> {
            repoFileMetaDataDao.removeRepoDomainFileList(storageDomain.getId(), imageType);
            Integer totalListSize = Config.<Integer>getValue(ConfigValues.GlanceImageTotalListSize);
            List<RepoImage> repoImages = client.getAllImagesAsRepoImages(Config.<Integer>getValue(ConfigValues.GlanceImageListSize), totalListSize);
            if (repoImages.size() >= totalListSize) {
                AuditLogableBase logable = new AuditLogableBase();
                logable.addCustomValue("imageDomain", storageDomain.getName());
                logable.addCustomValue("imageListSize", String.valueOf(repoImages.size()));
                auditLogDirector.log(logable, AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_INCOMPLETE);
            }
            for (RepoImage repoImage : repoImages) {
                repoImage.setRepoDomainId(storageDomain.getId());
                repoFileMetaDataDao.addRepoFileMap(repoImage);
            }
            return true;
        });
    } finally {
        syncObject.unlock();
    }
}
#method_after
private boolean refreshImageDomain(final StorageDomain storageDomain, final ImageFileType imageType) {
    Provider provider = providerDao.get(new Guid(storageDomain.getStorage()));
    final OpenStackImageProviderProxy client = ProviderProxyFactory.getInstance().create(provider);
    Lock syncObject = getSyncObject(storageDomain.getId(), imageType);
    try {
        syncObject.lock();
        return TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, () -> {
            repoFileMetaDataDao.removeRepoDomainFileList(storageDomain.getId(), imageType);
            Integer totalListSize = Config.<Integer>getValue(ConfigValues.GlanceImageTotalListSize);
            List<RepoImage> repoImages = client.getAllImagesAsRepoImages(Config.<Integer>getValue(ConfigValues.GlanceImageListSize), totalListSize);
            if (repoImages.size() >= totalListSize) {
                AuditLogableBase logable = new AuditLogableBase();
                logable.addCustomValue("imageDomain", storageDomain.getName());
                logable.addCustomValue("imageListSize", String.valueOf(repoImages.size()));
                auditLogDirector.log(logable, AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_INCOMPLETE);
            }
            for (RepoImage repoImage : repoImages) {
                repoImage.setRepoDomainId(storageDomain.getId());
                repoFileMetaDataDao.addRepoFileMap(repoImage);
            }
            return true;
        });
    } finally {
        syncObject.unlock();
    }
}
#end_block

#method_before
public List<RepoImage> getCachedIsoListByDomainId(Guid isoStorageDomainId, ImageFileType imageType) {
    List<RepoImage> fileListMD = new ArrayList<>();
    if (isoStorageDomainId != null) {
        fileListMD = repoStorageDom.getRepoListForStorageDomain(isoStorageDomainId, imageType);
    }
    return fileListMD;
}
#method_after
public List<RepoImage> getCachedIsoListByDomainId(Guid isoStorageDomainId, ImageFileType imageType) {
    List<RepoImage> fileListMD = new ArrayList<>();
    if (isoStorageDomainId != null) {
        fileListMD = repoFileMetaDataDao.getRepoListForStorageDomain(isoStorageDomainId, imageType);
    }
    return fileListMD;
}
#end_block

#method_before
private static boolean refreshIsoFileListMetaData(final Guid repoStorageDomainId, final RepoFileMetaDataDao repoFileMetaDataDao, final Map<String, Map<String, Object>> fileStats, final ImageFileType imageType) {
    Lock syncObject = getSyncObject(repoStorageDomainId, imageType);
    try {
        syncObject.lock();
        return (Boolean) TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                long currentTime = System.currentTimeMillis();
                repoFileMetaDataDao.removeRepoDomainFileList(repoStorageDomainId, imageType);
                for (Map.Entry<String, Map<String, Object>> entry : fileStats.entrySet()) {
                    repoFileMetaDataDao.addRepoFileMap(newRepoImage(currentTime, entry));
                }
                return true;
            }

            public RepoImage newRepoImage(long currentTime, Map.Entry<String, Map<String, Object>> entry) {
                RepoImage repo_md = new RepoImage();
                repo_md.setLastRefreshed(currentTime);
                repo_md.setSize(retrieveIsoFileSize(entry));
                repo_md.setRepoDomainId(repoStorageDomainId);
                repo_md.setDateCreated(null);
                repo_md.setRepoImageId(entry.getKey());
                repo_md.setRepoImageName(null);
                repo_md.setFileType(imageType);
                return repo_md;
            }
        });
    } catch (Exception e) {
        log.warn("Updating repository content to DB failed for repoStorageDomainId={}, imageType={}: {}", repoStorageDomainId, imageType, e.getMessage());
        log.debug("Exception", e);
        return false;
    } finally {
        syncObject.unlock();
    }
}
#method_after
private boolean refreshIsoFileListMetaData(final Guid repoStorageDomainId, final Map<String, Map<String, Object>> fileStats, final ImageFileType imageType) {
    Lock syncObject = getSyncObject(repoStorageDomainId, imageType);
    try {
        syncObject.lock();
        return (Boolean) TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                long currentTime = System.currentTimeMillis();
                repoFileMetaDataDao.removeRepoDomainFileList(repoStorageDomainId, imageType);
                for (Map.Entry<String, Map<String, Object>> entry : fileStats.entrySet()) {
                    repoFileMetaDataDao.addRepoFileMap(newRepoImage(currentTime, entry));
                }
                return true;
            }

            public RepoImage newRepoImage(long currentTime, Map.Entry<String, Map<String, Object>> entry) {
                RepoImage repo_md = new RepoImage();
                repo_md.setLastRefreshed(currentTime);
                repo_md.setSize(retrieveIsoFileSize(entry));
                repo_md.setRepoDomainId(repoStorageDomainId);
                repo_md.setDateCreated(null);
                repo_md.setRepoImageId(entry.getKey());
                repo_md.setRepoImageName(null);
                repo_md.setFileType(imageType);
                return repo_md;
            }
        });
    } catch (Exception e) {
        log.warn("Updating repository content to DB failed for repoStorageDomainId={}, imageType={}: {}", repoStorageDomainId, imageType, e.getMessage());
        log.debug("Exception", e);
        return false;
    } finally {
        syncObject.unlock();
    }
}
#end_block

#method_before
private boolean refreshVdsmFileList(Guid repoStoragePoolId, Guid repoStorageDomainId, ImageFileType imageFileType, Map<String, Map<String, Object>> fileStats, FileListRefreshed fileListRefreshed) {
    if (repoStorageDomainId == null) {
        return false;
    }
    boolean vdsmRefreshOk = fileStats != null;
    log.debug("The refresh process from VDSM, for {}, {}.", imageFileType, succeededOrFailed(vdsmRefreshOk));
    if (!vdsmRefreshOk) {
        return false;
    }
    boolean refreshSucceeded = refreshIsoFileListMetaData(repoStorageDomainId, repoStorageDom, fileStats, imageFileType);
    if (refreshSucceeded && fileListRefreshed != null) {
        fileListRefreshed.onFileListRefreshed(repoStoragePoolId, fileStats.keySet());
    }
    return refreshSucceeded;
}
#method_after
private boolean refreshVdsmFileList(Guid repoStoragePoolId, Guid repoStorageDomainId, ImageFileType imageFileType, Map<String, Map<String, Object>> fileStats, FileListRefreshed fileListRefreshed) {
    if (repoStorageDomainId == null) {
        return false;
    }
    boolean vdsmRefreshOk = fileStats != null;
    log.debug("The refresh process from VDSM, for {}, {}.", imageFileType, succeededOrFailed(vdsmRefreshOk));
    if (!vdsmRefreshOk) {
        return false;
    }
    boolean refreshSucceeded = refreshIsoFileListMetaData(repoStorageDomainId, fileStats, imageFileType);
    if (refreshSucceeded && fileListRefreshed != null) {
        fileListRefreshed.onFileListRefreshed(repoStoragePoolId, fileStats.keySet());
    }
    return refreshSucceeded;
}
#end_block

#method_before
private static Lock getSyncObject(Guid domainId, ImageFileType imageType) {
    Pair<Guid, ImageFileType> domainPerFileType = new Pair<>(domainId, imageType);
    syncDomainForFileTypeMap.putIfAbsent(domainPerFileType, new ReentrantLock());
    return syncDomainForFileTypeMap.get(domainPerFileType);
}
#method_after
private Lock getSyncObject(Guid domainId, ImageFileType imageType) {
    Pair<Guid, ImageFileType> domainPerFileType = new Pair<>(domainId, imageType);
    syncDomainForFileTypeMap.putIfAbsent(domainPerFileType, new ReentrantLock());
    return syncDomainForFileTypeMap.get(domainPerFileType);
}
#end_block

#method_before
private static void addToAuditLogErrorMessage(String problematicRepoFilesList) {
    AuditLogableBase logable = new AuditLogableBase();
    // Get translated error by error code ,if no translation found (should not happened) ,
    // will set the error code instead.
    logable.addCustomValue("imageDomains", problematicRepoFilesList);
    auditLogDirector.log(logable, AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_FAILED);
}
#method_after
private void addToAuditLogErrorMessage(String problematicRepoFilesList) {
    AuditLogableBase logable = new AuditLogableBase();
    // Get translated error by error code ,if no translation found (should not happened) ,
    // will set the error code instead.
    logable.addCustomValue("imageDomains", problematicRepoFilesList);
    auditLogDirector.log(logable, AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_FAILED);
}
#end_block

#method_before
private static void addToAuditLogSuccessMessage(String IsoDomain, String imageType) {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("imageDomains", String.format("%s (%s file type)", IsoDomain, imageType));
    auditLogDirector.log(logable, AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_SUCCEEDED);
}
#method_after
private void addToAuditLogSuccessMessage(String IsoDomain, String imageType) {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("imageDomains", String.format("%s (%s file type)", IsoDomain, imageType));
    auditLogDirector.log(logable, AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_SUCCEEDED);
}
#end_block

#method_before
public void createCommand() {
    mockCpuFlagsManagerHandler();
    when(osRepository.isWindows(anyInt())).thenReturn(false);
    when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true);
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    updateVmHandler();
    RunVmParams param = new RunVmParams(Guid.newGuid());
    command = spy(new RunVmCommand<RunVmParams>(param, null) {

        @Override
        protected void loadPayloadDevice() {
        }
    });
    mockIsoDomainListSyncronizer();
    mockSuccessfulRunVmValidator();
    doNothing().when(command).initParametersForExternalNetworks();
    doNothing().when(command).initParametersForPassthroughVnics();
    mockSuccessfulSnapshotValidator();
    mockBackend();
}
#method_after
public void createCommand() {
    mockCpuFlagsManagerHandler();
    when(osRepository.isWindows(anyInt())).thenReturn(false);
    when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true);
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    updateVmHandler();
    RunVmParams param = new RunVmParams(Guid.newGuid());
    command = spy(new RunVmCommand<RunVmParams>(param, null) {

        @Override
        protected void loadPayloadDevice() {
        }
    });
    mockIsoDomainListSynchronizer();
    mockSuccessfulRunVmValidator();
    doNothing().when(command).initParametersForExternalNetworks();
    doNothing().when(command).initParametersForPassthroughVnics();
    mockSuccessfulSnapshotValidator();
    mockBackend();
}
#end_block

#method_before
@Test
public void testFlowOnStatelessNoDisks() {
    final VM vm = new VM();
    vm.setStatus(VMStatus.Down);
    vm.getDiskList().clear();
    doReturn(vm).when(command).getVm();
    final RunVmParams params = new RunVmParams();
    params.setRunAsStateless(true);
    doReturn(params).when(command).getParameters();
    doNothing().when(command).fetchVmDisksFromDb();
    assertEquals(RunVmFlow.RUN, command.getFlow());
}
#method_after
@Test
public void testFlowOnStatelessNoDisks() {
    final VM vm = new VM();
    vm.setStatus(VMStatus.Down);
    vm.getDiskList().clear();
    doReturn(vm).when(command).getVm();
    final RunVmParams params = new RunVmParams();
    params.setRunAsStateless(true);
    doReturn(params).when(command).getParameters();
    doNothing().when(command).fetchVmDisksFromDb();
    doReturn(false).when(command).isStatelessSnapshotExistsForVm();
    assertEquals(RunVmFlow.CREATE_STATELESS_IMAGES, command.getFlow());
}
#end_block

#method_before
private void initHandlers() {
    tagsHandler = HandlersFactory.createTagsHandler();
    BaseConditionFieldAutoCompleter.tagsHandler = tagsHandler;
    VmHandler.init();
    VdsHandler.init();
    VmTemplateHandler.init();
    log.info("Completed initializing handlers");
}
#method_after
private void initHandlers() {
    BaseConditionFieldAutoCompleter.tagsHandler = tagsDirector;
    VmHandler.init();
    VdsHandler.init();
    VmTemplateHandler.init();
    log.info("Completed initializing handlers");
}
#end_block

#method_before
private void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // save host that HE VM was running on prior to engine startup
    serviceLoader.load(PreviousHostedEngineHost.class);
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    serviceLoader.load(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    serviceLoader.load(CpuFlagsManagerHandler.class);
    serviceLoader.load(AuditLogCleanupManager.class);
    serviceLoader.load(CommandEntityCleanupManager.class);
    TagsDirector.getInstance().init();
    serviceLoader.load(IsoDomainListSynchronizer.class);
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    serviceLoader.load(JobRepositoryCleanupManager.class);
    serviceLoader.load(AutoRecoveryManager.class);
    initExecutionMessageDirector();
    taskSchedulers.select(SchedulerUtilQuartzImpl.class).get().scheduleAFixedDelayJob(sessionDataContainer, "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    serviceLoader.load(VmsMonitoring.class);
    serviceLoader.load(VmDevicesMonitoring.class);
    serviceLoader.load(VmPoolHandler.class);
    serviceLoader.load(VmPoolMonitor.class);
    serviceLoader.load(HaAutoStartVmsRunner.class);
    serviceLoader.load(QuotaManager.class);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    registerIconDefaultsProvider();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#method_after
private void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // save host that HE VM was running on prior to engine startup
    serviceLoader.load(PreviousHostedEngineHost.class);
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    serviceLoader.load(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    serviceLoader.load(CpuFlagsManagerHandler.class);
    serviceLoader.load(AuditLogCleanupManager.class);
    serviceLoader.load(CommandEntityCleanupManager.class);
    serviceLoader.load(TagsDirector.class);
    serviceLoader.load(IsoDomainListSynchronizer.class);
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    serviceLoader.load(JobRepositoryCleanupManager.class);
    serviceLoader.load(AutoRecoveryManager.class);
    initExecutionMessageDirector();
    taskSchedulers.select(SchedulerUtilQuartzImpl.class).get().scheduleAFixedDelayJob(sessionDataContainer, "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    serviceLoader.load(VmsMonitoring.class);
    serviceLoader.load(VmDevicesMonitoring.class);
    serviceLoader.load(VmPoolHandler.class);
    serviceLoader.load(VmPoolMonitor.class);
    serviceLoader.load(HaAutoStartVmsRunner.class);
    serviceLoader.load(QuotaManager.class);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    registerIconDefaultsProvider();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#end_block

#method_before
public ValidationResult setAndValidateDiskProfiles(Map<DiskImage, Guid> map, DbUser user) {
    if (map == null) {
        return ValidationResult.VALID;
    }
    Map<Guid, List<DiskProfile>> storageDiskProfilesMap = new HashMap<>();
    // caching disk profile ids that was already checked.
    Set<Guid> permittedDiskProfilesIds = new HashSet<>();
    for (Entry<DiskImage, Guid> entry : map.entrySet()) {
        DiskImage diskImage = entry.getKey();
        Guid storageDomainId = entry.getValue();
        if (diskImage.getDiskStorageType() != DiskStorageType.IMAGE) {
            log.info("Disk profiles is not supported for storage type '{}' (Disk '{}')", diskImage.getDiskStorageType(), diskImage.getDiskAlias());
            continue;
        }
        if (diskImage.getDiskProfileId() == null && storageDomainId != null) {
            List<DiskProfile> diskProfilesList = storageDiskProfilesMap.get(storageDomainId);
            if (diskProfilesList == null) {
                diskProfilesList = diskProfileDao.getAllForStorageDomain(storageDomainId);
                storageDiskProfilesMap.put(storageDomainId, diskProfilesList);
            }
            // Set Disk Profile according to permissions
            if (!updateDiskProfileForBackwardCompatibility(diskImage, diskProfilesList, permittedDiskProfilesIds, user)) {
                return new ValidationResult(EngineMessage.USER_NOT_AUTHORIZED_TO_ATTACH_DISK_PROFILE);
            }
        } else {
            DiskProfile diskProfile = updateDiskImageProfilesList(diskImage, storageDomainId, user);
            if (diskProfile == null) {
                return new ValidationResult(EngineMessage.ACTION_TYPE_DISK_PROFILE_NOT_FOUND_FOR_STORAGE_DOMAIN, String.format("$storageDomainId %s", storageDomainId));
            }
            ValidationResult result = isDiskProfileParentEntityValid(diskProfile, storageDomainId);
            if (result != ValidationResult.VALID) {
                return result;
            }
            if (!isDiskProfilePermitted(diskProfile, permittedDiskProfilesIds, user)) {
                return new ValidationResult(EngineMessage.USER_NOT_AUTHORIZED_TO_ATTACH_DISK_PROFILE);
            }
        }
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult setAndValidateDiskProfiles(Map<DiskImage, Guid> map, DbUser user) {
    if (map == null) {
        return ValidationResult.VALID;
    }
    Map<Guid, List<DiskProfile>> storageDiskProfilesMap = new HashMap<>();
    // caching disk profile ids that was already checked.
    Set<Guid> permittedDiskProfilesIds = new HashSet<>();
    for (Entry<DiskImage, Guid> entry : map.entrySet()) {
        DiskImage diskImage = entry.getKey();
        Guid storageDomainId = entry.getValue();
        if (diskImage.getDiskStorageType() != DiskStorageType.IMAGE) {
            log.info("Disk profiles is not supported for storage type '{}' (Disk '{}')", diskImage.getDiskStorageType(), diskImage.getDiskAlias());
            continue;
        }
        if (diskImage.getDiskProfileId() == null && storageDomainId != null) {
            List<DiskProfile> diskProfilesList = storageDiskProfilesMap.get(storageDomainId);
            if (diskProfilesList == null) {
                diskProfilesList = diskProfileDao.getAllForStorageDomain(storageDomainId);
                storageDiskProfilesMap.put(storageDomainId, diskProfilesList);
            }
            // Set Disk Profile according to permissions
            if (!updateDiskProfileForBackwardCompatibility(diskImage, diskProfilesList, permittedDiskProfilesIds, user)) {
                return new ValidationResult(EngineMessage.USER_NOT_AUTHORIZED_TO_ATTACH_DISK_PROFILE);
            }
        } else {
            DiskProfile diskProfile = updateDiskImageProfilesList(diskImage, storageDomainId);
            if (diskProfile == null) {
                return new ValidationResult(EngineMessage.ACTION_TYPE_DISK_PROFILE_NOT_FOUND_FOR_STORAGE_DOMAIN, String.format("$storageDomainId %s", storageDomainId));
            }
            ValidationResult result = isDiskProfileParentEntityValid(diskProfile, storageDomainId);
            if (result != ValidationResult.VALID) {
                return result;
            }
            if (!isDiskProfilePermitted(diskProfile, permittedDiskProfilesIds, user)) {
                return new ValidationResult(EngineMessage.USER_NOT_AUTHORIZED_TO_ATTACH_DISK_PROFILE);
            }
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private DiskProfile updateDiskImageProfilesList(DiskImage diskImage, Guid storageDomainId, DbUser user) {
    DiskProfile diskProfile = null;
    if (storageDomainId != null && user != null) {
        List<Guid> diskProfileIds = diskImage.getDiskProfileIds();
        List<DiskProfile> diskProfilesListByStorageDomain = diskProfileDao.getAllForStorageDomain(storageDomainId);
        Optional<DiskProfile> match = diskProfilesListByStorageDomain.stream().filter(profile -> diskProfileIds.contains(profile.getId())).findFirst();
        if (match.isPresent()) {
            diskProfile = match.get();
            diskImage.setDiskProfileIds(new ArrayList<Guid>(Arrays.asList(diskProfile.getId())));
        }
    }
    return diskProfile;
}
#method_after
private DiskProfile updateDiskImageProfilesList(DiskImage diskImage, Guid storageDomainId) {
    DiskProfile diskProfile = null;
    if (storageDomainId != null) {
        List<Guid> diskProfileIds = diskImage.getDiskProfileIds();
        List<DiskProfile> diskProfilesListByStorageDomain = diskProfileDao.getAllForStorageDomain(storageDomainId);
        Optional<DiskProfile> match = diskProfilesListByStorageDomain.stream().filter(profile -> diskProfileIds.contains(profile.getId())).findFirst();
        if (match.isPresent()) {
            diskProfile = match.get();
            diskImage.setDiskProfileIds(new ArrayList<Guid>(Arrays.asList(diskProfile.getId())));
        }
    }
    return diskProfile;
}
#end_block

#method_before
@Override
protected boolean validate() {
    VdcReturnValueBase returnValue = CommandHelper.canDoAction(VdcActionType.AddDisk, getAddDiskParameters(), getContext().clone(), true);
    getReturnValue().setValidationMessages(returnValue.getValidationMessages());
    return returnValue.isValid();
}
#method_after
@Override
protected boolean validate() {
    VdcReturnValueBase returnValue = CommandHelper.canDoAction(VdcActionType.AddDisk, getAddDiskParameters(), getContext().clone());
    getReturnValue().setValidationMessages(returnValue.getValidationMessages());
    return returnValue.isValid();
}
#end_block

#method_before
public static VdcReturnValueBase canDoAction(VdcActionType actionType, VdcActionParametersBase parameters, CommandContext commandContext, boolean isInternal) {
    parameters.setSessionId(commandContext.getEngineContext().getSessionId());
    CommandBase<?> command = buildCommand(actionType, parameters, commandContext.getExecutionContext(), CommandStatus.NOT_STARTED);
    command.setInternalExecution(isInternal);
    return command.validateOnly();
}
#method_after
public static VdcReturnValueBase canDoAction(VdcActionType actionType, VdcActionParametersBase parameters, CommandContext commandContext) {
    return CommandsFactory.createCommand(actionType, parameters, commandContext).validateOnly();
}
#end_block

#method_before
public static JsonCommand createCommand(String methodName) {
    switch(methodName) {
        case "Host.getCapabilities":
            return new GetCapabilitiesCommand();
        case "Host.getVMList":
            return new GetVmListCommand();
        case "Host.getStats":
            return new GetStatsCommand();
        case "Host.getAllVmStats":
            return new GetAllVmStatsCommand();
        case "Host.getHardwareInfo":
            return new GetHardwareInfoCommmand();
        case "Host.getAllTasksStatuses":
            return new GetAllTasksStatusesCommand();
        case "Host.getAllTasksInfo":
            return new GetAllTasksInfoCommand();
        case "Host.getStorageDomains":
            return new HostGetStorageDomainsCommand();
        case "Host.getVMFullList":
            return new GetFullVmListCommand();
        case "Host.HostDevListByCaps":
            return new HostDevListByCaps();
        case "VM.create":
            return new VmCreateCommand();
        case "VM.destroy":
            return new VmDestroyCommand();
        case "VM.shutdown":
            return new VmShutdownCommand();
        case "VM.getStats":
            return new VmGetStatsCommand();
        case "VM.migrate":
            return new VmMigrateCommand();
        case "VM.setTicket":
            return new VmSetTicketCommand();
        case "StoragePool.spmStart":
            return new SpmStartCommand();
        case "StoragePool.spmStop":
            return new SpmStopCommand();
        case "StoragePool.getSpmStatus":
            return new SpmGetStatusCommand();
        case "StoragePool.connect":
            return new StoragePoolConnectCommand();
        case "StoragePool.disconnect":
            return new StoragePoolDisconnectCommand();
        case "StoragePool.connectStorageServer":
            return new StorageServerConnectCommand();
        case "StoragePool.disconnectStorageServer":
            return new StorageServerDisconnectCommand();
        case "StoragePool.getInfo":
            return new StoragePoolGetInfo();
        case "StoragePool.refresh":
            return new StoragePoolRefreshCommand();
        case "StoragePool.getIsoList":
            return new StoragePoolGetIsoListCommand();
        case "StoragePool.create":
            return new StoragePoolCreateCommand();
        case "StorageDomain.activate":
            return new StorageDomainActivateCommand();
        case "StorageDomain.getInfo":
            return new StorageDomainGetInfoCommand();
        case "StorageDomain.getStats":
            return new StorageDomainGetStatsCommand();
        case "StorageDomain.create":
            return new StorageDomainCreateCommand();
        case "Volume.create":
            return new VolumeCreateCommand();
        case "Task.getStatus":
            return new TaskGetStatusCommand();
        case "Task.stop":
            return new TaskStopCommand();
        case "Task.clear":
            return new TaskClearCommand();
        case "Task.revert":
            return new TaskRevertCommand();
        case "Image.delete":
            return new ImageDelete();
        case "Volume.getInfo":
            return new VolumeGetInfo();
        default:
            // TODO: Support Host.setMOMPolicyParameters
            Exception e = new Exception();
            log.error("Unsupported method " + methodName, e);
            return new UnsupportedCommand();
    }
}
#method_after
public static JsonCommand createCommand(String methodName) {
    switch(methodName) {
        case "Host.getCapabilities":
            return new GetCapabilitiesCommand();
        case "Host.getVMList":
            return new GetVmListCommand();
        case "Host.getStats":
            return new GetStatsCommand();
        case "Host.getAllVmStats":
            return new GetAllVmStatsCommand();
        case "Host.getHardwareInfo":
            return new GetHardwareInfoCommmand();
        case "Host.getAllTasksStatuses":
            return new GetAllTasksStatusesCommand();
        case "Host.getAllTasksInfo":
            return new GetAllTasksInfoCommand();
        case "Host.getStorageDomains":
            return new HostGetStorageDomainsCommand();
        case "Host.getVMFullList":
            return new GetFullVmListCommand();
        case "Host.HostDevListByCaps":
            return new HostDevListByCaps();
        case "VM.create":
            return new VmCreateCommand();
        case "VM.destroy":
            return new VmDestroyCommand();
        case "VM.shutdown":
            return new VmShutdownCommand();
        case "VM.getStats":
            return new VmGetStatsCommand();
        case "VM.migrate":
            return new VmMigrateCommand();
        case "VM.setTicket":
            return new VmSetTicketCommand();
        case "StoragePool.spmStart":
            return new SpmStartCommand();
        case "StoragePool.spmStop":
            return new SpmStopCommand();
        case "StoragePool.getSpmStatus":
            return new SpmGetStatusCommand();
        case "StoragePool.connect":
            return new StoragePoolConnectCommand();
        case "StoragePool.disconnect":
            return new StoragePoolDisconnectCommand();
        case "StoragePool.connectStorageServer":
            return new StorageServerConnectCommand();
        case "StoragePool.disconnectStorageServer":
            return new StorageServerDisconnectCommand();
        case "StoragePool.getInfo":
            return new StoragePoolGetInfo();
        case "StoragePool.refresh":
            return new StoragePoolRefreshCommand();
        case "StoragePool.getIsoList":
            return new StoragePoolGetIsoListCommand();
        case "StoragePool.create":
            return new StoragePoolCreateCommand();
        case "StorageDomain.activate":
            return new StorageDomainActivateCommand();
        case "StorageDomain.getInfo":
            return new StorageDomainGetInfoCommand();
        case "StorageDomain.getStats":
            return new StorageDomainGetStatsCommand();
        case "StorageDomain.create":
            return new StorageDomainCreateCommand();
        case "StorageDomain.attach":
            return new StorageDomainAttachCommand();
        case "Volume.create":
            return new VolumeCreateCommand();
        case "Task.getStatus":
            return new TaskGetStatusCommand();
        case "Task.stop":
            return new TaskStopCommand();
        case "Task.clear":
            return new TaskClearCommand();
        case "Task.revert":
            return new TaskRevertCommand();
        case "Image.delete":
            return new ImageDelete();
        case "Volume.getInfo":
            return new VolumeGetInfoCommand();
        default:
            // TODO: Support Host.setMOMPolicyParameters
            Exception e = new Exception();
            log.error("Unsupported method " + methodName, e);
            return new UnsupportedCommand();
    }
}
#end_block

#method_before
public void cleanup() {
    macPoolWidget.cleanup();
    driver.cleanup();
}
#method_after
public void cleanup() {
    driver.cleanup();
}
#end_block

#method_before
@Override
public void cleanup() {
    if (getExecutedEvent() != null) {
        getExecutedEvent().clearListeners();
    }
    super.cleanup();
}
#method_after
@Override
public void cleanup() {
    cleanupEvents(getExecutedEvent());
    super.cleanup();
}
#end_block

#method_before
private void writeCleanup() {
    JClassType editorType = model.getEditorType();
    Set<String> fieldSet = new HashSet<>();
    logger.log(Type.DEBUG, // $NON-NLS-1$
    "Starting to write cleanup impl. for editor " + editorType.getQualifiedSourceName());
    sw.println();
    // $NON-NLS-1$
    sw.println("@Override");
    // $NON-NLS-1$
    sw.println("public void cleanup() {");
    sw.indent();
    // $NON-NLS-1$
    sw.println("getObject().cleanup();");
    for (EditorData editorData : model.getEditorData()) {
        if (editorData.getPropertyOwnerType().isAssignableTo(hasCleanupType)) {
            // $NON-NLS-1$
            fieldSet.add(String.format("getObject()%s", editorData.getBeanOwnerExpression()));
        } else {
            // $NON-NLS-1$
            logger.log(Type.WARN, "Skipping non-model field for path " + editorData.getPath());
        }
    }
    for (JField field : editorType.getFields()) {
        if (field.getType().isClassOrInterface() != null && field.getType().isClassOrInterface().isAssignableTo(hasCleanupType) && !field.getType().isClassOrInterface().isAssignableTo(baseModelType)) {
            // $NON-NLS-1$
            fieldSet.add(String.format("getEditor().%s", field.getName()));
            if (!field.isPublic()) {
                logger.log(Type.ERROR, // $NON-NLS-1$
                "Field " + field.getName() + // $NON-NLS-1$
                " is not public, but needs to be cleaned up");
            }
        }
    }
    for (String name : fieldSet) {
        // $NON-NLS-1$
        sw.println("%s.cleanup();", name);
    }
    sw.outdent();
    // $NON-NLS-1$
    sw.println("}");
}
#method_after
private void writeCleanup() {
    JClassType editorType = model.getEditorType();
    logger.log(Type.DEBUG, // $NON-NLS-1$
    "Starting to write cleanup impl. for editor " + editorType.getQualifiedSourceName());
    sw.println();
    // $NON-NLS-1$
    sw.println("@Override");
    // $NON-NLS-1$
    sw.println("public void cleanup() {");
    sw.indent();
    // $NON-NLS-1$
    sw.println("if (getObject() != null) {");
    sw.indent();
    if (model.getProxyType().isAssignableTo(hasCleanupType)) {
        // $NON-NLS-1$
        sw.println("getObject().cleanup();");
    }
    for (EditorData editorData : model.getEditorData()) {
        if (editorData.getPropertyOwnerType().isAssignableTo(hasCleanupType)) {
            sw.println(// $NON-NLS-1$
            String.format(// $NON-NLS-1$
            "getObject()%s.cleanup();", editorData.getBeanOwnerExpression()));
        }
    }
    sw.outdent();
    // $NON-NLS-1$
    sw.println("}");
    for (JField field : editorType.getFields()) {
        JClassType fieldClassType = field.getType().isClassOrInterface();
        if (fieldClassType != null && fieldClassType.isAssignableTo(hasCleanupType) && !field.getType().isClassOrInterface().isAssignableTo(baseModelType)) {
            sw.println(// $NON-NLS-1$
            String.format(// $NON-NLS-1$
            "getEditor().%s.cleanup();", field.getName()));
        }
    }
    sw.outdent();
    // $NON-NLS-1$
    sw.println("}");
}
#end_block

#method_before
@Override
public void cleanup() {
    getSelectedItemChangedEvent().clearListeners();
    getSelectedItemsChangedEvent().clearListeners();
    getItemsChangedEvent().clearListeners();
    if (getItems() != null) {
        for (T item : getItems()) {
            if (item instanceof Model) {
                ((Model) item).cleanup();
            }
        }
    }
    super.cleanup();
}
#method_after
@Override
public void cleanup() {
    cleanupEvents(getSelectedItemChangedEvent(), getSelectedItemsChangedEvent(), getItemsChangedEvent());
    if (getItems() != null) {
        for (T item : getItems()) {
            if (item instanceof HasCleanup) {
                ((HasCleanup) item).cleanup();
            }
        }
    }
    super.cleanup();
}
#end_block

#method_before
@Override
public void cleanup() {
    if (getRefreshPolicyUnitsEvent() != null) {
        getRefreshPolicyUnitsEvent().clearListeners();
    }
    super.cleanup();
}
#method_after
@Override
public void cleanup() {
    cleanupEvents(getRefreshPolicyUnitsEvent());
    super.cleanup();
}
#end_block

#method_before
@Override
public void cleanup() {
    if (getSelectionChangedEvent() != null) {
        getSelectionChangedEvent().clearListeners();
    }
    super.cleanup();
}
#method_after
@Override
public void cleanup() {
    cleanupEvents(getSelectionChangedEvent());
    super.cleanup();
}
#end_block

#method_before
@Override
public void cleanup() {
    disksAllocationView.cleanup();
    driver.cleanup();
}
#method_after
@Override
public void cleanup() {
    driver.cleanup();
}
#end_block

#method_before
@Override
public void cleanup() {
// TODO cleanup something?
}
#method_after
@Override
public void cleanup() {
// TODO clean up stuff if needed
}
#end_block

#method_before
@Override
public void cleanup() {
    subnetWidget.cleanup();
    driver.cleanup();
}
#method_after
@Override
public void cleanup() {
    driver.cleanup();
}
#end_block

#method_before
@Override
public void cleanup() {
// TODO cleanup the table?
}
#method_after
@Override
public void cleanup() {
// TODO clean up stuff if needed
}
#end_block

#method_before
@Override
public void cleanup() {
    getLoggedInEvent().clearListeners();
    super.cleanup();
}
#method_after
@Override
public void cleanup() {
    cleanupEvents(getLoggedInEvent());
    super.cleanup();
}
#end_block

#method_before
@Override
public void cleanup() {
    networkProviderWidget.cleanup();
    fenceAgentsEditor.cleanup();
    proxySourceEditor.cleanup();
    driver.cleanup();
}
#method_after
@Override
public void cleanup() {
    driver.cleanup();
}
#end_block

#method_before
@Override
public void cleanup() {
    driver.cleanup();
    vmDiskPopupWidget.cleanup();
}
#method_after
@Override
public void cleanup() {
    driver.cleanup();
}
#end_block

#method_before
protected void init(M model) {
    items.clear();
    cleanContentPanel();
    if (modelItems != null) {
        for (T item : modelItems) {
            if (item instanceof HasCleanup) {
                ((HasCleanup) item).cleanup();
            }
        }
    }
    modelItems = model.getItems();
    if (modelItems == null) {
        modelItems = new LinkedList<>();
        // this will invoke init() again with the empty list as values instead of null
        model.setItems(modelItems);
        return;
    }
    if (modelItems.isEmpty() && showGhost) {
        T ghostValue = addGhostEntry().getFirst();
        modelItems.add(ghostValue);
    } else {
        Iterator<T> i = modelItems.iterator();
        while (i.hasNext()) {
            T value = i.next();
            addEntry(value, !i.hasNext());
        }
    }
}
#method_after
protected void init(M model) {
    items.clear();
    cleanContentPanel();
    cleanupModelItems();
    modelItems = model.getItems();
    if (modelItems == null) {
        modelItems = new LinkedList<>();
        // this will invoke init() again with the empty list as values instead of null
        model.setItems(modelItems);
        return;
    }
    if (modelItems.isEmpty() && showGhost) {
        T ghostValue = addGhostEntry().getFirst();
        modelItems.add(ghostValue);
    } else {
        Iterator<T> i = modelItems.iterator();
        while (i.hasNext()) {
            T value = i.next();
            addEntry(value, !i.hasNext());
        }
    }
}
#end_block

#method_before
@Override
public void cleanup() {
    if (model != null) {
        model.cleanup();
        model = null;
    }
    if (modelItems != null) {
        for (T model : modelItems) {
            if (model instanceof HasCleanup) {
                ((HasCleanup) model).cleanup();
            }
        }
    }
    for (Pair<T, V> item : items) {
        T value = item.getFirst();
        if (!isGhost(value)) {
            if (item instanceof HasCleanup) {
                ((HasCleanup) value).cleanup();
            }
        }
    }
    cleanContentPanel();
}
#method_after
@Override
public void cleanup() {
    if (model != null) {
        model.cleanup();
        model = null;
    }
    cleanupModelItems();
    cleanupNonGhostItems();
    cleanContentPanel();
}
#end_block

#method_before
@Override
public void cleanup() {
    macRanges.cleanup();
    driver.cleanup();
}
#method_after
@Override
public void cleanup() {
    driver.cleanup();
}
#end_block

#method_before
@Override
public void cleanup() {
// TODO cleanup table?
}
#method_after
@Override
public void cleanup() {
// TODO clean up stuff if needed
}
#end_block

#method_before
@Override
public void cleanup() {
    labelsWidget.cleanup();
    driver.cleanup();
}
#method_after
@Override
public void cleanup() {
    driver.cleanup();
}
#end_block

#method_before
@Override
public void cleanup() {
    if (getErrorEvent() != null) {
        getErrorEvent().clearListeners();
    }
    super.cleanup();
}
#method_after
@Override
public void cleanup() {
    cleanupEvents(getErrorEvent());
    super.cleanup();
}
#end_block

#method_before
@Override
public void cleanup() {
    if (getNicsChangedEvent() != null) {
        getNicsChangedEvent().clearListeners();
    }
    if (getOperationCandidateEvent() != null) {
        getOperationCandidateEvent().clearListeners();
    }
    super.cleanup();
}
#method_after
@Override
public void cleanup() {
    cleanupEvents(getNicsChangedEvent(), getOperationCandidateEvent());
    super.cleanup();
}
#end_block

#method_before
@Override
public void cleanup() {
// TODO cleanup stuff.
}
#method_after
@Override
public void cleanup() {
// TODO clean up stuff if needed
}
#end_block

#method_before
private void updateProperties() {
    VM vm = getEntity();
    super.updateProperties(vm.getId());
    setName(vm.getName());
    setDescription(vm.getVmDescription());
    // $NON-NLS-1$
    setQuotaName(vm.getQuotaName() != null ? vm.getQuotaName() : "");
    setQuotaAvailable(vm.getQuotaEnforcementType() != null && !vm.getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED));
    setTemplate(vmTemplateNameRenderer.render(vm));
    // $NON-NLS-1$
    setDefinedMemory(vm.getVmMemSizeMb() + " MB");
    // $NON-NLS-1$
    setMinAllocatedMemory(vm.getMinAllocatedMem() + " MB");
    if (vm.isRunningOrPaused() && vm.getGuestMemoryBuffered() != null && vm.getGuestMemoryCached() != null && vm.getGuestMemoryFree() != null) {
        setGuestFreeCachedBufferedMemInfo(// $NON-NLS-1$
        (vm.getGuestMemoryFree() / 1024L) + " / " + (vm.getGuestMemoryBuffered() / 1024L) + // $NON-NLS-1$
        " / " + (vm.getGuestMemoryCached() / 1024L) + // $NON-NLS-1$
        " MB");
    } else {
        // Handled in form
        setGuestFreeCachedBufferedMemInfo(null);
    }
    setOS(AsyncDataProvider.getInstance().getOsName(vm.getVmOsId()));
    EnumTranslator translator = EnumTranslator.getInstance();
    setDefaultDisplayType(translator.translate(vm.getDefaultDisplayType()));
    setOrigin(translator.translate(vm.getOrigin()));
    setIsHighlyAvailable(vm.isAutoStartup());
    setPriority(AsyncDataProvider.getInstance().priorityToString(vm.getPriority()));
    setMonitorCount(vm.getNumOfMonitors());
    setUsbPolicy(translator.translate(vm.getUsbPolicy()));
    setCpuInfo(ConstantsManager.getInstance().getMessages().cpuInfoLabel(vm.getNumOfCpus(), vm.getNumOfSockets(), vm.getCpuPerSocket(), vm.getThreadsPerCpu()));
    setGuestCpuCount(vm.getGuestCpuCount());
    setHasDomain(AsyncDataProvider.getInstance().isWindowsOsType(vm.getVmOsId()));
    if (vm.getVmInit() != null) {
        setDomain(vm.getVmInit().getDomain());
    }
    setHasTimeZone(!StringHelper.isNullOrEmpty(vm.getTimeZone()));
    setTimeZone(vm.getTimeZone());
    setHasCustomProperties(!StringHelper.isNullOrEmpty(vm.getCustomProperties()));
    setCustomProperties(getHasCustomProperties() ? constants.configured() : constants.notConfigured());
    setCompatibilityVersion(vm.getCompatibilityVersion() != null ? vm.getCompatibilityVersion().toString() : // $NON-NLS-1$
    "");
    setVmId(vm.getId().toString());
    setFqdn(vm.getVmFQDN());
    setHasAlert(vm.getVmPauseStatus() != VmPauseStatus.NONE && vm.getVmPauseStatus() != VmPauseStatus.NOERR);
    if (getHasAlert()) {
        setAlert(translator.translate(vm.getVmPauseStatus()));
    } else {
        setAlert(null);
    }
    setHasCreatedByUser(vm.getCreatedByUserId() != null);
    if (getHasCreatedByUser()) {
        Frontend.getInstance().runQuery(VdcQueryType.GetDbUserByUserId, new IdQueryParameters(vm.getCreatedByUserId()), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

            @Override
            public void onSuccess(VdcQueryReturnValue result) {
                DbUser dbUser = result.getReturnValue();
                if (dbUser != null) {
                    setCreatedByUser(getUserName(dbUser));
                }
            }

            private String getUserName(DbUser dbUser) {
                if (StringUtils.isNotEmpty(dbUser.getFirstName()) || StringUtils.isNotEmpty(dbUser.getLastName())) {
                    return messages.userName(nullToEmpty(dbUser.getFirstName()), nullToEmpty(dbUser.getLastName()));
                }
                return dbUser.getLoginName();
            }

            private String nullToEmpty(String val) {
                return val == null ? "" : val;
            }
        }));
    }
    setHasDefaultHost(vm.getDedicatedVmForVdsList().size() > 0);
    if (getHasDefaultHost()) {
        Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(// $NON-NLS-1$
        "Host: cluster = " + vm.getClusterName() + " sortby name", SearchType.VDS).withoutRefresh(), new // $NON-NLS-1$
        AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

            @Override
            public void onSuccess(VdcQueryReturnValue returnValue) {
                VM localVm = getEntity();
                if (localVm == null) {
                    return;
                }
                ArrayList<VDS> hosts = returnValue.getReturnValue();
                if (localVm.getDedicatedVmForVdsList().size() > 0) {
                    String defaultHost = "";
                    for (VDS host : hosts) {
                        if (localVm.getDedicatedVmForVdsList().contains(host.getId())) {
                            if (defaultHost.isEmpty()) {
                                defaultHost = host.getName();
                            } else {
                                // $NON-NLS-1$
                                defaultHost += ", " + host.getName();
                            }
                        }
                    }
                    setDefaultHost(defaultHost);
                }
            }
        }));
    } else {
        setDefaultHost(ConstantsManager.getInstance().getConstants().anyHostInCluster());
    }
}
#method_after
private void updateProperties() {
    VM vm = getEntity();
    super.updateProperties(vm.getId());
    setName(vm.getName());
    setDescription(vm.getVmDescription());
    // $NON-NLS-1$
    setQuotaName(vm.getQuotaName() != null ? vm.getQuotaName() : "");
    setQuotaAvailable(vm.getQuotaEnforcementType() != null && !vm.getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED));
    setTemplate(vmTemplateNameRenderer.render(vm));
    // $NON-NLS-1$
    setDefinedMemory(vm.getVmMemSizeMb() + " MB");
    // $NON-NLS-1$
    setMinAllocatedMemory(vm.getMinAllocatedMem() + " MB");
    if (vm.isRunningOrPaused() && vm.getGuestMemoryBuffered() != null && vm.getGuestMemoryCached() != null && vm.getGuestMemoryFree() != null) {
        setGuestFreeCachedBufferedMemInfo(// $NON-NLS-1$
        (vm.getGuestMemoryFree() / 1024L) + " / " + (vm.getGuestMemoryBuffered() / 1024L) + // $NON-NLS-1$
        " / " + (vm.getGuestMemoryCached() / 1024L) + // $NON-NLS-1$
        " MB");
    } else {
        // Handled in form
        setGuestFreeCachedBufferedMemInfo(null);
    }
    setOS(AsyncDataProvider.getInstance().getOsName(vm.getVmOsId()));
    EnumTranslator translator = EnumTranslator.getInstance();
    setDefaultDisplayType(translator.translate(vm.getDefaultDisplayType()));
    setOrigin(translator.translate(vm.getOrigin()));
    setIsHighlyAvailable(vm.isAutoStartup());
    setPriority(AsyncDataProvider.getInstance().priorityToString(vm.getPriority()));
    setMonitorCount(vm.getNumOfMonitors());
    setUsbPolicy(translator.translate(vm.getUsbPolicy()));
    setCpuInfo(ConstantsManager.getInstance().getMessages().cpuInfoLabel(vm.getNumOfCpus(), vm.getNumOfSockets(), vm.getCpuPerSocket(), vm.getThreadsPerCpu()));
    setGuestCpuCount(vm.getGuestCpuCount());
    setHasDomain(AsyncDataProvider.getInstance().isWindowsOsType(vm.getVmOsId()));
    if (vm.getVmInit() != null) {
        setDomain(vm.getVmInit().getDomain());
    }
    setHasTimeZone(!StringHelper.isNullOrEmpty(vm.getTimeZone()));
    setTimeZone(vm.getTimeZone());
    setHasCustomProperties(!StringHelper.isNullOrEmpty(vm.getCustomProperties()));
    setCustomProperties(getHasCustomProperties() ? constants.configured() : constants.notConfigured());
    setCompatibilityVersion(vm.getCompatibilityVersion() != null ? vm.getCompatibilityVersion().toString() : // $NON-NLS-1$
    "");
    setVmId(vm.getId().toString());
    setFqdn(vm.getFqdn());
    setHasAlert(vm.getVmPauseStatus() != VmPauseStatus.NONE && vm.getVmPauseStatus() != VmPauseStatus.NOERR);
    if (getHasAlert()) {
        setAlert(translator.translate(vm.getVmPauseStatus()));
    } else {
        setAlert(null);
    }
    setHasCreatedByUser(vm.getCreatedByUserId() != null);
    if (getHasCreatedByUser()) {
        Frontend.getInstance().runQuery(VdcQueryType.GetDbUserByUserId, new IdQueryParameters(vm.getCreatedByUserId()), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

            @Override
            public void onSuccess(VdcQueryReturnValue result) {
                DbUser dbUser = result.getReturnValue();
                if (dbUser != null) {
                    setCreatedByUser(getUserName(dbUser));
                }
            }

            private String getUserName(DbUser dbUser) {
                if (StringUtils.isNotEmpty(dbUser.getFirstName()) || StringUtils.isNotEmpty(dbUser.getLastName())) {
                    return messages.userName(nullToEmpty(dbUser.getFirstName()), nullToEmpty(dbUser.getLastName()));
                }
                return dbUser.getLoginName();
            }

            private String nullToEmpty(String val) {
                return val == null ? "" : val;
            }
        }));
    }
    setHasDefaultHost(vm.getDedicatedVmForVdsList().size() > 0);
    if (getHasDefaultHost()) {
        Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(// $NON-NLS-1$
        "Host: cluster = " + vm.getClusterName() + " sortby name", SearchType.VDS).withoutRefresh(), new // $NON-NLS-1$
        AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

            @Override
            public void onSuccess(VdcQueryReturnValue returnValue) {
                VM localVm = getEntity();
                if (localVm == null) {
                    return;
                }
                ArrayList<VDS> hosts = returnValue.getReturnValue();
                if (localVm.getDedicatedVmForVdsList().size() > 0) {
                    String defaultHost = "";
                    for (VDS host : hosts) {
                        if (localVm.getDedicatedVmForVdsList().contains(host.getId())) {
                            if (defaultHost.isEmpty()) {
                                defaultHost = host.getName();
                            } else {
                                // $NON-NLS-1$
                                defaultHost += ", " + host.getName();
                            }
                        }
                    }
                    setDefaultHost(defaultHost);
                }
            }
        }));
    } else {
        setDefaultHost(ConstantsManager.getInstance().getConstants().anyHostInCluster());
    }
}
#end_block

#method_before
@Override
public void cleanup() {
    if (getUpdateCompleteEvent() != null) {
        getUpdateCompleteEvent().clearListeners();
    }
    super.cleanup();
}
#method_after
@Override
public void cleanup() {
    cleanupEvents(getUpdateCompleteEvent());
    super.cleanup();
}
#end_block

#method_before
@Override
public void cleanup() {
    if (getPathChangedEvent() != null) {
        getPathChangedEvent().clearListeners();
    }
    super.cleanup();
}
#method_after
@Override
public void cleanup() {
    cleanupEvents(getPathChangedEvent());
    super.cleanup();
}
#end_block

#method_before
@Override
public void cleanup() {
    neutronAgentWidget.cleanup();
    driver.cleanup();
}
#method_after
@Override
public void cleanup() {
    driver.cleanup();
}
#end_block

#method_before
@Override
public void cleanup() {
    dnsServersEditor.cleanup();
    driver.cleanup();
}
#method_after
@Override
public void cleanup() {
    driver.cleanup();
}
#end_block

#method_before
@Override
public void cleanup() {
    if (getUpdateCompleteEvent() != null) {
        getUpdateCompleteEvent().clearListeners();
    }
    super.cleanup();
}
#method_after
@Override
public void cleanup() {
    cleanupEvents(getUpdateCompleteEvent());
    super.cleanup();
}
#end_block

#method_before
@Override
public void cleanup() {
    neutronAgentWidget.cleanup();
    vmwarePropertiesWidget.cleanup();
    kvmPropertiesWidget.cleanup();
    xenPropertiesWidget.cleanup();
    driver.cleanup();
}
#method_after
@Override
public void cleanup() {
    driver.cleanup();
}
#end_block

#method_before
@Override
public void cleanup() {
    if (hasEventBusSet()) {
        unsetEventBus();
    }
    if (getPropertyChangedEvent() != null) {
        getPropertyChangedEvent().clearListeners();
    }
    for (UICommand command : getCommands()) {
        command.cleanup();
    }
    invalidTabs.clear();
// propertyChangedEvent = null;
}
#method_after
@Override
public void cleanup() {
    if (hasEventBusSet()) {
        unsetEventBus();
    }
    cleanupEvents(getPropertyChangedEvent());
    for (UICommand command : getCommands()) {
        command.cleanup();
    }
    invalidTabs.clear();
}
#end_block

#method_before
@Override
public void cleanup() {
// TODO cleanup table?
}
#method_after
@Override
public void cleanup() {
// TODO clean up stuff if needed
}
#end_block

#method_before
@Override
public void cleanup() {
    if (getFiltersChangedEvent() != null) {
        getFiltersChangedEvent().clearListeners();
    }
    if (getFunctionsChangedEvent() != null) {
        getFunctionsChangedEvent().clearListeners();
    }
    super.cleanup();
}
#method_after
@Override
public void cleanup() {
    cleanupEvents(getFiltersChangedEvent(), getFunctionsChangedEvent());
    super.cleanup();
}
#end_block

#method_before
@Override
public void cleanup() {
    qosWidget.cleanup();
    driver.cleanup();
}
#method_after
@Override
public void cleanup() {
    driver.cleanup();
}
#end_block

#method_before
@Override
public void cleanup() {
// TODO, should this clean up something?
}
#method_after
@Override
public void cleanup() {
// TODO clean up stuff if needed
}
#end_block

#method_before
@Override
public boolean render(ConsoleModel value) {
    if (value instanceof SpiceConsoleModel) {
        return extractBoolean(((SpiceConsoleModel) value).getspice());
    }
    return false;
}
#method_after
@Override
public boolean render(ConsoleModel value) {
    if (value instanceof SpiceConsoleModel) {
        return extractBoolean(((SpiceConsoleModel) value).getSpiceImpl());
    }
    return false;
}
#end_block

#method_before
@Override
public ConsoleModel read(boolean value, ConsoleModel model) {
    if (model instanceof SpiceConsoleModel) {
        updateModel(((SpiceConsoleModel) model).getspice(), value);
    }
    return model;
}
#method_after
@Override
public ConsoleModel read(boolean value, ConsoleModel model) {
    if (model instanceof SpiceConsoleModel) {
        updateModel(((SpiceConsoleModel) model).getSpiceImpl(), value);
    }
    return model;
}
#end_block

#method_before
@Override
public void cleanup() {
// TODO, clean up stuff?
}
#method_after
@Override
public void cleanup() {
// TODO clean up stuff if needed
}
#end_block

#method_before
@Override
public void cleanup() {
// TODO: cleanup table?
}
#method_after
@Override
public void cleanup() {
// TODO clean up stuff if needed
}
#end_block

#method_before
@Override
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    log.debug("Entered SsoLoginServlet");
    String scope = String.format("ovirt-app-admin ovirt-app-portal ovirt-ext=auth:sequence-priority=%s", EngineLocalConfig.getInstance().getProperty(authSequencePriorityPropertyName));
    String redirectUri = String.format("%s://%s:%s%s", request.getScheme(), FiltersHelper.getRedirectUriServerName(request.getServerName()), request.getServerPort(), postActionUrl);
    String url = new URLBuilder(FiltersHelper.getEngineSsoUrl(request), "/oauth/authorize").addParameter("client_id", EngineLocalConfig.getInstance().getProperty("ENGINE_SSO_CLIENT_ID")).addParameter("response_type", "code").addParameter("app_url", request.getParameter("app_url")).addParameter("engine_url", FiltersHelper.getEngineUrl(request)).addParameter("redirect_uri", redirectUri).addParameter("scope", scope).build();
    log.debug("Redirecting to url: {}", url);
    response.sendRedirect(url);
}
#method_after
@Override
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    log.debug("Entered SsoLoginServlet");
    String scope = String.format("ovirt-app-admin ovirt-app-portal ovirt-ext=auth:sequence-priority=%s", EngineLocalConfig.getInstance().getProperty(authSequencePriorityPropertyName));
    String redirectUri = String.format("%s://%s:%s%s", request.getScheme(), FiltersHelper.getRedirectUriServerName(request.getServerName()), request.getServerPort(), postActionUrl);
    String url = new URLBuilder(FiltersHelper.getEngineSsoUrl(request), "/oauth/authorize").addParameter("client_id", EngineLocalConfig.getInstance().getProperty("ENGINE_SSO_CLIENT_ID")).addParameter("response_type", "code").addParameter("app_url", request.getParameter("app_url")).addParameter("engine_url", FiltersHelper.getEngineUrl(request)).addParameter("redirect_uri", redirectUri).addParameter("scope", scope).build();
    log.debug("Redirecting to '{}'", url);
    response.sendRedirect(url);
}
#end_block

#method_before
@Override
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    log.debug("Entered SsoPostLoginServlet");
    String username = null;
    String profile = null;
    InitialContext ctx = null;
    try {
        String error = request.getParameter("error");
        String error_code = request.getParameter("error_code");
        if (StringUtils.isNotEmpty(error) && StringUtils.isNotEmpty(error_code)) {
            throw new RuntimeException(String.format("%s: %s", error_code, error));
        }
        String code = request.getParameter("code");
        if (StringUtils.isEmpty(code)) {
            throw new RuntimeException("No authorization code found in request");
        }
        String appUrl = request.getParameter("app_url");
        log.debug("Received app_url: {}", appUrl);
        Map<String, Object> jsonResponse = FiltersHelper.getPayloadForAuthCode(code, "ovirt-app-admin ovirt-app-portal ovirt-app-api", URLEncoder.encode(postActionUrl, "UTF-8"));
        Map<String, Object> payload = (Map<String, Object>) jsonResponse.get("ovirt");
        username = (String) jsonResponse.get("user_id");
        profile = "";
        int index = username.lastIndexOf("@");
        if (index != -1) {
            profile = username.substring(index + 1);
            username = username.substring(0, index);
        }
        try {
            ctx = new InitialContext();
            VdcReturnValueBase queryRetVal = FiltersHelper.getBackend(ctx).runAction(VdcActionType.CreateUserSession, new CreateUserSessionParameters((String) jsonResponse.get(SessionConstants.SSO_TOKEN_KEY), profile, username, (String) payload.get("principal_id"), (String) payload.get("email"), request.getRemoteAddr(), (Collection<ExtMap>) payload.get("group_ids"), loginAsAdmin));
            if (!queryRetVal.getSucceeded()) {
                throw new RuntimeException(String.format("The user %s@%s is not authorized to perform login", username, profile));
            } else {
                HttpSession httpSession = request.getSession(true);
                httpSession.setAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY, queryRetVal.getActionReturnValue());
                httpSession.setAttribute(FiltersHelper.Constants.REQUEST_LOGIN_FILTER_AUTHENTICATION_DONE, true);
                log.debug("Redirecting to app_url: {}", appUrl);
                response.sendRedirect(appUrl);
            }
        } catch (RuntimeException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new RuntimeException(String.format("User login failure: %s", username), ex);
        } finally {
            try {
                if (ctx != null) {
                    ctx.close();
                }
            } catch (NamingException ex) {
                log.error("Unable to close context", ex);
            }
        }
    } catch (Exception ex) {
        log.error(ex.getMessage());
        log.debug("User login failure", ex);
        String url = String.format("%s://%s:%s%s/", request.getScheme(), FiltersHelper.getRedirectUriServerName(request.getServerName()), request.getServerPort(), EngineLocalConfig.getInstance().getProperty("ENGINE_URI"));
        response.sendRedirect(new URLBuilder(url).addParameter("error", StringUtils.defaultIfEmpty(ex.getMessage(), "Internal Server error")).addParameter("error_code", "server_error").build());
    }
}
#method_after
@Override
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    log.debug("Entered SsoPostLoginServlet");
    String username = null;
    String profile = null;
    InitialContext ctx = null;
    try {
        String error = request.getParameter("error");
        String error_code = request.getParameter("error_code");
        if (StringUtils.isNotEmpty(error) && StringUtils.isNotEmpty(error_code)) {
            throw new RuntimeException(String.format("%s: %s", error_code, error));
        }
        String code = request.getParameter("code");
        if (StringUtils.isEmpty(code)) {
            throw new RuntimeException("No authorization code found in request");
        }
        String appUrl = request.getParameter("app_url");
        log.debug("Received app_url '{}'", appUrl);
        Map<String, Object> jsonResponse = FiltersHelper.getPayloadForAuthCode(code, "ovirt-app-admin ovirt-app-portal ovirt-app-api", URLEncoder.encode(postActionUrl, "UTF-8"));
        Map<String, Object> payload = (Map<String, Object>) jsonResponse.get("ovirt");
        username = (String) jsonResponse.get("user_id");
        profile = "";
        int index = username.lastIndexOf("@");
        if (index != -1) {
            profile = username.substring(index + 1);
            username = username.substring(0, index);
        }
        try {
            ctx = new InitialContext();
            VdcReturnValueBase queryRetVal = FiltersHelper.getBackend(ctx).runAction(VdcActionType.CreateUserSession, new CreateUserSessionParameters((String) jsonResponse.get(SessionConstants.SSO_TOKEN_KEY), profile, username, (String) payload.get("principal_id"), (String) payload.get("email"), request.getRemoteAddr(), (Collection<ExtMap>) payload.get("group_ids"), loginAsAdmin));
            if (!queryRetVal.getSucceeded()) {
                throw new RuntimeException(String.format("The user %s@%s is not authorized to perform login", username, profile));
            } else {
                HttpSession httpSession = request.getSession(true);
                httpSession.setAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY, queryRetVal.getActionReturnValue());
                httpSession.setAttribute(FiltersHelper.Constants.REQUEST_LOGIN_FILTER_AUTHENTICATION_DONE, true);
                log.debug("Redirecting to '{}'", appUrl);
                response.sendRedirect(appUrl);
            }
        } catch (RuntimeException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new RuntimeException(String.format("User login failure: %s", username), ex);
        } finally {
            try {
                if (ctx != null) {
                    ctx.close();
                }
            } catch (NamingException ex) {
                log.error("Unable to close context", ex);
            }
        }
    } catch (Exception ex) {
        log.error(ex.getMessage());
        log.debug("User login failure", ex);
        String url = String.format("%s://%s:%s%s/", request.getScheme(), FiltersHelper.getRedirectUriServerName(request.getServerName()), request.getServerPort(), EngineLocalConfig.getInstance().getProperty("ENGINE_URI"));
        response.sendRedirect(new URLBuilder(url).addParameter("error", StringUtils.defaultIfEmpty(ex.getMessage(), "Internal Server error")).addParameter("error_code", "server_error").build());
    }
}
#end_block

#method_before
public Map getVdsCapabilities() {
    final Host host = getActiveHost();
    try {
        Map resultMap = getDoneStatus();
        Map infoMap = map();
        infoMap.put("HBAInventory", getHBAInventoryMap());
        infoMap.put("autoNumaBalancing", "1");
        infoMap.put("packages2", getPackages2Map());
        AppConfig.ArchitectureType architecture = AppConfig.getInstance().getArchitectureType();
        infoMap.put("cpuModel", architecture.getCpuModel());
        infoMap.put("cpuFlags", architecture.getCpuFlags());
        infoMap.put("hooks", map());
        infoMap.put("cpuSockets", "1");
        infoMap.put("vmTypes", getVmTypesList());
        infoMap.put("supportedProtocols", getSupportedProtocolsList());
        infoMap.put("networks", getNetworksMap(host));
        infoMap.put("bridges", getBridgesMap(host));
        // 018CE76D-8EFE-D511-B30D-80C16E727330_80:c1:6e:6c:51:54
        infoMap.put("uuid", host.getUuid() + "_80:" + host.getMacAddress());
        infoMap.put("lastClientIface", AppConfig.getInstance().getNetworkBridgeName());
        infoMap.put("nics", getNicsMap(host));
        infoMap.put("numaNodeDistance", getNumaNodeDistanceMap());
        infoMap.put("numaNodes", getNumaNodesMap());
        infoMap.put("onlineCpus", getOnlineCpusList());
        infoMap.put("software_revision", "0.141");
        infoMap.put("clusterLevels", getClusterLevelsList());
        infoMap.put("ISCSIInitiatorName", "iqn.1994-05.com.example:ef52ec17bb0");
        infoMap.put("netConfigDirty", "False");
        infoMap.put("supportedENGINEs", getSupportedENGINEsList());
        infoMap.put("reservedMem", "321");
        infoMap.put("bondings", getBondingsMap());
        infoMap.put("software_version", "4.10");
        infoMap.put("memSize", "7976");
        infoMap.put("cpuSpeed", "1200.000");
        infoMap.put("version_name", "Snow Man");
        infoMap.put("vlans", map());
        infoMap.put("cpuCores", "4");
        infoMap.put("kvmEnabled", "true");
        infoMap.put("guestOverhead", "65");
        // null
        infoMap.put("management_ip", "");
        infoMap.put("cpuThreads", "4");
        infoMap.put("emulatedMachines", getEmulatedMachinesList());
        infoMap.put("operatingSystem", getOperatingSystemMap());
        infoMap.put("lastClient", "10.36.6.76");
        infoMap.put("rngSources", Arrays.asList(new String[] { "RANDOM" }));
        infoMap.put("selinux", getSELinux());
        infoMap.put("kdumpStatus", "1");
        resultMap.put("info", infoMap);
        return resultMap;
    } catch (Exception e) {
        throw error(e);
    }
}
#method_after
public Map getVdsCapabilities() {
    final Host host = getActiveHost();
    try {
        Map resultMap = getDoneStatus();
        Map infoMap = map();
        infoMap.put("HBAInventory", getHBAInventoryMap());
        infoMap.put("autoNumaBalancing", "1");
        infoMap.put("packages2", getPackages2Map());
        AppConfig.ArchitectureType architecture = AppConfig.getInstance().getArchitectureType();
        infoMap.put("cpuModel", architecture.getCpuModel());
        infoMap.put("cpuFlags", architecture.getCpuFlags());
        infoMap.put("hooks", map());
        infoMap.put("cpuSockets", "1");
        infoMap.put("vmTypes", getVmTypesList());
        infoMap.put("supportedProtocols", getSupportedProtocolsList());
        infoMap.put("networks", getNetworksMap(host));
        infoMap.put("bridges", getBridgesMap(host));
        // 018CE76D-8EFE-D511-B30D-80C16E727330_80:c1:6e:6c:51:54
        infoMap.put("uuid", host.getUuid() + "_80:" + host.getMacAddress());
        infoMap.put("lastClientIface", AppConfig.getInstance().getNetworkBridgeName());
        infoMap.put("nics", getNicsMap(host));
        infoMap.put("numaNodeDistance", getNumaNodeDistanceMap());
        infoMap.put("numaNodes", getNumaNodesMap());
        infoMap.put("onlineCpus", getOnlineCpusList());
        infoMap.put("software_revision", "0.141");
        infoMap.put("clusterLevels", getClusterLevelsList());
        infoMap.put("ISCSIInitiatorName", "iqn.1994-05.com.example:ef52ec17bb0");
        infoMap.put("netConfigDirty", "False");
        infoMap.put("supportedENGINEs", getSupportedENGINEsList());
        infoMap.put("reservedMem", "321");
        infoMap.put("bondings", getBondingsMap());
        infoMap.put("software_version", "4.10");
        infoMap.put("memSize", Integer.toString(TOTAL_MEMORY_SIZE));
        infoMap.put("cpuSpeed", "1200.000");
        infoMap.put("version_name", "Snow Man");
        infoMap.put("vlans", map());
        infoMap.put("cpuCores", "4");
        infoMap.put("kvmEnabled", "true");
        infoMap.put("guestOverhead", "65");
        // null
        infoMap.put("management_ip", "");
        infoMap.put("cpuThreads", "4");
        infoMap.put("emulatedMachines", getEmulatedMachinesList());
        infoMap.put("operatingSystem", getOperatingSystemMap());
        infoMap.put("lastClient", "10.36.6.76");
        infoMap.put("rngSources", Arrays.asList(new String[] { "RANDOM" }));
        infoMap.put("selinux", getSELinux());
        infoMap.put("kdumpStatus", "1");
        resultMap.put("info", infoMap);
        return resultMap;
    } catch (Exception e) {
        throw error(e);
    }
}
#end_block

#method_before
Map getNumaNodesMap() {
    Map numaNodesMap = map();
    // Node 0
    Map nodeZeroMap = map();
    List nodeZeroCpuList = lst();
    nodeZeroCpuList.add(Integer.valueOf(1));
    nodeZeroCpuList.add(Integer.valueOf(3));
    nodeZeroCpuList.add(Integer.valueOf(5));
    nodeZeroCpuList.add(Integer.valueOf(7));
    nodeZeroCpuList.add(Integer.valueOf(9));
    nodeZeroCpuList.add(Integer.valueOf(11));
    nodeZeroCpuList.add(Integer.valueOf(13));
    nodeZeroCpuList.add(Integer.valueOf(15));
    nodeZeroMap.put("cpus", nodeZeroCpuList);
    nodeZeroMap.put("totalMemory", Integer.valueOf(16373));
    numaNodesMap.put("0", nodeZeroMap);
    // Node 1
    Map nodeOneMap = map();
    List nodeOneCpuList = lst();
    nodeOneCpuList.add(Integer.valueOf(0));
    nodeOneCpuList.add(Integer.valueOf(2));
    nodeOneCpuList.add(Integer.valueOf(4));
    nodeOneCpuList.add(Integer.valueOf(6));
    nodeOneCpuList.add(Integer.valueOf(8));
    nodeOneCpuList.add(Integer.valueOf(10));
    nodeOneCpuList.add(Integer.valueOf(12));
    nodeOneCpuList.add(Integer.valueOf(14));
    nodeOneMap.put("cpus", nodeOneCpuList);
    nodeOneMap.put("totalMemory", Integer.valueOf(16383));
    numaNodesMap.put("1", nodeOneMap);
    return numaNodesMap;
}
#method_after
Map getNumaNodesMap() {
    Map numaNodesMap = map();
    int totalMemPerNode = TOTAL_MEMORY_SIZE / NUMBER_OF_NUMA_NODES;
    // Node 0
    Map nodeZeroMap = map();
    List nodeZeroCpuList = lst();
    nodeZeroCpuList.add(Integer.valueOf(1));
    nodeZeroCpuList.add(Integer.valueOf(3));
    nodeZeroCpuList.add(Integer.valueOf(5));
    nodeZeroCpuList.add(Integer.valueOf(7));
    nodeZeroCpuList.add(Integer.valueOf(9));
    nodeZeroCpuList.add(Integer.valueOf(11));
    nodeZeroCpuList.add(Integer.valueOf(13));
    nodeZeroCpuList.add(Integer.valueOf(15));
    nodeZeroMap.put("cpus", nodeZeroCpuList);
    nodeZeroMap.put("totalMemory", Integer.valueOf(totalMemPerNode));
    numaNodesMap.put("0", nodeZeroMap);
    // Node 1
    Map nodeOneMap = map();
    List nodeOneCpuList = lst();
    nodeOneCpuList.add(Integer.valueOf(0));
    nodeOneCpuList.add(Integer.valueOf(2));
    nodeOneCpuList.add(Integer.valueOf(4));
    nodeOneCpuList.add(Integer.valueOf(6));
    nodeOneCpuList.add(Integer.valueOf(8));
    nodeOneCpuList.add(Integer.valueOf(10));
    nodeOneCpuList.add(Integer.valueOf(12));
    nodeOneCpuList.add(Integer.valueOf(14));
    nodeOneMap.put("cpus", nodeOneCpuList);
    nodeOneMap.put("totalMemory", Integer.valueOf(totalMemPerNode));
    numaNodesMap.put("1", nodeOneMap);
    return numaNodesMap;
}
#end_block

#method_before
public Map getVdsStats() {
    AppConfig appConfig = AppConfig.getInstance();
    final Host host = getActiveHost();
    try {
        Map resultMap = getDoneStatus();
        Map infoMap = map();
        infoMap.put("memShared", Integer.valueOf(0));
        infoMap.put("thpState", "always");
        infoMap.put("netConfigDirty", "False");
        infoMap.put("rxRate", "0.00");
        int nTotal = 0;
        for (VM vm : getActiveHost().getRunningVMs().values()) {
            if (!vm.isForDelete()) {
                nTotal++;
            }
        }
        infoMap.put("vmCount", nTotal);
        infoMap.put("memUsed", Utils.rangeParsser(appConfig.getMemLoadValues()));
        infoMap.put("storageDomains", getStorageDomainsStatsMap());
        infoMap.put("network", getNetworkStatMap(host.getMacAddress()));
        infoMap.put("txDropped", "0");
        infoMap.put("cpuUser", Utils.rangeParsser(appConfig.getCpuLoadValues()));
        infoMap.put("ksmPages", Integer.valueOf(100));
        infoMap.put("elapsedTime", host.getElapsedTimeInSeconds() + "");
        infoMap.put("cpuLoad", Utils.rangeParsser(appConfig.getCpuLoadValues()));
        infoMap.put("cpuSys", Utils.rangeParsser(appConfig.getCpuLoadValues()));
        infoMap.put("diskStats", getDiskStatsMap());
        infoMap.put("memCommitted", Integer.valueOf(0));
        // boolean..0
        infoMap.put("ksmState", Boolean.FALSE);
        int nMigrating = 0;
        for (VM vm : host.getRunningVMs().values()) {
            if (vm.getStatus() == VM.VMStatus.MigratingFrom || vm.getStatus() == VM.VMStatus.MigratingTo) {
                nMigrating++;
            }
        }
        infoMap.put("vmMigrating", nMigrating);
        infoMap.put("ksmCpu", Integer.valueOf(0));
        infoMap.put("memAvailable", Integer.valueOf(6435));
        infoMap.put("txRate", "");
        infoMap.put("cpuUserVdsmd", "0.50");
        infoMap.put("momStatus", "active");
        // 28f88125-6e5e-4804-8c5d-b4620f80bc9c
        infoMap.put("generationID", host.getUuid("GENERATION_ID"));
        infoMap.put("rxDropped", "14965");
        infoMap.put("swapTotal", Integer.valueOf(20031));
        infoMap.put("swapFree", Integer.valueOf(20031));
        infoMap.put("statsAge", "0.43");
        // 2013-02-10T19:09:11 GMT
        infoMap.put("dateTime", host.getDateTimeGMT());
        infoMap.put("anonHugePages", "662");
        infoMap.put("cpuIdle", Utils.getCpuIdle(infoMap.get("cpuUser").toString()));
        int nActive = 0;
        for (VM vm : getActiveHost().getRunningVMs().values()) {
            if (vm.getStatus() == VM.VMStatus.Up) {
                nActive++;
            }
        }
        infoMap.put("vmActive", nActive);
        infoMap.put("cpuSysVdsmd", "0.25");
        infoMap.put("numaNodeMemFree", getNumaNodeMemFreeMap());
        resultMap.put("info", infoMap);
        Utils.getLatency();
        return resultMap;
    } catch (Exception e) {
        throw error(e);
    }
}
#method_after
public Map getVdsStats() {
    AppConfig appConfig = AppConfig.getInstance();
    final Host host = getActiveHost();
    try {
        Map resultMap = getDoneStatus();
        Map infoMap = map();
        infoMap.put("memShared", Integer.valueOf(0));
        infoMap.put("thpState", "always");
        infoMap.put("netConfigDirty", "False");
        infoMap.put("rxRate", "0.00");
        int nTotal = 0;
        for (VM vm : getActiveHost().getRunningVMs().values()) {
            if (!vm.isForDelete()) {
                nTotal++;
            }
        }
        infoMap.put("vmCount", nTotal);
        String memUsedPercent = Utils.rangeParsser(appConfig.getMemLoadValues());
        infoMap.put("memUsed", memUsedPercent);
        double memUsedInMB = TOTAL_MEMORY_SIZE - (Double.valueOf(memUsedPercent) / 100);
        int memFree = (int) (TOTAL_MEMORY_SIZE - memUsedInMB);
        infoMap.put("memFree", Integer.toString(memFree));
        infoMap.put("storageDomains", getStorageDomainsStatsMap());
        infoMap.put("network", getNetworkStatMap(host.getMacAddress()));
        infoMap.put("txDropped", "0");
        infoMap.put("cpuUser", Utils.rangeParsser(appConfig.getCpuLoadValues()));
        infoMap.put("ksmPages", Integer.valueOf(100));
        infoMap.put("elapsedTime", host.getElapsedTimeInSeconds() + "");
        infoMap.put("cpuLoad", Utils.rangeParsser(appConfig.getCpuLoadValues()));
        infoMap.put("cpuSys", Utils.rangeParsser(appConfig.getCpuLoadValues()));
        infoMap.put("diskStats", getDiskStatsMap());
        infoMap.put("memCommitted", Integer.valueOf(0));
        // boolean..0
        infoMap.put("ksmState", Boolean.FALSE);
        int nMigrating = 0;
        for (VM vm : host.getRunningVMs().values()) {
            if (vm.getStatus() == VM.VMStatus.MigratingFrom || vm.getStatus() == VM.VMStatus.MigratingTo) {
                nMigrating++;
            }
        }
        infoMap.put("vmMigrating", nMigrating);
        infoMap.put("ksmCpu", Integer.valueOf(0));
        infoMap.put("memAvailable", Integer.valueOf(6435));
        infoMap.put("txRate", "");
        infoMap.put("cpuUserVdsmd", "0.50");
        infoMap.put("momStatus", "active");
        // 28f88125-6e5e-4804-8c5d-b4620f80bc9c
        infoMap.put("generationID", host.getUuid("GENERATION_ID"));
        infoMap.put("rxDropped", "14965");
        infoMap.put("swapTotal", Integer.valueOf(20031));
        infoMap.put("swapFree", Integer.valueOf(20031));
        infoMap.put("statsAge", "0.43");
        // 2013-02-10T19:09:11 GMT
        infoMap.put("dateTime", host.getDateTimeGMT());
        infoMap.put("anonHugePages", "662");
        infoMap.put("cpuIdle", Utils.getCpuIdle(infoMap.get("cpuUser").toString()));
        int nActive = 0;
        for (VM vm : getActiveHost().getRunningVMs().values()) {
            if (vm.getStatus() == VM.VMStatus.Up) {
                nActive++;
            }
        }
        infoMap.put("vmActive", nActive);
        infoMap.put("cpuSysVdsmd", "0.25");
        infoMap.put("numaNodeMemFree", getNumaNodeMemFreeMap(memFree, memUsedPercent));
        resultMap.put("info", infoMap);
        Utils.getLatency();
        return resultMap;
    } catch (Exception e) {
        throw error(e);
    }
}
#end_block

#method_before
Map getNumaNodeMemFreeMap() {
    Map numaNodeMemFreeMap = map();
    // Node 0
    Map nodeZeroNumaFreeMemMap = map();
    nodeZeroNumaFreeMemMap.put("memFree", Integer.valueOf(13968));
    nodeZeroNumaFreeMemMap.put("memPercent", "15");
    numaNodeMemFreeMap.put("0", nodeZeroNumaFreeMemMap);
    // Node 1
    Map nodeOneNumaFreeMemMap = map();
    nodeOneNumaFreeMemMap.put("memFree", Integer.valueOf(14244));
    nodeOneNumaFreeMemMap.put("memPercent", "14");
    numaNodeMemFreeMap.put("1", nodeOneNumaFreeMemMap);
    return numaNodeMemFreeMap;
}
#method_after
Map getNumaNodeMemFreeMap(int memFree, String memUsed) {
    double memFreePerNode = ((double) memFree) / NUMBER_OF_NUMA_NODES;
    int nodeZeroMemFree = (int) Math.floor(memFreePerNode);
    int nodeOneMemFree = (int) Math.ceil(memFreePerNode);
    // Node 0
    Map nodeZeroNumaFreeMemMap = map();
    nodeZeroNumaFreeMemMap.put("memFree", Integer.valueOf(nodeZeroMemFree));
    nodeZeroNumaFreeMemMap.put("memPercent", memUsed);
    // Node 1
    Map nodeOneNumaFreeMemMap = map();
    nodeOneNumaFreeMemMap.put("memFree", Integer.valueOf(nodeOneMemFree));
    nodeOneNumaFreeMemMap.put("memPercent", memUsed);
    Map numaNodeMemFreeMap = map();
    numaNodeMemFreeMap.put("0", nodeZeroNumaFreeMemMap);
    numaNodeMemFreeMap.put("1", nodeOneNumaFreeMemMap);
    return numaNodeMemFreeMap;
}
#end_block

#method_before
private void cancelIncommingMigrations() {
    for (Guid hostId : vdssToMaintenance.keySet()) {
        for (VM vm : getVmDao().getAllMigratingToHost(hostId)) {
            if (vm.getStatus() == VMStatus.MigratingFrom) {
                log.info("Cancelling incoming migration of '{}' id '{}'", vm, vm.getId());
                runVdsCommand(VDSCommandType.CancelMigrate, new CancelMigrationVDSParameters(vm.getRunOnVds(), vm.getId(), true));
            }
        }
    }
}
#method_after
private void cancelIncommingMigrations() {
    for (Guid hostId : vdssToMaintenance.keySet()) {
        for (VmDynamic vm : getVmDynamicDao().getAllMigratingToHost(hostId)) {
            if (vm.getStatus() == VMStatus.MigratingFrom) {
                log.info("Cancelling incoming migration of '{}' id '{}'", vm, vm.getId());
                runVdsCommand(VDSCommandType.CancelMigrate, new CancelMigrationVDSParameters(vm.getRunOnVds(), vm.getId(), true));
            }
        }
    }
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__TYPE__HOST);
    addCanDoActionMessage(EngineMessage.VAR__ACTION__MAINTENANCE);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addValidationMessage(EngineMessage.VAR__TYPE__HOST);
    addValidationMessage(EngineMessage.VAR__ACTION__MAINTENANCE);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    MoveVdssToGoingToMaintenanceMode();
    MigrateAllVdss();
    // find clusters for hosts that should move to maintenance
    Set<Guid> clusters = new HashSet<>();
    for (VDS vds : vdssToMaintenance.values()) {
        if (!clusters.contains(vds.getVdsGroupId())) {
            clusters.add(vds.getVdsGroupId());
            // set network to operational / non-operational
            List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(vds.getVdsGroupId());
            for (Network net : networks) {
                NetworkClusterHelper.setStatus(vds.getVdsGroupId(), net);
            }
        }
    }
    // clear the automatic PM flag unless instructed otherwise
    if (!getParameters().getKeepPolicyPMEnabled()) {
        for (Guid vdsId : getParameters().getVdsIdList()) {
            getDbFacade().getVdsDynamicDao().updateVdsDynamicPowerManagementPolicyFlag(vdsId, false);
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    moveVdssToGoingToMaintenanceMode();
    migrateAllVdss();
    // find clusters for hosts that should move to maintenance
    Set<Guid> clusters = new HashSet<>();
    for (VDS vds : vdssToMaintenance.values()) {
        if (!clusters.contains(vds.getClusterId())) {
            clusters.add(vds.getClusterId());
            // set network to operational / non-operational
            List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(vds.getClusterId());
            for (Network net : networks) {
                NetworkClusterHelper.setStatus(vds.getClusterId(), net);
            }
        }
    }
    // clear the automatic PM flag unless instructed otherwise
    if (!getParameters().getKeepPolicyPMEnabled()) {
        for (Guid vdsId : getParameters().getVdsIdList()) {
            getDbFacade().getVdsDynamicDao().updateVdsDynamicPowerManagementPolicyFlag(vdsId, false);
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
// Currently we cannot guarantee that migrating VM with positive enforcing affinity will
private boolean handlePositiveEnforcingAffinityGroup(Guid vdsId, List<VM> runningVms) {
    // less than 2 VMs in host means no positive affinity to worry about
    if (runningVms.size() > 1) {
        List<AffinityGroup> affinityGroups = getDbFacade().getAffinityGroupDao().getPositiveEnforcingAffinityGroupsByRunningVmsOnVdsId(vdsId);
        if (!affinityGroups.isEmpty()) {
            List<Object> items = new ArrayList<>();
            for (AffinityGroup affinityGroup : affinityGroups) {
                // affinity group has less than 2 vms (trivial)
                if (affinityGroup.getEntityIds().size() < 2) {
                    continue;
                }
                // counter for running VMs in affinity group
                int count = 0;
                for (VM vm : runningVms) {
                    if (affinityGroup.getEntityIds().contains(vm.getId())) {
                        count++;
                    }
                }
                if (count > 1) {
                    items.add(String.format("%1$s (%2$s)", affinityGroup.getName(), StringUtils.join(affinityGroup.getEntityNames(), " ,")));
                }
            }
            if (!items.isEmpty()) {
                addCanDoActionMessage(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_HAS_AFFINITY_VMS);
                getReturnValue().getCanDoActionMessages().addAll(ReplacementUtils.replaceWith("AFFINITY_GROUPS_VMS", items));
                return false;
            }
        }
    }
    return true;
}
#method_after
// Currently we cannot guarantee that migrating VM with positive enforcing affinity will
private boolean handlePositiveEnforcingAffinityGroup(Guid vdsId, List<VM> runningVms) {
    // less than 2 VMs in host means no positive affinity to worry about
    if (runningVms.size() > 1) {
        List<AffinityGroup> affinityGroups = getDbFacade().getAffinityGroupDao().getPositiveEnforcingAffinityGroupsByRunningVmsOnVdsId(vdsId);
        if (!affinityGroups.isEmpty()) {
            List<Object> items = new ArrayList<>();
            for (AffinityGroup affinityGroup : affinityGroups) {
                // affinity group has less than 2 vms (trivial)
                if (affinityGroup.getEntityIds().size() < 2) {
                    continue;
                }
                // counter for running VMs in affinity group
                int count = 0;
                for (VM vm : runningVms) {
                    if (affinityGroup.getEntityIds().contains(vm.getId())) {
                        count++;
                    }
                }
                if (count > 1) {
                    items.add(String.format("%1$s (%2$s)", affinityGroup.getName(), StringUtils.join(affinityGroup.getEntityNames(), " ,")));
                }
            }
            if (!items.isEmpty()) {
                addValidationMessage(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_HAS_AFFINITY_VMS);
                getReturnValue().getValidationMessages().addAll(ReplacementUtils.replaceWith("AFFINITY_GROUPS_VMS", items));
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
private void handleNonMigratableVms(List<String> hostsWithNonMigratableVms, List<String> nonMigratableVms) {
    if (!nonMigratableVms.isEmpty()) {
        addCanDoActionMessage(EngineMessage.VDS_CANNOT_MAINTENANCE_IT_INCLUDES_NON_MIGRATABLE_VM);
        getReturnValue().getCanDoActionMessages().add((String.format("$VmsList %1$s", StringUtils.join(nonMigratableVms, " , "))));
        getReturnValue().getCanDoActionMessages().add((String.format("$HostsList %1$s", StringUtils.join(hostsWithNonMigratableVms, " , "))));
    }
}
#method_after
private void handleNonMigratableVms(List<String> hostsWithNonMigratableVms, List<String> nonMigratableVms) {
    if (!nonMigratableVms.isEmpty()) {
        addValidationMessage(EngineMessage.VDS_CANNOT_MAINTENANCE_IT_INCLUDES_NON_MIGRATABLE_VM);
        getReturnValue().getValidationMessages().add(String.format("$VmsList %1$s", StringUtils.join(nonMigratableVms, " , ")));
        getReturnValue().getValidationMessages().add(String.format("$HostsList %1$s", StringUtils.join(hostsWithNonMigratableVms, " , ")));
    }
}
#end_block

#method_before
private void handleNonResponsiveHosts(List<String> hostNotRespondingList) {
    if (!hostNotRespondingList.isEmpty()) {
        addCanDoActionMessage(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_RESPONDING_WITH_VMS);
        getReturnValue().getCanDoActionMessages().add(String.format("$HostNotResponding %1$s", StringUtils.join(hostNotRespondingList, ",")));
    }
}
#method_after
private void handleNonResponsiveHosts(List<String> hostNotRespondingList) {
    if (!hostNotRespondingList.isEmpty()) {
        addValidationMessage(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_RESPONDING_WITH_VMS);
        getReturnValue().getValidationMessages().add(String.format("$HostNotResponding %1$s", StringUtils.join(hostNotRespondingList, ",")));
    }
}
#end_block

#method_before
private void handleHostsWithVmsWithPluggedDiskSnapshots(List<String> hostsWithVmsWithPluggedDiskSnapshots) {
    if (!hostsWithVmsWithPluggedDiskSnapshots.isEmpty()) {
        getReturnValue().getCanDoActionMessages().add((String.format("$HostsList %1$s", StringUtils.join(hostsWithVmsWithPluggedDiskSnapshots, ","))));
    }
}
#method_after
private void handleHostsWithVmsWithPluggedDiskSnapshots(List<String> hostsWithVmsWithPluggedDiskSnapshots) {
    if (!hostsWithVmsWithPluggedDiskSnapshots.isEmpty()) {
        getReturnValue().getValidationMessages().add(String.format("$HostsList %1$s", StringUtils.join(hostsWithVmsWithPluggedDiskSnapshots, ",")));
    }
}
#end_block

#method_before
private void addClusterDetails(Guid vdsGroupID, List<String> clustersWithRunningVms) {
    if (vdsGroupID != null && !vdsGroupID.equals(Guid.Empty)) {
        VDSGroup vdsGroup = DbFacade.getInstance().getVdsGroupDao().getWithRunningVms(vdsGroupID);
        if (vdsGroup != null) {
            clustersWithRunningVms.add(vdsGroup.getName());
        }
    }
}
#method_after
private void addClusterDetails(Guid clusterID, List<String> clustersWithRunningVms) {
    if (clusterID != null && !clusterID.equals(Guid.Empty)) {
        Cluster cluster = DbFacade.getInstance().getClusterDao().getWithRunningVms(clusterID);
        if (cluster != null) {
            clustersWithRunningVms.add(cluster.getName());
        }
    }
}
#end_block

#method_before
private void initHandlers() {
    BaseConditionFieldAutoCompleter.tagsHandler = handlersFactory.createTagsHandler();
    VmHandler.init();
    VdsHandler.init();
    VmTemplateHandler.init();
    log.info("Completed initializing handlers");
}
#method_after
private void initHandlers() {
    BaseConditionFieldAutoCompleter.tagsHandler = tagsDirector;
    VmHandler.init();
    VdsHandler.init();
    VmTemplateHandler.init();
    log.info("Completed initializing handlers");
}
#end_block

#method_before
@Test
public void serializeCollectionsSingletonList() {
    ManageNetworkClustersParameters params = new ManageNetworkClustersParameters(Collections.singletonList(new NetworkCluster(Guid.createGuidFromString("f455686a-79cc-11e6-8c65-54ee755c6cc7"), Guid.createGuidFromString("f970c5f6-79cc-11e6-bc8f-54ee755c6cc7"), NetworkStatus.NON_OPERATIONAL, false, false, false, false, false)));
    JsonObjectSerializer serializer = new JsonObjectSerializer();
    String json = serializer.serialize(params);
    assertTrue(json.length() > 0);
    ManageNetworkClustersParameters deserializedParams = new JsonObjectDeserializer().deserialize(json, ManageNetworkClustersParameters.class);
    assertEquals(params.getExecutionReason(), deserializedParams.getExecutionReason());
}
#method_after
@Test
public void serializeCollectionsSingletonList() {
    ManageNetworkClustersParameters params = new ManageNetworkClustersParameters(Collections.singletonList(new NetworkCluster(Guid.newGuid(), Guid.newGuid(), NetworkStatus.NON_OPERATIONAL, false, false, false, false, false)));
    JsonObjectSerializer serializer = new JsonObjectSerializer();
    String json = serializer.serialize(params);
    assertTrue(json.length() > 0);
    ManageNetworkClustersParameters deserializedParams = new JsonObjectDeserializer().deserialize(json, ManageNetworkClustersParameters.class);
    assertEquals(params.getExecutionReason(), deserializedParams.getExecutionReason());
}
#end_block

#method_before
@Test
public void serializeCollectionsSingletonMap() {
    MoveOrCopyParameters params = new MoveOrCopyParameters(Guid.createGuidFromString("f455686a-79cc-11e6-8c65-54ee755c6cc7"), Guid.createGuidFromString("f970c5f6-79cc-11e6-bc8f-54ee755c6cc7"));
    params.setImageToDestinationDomainMap(Collections.singletonMap(Guid.createGuidFromString("9edb6526-7ab5-11e6-b829-54ee755c6cc7"), Guid.createGuidFromString("c097a788-7ab5-11e6-849b-54ee755c6cc7")));
    JsonObjectSerializer serializer = new JsonObjectSerializer();
    String json = serializer.serialize(params);
    assertTrue(json.length() > 0);
    MoveOrCopyParameters deserializedParams = new JsonObjectDeserializer().deserialize(json, MoveOrCopyParameters.class);
    assertEquals(params.getContainerId(), deserializedParams.getContainerId());
    assertEquals(params.getExecutionReason(), deserializedParams.getExecutionReason());
}
#method_after
@Test
public void serializeCollectionsSingletonMap() {
    MoveOrCopyParameters params = new MoveOrCopyParameters(Guid.newGuid(), Guid.newGuid());
    params.setImageToDestinationDomainMap(Collections.singletonMap(Guid.createGuidFromString("9edb6526-7ab5-11e6-b829-54ee755c6cc7"), Guid.createGuidFromString("c097a788-7ab5-11e6-849b-54ee755c6cc7")));
    JsonObjectSerializer serializer = new JsonObjectSerializer();
    String json = serializer.serialize(params);
    assertTrue(json.length() > 0);
    MoveOrCopyParameters deserializedParams = new JsonObjectDeserializer().deserialize(json, MoveOrCopyParameters.class);
    assertEquals(params.getContainerId(), deserializedParams.getContainerId());
    assertEquals(params.getExecutionReason(), deserializedParams.getExecutionReason());
}
#end_block

#method_before
@Override
protected TypeIdResolver idResolver(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) {
    TypeIdResolver idResolver;
    if (baseType.isCollectionLikeType()) {
        idResolver = new JsonCollectionIdResolver(baseType, config.getTypeFactory());
    } else if (baseType.isMapLikeType()) {
        idResolver = new JsonMapIdResolver(baseType, config.getTypeFactory());
    } else {
        idResolver = super.idResolver(config, baseType, subtypes, forSer, forDeser);
    }
    return idResolver;
}
#method_after
@Override
protected TypeIdResolver idResolver(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) {
    TypeIdResolver idResolver;
    if (baseType.isCollectionLikeType()) {
        // provide a custom id resolver for collections
        idResolver = new JsonCollectionIdResolver(baseType, config.getTypeFactory());
    } else if (baseType.isMapLikeType()) {
        // provide a custom id resolver for maps
        idResolver = new JsonMapIdResolver(baseType, config.getTypeFactory());
    } else {
        // use the default resolver
        idResolver = super.idResolver(config, baseType, subtypes, forSer, forDeser);
    }
    return idResolver;
}
#end_block

#method_before
@Override
public String idFromValue(Object o) {
    String id = super.idFromValue(o);
    if (relacementIds.containsKey(id)) {
        id = relacementIds.get(id);
    }
    return id;
}
#method_after
@Override
public String idFromValue(Object o) {
    String id = super.idFromValue(o);
    // return a replacement id if it exists
    return relacementIds.getOrDefault(id, id);
}
#end_block

#method_before
@Override
public String idFromValueAndType(Object o, Class<?> aClass) {
    String id = super.idFromValueAndType(o, aClass);
    if (relacementIds.containsKey(id)) {
        id = relacementIds.get(id);
    }
    return id;
}
#method_after
@Override
public String idFromValueAndType(Object o, Class<?> aClass) {
    String id = super.idFromValueAndType(o, aClass);
    // return a replacement id if it exists
    return relacementIds.getOrDefault(id, id);
}
#end_block

#method_before
@Override
public String idFromValue(Object o) {
    String id = super.idFromValue(o);
    if (relacementIds.containsKey(id)) {
        id = relacementIds.get(id);
    }
    return id;
}
#method_after
@Override
public String idFromValue(Object o) {
    String id = super.idFromValue(o);
    // return a replacement id if it exists
    return relacementIds.getOrDefault(id, id);
}
#end_block

#method_before
@Override
public String idFromValueAndType(Object o, Class<?> aClass) {
    String id = super.idFromValueAndType(o, aClass);
    if (relacementIds.containsKey(id)) {
        id = relacementIds.get(id);
    }
    return id;
}
#method_after
@Override
public String idFromValueAndType(Object o, Class<?> aClass) {
    String id = super.idFromValueAndType(o, aClass);
    // return a replacement id if it exists
    return relacementIds.getOrDefault(id, id);
}
#end_block

#method_before
public ValidationResult isStorageFormatCompatibleWithDomain() {
    StorageFormatType storageFormat = storageDomain.getStorageFormat();
    StorageType storageType = storageDomain.getStorageType();
    StorageDomainType storageDomainFunction = storageDomain.getStorageDomainType();
    boolean validationSucceeded = true;
    // V2 is applicable only for block data storage domains
    if (storageFormat == StorageFormatType.V2) {
        if (!(storageDomainFunction.isDataDomain() && storageType.isBlockDomain())) {
            validationSucceeded = false;
        }
    }
    // V3 & V4 is applicable only for data storage domains
    if (storageFormat == StorageFormatType.V3 || storageFormat == StorageFormatType.V4) {
        if (!storageDomainFunction.isDataDomain()) {
            validationSucceeded = false;
        }
    }
    return validationSucceeded ? ValidationResult.VALID : new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_FORMAT_ILLEGAL_HOST, String.format("$storageFormat %1$s", storageDomain.getStorageFormat()));
}
#method_after
public ValidationResult isStorageFormatCompatibleWithDomain() {
    StorageFormatType storageFormat = storageDomain.getStorageFormat();
    StorageType storageType = storageDomain.getStorageType();
    StorageDomainType storageDomainFunction = storageDomain.getStorageDomainType();
    boolean validationSucceeded = true;
    // V2 is applicable only for block data storage domains
    if (storageFormat == StorageFormatType.V2) {
        if (!(storageDomainFunction.isDataDomain() && storageType.isBlockDomain())) {
            validationSucceeded = false;
        }
    }
    // Above V3 is applicable only for data storage domains
    if (storageFormat.compareTo(StorageFormatType.V3) >= 0) {
        if (!storageDomainFunction.isDataDomain()) {
            validationSucceeded = false;
        }
    }
    return validationSucceeded ? ValidationResult.VALID : new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_FORMAT_ILLEGAL_HOST, String.format("$storageFormat %1$s", storageDomain.getStorageFormat()));
}
#end_block

#method_before
@Test
public void validateSucceedsInitFormatDataDomain() {
    sd.setStorageFormat(null);
    ValidateTestUtils.runAndAssertValidateSuccess(cmd);
    assertEquals("Format not initialized correctly", StorageFormatType.V4, sd.getStorageFormat());
}
#method_after
@Test
public void validateSucceedsInitFormatDataDomain() {
    sd.setStorageFormat(null);
    ValidateTestUtils.runAndAssertValidateSuccess(cmd);
    StorageFormatType targetStorageFormatType = StorageFormatType.values()[StorageFormatType.values().length - 1];
    assertEquals("Format not initialized correctly", targetStorageFormatType, sd.getStorageFormat());
}
#end_block

#method_before
protected void performDiskUpdate(final boolean unlockImage) {
    if (shouldPerformMetadataUpdate()) {
        updateMetaDataDescription((DiskImage) getNewDisk());
    }
    final Disk diskForUpdate = getDiskDao().get(getParameters().getDiskInfo().getId());
    final DiskVmElement diskVmElementForUpdate = getDiskVmElementDao().get(new VmDeviceId(getOldDisk().getId(), getVmId()));
    applyUserChanges(diskForUpdate, diskVmElementForUpdate);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getVmStaticDao().incrementDbGeneration(getVm().getId());
            updateDeviceProperties();
            getBaseDiskDao().update(diskForUpdate);
            getDiskVmElementDao().update(diskVmElementForUpdate);
            switch(diskForUpdate.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) diskForUpdate;
                    diskImage.setQuotaId(getQuotaId());
                    if (unlockImage && diskImage.getImageStatus() == ImageStatus.LOCKED) {
                        diskImage.setImageStatus(ImageStatus.OK);
                    }
                    getImageDao().update(diskImage.getImage());
                    updateQuota(diskImage);
                    updateDiskProfile();
                    break;
                case CINDER:
                    CinderDisk cinderDisk = (CinderDisk) diskForUpdate;
                    cinderDisk.setQuotaId(getQuotaId());
                    setStorageDomainId(cinderDisk.getStorageIds().get(0));
                    getCinderBroker().updateDisk(cinderDisk);
                    if (unlockImage && cinderDisk.getImageStatus() == ImageStatus.LOCKED) {
                        cinderDisk.setImageStatus(ImageStatus.OK);
                    }
                    getImageDao().update(cinderDisk.getImage());
                    updateQuota(cinderDisk);
                    break;
                case LUN:
                    updateLunProperties((LunDisk) getNewDisk());
                    break;
            }
            reloadDisks();
            updateBootOrder();
            setSucceeded(true);
            // If necessary set the new Storage QoS values on running VMs asynchronously
            liveUpdateDiskProfile();
            return null;
        }

        private void updateDeviceProperties() {
            if (updateReadOnlyRequested()) {
                vmDeviceForVm.setIsReadOnly(getNewDisk().getReadOnly());
                getVmDeviceDao().update(vmDeviceForVm);
            }
            if (getOldDiskVmElement().getDiskInterface() != getDiskVmElement().getDiskInterface()) {
                vmDeviceForVm.setAddress("");
                getVmDeviceDao().clearDeviceAddress(getOldDisk().getId());
            }
            if (getOldDiskVmElement().isBoot() != getDiskVmElement().isBoot()) {
                if (getDiskVmElement().getDiskInterface().equals(DiskInterface.IDE)) {
                    vmDeviceForVm.setAddress("");
                    getVmDeviceDao().clearDeviceAddress(getOldDisk().getId());
                }
            }
        }

        private void updateLunProperties(LunDisk lunDisk) {
            if (updateIsUsingScsiReservationRequested(lunDisk)) {
                vmDeviceForVm.setUsingScsiReservation(lunDisk.isUsingScsiReservation());
                getVmDeviceDao().update(vmDeviceForVm);
            }
        }
    });
}
#method_after
protected void performDiskUpdate(final boolean unlockImage) {
    if (shouldPerformMetadataUpdate()) {
        updateMetaDataDescription((DiskImage) getNewDisk());
    }
    final Disk diskForUpdate = getDiskDao().get(getParameters().getDiskInfo().getId());
    final DiskVmElement diskVmElementForUpdate = getDiskVmElementDao().get(new VmDeviceId(getOldDisk().getId(), getVmId()));
    applyUserChanges(diskForUpdate, diskVmElementForUpdate);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getVmStaticDao().incrementDbGeneration(getVm().getId());
            updateDeviceProperties();
            getBaseDiskDao().update(diskForUpdate);
            getDiskVmElementDao().update(diskVmElementForUpdate);
            switch(diskForUpdate.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) diskForUpdate;
                    diskImage.setQuotaId(getQuotaId());
                    if (unlockImage && diskImage.getImageStatus() == ImageStatus.LOCKED) {
                        diskImage.setImageStatus(ImageStatus.OK);
                    }
                    getImageDao().update(diskImage.getImage());
                    updateQuota(diskImage);
                    updateDiskProfile();
                    break;
                case CINDER:
                    CinderDisk cinderDisk = (CinderDisk) diskForUpdate;
                    cinderDisk.setQuotaId(getQuotaId());
                    setStorageDomainId(cinderDisk.getStorageIds().get(0));
                    getCinderBroker().updateDisk(cinderDisk);
                    if (unlockImage && cinderDisk.getImageStatus() == ImageStatus.LOCKED) {
                        cinderDisk.setImageStatus(ImageStatus.OK);
                    }
                    getImageDao().update(cinderDisk.getImage());
                    updateQuota(cinderDisk);
                    break;
                case LUN:
                    updateLunProperties((LunDisk) getNewDisk());
                    break;
            }
            reloadDisks();
            updateBootOrder();
            setSucceeded(true);
            // If necessary set the new Storage QoS values on running VMs asynchronously
            liveUpdateDiskProfile();
            return null;
        }

        private void updateDeviceProperties() {
            if (updateReadOnlyRequested()) {
                vmDeviceForVm.setIsReadOnly(getNewDisk().getReadOnly());
                getVmDeviceDao().update(vmDeviceForVm);
            }
            if ((getOldDiskVmElement().getDiskInterface() != getDiskVmElement().getDiskInterface()) || ((getOldDiskVmElement().isBoot() != getDiskVmElement().isBoot()) && (getDiskVmElement().getDiskInterface() == DiskInterface.IDE))) {
                vmDeviceForVm.setAddress("");
                getVmDeviceDao().clearDeviceAddress(getOldDisk().getId());
            }
        }

        private void updateLunProperties(LunDisk lunDisk) {
            if (updateIsUsingScsiReservationRequested(lunDisk)) {
                vmDeviceForVm.setUsingScsiReservation(lunDisk.isUsingScsiReservation());
                getVmDeviceDao().update(vmDeviceForVm);
            }
        }
    });
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    if (isDiskImage()) {
        DiskImage diskImage = (DiskImage) getNewDisk();
        // when disk profile isn't updated, skip check.
        if (diskImage.getDiskProfileId() != null && diskImage.getDiskProfileId().equals(((DiskImage) getOldDisk()).getDiskProfileId())) {
            return true;
        }
        Map<DiskImage, Guid> map = new HashMap<>();
        map.put(diskImage, diskImage.getStorageIds().get(0));
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getCurrentUser()));
    }
    return true;
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    if (isDiskImage()) {
        DiskImage diskImage = (DiskImage) getNewDisk();
        // when disk profile isn't updated, skip check.
        if (diskImage.getDiskProfileId() != null && diskImage.getDiskProfileId().equals(((DiskImage) getOldDisk()).getDiskProfileId())) {
            return true;
        }
        Map<DiskImage, Guid> map = new HashMap<>();
        map.put(diskImage, diskImage.getStorageIds().get(0));
        return validate(diskProfileHelper.setAndValidateDiskProfiles(map, getCurrentUser()));
    }
    return true;
}
#end_block

#method_before
public void setSearchString(String value) {
    if (!Objects.equals(searchString, value)) {
        searchString = value;
        pagingSearchString = null;
        searchStringChanged();
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("SearchString"));
    }
}
#method_after
public void setSearchString(String value) {
    if (!Objects.equals(searchString, value)) {
        searchString = value;
        pagingSearchString = null;
        currentPageNumber = 1;
        searchStringChanged();
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("SearchString"));
    }
}
#end_block

#method_before
public void syncSearch(VdcQueryType vdcQueryType, VdcQueryParametersBase vdcQueryParametersBase) {
    vdcQueryParametersBase.setRefresh(getIsQueryFirstTime());
    // is necessary for pagination UI widgets to function properly
    if (vdcQueryParametersBase instanceof SearchParameters) {
        SearchParameters sp = (SearchParameters) vdcQueryParametersBase;
        int searchPage;
        MatchResult m = checkForSearchPageRegExp.exec(sp.getSearchPattern());
        if (m != null) {
            searchPage = Integer.parseInt(m.getGroup(1), 10);
        } else {
            searchPage = 1;
        }
        setSearchStringPage(searchPage);
    }
    Frontend.getInstance().runQuery(vdcQueryType, vdcQueryParametersBase, new SetItemsAsyncQuery());
    setIsQueryFirstTime(false);
}
#method_after
protected void syncSearch(VdcQueryType vdcQueryType, VdcQueryParametersBase vdcQueryParametersBase) {
    vdcQueryParametersBase.setRefresh(getIsQueryFirstTime());
    Frontend.getInstance().runQuery(vdcQueryType, vdcQueryParametersBase, new SetItemsAsyncQuery());
    setIsQueryFirstTime(false);
}
#end_block

#method_before
@OnTimerMethodAnnotation("availableUpdates")
public void availableUpdates() {
    if (cachedVds.getStatus() != VDSStatus.Up && cachedVds.getStatus() != VDSStatus.NonOperational) {
        log.warn("Check for available updates is skipped for host '{}' due to unsupported host status '{}' ", cachedVds.getName(), cachedVds.getStatus());
        return;
    }
    boolean updateAvailable;
    try {
        updateAvailable = resourceManager.isUpdateAvailable(cachedVds);
    } catch (Exception e) {
        log.error("Failed to check if updates are available for host '{}'", cachedVds.getName());
        AuditLogableBase auditLog = new AuditLogableBase();
        auditLog.setVds(cachedVds);
        auditLog.addCustomValue("Message", StringUtils.defaultString(e.getMessage(), e.getCause().toString()));
        auditLogDirector.log(auditLog, AuditLogType.HOST_AVAILABLE_UPDATES_FAILED);
        return;
    }
    synchronized (this) {
        if (updateAvailable != cachedVds.isUpdateAvailable()) {
            cachedVds.getDynamicData().setUpdateAvailable(updateAvailable);
            vdsDynamicDao.updateUpdateAvailable(cachedVds.getId(), updateAvailable);
        }
    }
}
#method_after
@OnTimerMethodAnnotation("availableUpdates")
public void availableUpdates() {
    if (cachedVds.getStatus() != VDSStatus.Up && cachedVds.getStatus() != VDSStatus.NonOperational) {
        log.warn("Check for available updates is skipped for host '{}' due to unsupported host status '{}' ", cachedVds.getName(), cachedVds.getStatus());
        return;
    }
    boolean updateAvailable;
    try {
        updateAvailable = resourceManager.isUpdateAvailable(cachedVds);
    } catch (Exception e) {
        log.error("Failed to check if updates are available for host '{}' with exception '{}'", cachedVds.getName(), StringUtils.defaultString(e.getMessage(), e.getCause().toString()));
        log.debug("Exception", e);
        AuditLogableBase auditLog = new AuditLogableBase();
        auditLog.setVds(cachedVds);
        auditLog.addCustomValue("Message", StringUtils.defaultString(e.getMessage(), e.getCause().toString()));
        auditLogDirector.log(auditLog, AuditLogType.HOST_AVAILABLE_UPDATES_FAILED);
        return;
    }
    synchronized (this) {
        if (updateAvailable != cachedVds.isUpdateAvailable()) {
            cachedVds.getDynamicData().setUpdateAvailable(updateAvailable);
            vdsDynamicDao.updateUpdateAvailable(cachedVds.getId(), updateAvailable);
        }
    }
}
#end_block

#method_before
private void moveVmsToUnknown() {
    List<VM> vms = getVmsToMoveToUnknown();
    for (VM vm : vms) {
        destroyVmOnDestination(vm);
        resourceManager.removeAsyncRunningVm(vm.getId());
    }
    List<Guid> vmIds = vms.stream().map(VM::getId).collect(Collectors.toList());
    getVmDynamicDao().updateVmsToUnknown(vmIds);
    vmIds.forEach(vmId -> {
        // log VM transition to unknown status
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVmId(vmId);
        auditLogDirector.log(logable, AuditLogType.VM_SET_TO_UNKNOWN_STATUS);
    });
}
#method_after
private void moveVmsToUnknown() {
    List<VmDynamic> vms = getVmsToMoveToUnknown();
    for (VmDynamic vm : vms) {
        destroyVmOnDestination(vm);
        resourceManager.removeAsyncRunningVm(vm.getId());
    }
    List<Guid> vmIds = vms.stream().map(VmDynamic::getId).collect(Collectors.toList());
    getVmDynamicDao().updateVmsToUnknown(vmIds);
    vmIds.forEach(vmId -> {
        // log VM transition to unknown status
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVmId(vmId);
        auditLogDirector.log(logable, AuditLogType.VM_SET_TO_UNKNOWN_STATUS);
    });
}
#end_block

#method_before
private void destroyVmOnDestination(final VM vm) {
    if (vm.getStatus() != VMStatus.MigratingFrom || vm.getMigratingToVds() == null) {
        return;
    }
    // avoid nested locks by doing this in a separate thread
    ThreadPoolUtil.execute(() -> {
        VDSReturnValue returnValue = resourceManager.runVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(vm.getMigratingToVds(), vm.getId(), true, false, 0));
        if (returnValue != null && returnValue.getSucceeded()) {
            log.info("Stopped migrating VM: '{}' on VDS: '{}'", vm.getName(), vm.getMigratingToVds());
        } else {
            log.info("Could not stop migrating VM: '{}' on VDS: '{}'", vm.getName(), vm.getMigratingToVds());
        }
    });
}
#method_after
private void destroyVmOnDestination(final VmDynamic vm) {
    if (vm.getStatus() != VMStatus.MigratingFrom || vm.getMigratingToVds() == null) {
        return;
    }
    // avoid nested locks by doing this in a separate thread
    ThreadPoolUtil.execute(() -> {
        VDSReturnValue returnValue = resourceManager.runVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(vm.getMigratingToVds(), vm.getId(), true, false, 0));
        if (returnValue != null && returnValue.getSucceeded()) {
            log.info("Stopped migrating VM: '{}' on VDS: '{}'", resourceManager.getVmManager(vm.getId()).getName(), vm.getMigratingToVds());
        } else {
            log.info("Could not stop migrating VM: '{}' on VDS: '{}'", resourceManager.getVmManager(vm.getId()).getName(), vm.getMigratingToVds());
        }
    });
}
#end_block

#method_before
private List<VM> getVmsToMoveToUnknown() {
    List<VM> vmList = vmDao.getAllRunningForVds(getVdsId());
    List<VM> migratingVms = vmDao.getAllMigratingToHost(getVdsId());
    for (VM incomingVm : migratingVms) {
        if (incomingVm.getStatus() == VMStatus.MigratingTo) {
            // this VM is finished the migration handover and is running on this host now
            // and should be treated as well.
            vmList.add(incomingVm);
        }
    }
    return vmList;
}
#method_after
private List<VmDynamic> getVmsToMoveToUnknown() {
    List<VmDynamic> vmList = vmDynamicDao.getAllRunningForVds(getVdsId());
    List<VmDynamic> migratingVms = vmDynamicDao.getAllMigratingToHost(getVdsId());
    for (VmDynamic incomingVm : migratingVms) {
        if (incomingVm.getStatus() == VMStatus.MigratingTo) {
            // this VM is finished the migration handover and is running on this host now
            // and should be treated as well.
            vmList.add(incomingVm);
        }
    }
    return vmList;
}
#end_block

#method_before
@Override
public void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    Map<Guid, StorageQos> qosCache = new HashMap<>();
    int pinnedDriveIndex = 0;
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<>();
        // get vm device for this disk from DB
        VmDevice vmDevice = vmInfoBuildUtils.getVmDeviceByDiskId(disk.getId(), vm.getId());
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        // skip unmanaged devices (handled separately)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(dve.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    if (vm.getNumOfIoThreads() != 0) {
                        // simple round robin e.g. for 2 threads and 4 disks it will be pinned like this:
                        // disk 0 -> iothread 1
                        // disk 1 -> iothread 2
                        // disk 2 -> iothread 1
                        // disk 3 -> iothread 2
                        int pinTo = pinnedDriveIndex % vm.getNumOfIoThreads() + 1;
                        pinnedDriveIndex++;
                        vmDevice.getSpecParams().put(VdsProperties.pinToIoThread, pinTo);
                    }
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    // set device type as 'lun' (instead of 'disk') and set the specified SGIO.
                    if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(vmInfoBuildUtils.createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(vmInfoBuildUtils.createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && dve.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, getBootableDiskIndex(disk));
            }
            vmInfoBuildUtils.addAddress(vmDevice, struct);
            switch(disk.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) disk;
                    struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                    struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                    struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                    struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                    struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
                    if (!qosCache.containsKey(diskImage.getDiskProfileId())) {
                        qosCache.put(diskImage.getDiskProfileId(), vmInfoBuildUtils.loadStorageQos(diskImage));
                    }
                    vmInfoBuildUtils.handleIoTune(vmDevice, qosCache.get(diskImage.getDiskProfileId()));
                    break;
                case LUN:
                    LunDisk lunDisk = (LunDisk) disk;
                    struct.put(VdsProperties.Guid, lunDisk.getLun().getLUNId());
                    struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
                    break;
                case CINDER:
                    vmInfoBuildUtils.buildCinderDisk((CinderDisk) disk, struct);
                    break;
            }
            vmInfoBuildUtils.addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#method_after
@Override
public void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    Map<Guid, StorageQos> qosCache = new HashMap<>();
    int pinnedDriveIndex = 0;
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<>();
        // get vm device for this disk from DB
        VmDevice vmDevice = vmInfoBuildUtils.getVmDeviceByDiskId(disk.getId(), vm.getId());
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        // skip unmanaged devices (handled separately)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(dve.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    pinnedDriveIndex = pinToIoThreads(vmDevice, pinnedDriveIndex);
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    // set device type as 'lun' (instead of 'disk') and set the specified SGIO.
                    if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(vmInfoBuildUtils.createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    if (FeatureSupported.virtioScsiIoThread(vm.getCompatibilityVersion())) {
                        pinnedDriveIndex = pinToIoThreads(vmDevice, pinnedDriveIndex);
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(vmInfoBuildUtils.createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && dve.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, getBootableDiskIndex(disk));
            }
            vmInfoBuildUtils.addAddress(vmDevice, struct);
            switch(disk.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) disk;
                    struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                    struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                    struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                    struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                    struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
                    if (!qosCache.containsKey(diskImage.getDiskProfileId())) {
                        qosCache.put(diskImage.getDiskProfileId(), vmInfoBuildUtils.loadStorageQos(diskImage));
                    }
                    vmInfoBuildUtils.handleIoTune(vmDevice, qosCache.get(diskImage.getDiskProfileId()));
                    break;
                case LUN:
                    LunDisk lunDisk = (LunDisk) disk;
                    struct.put(VdsProperties.Guid, lunDisk.getLun().getLUNId());
                    struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
                    break;
                case CINDER:
                    vmInfoBuildUtils.buildCinderDisk((CinderDisk) disk, struct);
                    break;
            }
            vmInfoBuildUtils.addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#end_block

#method_before
private void buildVmGraphicsDevicesOverridden(Map<GraphicsType, GraphicsInfo> graphicsInfos, Map<String, Object> extraSpecParams) {
    for (Entry<GraphicsType, GraphicsInfo> graphicsInfo : graphicsInfos.entrySet()) {
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, VmDeviceGeneralType.GRAPHICS.getValue());
        struct.put(VdsProperties.Device, graphicsInfo.getKey().name().toLowerCase());
        struct.put(VdsProperties.DeviceId, String.valueOf(Guid.newGuid()));
        if (extraSpecParams != null) {
            struct.put(VdsProperties.SpecParams, extraSpecParams);
        }
        devices.add(struct);
    }
    if (!graphicsInfos.isEmpty()) {
        String legacyGraphicsType = (graphicsInfos.size() == 2) ? VdsProperties.QXL : graphicsTypeToLegacyDisplayType(graphicsInfos.keySet().iterator().next());
        createInfo.put(VdsProperties.display, legacyGraphicsType);
    }
}
#method_after
private void buildVmGraphicsDevicesOverridden(Map<GraphicsType, GraphicsInfo> graphicsInfos, Map<String, Object> extraSpecParams) {
    final Comparator<GraphicsType> spiceLastComparator = ComparatorUtils.sortLast(GraphicsType.SPICE);
    final List<Entry<GraphicsType, GraphicsInfo>> sortedGraphicsInfos = graphicsInfos.entrySet().stream().sorted(Comparator.comparing(Entry::getKey, spiceLastComparator)).collect(Collectors.toList());
    for (Entry<GraphicsType, GraphicsInfo> graphicsInfo : sortedGraphicsInfos) {
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, VmDeviceGeneralType.GRAPHICS.getValue());
        struct.put(VdsProperties.Device, graphicsInfo.getKey().name().toLowerCase());
        struct.put(VdsProperties.DeviceId, String.valueOf(Guid.newGuid()));
        if (extraSpecParams != null) {
            struct.put(VdsProperties.SpecParams, extraSpecParams);
        }
        devices.add(struct);
    }
    if (!graphicsInfos.isEmpty()) {
        String legacyGraphicsType = (graphicsInfos.size() == 2) ? VdsProperties.QXL : graphicsTypeToLegacyDisplayType(graphicsInfos.keySet().iterator().next());
        createInfo.put(VdsProperties.display, legacyGraphicsType);
    }
}
#end_block

#method_before
private void buildVmGraphicsDevicesFromDb(Map<String, Object> extraSpecParams) {
    Comparator<VmDevice> spiceLastDeviceComparator = Comparator.comparing(VmDevice::getDevice, getSpiceLastStringComparator());
    buildVmDevicesFromDb(VmDeviceGeneralType.GRAPHICS, false, extraSpecParams, spiceLastDeviceComparator);
    String legacyDisplay = deriveDisplayTypeLegacy();
    if (legacyDisplay != null) {
        createInfo.put(VdsProperties.display, legacyDisplay);
    }
}
#method_after
private void buildVmGraphicsDevicesFromDb(Map<String, Object> extraSpecParams) {
    Comparator<VmDevice> spiceLastDeviceComparator = Comparator.comparing(VmDevice::getDevice, ComparatorUtils.sortLast(VmDeviceType.SPICE.getName()));
    buildVmDevicesFromDb(VmDeviceGeneralType.GRAPHICS, false, extraSpecParams, spiceLastDeviceComparator);
    String legacyDisplay = deriveDisplayTypeLegacy();
    if (legacyDisplay != null) {
        createInfo.put(VdsProperties.display, legacyDisplay);
    }
}
#end_block

#method_before
private String buildMetadataDictionaryForVm(VM vm) {
    List<DiskImage> allVmImages = new ArrayList<>();
    List<DiskImage> filteredDisks = DisksFilter.filterImageDisks(vm.getDiskList(), SNAPABLE_DISKS_ONLY, ACTIVE_DISKS_ONLY);
    for (DiskImage diskImage : filteredDisks) {
        List<DiskImage> images = ImagesHandler.getAllImageSnapshots(diskImage.getImageId());
        images.stream().forEach(d -> d.setDiskVmElements(Collections.singletonList(diskImage.getDiskVmElementForVm(vm.getId()))));
        allVmImages.addAll(images);
    }
    return ovfManager.exportVm(vm, allVmImages, ClusterUtils.getCompatibilityVersion(vm));
}
#method_after
private String buildMetadataDictionaryForVm(VM vm) {
    List<DiskImage> allVmImages = new ArrayList<>();
    List<DiskImage> filteredDisks = DisksFilter.filterImageDisks(vm.getDiskList(), ONLY_SNAPABLE, ONLY_ACTIVE);
    for (DiskImage diskImage : filteredDisks) {
        List<DiskImage> images = ImagesHandler.getAllImageSnapshots(diskImage.getImageId());
        images.stream().forEach(d -> d.setDiskVmElements(Collections.singletonList(diskImage.getDiskVmElementForVm(vm.getId()))));
        allVmImages.addAll(images);
    }
    return ovfManager.exportVm(vm, allVmImages, ClusterUtils.getCompatibilityVersion(vm));
}
#end_block

#method_before
protected void restoreSnapshotAndRemoveObsoleteSnapshots(Snapshot targetSnapshot) {
    Guid activeSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE);
    List<DiskImage> imagesFromActiveSnapshot = getDiskImageDao().getAllSnapshotsForVmSnapshot(activeSnapshotId);
    Snapshot previewedSnapshot = getSnapshotDao().get(getVmId(), SnapshotType.PREVIEW);
    if (previewedSnapshot != null) {
        SnapshotVmConfigurationHelper snapshotVmConfigurationHelper = new SnapshotVmConfigurationHelper();
        VM vmFromConf = snapshotVmConfigurationHelper.getVmFromConfiguration(previewedSnapshot.getVmConfiguration(), previewedSnapshot.getVmId(), previewedSnapshot.getId());
        List<DiskImage> previewedImagesFromDB = getDiskImageDao().getAllSnapshotsForVmSnapshot(previewedSnapshot.getId());
        imagesFromPreviewSnapshot.addAll(ImagesHandler.imagesIntersection(vmFromConf.getImages(), previewedImagesFromDB));
    }
    List<DiskImage> intersection = ImagesHandler.imagesIntersection(imagesFromActiveSnapshot, imagesFromPreviewSnapshot);
    switch(targetSnapshot.getType()) {
        case PREVIEW:
            getSnapshotDao().updateStatus(getSnapshotDao().getId(getVmId(), SnapshotType.REGULAR, SnapshotStatus.IN_PREVIEW), SnapshotStatus.OK);
            getParameters().setImages((List<DiskImage>) CollectionUtils.union(imagesFromPreviewSnapshot, intersection));
            imagesFromPreviewSnapshot.forEach(image -> {
                if (image.getDiskStorageType() != DiskStorageType.CINDER) {
                    imagesToRestore.add(image);
                } else {
                    List<DiskImage> cinderDiskFromPreviewSnapshot = intersection.stream().filter(diskImage -> diskImage.getId().equals(image.getId())).collect(Collectors.toList());
                    if (!cinderDiskFromPreviewSnapshot.isEmpty()) {
                        imagesToRestore.add(cinderDiskFromPreviewSnapshot.get(0));
                    }
                }
            });
            updateSnapshotIdForSkipRestoreImages(ImagesHandler.imagesSubtract(imagesFromActiveSnapshot, imagesToRestore), targetSnapshot.getId());
            restoreConfiguration(targetSnapshot);
            break;
        case STATELESS:
            imagesToRestore = getParameters().getImages();
            restoreConfiguration(targetSnapshot);
            break;
        case REGULAR:
            prepareToDeletePreviewBranch(imagesFromActiveSnapshot);
            // Set the active snapshot's images as target images for restore, because they are what we keep.
            getParameters().setImages(imagesFromActiveSnapshot);
            imagesFromActiveSnapshot.forEach(image -> {
                List<DiskImage> cinderDiskFromPreviewSnapshot = imagesFromPreviewSnapshot.stream().filter(diskImage -> diskImage.getId().equals(image.getId())).collect(Collectors.toList());
                if (!cinderDiskFromPreviewSnapshot.isEmpty()) {
                    if (image.getDiskStorageType() == DiskStorageType.IMAGE) {
                        imagesToRestore.add(image);
                    } else if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                        CinderDisk cinderVolume = getInitialCinderVolumeToDelete(image);
                        if (cinderVolume != null) {
                            imagesToRestore.add(cinderVolume);
                        }
                    }
                }
            });
            updateSnapshotIdForSkipRestoreImages(ImagesHandler.imagesSubtract(imagesFromActiveSnapshot, imagesToRestore), activeSnapshotId);
            break;
        default:
            throw new EngineException(EngineError.ENGINE, "No support for restoring to snapshot type: " + targetSnapshot.getType());
    }
}
#method_after
protected void restoreSnapshotAndRemoveObsoleteSnapshots(Snapshot targetSnapshot) {
    Guid activeSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE);
    List<DiskImage> imagesFromActiveSnapshot = getDiskImageDao().getAllSnapshotsForVmSnapshot(activeSnapshotId);
    Snapshot previewedSnapshot = getSnapshotDao().get(getVmId(), SnapshotType.PREVIEW);
    if (previewedSnapshot != null) {
        VM vmFromConf = snapshotVmConfigurationHelper.getVmFromConfiguration(previewedSnapshot.getVmConfiguration(), previewedSnapshot.getVmId(), previewedSnapshot.getId());
        List<DiskImage> previewedImagesFromDB = getDiskImageDao().getAllSnapshotsForVmSnapshot(previewedSnapshot.getId());
        imagesFromPreviewSnapshot.addAll(ImagesHandler.imagesIntersection(vmFromConf.getImages(), previewedImagesFromDB));
    }
    List<DiskImage> intersection = ImagesHandler.imagesIntersection(imagesFromActiveSnapshot, imagesFromPreviewSnapshot);
    switch(targetSnapshot.getType()) {
        case PREVIEW:
            getSnapshotDao().updateStatus(getSnapshotDao().getId(getVmId(), SnapshotType.REGULAR, SnapshotStatus.IN_PREVIEW), SnapshotStatus.OK);
            getParameters().setImages((List<DiskImage>) CollectionUtils.union(imagesFromPreviewSnapshot, intersection));
            imagesFromPreviewSnapshot.forEach(image -> {
                if (image.getDiskStorageType() != DiskStorageType.CINDER) {
                    imagesToRestore.add(image);
                } else {
                    List<DiskImage> cinderDiskFromPreviewSnapshot = intersection.stream().filter(diskImage -> diskImage.getId().equals(image.getId())).collect(Collectors.toList());
                    if (!cinderDiskFromPreviewSnapshot.isEmpty()) {
                        imagesToRestore.add(cinderDiskFromPreviewSnapshot.get(0));
                    }
                }
            });
            updateSnapshotIdForSkipRestoreImages(ImagesHandler.imagesSubtract(imagesFromActiveSnapshot, imagesToRestore), targetSnapshot.getId());
            restoreConfiguration(targetSnapshot);
            break;
        case STATELESS:
            imagesToRestore = getParameters().getImages();
            restoreConfiguration(targetSnapshot);
            break;
        case REGULAR:
            prepareToDeletePreviewBranch(imagesFromActiveSnapshot);
            // Set the active snapshot's images as target images for restore, because they are what we keep.
            getParameters().setImages(imagesFromActiveSnapshot);
            imagesFromActiveSnapshot.forEach(image -> {
                List<DiskImage> cinderDiskFromPreviewSnapshot = imagesFromPreviewSnapshot.stream().filter(diskImage -> diskImage.getId().equals(image.getId())).collect(Collectors.toList());
                if (!cinderDiskFromPreviewSnapshot.isEmpty()) {
                    if (image.getDiskStorageType() == DiskStorageType.IMAGE) {
                        imagesToRestore.add(image);
                    } else if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                        CinderDisk cinderVolume = getInitialCinderVolumeToDelete(image);
                        if (cinderVolume != null) {
                            imagesToRestore.add(cinderVolume);
                        }
                    }
                }
            });
            updateSnapshotIdForSkipRestoreImages(ImagesHandler.imagesSubtract(imagesFromActiveSnapshot, imagesToRestore), activeSnapshotId);
            break;
        default:
            throw new EngineException(EngineError.ENGINE, "No support for restoring to snapshot type: " + targetSnapshot.getType());
    }
}
#end_block

#method_before
protected boolean performImagesChecks() {
    List<DiskImage> diskImagesToCheck = DisksFilter.filterImageDisks(getImagesList(), NOT_SHAREABLE_DISKS_ONLY, ACTIVE_DISKS_ONLY);
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
    return validate(diskImagesValidator.diskImagesNotLocked());
}
#method_after
protected boolean performImagesChecks() {
    List<DiskImage> diskImagesToCheck = DisksFilter.filterImageDisks(getImagesList(), ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
    return validate(diskImagesValidator.diskImagesNotLocked());
}
#end_block

#method_before
private List<DiskImage> getDiskImagesToValidate() {
    List<Disk> disks = getDiskDao().getAllForVm(getVmId());
    List<DiskImage> allDisks = DisksFilter.filterImageDisks(disks, NOT_SHAREABLE_DISKS_ONLY, ACTIVE_DISKS_ONLY);
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(disks);
    allDisks.addAll(cinderDisks);
    return allDisks;
}
#method_after
private List<DiskImage> getDiskImagesToValidate() {
    List<Disk> disks = getDiskDao().getAllForVm(getVmId());
    List<DiskImage> allDisks = DisksFilter.filterImageDisks(disks, ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(disks);
    allDisks.addAll(cinderDisks);
    return allDisks;
}
#end_block

#method_before
public ValidationResult vmNotHavingDeviceSnapshotsAttachedToOtherVms(boolean onlyPlugged) {
    List<Disk> vmDisks = getDbFacade().getDiskDao().getAllForVm(vm.getId());
    ValidationResult result = new DiskImagesValidator(DisksFilter.filterImageDisks(vmDisks, NOT_SHAREABLE_DISKS_ONLY, ACTIVE_DISKS_ONLY)).diskImagesSnapshotsNotAttachedToOtherVms(onlyPlugged);
    if (result != ValidationResult.VALID) {
        return result;
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult vmNotHavingDeviceSnapshotsAttachedToOtherVms(boolean onlyPlugged) {
    List<Disk> vmDisks = getDbFacade().getDiskDao().getAllForVm(vm.getId());
    ValidationResult result = new DiskImagesValidator(DisksFilter.filterImageDisks(vmDisks, ONLY_NOT_SHAREABLE, ONLY_ACTIVE)).diskImagesSnapshotsNotAttachedToOtherVms(onlyPlugged);
    if (result != ValidationResult.VALID) {
        return result;
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    Set<Guid> imagesToBeRemoved = new HashSet<>();
    List<DiskImage> images = getParameters().getImages();
    if (images == null) {
        images = DisksFilter.filterImageDisks(DbFacade.getInstance().getDiskDao().getAllForVm(getVmId()), NOT_SHAREABLE_DISKS_ONLY, ACTIVE_DISKS_ONLY);
    }
    for (DiskImage image : images) {
        if (Boolean.TRUE.equals(image.getActive())) {
            imagesToBeRemoved.add(image.getImageId());
        }
    }
    Collection<DiskImage> failedRemoving = new LinkedList<>();
    for (final DiskImage image : images) {
        if (imagesToBeRemoved.contains(image.getImageId())) {
            VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(VdcActionType.RemoveImage, buildRemoveImageParameters(image));
            if (vdcReturnValue.getSucceeded()) {
                getReturnValue().getInternalVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
            } else {
                StorageDomain domain = getStorageDomainDao().get(image.getStorageIds().get(0));
                failedRemoving.add(image);
                log.error("Can't remove image id '{}' for VM id '{}' from domain id '{}' due to: {}.", image.getImageId(), getParameters().getVmId(), image.getStorageIds().get(0), vdcReturnValue.getFault().getMessage());
                if (domain.getStorageDomainType() == StorageDomainType.Data) {
                    log.info("Image id '{}' will be set at illegal state with no snapshot id.", image.getImageId());
                    TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
                        // If VDSM task didn't succeed to initiate a task we change the disk to at illegal
                        // state.
                        updateDiskImagesToIllegal(image);
                        return true;
                    });
                } else {
                    log.info("Image id '{}' is not on a data domain and will not be marked as illegal.", image.getImageId());
                }
            }
        }
    }
    setActionReturnValue(failedRemoving);
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    Set<Guid> imagesToBeRemoved = new HashSet<>();
    List<DiskImage> images = getParameters().getImages();
    if (images == null) {
        images = DisksFilter.filterImageDisks(DbFacade.getInstance().getDiskDao().getAllForVm(getVmId()), ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
    }
    for (DiskImage image : images) {
        if (Boolean.TRUE.equals(image.getActive())) {
            imagesToBeRemoved.add(image.getImageId());
        }
    }
    Collection<DiskImage> failedRemoving = new LinkedList<>();
    for (final DiskImage image : images) {
        if (imagesToBeRemoved.contains(image.getImageId())) {
            VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(VdcActionType.RemoveImage, buildRemoveImageParameters(image));
            if (vdcReturnValue.getSucceeded()) {
                getReturnValue().getInternalVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
            } else {
                StorageDomain domain = getStorageDomainDao().get(image.getStorageIds().get(0));
                failedRemoving.add(image);
                log.error("Can't remove image id '{}' for VM id '{}' from domain id '{}' due to: {}.", image.getImageId(), getParameters().getVmId(), image.getStorageIds().get(0), vdcReturnValue.getFault().getMessage());
                if (domain.getStorageDomainType() == StorageDomainType.Data) {
                    log.info("Image id '{}' will be set at illegal state with no snapshot id.", image.getImageId());
                    TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
                        // If VDSM task didn't succeed to initiate a task we change the disk to at illegal
                        // state.
                        updateDiskImagesToIllegal(image);
                        return true;
                    });
                } else {
                    log.info("Image id '{}' is not on a data domain and will not be marked as illegal.", image.getImageId());
                }
            }
        }
    }
    setActionReturnValue(failedRemoving);
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected List<DiskImage> getVmDisksFromDB() {
    if (cachedDisksFromDb == null) {
        cachedDisksFromDb = DisksFilter.filterImageDisks(getVm().getDiskMap().values(), SNAPABLE_DISKS_ONLY, ACTIVE_DISKS_ONLY);
        cachedDisksFromDb.addAll(ImagesHandler.filterDisksBasedOnCinder(getVm().getDiskMap().values(), true));
    }
    return cachedDisksFromDb;
}
#method_after
@Override
protected List<DiskImage> getVmDisksFromDB() {
    if (cachedDisksFromDb == null) {
        cachedDisksFromDb = DisksFilter.filterImageDisks(getVm().getDiskMap().values(), ONLY_SNAPABLE, ONLY_ACTIVE);
        cachedDisksFromDb.addAll(ImagesHandler.filterDisksBasedOnCinder(getVm().getDiskMap().values(), true));
    }
    return cachedDisksFromDb;
}
#end_block

#method_before
protected VM getVmFromConfiguration() {
    VdcQueryReturnValue queryReturnValue = runInternalQuery(VdcQueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(getParameters().getSourceSnapshotId()));
    return queryReturnValue.getSucceeded() ? queryReturnValue.<VM>getReturnValue() : null;
}
#method_after
protected VM getVmFromConfiguration() {
    VdcQueryReturnValue queryReturnValue = runInternalQuery(VdcQueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(getParameters().getSourceSnapshotId()));
    return queryReturnValue.getSucceeded() ? queryReturnValue.getReturnValue() : null;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    List<DiskImage> templateDiskImages = DisksFilter.filterImageDisks(getVmTemplate().getDiskTemplateMap().values(), NOT_SHAREABLE_DISKS_ONLY);
    for (DiskImage dit : templateDiskImages) {
        DiskImage diskImage = diskInfoDestinationMap.get(dit.getId());
        if (!ImagesHandler.checkImageConfiguration(destStorages.get(diskImage.getStorageIds().get(0)).getStorageStaticData(), diskImage, getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    List<DiskImage> templateDiskImages = DisksFilter.filterImageDisks(getVmTemplate().getDiskTemplateMap().values(), ONLY_NOT_SHAREABLE);
    for (DiskImage dit : templateDiskImages) {
        DiskImage diskImage = diskInfoDestinationMap.get(dit.getId());
        if (!ImagesHandler.checkImageConfiguration(destStorages.get(diskImage.getStorageIds().get(0)).getStorageStaticData(), diskImage, getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean verifySourceDomains() {
    Map<Guid, StorageDomain> poolDomainsMap = Entities.businessEntitiesById(getPoolDomains());
    EnumSet<StorageDomainStatus> validDomainStatuses = EnumSet.of(StorageDomainStatus.Active);
    List<DiskImage> templateDiskImages = DisksFilter.filterImageDisks(getImagesToCheckDestinationStorageDomains(), NOT_SHAREABLE_DISKS_ONLY);
    validDisksDomains = ImagesHandler.findDomainsInApplicableStatusForDisks(templateDiskImages, poolDomainsMap, validDomainStatuses);
    return validate(new DiskImagesValidator(templateDiskImages).diskImagesOnAnyApplicableDomains(validDisksDomains, poolDomainsMap, EngineMessage.ACTION_TYPE_FAILED_NO_VALID_DOMAINS_STATUS_FOR_TEMPLATE_DISKS, validDomainStatuses));
}
#method_after
@Override
protected boolean verifySourceDomains() {
    Map<Guid, StorageDomain> poolDomainsMap = Entities.businessEntitiesById(getPoolDomains());
    EnumSet<StorageDomainStatus> validDomainStatuses = EnumSet.of(StorageDomainStatus.Active);
    List<DiskImage> templateDiskImages = DisksFilter.filterImageDisks(getImagesToCheckDestinationStorageDomains(), ONLY_NOT_SHAREABLE);
    validDisksDomains = ImagesHandler.findDomainsInApplicableStatusForDisks(templateDiskImages, poolDomainsMap, validDomainStatuses);
    return validate(new DiskImagesValidator(templateDiskImages).diskImagesOnAnyApplicableDomains(validDisksDomains, poolDomainsMap, EngineMessage.ACTION_TYPE_FAILED_NO_VALID_DOMAINS_STATUS_FOR_TEMPLATE_DISKS, validDomainStatuses));
}
#end_block

#method_before
@Override
protected void chooseDisksSourceDomains() {
    diskInfoSourceMap = new HashMap<>();
    List<DiskImage> templateDiskImages = DisksFilter.filterImageDisks(getImagesToCheckDestinationStorageDomains(), NOT_SHAREABLE_DISKS_ONLY);
    for (DiskImage disk : templateDiskImages) {
        Guid diskId = disk.getId();
        Set<Guid> validDomainsForDisk = validDisksDomains.get(diskId);
        Guid destinationDomain = retrieveDestinationDomainForDisk(diskId);
        // possibly faster operation, otherwise we'll choose random valid domain as the source.
        if (validDomainsForDisk.contains(destinationDomain)) {
            diskInfoSourceMap.put(diskId, destinationDomain);
        } else {
            diskInfoSourceMap.put(diskId, validDomainsForDisk.iterator().next());
        }
    }
}
#method_after
@Override
protected void chooseDisksSourceDomains() {
    diskInfoSourceMap = new HashMap<>();
    List<DiskImage> templateDiskImages = DisksFilter.filterImageDisks(getImagesToCheckDestinationStorageDomains(), ONLY_NOT_SHAREABLE);
    for (DiskImage disk : templateDiskImages) {
        Guid diskId = disk.getId();
        Set<Guid> validDomainsForDisk = validDisksDomains.get(diskId);
        Guid destinationDomain = retrieveDestinationDomainForDisk(diskId);
        // possibly faster operation, otherwise we'll choose random valid domain as the source.
        if (validDomainsForDisk.contains(destinationDomain)) {
            diskInfoSourceMap.put(diskId, destinationDomain);
        } else {
            diskInfoSourceMap.put(diskId, validDomainsForDisk.iterator().next());
        }
    }
}
#end_block

#method_before
private boolean isRemoveAutoGeneratedSnapshotRequired() {
    return getParameters().getStage() != LiveMigrateStage.CREATE_SNAPSHOT && getParameters().getStage() != LiveMigrateStage.AUTO_GENERATED_SNAPSHOT_REMOVE_END;
}
#method_after
private boolean isRemoveAutoGeneratedSnapshotRequired() {
    boolean removeSnapshotRequired = getParameters().getStage() != LiveMigrateStage.CREATE_SNAPSHOT && getParameters().getStage() != LiveMigrateStage.AUTO_GENERATED_SNAPSHOT_REMOVE_END;
    if (removeSnapshotRequired) {
        if (!getVm().getStatus().isQualifiedForLiveSnapshotMerge()) {
            // If the VM is not qualified for live merge, i.e. its status is not up, the auto-generated snapshot
            // is not removed. Removing the snapshot while the VM isn't running will end up with cold merge
            // and this is not desired here.
            // Once cold merge enhanced to use qemu-img commit, this limit can be removed. See BZ 1246114.
            // This behavior can be tracked by BZ 1369942.
            log.warn("Auto-generated snapshot cannot be removed because VM isn't qualified for live merge. VM status is '{}'", getVm().getStatus());
            removeSnapshotRequired = false;
        }
    }
    return removeSnapshotRequired;
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    Map<DiskImage, Guid> map = new HashMap<>();
    for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
        DiskImage diskImage = getDiskImageByImageId(parameters.getImageId());
        map.put(diskImage, diskImage.getStorageIds().get(0));
    }
    return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getCurrentUser()));
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    Map<DiskImage, Guid> map = new HashMap<>();
    for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
        DiskImage diskImage = getDiskImageByImageId(parameters.getImageId());
        map.put(diskImage, diskImage.getStorageIds().get(0));
    }
    return validate(diskProfileHelper.setAndValidateDiskProfiles(map, getCurrentUser()));
}
#end_block

#method_before
protected boolean checkImagesStatus() {
    List<DiskImage> disksToCheck = DisksFilter.filterImageDisks(getDiskDao().getAllForVm(getVmId()), NOT_SHAREABLE_DISKS_ONLY, ACTIVE_DISKS_ONLY);
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(disksToCheck);
    return validate(diskImagesValidator.diskImagesNotLocked()) && validate(diskImagesValidator.diskImagesHaveNotExceededMaxNumberOfVolumesInImageChain());
}
#method_after
protected boolean checkImagesStatus() {
    List<DiskImage> disksToCheck = DisksFilter.filterImageDisks(getDiskDao().getAllForVm(getVmId()), ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(disksToCheck);
    return validate(diskImagesValidator.diskImagesNotLocked()) && validate(diskImagesValidator.diskImagesHaveNotExceededMaxNumberOfVolumesInImageChain());
}
#end_block

#method_before
public static List<DiskImage> getPluggedActiveImagesForVm(Guid vmId) {
    return DisksFilter.filterImageDisks(DbFacade.getInstance().getDiskDao().getAllForVm(vmId, true), NOT_SHAREABLE_DISKS_ONLY, ACTIVE_DISKS_ONLY);
}
#method_after
public static List<DiskImage> getPluggedActiveImagesForVm(Guid vmId) {
    return DisksFilter.filterImageDisks(DbFacade.getInstance().getDiskDao().getAllForVm(vmId, true), ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
}
#end_block

#method_before
@Override
protected Collection<DiskImage> getAdjustedDiskImagesFromConfiguration() {
    if (diskImagesFromConfiguration == null) {
        diskImagesFromConfiguration = DisksFilter.filterImageDisks(vmFromConfiguration.getDiskMap().values(), SNAPABLE_DISKS_ONLY, ACTIVE_DISKS_ONLY);
        diskImagesFromConfiguration.addAll(ImagesHandler.filterDisksBasedOnCinder(vmFromConfiguration.getDiskMap().values(), true));
        adjustDisksImageConfiguration(diskImagesFromConfiguration);
    }
    return diskImagesFromConfiguration;
}
#method_after
@Override
protected Collection<DiskImage> getAdjustedDiskImagesFromConfiguration() {
    if (diskImagesFromConfiguration == null) {
        diskImagesFromConfiguration = DisksFilter.filterImageDisks(vmFromConfiguration.getDiskMap().values(), ONLY_SNAPABLE, ONLY_ACTIVE);
        diskImagesFromConfiguration.addAll(ImagesHandler.filterDisksBasedOnCinder(vmFromConfiguration.getDiskMap().values(), true));
        adjustDisksImageConfiguration(diskImagesFromConfiguration);
    }
    return diskImagesFromConfiguration;
}
#end_block

#method_before
public static boolean isVmTemplateImagesReady(VmTemplate vmTemplate, Guid storageDomainId, List<String> reasons, boolean checkImagesExists, boolean checkLocked, boolean checkIllegal, boolean checkStorageDomain, List<DiskImage> providedVmtImages) {
    boolean returnValue = true;
    List<DiskImage> vmtImages = providedVmtImages;
    if (checkStorageDomain) {
        StorageDomainValidator storageDomainValidator = new StorageDomainValidator(DbFacade.getInstance().getStorageDomainDao().getForStoragePool(storageDomainId, vmTemplate.getStoragePoolId()));
        ValidationResult res = storageDomainValidator.isDomainExistAndActive();
        returnValue = res.isValid();
        if (!returnValue) {
            reasons.addAll(res.getMessagesAsStrings());
            reasons.addAll(res.getVariableReplacements());
        }
    }
    if (returnValue && checkImagesExists) {
        if (vmtImages == null) {
            vmtImages = DisksFilter.filterImageDisks(DbFacade.getInstance().getDiskDao().getAllForVm(vmTemplate.getId()), ACTIVE_DISKS_ONLY);
        }
        if (vmtImages.size() > 0 && !ImagesHandler.isImagesExists(vmtImages, vmtImages.get(0).getStoragePoolId())) {
            reasons.add(EngineMessage.TEMPLATE_IMAGE_NOT_EXIST.toString());
            returnValue = false;
        }
    }
    if (returnValue && checkLocked) {
        if (vmTemplate.getStatus() == VmTemplateStatus.Locked) {
            returnValue = false;
        } else {
            if (vmtImages != null) {
                for (DiskImage image : vmtImages) {
                    if (image.getImageStatus() == ImageStatus.LOCKED) {
                        returnValue = false;
                        break;
                    }
                }
            }
        }
        if (!returnValue) {
            reasons.add(EngineMessage.VM_TEMPLATE_IMAGE_IS_LOCKED.toString());
        }
    }
    if (returnValue && checkIllegal && (vmTemplate.getStatus() == VmTemplateStatus.Illegal)) {
        returnValue = false;
        reasons.add(EngineMessage.VM_TEMPLATE_IMAGE_IS_ILLEGAL.toString());
    }
    return returnValue;
}
#method_after
public static boolean isVmTemplateImagesReady(VmTemplate vmTemplate, Guid storageDomainId, List<String> reasons, boolean checkImagesExists, boolean checkLocked, boolean checkIllegal, boolean checkStorageDomain, List<DiskImage> providedVmtImages) {
    boolean returnValue = true;
    List<DiskImage> vmtImages = providedVmtImages;
    if (checkStorageDomain) {
        StorageDomainValidator storageDomainValidator = new StorageDomainValidator(DbFacade.getInstance().getStorageDomainDao().getForStoragePool(storageDomainId, vmTemplate.getStoragePoolId()));
        ValidationResult res = storageDomainValidator.isDomainExistAndActive();
        returnValue = res.isValid();
        if (!returnValue) {
            reasons.addAll(res.getMessagesAsStrings());
            reasons.addAll(res.getVariableReplacements());
        }
    }
    if (returnValue && checkImagesExists) {
        if (vmtImages == null) {
            vmtImages = DisksFilter.filterImageDisks(DbFacade.getInstance().getDiskDao().getAllForVm(vmTemplate.getId()), ONLY_ACTIVE);
        }
        if (vmtImages.size() > 0 && !ImagesHandler.isImagesExists(vmtImages, vmtImages.get(0).getStoragePoolId())) {
            reasons.add(EngineMessage.TEMPLATE_IMAGE_NOT_EXIST.toString());
            returnValue = false;
        }
    }
    if (returnValue && checkLocked) {
        if (vmTemplate.getStatus() == VmTemplateStatus.Locked) {
            returnValue = false;
        } else {
            if (vmtImages != null) {
                for (DiskImage image : vmtImages) {
                    if (image.getImageStatus() == ImageStatus.LOCKED) {
                        returnValue = false;
                        break;
                    }
                }
            }
        }
        if (!returnValue) {
            reasons.add(EngineMessage.VM_TEMPLATE_IMAGE_IS_LOCKED.toString());
        }
    }
    if (returnValue && checkIllegal && (vmTemplate.getStatus() == VmTemplateStatus.Illegal)) {
        returnValue = false;
        reasons.add(EngineMessage.VM_TEMPLATE_IMAGE_IS_ILLEGAL.toString());
    }
    return returnValue;
}
#end_block

#method_before
protected void moveOrCopyAllImageGroups() {
    moveOrCopyAllImageGroups(getVm().getId(), DisksFilter.filterImageDisks(getVm().getDiskMap().values(), ACTIVE_DISKS_ONLY));
    copyAllMemoryImages(getVm().getId());
}
#method_after
protected void moveOrCopyAllImageGroups() {
    moveOrCopyAllImageGroups(getVm().getId(), DisksFilter.filterImageDisks(getVm().getDiskMap().values(), ONLY_ACTIVE));
    copyAllMemoryImages(getVm().getId());
}
#end_block

#method_before
private DiskImage createMemoryDisk(Snapshot snapshot) {
    List<Guid> guids = GuidUtils.getGuidListFromString(snapshot.getMemoryVolume());
    SnapshotVmConfigurationHelper snapshotVmConfigurationHelper = new SnapshotVmConfigurationHelper();
    VM vm = snapshotVmConfigurationHelper.getVmFromConfiguration(snapshot.getVmConfiguration(), snapshot.getVmId(), snapshot.getId());
    DiskImage memoryDisk = MemoryUtils.createMemoryDisk(vm, getStorageDomainStaticDao().get(guids.get(0)).getStorageType());
    memoryDisk.setId(guids.get(2));
    memoryDisk.setImageId(guids.get(3));
    memoryDisk.setStorageIds(new ArrayList<>(Collections.singletonList(guids.get(0))));
    memoryDisk.setStoragePoolId(guids.get(1));
    memoryDisk.setCreationDate(snapshot.getCreationDate());
    return memoryDisk;
}
#method_after
private DiskImage createMemoryDisk(Snapshot snapshot) {
    List<Guid> guids = GuidUtils.getGuidListFromString(snapshot.getMemoryVolume());
    VM vm = snapshotVmConfigurationHelper.getVmFromConfiguration(snapshot.getVmConfiguration(), snapshot.getVmId(), snapshot.getId());
    DiskImage memoryDisk = MemoryUtils.createMemoryDisk(vm, getStorageDomainStaticDao().get(guids.get(0)).getStorageType());
    memoryDisk.setId(guids.get(2));
    memoryDisk.setImageId(guids.get(3));
    memoryDisk.setStorageIds(new ArrayList<>(Collections.singletonList(guids.get(0))));
    memoryDisk.setStoragePoolId(guids.get(1));
    memoryDisk.setCreationDate(snapshot.getCreationDate());
    return memoryDisk;
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    if (getParameters().getVm().getDiskMap() != null) {
        Map<DiskImage, Guid> map = new HashMap<>();
        for (Disk disk : getParameters().getVm().getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                map.put(diskImage, imageToDestinationDomainMap.get(diskImage.getId()));
            }
        }
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getCurrentUser()));
    }
    return true;
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    if (getParameters().getVm().getDiskMap() != null) {
        Map<DiskImage, Guid> map = new HashMap<>();
        for (Disk disk : getParameters().getVm().getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                map.put(diskImage, imageToDestinationDomainMap.get(diskImage.getId()));
            }
        }
        return validate(diskProfileHelper.setAndValidateDiskProfiles(map, getCurrentUser()));
    }
    return true;
}
#end_block

#method_before
private List<DiskImage> getDiskImagesToValidate() {
    List<Disk> disks = getDiskDao().getAllForVm(getSourceVmFromDb().getId());
    List<DiskImage> allDisks = DisksFilter.filterImageDisks(disks, NOT_SHAREABLE_DISKS_ONLY, ACTIVE_DISKS_ONLY);
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(disks, true);
    allDisks.addAll(cinderDisks);
    return allDisks;
}
#method_after
private List<DiskImage> getDiskImagesToValidate() {
    List<Disk> disks = getDiskDao().getAllForVm(getSourceVmFromDb().getId());
    List<DiskImage> allDisks = DisksFilter.filterImageDisks(disks, ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(disks, true);
    allDisks.addAll(cinderDisks);
    return allDisks;
}
#end_block

#method_before
public static void filterImageDisksForVM(VM vm) {
    List<DiskImage> filteredDisks = DisksFilter.filterImageDisks(vm.getDiskMap().values(), ACTIVE_DISKS_ONLY);
    List<CinderDisk> filteredCinderDisks = ImagesHandler.filterDisksBasedOnCinder(vm.getDiskMap().values());
    filteredDisks.addAll(filteredCinderDisks);
    @SuppressWarnings("unchecked")
    Collection<? extends Disk> vmDisksToRemove = CollectionUtils.subtract(vm.getDiskMap().values(), filteredDisks);
    vm.clearDisks();
    updateDisksForVm(vm, filteredDisks);
    for (Disk diskToRemove : vmDisksToRemove) {
        vm.getManagedVmDeviceMap().remove(diskToRemove.getId());
    }
}
#method_after
public static void filterImageDisksForVM(VM vm) {
    List<DiskImage> filteredDisks = DisksFilter.filterImageDisks(vm.getDiskMap().values(), ONLY_ACTIVE);
    List<CinderDisk> filteredCinderDisks = ImagesHandler.filterDisksBasedOnCinder(vm.getDiskMap().values());
    filteredDisks.addAll(filteredCinderDisks);
    @SuppressWarnings("unchecked")
    Collection<? extends Disk> vmDisksToRemove = CollectionUtils.subtract(vm.getDiskMap().values(), filteredDisks);
    vm.clearDisks();
    updateDisksForVm(vm, filteredDisks);
    for (Disk diskToRemove : vmDisksToRemove) {
        vm.getManagedVmDeviceMap().remove(diskToRemove.getId());
    }
}
#end_block

#method_before
protected ValidationResult isImagesExceededVolumesInImageChain() {
    List<DiskImage> allImageDisks = DisksFilter.filterImageDisks(getDiskDao().getAllForVm(vm.getId()), SNAPABLE_DISKS_ONLY);
    DiskImagesValidator diskImagesValidatorForChain = createDiskImageValidator(allImageDisks);
    return diskImagesValidatorForChain.diskImagesHaveNotExceededMaxNumberOfVolumesInImageChain();
}
#method_after
protected ValidationResult isImagesExceededVolumesInImageChain() {
    List<DiskImage> allImageDisks = DisksFilter.filterImageDisks(getDiskDao().getAllForVm(vm.getId()), ONLY_SNAPABLE);
    DiskImagesValidator diskImagesValidatorForChain = createDiskImageValidator(allImageDisks);
    return diskImagesValidatorForChain.diskImagesHaveNotExceededMaxNumberOfVolumesInImageChain();
}
#end_block

#method_before
protected ValidationResult hasSpaceForSnapshots() {
    List<Disk> disks = DbFacade.getInstance().getDiskDao().getAllForVm(vm.getId());
    List<DiskImage> allDisks = DisksFilter.filterImageDisks(disks, SNAPABLE_DISKS_ONLY);
    Set<Guid> sdIds = ImagesHandler.getAllStorageIdsForImageIds(allDisks);
    MultipleStorageDomainsValidator msdValidator = getStorageDomainsValidator(sdIds);
    ValidationResult retVal = msdValidator.allDomainsWithinThresholds();
    if (retVal == ValidationResult.VALID) {
        return msdValidator.allDomainsHaveSpaceForNewDisks(allDisks);
    }
    return retVal;
}
#method_after
protected ValidationResult hasSpaceForSnapshots() {
    List<Disk> disks = DbFacade.getInstance().getDiskDao().getAllForVm(vm.getId());
    List<DiskImage> allDisks = DisksFilter.filterImageDisks(disks, ONLY_SNAPABLE);
    Set<Guid> sdIds = ImagesHandler.getAllStorageIdsForImageIds(allDisks);
    MultipleStorageDomainsValidator msdValidator = getStorageDomainsValidator(sdIds);
    ValidationResult retVal = msdValidator.allDomainsWithinThresholds();
    if (retVal == ValidationResult.VALID) {
        return msdValidator.allDomainsHaveSpaceForNewDisks(allDisks);
    }
    return retVal;
}
#end_block

#method_before
private List<DiskImage> getVmImageDisks() {
    if (cachedVmImageDisks == null) {
        cachedVmImageDisks = DisksFilter.filterImageDisks(getVmDisks(), NOT_SHAREABLE_DISKS_ONLY);
        cachedVmImageDisks.addAll(ImagesHandler.filterDisksBasedOnCinder(getVmDisks(), true));
    }
    return cachedVmImageDisks;
}
#method_after
private List<DiskImage> getVmImageDisks() {
    if (cachedVmImageDisks == null) {
        cachedVmImageDisks = DisksFilter.filterImageDisks(getVmDisks(), ONLY_NOT_SHAREABLE);
        cachedVmImageDisks.addAll(ImagesHandler.filterDisksBasedOnCinder(getVmDisks(), true));
    }
    return cachedVmImageDisks;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    final boolean restoreMemory = getParameters().isRestoreMemory() && FeatureSupported.isMemorySnapshotSupportedByArchitecture(getVm().getClusterArch(), getVm().getCompatibilityVersion());
    final Guid newActiveSnapshotId = Guid.newGuid();
    final Snapshot snapshotToBePreviewed = getDstSnapshot();
    final Snapshot previousActiveSnapshot = getSnapshotDao().get(getVmId(), SnapshotType.ACTIVE);
    final Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
    final List<DiskImage> images = getImagesToPreview();
    // Images list without those that are excluded from preview
    final List<DiskImage> filteredImages = (List<DiskImage>) CollectionUtils.subtract(images, getImagesExcludedFromPreview(images, previousActiveSnapshotId, newActiveSnapshotId));
    final List<CinderDisk> cinderDisks = new ArrayList<>();
    TransactionSupport.executeInNewTransaction(() -> {
        getCompensationContext().snapshotEntity(previousActiveSnapshot);
        getSnapshotDao().remove(previousActiveSnapshotId);
        getSnapshotsManager().addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotType.PREVIEW, getVm(), previousActiveSnapshot.getMemoryVolume(), getCompensationContext());
        getSnapshotsManager().addActiveSnapshot(newActiveSnapshotId, getVm(), restoreMemory ? snapshotToBePreviewed.getMemoryVolume() : StringUtils.EMPTY, images, getCompensationContext());
        // being executed in the same transaction so we can restore the vm config and end the command.
        if (!filteredImages.isEmpty()) {
            getCompensationContext().stateChanged();
        } else {
            getVmStaticDao().incrementDbGeneration(getVm().getId());
            restoreVmConfigFromSnapshot();
        }
        return null;
    });
    if (!filteredImages.isEmpty()) {
        VmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : filteredImages) {
                    if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                        cinderDisks.add((CinderDisk) image);
                        continue;
                    }
                    VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(VdcActionType.TryBackToSnapshot, buildTryBackToSnapshotParameters(newActiveSnapshotId, image));
                    if (vdcReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                    } else if (vdcReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new EngineException(vdcReturnValue.getFault().getError(), vdcReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                if (!cinderDisks.isEmpty() && !tryBackAllCinderDisks(cinderDisks, newActiveSnapshotId)) {
                    throw new EngineException(EngineError.CINDER_ERROR, "Failed to preview a snapshot!");
                }
                return null;
            }

            private ImagesContainterParametersBase buildTryBackToSnapshotParameters(final Guid newActiveSnapshotId, DiskImage image) {
                ImagesContainterParametersBase params = new ImagesContainterParametersBase(image.getImageId());
                params.setParentCommand(VdcActionType.TryBackToAllSnapshotsOfVm);
                params.setVmSnapshotId(newActiveSnapshotId);
                params.setEntityInfo(getParameters().getEntityInfo());
                params.setParentParameters(getParameters());
                params.setQuotaId(image.getQuotaId());
                return params;
            }
        });
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    final boolean restoreMemory = getParameters().isRestoreMemory() && FeatureSupported.isMemorySnapshotSupportedByArchitecture(getVm().getClusterArch(), getVm().getCompatibilityVersion());
    final Guid newActiveSnapshotId = Guid.newGuid();
    final Snapshot snapshotToBePreviewed = getDstSnapshot();
    final Snapshot previousActiveSnapshot = getSnapshotDao().get(getVmId(), SnapshotType.ACTIVE);
    final Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
    final List<DiskImage> images = getImagesToPreview();
    // Images list without those that are excluded from preview
    final List<DiskImage> filteredImages = (List<DiskImage>) CollectionUtils.subtract(images, getImagesExcludedFromPreview(images, previousActiveSnapshotId, newActiveSnapshotId));
    final List<CinderDisk> cinderDisks = new ArrayList<>();
    TransactionSupport.executeInNewTransaction(() -> {
        getCompensationContext().snapshotEntity(previousActiveSnapshot);
        getSnapshotDao().remove(previousActiveSnapshotId);
        getSnapshotsManager().addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotType.PREVIEW, getVm(), previousActiveSnapshot.getMemoryVolume(), getCompensationContext());
        getSnapshotsManager().addActiveSnapshot(newActiveSnapshotId, getVm(), restoreMemory ? snapshotToBePreviewed.getMemoryVolume() : StringUtils.EMPTY, images, getCompensationContext());
        // being executed in the same transaction so we can restore the vm config and end the command.
        if (!filteredImages.isEmpty()) {
            getCompensationContext().stateChanged();
        } else {
            getVmStaticDao().incrementDbGeneration(getVm().getId());
            restoreVmConfigFromSnapshot();
        }
        return null;
    });
    if (!filteredImages.isEmpty()) {
        VmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : filteredImages) {
                    if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                        cinderDisks.add((CinderDisk) image);
                        continue;
                    }
                    VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(VdcActionType.TryBackToSnapshot, buildTryBackToSnapshotParameters(newActiveSnapshotId, image));
                    if (vdcReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                    } else if (vdcReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new EngineException(vdcReturnValue.getFault().getError(), vdcReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                if (!cinderDisks.isEmpty() && !tryBackAllCinderDisks(cinderDisks, newActiveSnapshotId)) {
                    throw new EngineException(EngineError.CINDER_ERROR, "Failed to preview a snapshot!");
                }
                return null;
            }

            private ImagesContainterParametersBase buildTryBackToSnapshotParameters(final Guid newActiveSnapshotId, DiskImage image) {
                ImagesContainterParametersBase params = new ImagesContainterParametersBase(image.getImageId());
                params.setParentCommand(VdcActionType.TryBackToAllSnapshotsOfVm);
                params.setVmSnapshotId(newActiveSnapshotId);
                params.setEntityInfo(getParameters().getEntityInfo());
                params.setParentParameters(getParameters());
                params.setQuotaId(image.getQuotaId());
                return params;
            }
        });
    }
    if (restoreMemory && getVm().getCustomCompatibilityVersion() == null && (// taken in pre-3.6
    getVm().getClusterCompatibilityVersionOrigin() == null || getVm().getClusterCompatibilityVersionOrigin().less(getVm().getClusterCompatibilityVersion()))) {
        // the snapshot was taken before cluster version change, call the UpdateVmCommand
        // vm_static of the getVm() is just updated by the previewed OVF config, so reload before UpdateVmCommand
        VM vmFromDb = getVmDao().get(getVmId());
        if (!updateVm(vmFromDb, getVm().getClusterCompatibilityVersionOrigin())) {
            return;
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
private List<DiskImage> getImagesToPreview() {
    if (imagesToPreview == null) {
        imagesToPreview = getParameters().getDisks() != null ? getParameters().getDisks() : getDbFacade().getDiskImageDao().getAllSnapshotsForVmSnapshot(getDstSnapshot().getId());
        // Filter out shareable/nonsnapable disks
        List<CinderDisk> CinderImagesToPreview = ImagesHandler.filterDisksBasedOnCinder(imagesToPreview);
        imagesToPreview = DisksFilter.filterImageDisks(imagesToPreview, NOT_SHAREABLE_DISKS_ONLY, SNAPABLE_DISKS_ONLY);
        imagesToPreview.addAll(CinderImagesToPreview);
    }
    return imagesToPreview;
}
#method_after
private List<DiskImage> getImagesToPreview() {
    if (imagesToPreview == null) {
        imagesToPreview = getParameters().getDisks() != null ? getParameters().getDisks() : getDbFacade().getDiskImageDao().getAllSnapshotsForVmSnapshot(getDstSnapshot().getId());
        // Filter out shareable/nonsnapable disks
        List<CinderDisk> CinderImagesToPreview = ImagesHandler.filterDisksBasedOnCinder(imagesToPreview);
        imagesToPreview = DisksFilter.filterImageDisks(imagesToPreview, ONLY_NOT_SHAREABLE, ONLY_SNAPABLE);
        imagesToPreview.addAll(CinderImagesToPreview);
    }
    return imagesToPreview;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (Guid.Empty.equals(getParameters().getDstSnapshotId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
    }
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    VmValidator vmValidator = new VmValidator(getVm());
    if (!validate(vmValidator.vmDown()) || !validate(snapshotsValidator.snapshotExists(getVmId(), getParameters().getDstSnapshotId())) || !validate(snapshotsValidator.vmNotDuringSnapshot(getVmId())) || !validate(snapshotsValidator.vmNotInPreview(getVmId()))) {
        return false;
    }
    updateVmDisksFromDb();
    List<DiskImage> diskImages = DisksFilter.filterImageDisks(getVm().getDiskMap().values(), NOT_SHAREABLE_DISKS_ONLY, SNAPABLE_DISKS_ONLY, ACTIVE_DISKS_ONLY);
    diskImages.addAll(ImagesHandler.filterDisksBasedOnCinder(getVm().getDiskMap().values(), true));
    if (!diskImages.isEmpty()) {
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImages);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        DiskImagesValidator diskImagesToPreviewValidator = new DiskImagesValidator(getImagesToPreview());
        if (!validate(diskImagesToPreviewValidator.diskImagesNotIllegal()) || !validate(diskImagesToPreviewValidator.diskImagesNotLocked())) {
            return false;
        }
        Set<Guid> storageIds = ImagesHandler.getAllStorageIdsForImageIds(diskImages);
        MultipleStorageDomainsValidator storageValidator = new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), storageIds);
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp()) || !validate(storageValidator.allDomainsExistAndActive()) || !validate(storageValidator.allDomainsWithinThresholds()) || !validateCinder()) {
            return false;
        }
    }
    DiskSnapshotsValidator diskSnapshotsValidator = new DiskSnapshotsValidator(getParameters().getDisks());
    if (!validate(diskSnapshotsValidator.canDiskSnapshotsBePreviewed(getParameters().getDstSnapshotId()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (Guid.Empty.equals(getParameters().getDstSnapshotId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
    }
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    VmValidator vmValidator = new VmValidator(getVm());
    if (!validate(vmValidator.vmDown()) || !validate(snapshotsValidator.snapshotExists(getVmId(), getParameters().getDstSnapshotId())) || !validate(snapshotsValidator.vmNotDuringSnapshot(getVmId())) || !validate(snapshotsValidator.vmNotInPreview(getVmId()))) {
        return false;
    }
    updateVmDisksFromDb();
    List<DiskImage> diskImages = DisksFilter.filterImageDisks(getVm().getDiskMap().values(), ONLY_NOT_SHAREABLE, ONLY_SNAPABLE, ONLY_ACTIVE);
    diskImages.addAll(ImagesHandler.filterDisksBasedOnCinder(getVm().getDiskMap().values(), true));
    if (!diskImages.isEmpty()) {
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImages);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        DiskImagesValidator diskImagesToPreviewValidator = new DiskImagesValidator(getImagesToPreview());
        if (!validate(diskImagesToPreviewValidator.diskImagesNotIllegal()) || !validate(diskImagesToPreviewValidator.diskImagesNotLocked())) {
            return false;
        }
        Set<Guid> storageIds = ImagesHandler.getAllStorageIdsForImageIds(diskImages);
        MultipleStorageDomainsValidator storageValidator = new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), storageIds);
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp()) || !validate(storageValidator.allDomainsExistAndActive()) || !validate(storageValidator.allDomainsWithinThresholds()) || !validateCinder()) {
            return false;
        }
    }
    DiskSnapshotsValidator diskSnapshotsValidator = new DiskSnapshotsValidator(getParameters().getDisks());
    if (!validate(diskSnapshotsValidator.canDiskSnapshotsBePreviewed(getParameters().getDstSnapshotId()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
protected void executeCommand() {
    List<DiskImage> imageTemplates = DisksFilter.filterImageDisks(DbFacade.getInstance().getDiskDao().getAllForVm(getVmTemplateId()));
    for (DiskImage template : imageTemplates) {
        // remove this disk in all domain that were sent
        for (Guid domain : (Collection<Guid>) CollectionUtils.intersection(getParameters().getStorageDomainsList(), template.getStorageIds())) {
            ImagesContainterParametersBase tempVar = new ImagesContainterParametersBase(template.getImageId(), getVmTemplateId());
            tempVar.setStorageDomainId(domain);
            tempVar.setStoragePoolId(template.getStoragePoolId());
            tempVar.setImageGroupID(template.getId());
            tempVar.setEntityInfo(getParameters().getEntityInfo());
            tempVar.setWipeAfterDelete(template.isWipeAfterDelete());
            tempVar.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
            tempVar.setParentCommand(getActionType());
            tempVar.setParentParameters(getParameters());
            VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(VdcActionType.RemoveTemplateSnapshot, tempVar);
            if (vdcReturnValue.getSucceeded()) {
                getReturnValue().getInternalVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
            } else {
                log.error("Can't remove image id '{}' for template id '{}' from domain id '{}' due to: {}.", template.getImageId(), getVmTemplateId(), domain, vdcReturnValue.getFault().getMessage());
            }
            DbFacade.getInstance().getImageStorageDomainMapDao().remove(new ImageStorageDomainMapId(template.getImageId(), domain));
        }
        DiskImage diskImage = DbFacade.getInstance().getDiskImageDao().get(template.getImageId());
        if (diskImage != null) {
            DbFacade.getInstance().getBaseDiskDao().remove(template.getId());
            DbFacade.getInstance().getVmDeviceDao().remove(new VmDeviceId(diskImage.getImageId(), getVmTemplateId()));
            DbFacade.getInstance().getImageStorageDomainMapDao().remove(diskImage.getImageId());
            DbFacade.getInstance().getImageDao().remove(template.getImageId());
        }
    }
    setSucceeded(true);
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected void executeCommand() {
    List<DiskImage> imageTemplates = DisksFilter.filterImageDisks(DbFacade.getInstance().getDiskDao().getAllForVm(getVmTemplateId()), ONLY_ACTIVE);
    for (DiskImage template : imageTemplates) {
        // remove this disk in all domain that were sent
        for (Guid domain : (Collection<Guid>) CollectionUtils.intersection(getParameters().getStorageDomainsList(), template.getStorageIds())) {
            ImagesContainterParametersBase tempVar = new ImagesContainterParametersBase(template.getImageId(), getVmTemplateId());
            tempVar.setStorageDomainId(domain);
            tempVar.setStoragePoolId(template.getStoragePoolId());
            tempVar.setImageGroupID(template.getId());
            tempVar.setEntityInfo(getParameters().getEntityInfo());
            tempVar.setWipeAfterDelete(template.isWipeAfterDelete());
            tempVar.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
            tempVar.setParentCommand(getActionType());
            tempVar.setParentParameters(getParameters());
            VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(VdcActionType.RemoveTemplateSnapshot, tempVar);
            if (vdcReturnValue.getSucceeded()) {
                getReturnValue().getInternalVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
            } else {
                log.error("Can't remove image id '{}' for template id '{}' from domain id '{}' due to: {}.", template.getImageId(), getVmTemplateId(), domain, vdcReturnValue.getFault().getMessage());
            }
            DbFacade.getInstance().getImageStorageDomainMapDao().remove(new ImageStorageDomainMapId(template.getImageId(), domain));
        }
        DiskImage diskImage = DbFacade.getInstance().getDiskImageDao().get(template.getImageId());
        if (diskImage != null) {
            DbFacade.getInstance().getBaseDiskDao().remove(template.getId());
            DbFacade.getInstance().getVmDeviceDao().remove(new VmDeviceId(diskImage.getImageId(), getVmTemplateId()));
            DbFacade.getInstance().getImageStorageDomainMapDao().remove(diskImage.getImageId());
            DbFacade.getInstance().getImageDao().remove(template.getImageId());
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
private boolean removeVm() {
    final List<DiskImage> diskImages = DisksFilter.filterImageDisks(getVm().getDiskList(), NOT_SHAREABLE_DISKS_ONLY, ACTIVE_DISKS_ONLY);
    final List<LunDisk> lunDisks = ImagesHandler.filterDiskBasedOnLuns(getVm().getDiskMap().values(), false);
    for (VmNic nic : getInterfaces()) {
        new ExternalNetworkManager(nic).deallocateIfExternal();
    }
    removeMemoryVolumes();
    TransactionSupport.executeInNewTransaction(() -> {
        removeVmFromDb();
        if (getParameters().isRemoveDisks()) {
            for (DiskImage image : diskImages) {
                getCompensationContext().snapshotEntityStatus(image.getImage(), ImageStatus.ILLEGAL);
                ImagesHandler.updateImageStatus(image.getImage().getId(), ImageStatus.LOCKED);
            }
            for (LunDisk lunDisk : lunDisks) {
                ImagesHandler.removeLunDisk(lunDisk);
            }
            getCompensationContext().stateChanged();
        } else {
            for (DiskImage image : diskImages) {
                getImageDao().updateImageVmSnapshotId(image.getImageId(), null);
            }
        }
        return null;
    });
    Collection<DiskImage> unremovedDisks = Collections.emptyList();
    if (getParameters().isRemoveDisks()) {
        if (!diskImages.isEmpty()) {
            unremovedDisks = removeVmImages(diskImages).getActionReturnValue();
        }
        unremovedDisks.addAll(removeCinderDisks());
        if (!unremovedDisks.isEmpty()) {
            processUnremovedDisks(unremovedDisks);
            return false;
        }
    }
    vmDeleted.fire(getVmId());
    return true;
}
#method_after
private boolean removeVm() {
    final List<DiskImage> diskImages = DisksFilter.filterImageDisks(getVm().getDiskList(), ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
    final List<LunDisk> lunDisks = ImagesHandler.filterDiskBasedOnLuns(getVm().getDiskMap().values(), false);
    for (VmNic nic : getInterfaces()) {
        new ExternalNetworkManager(nic).deallocateIfExternal();
    }
    removeMemoryVolumes();
    TransactionSupport.executeInNewTransaction(() -> {
        removeVmFromDb();
        if (getParameters().isRemoveDisks()) {
            for (DiskImage image : diskImages) {
                getCompensationContext().snapshotEntityStatus(image.getImage(), ImageStatus.ILLEGAL);
                ImagesHandler.updateImageStatus(image.getImage().getId(), ImageStatus.LOCKED);
            }
            for (LunDisk lunDisk : lunDisks) {
                ImagesHandler.removeLunDisk(lunDisk);
            }
            getCompensationContext().stateChanged();
        } else {
            for (DiskImage image : diskImages) {
                getImageDao().updateImageVmSnapshotId(image.getImageId(), null);
            }
        }
        return null;
    });
    Collection<DiskImage> unremovedDisks = Collections.emptyList();
    if (getParameters().isRemoveDisks()) {
        if (!diskImages.isEmpty()) {
            unremovedDisks = removeVmImages(diskImages).getActionReturnValue();
        }
        unremovedDisks.addAll(removeCinderDisks());
        if (!unremovedDisks.isEmpty()) {
            processUnremovedDisks(unremovedDisks);
            return false;
        }
    }
    vmDeleted.fire(getVmId());
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().isDeleteProtected()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DELETE_PROTECTION_ENABLED);
    }
    VmHandler.updateDisksFromDb(getVm());
    getParameters().setUseCinderCommandCallback(getParameters().isRemoveDisks() && !getCinderDisks().isEmpty());
    if (!getParameters().isRemoveDisks() && !canRemoveVmWithDetachDisks()) {
        return false;
    }
    switch(getVm().getStatus()) {
        case Unassigned:
        case Down:
        case ImageIllegal:
        case ImageLocked:
            break;
        case Suspended:
            return failValidation(EngineMessage.VM_CANNOT_REMOVE_VM_WHEN_STATUS_IS_NOT_DOWN);
        default:
            return (getVm().isHostedEngine() && isInternalExecution()) || failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_RUNNING);
    }
    if (getVm().getVmPoolId() != null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_ATTACHED_TO_POOL);
    }
    // enable to remove vms without images
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    if (!validate(snapshotsValidator.vmNotDuringSnapshot(getVmId()))) {
        return false;
    }
    if (!getVm().getDiskMap().isEmpty() && !validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    Collection<Disk> vmDisks = getVm().getDiskMap().values();
    List<DiskImage> vmImages = DisksFilter.filterImageDisks(vmDisks, NOT_SHAREABLE_DISKS_ONLY, ACTIVE_DISKS_ONLY);
    vmImages.addAll(ImagesHandler.filterDisksBasedOnCinder(vmDisks));
    if (!vmImages.isEmpty()) {
        Set<Guid> storageIds = ImagesHandler.getAllStorageIdsForImageIds(vmImages);
        MultipleStorageDomainsValidator storageValidator = new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), storageIds);
        if (!validate(storageValidator.allDomainsExistAndActive())) {
            return false;
        }
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(vmImages);
        if (!getParameters().getForce() && !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
    }
    // Handle VM status with ImageLocked
    VmValidator vmValidator = new VmValidator(getVm());
    ValidationResult vmLockedValidatorResult = vmValidator.vmNotLocked();
    if (!vmLockedValidatorResult.isValid()) {
        // without force remove, we can't remove the VM
        if (!getParameters().getForce()) {
            return failValidation(vmLockedValidatorResult.getMessages());
        }
        // If it is force, we cannot remove if there are task
        if (CommandCoordinatorUtil.hasTasksByStoragePoolId(getVm().getStoragePoolId())) {
            return failValidation(EngineMessage.VM_CANNOT_REMOVE_HAS_RUNNING_TASKS);
        }
    }
    if (getParameters().isRemoveDisks() && !validate(vmValidator.vmNotHavingDeviceSnapshotsAttachedToOtherVms(false))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().isDeleteProtected()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DELETE_PROTECTION_ENABLED);
    }
    VmHandler.updateDisksFromDb(getVm());
    getParameters().setUseCinderCommandCallback(getParameters().isRemoveDisks() && !getCinderDisks().isEmpty());
    if (!getParameters().isRemoveDisks() && !canRemoveVmWithDetachDisks()) {
        return false;
    }
    switch(getVm().getStatus()) {
        case Unassigned:
        case Down:
        case ImageIllegal:
        case ImageLocked:
            break;
        case Suspended:
            return failValidation(EngineMessage.VM_CANNOT_REMOVE_VM_WHEN_STATUS_IS_NOT_DOWN);
        default:
            return (getVm().isHostedEngine() && isInternalExecution()) || failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_RUNNING);
    }
    if (getVm().getVmPoolId() != null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_ATTACHED_TO_POOL);
    }
    // enable to remove vms without images
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    if (!validate(snapshotsValidator.vmNotDuringSnapshot(getVmId()))) {
        return false;
    }
    if (!getVm().getDiskMap().isEmpty() && !validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    Collection<Disk> vmDisks = getVm().getDiskMap().values();
    List<DiskImage> vmImages = DisksFilter.filterImageDisks(vmDisks, ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
    vmImages.addAll(ImagesHandler.filterDisksBasedOnCinder(vmDisks));
    if (!vmImages.isEmpty()) {
        Set<Guid> storageIds = ImagesHandler.getAllStorageIdsForImageIds(vmImages);
        MultipleStorageDomainsValidator storageValidator = new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), storageIds);
        if (!validate(storageValidator.allDomainsExistAndActive())) {
            return false;
        }
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(vmImages);
        if (!getParameters().getForce() && !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
    }
    // Handle VM status with ImageLocked
    VmValidator vmValidator = new VmValidator(getVm());
    ValidationResult vmLockedValidatorResult = vmValidator.vmNotLocked();
    if (!vmLockedValidatorResult.isValid()) {
        // without force remove, we can't remove the VM
        if (!getParameters().getForce()) {
            return failValidation(vmLockedValidatorResult.getMessages());
        }
        // If it is force, we cannot remove if there are task
        if (CommandCoordinatorUtil.hasTasksByStoragePoolId(getVm().getStoragePoolId())) {
            return failValidation(EngineMessage.VM_CANNOT_REMOVE_HAS_RUNNING_TASKS);
        }
    }
    if (getParameters().isRemoveDisks() && !validate(vmValidator.vmNotHavingDeviceSnapshotsAttachedToOtherVms(false))) {
        return false;
    }
    return true;
}
#end_block

#method_before
private void removeDiskImages() {
    List<DiskImage> images = DisksFilter.filterImageDisks(getVm().getDiskMap().values(), NOT_SHAREABLE_DISKS_ONLY, ACTIVE_DISKS_ONLY);
    for (DiskImage image : images) {
        image.setStorageIds(new ArrayList<>(Arrays.asList(getParameters().getStorageDomainId())));
        image.setStoragePoolId(getParameters().getStoragePoolId());
    }
    removeVmImages(images);
}
#method_after
private void removeDiskImages() {
    List<DiskImage> images = DisksFilter.filterImageDisks(getVm().getDiskMap().values(), ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
    for (DiskImage image : images) {
        image.setStorageIds(new ArrayList<>(Arrays.asList(getParameters().getStorageDomainId())));
        image.setStoragePoolId(getParameters().getStoragePoolId());
    }
    removeVmImages(images);
}
#end_block

#method_before
private boolean canRemoveVmImageDisk() {
    if (!listVms.isEmpty()) {
        Guid storagePoolId = listVms.get(0).getStoragePoolId();
        StoragePool sp = getStoragePoolDao().get(storagePoolId);
        if (!validate(new StoragePoolValidator(sp).isUp())) {
            return false;
        }
        List<DiskImage> diskList = DisksFilter.filterImageDisks(Collections.singletonList(getDisk()), NOT_SHAREABLE_DISKS_ONLY, ACTIVE_DISKS_ONLY);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskList);
        if (!validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
    }
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    for (VM vm : listVms) {
        if (!validate(snapshotsValidator.vmNotDuringSnapshot(vm.getId())) || !validate(snapshotsValidator.vmNotInPreview(vm.getId()))) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean canRemoveVmImageDisk() {
    if (!listVms.isEmpty()) {
        Guid storagePoolId = listVms.get(0).getStoragePoolId();
        StoragePool sp = getStoragePoolDao().get(storagePoolId);
        if (!validate(new StoragePoolValidator(sp).isUp())) {
            return false;
        }
        List<DiskImage> diskList = DisksFilter.filterImageDisks(Collections.singletonList(getDisk()), ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskList);
        if (!validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
    }
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    for (VM vm : listVms) {
        if (!validate(snapshotsValidator.vmNotDuringSnapshot(vm.getId())) || !validate(snapshotsValidator.vmNotInPreview(vm.getId()))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected String generateVmConfiguration(VM vm, List<DiskImage> disks, Map<Guid, VmDevice> vmDevices) {
    if (vm.getInterfaces() == null || vm.getInterfaces().isEmpty()) {
        vm.setInterfaces(getVmNetworkInterfaceDao().getAllForVm(vm.getId()));
    }
    if (StringUtils.isEmpty(vm.getVmtName())) {
        VmTemplate t = getVmTemplateDao().get(vm.getVmtGuid());
        vm.setVmtName(t.getName());
    }
    if (vmDevices == null) {
        vmDeviceUtils.setVmDevices(vm.getStaticData());
    } else {
        vm.getStaticData().setManagedDeviceMap(vmDevices);
    }
    if (disks == null) {
        disks = DisksFilter.filterImageDisks(getDiskDao().getAllForVm(vm.getId()), SNAPABLE_DISKS_ONLY, ACTIVE_DISKS_ONLY);
        disks.addAll(ImagesHandler.getCinderLeafImages(getDiskDao().getAllForVm(vm.getId()), false));
    }
    populateDisksWithVmData(disks, vm.getId());
    for (DiskImage image : disks) {
        image.setStorageIds(null);
    }
    return new OvfManager().exportVm(vm, new ArrayList<>(disks), ClusterUtils.getCompatibilityVersion(vm));
}
#method_after
protected String generateVmConfiguration(VM vm, List<DiskImage> disks, Map<Guid, VmDevice> vmDevices) {
    if (vm.getInterfaces() == null || vm.getInterfaces().isEmpty()) {
        vm.setInterfaces(getVmNetworkInterfaceDao().getAllForVm(vm.getId()));
    }
    if (StringUtils.isEmpty(vm.getVmtName())) {
        VmTemplate t = getVmTemplateDao().get(vm.getVmtGuid());
        vm.setVmtName(t.getName());
    }
    if (vmDevices == null) {
        vmDeviceUtils.setVmDevices(vm.getStaticData());
    } else {
        vm.getStaticData().setManagedDeviceMap(vmDevices);
    }
    if (disks == null) {
        disks = DisksFilter.filterImageDisks(getDiskDao().getAllForVm(vm.getId()), ONLY_SNAPABLE, ONLY_ACTIVE);
        disks.addAll(ImagesHandler.getCinderLeafImages(getDiskDao().getAllForVm(vm.getId()), false));
    }
    populateDisksWithVmData(disks, vm.getId());
    for (DiskImage image : disks) {
        image.setStorageIds(null);
    }
    return new OvfManager().exportVm(vm, new ArrayList<>(disks), ClusterUtils.getCompatibilityVersion(vm));
}
#end_block

#method_before
public boolean updateVmFromConfiguration(VM vm, String configuration) {
    try {
        VmStatic oldVmStatic = vm.getStaticData();
        VM tempVM = new VM();
        ArrayList<DiskImage> images = new ArrayList<>();
        ArrayList<VmNetworkInterface> interfaces = new ArrayList<>();
        new OvfManager().importVm(configuration, tempVM, images, interfaces);
        for (DiskImage diskImage : images) {
            DiskImage dbImage = getDiskImageDao().getSnapshotById(diskImage.getImageId());
            if (dbImage != null) {
                diskImage.setStorageIds(dbImage.getStorageIds());
            }
        }
        new VMStaticOvfLogHandler(tempVM.getStaticData()).resetDefaults(oldVmStatic);
        vm.setStaticData(tempVM.getStaticData());
        IconUtils.preserveIcons(vm.getStaticData(), oldVmStatic);
        vm.setImages(images);
        vm.setInterfaces(interfaces);
        // These fields are not saved in the OVF, so get them from the current VM.
        vm.setIsoPath(oldVmStatic.getIsoPath());
        vm.setCpuProfileId(oldVmStatic.getCpuProfileId());
        vm.setClusterId(oldVmStatic.getClusterId());
        vm.setClusterCompatibilityVersionOrigin(oldVmStatic.getClusterCompatibilityVersionOrigin());
        // The VM configuration does not hold the vds group Id.
        // It is necessary to fetch the vm static from the Db, in order to get this information
        VmStatic vmStaticFromDb = getVmStaticDao().get(vm.getId());
        if (vmStaticFromDb != null) {
            Cluster cluster = getClusterDao().get(vmStaticFromDb.getClusterId());
            if (cluster != null) {
                vm.setStoragePoolId(cluster.getStoragePoolId());
                vm.setClusterCompatibilityVersion(cluster.getCompatibilityVersion());
                vm.setClusterName(cluster.getName());
                vm.setClusterCpuName(cluster.getCpuName());
            }
        }
        // if the required dedicated host is invalid -> use current VM dedicated host
        if (!VmHandler.validateDedicatedVdsExistOnSameCluster(vm.getStaticData(), null)) {
            vm.setDedicatedVmForVdsList(oldVmStatic.getDedicatedVmForVdsList());
        }
        validateQuota(vm);
        return true;
    } catch (OvfReaderException e) {
        log.error("Failed to update VM from the configuration '{}': {}", configuration, e.getMessage());
        log.debug("Exception", e);
        return false;
    }
}
#method_after
public boolean updateVmFromConfiguration(VM vm, String configuration) {
    try {
        VmStatic oldVmStatic = vm.getStaticData();
        VM tempVM = new VM();
        ArrayList<DiskImage> images = new ArrayList<>();
        ArrayList<VmNetworkInterface> interfaces = new ArrayList<>();
        new OvfManager().importVm(configuration, tempVM, images, interfaces);
        for (DiskImage diskImage : images) {
            DiskImage dbImage = getDiskImageDao().getSnapshotById(diskImage.getImageId());
            if (dbImage != null) {
                diskImage.setStorageIds(dbImage.getStorageIds());
            }
        }
        new VMStaticOvfLogHandler(tempVM.getStaticData()).resetDefaults(oldVmStatic);
        vm.setStaticData(tempVM.getStaticData());
        IconUtils.preserveIcons(vm.getStaticData(), oldVmStatic);
        vm.setImages(images);
        vm.setInterfaces(interfaces);
        // These fields are not saved in the OVF, so get them from the current VM.
        vm.setIsoPath(oldVmStatic.getIsoPath());
        vm.setCpuProfileId(oldVmStatic.getCpuProfileId());
        vm.setClusterId(oldVmStatic.getClusterId());
        // The VM configuration does not hold the vds group Id.
        // It is necessary to fetch the vm static from the Db, in order to get this information
        VmStatic vmStaticFromDb = getVmStaticDao().get(vm.getId());
        if (vmStaticFromDb != null) {
            Cluster cluster = getClusterDao().get(vmStaticFromDb.getClusterId());
            if (cluster != null) {
                vm.setStoragePoolId(cluster.getStoragePoolId());
                vm.setClusterCompatibilityVersion(cluster.getCompatibilityVersion());
                vm.setClusterName(cluster.getName());
                vm.setClusterCpuName(cluster.getCpuName());
            }
        }
        // if the required dedicated host is invalid -> use current VM dedicated host
        if (!VmHandler.validateDedicatedVdsExistOnSameCluster(vm.getStaticData(), null)) {
            vm.setDedicatedVmForVdsList(oldVmStatic.getDedicatedVmForVdsList());
        }
        validateQuota(vm);
        return true;
    } catch (OvfReaderException e) {
        log.error("Failed to update VM from the configuration '{}': {}", configuration, e.getMessage());
        log.debug("Exception", e);
        return false;
    }
}
#end_block

#method_before
public ArrayList<DiskImage> getVmImagesFromDb(VM vm) {
    ArrayList<DiskImage> allVmImages = new ArrayList<>();
    List<DiskImage> filteredDisks = DisksFilter.filterImageDisks(vm.getDiskList(), SNAPABLE_DISKS_ONLY, ACTIVE_DISKS_ONLY);
    for (DiskImage diskImage : filteredDisks) {
        allVmImages.addAll(getAllImageSnapshots(diskImage));
    }
    for (DiskImage disk : allVmImages) {
        DiskVmElement dve = DbFacade.getInstance().getDiskVmElementDao().get(new VmDeviceId(disk.getId(), vm.getId()));
        disk.setDiskVmElements(Collections.singletonList(dve));
    }
    return allVmImages;
}
#method_after
public ArrayList<DiskImage> getVmImagesFromDb(VM vm) {
    ArrayList<DiskImage> allVmImages = new ArrayList<>();
    List<DiskImage> filteredDisks = DisksFilter.filterImageDisks(vm.getDiskList(), ONLY_SNAPABLE, ONLY_ACTIVE);
    for (DiskImage diskImage : filteredDisks) {
        allVmImages.addAll(getAllImageSnapshots(diskImage));
    }
    for (DiskImage disk : allVmImages) {
        DiskVmElement dve = DbFacade.getInstance().getDiskVmElementDao().get(new VmDeviceId(disk.getId(), vm.getId()));
        disk.setDiskVmElements(Collections.singletonList(dve));
    }
    return allVmImages;
}
#end_block

#method_before
private List<DiskImage> getDiskImages(List<Disk> disks) {
    if (cachedImagesDisks == null) {
        cachedImagesDisks = DisksFilter.filterImageDisks(disks, NOT_SHAREABLE_DISKS_ONLY, SNAPABLE_DISKS_ONLY, ACTIVE_DISKS_ONLY);
    }
    return cachedImagesDisks;
}
#method_after
private List<DiskImage> getDiskImages(List<Disk> disks) {
    if (cachedImagesDisks == null) {
        cachedImagesDisks = DisksFilter.filterImageDisks(disks, ONLY_NOT_SHAREABLE, ONLY_SNAPABLE, ONLY_ACTIVE);
    }
    return cachedImagesDisks;
}
#end_block

#method_before
private SnapshotVDSCommandParameters buildLiveSnapshotParameters(Snapshot snapshot) {
    List<Disk> pluggedDisksForVm = getDiskDao().getAllForVm(getVm().getId(), true);
    List<DiskImage> filteredPluggedDisksForVm = DisksFilter.filterImageDisks(pluggedDisksForVm, SNAPABLE_DISKS_ONLY, ACTIVE_DISKS_ONLY);
    // 'filteredPluggedDisks' should contain only disks from 'getDisksList()' that are plugged to the VM.
    List<DiskImage> filteredPluggedDisks = ImagesHandler.imagesIntersection(filteredPluggedDisksForVm, getDisksList());
    SnapshotVDSCommandParameters parameters = new SnapshotVDSCommandParameters(getVm().getRunOnVds(), getVm().getId(), filteredPluggedDisks);
    if (isMemorySnapshotSupported()) {
        parameters.setMemoryVolume(snapshot.getMemoryVolume());
    }
    parameters.setVmFrozen(shouldFreezeOrThawVm());
    return parameters;
}
#method_after
private SnapshotVDSCommandParameters buildLiveSnapshotParameters(Snapshot snapshot) {
    List<Disk> pluggedDisksForVm = getDiskDao().getAllForVm(getVm().getId(), true);
    List<DiskImage> filteredPluggedDisksForVm = DisksFilter.filterImageDisks(pluggedDisksForVm, ONLY_SNAPABLE, ONLY_ACTIVE);
    // 'filteredPluggedDisks' should contain only disks from 'getDisksList()' that are plugged to the VM.
    List<DiskImage> filteredPluggedDisks = ImagesHandler.imagesIntersection(filteredPluggedDisksForVm, getDisksList());
    SnapshotVDSCommandParameters parameters = new SnapshotVDSCommandParameters(getVm().getRunOnVds(), getVm().getId(), filteredPluggedDisks);
    if (isMemorySnapshotSupported()) {
        parameters.setMemoryVolume(snapshot.getMemoryVolume());
    }
    parameters.setVmFrozen(shouldFreezeOrThawVm());
    return parameters;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVm() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!isSpecifiedDisksExist(getParameters().getDisks())) {
        return false;
    }
    // Initialize validators.
    VmValidator vmValidator = createVmValidator();
    SnapshotsValidator snapshotValidator = createSnapshotValidator();
    StoragePoolValidator spValidator = createStoragePoolValidator();
    DiskImagesValidator diskImagesValidatorForChain = createDiskImageValidator(DisksFilter.filterImageDisks(getDisksList(), NOT_SHAREABLE_DISKS_ONLY, SNAPABLE_DISKS_ONLY, ACTIVE_DISKS_ONLY));
    if (!(validateVM(vmValidator) && validate(spValidator.isUp()) && validate(vmValidator.vmNotIlegal()) && validate(vmValidator.vmNotLocked()) && validate(snapshotValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotValidator.vmNotInPreview(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()) && validate(diskImagesValidatorForChain.diskImagesHaveNotExceededMaxNumberOfVolumesInImageChain()) && (!getParameters().isSaveMemory() || validate(vmValidator.vmNotHavingPciPassthroughDevices())))) {
        return false;
    }
    List<DiskImage> disksList = getDisksListForChecks();
    if (disksList.size() > 0) {
        DiskImagesValidator diskImagesValidator = createDiskImageValidator(disksList);
        if (!(validate(diskImagesValidator.diskImagesNotLocked()) && validate(diskImagesValidator.diskImagesNotIllegal()))) {
            return false;
        }
    }
    return validateStorage();
}
#method_after
@Override
protected boolean validate() {
    if (getVm() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!isSpecifiedDisksExist(getParameters().getDisks())) {
        return false;
    }
    // Initialize validators.
    VmValidator vmValidator = createVmValidator();
    SnapshotsValidator snapshotValidator = createSnapshotValidator();
    StoragePoolValidator spValidator = createStoragePoolValidator();
    DiskImagesValidator diskImagesValidatorForChain = createDiskImageValidator(DisksFilter.filterImageDisks(getDisksList(), ONLY_NOT_SHAREABLE, ONLY_SNAPABLE, ONLY_ACTIVE));
    if (!(validateVM(vmValidator) && validate(spValidator.isUp()) && validate(vmValidator.vmNotIlegal()) && validate(vmValidator.vmNotLocked()) && validate(snapshotValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotValidator.vmNotInPreview(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()) && validate(diskImagesValidatorForChain.diskImagesHaveNotExceededMaxNumberOfVolumesInImageChain()) && (!getParameters().isSaveMemory() || validate(vmValidator.vmNotHavingPciPassthroughDevices())))) {
        return false;
    }
    List<DiskImage> disksList = getDisksListForChecks();
    if (disksList.size() > 0) {
        DiskImagesValidator diskImagesValidator = createDiskImageValidator(disksList);
        if (!(validate(diskImagesValidator.diskImagesNotLocked()) && validate(diskImagesValidator.diskImagesNotIllegal()))) {
            return false;
        }
    }
    return validateStorage();
}
#end_block

#method_before
@Override
protected boolean validate() {
    macPool = getMacPool();
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && getVmStaticDao().get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(Injector.get(InClusterUpgradeValidator.class).isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    macPool = getMacPool();
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && getVmStaticDao().get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    if (diskInfoDestinationMap != null && !diskInfoDestinationMap.isEmpty()) {
        Map<DiskImage, Guid> map = new HashMap<>();
        List<DiskImage> diskImages = DisksFilter.filterImageDisks(diskInfoDestinationMap.values(), NOT_SHAREABLE_DISKS_ONLY, ACTIVE_DISKS_ONLY);
        for (DiskImage diskImage : diskImages) {
            map.put(diskImage, diskImage.getStorageIds().get(0));
        }
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getCurrentUser()));
    }
    return true;
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    if (diskInfoDestinationMap != null && !diskInfoDestinationMap.isEmpty()) {
        Map<DiskImage, Guid> map = new HashMap<>();
        List<DiskImage> diskImages = DisksFilter.filterImageDisks(diskInfoDestinationMap.values(), ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
        for (DiskImage diskImage : diskImages) {
            map.put(diskImage, diskImage.getStorageIds().get(0));
        }
        return validate(diskProfileHelper.setAndValidateDiskProfiles(map, getCurrentUser()));
    }
    return true;
}
#end_block

#method_before
protected boolean addVmImages() {
    if (!vmDisksSource.getDiskTemplateMap().isEmpty()) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        lockVM();
        Collection<DiskImage> templateDisks = getImagesToCheckDestinationStorageDomains();
        List<DiskImage> diskImages = DisksFilter.filterImageDisks(templateDisks, NOT_SHAREABLE_DISKS_ONLY, ACTIVE_DISKS_ONLY);
        for (DiskImage image : diskImages) {
            VdcReturnValueBase result = runInternalActionWithTasksContext(getDiskCreationCommandType(), buildDiskCreationParameters(image));
            // if couldn't create snapshot then stop the transaction and the command
            if (!result.getSucceeded()) {
                throw new EngineException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(image.getId(), newImage.getId());
            }
        }
        // Clone volumes for Cinder disk templates
        addVmCinderDisks(templateDisks);
    }
    return true;
}
#method_after
protected boolean addVmImages() {
    if (!vmDisksSource.getDiskTemplateMap().isEmpty()) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        lockVM();
        Collection<DiskImage> templateDisks = getImagesToCheckDestinationStorageDomains();
        List<DiskImage> diskImages = DisksFilter.filterImageDisks(templateDisks, ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
        for (DiskImage image : diskImages) {
            VdcReturnValueBase result = runInternalActionWithTasksContext(getDiskCreationCommandType(), buildDiskCreationParameters(image));
            // if couldn't create snapshot then stop the transaction and the command
            if (!result.getSucceeded()) {
                throw new EngineException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(image.getId(), newImage.getId());
            }
        }
        // Clone volumes for Cinder disk templates
        addVmCinderDisks(templateDisks);
    }
    return true;
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    if (diskInfoDestinationMap != null && !diskInfoDestinationMap.isEmpty()) {
        Map<DiskImage, Guid> map = new HashMap<>();
        for (DiskImage diskImage : diskInfoDestinationMap.values()) {
            if (diskImage.getDiskStorageType() == DiskStorageType.IMAGE) {
                map.put(diskImage, diskImage.getStorageIds().get(0));
            }
        }
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getCurrentUser()));
    }
    return true;
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    if (diskInfoDestinationMap != null && !diskInfoDestinationMap.isEmpty()) {
        Map<DiskImage, Guid> map = new HashMap<>();
        for (DiskImage diskImage : diskInfoDestinationMap.values()) {
            if (diskImage.getDiskStorageType() == DiskStorageType.IMAGE) {
                map.put(diskImage, diskImage.getStorageIds().get(0));
            }
        }
        return validate(diskProfileHelper.setAndValidateDiskProfiles(map, getCurrentUser()));
    }
    return true;
}
#end_block

#method_before
protected boolean imagesRelatedChecks() {
    // images related checks
    if (!images.isEmpty()) {
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<CinderDisk> cinderDisks = getCinderDisks();
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
        if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = DisksFilter.filterImageDisks(images, NOT_SHAREABLE_DISKS_ONLY, ACTIVE_DISKS_ONLY);
        diskImagesToCheck.addAll(cinderDisks);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = getStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                    addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
                } else {
                    addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
                return false;
            }
            if (storage.getStorageDomainType().isIsoOrImportExportDomain()) {
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
        }
        return validateSpaceRequirements();
    }
    return true;
}
#method_after
protected boolean imagesRelatedChecks() {
    // images related checks
    if (!images.isEmpty()) {
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<CinderDisk> cinderDisks = getCinderDisks();
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
        if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = DisksFilter.filterImageDisks(images, ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
        diskImagesToCheck.addAll(cinderDisks);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = getStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                    addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
                } else {
                    addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
                return false;
            }
            if (storage.getStorageDomainType().isIsoOrImportExportDomain()) {
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
        }
        return validateSpaceRequirements();
    }
    return true;
}
#end_block

#method_before
protected boolean validateSpaceRequirements() {
    // update vm snapshots for storage free space check
    ImagesHandler.fillImagesBySnapshots(getVm());
    List<DiskImage> disksList = DisksFilter.filterImageDisks(getVm().getDiskMap().values(), NOT_SHAREABLE_DISKS_ONLY, ACTIVE_DISKS_ONLY);
    List<DiskImage> disksListForStorageChecks = createDiskDummiesForSpaceValidations(disksList);
    MultipleStorageDomainsValidator multipleSdValidator = getStorageDomainsValidator(getVm().getStoragePoolId(), getStorageGuidSet());
    return validate(multipleSdValidator.allDomainsWithinThresholds()) && validate(multipleSdValidator.allDomainsHaveSpaceForClonedDisks(disksListForStorageChecks));
}
#method_after
protected boolean validateSpaceRequirements() {
    // update vm snapshots for storage free space check
    ImagesHandler.fillImagesBySnapshots(getVm());
    List<DiskImage> disksList = DisksFilter.filterImageDisks(getVm().getDiskMap().values(), ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
    List<DiskImage> disksListForStorageChecks = createDiskDummiesForSpaceValidations(disksList);
    MultipleStorageDomainsValidator multipleSdValidator = getStorageDomainsValidator(getVm().getStoragePoolId(), getStorageGuidSet());
    return validate(multipleSdValidator.allDomainsWithinThresholds()) && validate(multipleSdValidator.allDomainsHaveSpaceForClonedDisks(disksListForStorageChecks));
}
#end_block

#method_before
protected void addVmTemplateImages(Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping) {
    List<DiskImage> diskImages = DisksFilter.filterImageDisks(images, NOT_SHAREABLE_DISKS_ONLY, ACTIVE_DISKS_ONLY);
    for (DiskImage diskImage : diskImages) {
        addVmTemplateImage(srcDeviceIdToTargetDeviceIdMapping, diskImage);
    }
}
#method_after
protected void addVmTemplateImages(Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping) {
    List<DiskImage> diskImages = DisksFilter.filterImageDisks(images, ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
    for (DiskImage diskImage : diskImages) {
        addVmTemplateImage(srcDeviceIdToTargetDeviceIdMapping, diskImage);
    }
}
#end_block

#method_before
protected boolean setAndValidateCpuProfile() {
    // cpu profile isn't supported for instance types.
    if (getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE) {
        return true;
    }
    return validate(CpuProfileHelper.setAndValidateCpuProfile(getParameters().getMasterVm()));
}
#method_after
protected boolean setAndValidateCpuProfile() {
    // cpu profile isn't supported for instance types.
    if (getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE) {
        return true;
    }
    return validate(cpuProfileHelper.setAndValidateCpuProfile(getParameters().getMasterVm(), getUserId()));
}
#end_block

#method_before
private List<DiskImage> getImageTemplates() {
    if (imageTemplates == null) {
        List<Disk> allImages = DbFacade.getInstance().getDiskDao().getAllForVm(getVmTemplateId());
        imageTemplates = DisksFilter.filterImageDisks(allImages, ACTIVE_DISKS_ONLY);
        imageTemplates.addAll(ImagesHandler.filterDisksBasedOnCinder(allImages, true));
    }
    return imageTemplates;
}
#method_after
private List<DiskImage> getImageTemplates() {
    if (imageTemplates == null) {
        List<Disk> allImages = DbFacade.getInstance().getDiskDao().getAllForVm(getVmTemplateId());
        imageTemplates = DisksFilter.filterImageDisks(allImages, ONLY_ACTIVE);
        imageTemplates.addAll(ImagesHandler.filterDisksBasedOnCinder(allImages, true));
    }
    return imageTemplates;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getVmTemplate().isBaseTemplate()) {
        shiftBaseTemplateToSuccessor();
    }
    List<Disk> templateImages = DbFacade.getInstance().getDiskDao().getAllForVm(getVmTemplateId());
    final List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(templateImages);
    final List<DiskImage> diskImages = DisksFilter.filterImageDisks(templateImages, ACTIVE_DISKS_ONLY);
    // Set VM to lock status immediately, for reducing race condition.
    VmTemplateHandler.lockVmTemplateInTransaction(getVmTemplateId(), getCompensationContext());
    if (!diskImages.isEmpty() || !cinderDisks.isEmpty()) {
        TransactionSupport.executeInNewTransaction(() -> {
            if (!diskImages.isEmpty() && removeVmTemplateImages()) {
                VmHandler.removeVmInitFromDB(getVmTemplate());
                setSucceeded(true);
            }
            if (!cinderDisks.isEmpty()) {
                removeCinderDisks(cinderDisks);
                setSucceeded(true);
            }
            return null;
        });
    }
    // if for some reason template doesn't have images, remove it now and not in end action
    if (noAsyncOperations()) {
        handleEndAction();
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getVmTemplate().isBaseTemplate()) {
        shiftBaseTemplateToSuccessor();
    }
    List<Disk> templateImages = DbFacade.getInstance().getDiskDao().getAllForVm(getVmTemplateId());
    final List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(templateImages);
    final List<DiskImage> diskImages = DisksFilter.filterImageDisks(templateImages, ONLY_ACTIVE);
    // Set VM to lock status immediately, for reducing race condition.
    VmTemplateHandler.lockVmTemplateInTransaction(getVmTemplateId(), getCompensationContext());
    if (!diskImages.isEmpty() || !cinderDisks.isEmpty()) {
        TransactionSupport.executeInNewTransaction(() -> {
            if (!diskImages.isEmpty() && removeVmTemplateImages()) {
                VmHandler.removeVmInitFromDB(getVmTemplate());
                setSucceeded(true);
            }
            if (!cinderDisks.isEmpty()) {
                removeCinderDisks(cinderDisks);
                setSucceeded(true);
            }
            return null;
        });
    }
    // if for some reason template doesn't have images, remove it now and not in end action
    if (noAsyncOperations()) {
        handleEndAction();
    }
}
#end_block

#method_before
@Override
protected Collection<DiskImage> getAdjustedDiskImagesFromConfiguration() {
    VdcQueryReturnValue vdcReturnValue = runInternalQuery(VdcQueryType.GetAllDisksByVmId, new IdQueryParameters(oldVmId));
    List<Disk> loadedImages = vdcReturnValue.getReturnValue() != null ? (List<Disk>) vdcReturnValue.getReturnValue() : new ArrayList<>();
    if (diskImagesFromConfiguration == null) {
        diskImagesFromConfiguration = DisksFilter.filterImageDisks(loadedImages, SNAPABLE_DISKS_ONLY, ACTIVE_DISKS_ONLY);
        diskImagesFromConfiguration.addAll(ImagesHandler.filterDisksBasedOnCinder(loadedImages, true));
    }
    return diskImagesFromConfiguration;
}
#method_after
@Override
protected Collection<DiskImage> getAdjustedDiskImagesFromConfiguration() {
    VdcQueryReturnValue vdcReturnValue = runInternalQuery(VdcQueryType.GetAllDisksByVmId, new IdQueryParameters(oldVmId));
    List<Disk> loadedImages = vdcReturnValue.getReturnValue() != null ? (List<Disk>) vdcReturnValue.getReturnValue() : new ArrayList<>();
    if (diskImagesFromConfiguration == null) {
        diskImagesFromConfiguration = DisksFilter.filterImageDisks(loadedImages, ONLY_SNAPABLE, ONLY_ACTIVE);
        diskImagesFromConfiguration.addAll(ImagesHandler.filterDisksBasedOnCinder(loadedImages, true));
    }
    return diskImagesFromConfiguration;
}
#end_block

#method_before
public boolean isNonPrestartedVmFree(Guid vmId, ErrorProcessor errorProcessor) {
    List<String> messages = new ArrayList<>();
    // check that there is no user already attached to this VM
    if (vmAssignedToUser(vmId, messages)) {
        return failVmFree(errorProcessor, vmId, messages);
    }
    // check that VN can be run
    if (!canRunPoolVm(vmId, messages)) {
        return failVmFree(errorProcessor, vmId, messages);
    }
    // check VM images
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    ValidationResult vmDuringSnapshotResult = snapshotsValidator.vmNotDuringSnapshot(vmId);
    if (!vmDuringSnapshotResult.isValid()) {
        return failVmFree(errorProcessor, vmId, vmDuringSnapshotResult.getMessagesAsStrings());
    }
    ValidationResult vmInPreviewResult = snapshotsValidator.vmNotInPreview(vmId);
    if (!vmInPreviewResult.isValid()) {
        return failVmFree(errorProcessor, vmId, vmInPreviewResult.getMessagesAsStrings());
    }
    List<Disk> disks = diskDao.getAllForVm(vmId);
    List<DiskImage> vmImages = DisksFilter.filterImageDisks(disks, NOT_SHAREABLE_DISKS_ONLY, SNAPABLE_DISKS_ONLY);
    VM vm = vmDao.get(vmId);
    StoragePool sp = storagePoolDao.get(vm.getStoragePoolId());
    ValidationResult spUpResult = new StoragePoolValidator(sp).isUp();
    if (!spUpResult.isValid()) {
        return failVmFree(errorProcessor, vmId, spUpResult.getMessagesAsStrings());
    }
    Guid storageDomainId = vmImages.size() > 0 ? vmImages.get(0).getStorageIds().get(0) : Guid.Empty;
    if (!Guid.Empty.equals(storageDomainId)) {
        StorageDomainValidator storageDomainValidator = new StorageDomainValidator(storageDomainDao.getForStoragePool(storageDomainId, sp.getId()));
        ValidationResult domainActiveResult = storageDomainValidator.isDomainExistAndActive();
        if (!domainActiveResult.isValid()) {
            return failVmFree(errorProcessor, vmId, domainActiveResult.getMessagesAsStrings());
        }
    }
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(vmImages);
    ValidationResult disksNotLockedResult = diskImagesValidator.diskImagesNotLocked();
    if (!disksNotLockedResult.isValid()) {
        messages.addAll(disksNotLockedResult.getMessagesAsStrings());
        messages.addAll(disksNotLockedResult.getVariableReplacements());
        return failVmFree(errorProcessor, vmId, messages);
    }
    ValidationResult vmNotLockResult = new VmValidator(vm).vmNotLocked();
    if (!vmNotLockResult.isValid()) {
        return failVmFree(errorProcessor, vmId, vmNotLockResult.getMessagesAsStrings());
    }
    return true;
}
#method_after
public boolean isNonPrestartedVmFree(Guid vmId, ErrorProcessor errorProcessor) {
    List<String> messages = new ArrayList<>();
    // check that there is no user already attached to this VM
    if (vmAssignedToUser(vmId, messages)) {
        return failVmFree(errorProcessor, vmId, messages);
    }
    // check that VN can be run
    if (!canRunPoolVm(vmId, messages)) {
        return failVmFree(errorProcessor, vmId, messages);
    }
    // check VM images
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    ValidationResult vmDuringSnapshotResult = snapshotsValidator.vmNotDuringSnapshot(vmId);
    if (!vmDuringSnapshotResult.isValid()) {
        return failVmFree(errorProcessor, vmId, vmDuringSnapshotResult.getMessagesAsStrings());
    }
    ValidationResult vmInPreviewResult = snapshotsValidator.vmNotInPreview(vmId);
    if (!vmInPreviewResult.isValid()) {
        return failVmFree(errorProcessor, vmId, vmInPreviewResult.getMessagesAsStrings());
    }
    List<Disk> disks = diskDao.getAllForVm(vmId);
    List<DiskImage> vmImages = DisksFilter.filterImageDisks(disks, ONLY_NOT_SHAREABLE, ONLY_SNAPABLE);
    VM vm = vmDao.get(vmId);
    StoragePool sp = storagePoolDao.get(vm.getStoragePoolId());
    ValidationResult spUpResult = new StoragePoolValidator(sp).isUp();
    if (!spUpResult.isValid()) {
        return failVmFree(errorProcessor, vmId, spUpResult.getMessagesAsStrings());
    }
    Guid storageDomainId = vmImages.size() > 0 ? vmImages.get(0).getStorageIds().get(0) : Guid.Empty;
    if (!Guid.Empty.equals(storageDomainId)) {
        StorageDomainValidator storageDomainValidator = new StorageDomainValidator(storageDomainDao.getForStoragePool(storageDomainId, sp.getId()));
        ValidationResult domainActiveResult = storageDomainValidator.isDomainExistAndActive();
        if (!domainActiveResult.isValid()) {
            return failVmFree(errorProcessor, vmId, domainActiveResult.getMessagesAsStrings());
        }
    }
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(vmImages);
    ValidationResult disksNotLockedResult = diskImagesValidator.diskImagesNotLocked();
    if (!disksNotLockedResult.isValid()) {
        messages.addAll(disksNotLockedResult.getMessagesAsStrings());
        messages.addAll(disksNotLockedResult.getVariableReplacements());
        return failVmFree(errorProcessor, vmId, messages);
    }
    ValidationResult vmNotLockResult = new VmValidator(vm).vmNotLocked();
    if (!vmNotLockResult.isValid()) {
        return failVmFree(errorProcessor, vmId, vmNotLockResult.getMessagesAsStrings());
    }
    return true;
}
#end_block

#method_before
private List<DiskImage> getDisksBasedOnImage() {
    if (disksImages == null) {
        disksImages = DisksFilter.filterImageDisks(getVm().getDiskMap().values(), SNAPABLE_DISKS_ONLY, ACTIVE_DISKS_ONLY);
    }
    return disksImages;
}
#method_after
private List<DiskImage> getDisksBasedOnImage() {
    if (disksImages == null) {
        disksImages = DisksFilter.filterImageDisks(getVm().getDiskMap().values(), ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
    }
    return disksImages;
}
#end_block

